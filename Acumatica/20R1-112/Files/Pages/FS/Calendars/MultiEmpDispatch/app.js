var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = false;
$jscomp.ASSUME_NO_NATIVE_MAP = false;
$jscomp.ASSUME_NO_NATIVE_SET = false;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || typeof Object.defineProperties == 'function' ? Object.defineProperty : function(target, property, descriptor) {
  descriptor = descriptor;
  if (target == Array.prototype || target == Object.prototype) {
    return;
  }
  target[property] = descriptor.value;
};
$jscomp.getGlobal = function(maybeGlobal) {
  return typeof window != 'undefined' && window === maybeGlobal ? maybeGlobal : typeof global != 'undefined' && global != null ? global : maybeGlobal;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function(target, polyfill, fromLang, toLang) {
  if (!polyfill) {
    return;
  }
  var obj = $jscomp.global;
  var split = target.split('.');
  for (var i = 0; i < split.length - 1; i++) {
    var key = split[i];
    if (!(key in obj)) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  var property = split[split.length - 1];
  var orig = obj[property];
  var impl = polyfill(orig);
  if (impl == orig || impl == null) {
    return;
  }
  $jscomp.defineProperty(obj, property, {configurable:true, writable:true, value:impl});
};
$jscomp.polyfill('Array.prototype.copyWithin', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, start, opt_end) {
    var len = this.length;
    target = Number(target);
    start = Number(start);
    opt_end = Number(opt_end != null ? opt_end : len);
    if (target < start) {
      opt_end = Math.min(opt_end, len);
      while (start < opt_end) {
        if (start in this) {
          this[target++] = this[start++];
        } else {
          delete this[target++];
          start++;
        }
      }
    } else {
      opt_end = Math.min(opt_end, len + start - target);
      target += opt_end - start;
      while (opt_end > start) {
        if (--opt_end in this) {
          this[--target] = this[opt_end];
        } else {
          delete this[target];
        }
      }
    }
    return this;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.SYMBOL_PREFIX = 'jscomp_symbol_';
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  if (!$jscomp.global['Symbol']) {
    $jscomp.global['Symbol'] = $jscomp.Symbol;
  }
};
$jscomp.Symbol = function() {
  var counter = 0;
  function Symbol(opt_description) {
    return $jscomp.SYMBOL_PREFIX + (opt_description || '') + counter++;
  }
  return Symbol;
}();
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var symbolIterator = $jscomp.global['Symbol'].iterator;
  if (!symbolIterator) {
    symbolIterator = $jscomp.global['Symbol'].iterator = $jscomp.global['Symbol']('iterator');
  }
  if (typeof Array.prototype[symbolIterator] != 'function') {
    $jscomp.defineProperty(Array.prototype, symbolIterator, {configurable:true, writable:true, value:function() {
      return $jscomp.arrayIterator(this);
    }});
  }
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.arrayIterator = function(array) {
  var index = 0;
  return $jscomp.iteratorPrototype(function() {
    if (index < array.length) {
      return {done:false, value:array[index++]};
    } else {
      return {done:true};
    }
  });
};
$jscomp.iteratorPrototype = function(next) {
  $jscomp.initSymbolIterator();
  var iterator = {next:next};
  iterator[$jscomp.global['Symbol'].iterator] = function() {
    return this;
  };
  return iterator;
};
$jscomp.iteratorFromArray = function(array, transform) {
  $jscomp.initSymbolIterator();
  if (array instanceof String) {
    array = array + '';
  }
  var i = 0;
  var iter = {next:function() {
    if (i < array.length) {
      var index = i++;
      return {value:transform(index, array[index]), done:false};
    }
    iter.next = function() {
      return {done:true, value:void 0};
    };
    return iter.next();
  }};
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  iter[Symbol.iterator] = function() {
    return iter;
  };
  return iter;
};
$jscomp.polyfill('Array.prototype.entries', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(i, v) {
      return [i, v];
    });
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.fill', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(value, opt_start, opt_end) {
    var length = this.length || 0;
    if (opt_start < 0) {
      opt_start = Math.max(0, length + opt_start);
    }
    if (opt_end == null || opt_end > length) {
      opt_end = length;
    }
    opt_end = Number(opt_end);
    if (opt_end < 0) {
      opt_end = Math.max(0, length + opt_end);
    }
    for (var i = Number(opt_start || 0); i < opt_end; i++) {
      this[i] = value;
    }
    return this;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.findInternal = function(array, callback, thisArg) {
  if (array instanceof String) {
    array = String(array);
  }
  var len = array.length;
  for (var i = 0; i < len; i++) {
    var value = array[i];
    if (callback.call(thisArg, value, i, array)) {
      return {i:i, v:value};
    }
  }
  return {i:-1, v:void 0};
};
$jscomp.polyfill('Array.prototype.find', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(callback, opt_thisArg) {
    return $jscomp.findInternal(this, callback, opt_thisArg).v;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.findIndex', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(callback, opt_thisArg) {
    return $jscomp.findInternal(this, callback, opt_thisArg).i;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.from', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(arrayLike, opt_mapFn, opt_thisArg) {
    $jscomp.initSymbolIterator();
    opt_mapFn = opt_mapFn != null ? opt_mapFn : function(x) {
      return x;
    };
    var result = [];
    $jscomp.initSymbol();
    $jscomp.initSymbolIterator();
    var iteratorFunction = arrayLike[Symbol.iterator];
    if (typeof iteratorFunction == 'function') {
      arrayLike = iteratorFunction.call(arrayLike);
      var next;
      while (!(next = arrayLike.next()).done) {
        result.push(opt_mapFn.call(opt_thisArg, next.value));
      }
    } else {
      var len = arrayLike.length;
      for (var i = 0; i < len; i++) {
        result.push(opt_mapFn.call(opt_thisArg, arrayLike[i]));
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Object.is', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(left, right) {
    if (left === right) {
      return left !== 0 || 1 / left === 1 / right;
    } else {
      return left !== left && right !== right;
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.includes', function(orig) {
  if (orig) {
    return orig;
  }
  var includes = function(searchElement, opt_fromIndex) {
    var array = this;
    if (array instanceof String) {
      array = String(array);
    }
    var len = array.length;
    for (var i = opt_fromIndex || 0; i < len; i++) {
      if (array[i] == searchElement || Object.is(array[i], searchElement)) {
        return true;
      }
    }
    return false;
  };
  return includes;
}, 'es7', 'es3');
$jscomp.polyfill('Array.prototype.keys', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(i) {
      return i;
    });
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.of', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(var_args) {
    return Array.from(arguments);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.values', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(k, v) {
      return v;
    });
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.makeIterator = function(iterable) {
  $jscomp.initSymbolIterator();
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var iteratorFunction = iterable[Symbol.iterator];
  return iteratorFunction ? iteratorFunction.call(iterable) : $jscomp.arrayIterator(iterable);
};
$jscomp.FORCE_POLYFILL_PROMISE = false;
$jscomp.polyfill('Promise', function(NativePromise) {
  if (NativePromise && !$jscomp.FORCE_POLYFILL_PROMISE) {
    return NativePromise;
  }
  function AsyncExecutor() {
    this.batch_ = null;
  }
  AsyncExecutor.prototype.asyncExecute = function(f) {
    if (this.batch_ == null) {
      this.batch_ = [];
      this.asyncExecuteBatch_();
    }
    this.batch_.push(f);
    return this;
  };
  AsyncExecutor.prototype.asyncExecuteBatch_ = function() {
    var self = this;
    this.asyncExecuteFunction(function() {
      self.executeBatch_();
    });
  };
  var nativeSetTimeout = $jscomp.global['setTimeout'];
  AsyncExecutor.prototype.asyncExecuteFunction = function(f) {
    nativeSetTimeout(f, 0);
  };
  AsyncExecutor.prototype.executeBatch_ = function() {
    while (this.batch_ && this.batch_.length) {
      var executingBatch = this.batch_;
      this.batch_ = [];
      for (var i = 0; i < executingBatch.length; ++i) {
        var f = executingBatch[i];
        delete executingBatch[i];
        try {
          f();
        } catch (error) {
          this.asyncThrow_(error);
        }
      }
    }
    this.batch_ = null;
  };
  AsyncExecutor.prototype.asyncThrow_ = function(exception) {
    this.asyncExecuteFunction(function() {
      throw exception;
    });
  };
  var PromiseState = {PENDING:0, FULFILLED:1, REJECTED:2};
  var PolyfillPromise = function(executor) {
    this.state_ = PromiseState.PENDING;
    this.result_ = undefined;
    this.onSettledCallbacks_ = [];
    var resolveAndReject = this.createResolveAndReject_();
    try {
      executor(resolveAndReject.resolve, resolveAndReject.reject);
    } catch (e) {
      resolveAndReject.reject(e);
    }
  };
  PolyfillPromise.prototype.createResolveAndReject_ = function() {
    var thisPromise = this;
    var alreadyCalled = false;
    function firstCallWins(method) {
      return function(x) {
        if (!alreadyCalled) {
          alreadyCalled = true;
          method.call(thisPromise, x);
        }
      };
    }
    return {resolve:firstCallWins(this.resolveTo_), reject:firstCallWins(this.reject_)};
  };
  PolyfillPromise.prototype.resolveTo_ = function(value) {
    if (value === this) {
      this.reject_(new TypeError('A Promise cannot resolve to itself'));
    } else {
      if (value instanceof PolyfillPromise) {
        this.settleSameAsPromise_(value);
      } else {
        if (isObject(value)) {
          this.resolveToNonPromiseObj_(value);
        } else {
          this.fulfill_(value);
        }
      }
    }
  };
  PolyfillPromise.prototype.resolveToNonPromiseObj_ = function(obj) {
    var thenMethod = undefined;
    try {
      thenMethod = obj.then;
    } catch (error) {
      this.reject_(error);
      return;
    }
    if (typeof thenMethod == 'function') {
      this.settleSameAsThenable_(thenMethod, obj);
    } else {
      this.fulfill_(obj);
    }
  };
  function isObject(value) {
    switch(typeof value) {
      case 'object':
        return value != null;
      case 'function':
        return true;
      default:
        return false;
    }
  }
  PolyfillPromise.prototype.reject_ = function(reason) {
    this.settle_(PromiseState.REJECTED, reason);
  };
  PolyfillPromise.prototype.fulfill_ = function(value) {
    this.settle_(PromiseState.FULFILLED, value);
  };
  PolyfillPromise.prototype.settle_ = function(settledState, valueOrReason) {
    if (this.state_ != PromiseState.PENDING) {
      throw new Error('Cannot settle(' + settledState + ', ' + valueOrReason | '): Promise already settled in state' + this.state_);
    }
    this.state_ = settledState;
    this.result_ = valueOrReason;
    this.executeOnSettledCallbacks_();
  };
  PolyfillPromise.prototype.executeOnSettledCallbacks_ = function() {
    if (this.onSettledCallbacks_ != null) {
      var callbacks = this.onSettledCallbacks_;
      for (var i = 0; i < callbacks.length; ++i) {
        callbacks[i].call();
        callbacks[i] = null;
      }
      this.onSettledCallbacks_ = null;
    }
  };
  var asyncExecutor = new AsyncExecutor;
  PolyfillPromise.prototype.settleSameAsPromise_ = function(promise) {
    var methods = this.createResolveAndReject_();
    promise.callWhenSettled_(methods.resolve, methods.reject);
  };
  PolyfillPromise.prototype.settleSameAsThenable_ = function(thenMethod, thenable) {
    var methods = this.createResolveAndReject_();
    try {
      thenMethod.call(thenable, methods.resolve, methods.reject);
    } catch (error) {
      methods.reject(error);
    }
  };
  PolyfillPromise.prototype.then = function(onFulfilled, onRejected) {
    var resolveChild;
    var rejectChild;
    var childPromise = new PolyfillPromise(function(resolve, reject) {
      resolveChild = resolve;
      rejectChild = reject;
    });
    function createCallback(paramF, defaultF) {
      if (typeof paramF == 'function') {
        return function(x) {
          try {
            resolveChild(paramF(x));
          } catch (error) {
            rejectChild(error);
          }
        };
      } else {
        return defaultF;
      }
    }
    this.callWhenSettled_(createCallback(onFulfilled, resolveChild), createCallback(onRejected, rejectChild));
    return childPromise;
  };
  PolyfillPromise.prototype['catch'] = function(onRejected) {
    return this.then(undefined, onRejected);
  };
  PolyfillPromise.prototype.callWhenSettled_ = function(onFulfilled, onRejected) {
    var thisPromise = this;
    function callback() {
      switch(thisPromise.state_) {
        case PromiseState.FULFILLED:
          onFulfilled(thisPromise.result_);
          break;
        case PromiseState.REJECTED:
          onRejected(thisPromise.result_);
          break;
        default:
          throw new Error('Unexpected state: ' + thisPromise.state_);
      }
    }
    if (this.onSettledCallbacks_ == null) {
      asyncExecutor.asyncExecute(callback);
    } else {
      this.onSettledCallbacks_.push(function() {
        asyncExecutor.asyncExecute(callback);
      });
    }
  };
  function resolvingPromise(opt_value) {
    if (opt_value instanceof PolyfillPromise) {
      return opt_value;
    } else {
      return new PolyfillPromise(function(resolve, reject) {
        resolve(opt_value);
      });
    }
  }
  PolyfillPromise['resolve'] = resolvingPromise;
  PolyfillPromise['reject'] = function(opt_reason) {
    return new PolyfillPromise(function(resolve, reject) {
      reject(opt_reason);
    });
  };
  PolyfillPromise['race'] = function(thenablesOrValues) {
    return new PolyfillPromise(function(resolve, reject) {
      var iterator = $jscomp.makeIterator(thenablesOrValues);
      for (var iterRec = iterator.next(); !iterRec.done; iterRec = iterator.next()) {
        resolvingPromise(iterRec.value).callWhenSettled_(resolve, reject);
      }
    });
  };
  PolyfillPromise['all'] = function(thenablesOrValues) {
    var iterator = $jscomp.makeIterator(thenablesOrValues);
    var iterRec = iterator.next();
    if (iterRec.done) {
      return resolvingPromise([]);
    } else {
      return new PolyfillPromise(function(resolveAll, rejectAll) {
        var resultsArray = [];
        var unresolvedCount = 0;
        function onFulfilled(i) {
          return function(ithResult) {
            resultsArray[i] = ithResult;
            unresolvedCount--;
            if (unresolvedCount == 0) {
              resolveAll(resultsArray);
            }
          };
        }
        do {
          resultsArray.push(undefined);
          unresolvedCount++;
          resolvingPromise(iterRec.value).callWhenSettled_(onFulfilled(resultsArray.length - 1), rejectAll);
          iterRec = iterator.next();
        } while (!iterRec.done);
      });
    }
  };
  return PolyfillPromise;
}, 'es6', 'es3');
$jscomp.executeAsyncGenerator = function(generator) {
  function passValueToGenerator(value) {
    return generator.next(value);
  }
  function passErrorToGenerator(error) {
    return generator['throw'](error);
  }
  return new Promise(function(resolve, reject) {
    function handleGeneratorRecord(genRec) {
      if (genRec.done) {
        resolve(genRec.value);
      } else {
        Promise.resolve(genRec.value).then(passValueToGenerator, passErrorToGenerator).then(handleGeneratorRecord, reject);
      }
    }
    handleGeneratorRecord(generator.next());
  });
};
$jscomp.owns = function(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};
$jscomp.polyfill('WeakMap', function(NativeWeakMap) {
  function isConformant() {
    if (!NativeWeakMap || !Object.seal) {
      return false;
    }
    try {
      var x = Object.seal({});
      var y = Object.seal({});
      var map = new NativeWeakMap([[x, 2], [y, 3]]);
      if (map.get(x) != 2 || map.get(y) != 3) {
        return false;
      }
      map['delete'](x);
      map.set(y, 4);
      return !map.has(x) && map.get(y) == 4;
    } catch (err) {
      return false;
    }
  }
  if (isConformant()) {
    return NativeWeakMap;
  }
  var prop = '$jscomp_hidden_' + Math.random().toString().substring(2);
  function insert(target) {
    if (!$jscomp.owns(target, prop)) {
      var obj = {};
      $jscomp.defineProperty(target, prop, {value:obj});
    }
  }
  function patch(name) {
    var prev = Object[name];
    if (prev) {
      Object[name] = function(target) {
        insert(target);
        return prev(target);
      };
    }
  }
  patch('freeze');
  patch('preventExtensions');
  patch('seal');
  var index = 0;
  var PolyfillWeakMap = function(opt_iterable) {
    this.id_ = (index += Math.random() + 1).toString();
    if (opt_iterable) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.set(item[0], item[1]);
      }
    }
  };
  PolyfillWeakMap.prototype.set = function(key, value) {
    insert(key);
    if (!$jscomp.owns(key, prop)) {
      throw new Error('WeakMap key fail: ' + key);
    }
    key[prop][this.id_] = value;
    return this;
  };
  PolyfillWeakMap.prototype.get = function(key) {
    return $jscomp.owns(key, prop) ? key[prop][this.id_] : undefined;
  };
  PolyfillWeakMap.prototype.has = function(key) {
    return $jscomp.owns(key, prop) && $jscomp.owns(key[prop], this.id_);
  };
  PolyfillWeakMap.prototype['delete'] = function(key) {
    if (!$jscomp.owns(key, prop) || !$jscomp.owns(key[prop], this.id_)) {
      return false;
    }
    return delete key[prop][this.id_];
  };
  return PolyfillWeakMap;
}, 'es6', 'es3');
$jscomp.MapEntry = function() {
  this.previous;
  this.next;
  this.head;
  this.key;
  this.value;
};
$jscomp.polyfill('Map', function(NativeMap) {
  var isConformant = !$jscomp.ASSUME_NO_NATIVE_MAP && function() {
    if (!NativeMap || !NativeMap.prototype.entries || typeof Object.seal != 'function') {
      return false;
    }
    try {
      NativeMap = NativeMap;
      var key = Object.seal({x:4});
      var map = new NativeMap($jscomp.makeIterator([[key, 's']]));
      if (map.get(key) != 's' || map.size != 1 || map.get({x:4}) || map.set({x:4}, 't') != map || map.size != 2) {
        return false;
      }
      var iter = map.entries();
      var item = iter.next();
      if (item.done || item.value[0] != key || item.value[1] != 's') {
        return false;
      }
      item = iter.next();
      if (item.done || item.value[0].x != 4 || item.value[1] != 't' || !iter.next().done) {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }();
  if (isConformant) {
    return NativeMap;
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var idMap = new WeakMap;
  var PolyfillMap = function(opt_iterable) {
    this.data_ = {};
    this.head_ = createHead();
    this.size = 0;
    if (opt_iterable) {
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.set(item[0], item[1]);
      }
    }
  };
  PolyfillMap.prototype.set = function(key, value) {
    var r = maybeGetEntry(this, key);
    if (!r.list) {
      r.list = this.data_[r.id] = [];
    }
    if (!r.entry) {
      r.entry = {next:this.head_, previous:this.head_.previous, head:this.head_, key:key, value:value};
      r.list.push(r.entry);
      this.head_.previous.next = r.entry;
      this.head_.previous = r.entry;
      this.size++;
    } else {
      r.entry.value = value;
    }
    return this;
  };
  PolyfillMap.prototype['delete'] = function(key) {
    var r = maybeGetEntry(this, key);
    if (r.entry && r.list) {
      r.list.splice(r.index, 1);
      if (!r.list.length) {
        delete this.data_[r.id];
      }
      r.entry.previous.next = r.entry.next;
      r.entry.next.previous = r.entry.previous;
      r.entry.head = null;
      this.size--;
      return true;
    }
    return false;
  };
  PolyfillMap.prototype.clear = function() {
    this.data_ = {};
    this.head_ = this.head_.previous = createHead();
    this.size = 0;
  };
  PolyfillMap.prototype.has = function(key) {
    return !!maybeGetEntry(this, key).entry;
  };
  PolyfillMap.prototype.get = function(key) {
    var entry = maybeGetEntry(this, key).entry;
    return entry && entry.value;
  };
  PolyfillMap.prototype.entries = function() {
    return makeIterator(this, function(entry) {
      return [entry.key, entry.value];
    });
  };
  PolyfillMap.prototype.keys = function() {
    return makeIterator(this, function(entry) {
      return entry.key;
    });
  };
  PolyfillMap.prototype.values = function() {
    return makeIterator(this, function(entry) {
      return entry.value;
    });
  };
  PolyfillMap.prototype.forEach = function(callback, opt_thisArg) {
    var iter = this.entries();
    var item;
    while (!(item = iter.next()).done) {
      var entry = item.value;
      callback.call(opt_thisArg, entry[1], entry[0], this);
    }
  };
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  PolyfillMap.prototype[Symbol.iterator] = PolyfillMap.prototype.entries;
  var maybeGetEntry = function(map, key) {
    var id = getId(key);
    var list = map.data_[id];
    if (list && $jscomp.owns(map.data_, id)) {
      for (var index = 0; index < list.length; index++) {
        var entry = list[index];
        if (key !== key && entry.key !== entry.key || key === entry.key) {
          return {id:id, list:list, index:index, entry:entry};
        }
      }
    }
    return {id:id, list:list, index:-1, entry:undefined};
  };
  var makeIterator = function(map, func) {
    var entry = map.head_;
    return $jscomp.iteratorPrototype(function() {
      if (entry) {
        while (entry.head != map.head_) {
          entry = entry.previous;
        }
        while (entry.next != entry.head) {
          entry = entry.next;
          return {done:false, value:func(entry)};
        }
        entry = null;
      }
      return {done:true, value:void 0};
    });
  };
  var createHead = function() {
    var head = {};
    head.previous = head.next = head.head = head;
    return head;
  };
  var mapIndex = 0;
  var getId = function(obj) {
    var type = obj && typeof obj;
    if (type == 'object' || type == 'function') {
      obj = obj;
      if (!idMap.has(obj)) {
        var id = '' + ++mapIndex;
        idMap.set(obj, id);
        return id;
      }
      return idMap.get(obj);
    }
    return 'p_' + obj;
  };
  return PolyfillMap;
}, 'es6', 'es3');
$jscomp.polyfill('Math.acosh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    return Math.log(x + Math.sqrt(x * x - 1));
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.asinh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    var y = Math.log(Math.abs(x) + Math.sqrt(x * x + 1));
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log1p', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x < 0.25 && x > -0.25) {
      var y = x;
      var d = 1;
      var z = x;
      var zPrev = 0;
      var s = 1;
      while (zPrev != z) {
        y *= x;
        s *= -1;
        z = (zPrev = z) + s * y / ++d;
      }
      return z;
    }
    return Math.log(1 + x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.atanh', function(orig) {
  if (orig) {
    return orig;
  }
  var log1p = Math.log1p;
  var polyfill = function(x) {
    x = Number(x);
    return (log1p(x) - log1p(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.cbrt', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (x === 0) {
      return x;
    }
    x = Number(x);
    var y = Math.pow(Math.abs(x), 1 / 3);
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.clz32', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x) >>> 0;
    if (x === 0) {
      return 32;
    }
    var result = 0;
    if ((x & 4294901760) === 0) {
      x <<= 16;
      result += 16;
    }
    if ((x & 4278190080) === 0) {
      x <<= 8;
      result += 8;
    }
    if ((x & 4026531840) === 0) {
      x <<= 4;
      result += 4;
    }
    if ((x & 3221225472) === 0) {
      x <<= 2;
      result += 2;
    }
    if ((x & 2147483648) === 0) {
      result++;
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.cosh', function(orig) {
  if (orig) {
    return orig;
  }
  var exp = Math.exp;
  var polyfill = function(x) {
    x = Number(x);
    return (exp(x) + exp(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.expm1', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x < .25 && x > -.25) {
      var y = x;
      var d = 1;
      var z = x;
      var zPrev = 0;
      while (zPrev != z) {
        y *= x / ++d;
        z = (zPrev = z) + y;
      }
      return z;
    }
    return Math.exp(x) - 1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.hypot', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x, y, var_args) {
    x = Number(x);
    y = Number(y);
    var i, z, sum;
    var max = Math.max(Math.abs(x), Math.abs(y));
    for (i = 2; i < arguments.length; i++) {
      max = Math.max(max, Math.abs(arguments[i]));
    }
    if (max > 1e100 || max < 1e-100) {
      x = x / max;
      y = y / max;
      sum = x * x + y * y;
      for (i = 2; i < arguments.length; i++) {
        z = Number(arguments[i]) / max;
        sum += z * z;
      }
      return Math.sqrt(sum) * max;
    } else {
      sum = x * x + y * y;
      for (i = 2; i < arguments.length; i++) {
        z = Number(arguments[i]);
        sum += z * z;
      }
      return Math.sqrt(sum);
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.imul', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(a, b) {
    a = Number(a);
    b = Number(b);
    var ah = a >>> 16 & 65535;
    var al = a & 65535;
    var bh = b >>> 16 & 65535;
    var bl = b & 65535;
    var lh = ah * bl + al * bh << 16 >>> 0;
    return al * bl + lh | 0;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log10', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Math.log(x) / Math.LN10;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log2', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Math.log(x) / Math.LN2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.sign', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    return x === 0 || isNaN(x) ? x : x > 0 ? 1 : -1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.sinh', function(orig) {
  if (orig) {
    return orig;
  }
  var exp = Math.exp;
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    return (exp(x) - exp(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.tanh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    var y = Math.exp(-2 * Math.abs(x));
    var z = (1 - y) / (1 + y);
    return x < 0 ? -z : z;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.trunc', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (isNaN(x) || x === Infinity || x === -Infinity || x === 0) {
      return x;
    }
    var y = Math.floor(Math.abs(x));
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.EPSILON', function(orig) {
  return Math.pow(2, -52);
}, 'es6', 'es3');
$jscomp.polyfill('Number.MAX_SAFE_INTEGER', function() {
  return 9007199254740991;
}, 'es6', 'es3');
$jscomp.polyfill('Number.MIN_SAFE_INTEGER', function() {
  return -9007199254740991;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isFinite', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (typeof x !== 'number') {
      return false;
    }
    return !isNaN(x) && x !== Infinity && x !== -Infinity;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isInteger', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (!Number.isFinite(x)) {
      return false;
    }
    return x === Math.floor(x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isNaN', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return typeof x === 'number' && isNaN(x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isSafeInteger', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Number.isInteger(x) && Math.abs(x) <= Number.MAX_SAFE_INTEGER;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Object.assign', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, var_args) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      if (!source) {
        continue;
      }
      for (var key in source) {
        if ($jscomp.owns(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Object.entries', function(orig) {
  if (orig) {
    return orig;
  }
  var entries = function(obj) {
    var result = [];
    for (var key in obj) {
      if ($jscomp.owns(obj, key)) {
        result.push([key, obj[key]]);
      }
    }
    return result;
  };
  return entries;
}, 'es8', 'es3');
$jscomp.polyfill('Object.getOwnPropertySymbols', function(orig) {
  if (orig) {
    return orig;
  }
  return function() {
    return [];
  };
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.ownKeys', function(orig) {
  if (orig) {
    return orig;
  }
  var symbolPrefix = 'jscomp_symbol_';
  function isSymbol(key) {
    return key.substring(0, symbolPrefix.length) == symbolPrefix;
  }
  var polyfill = function(target) {
    var keys = [];
    var names = Object.getOwnPropertyNames(target);
    var symbols = Object.getOwnPropertySymbols(target);
    for (var i = 0; i < names.length; i++) {
      (isSymbol(names[i]) ? symbols : keys).push(names[i]);
    }
    return keys.concat(symbols);
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Object.getOwnPropertyDescriptors', function(orig) {
  if (orig) {
    return orig;
  }
  var getOwnPropertyDescriptors = function(obj) {
    var result = {};
    var keys = Reflect.ownKeys(obj);
    for (var i = 0; i < keys.length; i++) {
      result[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return result;
  };
  return getOwnPropertyDescriptors;
}, 'es8', 'es5');
$jscomp.underscoreProtoCanBeSet = function() {
  var x = {a:true};
  var y = {};
  try {
    y.__proto__ = x;
    return y.a;
  } catch (e) {
  }
  return false;
};
$jscomp.setPrototypeOf = typeof Object.setPrototypeOf == 'function' ? Object.setPrototypeOf : $jscomp.underscoreProtoCanBeSet() ? function(target, proto) {
  target.__proto__ = proto;
  if (target.__proto__ !== proto) {
    throw new TypeError(target + ' is not extensible');
  }
  return target;
} : null;
$jscomp.polyfill('Object.setPrototypeOf', function(orig) {
  return orig || $jscomp.setPrototypeOf;
}, 'es6', 'es5');
$jscomp.polyfill('Object.values', function(orig) {
  if (orig) {
    return orig;
  }
  var values = function(obj) {
    var result = [];
    for (var key in obj) {
      if ($jscomp.owns(obj, key)) {
        result.push(obj[key]);
      }
    }
    return result;
  };
  return values;
}, 'es8', 'es3');
$jscomp.polyfill('Reflect.apply', function(orig) {
  if (orig) {
    return orig;
  }
  var apply = Function.prototype.apply;
  var polyfill = function(target, thisArg, argList) {
    return apply.call(target, thisArg, argList);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.objectCreate = $jscomp.ASSUME_ES5 || typeof Object.create == 'function' ? Object.create : function(prototype) {
  var ctor = function() {
  };
  ctor.prototype = prototype;
  return new ctor;
};
$jscomp.construct = function() {
  function reflectConstructWorks() {
    function Base() {
    }
    function Derived() {
    }
    new Base;
    Reflect.construct(Base, [], Derived);
    return new Base instanceof Base;
  }
  if (typeof Reflect != 'undefined' && Reflect.construct) {
    if (reflectConstructWorks()) {
      return Reflect.construct;
    }
    var brokenConstruct = Reflect.construct;
    var patchedConstruct = function(target, argList, opt_newTarget) {
      var out = brokenConstruct(target, argList);
      if (opt_newTarget) {
        Reflect.setPrototypeOf(out, opt_newTarget.prototype);
      }
      return out;
    };
    return patchedConstruct;
  }
  function construct(target, argList, opt_newTarget) {
    if (opt_newTarget === undefined) {
      opt_newTarget = target;
    }
    var proto = opt_newTarget.prototype || Object.prototype;
    var obj = $jscomp.objectCreate(proto);
    var apply = Function.prototype.apply;
    var out = apply.call(target, obj, argList);
    return out || obj;
  }
  return construct;
}();
$jscomp.polyfill('Reflect.construct', function(orig) {
  return $jscomp.construct;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.defineProperty', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, attributes) {
    try {
      Object.defineProperty(target, propertyKey, attributes);
      var desc = Object.getOwnPropertyDescriptor(target, propertyKey);
      if (!desc) {
        return false;
      }
      return desc.configurable === (attributes.configurable || false) && desc.enumerable === (attributes.enumerable || false) && ('value' in desc ? desc.value === attributes.value && desc.writable === (attributes.writable || false) : desc.get === attributes.get && desc.set === attributes.set);
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.deleteProperty', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey) {
    if (!$jscomp.owns(target, propertyKey)) {
      return true;
    }
    try {
      return delete target[propertyKey];
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.getOwnPropertyDescriptor', function(orig) {
  return orig || Object.getOwnPropertyDescriptor;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.getPrototypeOf', function(orig) {
  return orig || Object.getPrototypeOf;
}, 'es6', 'es5');
$jscomp.findDescriptor = function(target, propertyKey) {
  var obj = target;
  while (obj) {
    var property = Reflect.getOwnPropertyDescriptor(obj, propertyKey);
    if (property) {
      return property;
    }
    obj = Reflect.getPrototypeOf(obj);
  }
  return undefined;
};
$jscomp.polyfill('Reflect.get', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, opt_receiver) {
    if (arguments.length <= 2) {
      return target[propertyKey];
    }
    var property = $jscomp.findDescriptor(target, propertyKey);
    if (property) {
      return property.get ? property.get.call(opt_receiver) : property.value;
    }
    return undefined;
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.has', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey) {
    return propertyKey in target;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.isExtensible', function(orig) {
  if (orig) {
    return orig;
  }
  if ($jscomp.ASSUME_ES5 || typeof Object.isExtensible == 'function') {
    return Object.isExtensible;
  }
  return function() {
    return true;
  };
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.preventExtensions', function(orig) {
  if (orig) {
    return orig;
  }
  if (!($jscomp.ASSUME_ES5 || typeof Object.preventExtensions == 'function')) {
    return function() {
      return false;
    };
  }
  var polyfill = function(target) {
    Object.preventExtensions(target);
    return !Object.isExtensible(target);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.set', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, value, opt_receiver) {
    var property = $jscomp.findDescriptor(target, propertyKey);
    if (!property) {
      if (Reflect.isExtensible(target)) {
        target[propertyKey] = value;
        return true;
      }
      return false;
    }
    if (property.set) {
      property.set.call(arguments.length > 3 ? opt_receiver : target, value);
      return true;
    } else {
      if (property.writable && !Object.isFrozen(target)) {
        target[propertyKey] = value;
        return true;
      }
    }
    return false;
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.setPrototypeOf', function(orig) {
  if (orig) {
    return orig;
  } else {
    if ($jscomp.setPrototypeOf) {
      var setPrototypeOf = $jscomp.setPrototypeOf;
      var polyfill = function(target, proto) {
        try {
          setPrototypeOf(target, proto);
          return true;
        } catch (e) {
          return false;
        }
      };
      return polyfill;
    } else {
      return null;
    }
  }
}, 'es6', 'es5');
$jscomp.polyfill('Set', function(NativeSet) {
  var isConformant = !$jscomp.ASSUME_NO_NATIVE_SET && function() {
    if (!NativeSet || !NativeSet.prototype.entries || typeof Object.seal != 'function') {
      return false;
    }
    try {
      NativeSet = NativeSet;
      var value = Object.seal({x:4});
      var set = new NativeSet($jscomp.makeIterator([value]));
      if (!set.has(value) || set.size != 1 || set.add(value) != set || set.size != 1 || set.add({x:4}) != set || set.size != 2) {
        return false;
      }
      var iter = set.entries();
      var item = iter.next();
      if (item.done || item.value[0] != value || item.value[1] != value) {
        return false;
      }
      item = iter.next();
      if (item.done || item.value[0] == value || item.value[0].x != 4 || item.value[1] != item.value[0]) {
        return false;
      }
      return iter.next().done;
    } catch (err) {
      return false;
    }
  }();
  if (isConformant) {
    return NativeSet;
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var PolyfillSet = function(opt_iterable) {
    this.map_ = new Map;
    if (opt_iterable) {
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.add(item);
      }
    }
    this.size = this.map_.size;
  };
  PolyfillSet.prototype.add = function(value) {
    this.map_.set(value, value);
    this.size = this.map_.size;
    return this;
  };
  PolyfillSet.prototype['delete'] = function(value) {
    var result = this.map_['delete'](value);
    this.size = this.map_.size;
    return result;
  };
  PolyfillSet.prototype.clear = function() {
    this.map_.clear();
    this.size = 0;
  };
  PolyfillSet.prototype.has = function(value) {
    return this.map_.has(value);
  };
  PolyfillSet.prototype.entries = function() {
    return this.map_.entries();
  };
  PolyfillSet.prototype.values = function() {
    return this.map_.values();
  };
  PolyfillSet.prototype.keys = PolyfillSet.prototype.values;
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  PolyfillSet.prototype[Symbol.iterator] = PolyfillSet.prototype.values;
  PolyfillSet.prototype.forEach = function(callback, opt_thisArg) {
    var set = this;
    this.map_.forEach(function(value) {
      return callback.call(opt_thisArg, value, value, set);
    });
  };
  return PolyfillSet;
}, 'es6', 'es3');
$jscomp.checkStringArgs = function(thisArg, arg, func) {
  if (thisArg == null) {
    throw new TypeError("The 'this' value for String.prototype." + func + ' must not be null or undefined');
  }
  if (arg instanceof RegExp) {
    throw new TypeError('First argument to String.prototype.' + func + ' must not be a regular expression');
  }
  return thisArg + '';
};
$jscomp.polyfill('String.prototype.codePointAt', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(position) {
    var string = $jscomp.checkStringArgs(this, null, 'codePointAt');
    var size = string.length;
    position = Number(position) || 0;
    if (!(position >= 0 && position < size)) {
      return void 0;
    }
    position = position | 0;
    var first = string.charCodeAt(position);
    if (first < 55296 || first > 56319 || position + 1 === size) {
      return first;
    }
    var second = string.charCodeAt(position + 1);
    if (second < 56320 || second > 57343) {
      return first;
    }
    return (first - 55296) * 1024 + second + 9216;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.endsWith', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'endsWith');
    searchString = searchString + '';
    if (opt_position === void 0) {
      opt_position = string.length;
    }
    var i = Math.max(0, Math.min(opt_position | 0, string.length));
    var j = searchString.length;
    while (j > 0 && i > 0) {
      if (string[--i] != searchString[--j]) {
        return false;
      }
    }
    return j <= 0;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.fromCodePoint', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(var_args) {
    var result = '';
    for (var i = 0; i < arguments.length; i++) {
      var code = Number(arguments[i]);
      if (code < 0 || code > 1114111 || code !== Math.floor(code)) {
        throw new RangeError('invalid_code_point ' + code);
      }
      if (code <= 65535) {
        result += String.fromCharCode(code);
      } else {
        code -= 65536;
        result += String.fromCharCode(code >>> 10 & 1023 | 55296);
        result += String.fromCharCode(code & 1023 | 56320);
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.includes', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'includes');
    return string.indexOf(searchString, opt_position || 0) !== -1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.repeat', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(copies) {
    var string = $jscomp.checkStringArgs(this, null, 'repeat');
    if (copies < 0 || copies > 1342177279) {
      throw new RangeError('Invalid count value');
    }
    copies = copies | 0;
    var result = '';
    while (copies) {
      if (copies & 1) {
        result += string;
      }
      if (copies >>>= 1) {
        string += string;
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.stringPadding = function(padString, padLength) {
  var padding = padString !== undefined ? String(padString) : ' ';
  if (!(padLength > 0) || !padding) {
    return '';
  }
  var repeats = Math.ceil(padLength / padding.length);
  return padding.repeat(repeats).substring(0, padLength);
};
$jscomp.polyfill('String.prototype.padEnd', function(orig) {
  if (orig) {
    return orig;
  }
  var padEnd = function(targetLength, opt_padString) {
    var string = $jscomp.checkStringArgs(this, null, 'padStart');
    var padLength = targetLength - string.length;
    return string + $jscomp.stringPadding(opt_padString, padLength);
  };
  return padEnd;
}, 'es8', 'es3');
$jscomp.polyfill('String.prototype.padStart', function(orig) {
  if (orig) {
    return orig;
  }
  var padStart = function(targetLength, opt_padString) {
    var string = $jscomp.checkStringArgs(this, null, 'padStart');
    var padLength = targetLength - string.length;
    return $jscomp.stringPadding(opt_padString, padLength) + string;
  };
  return padStart;
}, 'es8', 'es3');
$jscomp.polyfill('String.prototype.startsWith', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'startsWith');
    searchString = searchString + '';
    var strLen = string.length;
    var searchLen = searchString.length;
    var i = Math.max(0, Math.min(opt_position | 0, string.length));
    var j = 0;
    while (j < searchLen && i < strLen) {
      if (string[i++] != searchString[j++]) {
        return false;
      }
    }
    return j >= searchLen;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.arrayFromIterator = function(iterator) {
  var i;
  var arr = [];
  while (!(i = iterator.next()).done) {
    arr.push(i.value);
  }
  return arr;
};
$jscomp.arrayFromIterable = function(iterable) {
  if (iterable instanceof Array) {
    return iterable;
  } else {
    return $jscomp.arrayFromIterator($jscomp.makeIterator(iterable));
  }
};
$jscomp.inherits = function(childCtor, parentCtor) {
  childCtor.prototype = $jscomp.objectCreate(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
  if ($jscomp.setPrototypeOf) {
    var setPrototypeOf = $jscomp.setPrototypeOf;
    setPrototypeOf(childCtor, parentCtor);
  } else {
    for (var p in parentCtor) {
      if (p == 'prototype') {
        continue;
      }
      if (Object.defineProperties) {
        var descriptor = Object.getOwnPropertyDescriptor(parentCtor, p);
        if (descriptor) {
          Object.defineProperty(childCtor, p, descriptor);
        }
      } else {
        childCtor[p] = parentCtor[p];
      }
    }
  }
  childCtor.superClass_ = parentCtor.prototype;
};
$jscomp.polyfill('WeakSet', function(NativeWeakSet) {
  function isConformant() {
    if (!NativeWeakSet || !Object.seal) {
      return false;
    }
    try {
      var x = Object.seal({});
      var y = Object.seal({});
      var set = new NativeWeakSet([x]);
      if (!set.has(x) || set.has(y)) {
        return false;
      }
      set['delete'](x);
      set.add(y);
      return !set.has(x) && set.has(y);
    } catch (err) {
      return false;
    }
  }
  if (isConformant()) {
    return NativeWeakSet;
  }
  var PolyfillWeakSet = function(opt_iterable) {
    this.map_ = new WeakMap;
    if (opt_iterable) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.add(item);
      }
    }
  };
  PolyfillWeakSet.prototype.add = function(elem) {
    this.map_.set(elem, true);
    return this;
  };
  PolyfillWeakSet.prototype.has = function(elem) {
    return this.map_.has(elem);
  };
  PolyfillWeakSet.prototype['delete'] = function(elem) {
    return this.map_['delete'](elem);
  };
  return PolyfillWeakSet;
}, 'es6', 'es3');
try {
  if (Array.prototype.values.toString().indexOf('[native code]') == -1) {
    delete Array.prototype.values;
  }
} catch (e) {
}
var EXTJS_23846 = EXTJS_23846 || {};
var Ext = Ext || {};
if (!Ext.Toolbar) {
  Ext.Toolbar = {};
}
if (!Ext.app) {
  Ext.app = {};
}
if (!Ext.app.bind) {
  Ext.app.bind = {};
}
if (!Ext.app.domain) {
  Ext.app.domain = {};
}
if (!Ext.button) {
  Ext.button = {};
}
if (!Ext.container) {
  Ext.container = {};
}
if (!Ext.core) {
  Ext.core = {};
}
if (!Ext.data) {
  Ext.data = {};
}
if (!Ext.data.field) {
  Ext.data.field = {};
}
if (!Ext.data.flash) {
  Ext.data.flash = {};
}
if (!Ext.data.identifier) {
  Ext.data.identifier = {};
}
if (!Ext.data.matrix) {
  Ext.data.matrix = {};
}
if (!Ext.data.operation) {
  Ext.data.operation = {};
}
if (!Ext.data.proxy) {
  Ext.data.proxy = {};
}
if (!Ext.data.reader) {
  Ext.data.reader = {};
}
if (!Ext.data.request) {
  Ext.data.request = {};
}
if (!Ext.data.schema) {
  Ext.data.schema = {};
}
if (!Ext.data.session) {
  Ext.data.session = {};
}
if (!Ext.data.validator) {
  Ext.data.validator = {};
}
if (!Ext.data.writer) {
  Ext.data.writer = {};
}
if (!Ext.dd) {
  Ext.dd = {};
}
if (!Ext.dom) {
  Ext.dom = {};
}
if (!Ext.dom.Element) {
  Ext.dom.Element = {};
}
if (!Ext.event) {
  Ext.event = {};
}
if (!Ext.event.gesture) {
  Ext.event.gesture = {};
}
if (!Ext.event.publisher) {
  Ext.event.publisher = {};
}
if (!Ext.form) {
  Ext.form = {};
}
if (!Ext.form.Action) {
  Ext.form.Action = {};
}
if (!Ext.form.action) {
  Ext.form.action = {};
}
if (!Ext.form.field) {
  Ext.form.field = {};
}
if (!Ext.form.trigger) {
  Ext.form.trigger = {};
}
if (!Ext.fx) {
  Ext.fx = {};
}
if (!Ext.fx.animation) {
  Ext.fx.animation = {};
}
if (!Ext.fx.easing) {
  Ext.fx.easing = {};
}
if (!Ext.fx.runner) {
  Ext.fx.runner = {};
}
if (!Ext.fx.target) {
  Ext.fx.target = {};
}
if (!Ext.grid) {
  Ext.grid = {};
}
if (!Ext.grid.column) {
  Ext.grid.column = {};
}
if (!Ext.grid.header) {
  Ext.grid.header = {};
}
if (!Ext.grid.locking) {
  Ext.grid.locking = {};
}
if (!Ext.grid.plugin) {
  Ext.grid.plugin = {};
}
if (!Ext.layout) {
  Ext.layout = {};
}
if (!Ext.layout.boxOverflow) {
  Ext.layout.boxOverflow = {};
}
if (!Ext.layout.component) {
  Ext.layout.component = {};
}
if (!Ext.layout.component.field) {
  Ext.layout.component.field = {};
}
if (!Ext.layout.container) {
  Ext.layout.container = {};
}
if (!Ext.layout.container.border) {
  Ext.layout.container.border = {};
}
if (!Ext.layout.container.boxOverflow) {
  Ext.layout.container.boxOverflow = {};
}
if (!Ext.list) {
  Ext.list = {};
}
if (!Ext.menu) {
  Ext.menu = {};
}
if (!Ext.mixin) {
  Ext.mixin = {};
}
if (!Ext.overrides) {
  Ext.overrides = {};
}
if (!Ext.overrides.app) {
  Ext.overrides.app = {};
}
if (!Ext.overrides.app.domain) {
  Ext.overrides.app.domain = {};
}
if (!Ext.overrides.dom) {
  Ext.overrides.dom = {};
}
if (!Ext.overrides.event) {
  Ext.overrides.event = {};
}
if (!Ext.overrides.event.publisher) {
  Ext.overrides.event.publisher = {};
}
if (!Ext.overrides.mixin) {
  Ext.overrides.mixin = {};
}
if (!Ext.overrides.plugin) {
  Ext.overrides.plugin = {};
}
if (!Ext.overrides.util) {
  Ext.overrides.util = {};
}
if (!Ext.panel) {
  Ext.panel = {};
}
if (!Ext.parse) {
  Ext.parse = {};
}
if (!Ext.parse.symbol) {
  Ext.parse.symbol = {};
}
if (!Ext.perf) {
  Ext.perf = {};
}
if (!Ext.picker) {
  Ext.picker = {};
}
if (!Ext.plugin) {
  Ext.plugin = {};
}
if (!Ext.promise) {
  Ext.promise = {};
}
if (!Ext.resizer) {
  Ext.resizer = {};
}
if (!Ext.route) {
  Ext.route = {};
}
if (!Ext.scroll) {
  Ext.scroll = {};
}
if (!Ext.selection) {
  Ext.selection = {};
}
if (!Ext.slider) {
  Ext.slider = {};
}
if (!Ext.state) {
  Ext.state = {};
}
if (!Ext.tab) {
  Ext.tab = {};
}
if (!Ext.theme) {
  Ext.theme = {};
}
if (!Ext.theme.neptune) {
  Ext.theme.neptune = {};
}
if (!Ext.theme.neptune.layout) {
  Ext.theme.neptune.layout = {};
}
if (!Ext.theme.neptune.layout.component) {
  Ext.theme.neptune.layout.component = {};
}
if (!Ext.theme.neptune.menu) {
  Ext.theme.neptune.menu = {};
}
if (!Ext.theme.neptune.panel) {
  Ext.theme.neptune.panel = {};
}
if (!Ext.theme.neptune.picker) {
  Ext.theme.neptune.picker = {};
}
if (!Ext.theme.neptune.resizer) {
  Ext.theme.neptune.resizer = {};
}
if (!Ext.theme.neptune.toolbar) {
  Ext.theme.neptune.toolbar = {};
}
if (!Ext.theme.triton) {
  Ext.theme.triton = {};
}
if (!Ext.theme.triton.form) {
  Ext.theme.triton.form = {};
}
if (!Ext.theme.triton.form.field) {
  Ext.theme.triton.form.field = {};
}
if (!Ext.theme.triton.grid) {
  Ext.theme.triton.grid = {};
}
if (!Ext.theme.triton.grid.column) {
  Ext.theme.triton.grid.column = {};
}
if (!Ext.theme.triton.menu) {
  Ext.theme.triton.menu = {};
}
if (!Ext.theme.triton.picker) {
  Ext.theme.triton.picker = {};
}
if (!Ext.theme.triton.resizer) {
  Ext.theme.triton.resizer = {};
}
if (!Ext.theme.triton.selection) {
  Ext.theme.triton.selection = {};
}
if (!Ext.theme.triton.toolbar) {
  Ext.theme.triton.toolbar = {};
}
if (!Ext.tip) {
  Ext.tip = {};
}
if (!Ext.toolbar) {
  Ext.toolbar = {};
}
if (!Ext.tree) {
  Ext.tree = {};
}
if (!Ext.util) {
  Ext.util = {};
}
if (!Ext.util.paintmonitor) {
  Ext.util.paintmonitor = {};
}
if (!Ext.util.sizemonitor) {
  Ext.util.sizemonitor = {};
}
if (!Ext.util.translatable) {
  Ext.util.translatable = {};
}
if (!Ext.ux) {
  Ext.ux = {};
}
if (!Ext.view) {
  Ext.view = {};
}
if (!Ext.window) {
  Ext.window = {};
}
var Gnt = Gnt || {};
if (!Gnt.feature) {
  Gnt.feature = {};
}
var MultiEmpDispatch = MultiEmpDispatch || {};
if (!MultiEmpDispatch.store) {
  MultiEmpDispatch.store = {};
}
if (!MultiEmpDispatch.view) {
  MultiEmpDispatch.view = {};
}
if (!MultiEmpDispatch.view.main) {
  MultiEmpDispatch.view.main = {};
}
var Robo = Robo || {};
if (!Robo.data) {
  Robo.data = {};
}
var Sch = Sch || {};
if (!Sch.column) {
  Sch.column = {};
}
if (!Sch.column.timeAxis) {
  Sch.column.timeAxis = {};
}
if (!Sch.crud) {
  Sch.crud = {};
}
if (!Sch.data) {
  Sch.data = {};
}
if (!Sch.data.mixin) {
  Sch.data.mixin = {};
}
if (!Sch.data.util) {
  Sch.data.util = {};
}
if (!Sch.eventlayout) {
  Sch.eventlayout = {};
}
if (!Sch.feature) {
  Sch.feature = {};
}
if (!Sch.layout) {
  Sch.layout = {};
}
if (!Sch.locale) {
  Sch.locale = {};
}
if (!Sch.mixin) {
  Sch.mixin = {};
}
if (!Sch.model) {
  Sch.model = {};
}
if (!Sch.panel) {
  Sch.panel = {};
}
if (!Sch.patches) {
  Sch.patches = {};
}
if (!Sch.plugin) {
  Sch.plugin = {};
}
if (!Sch.preset) {
  Sch.preset = {};
}
if (!Sch.selection) {
  Sch.selection = {};
}
if (!Sch.template) {
  Sch.template = {};
}
if (!Sch.tooltip) {
  Sch.tooltip = {};
}
if (!Sch.util) {
  Sch.util = {};
}
if (!Sch.view) {
  Sch.view = {};
}
if (!Sch.view.dependency) {
  Sch.view.dependency = {};
}
if (!Sch.view.dependency.renderingstrategy) {
  Sch.view.dependency.renderingstrategy = {};
}
if (!Sch.view.model) {
  Sch.view.model = {};
}
var Sdc = Sdc || {};
if (!Sdc.controller) {
  Sdc.controller = {};
}
if (!Sdc.data) {
  Sdc.data = {};
}
if (!Sdc.data.mixin) {
  Sdc.data.mixin = {};
}
if (!Sdc.form) {
  Sdc.form = {};
}
if (!Sdc.form.field) {
  Sdc.form.field = {};
}
if (!Sdc.locale) {
  Sdc.locale = {};
}
if (!Sdc.menu) {
  Sdc.menu = {};
}
if (!Sdc.message) {
  Sdc.message = {};
}
if (!Sdc.model) {
  Sdc.model = {};
}
if (!Sdc.panel) {
  Sdc.panel = {};
}
if (!Sdc.panel.mixin) {
  Sdc.panel.mixin = {};
}
if (!Sdc.plugin) {
  Sdc.plugin = {};
}
if (!Sdc.shortcut) {
  Sdc.shortcut = {};
}
if (!Sdc.shortcuts) {
  Sdc.shortcuts = {};
}
if (!Sdc.shortcuts.mixin) {
  Sdc.shortcuts.mixin = {};
}
if (!Sdc.tip) {
  Sdc.tip = {};
}
if (!Sdc.util) {
  Sdc.util = {};
}
if (!Sdc.view) {
  Sdc.view = {};
}
if (!Sdc.window) {
  Sdc.window = {};
}
(function(ExtCmd) {
  var baseStaticMembers, enumerables = ['constructor', 'toString', 'valueOf', 'toLocaleString'], enumerablesMap = {}, enumerablesObj = {}, enumerablesMask = 0, baseStaticMember, Base, ClassManager, Class, configPreFn, cachedConfigPreFn, platformConfigPostFn, platformConfigPreFn, deprecatedPostFn, privatesPreFn, v5ClassSystem, thunk = function() {
    var i, mask;
    Base = Ext.Base;
    ClassManager = Ext.ClassManager;
    Class = Ext.Class;
    for (i = enumerables.length; i-- > 0;) {
      mask = 1 << i;
      enumerablesObj[enumerablesMap[mask] = enumerables[i]] = mask;
    }
    for (i in enumerablesObj) {
      enumerablesMask |= enumerablesObj[i];
    }
    enumerablesMask = ~enumerablesMask;
    Function.prototype.$isFunction = 1;
    v5ClassSystem = !!ClassManager.addAlias;
    configPreFn = Class.getPreprocessor('config').fn;
    cachedConfigPreFn = Class.getPreprocessor('cachedConfig');
    cachedConfigPreFn = cachedConfigPreFn && cachedConfigPreFn.fn;
    privatesPreFn = Class.getPreprocessor('privates');
    privatesPreFn = privatesPreFn && privatesPreFn.fn;
    platformConfigPreFn = Class.getPreprocessor('platformConfig');
    platformConfigPreFn = platformConfigPreFn && platformConfigPreFn.fn;
    platformConfigPostFn = ClassManager.postprocessors.platformConfig;
    platformConfigPostFn = platformConfigPostFn && platformConfigPostFn.fn;
    deprecatedPostFn = ClassManager.postprocessors.deprecated;
    deprecatedPostFn = deprecatedPostFn && deprecatedPostFn.fn;
    baseStaticMembers = Base.$staticMembers;
    if (!baseStaticMembers) {
      baseStaticMembers = [];
      for (baseStaticMember in Base) {
        if (Base.hasOwnProperty(baseStaticMember)) {
          baseStaticMembers.push(baseStaticMember);
        }
      }
    }
    ExtCmd.derive = derive;
    return derive.apply(this, arguments);
  }, onBeforeCreated = function(cls, data, hooks) {
    var enumerableMembers = hooks.enumerableMembers, proto = cls.prototype, member, fn, which, val, existing;
    if (!data) {
      return;
    }
    if (v5ClassSystem) {
      cls.addMembers(data);
    } else {
      for (member in data) {
        val = data[member];
        if (val && val.$isFunction && !val.$isClass && val !== Ext.emptyFn && val !== Ext.identityFn) {
          existing = proto.hasOwnProperty(member) && proto[member];
          if (existing) {
            val.$previous = existing;
          }
          proto[member] = fn = val;
          fn.$owner = cls;
          fn.$name = member;
        } else {
          proto[member] = val;
        }
      }
      for (which = 1; enumerableMembers; which <<= 1) {
        if (enumerableMembers & which) {
          enumerableMembers &= ~which;
          member = enumerablesMap[which];
          proto[member] = fn = data[member];
          fn.$owner = cls;
          fn.$name = member;
        }
      }
    }
    if (data.platformConfig && platformConfigPostFn) {
      platformConfigPostFn.call(ClassManager, cls.$className, cls, data);
    }
    if (data.deprecated && deprecatedPostFn) {
      deprecatedPostFn.call(ClassManager, cls.$className, cls, data);
    }
  }, derive = function(className, base, data, enumerableMembers, xtypes, xtypesChain, xtypeMap, aliases, mixins, names, createdFn) {
    var cls = function ctor() {
      return this.constructor.apply(this, arguments) || null;
    }, ret = cls, hooks = {enumerableMembers:enumerableMembers & enumerablesMask, onCreated:createdFn, onBeforeCreated:onBeforeCreated, aliases:aliases}, alternates = data.alternateClassName || [], global = Ext.global, alias, alternate, i, ln, n, ns, name, proto, statics, staticMember, targetName, fn, val, altToName = ClassManager.alternateToName || ClassManager.maps.alternateToName, nameToAlt = ClassManager.nameToAlternates || ClassManager.maps.nameToAlternates;
    for (i = baseStaticMembers.length; i-- > 0;) {
      name = baseStaticMembers[i];
      cls[name] = Base[name];
    }
    if (data.$isFunction) {
      data = data(cls);
    }
    hooks.data = data;
    statics = data.statics;
    delete data.statics;
    data.$className = className;
    if ('$className' in data) {
      cls.$className = data.$className;
    }
    cls.extend(base);
    proto = cls.prototype;
    if (xtypes) {
      cls.xtype = data.xtype = xtypes[0];
      proto.xtypes = xtypes;
    }
    proto.xtypesChain = xtypesChain;
    proto.xtypesMap = xtypeMap;
    data.alias = aliases;
    ret.triggerExtended(cls, data, hooks);
    if (data.onClassExtended) {
      cls.onExtended(data.onClassExtended, cls);
      delete data.onClassExtended;
    }
    if (data.privates && privatesPreFn) {
      privatesPreFn.call(Class, cls, data);
    }
    if (statics) {
      if (v5ClassSystem) {
        cls.addStatics(statics);
      } else {
        for (staticMember in statics) {
          if (statics.hasOwnProperty(staticMember)) {
            val = statics[staticMember];
            if (val && val.$isFunction && !val.$isClass && val !== Ext.emptyFn && val !== Ext.identityFn) {
              cls[staticMember] = fn = val;
              fn.$owner = cls;
              fn.$name = staticMember;
            }
            cls[staticMember] = val;
          }
        }
      }
    }
    if (data.inheritableStatics) {
      cls.addInheritableStatics(data.inheritableStatics);
      delete data.inheritableStatics;
    }
    if (proto.onClassExtended) {
      ret.onExtended(proto.onClassExtended, ret);
      delete proto.onClassExtended;
    }
    if (data.platformConfig && platformConfigPreFn) {
      platformConfigPreFn.call(Class, cls, data);
      delete data.platformConfig;
    }
    if (data.config) {
      configPreFn.call(Class, cls, data);
    }
    if (data.cachedConfig && cachedConfigPreFn) {
      cachedConfigPreFn.call(Class, cls, data);
      delete data.cachedConfig;
    }
    hooks.onBeforeCreated(cls, hooks.data, hooks);
    for (i = 0, n = mixins && mixins.length; i < n; ++i) {
      cls.mixin.apply(cls, mixins[i]);
    }
    for (i = 0, n = aliases.length; i < n; i++) {
      alias = aliases[i];
      ClassManager.setAlias ? ClassManager.setAlias(cls, alias) : ClassManager.addAlias(cls, alias);
    }
    if (data.singleton) {
      ret = new cls;
    }
    if (!(alternates instanceof Array)) {
      alternates = [alternates];
    }
    targetName = ClassManager.getName(ret);
    for (i = 0, ln = alternates.length; i < ln; i++) {
      alternate = alternates[i];
      ClassManager.classes[alternate] = ret;
      if (v5ClassSystem) {
        ClassManager.addAlternate(cls, alternate);
      } else {
        if (targetName) {
          altToName[alternate] = targetName;
          alternates = nameToAlt[targetName] || (nameToAlt[targetName] = []);
          alternates.push(alternate);
        }
      }
    }
    for (i = 0, n = names.length; i < n; i += 2) {
      ns = names[i];
      if (!ns) {
        ns = global;
      }
      ns[names[i + 1]] = ret;
    }
    ClassManager.classes[className] = ret;
    if (!v5ClassSystem) {
      if (targetName && targetName !== className) {
        altToName[className] = targetName;
        alternates = nameToAlt[targetName] || (nameToAlt[targetName] = []);
        alternates.push(className);
      }
    }
    delete proto.alternateClassName;
    if (hooks.onCreated) {
      hooks.onCreated.call(ret, ret);
    }
    if (className) {
      ClassManager.triggerCreated(className);
    }
    return ret;
  };
  ExtCmd.derive = thunk;
})(Ext.cmd = {});
var Ext = Ext || {};
(function() {
  var global = this, objectPrototype = Object.prototype, toString = objectPrototype.toString, enumerables = ['valueOf', 'toLocaleString', 'toString', 'constructor'], emptyFn = Ext.fireIdle = function() {
  }, privateFn = function() {
  }, identityFn = function(o) {
    return o;
  }, callOverrideParent = function() {
    var method = callOverrideParent.caller.caller;
    return method.$owner.prototype[method.$name].apply(this, arguments);
  }, manifest = Ext.manifest || {}, i, iterableRe = /\[object\s*(?:Array|Arguments|\w*Collection|\w*List|HTML\s+document\.all\s+class)\]/, MSDateRe = /^\\?\/Date\(([-+])?(\d+)(?:[+-]\d{4})?\)\\?\/$/, elevateArgs, elevateFn, elevateRet, elevateScope;
  Ext.global = global;
  Ext.$nextIid = 0;
  Ext.now = Date.now || (Date.now = function() {
    return +new Date;
  });
  Ext.ticks = global.performance && global.performance.now ? function() {
    return performance.now();
  } : Ext.now;
  Ext._startTime = Ext.ticks();
  emptyFn.$nullFn = identityFn.$nullFn = emptyFn.$emptyFn = identityFn.$identityFn = privateFn.$nullFn = true;
  privateFn.$privacy = 'framework';
  emptyFn.$noClearOnDestroy = identityFn.$noClearOnDestroy = true;
  privateFn.$noClearOnDestroy = true;
  Ext['suspendLayouts'] = Ext['resumeLayouts'] = emptyFn;
  for (i in{toString:1}) {
    enumerables = null;
  }
  Ext.enumerables = enumerables;
  Ext.apply = function(object, config, defaults) {
    if (object) {
      if (defaults) {
        Ext.apply(object, defaults);
      }
      if (config && typeof config === 'object') {
        var i, j, k;
        for (i in config) {
          object[i] = config[i];
        }
        if (enumerables) {
          for (j = enumerables.length; j--;) {
            k = enumerables[j];
            if (config.hasOwnProperty(k)) {
              object[k] = config[k];
            }
          }
        }
      }
    }
    return object;
  };
  function addInstanceOverrides(target, owner, overrides) {
    var name, value;
    for (name in overrides) {
      if (overrides.hasOwnProperty(name)) {
        value = overrides[name];
        if (typeof value === 'function') {
          value.$name = name;
          value.$owner = owner;
          value.$previous = target.hasOwnProperty(name) ? target[name] : callOverrideParent;
        }
        target[name] = value;
      }
    }
  }
  Ext.buildSettings = Ext.apply({baseCSSPrefix:'x-'}, Ext.buildSettings || {});
  Ext.apply(Ext, {idSeed:0, idPrefix:'ext-', isRobot:false, isSecure:/^https/i.test(window.location.protocol), enableGarbageCollector:false, enableListenerCollection:true, name:Ext.sandboxName || 'Ext', privateFn:privateFn, emptyFn:emptyFn, identityFn:identityFn, frameStartTime:Ext.now(), manifest:manifest, enableAria:true, startsWithHashRe:/^#/, validIdRe:/^[a-z_][a-z0-9\-_]*$/i, BLANK_IMAGE_URL:'data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw\x3d\x3d', makeIdSelector:function(id) {
    return '#' + id;
  }, id:function(o, prefix) {
    if (o && o.id) {
      return o.id;
    }
    var id = (prefix || Ext.idPrefix) + ++Ext.idSeed;
    if (o) {
      o.id = id;
    }
    return id;
  }, returnId:function(o) {
    return o.getId();
  }, returnTrue:function() {
    return true;
  }, emptyString:new String, emptyArray:Object.freeze ? Object.freeze([]) : [], baseCSSPrefix:Ext.buildSettings.baseCSSPrefix, $eventNameMap:{}, $vendorEventRe:/^(DOMMouse|Moz.+|MS.+|webkit.+)/, canonicalEventName:function(name) {
    return Ext.$eventNameMap[name] || (Ext.$eventNameMap[name] = Ext.$vendorEventRe.test(name) ? name : name.toLowerCase());
  }, applyIf:function(object, config) {
    if (object && config && typeof config === 'object') {
      for (var property in config) {
        if (object[property] === undefined) {
          object[property] = config[property];
        }
      }
    }
    return object;
  }, destroy:function() {
    var ln = arguments.length, i, arg;
    for (i = 0; i < ln; i++) {
      arg = arguments[i];
      if (arg) {
        if (Ext.isArray(arg)) {
          this.destroy.apply(this, arg);
        } else {
          if (Ext.isFunction(arg.destroy) && !arg.destroyed) {
            arg.destroy();
          }
        }
      }
    }
    return null;
  }, destroyMembers:function(object) {
    for (var ref, name, i = 1, a = arguments, len = a.length; i < len; i++) {
      ref = object[name = a[i]];
      if (ref != null) {
        object[name] = Ext.destroy(ref);
      }
    }
  }, override:function(target, overrides) {
    if (target.$isClass) {
      target.override(overrides);
    } else {
      if (typeof target === 'function') {
        Ext.apply(target.prototype, overrides);
      } else {
        var owner = target.self, privates;
        if (owner && owner.$isClass) {
          privates = overrides.privates;
          if (privates) {
            overrides = Ext.apply({}, overrides);
            delete overrides.privates;
            addInstanceOverrides(target, owner, privates);
          }
          addInstanceOverrides(target, owner, overrides);
        } else {
          Ext.apply(target, overrides);
        }
      }
    }
    return target;
  }, valueFrom:function(value, defaultValue, allowBlank) {
    return Ext.isEmpty(value, allowBlank) ? defaultValue : value;
  }, isEmpty:function(value, allowEmptyString) {
    return value == null || (!allowEmptyString ? value === '' : false) || Ext.isArray(value) && value.length === 0;
  }, isArray:'isArray' in Array ? Array.isArray : function(value) {
    return toString.call(value) === '[object Array]';
  }, isDate:function(obj) {
    return toString.call(obj) === '[object Date]';
  }, isMSDate:function(value) {
    if (!Ext.isString(value)) {
      return false;
    }
    return MSDateRe.test(value);
  }, isObject:toString.call(null) === '[object Object]' ? function(value) {
    return value != null && toString.call(value) === '[object Object]' && value.ownerDocument === undefined;
  } : function(value) {
    return toString.call(value) === '[object Object]';
  }, isSimpleObject:function(value) {
    return value instanceof Object && value.constructor === Object;
  }, isPrimitive:function(value) {
    var type = typeof value;
    return type === 'string' || type === 'number' || type === 'boolean';
  }, isFunction:typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function' ? function(value) {
    return !!value && toString.call(value) === '[object Function]';
  } : function(value) {
    return !!value && typeof value === 'function';
  }, isNumber:function(value) {
    return typeof value === 'number' && isFinite(value);
  }, isNumeric:function(value) {
    return !isNaN(parseFloat(value)) && isFinite(value);
  }, isString:function(value) {
    return typeof value === 'string';
  }, isBoolean:function(value) {
    return typeof value === 'boolean';
  }, isElement:function(value) {
    return value ? value.nodeType === 1 : false;
  }, isTextNode:function(value) {
    return value ? value.nodeName === '#text' : false;
  }, isDefined:function(value) {
    return typeof value !== 'undefined';
  }, isIterable:function(value) {
    if (!value || typeof value.length !== 'number' || typeof value === 'string' || Ext.isFunction(value)) {
      return false;
    }
    if (!value.propertyIsEnumerable) {
      return !!value.item;
    }
    if (value.hasOwnProperty('length') && !value.propertyIsEnumerable('length')) {
      return true;
    }
    return iterableRe.test(toString.call(value));
  }, isDebugEnabled:emptyFn, clone:function(item, cloneDom) {
    if (item == null) {
      return item;
    }
    if (cloneDom !== false && item.nodeType && item.cloneNode) {
      return item.cloneNode(true);
    }
    var type = toString.call(item), i, j, k, clone, key;
    if (type === '[object Date]') {
      return new Date(item.getTime());
    }
    if (type === '[object Array]') {
      i = item.length;
      clone = [];
      while (i--) {
        clone[i] = Ext.clone(item[i], cloneDom);
      }
    } else {
      if (type === '[object Object]' && item.constructor === Object) {
        clone = {};
        for (key in item) {
          clone[key] = Ext.clone(item[key], cloneDom);
        }
        if (enumerables) {
          for (j = enumerables.length; j--;) {
            k = enumerables[j];
            if (item.hasOwnProperty(k)) {
              clone[k] = item[k];
            }
          }
        }
      }
    }
    return clone || item;
  }, getUniqueGlobalNamespace:function() {
    var uniqueGlobalNamespace = this.uniqueGlobalNamespace, i;
    if (uniqueGlobalNamespace === undefined) {
      i = 0;
      do {
        uniqueGlobalNamespace = 'ExtBox' + ++i;
      } while (global[uniqueGlobalNamespace] !== undefined);
      global[uniqueGlobalNamespace] = Ext;
      this.uniqueGlobalNamespace = uniqueGlobalNamespace;
    }
    return uniqueGlobalNamespace;
  }, functionFactoryCache:{}, cacheableFunctionFactory:function() {
    var me = this, args = Array.prototype.slice.call(arguments), cache = me.functionFactoryCache, idx, fn, ln;
    if (Ext.isSandboxed) {
      ln = args.length;
      if (ln > 0) {
        ln--;
        args[ln] = 'var Ext\x3dwindow.' + Ext.name + ';' + args[ln];
      }
    }
    idx = args.join('');
    fn = cache[idx];
    if (!fn) {
      fn = Function.prototype.constructor.apply(Function.prototype, args);
      cache[idx] = fn;
    }
    return fn;
  }, functionFactory:function() {
    var args = Array.prototype.slice.call(arguments), ln;
    if (Ext.isSandboxed) {
      ln = args.length;
      if (ln > 0) {
        ln--;
        args[ln] = 'var Ext\x3dwindow.' + Ext.name + ';' + args[ln];
      }
    }
    return Function.prototype.constructor.apply(Function.prototype, args);
  }, Logger:{verbose:emptyFn, log:emptyFn, info:emptyFn, warn:emptyFn, error:function(message) {
    throw new Error(message);
  }, deprecate:emptyFn}, ariaWarn:function(target, msg) {
    if (Ext.enableAria && !Ext.slicer) {
      if (!Ext.ariaWarn.first) {
        Ext.ariaWarn.first = true;
        Ext.log.warn('WAI-ARIA compatibility warnings can be suppressed by adding the following to application startup code:');
        Ext.log.warn('    Ext.ariaWarn \x3d Ext.emptyFn;');
      }
      Ext.log.warn({msg:msg, dump:target});
    }
  }, getElementById:function(id) {
    return document.getElementById(id);
  }, splitAndUnescape:function() {
    var cache = {};
    return function(origin, delimiter) {
      if (!origin) {
        return [];
      } else {
        if (!delimiter) {
          return [origin];
        }
      }
      var replaceRe = cache[delimiter] || (cache[delimiter] = new RegExp('\\\\' + delimiter, 'g')), result = [], parts, part;
      parts = origin.split(delimiter);
      while ((part = parts.shift()) !== undefined) {
        while (part.charAt(part.length - 1) === '\\' && parts.length > 0) {
          part = part + delimiter + parts.shift();
        }
        part = part.replace(replaceRe, delimiter);
        result.push(part);
      }
      return result;
    };
  }(), doElevate:function() {
    var fn = elevateFn, args = elevateArgs, scope = elevateScope;
    elevateFn = elevateArgs = elevateScope = null;
    elevateRet = args ? fn.apply(scope, args) : fn.call(scope);
    Ext.fireIdle();
  }, elevate:function(fn, scope, args) {
    var ret;
    if (args && !args.length) {
      args = null;
    }
    Ext._suppressIdle = false;
    if (Ext.elevateFunction) {
      elevateFn = fn;
      elevateScope = scope;
      elevateArgs = args;
      Ext.elevateFunction(Ext.doElevate);
      ret = elevateRet;
      elevateRet = null;
    } else {
      ret = args ? fn.apply(scope, args) : fn.call(scope);
      Ext.fireIdle();
    }
    return ret;
  }, getExpando:function(target, id) {
    var expandos = target.$expandos;
    return expandos && expandos[id] || null;
  }, setExpando:function(target, id, value) {
    var expandos = target.$expandos;
    if (value !== undefined) {
      (expandos || (target.$expandos = {}))[id] = value;
    } else {
      if (expandos) {
        delete expandos[id];
      }
    }
  }});
  Ext.returnTrue.$nullFn = Ext.returnId.$nullFn = true;
})();
Ext.platformTags.modern = !(Ext.platformTags.classic = Ext.isClassic = true);
(function() {
  function toString() {
    var me = this, cls = me.sourceClass, method = me.sourceMethod, msg = me.msg;
    if (method) {
      if (msg) {
        method += '(): ';
        method += msg;
      } else {
        method += '()';
      }
    }
    if (cls) {
      method = method ? cls + '.' + method : cls;
    }
    return method || msg || '';
  }
  Ext.Error = function(config) {
    if (Ext.isString(config)) {
      config = {msg:config};
    }
    var error = new Error;
    Ext.apply(error, config);
    error.message = error.message || error.msg;
    error.toString = toString;
    return error;
  };
  Ext.apply(Ext.Error, {ignore:false, raise:function(err) {
    err = err || {};
    if (Ext.isString(err)) {
      err = {msg:err};
    }
    var me = this, method = me.raise.caller, msg, name;
    if (method === Ext.raise) {
      method = method.caller;
    }
    if (method) {
      if (!err.sourceMethod && (name = method.$name)) {
        err.sourceMethod = name;
      }
      if (!err.sourceClass && (name = method.$owner) && (name = name.$className)) {
        err.sourceClass = name;
      }
    }
    if (me.handle(err) !== true) {
      msg = toString.call(err);
      throw new Ext.Error(err);
    }
  }, handle:function() {
    return this.ignore;
  }});
})();
Ext.deprecated = function(suggestion) {
  return Ext.emptyFn;
};
Ext.raise = function() {
  Ext.Error.raise.apply(Ext.Error, arguments);
};
Ext.Array = function() {
  var arrayPrototype = Array.prototype, slice = arrayPrototype.slice, supportsSplice = function() {
    var array = [], lengthBefore, j = 20;
    if (!array.splice) {
      return false;
    }
    while (j--) {
      array.push('A');
    }
    array.splice(15, 0, 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F');
    lengthBefore = array.length;
    array.splice(13, 0, 'XXX');
    if (lengthBefore + 1 !== array.length) {
      return false;
    }
    return true;
  }(), supportsIndexOf = 'indexOf' in arrayPrototype, supportsSliceOnNodeList = true;
  function stableSort(array, userComparator) {
    var len = array.length, indices = new Array(len), i;
    for (i = 0; i < len; i++) {
      indices[i] = i;
    }
    indices.sort(function(index1, index2) {
      return userComparator(array[index1], array[index2]) || index1 - index2;
    });
    for (i = 0; i < len; i++) {
      indices[i] = array[indices[i]];
    }
    for (i = 0; i < len; i++) {
      array[i] = indices[i];
    }
    return array;
  }
  try {
    if (typeof document !== 'undefined') {
      slice.call(document.getElementsByTagName('body'));
    }
  } catch (e$0) {
    supportsSliceOnNodeList = false;
  }
  var fixArrayIndex = function(array, index) {
    return index < 0 ? Math.max(0, array.length + index) : Math.min(array.length, index);
  }, replaceSim = function(array, index, removeCount, insert) {
    var add = insert ? insert.length : 0, length = array.length, pos = fixArrayIndex(array, index);
    if (pos === length) {
      if (add) {
        array.push.apply(array, insert);
      }
    } else {
      var remove = Math.min(removeCount, length - pos), tailOldPos = pos + remove, tailNewPos = tailOldPos + add - remove, tailCount = length - tailOldPos, lengthAfterRemove = length - remove, i;
      if (tailNewPos < tailOldPos) {
        for (i = 0; i < tailCount; ++i) {
          array[tailNewPos + i] = array[tailOldPos + i];
        }
      } else {
        if (tailNewPos > tailOldPos) {
          for (i = tailCount; i--;) {
            array[tailNewPos + i] = array[tailOldPos + i];
          }
        }
      }
      if (add && pos === lengthAfterRemove) {
        array.length = lengthAfterRemove;
        array.push.apply(array, insert);
      } else {
        array.length = lengthAfterRemove + add;
        for (i = 0; i < add; ++i) {
          array[pos + i] = insert[i];
        }
      }
    }
    return array;
  }, replaceNative = function(array, index, removeCount, insert) {
    if (insert && insert.length) {
      if (index === 0 && !removeCount) {
        array.unshift.apply(array, insert);
      } else {
        if (index < array.length) {
          array.splice.apply(array, [index, removeCount].concat(insert));
        } else {
          array.push.apply(array, insert);
        }
      }
    } else {
      array.splice(index, removeCount);
    }
    return array;
  }, eraseSim = function(array, index, removeCount) {
    return replaceSim(array, index, removeCount);
  }, eraseNative = function(array, index, removeCount) {
    array.splice(index, removeCount);
    return array;
  }, spliceSim = function(array, index, removeCount) {
    var len = arguments.length, pos = fixArrayIndex(array, index), removed;
    if (len < 3) {
      removeCount = array.length - pos;
    }
    removed = array.slice(index, fixArrayIndex(array, pos + removeCount));
    if (len < 4) {
      replaceSim(array, pos, removeCount);
    } else {
      replaceSim(array, pos, removeCount, slice.call(arguments, 3));
    }
    return removed;
  }, spliceNative = function(array) {
    return array.splice.apply(array, slice.call(arguments, 1));
  }, erase = supportsSplice ? eraseNative : eraseSim, replace = supportsSplice ? replaceNative : replaceSim, splice = supportsSplice ? spliceNative : spliceSim, ExtArray = {binarySearch:function(array, item, begin, end, compareFn) {
    var length = array.length, middle, comparison;
    if (begin instanceof Function) {
      compareFn = begin;
      begin = 0;
      end = length;
    } else {
      if (end instanceof Function) {
        compareFn = end;
        end = length;
      } else {
        if (begin === undefined) {
          begin = 0;
        }
        if (end === undefined) {
          end = length;
        }
        compareFn = compareFn || ExtArray.lexicalCompare;
      }
    }
    --end;
    while (begin <= end) {
      middle = begin + end >> 1;
      comparison = compareFn(item, array[middle]);
      if (comparison >= 0) {
        begin = middle + 1;
      } else {
        if (comparison < 0) {
          end = middle - 1;
        }
      }
    }
    return begin;
  }, defaultCompare:function(lhs, rhs) {
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }, lexicalCompare:function(lhs, rhs) {
    lhs = String(lhs);
    rhs = String(rhs);
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }, each:function(array, fn, scope, reverse) {
    array = ExtArray.from(array);
    var i, ln = array.length;
    if (reverse !== true) {
      for (i = 0; i < ln; i++) {
        if (fn.call(scope || array[i], array[i], i, array) === false) {
          return i;
        }
      }
    } else {
      for (i = ln - 1; i > -1; i--) {
        if (fn.call(scope || array[i], array[i], i, array) === false) {
          return i;
        }
      }
    }
    return true;
  }, findInsertionIndex:function(item, items, comparatorFn, index) {
    var len = items.length, beforeCheck, afterCheck;
    comparatorFn = comparatorFn || ExtArray.lexicalCompare;
    if (index < len) {
      beforeCheck = index > 0 ? comparatorFn(items[index - 1], item) : 0;
      afterCheck = index < len - 1 ? comparatorFn(item, items[index]) : 0;
      if (beforeCheck < 1 && afterCheck < 1) {
        return index;
      }
    }
    return ExtArray.binarySearch(items, item, comparatorFn);
  }, forEach:'forEach' in arrayPrototype ? function(array, fn, scope) {
    array.forEach(fn, scope);
  } : function(array, fn, scope) {
    for (var i = 0, ln = array.length; i < ln; i++) {
      fn.call(scope, array[i], i, array);
    }
  }, indexOf:supportsIndexOf ? function(array, item, from) {
    return array ? arrayPrototype.indexOf.call(array, item, from) : -1;
  } : function(array, item, from) {
    var i, length = array ? array.length : 0;
    for (i = from < 0 ? Math.max(0, length + from) : from || 0; i < length; i++) {
      if (array[i] === item) {
        return i;
      }
    }
    return -1;
  }, contains:supportsIndexOf ? function(array, item) {
    return arrayPrototype.indexOf.call(array, item) !== -1;
  } : function(array, item) {
    var i, ln;
    for (i = 0, ln = array.length; i < ln; i++) {
      if (array[i] === item) {
        return true;
      }
    }
    return false;
  }, toArray:function(iterable, start, end) {
    if (!iterable || !iterable.length) {
      return [];
    }
    if (typeof iterable === 'string') {
      iterable = iterable.split('');
    }
    if (supportsSliceOnNodeList) {
      return slice.call(iterable, start || 0, end || iterable.length);
    }
    var array = [], i;
    start = start || 0;
    end = end ? end < 0 ? iterable.length + end : end : iterable.length;
    for (i = start; i < end; i++) {
      array.push(iterable[i]);
    }
    return array;
  }, pluck:function(array, propertyName) {
    var ret = [], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      ret.push(item[propertyName]);
    }
    return ret;
  }, map:'map' in arrayPrototype ? function(array, fn, scope) {
    return array.map(fn, scope);
  } : function(array, fn, scope) {
    var len = array.length, results = new Array(len), i;
    for (i = 0; i < len; i++) {
      results[i] = fn.call(scope, array[i], i, array);
    }
    return results;
  }, every:'every' in arrayPrototype ? function(array, fn, scope) {
    return array.every(fn, scope);
  } : function(array, fn, scope) {
    var i = 0, ln = array.length;
    for (; i < ln; ++i) {
      if (!fn.call(scope, array[i], i, array)) {
        return false;
      }
    }
    return true;
  }, some:'some' in arrayPrototype ? function(array, fn, scope) {
    return array.some(fn, scope);
  } : function(array, fn, scope) {
    var i = 0, ln = array.length;
    for (; i < ln; ++i) {
      if (fn.call(scope, array[i], i, array)) {
        return true;
      }
    }
    return false;
  }, equals:function(array1, array2) {
    var len1 = array1.length, len2 = array2.length, i;
    if (array1 === array2) {
      return true;
    }
    if (len1 !== len2) {
      return false;
    }
    for (i = 0; i < len1; ++i) {
      if (array1[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }, clean:function(array) {
    var results = [], i = 0, ln = array.length, item;
    for (; i < ln; i++) {
      item = array[i];
      if (!Ext.isEmpty(item)) {
        results.push(item);
      }
    }
    return results;
  }, unique:function(array) {
    var clone = [], i = 0, ln = array.length, item;
    for (; i < ln; i++) {
      item = array[i];
      if (ExtArray.indexOf(clone, item) === -1) {
        clone.push(item);
      }
    }
    return clone;
  }, filter:'filter' in arrayPrototype ? function(array, fn, scope) {
    return array.filter(fn, scope);
  } : function(array, fn, scope) {
    var results = [], i = 0, ln = array.length;
    for (; i < ln; i++) {
      if (fn.call(scope, array[i], i, array)) {
        results.push(array[i]);
      }
    }
    return results;
  }, findBy:function(array, fn, scope) {
    var i = 0, len = array.length;
    for (; i < len; i++) {
      if (fn.call(scope || array, array[i], i)) {
        return array[i];
      }
    }
    return null;
  }, from:function(value, newReference) {
    if (value === undefined || value === null) {
      return [];
    }
    if (Ext.isArray(value)) {
      return newReference ? slice.call(value) : value;
    }
    var type = typeof value;
    if (value && value.length !== undefined && type !== 'string' && (type !== 'function' || !value.apply)) {
      return ExtArray.toArray(value);
    }
    return [value];
  }, remove:function(array, item) {
    var index = ExtArray.indexOf(array, item);
    if (index !== -1) {
      erase(array, index, 1);
    }
    return array;
  }, removeAt:function(array, index, count) {
    var len = array.length;
    if (index >= 0 && index < len) {
      count = count || 1;
      count = Math.min(count, len - index);
      erase(array, index, count);
    }
    return array;
  }, include:function(array, item) {
    if (!ExtArray.contains(array, item)) {
      array.push(item);
    }
  }, clone:function(array) {
    return slice.call(array);
  }, merge:function() {
    var args = slice.call(arguments), array = [], i, ln;
    for (i = 0, ln = args.length; i < ln; i++) {
      array = array.concat(args[i]);
    }
    return ExtArray.unique(array);
  }, intersect:function() {
    var intersection = [], arrays = slice.call(arguments), arraysLength, array, arrayLength, minArray, minArrayIndex, minArrayCandidate, minArrayLength, element, elementCandidate, elementCount, i, j, k;
    if (!arrays.length) {
      return intersection;
    }
    arraysLength = arrays.length;
    for (i = minArrayIndex = 0; i < arraysLength; i++) {
      minArrayCandidate = arrays[i];
      if (!minArray || minArrayCandidate.length < minArray.length) {
        minArray = minArrayCandidate;
        minArrayIndex = i;
      }
    }
    minArray = ExtArray.unique(minArray);
    erase(arrays, minArrayIndex, 1);
    minArrayLength = minArray.length;
    arraysLength = arrays.length;
    for (i = 0; i < minArrayLength; i++) {
      element = minArray[i];
      elementCount = 0;
      for (j = 0; j < arraysLength; j++) {
        array = arrays[j];
        arrayLength = array.length;
        for (k = 0; k < arrayLength; k++) {
          elementCandidate = array[k];
          if (element === elementCandidate) {
            elementCount++;
            break;
          }
        }
      }
      if (elementCount === arraysLength) {
        intersection.push(element);
      }
    }
    return intersection;
  }, difference:function(arrayA, arrayB) {
    var clone = slice.call(arrayA), ln = clone.length, i, j, lnB;
    for (i = 0, lnB = arrayB.length; i < lnB; i++) {
      for (j = 0; j < ln; j++) {
        if (clone[j] === arrayB[i]) {
          erase(clone, j, 1);
          j--;
          ln--;
        }
      }
    }
    return clone;
  }, reduce:Array.prototype.reduce ? function(array, reduceFn, initialValue) {
    if (arguments.length === 3) {
      return Array.prototype.reduce.call(array, reduceFn, initialValue);
    }
    return Array.prototype.reduce.call(array, reduceFn);
  } : function(array, reduceFn, initialValue) {
    array = Object(array);
    var index = 0, length = array.length >>> 0, reduced = initialValue;
    if (arguments.length < 3) {
      while (true) {
        if (index in array) {
          reduced = array[index++];
          break;
        }
        if (++index >= length) {
          throw new TypeError('Reduce of empty array with no initial value');
        }
      }
    }
    for (; index < length; ++index) {
      if (index in array) {
        reduced = reduceFn(reduced, array[index], index, array);
      }
    }
    return reduced;
  }, slice:[1, 2].slice(1, undefined).length ? function(array, begin, end) {
    return slice.call(array, begin, end);
  } : function(array, begin, end) {
    if (typeof begin === 'undefined') {
      return slice.call(array);
    }
    if (typeof end === 'undefined') {
      return slice.call(array, begin);
    }
    return slice.call(array, begin, end);
  }, sort:function(array, sortFn) {
    return stableSort(array, sortFn || ExtArray.lexicalCompare);
  }, flatten:function(array) {
    var worker = [];
    function rFlatten(a) {
      var i, ln, v;
      for (i = 0, ln = a.length; i < ln; i++) {
        v = a[i];
        if (Ext.isArray(v)) {
          rFlatten(v);
        } else {
          worker.push(v);
        }
      }
      return worker;
    }
    return rFlatten(array);
  }, min:function(array, comparisonFn) {
    var min = array[0], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      if (comparisonFn) {
        if (comparisonFn(min, item) === 1) {
          min = item;
        }
      } else {
        if (item < min) {
          min = item;
        }
      }
    }
    return min;
  }, max:function(array, comparisonFn) {
    var max = array[0], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      if (comparisonFn) {
        if (comparisonFn(max, item) === -1) {
          max = item;
        }
      } else {
        if (item > max) {
          max = item;
        }
      }
    }
    return max;
  }, mean:function(array) {
    return array.length > 0 ? ExtArray.sum(array) / array.length : undefined;
  }, sum:function(array) {
    var sum = 0, i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      sum += item;
    }
    return sum;
  }, toMap:function(strings, getKey, scope) {
    if (!strings) {
      return null;
    }
    var map = {}, i = strings.length;
    if (typeof strings === 'string') {
      map[strings] = 1;
    } else {
      if (!getKey) {
        while (i--) {
          map[strings[i]] = i + 1;
        }
      } else {
        if (typeof getKey === 'string') {
          while (i--) {
            map[strings[i][getKey]] = i + 1;
          }
        } else {
          while (i--) {
            map[getKey.call(scope, strings[i])] = i + 1;
          }
        }
      }
    }
    return map;
  }, toValueMap:function(array, getKey, scope, arrayify) {
    var map = {}, i = array.length, autoArray, alwaysArray, entry, fn, key, value;
    if (!getKey) {
      while (i--) {
        value = array[i];
        map[value] = value;
      }
    } else {
      if (!(fn = typeof getKey !== 'string')) {
        arrayify = scope;
      }
      alwaysArray = arrayify === 1;
      autoArray = arrayify === 2;
      while (i--) {
        value = array[i];
        key = fn ? getKey.call(scope, value) : value[getKey];
        if (alwaysArray) {
          if (key in map) {
            map[key].push(value);
          } else {
            map[key] = [value];
          }
        } else {
          if (autoArray && key in map) {
            if ((entry = map[key]) instanceof Array) {
              entry.push(value);
            } else {
              map[key] = [entry, value];
            }
          } else {
            map[key] = value;
          }
        }
      }
    }
    return map;
  }, erase:erase, insert:function(array, index, items) {
    return replace(array, index, 0, items);
  }, move:function(array, fromIdx, toIdx) {
    if (toIdx === fromIdx) {
      return;
    }
    var item = array[fromIdx], incr = toIdx > fromIdx ? 1 : -1, i;
    for (i = fromIdx; i != toIdx; i += incr) {
      array[i] = array[i + incr];
    }
    array[toIdx] = item;
  }, replace:replace, splice:splice, push:function(target) {
    var args = arguments, len = args.length, i, newItem;
    if (target === undefined) {
      target = [];
    } else {
      if (!Ext.isArray(target)) {
        target = [target];
      }
    }
    for (i = 1; i < len; i++) {
      newItem = args[i];
      Array.prototype.push[Ext.isIterable(newItem) ? 'apply' : 'call'](target, newItem);
    }
    return target;
  }, numericSortFn:function(a, b) {
    return a - b;
  }};
  Ext.each = ExtArray.each;
  ExtArray.union = ExtArray.merge;
  Ext.min = ExtArray.min;
  Ext.max = ExtArray.max;
  Ext.sum = ExtArray.sum;
  Ext.mean = ExtArray.mean;
  Ext.flatten = ExtArray.flatten;
  Ext.clean = ExtArray.clean;
  Ext.unique = ExtArray.unique;
  Ext.pluck = ExtArray.pluck;
  Ext.toArray = function() {
    return ExtArray.toArray.apply(ExtArray, arguments);
  };
  return ExtArray;
}();
Ext.String = function() {
  var trimRegex = /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g, escapeRe = /('|\\)/g, escapeRegexRe = /([-.*+?\^${}()|\[\]\/\\])/g, basicTrimRe = /^\s+|\s+$/g, whitespaceRe = /\s+/, varReplace = /(^[^a-z]*|[^\w])/gi, charToEntity, entityToChar, charToEntityRegex, 
  entityToCharRegex, htmlEncodeReplaceFn = function(match, capture) {
    return charToEntity[capture];
  }, htmlDecodeReplaceFn = function(match, capture) {
    return capture in entityToChar ? entityToChar[capture] : String.fromCharCode(parseInt(capture.substr(2), 10));
  }, boundsCheck = function(s, other) {
    if (s === null || s === undefined || other === null || other === undefined) {
      return false;
    }
    return other.length <= s.length;
  }, fromCharCode = String.fromCharCode, ExtString;
  return ExtString = {fromCodePoint:String.fromCodePoint || function() {
    var codePoint, result = '', codeUnits = [], index = -1, length = arguments.length;
    while (++index < length) {
      codePoint = Number(arguments[index]);
      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || Math.floor(codePoint) !== codePoint) {
        Ext.raise('Invalid code point: ' + codePoint);
      }
      if (codePoint <= 65535) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 65536;
        codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
      }
      if (index + 1 === length) {
        result += fromCharCode(codeUnits);
        codeUnits.length = 0;
      }
    }
    return result;
  }, insert:function(s, value, index) {
    if (!s) {
      return value;
    }
    if (!value) {
      return s;
    }
    var len = s.length;
    if (!index && index !== 0) {
      index = len;
    }
    if (index < 0) {
      index *= -1;
      if (index >= len) {
        index = 0;
      } else {
        index = len - index;
      }
    }
    if (index === 0) {
      s = value + s;
    } else {
      if (index >= s.length) {
        s += value;
      } else {
        s = s.substr(0, index) + value + s.substr(index);
      }
    }
    return s;
  }, startsWith:function(s, start, ignoreCase) {
    var result = boundsCheck(s, start);
    if (result) {
      if (ignoreCase) {
        s = s.toLowerCase();
        start = start.toLowerCase();
      }
      result = s.lastIndexOf(start, 0) === 0;
    }
    return result;
  }, endsWith:function(s, end, ignoreCase) {
    var result = boundsCheck(s, end);
    if (result) {
      if (ignoreCase) {
        s = s.toLowerCase();
        end = end.toLowerCase();
      }
      result = s.indexOf(end, s.length - end.length) !== -1;
    }
    return result;
  }, createVarName:function(s) {
    return s.replace(varReplace, '');
  }, htmlEncode:function(value) {
    return !value ? value : String(value).replace(charToEntityRegex, htmlEncodeReplaceFn);
  }, htmlDecode:function(value) {
    return !value ? value : String(value).replace(entityToCharRegex, htmlDecodeReplaceFn);
  }, hasHtmlCharacters:function(s) {
    return charToEntityRegex.test(s);
  }, addCharacterEntities:function(newEntities) {
    var charKeys = [], entityKeys = [], key, echar;
    for (key in newEntities) {
      echar = newEntities[key];
      entityToChar[key] = echar;
      charToEntity[echar] = key;
      charKeys.push(echar);
      entityKeys.push(key);
    }
    charToEntityRegex = new RegExp('(' + charKeys.join('|') + ')', 'g');
    entityToCharRegex = new RegExp('(' + entityKeys.join('|') + '|\x26#[0-9]{1,5};)', 'g');
  }, resetCharacterEntities:function() {
    charToEntity = {};
    entityToChar = {};
    this.addCharacterEntities({'\x26amp;':'\x26', '\x26gt;':'\x3e', '\x26lt;':'\x3c', '\x26quot;':'"', '\x26#39;':"'"});
  }, urlAppend:function(url, string) {
    if (!Ext.isEmpty(string)) {
      return url + (url.indexOf('?') === -1 ? '?' : '\x26') + string;
    }
    return url;
  }, trim:function(string) {
    if (string) {
      string = string.replace(trimRegex, '');
    }
    return string || '';
  }, capitalize:function(string) {
    if (string) {
      string = string.charAt(0).toUpperCase() + string.substr(1);
    }
    return string || '';
  }, uncapitalize:function(string) {
    if (string) {
      string = string.charAt(0).toLowerCase() + string.substr(1);
    }
    return string || '';
  }, ellipsis:function(value, length, word) {
    if (value && value.length > length) {
      if (word) {
        var vs = value.substr(0, length - 2), index = Math.max(vs.lastIndexOf(' '), vs.lastIndexOf('.'), vs.lastIndexOf('!'), vs.lastIndexOf('?'));
        if (index !== -1 && index >= length - 15) {
          return vs.substr(0, index) + '...';
        }
      }
      return value.substr(0, length - 3) + '...';
    }
    return value;
  }, escapeRegex:function(string) {
    return string.replace(escapeRegexRe, '\\$1');
  }, createRegex:function(value, startsWith, endsWith, ignoreCase) {
    var ret = value;
    if (value != null && !value.exec) {
      ret = ExtString.escapeRegex(String(value));
      if (startsWith !== false) {
        ret = '^' + ret;
      }
      if (endsWith !== false) {
        ret += '$';
      }
      ret = new RegExp(ret, ignoreCase !== false ? 'i' : '');
    }
    return ret;
  }, escape:function(string) {
    return string.replace(escapeRe, '\\$1');
  }, toggle:function(string, value, other) {
    return string === value ? other : value;
  }, leftPad:function(string, size, character) {
    var result = String(string);
    character = character || ' ';
    while (result.length < size) {
      result = character + result;
    }
    return result;
  }, repeat:function(pattern, count, sep) {
    if (count < 1) {
      count = 0;
    }
    for (var buf = [], i = count; i--;) {
      buf.push(pattern);
    }
    return buf.join(sep || '');
  }, splitWords:function(words) {
    if (words && typeof words == 'string') {
      return words.replace(basicTrimRe, '').split(whitespaceRe);
    }
    return words || [];
  }};
}();
Ext.String.resetCharacterEntities();
Ext.htmlEncode = Ext.String.htmlEncode;
Ext.htmlDecode = Ext.String.htmlDecode;
Ext.urlAppend = Ext.String.urlAppend;
Ext.Date = function() {
  var utilDate, nativeDate = Date, stripEscapeRe = /(\\.)/g, hourInfoRe = /([gGhHisucUOPZ]|MS)/, dateInfoRe = /([djzmnYycU]|MS)/, slashRe = /\\/gi, numberTokenRe = /\{(\d+)\}/g, MSFormatRe = new RegExp('\\/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\/'), pad = Ext.String.leftPad, monthInfo = {F:true, m:true, M:true, n:true}, yearInfo = {o:true, Y:true, y:true}, code = ['var me \x3d this, dt, y, m, d, h, i, s, ms, o, O, z, zz, u, v, W, year, jan4, week1monday, daysInMonth, dayMatched,', 'def \x3d me.defaults,', 
  'from \x3d Ext.Number.from,', 'results \x3d String(input).match(me.parseRegexes[{0}]);', 'if(results){', '{1}', 'if(u !\x3d null){', 'v \x3d new Date(u * 1000);', '}else{', 'dt \x3d me.clearTime(new Date);', 'y \x3d from(y, from(def.y, dt.getFullYear()));', 'm \x3d from(m, from(def.m - 1, dt.getMonth()));', 'dayMatched \x3d d !\x3d\x3d undefined;', 'd \x3d from(d, from(def.d, dt.getDate()));', 'if (!dayMatched) {', 'dt.setDate(1);', 'dt.setMonth(m);', 'dt.setFullYear(y);', 'daysInMonth \x3d me.getDaysInMonth(dt);', 
  'if (d \x3e daysInMonth) {', 'd \x3d daysInMonth;', '}', '}', 'h  \x3d from(h, from(def.h, dt.getHours()));', 'i  \x3d from(i, from(def.i, dt.getMinutes()));', 's  \x3d from(s, from(def.s, dt.getSeconds()));', 'ms \x3d from(ms, from(def.ms, dt.getMilliseconds()));', 'if(z \x3e\x3d 0 \x26\x26 y \x3e\x3d 0){', 'v \x3d me.add(new Date(y \x3c 100 ? 100 : y, 0, 1, h, i, s, ms), me.YEAR, y \x3c 100 ? y - 100 : 0);', 'v \x3d !strict? v : (strict \x3d\x3d\x3d true \x26\x26 (z \x3c\x3d 364 || (me.isLeapYear(v) \x26\x26 z \x3c\x3d 365))? me.add(v, me.DAY, z) : null);', 
  '}else if(strict \x3d\x3d\x3d true \x26\x26 !me.isValid(y, m + 1, d, h, i, s, ms)){', 'v \x3d null;', '}else{', 'if (W) {', 'year \x3d y || (new Date()).getFullYear();', 'jan4 \x3d new Date(year, 0, 4, 0, 0, 0);', 'd \x3d jan4.getDay();', 'week1monday \x3d new Date(jan4.getTime() - ((d \x3d\x3d\x3d 0 ? 6 : d - 1) * 86400000));', 'v \x3d Ext.Date.clearTime(new Date(week1monday.getTime() + ((W - 1) * 604800000 + 43200000)));', '} else {', 'v \x3d me.add(new Date(y \x3c 100 ? 100 : y, m, d, h, i, s, ms), me.YEAR, y \x3c 100 ? y - 100 : 0);', 
  '}', '}', '}', '}', 'if(v){', 'if(zz !\x3d null){', 'v \x3d me.add(v, me.SECOND, -v.getTimezoneOffset() * 60 - zz);', '}else if(o){', "v \x3d me.add(v, me.MINUTE, -v.getTimezoneOffset() + (sn \x3d\x3d '+'? -1 : 1) * (hr * 60 + mn));", '}', '}', 'return (v !\x3d null) ? v : null;'].join('\n');
  if (!Date.prototype.toISOString) {
    Date.prototype.toISOString = function() {
      var me = this;
      return pad(me.getUTCFullYear(), 4, '0') + '-' + pad(me.getUTCMonth() + 1, 2, '0') + '-' + pad(me.getUTCDate(), 2, '0') + 'T' + pad(me.getUTCHours(), 2, '0') + ':' + pad(me.getUTCMinutes(), 2, '0') + ':' + pad(me.getUTCSeconds(), 2, '0') + '.' + pad(me.getUTCMilliseconds(), 3, '0') + 'Z';
    };
  }
  function xf(format) {
    var args = Array.prototype.slice.call(arguments, 1);
    return format.replace(numberTokenRe, function(m, i) {
      return args[i];
    });
  }
  utilDate = {now:nativeDate.now, toString:function(date) {
    if (!date) {
      date = new nativeDate;
    }
    return date.getFullYear() + '-' + pad(date.getMonth() + 1, 2, '0') + '-' + pad(date.getDate(), 2, '0') + 'T' + pad(date.getHours(), 2, '0') + ':' + pad(date.getMinutes(), 2, '0') + ':' + pad(date.getSeconds(), 2, '0');
  }, getElapsed:function(dateA, dateB) {
    return Math.abs(dateA - (dateB || utilDate.now()));
  }, useStrict:false, formatCodeToRegex:function(character, currentGroup) {
    var p = utilDate.parseCodes[character];
    if (p) {
      p = typeof p === 'function' ? p() : p;
      utilDate.parseCodes[character] = p;
    }
    return p ? Ext.applyIf({c:p.c ? xf(p.c, currentGroup || '{0}') : p.c}, p) : {g:0, c:null, s:Ext.String.escapeRegex(character)};
  }, parseFunctions:{'MS':function(input, strict) {
    var r = (input || '').match(MSFormatRe);
    return r ? new nativeDate(((r[1] || '') + r[2]) * 1) : null;
  }, 'time':function(input, strict) {
    var num = parseInt(input, 10);
    if (num || num === 0) {
      return new nativeDate(num);
    }
    return null;
  }, 'timestamp':function(input, strict) {
    var num = parseInt(input, 10);
    if (num || num === 0) {
      return new nativeDate(num * 1000);
    }
    return null;
  }}, parseRegexes:[], formatFunctions:{'MS':function() {
    return '\\/Date(' + this.getTime() + ')\\/';
  }, 'time':function() {
    return this.getTime().toString();
  }, 'timestamp':function() {
    return utilDate.format(this, 'U');
  }}, y2kYear:50, MILLI:'ms', SECOND:'s', MINUTE:'mi', HOUR:'h', DAY:'d', MONTH:'mo', YEAR:'y', DAYS_IN_WEEK:7, MONTHS_IN_YEAR:12, MAX_DAYS_IN_MONTH:31, SUNDAY:0, MONDAY:1, TUESDAY:2, WEDNESDAY:3, THURSDAY:4, FRIDAY:5, SATURDAY:6, defaults:{}, dayNames:['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], monthNames:['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], monthNumbers:{January:0, Jan:0, February:1, 
  Feb:1, March:2, Mar:2, April:3, Apr:3, May:4, June:5, Jun:5, July:6, Jul:6, August:7, Aug:7, September:8, Sep:8, October:9, Oct:9, November:10, Nov:10, December:11, Dec:11}, defaultFormat:'m/d/Y', defaultTimeFormat:'h:i A', firstDayOfWeek:0, weekendDays:[0, 6], getShortMonthName:function(month) {
    return utilDate.monthNames[month].substring(0, 3);
  }, getShortDayName:function(day) {
    return utilDate.dayNames[day].substring(0, 3);
  }, getMonthNumber:function(name) {
    return utilDate.monthNumbers[name.substring(0, 1).toUpperCase() + name.substring(1, 3).toLowerCase()];
  }, formatContainsHourInfo:function(format) {
    return hourInfoRe.test(format.replace(stripEscapeRe, ''));
  }, formatContainsDateInfo:function(format) {
    return dateInfoRe.test(format.replace(stripEscapeRe, ''));
  }, isMonthFormat:function(format) {
    return !!monthInfo[format];
  }, isYearFormat:function(format) {
    return !!yearInfo[format];
  }, unescapeFormat:function(format) {
    return format.replace(slashRe, '');
  }, formatCodes:{d:"Ext.String.leftPad(m.getDate(), 2, '0')", D:'Ext.Date.getShortDayName(m.getDay())', j:'m.getDate()', l:'Ext.Date.dayNames[m.getDay()]', N:'(m.getDay() ? m.getDay() : 7)', S:'Ext.Date.getSuffix(m)', w:'m.getDay()', z:'Ext.Date.getDayOfYear(m)', W:"Ext.String.leftPad(Ext.Date.getWeekOfYear(m), 2, '0')", F:'Ext.Date.monthNames[m.getMonth()]', m:"Ext.String.leftPad(m.getMonth() + 1, 2, '0')", M:'Ext.Date.getShortMonthName(m.getMonth())', n:'(m.getMonth() + 1)', t:'Ext.Date.getDaysInMonth(m)', 
  L:'(Ext.Date.isLeapYear(m) ? 1 : 0)', o:'(m.getFullYear() + (Ext.Date.getWeekOfYear(m) \x3d\x3d 1 \x26\x26 m.getMonth() \x3e 0 ? +1 : (Ext.Date.getWeekOfYear(m) \x3e\x3d 52 \x26\x26 m.getMonth() \x3c 11 ? -1 : 0)))', Y:"Ext.String.leftPad(m.getFullYear(), 4, '0')", y:"('' + m.getFullYear()).substring(2, 4)", a:"(m.getHours() \x3c 12 ? 'am' : 'pm')", A:"(m.getHours() \x3c 12 ? 'AM' : 'PM')", g:'((m.getHours() % 12) ? m.getHours() % 12 : 12)', G:'m.getHours()', h:"Ext.String.leftPad((m.getHours() % 12) ? m.getHours() % 12 : 12, 2, '0')", 
  H:"Ext.String.leftPad(m.getHours(), 2, '0')", i:"Ext.String.leftPad(m.getMinutes(), 2, '0')", s:"Ext.String.leftPad(m.getSeconds(), 2, '0')", u:"Ext.String.leftPad(m.getMilliseconds(), 3, '0')", O:'Ext.Date.getGMTOffset(m)', P:'Ext.Date.getGMTOffset(m, true)', T:'Ext.Date.getTimezone(m)', Z:'(m.getTimezoneOffset() * -60)', c:function() {
    var c = 'Y-m-dTH:i:sP', code = [], i, l = c.length, e;
    for (i = 0; i < l; ++i) {
      e = c.charAt(i);
      code.push(e === 'T' ? "'T'" : utilDate.getFormatCode(e));
    }
    return code.join(' + ');
  }, C:function() {
    return 'm.toISOString()';
  }, U:'Math.round(m.getTime() / 1000)'}, isValid:function(year, month, day, hour, minute, second, millisecond) {
    hour = hour || 0;
    minute = minute || 0;
    second = second || 0;
    millisecond = millisecond || 0;
    var dt = utilDate.add(new nativeDate(year < 100 ? 100 : year, month - 1, day, hour, minute, second, millisecond), utilDate.YEAR, year < 100 ? year - 100 : 0);
    return year === dt.getFullYear() && month === dt.getMonth() + 1 && day === dt.getDate() && hour === dt.getHours() && minute === dt.getMinutes() && second === dt.getSeconds() && millisecond === dt.getMilliseconds();
  }, parse:function(input, format, strict) {
    var p = utilDate.parseFunctions;
    if (p[format] == null) {
      utilDate.createParser(format);
    }
    return p[format].call(utilDate, input, Ext.isDefined(strict) ? strict : utilDate.useStrict);
  }, parseDate:function(input, format, strict) {
    return utilDate.parse(input, format, strict);
  }, getFormatCode:function(character) {
    var f = utilDate.formatCodes[character];
    if (f) {
      f = typeof f === 'function' ? f() : f;
      utilDate.formatCodes[character] = f;
    }
    return f || "'" + Ext.String.escape(character) + "'";
  }, createFormat:function(format) {
    var code = [], special = false, ch = '', i;
    for (i = 0; i < format.length; ++i) {
      ch = format.charAt(i);
      if (!special && ch === '\\') {
        special = true;
      } else {
        if (special) {
          special = false;
          code.push("'" + Ext.String.escape(ch) + "'");
        } else {
          if (ch === '\n') {
            code.push("'\\n'");
          } else {
            code.push(utilDate.getFormatCode(ch));
          }
        }
      }
    }
    utilDate.formatFunctions[format] = Ext.functionFactory('var m\x3dthis;return ' + code.join('+'));
  }, createParser:function(format) {
    var regexNum = utilDate.parseRegexes.length, currentGroup = 1, calc = [], regex = [], special = false, ch = '', i = 0, len = format.length, atEnd = [], obj;
    for (; i < len; ++i) {
      ch = format.charAt(i);
      if (!special && ch === '\\') {
        special = true;
      } else {
        if (special) {
          special = false;
          regex.push(Ext.String.escape(ch));
        } else {
          obj = utilDate.formatCodeToRegex(ch, currentGroup);
          currentGroup += obj.g;
          regex.push(obj.s);
          if (obj.g && obj.c) {
            if (obj.calcAtEnd) {
              atEnd.push(obj.c);
            } else {
              calc.push(obj.c);
            }
          }
        }
      }
    }
    calc = calc.concat(atEnd);
    utilDate.parseRegexes[regexNum] = new RegExp('^' + regex.join('') + '$', 'i');
    utilDate.parseFunctions[format] = Ext.functionFactory('input', 'strict', xf(code, regexNum, calc.join('')));
  }, parseCodes:{d:{g:1, c:'d \x3d parseInt(results[{0}], 10);\n', s:'(3[0-1]|[1-2][0-9]|0[1-9])'}, j:{g:1, c:'d \x3d parseInt(results[{0}], 10);\n', s:'(3[0-1]|[1-2][0-9]|[1-9])'}, D:function() {
    for (var a = [], i = 0; i < 7; a.push(utilDate.getShortDayName(i)), ++i) {
    }
    return {g:0, c:null, s:'(?:' + a.join('|') + ')'};
  }, l:function() {
    return {g:0, c:null, s:'(?:' + utilDate.dayNames.join('|') + ')'};
  }, N:{g:0, c:null, s:'[1-7]'}, S:{g:0, c:null, s:'(?:st|nd|rd|th)'}, w:{g:0, c:null, s:'[0-6]'}, z:{g:1, c:'z \x3d parseInt(results[{0}], 10);\n', s:'(\\d{1,3})'}, W:{g:1, c:'W \x3d parseInt(results[{0}], 10);\n', s:'(\\d{2})'}, F:function() {
    return {g:1, c:'m \x3d parseInt(me.getMonthNumber(results[{0}]), 10);\n', s:'(' + utilDate.monthNames.join('|') + ')'};
  }, M:function() {
    for (var a = [], i = 0; i < 12; a.push(utilDate.getShortMonthName(i)), ++i) {
    }
    return Ext.applyIf({s:'(' + a.join('|') + ')'}, utilDate.formatCodeToRegex('F'));
  }, m:{g:1, c:'m \x3d parseInt(results[{0}], 10) - 1;\n', s:'(1[0-2]|0[1-9])'}, n:{g:1, c:'m \x3d parseInt(results[{0}], 10) - 1;\n', s:'(1[0-2]|[1-9])'}, t:{g:0, c:null, s:'(?:\\d{2})'}, L:{g:0, c:null, s:'(?:1|0)'}, o:{g:1, c:'y \x3d parseInt(results[{0}], 10);\n', s:'(\\d{4})'}, Y:{g:1, c:'y \x3d parseInt(results[{0}], 10);\n', s:'(\\d{4})'}, y:{g:1, c:'var ty \x3d parseInt(results[{0}], 10);\ny \x3d ty \x3e me.y2kYear ? 1900 + ty : 2000 + ty;\n', s:'(\\d{2})'}, a:{g:1, c:'if (/(am)/i.test(results[{0}])) {\nif (!h || h \x3d\x3d 12) { h \x3d 0; }\n} else { if (!h || h \x3c 12) { h \x3d (h || 0) + 12; }}', 
  s:'(am|pm|AM|PM)', calcAtEnd:true}, A:{g:1, c:'if (/(am)/i.test(results[{0}])) {\nif (!h || h \x3d\x3d 12) { h \x3d 0; }\n} else { if (!h || h \x3c 12) { h \x3d (h || 0) + 12; }}', s:'(AM|PM|am|pm)', calcAtEnd:true}, g:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(1[0-2]|[0-9])'}, G:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(2[0-3]|1[0-9]|[0-9])'}, h:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(1[0-2]|0[1-9])'}, H:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(2[0-3]|[0-1][0-9])'}, 
  i:{g:1, c:'i \x3d parseInt(results[{0}], 10);\n', s:'([0-5][0-9])'}, s:{g:1, c:'s \x3d parseInt(results[{0}], 10);\n', s:'([0-5][0-9])'}, u:{g:1, c:'ms \x3d results[{0}]; ms \x3d parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n', s:'(\\d+)'}, O:{g:1, c:['o \x3d results[{0}];', 'var sn \x3d o.substring(0,1),', 'hr \x3d o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),', 'mn \x3d o.substring(3,5) % 60;', "o \x3d ((-12 \x3c\x3d (hr*60 + mn)/60) \x26\x26 ((hr*60 + mn)/60 \x3c\x3d 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join('\n'), 
  s:'([+-]\\d{4})'}, P:{g:1, c:['o \x3d results[{0}];', 'var sn \x3d o.substring(0,1),', 'hr \x3d o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),', 'mn \x3d o.substring(4,6) % 60;', "o \x3d ((-12 \x3c\x3d (hr*60 + mn)/60) \x26\x26 ((hr*60 + mn)/60 \x3c\x3d 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join('\n'), s:'([+-]\\d{2}:\\d{2})'}, T:{g:0, c:null, s:'[A-Z]{1,5}'}, Z:{g:1, c:'zz \x3d results[{0}] * 1;\nzz \x3d (-43200 \x3c\x3d zz \x26\x26 zz \x3c\x3d 50400)? zz : null;\n', 
  s:'([+-]?\\d{1,5})'}, c:function() {
    var calc = [], arr = [utilDate.formatCodeToRegex('Y', 1), utilDate.formatCodeToRegex('m', 2), utilDate.formatCodeToRegex('d', 3), utilDate.formatCodeToRegex('H', 4), utilDate.formatCodeToRegex('i', 5), utilDate.formatCodeToRegex('s', 6), {c:"ms \x3d results[7] || '0'; ms \x3d parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n"}, {c:['if(results[8]) {', "if(results[8] \x3d\x3d 'Z'){", 'zz \x3d 0;', "}else if (results[8].indexOf(':') \x3e -1){", utilDate.formatCodeToRegex('P', 8).c, '}else{', utilDate.formatCodeToRegex('O', 
    8).c, '}', '}'].join('\n')}], i, l;
    for (i = 0, l = arr.length; i < l; ++i) {
      calc.push(arr[i].c);
    }
    return {g:1, c:calc.join(''), s:[arr[0].s, '(?:', '-', arr[1].s, '(?:', '-', arr[2].s, '(?:', '(?:T| )?', arr[3].s, ':', arr[4].s, '(?::', arr[5].s, ')?', '(?:(?:\\.|,)(\\d+))?', '(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?', ')?', ')?', ')?'].join('')};
  }, U:{g:1, c:'u \x3d parseInt(results[{0}], 10);\n', s:'(-?\\d+)'}}, dateFormat:function(date, format) {
    return utilDate.format(date, format);
  }, isEqual:function(date1, date2) {
    if (date1 && date2) {
      return date1.getTime() === date2.getTime();
    }
    return !(date1 || date2);
  }, format:function(date, format) {
    var formatFunctions = utilDate.formatFunctions;
    if (!Ext.isDate(date)) {
      return '';
    }
    if (formatFunctions[format] == null) {
      utilDate.createFormat(format);
    }
    return formatFunctions[format].call(date) + '';
  }, getTimezone:function(date) {
    return date.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,5})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, '$1$2').replace(/[^A-Z]/g, '');
  }, getGMTOffset:function(date, colon) {
    var offset = date.getTimezoneOffset();
    return (offset > 0 ? '-' : '+') + Ext.String.leftPad(Math.floor(Math.abs(offset) / 60), 2, '0') + (colon ? ':' : '') + Ext.String.leftPad(Math.abs(offset % 60), 2, '0');
  }, getDayOfYear:function(date) {
    var num = 0, d = utilDate.clone(date), m = date.getMonth(), i;
    for (i = 0, d.setDate(1), d.setMonth(0); i < m; d.setMonth(++i)) {
      num += utilDate.getDaysInMonth(d);
    }
    return num + date.getDate() - 1;
  }, getWeekOfYear:function() {
    var ms1d = 86400000, ms7d = 7 * ms1d;
    return function(date) {
      var DC3 = nativeDate.UTC(date.getFullYear(), date.getMonth(), date.getDate() + 3) / ms1d, AWN = Math.floor(DC3 / 7), Wyr = (new nativeDate(AWN * ms7d)).getUTCFullYear();
      return AWN - Math.floor(nativeDate.UTC(Wyr, 0, 7) / ms7d) + 1;
    };
  }(), isLeapYear:function(date) {
    var year = date.getFullYear();
    return !!((year & 3) === 0 && (year % 100 || year % 400 === 0 && year));
  }, getFirstDayOfMonth:function(date) {
    var day = (date.getDay() - (date.getDate() - 1)) % 7;
    return day < 0 ? day + 7 : day;
  }, getLastDayOfMonth:function(date) {
    return utilDate.getLastDateOfMonth(date).getDay();
  }, getFirstDateOfMonth:function(date) {
    return new nativeDate(date.getFullYear(), date.getMonth(), 1);
  }, getLastDateOfMonth:function(date) {
    return new nativeDate(date.getFullYear(), date.getMonth(), utilDate.getDaysInMonth(date));
  }, getDaysInMonth:function() {
    var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    return function(date) {
      var m = date.getMonth();
      return m === 1 && utilDate.isLeapYear(date) ? 29 : daysInMonth[m];
    };
  }(), getSuffix:function(date) {
    switch(date.getDate()) {
      case 1:
      case 21:
      case 31:
        return 'st';
      case 2:
      case 22:
        return 'nd';
      case 3:
      case 23:
        return 'rd';
      default:
        return 'th';
    }
  }, clone:function(date) {
    return new nativeDate(date.getTime());
  }, isDST:function(date) {
    return (new nativeDate(date.getFullYear(), 0, 1)).getTimezoneOffset() !== date.getTimezoneOffset();
  }, clearTime:function(date, clone) {
    if (isNaN(date.getTime())) {
      return date;
    }
    if (clone) {
      return utilDate.clearTime(utilDate.clone(date));
    }
    var d = date.getDate(), hr, c;
    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    if (date.getDate() !== d) {
      for (hr = 1, c = utilDate.add(date, utilDate.HOUR, hr); c.getDate() !== d; hr++, c = utilDate.add(date, utilDate.HOUR, hr)) {
      }
      date.setDate(d);
      date.setHours(c.getHours());
    }
    return date;
  }, add:function(date, interval, value, preventDstAdjust) {
    var d = utilDate.clone(date), base = 0, day, decimalValue;
    if (!interval || value === 0) {
      return d;
    }
    decimalValue = value - parseInt(value, 10);
    value = parseInt(value, 10);
    if (value) {
      switch(interval.toLowerCase()) {
        case utilDate.MILLI:
          if (preventDstAdjust) {
            d.setMilliseconds(d.getMilliseconds() + value);
          } else {
            d.setTime(d.getTime() + value);
          }
          break;
        case utilDate.SECOND:
          if (preventDstAdjust) {
            d.setSeconds(d.getSeconds() + value);
          } else {
            d.setTime(d.getTime() + value * 1000);
          }
          break;
        case utilDate.MINUTE:
          if (preventDstAdjust) {
            d.setMinutes(d.getMinutes() + value);
          } else {
            d.setTime(d.getTime() + value * 60 * 1000);
          }
          break;
        case utilDate.HOUR:
          if (preventDstAdjust) {
            d.setHours(d.getHours() + value);
          } else {
            d.setTime(d.getTime() + value * 60 * 60 * 1000);
          }
          break;
        case utilDate.DAY:
          d.setDate(d.getDate() + value);
          break;
        case utilDate.MONTH:
          day = date.getDate();
          if (day > 28) {
            day = Math.min(day, utilDate.getLastDateOfMonth(utilDate.add(utilDate.getFirstDateOfMonth(date), utilDate.MONTH, value)).getDate());
          }
          d.setDate(day);
          d.setMonth(date.getMonth() + value);
          break;
        case utilDate.YEAR:
          day = date.getDate();
          if (day > 28) {
            day = Math.min(day, utilDate.getLastDateOfMonth(utilDate.add(utilDate.getFirstDateOfMonth(date), utilDate.YEAR, value)).getDate());
          }
          d.setDate(day);
          d.setFullYear(date.getFullYear() + value);
          break;
      }
    }
    if (decimalValue) {
      switch(interval.toLowerCase()) {
        case utilDate.MILLI:
          base = 1;
          break;
        case utilDate.SECOND:
          base = 1000;
          break;
        case utilDate.MINUTE:
          base = 1000 * 60;
          break;
        case utilDate.HOUR:
          base = 1000 * 60 * 60;
          break;
        case utilDate.DAY:
          base = 1000 * 60 * 60 * 24;
          break;
        case utilDate.MONTH:
          day = utilDate.getDaysInMonth(d);
          base = 1000 * 60 * 60 * 24 * day;
          break;
        case utilDate.YEAR:
          day = utilDate.isLeapYear(d) ? 366 : 365;
          base = 1000 * 60 * 60 * 24 * day;
          break;
      }
      if (base) {
        d.setTime(d.getTime() + base * decimalValue);
      }
    }
    return d;
  }, subtract:function(date, interval, value, preventDstAdjust) {
    return utilDate.add(date, interval, -value, preventDstAdjust);
  }, between:function(date, start, end) {
    var t = date.getTime();
    return start.getTime() <= t && t <= end.getTime();
  }, isWeekend:function(date) {
    return Ext.Array.indexOf(this.weekendDays, date.getDay()) > -1;
  }, utcToLocal:function(d) {
    return new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
  }, localToUtc:function(d) {
    return utilDate.utc(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
  }, utc:function(year, month, day, hour, min, s, ms) {
    return new Date(Date.UTC(year, month, day, hour || 0, min || 0, s || 0, ms || 0));
  }, compat:function() {
    var p, statics = ['useStrict', 'formatCodeToRegex', 'parseFunctions', 'parseRegexes', 'formatFunctions', 'y2kYear', 'MILLI', 'SECOND', 'MINUTE', 'HOUR', 'DAY', 'MONTH', 'YEAR', 'defaults', 'dayNames', 'monthNames', 'monthNumbers', 'getShortMonthName', 'getShortDayName', 'getMonthNumber', 'formatCodes', 'isValid', 'parseDate', 'getFormatCode', 'createFormat', 'createParser', 'parseCodes'], proto = ['dateFormat', 'format', 'getTimezone', 'getGMTOffset', 'getDayOfYear', 'getWeekOfYear', 'isLeapYear', 
    'getFirstDayOfMonth', 'getLastDayOfMonth', 'getDaysInMonth', 'getSuffix', 'clone', 'isDST', 'clearTime', 'add', 'between'], sLen = statics.length, pLen = proto.length, stat, prot, s;
    for (s = 0; s < sLen; s++) {
      stat = statics[s];
      nativeDate[stat] = utilDate[stat];
    }
    for (p = 0; p < pLen; p++) {
      prot = proto[p];
      nativeDate.prototype[prot] = function() {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(this);
        return utilDate[prot].apply(utilDate, args);
      };
    }
  }, diff:function(min, max, unit) {
    var est, diff = +max - min;
    switch(unit) {
      case utilDate.MILLI:
        return diff;
      case utilDate.SECOND:
        return Math.floor(diff / 1000);
      case utilDate.MINUTE:
        return Math.floor(diff / 60000);
      case utilDate.HOUR:
        return Math.floor(diff / 3600000);
      case utilDate.DAY:
        return Math.floor(diff / 86400000);
      case 'w':
        return Math.floor(diff / 604800000);
      case utilDate.MONTH:
        est = max.getFullYear() * 12 + max.getMonth() - (min.getFullYear() * 12 + min.getMonth());
        if (utilDate.add(min, unit, est) > max) {
          return est - 1;
        }
        return est;
      case utilDate.YEAR:
        est = max.getFullYear() - min.getFullYear();
        if (utilDate.add(min, unit, est) > max) {
          return est - 1;
        } else {
          return est;
        }
    }
  }, align:function(date, unit, step) {
    var num = new nativeDate(+date);
    switch(unit.toLowerCase()) {
      case utilDate.MILLI:
        return num;
      case utilDate.SECOND:
        num.setUTCSeconds(num.getUTCSeconds() - num.getUTCSeconds() % step);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.MINUTE:
        num.setUTCMinutes(num.getUTCMinutes() - num.getUTCMinutes() % step);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.HOUR:
        num.setUTCHours(num.getUTCHours() - num.getUTCHours() % step);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.DAY:
        if (step === 7 || step === 14) {
          num.setUTCDate(num.getUTCDate() - num.getUTCDay() + 1);
        }
        num.setUTCHours(0);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.MONTH:
        num.setUTCMonth(num.getUTCMonth() - (num.getUTCMonth() - 1) % step, 1);
        num.setUTCHours(0);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.YEAR:
        num.setUTCFullYear(num.getUTCFullYear() - num.getUTCFullYear() % step, 1, 1);
        num.setUTCHours(0);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return date;
    }
  }};
  utilDate.parseCodes.C = utilDate.parseCodes.c;
  return utilDate;
}();
Ext.Function = function() {
  var lastTime = 0, animFrameId, animFrameHandlers = [], animFrameNoArgs = [], idSource = 0, animFrameMap = {}, slice = Array.prototype.slice, win = window, global = Ext.global, hasImmediate = !Ext.disableImmediate && !!(global.setImmediate && global.clearImmediate), requestAnimFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || function(callback) {
    var currTime = Ext.now(), timeToCall = Math.max(0, 16 - (currTime - lastTime)), timerFn = function() {
      callback(currTime + timeToCall);
    }, id;
    id = win.setTimeout(timerFn, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  }, fireHandlers = function() {
    var len = animFrameHandlers.length, id, i, handler;
    animFrameId = null;
    for (i = 0; i < len; i++) {
      handler = animFrameHandlers[i];
      id = handler[3];
      if (animFrameMap[id]) {
        delete animFrameMap[id];
        handler[0].apply(handler[1] || global, handler[2] || animFrameNoArgs);
      }
    }
    animFrameHandlers = animFrameHandlers.slice(len);
  }, fireElevatedHandlers = function() {
    Ext.elevate(fireHandlers);
  }, ExtFunction = {flexSetter:function(setter) {
    return function(name, value) {
      var k, i;
      if (name !== null) {
        if (typeof name !== 'string') {
          for (k in name) {
            if (name.hasOwnProperty(k)) {
              setter.call(this, k, name[k]);
            }
          }
          if (Ext.enumerables) {
            for (i = Ext.enumerables.length; i--;) {
              k = Ext.enumerables[i];
              if (name.hasOwnProperty(k)) {
                setter.call(this, k, name[k]);
              }
            }
          }
        } else {
          setter.call(this, name, value);
        }
      }
      return this;
    };
  }, bind:function(fn, scope, args, appendArgs) {
    if (arguments.length <= 2) {
      return fn.bind(scope);
    }
    var method = fn;
    return function() {
      var callArgs = args || arguments;
      if (appendArgs === true) {
        callArgs = slice.call(arguments, 0);
        callArgs = callArgs.concat(args);
      } else {
        if (typeof appendArgs === 'number') {
          callArgs = slice.call(arguments, 0);
          Ext.Array.insert(callArgs, appendArgs, args);
        }
      }
      return method.apply(scope || global, callArgs);
    };
  }, bindCallback:function(callback, scope, args, delay, caller) {
    return function() {
      var a = slice.call(arguments);
      return Ext.callback(callback, scope, args ? args.concat(a) : a, delay, caller);
    };
  }, pass:function(fn, args, scope) {
    if (!Ext.isArray(args)) {
      if (Ext.isIterable(args)) {
        args = Ext.Array.clone(args);
      } else {
        args = args !== undefined ? [args] : [];
      }
    }
    return function() {
      var fnArgs = args.slice();
      fnArgs.push.apply(fnArgs, arguments);
      return fn.apply(scope || this, fnArgs);
    };
  }, alias:function(object, methodName) {
    return function() {
      return object[methodName].apply(object, arguments);
    };
  }, clone:function(method) {
    var newMethod, prop;
    newMethod = function() {
      return method.apply(this, arguments);
    };
    for (prop in method) {
      if (method.hasOwnProperty(prop)) {
        newMethod[prop] = method[prop];
      }
    }
    return newMethod;
  }, createInterceptor:function(origFn, newFn, scope, returnValue) {
    if (!Ext.isFunction(newFn)) {
      return origFn;
    } else {
      returnValue = Ext.isDefined(returnValue) ? returnValue : null;
      return function() {
        var me = this, args = arguments;
        return newFn.apply(scope || me || global, args) !== false ? origFn.apply(me || global, args) : returnValue;
      };
    }
  }, createDelayed:function(fn, delay, scope, args, appendArgs) {
    var boundFn = fn;
    if (scope || args) {
      boundFn = Ext.Function.bind(fn, scope, args, appendArgs);
    }
    return function() {
      var me = this, args = slice.call(arguments), timerFn, timerId;
      timerFn = function() {
        Ext.elevate(boundFn, me, args);
      };
      timerId = setTimeout(timerFn, delay);
    };
  }, defer:function(fn, millis, scope, args, appendArgs) {
    var timerId = 0, timerFn, boundFn;
    if (!scope && !args && !appendArgs) {
      boundFn = fn;
    } else {
      boundFn = Ext.Function.bind(fn, scope, args, appendArgs);
    }
    if (millis > 0) {
      timerFn = function() {
        Ext.elevate(boundFn);
      };
      timerId = setTimeout(timerFn, millis);
    } else {
      boundFn();
    }
    return timerId;
  }, interval:function(fn, millis, scope, args, appendArgs) {
    var timerFn, timerId, boundFn;
    boundFn = Ext.Function.bind(fn, scope, args, appendArgs);
    timerFn = function() {
      Ext.elevate(boundFn);
    };
    timerId = setInterval(timerFn, millis);
    return timerId;
  }, createSequence:function(originalFn, newFn, scope) {
    if (!newFn) {
      return originalFn;
    } else {
      return function() {
        var result = originalFn.apply(this, arguments);
        newFn.apply(scope || this, arguments);
        return result;
      };
    }
  }, createBuffered:function(fn, buffer, scope, args) {
    var timerId, result = function() {
      var callArgs = args || slice.call(arguments, 0), me = scope || this, timerFn;
      if (timerId) {
        Ext.undefer(timerId);
      }
      timerFn = function() {
        Ext.elevate(fn, me, callArgs);
      };
      result.timer = timerId = setTimeout(timerFn, buffer);
    };
    return result;
  }, createAnimationFrame:function(fn, scope, args, queueStrategy) {
    var boundFn, timerId;
    queueStrategy = queueStrategy || 3;
    boundFn = function() {
      var timerFn, callArgs = args || slice.call(arguments, 0);
      scope = scope || this;
      if (queueStrategy === 3 && timerId) {
        ExtFunction.cancelAnimationFrame(timerId);
      }
      if (queueStrategy & 1 || !timerId) {
        timerFn = function() {
          timerId = boundFn.timerId = null;
          fn.apply(scope, callArgs);
        };
        timerId = boundFn.timerId = ExtFunction.requestAnimationFrame(timerFn);
      }
    };
    return boundFn;
  }, requestAnimationFrame:function(fn, scope, args) {
    var id = ++idSource, handler = slice.call(arguments, 0);
    handler[3] = id;
    animFrameMap[id] = 1;
    animFrameHandlers.push(handler);
    if (!animFrameId) {
      animFrameId = requestAnimFrame(fireElevatedHandlers);
    }
    return id;
  }, cancelAnimationFrame:function(id) {
    delete animFrameMap[id];
  }, createThrottled:function(fn, interval, scope) {
    var lastCallTime = 0, elapsed, lastArgs, timerId, execute = function() {
      fn.apply(scope, lastArgs);
      lastCallTime = Ext.now();
      lastArgs = timerId = null;
    };
    return function() {
      if (!scope) {
        scope = this;
      }
      elapsed = Ext.now() - lastCallTime;
      lastArgs = Ext.Array.slice(arguments);
      if (elapsed >= interval) {
        Ext.undefer(timerId);
        execute();
      } else {
        if (!timerId) {
          timerId = Ext.defer(execute, interval - elapsed);
        }
      }
    };
  }, createBarrier:function(count, fn, scope) {
    var barrierFn = function() {
      if (!--count) {
        fn.apply(scope, arguments);
      }
    };
    return barrierFn;
  }, interceptBefore:function(object, methodName, fn, scope) {
    var method = object[methodName] || Ext.emptyFn;
    return object[methodName] = function() {
      var ret = fn.apply(scope || this, arguments);
      method.apply(this, arguments);
      return ret;
    };
  }, interceptAfter:function(object, methodName, fn, scope) {
    var method = object[methodName] || Ext.emptyFn;
    return object[methodName] = function() {
      method.apply(this, arguments);
      return fn.apply(scope || this, arguments);
    };
  }, interceptAfterOnce:function(object, methodName, fn, scope) {
    var origMethod = object[methodName], newMethod;
    newMethod = function() {
      var ret;
      if (origMethod) {
        origMethod.apply(this, arguments);
      }
      ret = fn.apply(scope || this, arguments);
      object[methodName] = origMethod;
      object = methodName = fn = scope = origMethod = newMethod = null;
      return ret;
    };
    object[methodName] = newMethod;
    return newMethod;
  }, makeCallback:function(callback, scope) {
    return function() {
      return scope[callback].apply(scope, arguments);
    };
  }, memoize:function(fn, scope, hashFn) {
    var memo = {}, isFunc = hashFn && Ext.isFunction(hashFn);
    return function(value) {
      var key = isFunc ? hashFn.apply(scope, arguments) : value;
      if (!(key in memo)) {
        memo[key] = fn.apply(scope, arguments);
      }
      return memo[key];
    };
  }, toCode:function(fn) {
    var s = fn ? fn.toString() : '';
    return s;
  }};
  Ext.asap = hasImmediate ? function(fn, scope, parameters) {
    var boundFn = fn, timerFn, timerId;
    if (scope != null || parameters != null) {
      boundFn = ExtFunction.bind(fn, scope, parameters);
    }
    timerFn = function() {
      Ext.elevate(boundFn);
    };
    timerId = setImmediate(timerFn);
    return timerId;
  } : function(fn, scope, parameters) {
    var boundFn = fn, timerFn, timerId;
    if (scope != null || parameters != null) {
      boundFn = ExtFunction.bind(fn, scope, parameters);
    }
    timerFn = function() {
      Ext.elevate(boundFn);
    };
    timerId = setTimeout(timerFn, 0, true);
    return timerId;
  };
  Ext.unasap = hasImmediate ? function(id) {
    if (id) {
      clearImmediate(id);
    }
    return null;
  } : function(id) {
    return Ext.undefer(id);
  };
  Ext.asapCancel = function(id) {
    return Ext.unasap(id);
  };
  Ext.defer = ExtFunction.defer;
  Ext.undefer = function(id) {
    if (id) {
      clearTimeout(id);
    }
    return null;
  };
  Ext.interval = ExtFunction.interval;
  Ext.uninterval = function(id) {
    if (id) {
      clearInterval(id);
    }
    return null;
  };
  Ext.pass = ExtFunction.pass;
  Ext.bind = ExtFunction.bind;
  Ext.raf = function() {
    return ExtFunction.requestAnimationFrame.apply(ExtFunction, arguments);
  };
  Ext.unraf = function(id) {
    ExtFunction.cancelAnimationFrame(id);
  };
  return ExtFunction;
}();
Ext.Number = new function() {
  var ExtNumber = this, isToFixedBroken = (0.9).toFixed() !== '1', math = Math, ClipDefault = {count:false, inclusive:false, wrap:true};
  Number.MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -(math.pow(2, 53) - 1);
  Number.MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || math.pow(2, 53) - 1;
  Ext.apply(ExtNumber, {MIN_SAFE_INTEGER:Number.MIN_SAFE_INTEGER, MAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER, floatRe:/^[-+]?(?:\d+|\d*\.\d*)(?:[Ee][+-]?\d+)?$/, intRe:/^[-+]?\d+(?:[Ee]\+?\d+)?$/, Clip:{DEFAULT:ClipDefault, COUNT:Ext.applyIf({count:true}, ClipDefault), INCLUSIVE:Ext.applyIf({inclusive:true}, ClipDefault), NOWRAP:Ext.applyIf({wrap:false}, ClipDefault)}, parseFloat:function(value) {
    if (value === undefined) {
      value = null;
    }
    if (value !== null && typeof value !== 'number') {
      value = String(value);
      value = ExtNumber.floatRe.test(value) ? +value : null;
      if (isNaN(value)) {
        value = null;
      }
    }
    return value;
  }, parseInt:function(value) {
    if (value === undefined) {
      value = null;
    }
    if (typeof value === 'number') {
      value = Math.floor(value);
    } else {
      if (value !== null) {
        value = String(value);
        value = ExtNumber.intRe.test(value) ? +value : null;
      }
    }
    return value;
  }, binarySearch:function(array, value, begin, end) {
    if (begin === undefined) {
      begin = 0;
    }
    if (end === undefined) {
      end = array.length;
    }
    --end;
    var middle, midVal;
    while (begin <= end) {
      middle = begin + end >>> 1;
      midVal = array[middle];
      if (value === midVal) {
        return middle;
      }
      if (midVal < value) {
        begin = middle + 1;
      } else {
        end = middle - 1;
      }
    }
    return begin;
  }, bisectTuples:function(array, value, index, begin, end) {
    if (begin === undefined) {
      begin = 0;
    }
    if (end === undefined) {
      end = array.length;
    }
    --end;
    var middle, midVal;
    while (begin <= end) {
      middle = begin + end >>> 1;
      midVal = array[middle][index];
      if (value === midVal) {
        return middle;
      }
      if (midVal < value) {
        begin = middle + 1;
      } else {
        end = middle - 1;
      }
    }
    return begin;
  }, clipIndices:function(length, indices, options) {
    options = options || ClipDefault;
    var defaultValue = 0, wrap = options.wrap, begin, end, i;
    indices = indices || [];
    for (i = 0; i < 2; ++i) {
      begin = end;
      end = indices[i];
      if (end == null) {
        end = defaultValue;
      } else {
        if (i && options.count) {
          end += begin;
          end = end > length ? length : end;
        } else {
          if (wrap) {
            end = end < 0 ? length + end : end;
          }
          if (i && options.inclusive) {
            ++end;
          }
          end = end < 0 ? 0 : end > length ? length : end;
        }
      }
      defaultValue = length;
    }
    indices[0] = begin;
    indices[1] = end < begin ? begin : end;
    return indices;
  }, constrain:function(number, min, max) {
    var x = parseFloat(number);
    if (min === null) {
      min = number;
    }
    if (max === null) {
      max = number;
    }
    return x < min ? min : x > max ? max : x;
  }, snap:function(value, increment, minValue, maxValue) {
    var m;
    if (value === undefined || value < minValue) {
      return minValue || 0;
    }
    if (increment) {
      m = value % increment;
      if (m !== 0) {
        value -= m;
        if (m * 2 >= increment) {
          value += increment;
        } else {
          if (m * 2 < -increment) {
            value -= increment;
          }
        }
      }
    }
    return ExtNumber.constrain(value, minValue, maxValue);
  }, snapInRange:function(value, increment, minValue, maxValue) {
    var tween;
    minValue = minValue || 0;
    if (value === undefined || value < minValue) {
      return minValue;
    }
    if (increment && (tween = (value - minValue) % increment)) {
      value -= tween;
      tween *= 2;
      if (tween >= increment) {
        value += increment;
      }
    }
    if (maxValue !== undefined) {
      if (value > (maxValue = ExtNumber.snapInRange(maxValue, increment, minValue))) {
        value = maxValue;
      }
    }
    return value;
  }, roundToNearest:function(value, interval) {
    interval = interval || 1;
    return interval * math.round(value / interval);
  }, roundToPrecision:function(value, precision) {
    var factor = math.pow(10, precision || 1);
    return math.round(value * factor) / factor;
  }, truncateToPrecision:function(value, precision) {
    var factor = math.pow(10, precision || 1);
    return parseInt(value * factor, 10) / factor;
  }, sign:math.sign || function(x) {
    x = +x;
    if (x === 0 || isNaN(x)) {
      return x;
    }
    return x > 0 ? 1 : -1;
  }, log10:math.log10 || function(x) {
    return math.log(x) * math.LOG10E;
  }, isEqual:function(n1, n2, epsilon) {
    return math.abs(n1 - n2) < epsilon;
  }, isFinite:Number.isFinite || function(value) {
    return typeof value === 'number' && isFinite(value);
  }, isInteger:Number.isInteger || function(value) {
    return ~~(value + 0) === value;
  }, toFixed:isToFixedBroken ? function(value, precision) {
    precision = precision || 0;
    var pow = math.pow(10, precision);
    return (math.round(value * pow) / pow).toFixed(precision);
  } : function(value, precision) {
    return value.toFixed(precision);
  }, from:function(value, defaultValue) {
    if (isFinite(value)) {
      value = parseFloat(value);
    }
    return !isNaN(value) ? value : defaultValue;
  }, randomInt:function(from, to) {
    return math.floor(math.random() * (to - from + 1) + from);
  }, correctFloat:function(n) {
    return parseFloat(n.toPrecision(14));
  }});
  Ext.num = function() {
    return ExtNumber.from.apply(this, arguments);
  };
};
(function() {
  var TemplateClass = function() {
  }, queryRe = /^\?/, keyRe = /(\[):?([^\]]*)\]/g, nameRe = /^([^\[]+)/, plusRe = /\+/g, ExtObject = Ext.Object = {chain:Object.create || function(object) {
    TemplateClass.prototype = object;
    var result = new TemplateClass;
    TemplateClass.prototype = null;
    return result;
  }, clear:function(object) {
    for (var key in object) {
      delete object[key];
    }
    return object;
  }, freeze:Object.freeze ? function(obj, deep) {
    if (obj && typeof obj === 'object' && !Object.isFrozen(obj)) {
      Object.freeze(obj);
      if (deep) {
        for (var name in obj) {
          ExtObject.freeze(obj[name], deep);
        }
      }
    }
    return obj;
  } : Ext.identityFn, toQueryObjects:function(name, value, recursive) {
    var self = ExtObject.toQueryObjects, objects = [], i, ln;
    if (Ext.isArray(value)) {
      for (i = 0, ln = value.length; i < ln; i++) {
        if (recursive) {
          objects = objects.concat(self(name + '[' + i + ']', value[i], true));
        } else {
          objects.push({name:name, value:value[i]});
        }
      }
    } else {
      if (Ext.isObject(value)) {
        for (i in value) {
          if (value.hasOwnProperty(i)) {
            if (recursive) {
              objects = objects.concat(self(name + '[' + i + ']', value[i], true));
            } else {
              objects.push({name:name, value:value[i]});
            }
          }
        }
      } else {
        objects.push({name:name, value:value});
      }
    }
    return objects;
  }, toQueryString:function(object, recursive) {
    var paramObjects = [], params = [], i, j, ln, paramObject, value;
    for (i in object) {
      if (object.hasOwnProperty(i)) {
        paramObjects = paramObjects.concat(ExtObject.toQueryObjects(i, object[i], recursive));
      }
    }
    for (j = 0, ln = paramObjects.length; j < ln; j++) {
      paramObject = paramObjects[j];
      value = paramObject.value;
      if (Ext.isEmpty(value)) {
        value = '';
      } else {
        if (Ext.isDate(value)) {
          value = Ext.Date.toString(value);
        }
      }
      params.push(encodeURIComponent(paramObject.name) + '\x3d' + encodeURIComponent(String(value)));
    }
    return params.join('\x26');
  }, fromQueryString:function(queryString, recursive) {
    var parts = queryString.replace(queryRe, '').split('\x26'), object = {}, temp, components, name, value, i, ln, part, j, subLn, matchedKeys, matchedName, keys, key, nextKey;
    for (i = 0, ln = parts.length; i < ln; i++) {
      part = parts[i];
      if (part.length > 0) {
        components = part.split('\x3d');
        name = components[0];
        name = name.replace(plusRe, '%20');
        name = decodeURIComponent(name);
        value = components[1];
        if (value !== undefined) {
          value = value.replace(plusRe, '%20');
          value = decodeURIComponent(value);
        } else {
          value = '';
        }
        if (!recursive) {
          if (object.hasOwnProperty(name)) {
            if (!Ext.isArray(object[name])) {
              object[name] = [object[name]];
            }
            object[name].push(value);
          } else {
            object[name] = value;
          }
        } else {
          matchedKeys = name.match(keyRe);
          matchedName = name.match(nameRe);
          name = matchedName[0];
          keys = [];
          if (matchedKeys === null) {
            object[name] = value;
            continue;
          }
          for (j = 0, subLn = matchedKeys.length; j < subLn; j++) {
            key = matchedKeys[j];
            key = key.length === 2 ? '' : key.substring(1, key.length - 1);
            keys.push(key);
          }
          keys.unshift(name);
          temp = object;
          for (j = 0, subLn = keys.length; j < subLn; j++) {
            key = keys[j];
            if (j === subLn - 1) {
              if (Ext.isArray(temp) && key === '') {
                temp.push(value);
              } else {
                temp[key] = value;
              }
            } else {
              if (temp[key] === undefined || typeof temp[key] === 'string') {
                nextKey = keys[j + 1];
                temp[key] = Ext.isNumeric(nextKey) || nextKey === '' ? [] : {};
              }
              temp = temp[key];
            }
          }
        }
      }
    }
    return object;
  }, each:function(object, fn, scope) {
    var enumerables = Ext.enumerables, i, property;
    if (object) {
      scope = scope || object;
      for (property in object) {
        if (object.hasOwnProperty(property)) {
          if (fn.call(scope, property, object[property], object) === false) {
            return;
          }
        }
      }
      if (enumerables) {
        for (i = enumerables.length; i--;) {
          if (object.hasOwnProperty(property = enumerables[i])) {
            if (fn.call(scope, property, object[property], object) === false) {
              return;
            }
          }
        }
      }
    }
  }, eachValue:function(object, fn, scope) {
    var enumerables = Ext.enumerables, i, property;
    scope = scope || object;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        if (fn.call(scope, object[property]) === false) {
          return;
        }
      }
    }
    if (enumerables) {
      for (i = enumerables.length; i--;) {
        if (object.hasOwnProperty(property = enumerables[i])) {
          if (fn.call(scope, object[property]) === false) {
            return;
          }
        }
      }
    }
  }, merge:function(destination) {
    var i = 1, args = arguments, ln = args.length, mergeFn = ExtObject.merge, cloneFn = Ext.clone, object, key, value, sourceKey;
    for (; i < ln; i++) {
      object = args[i];
      for (key in object) {
        value = object[key];
        if (value && value.constructor === Object) {
          sourceKey = destination[key];
          if (sourceKey && sourceKey.constructor === Object) {
            mergeFn(sourceKey, value);
          } else {
            destination[key] = cloneFn(value);
          }
        } else {
          destination[key] = value;
        }
      }
    }
    return destination;
  }, mergeIf:function(destination) {
    var i = 1, ln = arguments.length, cloneFn = Ext.clone, object, key, value;
    for (; i < ln; i++) {
      object = arguments[i];
      for (key in object) {
        if (!(key in destination)) {
          value = object[key];
          if (value && value.constructor === Object) {
            destination[key] = cloneFn(value);
          } else {
            destination[key] = value;
          }
        }
      }
    }
    return destination;
  }, getAllKeys:function(object) {
    var keys = [], property;
    for (property in object) {
      keys.push(property);
    }
    return keys;
  }, getKey:function(object, value) {
    for (var property in object) {
      if (object.hasOwnProperty(property) && object[property] === value) {
        return property;
      }
    }
    return null;
  }, getValues:function(object) {
    var values = [], property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        values.push(object[property]);
      }
    }
    return values;
  }, getKeys:typeof Object.keys == 'function' ? function(object) {
    if (!object) {
      return [];
    }
    return Object.keys(object);
  } : function(object) {
    var keys = [], property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        keys.push(property);
      }
    }
    return keys;
  }, getSize:function(object) {
    var size = 0, property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        size++;
      }
    }
    return size;
  }, isEmpty:function(object) {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        return false;
      }
    }
    return true;
  }, equals:function() {
    var check = function(o1, o2) {
      var key;
      for (key in o1) {
        if (o1.hasOwnProperty(key)) {
          if (o1[key] !== o2[key]) {
            return false;
          }
        }
      }
      return true;
    };
    return function(object1, object2) {
      if (object1 === object2) {
        return true;
      }
      if (object1 && object2) {
        return check(object1, object2) && check(object2, object1);
      } else {
        if (!object1 && !object2) {
          return object1 === object2;
        } else {
          return false;
        }
      }
    };
  }(), fork:function(obj) {
    var ret, key, value;
    if (obj && obj.constructor === Object) {
      ret = ExtObject.chain(obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (value.constructor === Object) {
            ret[key] = ExtObject.fork(value);
          } else {
            if (value instanceof Array) {
              ret[key] = Ext.Array.clone(value);
            }
          }
        }
      }
    } else {
      ret = obj;
    }
    return ret;
  }, defineProperty:'defineProperty' in Object ? Object.defineProperty : function(object, name, descriptor) {
    if (!Object.prototype.__defineGetter__) {
      return;
    }
    if (descriptor.get) {
      object.__defineGetter__(name, descriptor.get);
    }
    if (descriptor.set) {
      object.__defineSetter__(name, descriptor.set);
    }
  }, classify:function(object) {
    var prototype = object, objectProperties = [], propertyClassesMap = {}, objectClass = function() {
      var i = 0, ln = objectProperties.length, property;
      for (; i < ln; i++) {
        property = objectProperties[i];
        this[property] = new propertyClassesMap[property];
      }
    }, key, value;
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        value = object[key];
        if (value && value.constructor === Object) {
          objectProperties.push(key);
          propertyClassesMap[key] = ExtObject.classify(value);
        }
      }
    }
    objectClass.prototype = prototype;
    return objectClass;
  }};
  Ext.merge = Ext.Object.merge;
  Ext.mergeIf = Ext.Object.mergeIf;
})();
Ext.apply(Ext, {_namedScopes:{'this':{isThis:1}, controller:{isController:1}, owner:{isOwner:1}, self:{isSelf:1}, 'self.controller':{isSelf:1, isController:1}}, escapeId:function() {
  var validIdRe = /^[a-zA-Z_][a-zA-Z0-9_\-]*$/i, escapeRx = /([\W]{1})/g, leadingNumRx = /^(\d)/g, escapeFn = function(match, capture) {
    return '\\' + capture;
  }, numEscapeFn = function(match, capture) {
    return '\\00' + capture.charCodeAt(0).toString(16) + ' ';
  };
  return function(id) {
    return validIdRe.test(id) ? id : id.replace(escapeRx, escapeFn).replace(leadingNumRx, numEscapeFn);
  };
}(), callback:function(callback, scope, args, delay, caller, defaultScope) {
  if (!callback) {
    return;
  }
  var namedScope = scope in Ext._namedScopes;
  if (callback.charAt) {
    if (callback[2] === '.') {
      callback = callback.substr(3);
      for (scope = caller.up(); scope && !scope[callback]; scope = scope.up()) {
      }
    } else {
      if ((!scope || namedScope) && caller) {
        scope = caller.resolveListenerScope(namedScope ? scope : defaultScope);
      }
    }
    callback = scope[callback];
  } else {
    if (namedScope) {
      scope = defaultScope || caller;
    } else {
      if (!scope) {
        scope = caller;
      }
    }
  }
  var ret;
  if (callback && Ext.isFunction(callback)) {
    scope = scope || Ext.global;
    if (delay) {
      Ext.defer(callback, delay, scope, args);
    } else {
      ret = args ? callback.apply(scope, args) : callback.call(scope);
    }
  }
  return ret;
}, coerce:function(from, to) {
  var fromType = Ext.typeOf(from), toType = Ext.typeOf(to), isString = typeof from === 'string';
  if (fromType !== toType) {
    switch(toType) {
      case 'string':
        return String(from);
      case 'number':
        return Number(from);
      case 'boolean':
        return isString && (!from || from === 'false' || from === '0') ? false : Boolean(from);
      case 'null':
        return isString && (!from || from === 'null') ? null : false;
      case 'undefined':
        return isString && (!from || from === 'undefined') ? undefined : false;
      case 'date':
        return isString && isNaN(from) ? Ext.Date.parse(from, Ext.Date.defaultFormat) : Date(Number(from));
    }
  }
  return from;
}, copyTo:function(dest, source, names, usePrototypeKeys) {
  if (typeof names === 'string') {
    names = names.split(Ext.propertyNameSplitRe);
  }
  for (var name, i = 0, n = names ? names.length : 0; i < n; i++) {
    name = names[i];
    if (usePrototypeKeys || source.hasOwnProperty(name)) {
      dest[name] = source[name];
    }
  }
  return dest;
}, copy:function(dest, source, names, usePrototypeKeys) {
  if (typeof names === 'string') {
    names = names.split(Ext.propertyNameSplitRe);
  }
  for (var name, i = 0, n = names ? names.length : 0; i < n; i++) {
    name = names[i];
    if (source.hasOwnProperty(name) || usePrototypeKeys && name in source) {
      dest[name] = source[name];
    }
  }
  return dest;
}, propertyNameSplitRe:/[,;\s]+/, copyToIf:function(destination, source, names) {
  if (typeof names === 'string') {
    names = names.split(Ext.propertyNameSplitRe);
  }
  for (var name, i = 0, n = names ? names.length : 0; i < n; i++) {
    name = names[i];
    if (destination[name] === undefined) {
      destination[name] = source[name];
    }
  }
  return destination;
}, copyIf:function(destination, source, names) {
  if (typeof names === 'string') {
    names = names.split(Ext.propertyNameSplitRe);
  }
  for (var name, i = 0, n = names ? names.length : 0; i < n; i++) {
    name = names[i];
    if (!(name in destination) && name in source) {
      destination[name] = source[name];
    }
  }
  return destination;
}, extend:function() {
  var objectConstructor = Object.prototype.constructor, inlineOverrides = function(o) {
    var m;
    for (m in o) {
      if (!o.hasOwnProperty(m)) {
        continue;
      }
      this[m] = o[m];
    }
  };
  return function(subclass, superclass, overrides) {
    if (Ext.isObject(superclass)) {
      overrides = superclass;
      superclass = subclass;
      subclass = overrides.constructor !== objectConstructor ? overrides.constructor : function() {
        superclass.apply(this, arguments);
      };
    }
    var F = function() {
    }, subclassProto, superclassProto = superclass.prototype;
    F.prototype = superclassProto;
    subclassProto = subclass.prototype = new F;
    subclassProto.constructor = subclass;
    subclass.superclass = superclassProto;
    if (superclassProto.constructor === objectConstructor) {
      superclassProto.constructor = superclass;
    }
    subclass.override = function(overrides) {
      Ext.override(subclass, overrides);
    };
    subclassProto.override = inlineOverrides;
    subclassProto.proto = subclassProto;
    subclass.override(overrides);
    subclass.extend = function(o) {
      return Ext.extend(subclass, o);
    };
    return subclass;
  };
}(), isOnline:function() {
  return Ext.global.navigator.onLine;
}, iterate:function(object, fn, scope) {
  if (Ext.isEmpty(object)) {
    return;
  }
  if (scope === undefined) {
    scope = object;
  }
  if (Ext.isIterable(object)) {
    Ext.Array.each.call(Ext.Array, object, fn, scope);
  } else {
    Ext.Object.each.call(Ext.Object, object, fn, scope);
  }
}, _resourcePoolRe:/^[<]([^<>@:]*)(?:[@]([^<>@:]+))?[>](.+)$/, resolveResource:function(url) {
  var ret = url, m;
  if (url && url.charAt(0) === '\x3c') {
    m = Ext._resourcePoolRe.exec(url);
    if (m) {
      ret = Ext.getResourcePath(m[3], m[1], m[2]);
    }
  }
  return ret;
}, urlEncode:function() {
  var args = Ext.Array.from(arguments), prefix = '';
  if (Ext.isString(args[1])) {
    prefix = args[1] + '\x26';
    args[1] = false;
  }
  return prefix + Ext.Object.toQueryString.apply(Ext.Object, args);
}, urlDecode:function() {
  return Ext.Object.fromQueryString.apply(Ext.Object, arguments);
}, getScrollbarSize:function(force) {
  var scrollbarSize = Ext._scrollbarSize;
  if (force || !scrollbarSize) {
    var db = document.body, div = document.createElement('div'), h, w;
    div.style.width = div.style.height = '100px';
    div.style.overflow = 'scroll';
    div.style.position = 'absolute';
    db.appendChild(div);
    Ext._scrollbarSize = scrollbarSize = {width:w = div.offsetWidth - div.clientWidth, height:h = div.offsetHeight - div.clientHeight};
    scrollbarSize.reservedWidth = w ? 'calc(100% - ' + w + 'px)' : '';
    scrollbarSize.reservedHeight = h ? 'calc(100% - ' + h + 'px)' : '';
    db.removeChild(div);
  }
  return scrollbarSize;
}, typeOf:function() {
  var nonWhitespaceRe = /\S/, toString = Object.prototype.toString, typeofTypes = {number:1, string:1, 'boolean':1, 'undefined':1}, toStringTypes = {'[object Array]':'array', '[object Date]':'date', '[object Boolean]':'boolean', '[object Number]':'number', '[object RegExp]':'regexp'};
  return function(value) {
    if (value === null) {
      return 'null';
    }
    var type = typeof value, ret, typeToString;
    if (typeofTypes[type]) {
      return type;
    }
    ret = toStringTypes[typeToString = toString.call(value)];
    if (ret) {
      return ret;
    }
    if (type === 'function') {
      return 'function';
    }
    if (type === 'object') {
      if (value.nodeType !== undefined) {
        if (value.nodeType === 3) {
          return nonWhitespaceRe.test(value.nodeValue) ? 'textnode' : 'whitespace';
        } else {
          return 'element';
        }
      }
      return 'object';
    }
    return typeToString;
  };
}(), factory:function(config, classReference, instance, aliasNamespace) {
  var manager = Ext.ClassManager, newInstance;
  if (!config || config.isInstance) {
    if (instance && instance !== config) {
      instance.destroy();
    }
    return config;
  }
  if (aliasNamespace) {
    if (typeof config === 'string') {
      return manager.instantiateByAlias(aliasNamespace + '.' + config);
    } else {
      if (Ext.isObject(config) && 'type' in config) {
        return manager.instantiateByAlias(aliasNamespace + '.' + config.type, config);
      }
    }
  }
  if (config === true) {
    return instance || Ext.create(classReference);
  }
  if ('xtype' in config) {
    newInstance = manager.instantiateByAlias('widget.' + config.xtype, config);
  } else {
    if ('xclass' in config) {
      newInstance = Ext.create(config.xclass, config);
    }
  }
  if (newInstance) {
    if (instance) {
      instance.destroy();
    }
    return newInstance;
  }
  if (instance) {
    return instance.setConfig(config);
  }
  return Ext.create(classReference, config);
}, convertKeyedItems:function(items, defaultProperty, functionProperty) {
  if (items && !items.isInstance && Ext.isObject(items)) {
    var obj = items, item, itemId, value;
    items = [];
    if (obj.xtype || obj.xclass || obj.itemId || obj.id) {
      items.push(obj);
    } else {
      for (itemId in obj) {
        item = obj[itemId];
        if (item) {
          if (item === true) {
            item = {};
          } else {
            if (typeof item === 'function') {
              value = item;
              item = {};
              item[functionProperty] = value;
            } else {
              if (typeof item === 'string') {
                value = item;
                item = {};
                item[defaultProperty || 'xtype'] = value;
              } else {
                item = Ext.apply({}, item);
              }
            }
          }
          item.itemId = itemId;
          items.push(item);
        }
      }
    }
  }
  return items;
}, weightSortFn:function(lhs, rhs) {
  return (lhs.weight || 0) - (rhs.weight || 0);
}, concat:function(a, b) {
  var noB = b == null, E = Ext.emptyArray;
  return a == null ? noB ? a : E.concat(b) : noB ? E.concat(a) : E.concat(a, b);
}, log:function() {
  var nullLog = function() {
  };
  nullLog.info = nullLog.warn = nullLog.error = Ext.emptyFn;
  return nullLog;
}()});
(function() {
  var checkVerTemp = [''], endOfVersionRe = /([^\d\.])/, notDigitsRe = /[^\d]/g, plusMinusRe = /[\-+]/g, stripRe = /\s/g, underscoreRe = /_/g, toolkitNames = {classic:1, modern:1}, Version;
  Ext.Version = Version = function(version, defaultMode) {
    var me = this, padModes = me.padModes, ch, i, pad, parts, release, releaseStartIndex, ver;
    if (version.isVersion) {
      version = version.version;
    }
    me.version = ver = String(version).toLowerCase().replace(underscoreRe, '.').replace(plusMinusRe, '');
    ch = ver.charAt(0);
    if (ch in padModes) {
      ver = ver.substring(1);
      pad = padModes[ch];
    } else {
      pad = defaultMode ? padModes[defaultMode] : 0;
    }
    me.pad = pad;
    releaseStartIndex = ver.search(endOfVersionRe);
    me.shortVersion = ver;
    if (releaseStartIndex !== -1) {
      me.release = release = ver.substr(releaseStartIndex, version.length);
      me.shortVersion = ver.substr(0, releaseStartIndex);
      release = Version.releaseValueMap[release] || release;
    }
    me.releaseValue = release || pad;
    me.shortVersion = me.shortVersion.replace(notDigitsRe, '');
    me.parts = parts = ver.split('.');
    for (i = parts.length; i--;) {
      parts[i] = parseInt(parts[i], 10);
    }
    if (pad === Infinity) {
      parts.push(pad);
    }
    me.major = parts[0] || pad;
    me.minor = parts[1] || pad;
    me.patch = parts[2] || pad;
    me.build = parts[3] || pad;
    return me;
  };
  Version.prototype = {isVersion:true, padModes:{'~':NaN, '^':Infinity}, release:'', compareTo:function(other) {
    var me = this, lhsPad = me.pad, lhsParts = me.parts, lhsLength = lhsParts.length, rhsVersion = other.isVersion ? other : new Version(other), rhsPad = rhsVersion.pad, rhsParts = rhsVersion.parts, rhsLength = rhsParts.length, length = Math.max(lhsLength, rhsLength), i, lhs, rhs;
    for (i = 0; i < length; i++) {
      lhs = i < lhsLength ? lhsParts[i] : lhsPad;
      rhs = i < rhsLength ? rhsParts[i] : rhsPad;
      if (lhs < rhs) {
        return -1;
      }
      if (lhs > rhs) {
        return 1;
      }
    }
    lhs = me.releaseValue;
    rhs = rhsVersion.releaseValue;
    if (lhs < rhs) {
      return -1;
    }
    if (lhs > rhs) {
      return 1;
    }
    return 0;
  }, toString:function() {
    return this.version;
  }, valueOf:function() {
    return this.version;
  }, getMajor:function() {
    return this.major;
  }, getMinor:function() {
    return this.minor;
  }, getPatch:function() {
    return this.patch;
  }, getBuild:function() {
    return this.build;
  }, getRelease:function() {
    return this.release;
  }, getReleaseValue:function() {
    return this.releaseValue;
  }, isGreaterThan:function(target) {
    return this.compareTo(target) > 0;
  }, isGreaterThanOrEqual:function(target) {
    return this.compareTo(target) >= 0;
  }, isLessThan:function(target) {
    return this.compareTo(target) < 0;
  }, isLessThanOrEqual:function(target) {
    return this.compareTo(target) <= 0;
  }, equals:function(target) {
    return this.compareTo(target) === 0;
  }, match:function(target) {
    target = String(target);
    return this.version.substr(0, target.length) === target;
  }, toArray:function() {
    var me = this;
    return [me.getMajor(), me.getMinor(), me.getPatch(), me.getBuild(), me.getRelease()];
  }, getShortVersion:function() {
    return this.shortVersion;
  }, gt:function(target) {
    return this.compareTo(target) > 0;
  }, lt:function(target) {
    return this.compareTo(target) < 0;
  }, gtEq:function(target) {
    return this.compareTo(target) >= 0;
  }, ltEq:function(target) {
    return this.compareTo(target) <= 0;
  }};
  Ext.apply(Version, {aliases:{from:{extjs:'ext', core:'core', touch:'modern'}, to:{ext:['extjs'], 'core':['core'], modern:['touch']}}, releaseValueMap:{dev:-6, alpha:-5, a:-5, beta:-4, b:-4, rc:-3, '#':-2, p:-1, pl:-1}, getComponentValue:function(value) {
    return !value ? 0 : isNaN(value) ? this.releaseValueMap[value] || value : parseInt(value, 10);
  }, compare:function(current, target) {
    var ver = current.isVersion ? current : new Version(current);
    return ver.compareTo(target);
  }, set:function(collection, packageName, version) {
    var aliases = Version.aliases.to[packageName], ver = version.isVersion ? version : new Version(version), i;
    collection[packageName] = ver;
    if (aliases) {
      for (i = aliases.length; i-- > 0;) {
        collection[aliases[i]] = ver;
      }
    }
    return ver;
  }});
  Ext.apply(Ext, {compatVersions:{}, versions:{}, lastRegisteredVersion:null, getCompatVersion:function(packageName) {
    var versions = Ext.compatVersions, compat;
    if (!packageName) {
      compat = versions.ext || versions.touch || versions.core;
    } else {
      compat = versions[Version.aliases.from[packageName] || packageName];
    }
    return compat || Ext.getVersion(packageName);
  }, setCompatVersion:function(packageName, version) {
    Version.set(Ext.compatVersions, packageName, version);
  }, setVersion:function(packageName, version) {
    if (packageName in toolkitNames) {
      Ext.toolkit = packageName;
    }
    Ext.lastRegisteredVersion = Version.set(Ext.versions, packageName, version);
    return this;
  }, getVersion:function(packageName) {
    var versions = Ext.versions;
    if (!packageName) {
      return versions.ext || versions.touch || versions.core;
    }
    return versions[Version.aliases.from[packageName] || packageName];
  }, checkVersion:function(specs, matchAll) {
    var isArray = Ext.isArray(specs), aliases = Version.aliases.from, compat = isArray ? specs : checkVerTemp, length = compat.length, versions = Ext.versions, frameworkVer = versions.ext || versions.touch, i, index, matches, minVer, maxVer, packageName, spec, range, ver;
    if (!isArray) {
      checkVerTemp[0] = specs;
    }
    for (i = 0; i < length; ++i) {
      if (!Ext.isString(spec = compat[i])) {
        matches = Ext.checkVersion(spec.and || spec.or, !spec.or);
        if (spec.not) {
          matches = !matches;
        }
      } else {
        if (spec.indexOf(' ') >= 0) {
          spec = spec.replace(stripRe, '');
        }
        index = spec.indexOf('@');
        if (index < 0) {
          range = spec;
          ver = frameworkVer;
        } else {
          packageName = spec.substring(0, index);
          if (!(ver = versions[aliases[packageName] || packageName])) {
            if (matchAll) {
              return false;
            }
            continue;
          }
          range = spec.substring(index + 1);
        }
        index = range.indexOf('-');
        if (index < 0) {
          if (range.charAt(index = range.length - 1) === '+') {
            minVer = range.substring(0, index);
            maxVer = null;
          } else {
            minVer = maxVer = range;
          }
        } else {
          if (index > 0) {
            minVer = range.substring(0, index);
            maxVer = range.substring(index + 1);
          } else {
            minVer = null;
            maxVer = range.substring(index + 1);
          }
        }
        matches = true;
        if (minVer) {
          minVer = new Version(minVer, '~');
          matches = minVer.ltEq(ver);
        }
        if (matches && maxVer) {
          maxVer = new Version(maxVer, '~');
          matches = maxVer.gtEq(ver);
        }
      }
      if (matches) {
        if (!matchAll) {
          return true;
        }
      } else {
        if (matchAll) {
          return false;
        }
      }
    }
    return !!matchAll;
  }, deprecate:function(packageName, since, closure, scope) {
    if (Version.compare(Ext.getVersion(packageName), since) < 1) {
      closure.call(scope);
    }
  }});
})();
(function(manifest) {
  var packages = manifest && manifest.packages || {}, compat = manifest && manifest.compatibility, name, pkg;
  for (name in packages) {
    pkg = packages[name];
    if (pkg && pkg.version) {
      Ext.setVersion(name, pkg.version);
    }
  }
  if (compat) {
    if (Ext.isString(compat)) {
      Ext.setCompatVersion('core', compat);
    } else {
      for (name in compat) {
        Ext.setCompatVersion(name, compat[name]);
      }
    }
  }
  if (!packages.ext && !packages.touch) {
    Ext.setVersion('ext', '6.5.3.57');
    Ext.setVersion('core', '6.5.3.57');
  }
})(Ext.manifest);
Ext.Config = function(name) {
  var me = this, capitalizedName = name.charAt(0).toUpperCase() + name.substr(1);
  me.name = name;
  me.names = {internal:'_' + name, initializing:'is' + capitalizedName + 'Initializing', apply:'apply' + capitalizedName, update:'update' + capitalizedName, get:'get' + capitalizedName, set:'set' + capitalizedName, initGet:'initGet' + capitalizedName, changeEvent:name.toLowerCase() + 'change'};
  me.root = me;
};
Ext.Config.map = {};
Ext.Config.get = function(name) {
  var map = Ext.Config.map, ret = map[name] || (map[name] = new Ext.Config(name));
  return ret;
};
Ext.Config.prototype = {self:Ext.Config, isConfig:true, getGetter:function() {
  return this.getter || (this.root.getter = this.makeGetter());
}, getInitGetter:function() {
  return this.initGetter || (this.root.initGetter = this.makeInitGetter());
}, getSetter:function() {
  return this.setter || (this.root.setter = this.makeSetter());
}, getEventedSetter:function() {
  return this.eventedSetter || (this.root.eventedSetter = this.makeEventedSetter());
}, getInternalName:function(target) {
  return target.$configPrefixed ? this.names.internal : this.name;
}, mergeNew:function(newValue, oldValue, target, mixinClass) {
  var ret, key;
  if (!oldValue) {
    ret = newValue;
  } else {
    if (!newValue) {
      ret = oldValue;
    } else {
      ret = Ext.Object.chain(oldValue);
      for (key in newValue) {
        if (!mixinClass || !(key in ret)) {
          ret[key] = newValue[key];
        }
      }
    }
  }
  return ret;
}, mergeSets:function(newValue, oldValue, preserveExisting) {
  var ret = oldValue ? Ext.Object.chain(oldValue) : {}, i, val;
  if (newValue instanceof Array) {
    for (i = newValue.length; i--;) {
      val = newValue[i];
      if (!preserveExisting || !(val in ret)) {
        ret[val] = true;
      }
    }
  } else {
    if (newValue) {
      if (newValue.constructor === Object) {
        for (i in newValue) {
          val = newValue[i];
          if (!preserveExisting || !(i in ret)) {
            ret[i] = val;
          }
        }
      } else {
        if (!preserveExisting || !(newValue in ret)) {
          ret[newValue] = true;
        }
      }
    }
  }
  return ret;
}, makeGetter:function() {
  var name = this.name, prefixedName = this.names.internal;
  return function() {
    var internalName = this.$configPrefixed ? prefixedName : name;
    return this[internalName];
  };
}, makeInitGetter:function() {
  var name = this.name, names = this.names, setName = names.set, getName = names.get, initializingName = names.initializing;
  return function() {
    var me = this;
    me[initializingName] = true;
    delete me[getName];
    me[setName](me.config[name]);
    delete me[initializingName];
    return me[getName].apply(me, arguments);
  };
}, makeSetter:function() {
  var name = this.name, names = this.names, prefixedName = names.internal, getName = names.get, applyName = names.apply, updateName = names.update, setter;
  setter = function(value) {
    var me = this, internalName = me.$configPrefixed ? prefixedName : name, oldValue = me[internalName];
    delete me[getName];
    if (!me[applyName] || (value = me[applyName](value, oldValue)) !== undefined) {
      if (value !== (oldValue = me[internalName])) {
        me[internalName] = value;
        if (me[updateName]) {
          me[updateName](value, oldValue);
        }
      }
    }
    return me;
  };
  setter.$isDefault = true;
  return setter;
}, makeEventedSetter:function() {
  var name = this.name, names = this.names, prefixedName = names.internal, getName = names.get, applyName = names.apply, updateName = names.update, changeEventName = names.changeEvent, updateFn = function(me, value, oldValue, internalName) {
    me[internalName] = value;
    if (me[updateName]) {
      me[updateName](value, oldValue);
    }
  }, setter;
  setter = function(value) {
    var me = this, internalName = me.$configPrefixed ? prefixedName : name, oldValue = me[internalName];
    delete me[getName];
    if (!me[applyName] || (value = me[applyName](value, oldValue)) !== undefined) {
      if (value !== (oldValue = me[internalName])) {
        if (me.isConfiguring) {
          me[internalName] = value;
          if (me[updateName]) {
            me[updateName](value, oldValue);
          }
        } else {
          me.fireEventedAction(changeEventName, [me, value, oldValue], updateFn, me, [me, value, oldValue, internalName]);
        }
      }
    }
    return me;
  };
  setter.$isDefault = true;
  return setter;
}};
(function() {
  var ExtConfig = Ext.Config, configPropMap = ExtConfig.map, ExtObject = Ext.Object;
  Ext.Configurator = function(cls) {
    var me = this, prototype = cls.prototype, superCfg = cls.superclass ? cls.superclass.self.$config : null;
    me.cls = cls;
    me.superCfg = superCfg;
    if (superCfg) {
      me.configs = ExtObject.chain(superCfg.configs);
      me.cachedConfigs = ExtObject.chain(superCfg.cachedConfigs);
      me.initMap = ExtObject.chain(superCfg.initMap);
      me.values = ExtObject.chain(superCfg.values);
      me.needsFork = superCfg.needsFork;
    } else {
      me.configs = {};
      me.cachedConfigs = {};
      me.initMap = {};
      me.values = {};
    }
    prototype.config = prototype.defaultConfig = me.values;
    cls.$config = me;
  };
  Ext.Configurator.prototype = {self:Ext.Configurator, needsFork:false, initList:null, add:function(config, mixinClass) {
    var me = this, Cls = me.cls, configs = me.configs, cachedConfigs = me.cachedConfigs, initMap = me.initMap, prototype = Cls.prototype, mixinConfigs = mixinClass && mixinClass.$config.configs, values = me.values, isObject, meta, isCached, merge, cfg, currentValue, name, names, s, value;
    for (name in config) {
      value = config[name];
      isObject = value && value.constructor === Object;
      meta = isObject && '$value' in value ? value : null;
      isCached = false;
      if (meta) {
        isCached = !!meta.cached;
        value = meta.$value;
        isObject = value && value.constructor === Object;
      }
      merge = meta && meta.merge;
      cfg = configs[name];
      if (cfg) {
        if (mixinClass) {
          merge = cfg.merge;
          if (!merge) {
            continue;
          }
          meta = null;
        } else {
          merge = merge || cfg.merge;
        }
        currentValue = values[name];
        if (merge) {
          value = merge.call(cfg, value, currentValue, Cls, mixinClass);
        } else {
          if (isObject) {
            if (currentValue && currentValue.constructor === Object) {
              value = ExtObject.merge({}, currentValue, value);
            }
          }
        }
      } else {
        if (mixinConfigs) {
          cfg = mixinConfigs[name];
          meta = null;
        } else {
          cfg = ExtConfig.get(name);
        }
        configs[name] = cfg;
        if (cfg.cached || isCached) {
          cachedConfigs[name] = true;
        }
        names = cfg.names;
        if (!prototype[s = names.get]) {
          prototype[s] = cfg.getter || cfg.getGetter();
        }
        if (!prototype[s = names.set]) {
          prototype[s] = meta && meta.evented ? cfg.eventedSetter || cfg.getEventedSetter() : cfg.setter || cfg.getSetter();
        }
      }
      if (meta) {
        if (cfg.owner !== Cls) {
          configs[name] = cfg = Ext.Object.chain(cfg);
          cfg.owner = Cls;
        }
        Ext.apply(cfg, meta);
        delete cfg.$value;
      }
      if (!me.needsFork && value && (value.constructor === Object || value instanceof Array)) {
        me.needsFork = true;
      }
      if (value !== null) {
        initMap[name] = true;
      } else {
        if (prototype.$configPrefixed) {
          prototype[configs[name].names.internal] = null;
        } else {
          prototype[configs[name].name] = null;
        }
        if (name in initMap) {
          initMap[name] = false;
        }
      }
      values[name] = value;
    }
  }, configure:function(instance, instanceConfig) {
    var me = this, configs = me.configs, initMap = me.initMap, initListMap = me.initListMap, initList = me.initList, prototype = me.cls.prototype, values = me.values, remaining = 0, firstInstance = !initList, cachedInitList, cfg, getter, i, internalName, ln, names, name, value, isCached, valuesKey, field;
    values = me.needsFork ? ExtObject.fork(values) : ExtObject.chain(values);
    instance.isConfiguring = true;
    if (firstInstance) {
      me.initList = initList = [];
      me.initListMap = initListMap = {};
      instance.isFirstInstance = true;
      for (name in initMap) {
        cfg = configs[name];
        isCached = cfg.cached;
        if (initMap[name]) {
          names = cfg.names;
          value = values[name];
          if (!prototype[names.set].$isDefault || prototype[names.apply] || prototype[names.update] || typeof value === 'object') {
            if (isCached) {
              (cachedInitList || (cachedInitList = [])).push(cfg);
            } else {
              initList.push(cfg);
              initListMap[name] = true;
            }
            instance[names.get] = cfg.initGetter || cfg.getInitGetter();
          } else {
            prototype[cfg.getInternalName(prototype)] = value;
          }
        } else {
          if (isCached) {
            prototype[cfg.getInternalName(prototype)] = undefined;
          }
        }
      }
    }
    ln = cachedInitList && cachedInitList.length;
    if (ln) {
      for (i = 0; i < ln; ++i) {
        internalName = cachedInitList[i].getInternalName(prototype);
        instance[internalName] = null;
      }
      for (i = 0; i < ln; ++i) {
        names = (cfg = cachedInitList[i]).names;
        getter = names.get;
        if (instance.hasOwnProperty(getter)) {
          instance[names.set](values[cfg.name]);
          delete instance[getter];
        }
      }
      for (i = 0; i < ln; ++i) {
        internalName = cachedInitList[i].getInternalName(prototype);
        prototype[internalName] = instance[internalName];
        delete instance[internalName];
      }
    }
    if (instanceConfig && instanceConfig.platformConfig) {
      instanceConfig = me.resolvePlatformConfig(instance, instanceConfig);
    }
    if (firstInstance) {
      if (instance.afterCachedConfig && !instance.afterCachedConfig.$nullFn) {
        instance.afterCachedConfig(instanceConfig);
      }
    }
    instance.config = values;
    for (i = 0, ln = initList.length; i < ln; ++i) {
      cfg = initList[i];
      instance[cfg.names.get] = cfg.initGetter || cfg.getInitGetter();
    }
    if (instance.transformInstanceConfig) {
      instanceConfig = instance.transformInstanceConfig(instanceConfig);
    }
    if (instanceConfig) {
      for (name in instanceConfig) {
        value = instanceConfig[name];
        cfg = configs[name];
        if (!cfg) {
          instance[name] = value;
        } else {
          if (!cfg.lazy) {
            ++remaining;
          }
          if (!initListMap[name]) {
            instance[cfg.names.get] = cfg.initGetter || cfg.getInitGetter();
          }
          if (cfg.merge) {
            value = cfg.merge(value, values[name], instance);
          } else {
            if (value && value.constructor === Object) {
              valuesKey = values[name];
              if (valuesKey && valuesKey.constructor === Object) {
                value = ExtObject.merge(values[name], value);
              } else {
                value = Ext.clone(value, false);
              }
            }
          }
        }
        values[name] = value;
      }
    }
    if (instance.beforeInitConfig && !instance.beforeInitConfig.$nullFn) {
      if (instance.beforeInitConfig(instanceConfig) === false) {
        return;
      }
    }
    if (instanceConfig) {
      for (name in instanceConfig) {
        if (!remaining) {
          break;
        }
        cfg = configs[name];
        if (cfg && !cfg.lazy) {
          --remaining;
          names = cfg.names;
          getter = names.get;
          if (instance.hasOwnProperty(getter)) {
            instance[names.set](values[name]);
            delete instance[names.get];
          }
        }
      }
    }
    for (i = 0, ln = initList.length; i < ln; ++i) {
      cfg = initList[i];
      names = cfg.names;
      getter = names.get;
      if (!cfg.lazy && instance.hasOwnProperty(getter)) {
        instance[names.set](values[cfg.name]);
        delete instance[getter];
      }
    }
    delete instance.isConfiguring;
  }, getCurrentConfig:function(instance) {
    var defaultConfig = instance.defaultConfig, config = {}, name;
    for (name in defaultConfig) {
      config[name] = instance[configPropMap[name].names.get]();
    }
    return config;
  }, merge:function(instance, baseConfig, config) {
    var configs = this.configs, name, value, baseValue, cfg;
    for (name in config) {
      value = config[name];
      cfg = configs[name];
      if (cfg) {
        if (cfg.merge) {
          value = cfg.merge(value, baseConfig[name], instance);
        } else {
          if (value && value.constructor === Object) {
            baseValue = baseConfig[name];
            if (baseValue && baseValue.constructor === Object) {
              value = Ext.Object.merge(baseValue, value);
            } else {
              value = Ext.clone(value, false);
            }
          }
        }
      }
      baseConfig[name] = value;
    }
    return baseConfig;
  }, reconfigure:function(instance, instanceConfig, options) {
    var currentConfig = instance.config, configList = [], strict = instance.$configStrict && !(options && options.strict === false), configs = this.configs, defaults = options && options.defaults, cfg, getter, i, len, name, names, prop;
    for (name in instanceConfig) {
      cfg = configs[name];
      if (defaults && instance.hasOwnProperty(cfg && instance.$configPrefixed ? cfg.names.internal : name)) {
        continue;
      }
      currentConfig[name] = instanceConfig[name];
      if (cfg) {
        instance[cfg.names.get] = cfg.initGetter || cfg.getInitGetter();
      } else {
        prop = instance.self.prototype[name];
        if (strict) {
          if (typeof prop === 'function' && !prop.$nullFn) {
            continue;
          }
        }
      }
      configList.push(name);
    }
    for (i = 0, len = configList.length; i < len; i++) {
      name = configList[i];
      cfg = configs[name];
      if (cfg) {
        names = cfg.names;
        getter = names.get;
        if (instance.hasOwnProperty(getter)) {
          instance[names.set](instanceConfig[name]);
          delete instance[getter];
        }
      } else {
        cfg = configPropMap[name] || Ext.Config.get(name);
        names = cfg.names;
        if (instance[names.set]) {
          instance[names.set](instanceConfig[name]);
        } else {
          instance[name] = instanceConfig[name];
        }
      }
    }
  }, resolvePlatformConfig:function(instance, instanceConfig) {
    var platformConfig = instanceConfig && instanceConfig.platformConfig, ret = instanceConfig, i, keys, n;
    if (platformConfig) {
      keys = Ext.getPlatformConfigKeys(platformConfig);
      n = keys.length;
      if (n) {
        ret = Ext.merge({}, ret);
        for (i = 0, n = keys.length; i < n; ++i) {
          this.merge(instance, ret, platformConfig[keys[i]]);
        }
      }
    }
    return ret;
  }};
})();
Ext.Base = function(flexSetter) {
  var noArgs = [], baseStaticMember, baseStaticMembers = [], makeAliasFn = function(name) {
    return function() {
      return this[name].apply(this, arguments);
    };
  }, Version = Ext.Version, leadingDigitRe = /^\d/, oneMember = {}, aliasOneMember = {}, Base = function() {
  }, BasePrototype = Base.prototype, Reaper;
  Ext.Reaper = Reaper = {delay:100, queue:[], timer:null, add:function(obj) {
    if (!Reaper.timer) {
      Reaper.timer = Ext.defer(Reaper.tick, Reaper.delay);
    }
    Reaper.queue.push(obj);
  }, flush:function() {
    if (Reaper.timer) {
      Ext.undefer(Reaper.timer);
      Reaper.timer = null;
    }
    var queue = Reaper.queue, n = queue.length, i, obj;
    Reaper.queue = [];
    for (i = 0; i < n; ++i) {
      obj = queue[i];
      if (obj && obj.$reap) {
        obj.$reap();
      }
    }
  }, tick:function() {
    Reaper.timer = null;
    Reaper.flush();
  }};
  Ext.apply(Base, {$className:'Ext.Base', $isClass:true, create:function() {
    return Ext.create.apply(Ext, [this].concat(Array.prototype.slice.call(arguments, 0)));
  }, addDeprecations:function(deprecations) {
    var me = this, all = [], compatVersion = Ext.getCompatVersion(deprecations.name), deprecate, versionSpec, index, message, target, enabled, existing, fn, names, oldName, newName, member, statics, version;
    for (versionSpec in deprecations) {
      if (leadingDigitRe.test(versionSpec)) {
        version = new Ext.Version(versionSpec);
        version.deprecations = deprecations[versionSpec];
        all.push(version);
      }
    }
    all.sort(Version.compare);
    for (index = all.length; index--;) {
      deprecate = (version = all[index]).deprecations;
      target = me.prototype;
      statics = deprecate.statics;
      enabled = compatVersion && compatVersion.lt(version);
      if (!enabled) {
        break;
      }
      while (deprecate) {
        names = deprecate.methods;
        if (names) {
          for (oldName in names) {
            member = names[oldName];
            fn = null;
            if (!member) {
            } else {
              if (Ext.isString(member)) {
                if (enabled) {
                  fn = makeAliasFn(member);
                }
              } else {
                message = '';
                if (member.message || member.fn) {
                  member = member.fn;
                }
                existing = target.hasOwnProperty(oldName) && target[oldName];
                if (enabled && member) {
                  member.$owner = me;
                  member.$name = oldName;
                  if (existing) {
                    member.$previous = existing;
                  }
                  fn = member;
                }
              }
            }
            if (fn) {
              target[oldName] = fn;
            }
          }
        }
        deprecate = statics;
        statics = null;
        target = me;
      }
    }
  }, extend:function(parentClass) {
    var me = this, parentPrototype = parentClass.prototype, prototype, name, statics;
    prototype = me.prototype = Ext.Object.chain(parentPrototype);
    prototype.self = me;
    me.superclass = prototype.superclass = parentPrototype;
    if (!parentClass.$isClass) {
      for (name in BasePrototype) {
        if (name in prototype) {
          prototype[name] = BasePrototype[name];
        }
      }
    }
    statics = parentPrototype.$inheritableStatics;
    if (statics) {
      for (name in statics) {
        if (!me.hasOwnProperty(name)) {
          me[name] = parentClass[name];
        }
      }
    }
    if (parentClass.$onExtended) {
      me.$onExtended = parentClass.$onExtended.slice();
    }
    me.getConfigurator();
  }, $onExtended:[], triggerExtended:function() {
    var callbacks = this.$onExtended, ln = callbacks.length, i, callback;
    if (ln > 0) {
      for (i = 0; i < ln; i++) {
        callback = callbacks[i];
        callback.fn.apply(callback.scope || this, arguments);
      }
    }
  }, onExtended:function(fn, scope) {
    this.$onExtended.push({fn:fn, scope:scope});
    return this;
  }, addStatics:function(members) {
    this.addMembers(members, true);
    return this;
  }, addInheritableStatics:function(members) {
    var me = this, proto = me.prototype, inheritableStatics = me.$inheritableStatics, name, member, current;
    if (!inheritableStatics) {
      inheritableStatics = Ext.apply({}, proto.$inheritableStatics);
      me.$inheritableStatics = proto.$inheritableStatics = inheritableStatics;
    }
    for (name in members) {
      if (members.hasOwnProperty(name)) {
        member = members[name];
        current = me[name];
        if (typeof current === 'function' && !current.$isClass && !current.$nullFn) {
          member.$previous = current;
        }
        me[name] = member;
        inheritableStatics[name] = true;
      }
    }
    return me;
  }, addMembers:function(members, isStatic, privacy) {
    var me = this, cloneFunction = Ext.Function.clone, target = isStatic ? me : me.prototype, defaultConfig = !isStatic && target.defaultConfig, enumerables = Ext.enumerables, privates = members.privates, configs, i, ln, member, name, subPrivacy, privateStatics;
    if (privates) {
      delete members.privates;
      if (!isStatic) {
        privateStatics = privates.statics;
        delete privates.statics;
      }
      me.addMembers(privates, isStatic, subPrivacy);
      if (privateStatics) {
        me.addMembers(privateStatics, true, subPrivacy);
      }
    }
    for (name in members) {
      if (members.hasOwnProperty(name)) {
        member = members[name];
        if (typeof member === 'function' && !member.$isClass && !member.$nullFn) {
          if (member.$owner) {
            member = cloneFunction(member);
          }
          if (target.hasOwnProperty(name)) {
            member.$previous = target[name];
          }
          member.$owner = me;
          member.$name = name;
        } else {
          if (defaultConfig && name in defaultConfig && !target.config.hasOwnProperty(name)) {
            (configs || (configs = {}))[name] = member;
            continue;
          }
        }
        target[name] = member;
      }
    }
    if (configs) {
      me.addConfig(configs);
    }
    if (enumerables) {
      for (i = 0, ln = enumerables.length; i < ln; ++i) {
        if (members.hasOwnProperty(name = enumerables[i])) {
          member = members[name];
          if (member && !member.$nullFn) {
            if (member.$owner) {
              member = cloneFunction(member);
            }
            member.$owner = me;
            member.$name = name;
            if (target.hasOwnProperty(name)) {
              member.$previous = target[name];
            }
          }
          target[name] = member;
        }
      }
    }
    return this;
  }, addMember:function(name, member) {
    oneMember[name] = member;
    this.addMembers(oneMember);
    delete oneMember[name];
    return this;
  }, borrow:function(fromClass, members) {
    var prototype = fromClass.prototype, membersObj = {}, i, ln, name;
    members = Ext.Array.from(members);
    for (i = 0, ln = members.length; i < ln; i++) {
      name = members[i];
      membersObj[name] = prototype[name];
    }
    return this.addMembers(membersObj);
  }, override:function(members) {
    var me = this, statics = members.statics, inheritableStatics = members.inheritableStatics, config = members.config, mixins = members.mixins, cachedConfig = members.cachedConfig;
    if (statics || inheritableStatics || config) {
      members = Ext.apply({}, members);
    }
    if (statics) {
      me.addMembers(statics, true);
      delete members.statics;
    }
    if (inheritableStatics) {
      me.addInheritableStatics(inheritableStatics);
      delete members.inheritableStatics;
    }
    if (members.platformConfig) {
      me.addPlatformConfig(members);
    }
    if (config) {
      me.addConfig(config);
      delete members.config;
    }
    if (cachedConfig) {
      me.addCachedConfig(cachedConfig);
      delete members.cachedConfig;
    }
    delete members.mixins;
    me.addMembers(members);
    if (mixins) {
      me.mixin(mixins);
    }
    return me;
  }, addPlatformConfig:function(data) {
    var me = this, prototype = me.prototype, platformConfigs = data.platformConfig, added, classConfigs, configs, configurator, keys, name, value, i, ln;
    delete prototype.platformConfig;
    configurator = me.getConfigurator();
    classConfigs = configurator.configs;
    keys = Ext.getPlatformConfigKeys(platformConfigs);
    for (i = 0, ln = keys.length; i < ln; ++i) {
      configs = platformConfigs[keys[i]];
      added = null;
      for (name in configs) {
        value = configs[name];
        if (name in classConfigs) {
          (added || (added = {}))[name] = value;
        } else {
          prototype[name] = value;
        }
      }
      if (added) {
        configurator.add(added);
      }
    }
  }, callParent:function(args) {
    var method;
    return (method = this.callParent.caller) && (method.$previous || (method = method.$owner ? method : method.caller) && method.$owner.superclass.self[method.$name]).apply(this, args || noArgs);
  }, callSuper:function(args) {
    var method;
    return (method = this.callSuper.caller) && ((method = method.$owner ? method : method.caller) && method.$owner.superclass.self[method.$name]).apply(this, args || noArgs);
  }, mixin:function(name, mixinClass) {
    var me = this, mixin, prototype, key, statics, i, ln, mixinName, mixinValue, mixins, mixinStatics, staticName;
    if (typeof name !== 'string') {
      mixins = name;
      if (mixins instanceof Array) {
        for (i = 0, ln = mixins.length; i < ln; i++) {
          mixin = mixins[i];
          me.mixin(mixin.prototype.mixinId || mixin.$className, mixin);
        }
      } else {
        for (mixinName in mixins) {
          me.mixin(mixinName, mixins[mixinName]);
        }
      }
      return;
    }
    mixin = mixinClass.prototype;
    prototype = me.prototype;
    if (mixin.onClassMixedIn) {
      mixin.onClassMixedIn.call(mixinClass, me);
    }
    if (!prototype.hasOwnProperty('mixins')) {
      if ('mixins' in prototype) {
        prototype.mixins = Ext.Object.chain(prototype.mixins);
      } else {
        prototype.mixins = {};
      }
    }
    for (key in mixin) {
      mixinValue = mixin[key];
      if (key === 'mixins') {
        Ext.applyIf(prototype.mixins, mixinValue);
      } else {
        if (!(key === 'mixinId' || key === 'config' || key === '$inheritableStatics') && prototype[key] === undefined) {
          prototype[key] = mixinValue;
        }
      }
    }
    statics = mixin.$inheritableStatics;
    if (statics) {
      mixinStatics = {};
      for (staticName in statics) {
        if (!me.hasOwnProperty(staticName)) {
          mixinStatics[staticName] = mixinClass[staticName];
        }
      }
      me.addInheritableStatics(mixinStatics);
    }
    if ('config' in mixin) {
      me.addConfig(mixin.config, mixinClass);
    }
    prototype.mixins[name] = mixin;
    if (mixin.afterClassMixedIn) {
      mixin.afterClassMixedIn.call(mixinClass, me);
    }
    return me;
  }, addConfig:function(config, mixinClass) {
    var cfg = this.$config || this.getConfigurator();
    cfg.add(config, mixinClass);
  }, addCachedConfig:function(config, isMixin) {
    var cached = {}, key;
    for (key in config) {
      cached[key] = {cached:true, $value:config[key]};
    }
    this.addConfig(cached, isMixin);
  }, getConfigurator:function() {
    return this.$config || new Ext.Configurator(this);
  }, getName:function() {
    return Ext.getClassName(this);
  }, createAlias:flexSetter(function(alias, origin) {
    aliasOneMember[alias] = function() {
      return this[origin].apply(this, arguments);
    };
    this.override(aliasOneMember);
    delete aliasOneMember[alias];
  })});
  for (baseStaticMember in Base) {
    if (Base.hasOwnProperty(baseStaticMember)) {
      baseStaticMembers.push(baseStaticMember);
    }
  }
  Base.$staticMembers = baseStaticMembers;
  Base.getConfigurator();
  Base.addMembers({$className:'Ext.Base', isInstance:true, $configPrefixed:true, $configStrict:true, isConfiguring:false, isFirstInstance:false, destroyed:false, clearPropertiesOnDestroy:true, clearPrototypeOnDestroy:false, statics:function() {
    var method = this.statics.caller, self = this.self;
    if (!method) {
      return self;
    }
    return method.$owner;
  }, callParent:function(args) {
    var method, superMethod = (method = this.callParent.caller) && (method.$previous || (method = method.$owner ? method : method.caller) && method.$owner.superclass[method.$name]);
    return superMethod.apply(this, args || noArgs);
  }, callSuper:function(args) {
    var method, superMethod = (method = this.callSuper.caller) && ((method = method.$owner ? method : method.caller) && method.$owner.superclass[method.$name]);
    return superMethod.apply(this, args || noArgs);
  }, self:Base, constructor:function() {
    return this;
  }, initConfig:function(instanceConfig) {
    var me = this, cfg = me.self.getConfigurator();
    me.initConfig = Ext.emptyFn;
    me.initialConfig = instanceConfig || {};
    cfg.configure(me, instanceConfig);
    return me;
  }, beforeInitConfig:Ext.emptyFn, getConfig:function(name, peek, ifInitialized) {
    var me = this, ret, cfg, propName;
    if (name) {
      cfg = me.self.$config.configs[name];
      if (cfg) {
        propName = me.$configPrefixed ? cfg.names.internal : name;
        if (ifInitialized) {
          ret = me.hasOwnProperty(propName) ? me[propName] : null;
        } else {
          if (peek) {
            ret = me.hasOwnProperty(propName) ? me[propName] : me.config[name];
          } else {
            ret = me[cfg.names.get]();
          }
        }
      } else {
        ret = me[name];
      }
    } else {
      ret = me.getCurrentConfig();
    }
    return ret;
  }, destroyMembers:function() {
    var me = this, configs = me.self.$config.configs, len = arguments.length, cfg, name, value, i;
    for (i = 0; i < len; i++) {
      name = arguments[i];
      cfg = configs[name];
      name = cfg && me.$configPrefixed ? cfg.names.internal : name;
      value = me.hasOwnProperty(name) && me[name];
      if (value) {
        Ext.destroy(value);
        me[name] = null;
      }
    }
  }, freezeConfig:function(name) {
    var me = this, config = Ext.Config.get(name), names = config.names, value = me[names.get]();
    me[names.set] = function(v) {
      return me;
    };
  }, setConfig:function(name, value, options) {
    var me = this, configurator, config, prop;
    if (name) {
      configurator = me.self.getConfigurator();
      if (typeof name === 'string') {
        config = configurator.configs[name];
        if (!config) {
          if (me.$configStrict) {
            prop = me.self.prototype[name];
            if (typeof prop === 'function' && !prop.$nullFn) {
              return me;
            }
          }
          config = Ext.Config.map[name] || Ext.Config.get(name);
        }
        if (me[config.names.set]) {
          me[config.names.set](value);
        } else {
          me[name] = value;
        }
      } else {
        configurator.reconfigure(me, name, options || value);
      }
    }
    return me;
  }, getCurrentConfig:function() {
    var cfg = this.self.getConfigurator();
    return cfg.getCurrentConfig(this);
  }, hasConfig:function(name) {
    return name in this.defaultConfig;
  }, getInitialConfig:function(name) {
    var config = this.config;
    if (!name) {
      return config;
    }
    return config[name];
  }, $links:null, link:function(name, value) {
    var me = this, links = me.$links || (me.$links = {});
    links[name] = true;
    me[name] = value;
    return value;
  }, unlink:function(names) {
    var me = this, i, ln, link, value;
    for (i = 0, ln = names.length; i < ln; i++) {
      link = names[i];
      value = me[link];
      if (value) {
        if (value.isInstance && !value.destroyed) {
          value.destroy();
        } else {
          if (value.parentNode && 'nodeType' in value) {
            value.parentNode.removeChild(value);
          }
        }
      }
      me[link] = null;
    }
    return me;
  }, $reap:function() {
    var me = this, protectedProps = me.$noClearOnDestroy, props, prop, value, type, i, len;
    props = Ext.Object.getKeys(me);
    for (i = 0, len = props.length; i < len; i++) {
      prop = props[i];
      if (!protectedProps || !protectedProps[prop]) {
        value = me[prop];
        type = typeof value;
        if (type === 'object' || type === 'function' && !value.$noClearOnDestroy) {
          me[prop] = null;
        }
      }
    }
    me.$nulled = true;
  }, destroy:function() {
    var me = this, links = me.$links, clearPropertiesOnDestroy = me.clearPropertiesOnDestroy;
    if (links) {
      me.$links = null;
      me.unlink(Ext.Object.getKeys(links));
    }
    me.destroy = Ext.emptyFn;
    me.isDestroyed = me.destroyed = true;
    if (clearPropertiesOnDestroy === true) {
      if (!me.isObservable) {
        me.$reap();
      }
    } else {
      if (clearPropertiesOnDestroy) {
        Reaper.add(me);
      }
    }
  }});
  BasePrototype.callOverridden = BasePrototype.callParent;
  return Base;
}(Ext.Function.flexSetter);
(function(LRU, prototype) {
  (Ext.util || (Ext.util = {})).LRU = LRU = function(config) {
    var me = this, head;
    if (config) {
      Ext.apply(me, config);
    }
    me.head = head = {key:null, value:null};
    me.map = {};
    head.next = head.prev = head;
  };
  LRU.prototype = prototype = {count:0, add:function(key, value) {
    var me = this, map = me.map, entry = map[key];
    if (entry) {
      me.unlink(entry);
      --me.count;
    }
    map[key] = entry = {key:key, value:value};
    me.link(entry);
    ++me.count;
    return entry;
  }, clear:function(fn, scope) {
    var me = this, head = me.head, entry = head.next;
    head.next = head.prev = head;
    me.count = 0;
    if (fn && !fn.$nullFn) {
      for (; entry !== head; entry = entry.next) {
        fn.call(scope || me, entry.key, entry.value);
      }
    }
  }, each:function(fn, scope) {
    scope = scope || this;
    for (var head = this.head, ent = head.next; ent !== head; ent = ent.next) {
      if (fn.call(scope, ent.key, ent.value)) {
        break;
      }
    }
  }, prune:function(fn, scope) {
    var me = this, entry = me.head.prev, ret;
    if (me.count) {
      ret = entry.value;
      me.unlink(entry);
      --me.count;
      if (fn) {
        fn.call(scope || me, entry.key, ret);
      }
    }
    return ret;
  }, remove:function(key) {
    var me = this, map = me.map, entry = map[key], value;
    if (entry) {
      me.unlink(entry);
      value = entry.value;
      delete map[key];
      --me.count;
    }
    return value;
  }, touch:function(key) {
    var me = this, head = me.head, entry = me.map[key];
    if (entry && entry.prev !== head) {
      me.unlink(entry);
      me.link(entry);
    }
  }, trim:function(size, fn, scope) {
    while (this.count > size) {
      this.prune(fn, scope);
    }
  }, link:function(entry) {
    var head = this.head, first = head.next;
    entry.next = first;
    entry.prev = head;
    head.next = entry;
    first.prev = entry;
  }, unlink:function(entry) {
    var next = entry.next, prev = entry.prev;
    prev.next = next;
    next.prev = prev;
  }};
  prototype.destroy = function() {
    this.clear.apply(this, arguments);
  };
})();
(function(LRU, fn, Cache) {
  Ext.util.Cache = Cache = function(config) {
    LRU.call(this, config);
  };
  fn.prototype = LRU.prototype;
  Cache.prototype = Ext.apply(new fn, {maxSize:100, clear:function() {
    LRU.prototype.clear.call(this, this.evict);
  }, get:function(key) {
    var me = this, entry = me.map[key], value;
    if (entry) {
      value = entry.value;
      me.touch(key);
    } else {
      value = me.miss.apply(me, arguments);
      me.add(key, value);
      me.trim(me.maxSize, me.evict);
    }
    return value;
  }, evict:Ext.emptyFn});
})(Ext.util.LRU, function() {
});
(function() {
  var ExtClass, Base = Ext.Base, baseStaticMembers = Base.$staticMembers, ruleKeySortFn = function(a, b) {
    return a.length - b.length || (a < b ? -1 : a > b ? 1 : 0);
  };
  function makeCtor(className) {
    function constructor() {
      return this.constructor.apply(this, arguments) || null;
    }
    return constructor;
  }
  Ext.Class = ExtClass = function(Class, data, onCreated) {
    if (typeof Class != 'function') {
      onCreated = data;
      data = Class;
      Class = null;
    }
    if (!data) {
      data = {};
    }
    Class = ExtClass.create(Class, data);
    ExtClass.process(Class, data, onCreated);
    return Class;
  };
  Ext.apply(ExtClass, {makeCtor:makeCtor, onBeforeCreated:function(Class, data, hooks) {
    Class.addMembers(data);
    hooks.onCreated.call(Class, Class);
  }, create:function(Class, data) {
    var i = baseStaticMembers.length, name;
    if (!Class) {
      Class = makeCtor();
    }
    while (i--) {
      name = baseStaticMembers[i];
      Class[name] = Base[name];
    }
    return Class;
  }, process:function(Class, data, onCreated) {
    var preprocessorStack = data.preprocessors || ExtClass.defaultPreprocessors, registeredPreprocessors = this.preprocessors, hooks = {onBeforeCreated:this.onBeforeCreated}, preprocessors = [], preprocessor, preprocessorsProperties, i, ln, j, subLn, preprocessorProperty;
    delete data.preprocessors;
    Class._classHooks = hooks;
    for (i = 0, ln = preprocessorStack.length; i < ln; i++) {
      preprocessor = preprocessorStack[i];
      if (typeof preprocessor == 'string') {
        preprocessor = registeredPreprocessors[preprocessor];
        preprocessorsProperties = preprocessor.properties;
        if (preprocessorsProperties === true) {
          preprocessors.push(preprocessor.fn);
        } else {
          if (preprocessorsProperties) {
            for (j = 0, subLn = preprocessorsProperties.length; j < subLn; j++) {
              preprocessorProperty = preprocessorsProperties[j];
              if (data.hasOwnProperty(preprocessorProperty)) {
                preprocessors.push(preprocessor.fn);
                break;
              }
            }
          }
        }
      } else {
        preprocessors.push(preprocessor);
      }
    }
    hooks.onCreated = onCreated ? onCreated : Ext.emptyFn;
    hooks.preprocessors = preprocessors;
    this.doProcess(Class, data, hooks);
  }, doProcess:function(Class, data, hooks) {
    var me = this, preprocessors = hooks.preprocessors, preprocessor = preprocessors.shift(), doProcess = me.doProcess;
    for (; preprocessor; preprocessor = preprocessors.shift()) {
      if (preprocessor.call(me, Class, data, hooks, doProcess) === false) {
        return;
      }
    }
    hooks.onBeforeCreated.apply(me, arguments);
  }, preprocessors:{}, registerPreprocessor:function(name, fn, properties, position, relativeTo) {
    if (!position) {
      position = 'last';
    }
    if (!properties) {
      properties = [name];
    }
    this.preprocessors[name] = {name:name, properties:properties || false, fn:fn};
    this.setDefaultPreprocessorPosition(name, position, relativeTo);
    return this;
  }, getPreprocessor:function(name) {
    return this.preprocessors[name];
  }, getPreprocessors:function() {
    return this.preprocessors;
  }, defaultPreprocessors:[], getDefaultPreprocessors:function() {
    return this.defaultPreprocessors;
  }, setDefaultPreprocessors:function(preprocessors) {
    this.defaultPreprocessors = Ext.Array.from(preprocessors);
    return this;
  }, setDefaultPreprocessorPosition:function(name, offset, relativeName) {
    var defaultPreprocessors = this.defaultPreprocessors, index;
    if (typeof offset == 'string') {
      if (offset === 'first') {
        defaultPreprocessors.unshift(name);
        return this;
      } else {
        if (offset === 'last') {
          defaultPreprocessors.push(name);
          return this;
        }
      }
      offset = offset === 'after' ? 1 : -1;
    }
    index = Ext.Array.indexOf(defaultPreprocessors, relativeName);
    if (index !== -1) {
      Ext.Array.splice(defaultPreprocessors, Math.max(0, index + offset), 0, name);
    }
    return this;
  }});
  ExtClass.registerPreprocessor('extend', function(Class, data, hooks) {
    var Base = Ext.Base, basePrototype = Base.prototype, extend = data.extend, Parent, parentPrototype, i;
    delete data.extend;
    if (extend && extend !== Object) {
      Parent = extend;
    } else {
      Parent = Base;
    }
    parentPrototype = Parent.prototype;
    if (!Parent.$isClass) {
      for (i in basePrototype) {
        if (!parentPrototype[i]) {
          parentPrototype[i] = basePrototype[i];
        }
      }
    }
    Class.extend(Parent);
    Class.triggerExtended.apply(Class, arguments);
    if (data.onClassExtended) {
      Class.onExtended(data.onClassExtended, Class);
      delete data.onClassExtended;
    }
  }, true);
  ExtClass.registerPreprocessor('privates', function(Class, data) {
    var privates = data.privates, statics = privates.statics, privacy = privates.privacy || true;
    delete data.privates;
    delete privates.statics;
    Class.addMembers(privates, false, privacy);
    if (statics) {
      Class.addMembers(statics, true, privacy);
    }
  });
  ExtClass.registerPreprocessor('statics', function(Class, data) {
    Class.addStatics(data.statics);
    delete data.statics;
  });
  ExtClass.registerPreprocessor('inheritableStatics', function(Class, data) {
    Class.addInheritableStatics(data.inheritableStatics);
    delete data.inheritableStatics;
  });
  Ext.createRuleFn = function(code) {
    return new Function('$c', 'with($c) { try { return (' + code + '); } catch(e) { return false;}}');
  };
  Ext.expressionCache = new Ext.util.Cache({miss:Ext.createRuleFn});
  Ext.ruleKeySortFn = ruleKeySortFn;
  Ext.getPlatformConfigKeys = function(platformConfig) {
    var ret = [], platform, rule;
    for (platform in platformConfig) {
      rule = Ext.expressionCache.get(platform);
      if (rule(Ext.platformTags)) {
        ret.push(platform);
      }
    }
    ret.sort(ruleKeySortFn);
    return ret;
  };
  ExtClass.registerPreprocessor('config', function(Class, data) {
    if (data.hasOwnProperty('$configPrefixed')) {
      Class.prototype.$configPrefixed = data.$configPrefixed;
    }
    Class.addConfig(data.config);
    delete data.config;
  });
  ExtClass.registerPreprocessor('cachedConfig', function(Class, data) {
    if (data.hasOwnProperty('$configPrefixed')) {
      Class.prototype.$configPrefixed = data.$configPrefixed;
    }
    Class.addCachedConfig(data.cachedConfig);
    delete data.cachedConfig;
  });
  ExtClass.registerPreprocessor('mixins', function(Class, data, hooks) {
    var mixins = data.mixins, onCreated = hooks.onCreated;
    delete data.mixins;
    hooks.onCreated = function() {
      hooks.onCreated = onCreated;
      Class.mixin(mixins);
      return hooks.onCreated.apply(this, arguments);
    };
  });
  Ext.extend = function(Class, Parent, members) {
    if (arguments.length === 2 && Ext.isObject(Parent)) {
      members = Parent;
      Parent = Class;
      Class = null;
    }
    var cls;
    if (!Parent) {
      throw new Error('[Ext.extend] Attempting to extend from a class which has not been loaded on the page.');
    }
    members.extend = Parent;
    members.preprocessors = ['extend', 'statics', 'inheritableStatics', 'mixins', 'config'];
    if (Class) {
      cls = new ExtClass(Class, members);
      cls.prototype.constructor = Class;
    } else {
      cls = new ExtClass(members);
    }
    cls.prototype.override = function(o) {
      for (var m in o) {
        if (o.hasOwnProperty(m)) {
          this[m] = o[m];
        }
      }
    };
    return cls;
  };
})();
Ext.Inventory = function() {
  var me = this;
  me.names = [];
  me.paths = {};
  me.alternateToName = {};
  me.aliasToName = {};
  me.nameToAliases = {};
  me.nameToAlternates = {};
  me.nameToPrefix = {};
};
Ext.Inventory.prototype = {_array1:[0], prefixes:null, dotRe:/\./g, wildcardRe:/\*/g, addAlias:function(className, alias, update) {
  return this.addMapping(className, alias, this.aliasToName, this.nameToAliases, update);
}, addAlternate:function(className, alternate) {
  return this.addMapping(className, alternate, this.alternateToName, this.nameToAlternates);
}, addMapping:function(className, alternate, toName, nameTo, update) {
  var name = className.$className || className, mappings = name, array = this._array1, a, aliases, cls, i, length, nameMapping;
  if (Ext.isString(name)) {
    mappings = {};
    mappings[name] = alternate;
  }
  for (cls in mappings) {
    aliases = mappings[cls];
    if (Ext.isString(aliases)) {
      array[0] = aliases;
      aliases = array;
    }
    length = aliases.length;
    nameMapping = nameTo[cls] || (nameTo[cls] = []);
    for (i = 0; i < length; ++i) {
      if (!(a = aliases[i])) {
        continue;
      }
      if (toName[a] !== cls) {
        toName[a] = cls;
        nameMapping.push(a);
      }
    }
  }
}, getAliasesByName:function(name) {
  return this.nameToAliases[name] || null;
}, getAlternatesByName:function(name) {
  return this.nameToAlternates[name] || null;
}, getNameByAlias:function(alias) {
  return this.aliasToName[alias] || '';
}, getNameByAlternate:function(alternate) {
  return this.alternateToName[alternate] || '';
}, getNamesByExpression:function(expression, exclude, accumulate) {
  var me = this, aliasToName = me.aliasToName, alternateToName = me.alternateToName, nameToAliases = me.nameToAliases, nameToAlternates = me.nameToAlternates, map = accumulate ? exclude : {}, names = [], expressions = Ext.isString(expression) ? [expression] : expression, length = expressions.length, wildcardRe = me.wildcardRe, expr, i, list, match, n, name, regex;
  for (i = 0; i < length; ++i) {
    if ((expr = expressions[i]).indexOf('*') < 0) {
      if (!(name = aliasToName[expr])) {
        if (!(name = alternateToName[expr])) {
          name = expr;
        }
      }
      if (!(name in map) && !(exclude && name in exclude)) {
        map[name] = 1;
        names.push(name);
      }
    } else {
      regex = new RegExp('^' + expr.replace(wildcardRe, '(.*?)') + '$');
      for (name in nameToAliases) {
        if (!(name in map) && !(exclude && name in exclude)) {
          if (!(match = regex.test(name))) {
            n = (list = nameToAliases[name]).length;
            while (!match && n-- > 0) {
              match = regex.test(list[n]);
            }
            list = nameToAlternates[name];
            if (list && !match) {
              n = list.length;
              while (!match && n-- > 0) {
                match = regex.test(list[n]);
              }
            }
          }
          if (match) {
            map[name] = 1;
            names.push(name);
          }
        }
      }
    }
  }
  return names;
}, getPath:function(className) {
  var me = this, paths = me.paths, ret = '', prefix;
  if (className in paths) {
    ret = paths[className];
  } else {
    prefix = me.nameToPrefix[className] || (me.nameToPrefix[className] = me.getPrefix(className));
    if (prefix) {
      className = className.substring(prefix.length + 1);
      ret = paths[prefix];
      if (ret) {
        ret += '/';
      }
    }
    ret += className.replace(me.dotRe, '/') + '.js';
  }
  return ret;
}, getPrefix:function(className) {
  if (className in this.paths) {
    return className;
  } else {
    if (className in this.nameToPrefix) {
      return this.nameToPrefix[className];
    }
  }
  var prefixes = this.getPrefixes(), length = className.length, items, currChar, currSubstr, prefix, j, jlen;
  while (length-- > 0) {
    items = prefixes[length];
    if (items) {
      currChar = className.charAt(length);
      if (currChar !== '.') {
        continue;
      }
      currSubstr = className.substring(0, length);
      for (j = 0, jlen = items.length; j < jlen; j++) {
        prefix = items[j];
        if (prefix === className.substring(0, length)) {
          return prefix;
        }
      }
    }
  }
  return '';
}, getPrefixes:function() {
  var me = this, prefixes = me.prefixes, names, name, nameLength, items, i, len;
  if (!prefixes) {
    names = me.names.slice(0);
    me.prefixes = prefixes = [];
    for (i = 0, len = names.length; i < len; i++) {
      name = names[i];
      nameLength = name.length;
      items = prefixes[nameLength] || (prefixes[nameLength] = []);
      items.push(name);
    }
  }
  return prefixes;
}, removeName:function(name) {
  var me = this, aliasToName = me.aliasToName, alternateToName = me.alternateToName, nameToAliases = me.nameToAliases, nameToAlternates = me.nameToAlternates, aliases = nameToAliases[name], alternates = nameToAlternates[name], i, a;
  delete nameToAliases[name];
  delete nameToAlternates[name];
  delete me.nameToPrefix[name];
  if (aliases) {
    for (i = aliases.length; i--;) {
      if (name === aliasToName[a = aliases[i]]) {
        delete aliasToName[a];
      }
    }
  }
  if (alternates) {
    for (i = alternates.length; i--;) {
      if (name === alternateToName[a = alternates[i]]) {
        delete alternateToName[a];
      }
    }
  }
}, resolveName:function(name) {
  var me = this, trueName;
  if (!(name in me.nameToAliases)) {
    if (!(trueName = me.aliasToName[name])) {
      trueName = me.alternateToName[name];
    }
  }
  return trueName || name;
}, select:function(receiver, scope) {
  var me = this, excludes = {}, ret = {excludes:excludes, exclude:function() {
    me.getNamesByExpression(arguments[0], excludes, true);
    return this;
  }}, name;
  for (name in receiver) {
    ret[name] = me.selectMethod(excludes, receiver[name], scope || receiver);
  }
  return ret;
}, selectMethod:function(excludes, fn, scope) {
  var me = this;
  return function(include) {
    var args = Ext.Array.slice(arguments, 1);
    args.unshift(me.getNamesByExpression(include, excludes));
    return fn.apply(scope, args);
  };
}, setPath:Ext.Function.flexSetter(function(name, path) {
  var me = this;
  me.paths[name] = path;
  me.names.push(name);
  me.prefixes = null;
  me.nameToPrefix = {};
  return me;
})};
Ext.ClassManager = function(Class, alias, arraySlice, arrayFrom, global) {
  var makeCtor = Ext.Class.makeCtor, nameLookupStack = [], namespaceCache = {Ext:{name:'Ext', value:Ext}}, Manager = Ext.apply(new Ext.Inventory, {classes:{}, classState:{}, existCache:{}, instantiators:[], isCreated:function(className) {
    if (Manager.classes[className] || Manager.existCache[className]) {
      return true;
    }
    if (!Manager.lookupName(className, false)) {
      return false;
    }
    Manager.triggerCreated(className);
    return true;
  }, createdListeners:[], nameCreatedListeners:{}, existsListeners:[], nameExistsListeners:{}, overrideMap:{}, triggerCreated:function(className, state) {
    Manager.existCache[className] = state || 1;
    Manager.classState[className] += 40;
    Manager.notify(className, Manager.createdListeners, Manager.nameCreatedListeners);
  }, onCreated:function(fn, scope, className) {
    Manager.addListener(fn, scope, className, Manager.createdListeners, Manager.nameCreatedListeners);
  }, notify:function(className, listeners, nameListeners) {
    var alternateNames = Manager.getAlternatesByName(className), names = [className], i, ln, j, subLn, listener, name;
    for (i = 0, ln = listeners.length; i < ln; i++) {
      listener = listeners[i];
      listener.fn.call(listener.scope, className);
    }
    while (names) {
      for (i = 0, ln = names.length; i < ln; i++) {
        name = names[i];
        listeners = nameListeners[name];
        if (listeners) {
          for (j = 0, subLn = listeners.length; j < subLn; j++) {
            listener = listeners[j];
            listener.fn.call(listener.scope, name);
          }
          delete nameListeners[name];
        }
      }
      names = alternateNames;
      alternateNames = null;
    }
  }, addListener:function(fn, scope, className, listeners, nameListeners) {
    if (Ext.isArray(className)) {
      fn = Ext.Function.createBarrier(className.length, fn, scope);
      for (i = 0; i < className.length; i++) {
        this.addListener(fn, null, className[i], listeners, nameListeners);
      }
      return;
    }
    var i, listener = {fn:fn, scope:scope};
    if (className) {
      if (this.isCreated(className)) {
        fn.call(scope, className);
        return;
      }
      if (!nameListeners[className]) {
        nameListeners[className] = [];
      }
      nameListeners[className].push(listener);
    } else {
      listeners.push(listener);
    }
  }, $namespaceCache:namespaceCache, addRootNamespaces:function(namespaces) {
    for (var name in namespaces) {
      namespaceCache[name] = {name:name, value:namespaces[name]};
    }
  }, clearNamespaceCache:function() {
    nameLookupStack.length = 0;
    for (var name in namespaceCache) {
      if (!namespaceCache[name].value) {
        delete namespaceCache[name];
      }
    }
  }, getNamespaceEntry:function(namespace) {
    if (typeof namespace !== 'string') {
      return namespace;
    }
    var entry = namespaceCache[namespace], i;
    if (!entry) {
      i = namespace.lastIndexOf('.');
      if (i < 0) {
        entry = {name:namespace};
      } else {
        entry = {name:namespace.substring(i + 1), parent:Manager.getNamespaceEntry(namespace.substring(0, i))};
      }
      namespaceCache[namespace] = entry;
    }
    return entry;
  }, lookupName:function(namespace, autoCreate) {
    var entry = Manager.getNamespaceEntry(namespace), scope = Ext.global, i = 0, e, parent;
    for (e = entry; e; e = e.parent) {
      nameLookupStack[i++] = e;
    }
    while (scope && i-- > 0) {
      e = nameLookupStack[i];
      parent = scope;
      scope = e.value || scope[e.name];
      if (!scope && autoCreate) {
        parent[e.name] = scope = {};
      }
    }
    return scope;
  }, setNamespace:function(namespace, value) {
    var entry = Manager.getNamespaceEntry(namespace), scope = Ext.global;
    if (entry.parent) {
      scope = Manager.lookupName(entry.parent, true);
    }
    scope[entry.name] = value;
    return value;
  }, setXType:function(cls, xtype) {
    var className = cls.$className, C = className ? cls : Manager.get(className = cls), proto = C.prototype, xtypes = proto.xtypes, xtypesChain = proto.xtypesChain, xtypesMap = proto.xtypesMap;
    if (!proto.hasOwnProperty('xtypes')) {
      proto.xtypes = xtypes = [];
      proto.xtypesChain = xtypesChain = xtypesChain ? xtypesChain.slice(0) : [];
      proto.xtypesMap = xtypesMap = Ext.apply({}, xtypesMap);
    }
    Manager.addAlias(className, 'widget.' + xtype, true);
    xtypes.push(xtype);
    xtypesChain.push(xtype);
    xtypesMap[xtype] = true;
  }, set:function(name, value) {
    var targetName = Manager.getName(value);
    Manager.classes[name] = Manager.setNamespace(name, value);
    if (targetName && targetName !== name) {
      Manager.addAlternate(targetName, name);
    }
    return Manager;
  }, get:function(name) {
    return Manager.classes[name] || Manager.lookupName(name, false);
  }, addNameAliasMappings:function(aliases) {
    Manager.addAlias(aliases);
  }, addNameAlternateMappings:function(alternates) {
    Manager.addAlternate(alternates);
  }, getByAlias:function(alias) {
    return Manager.get(Manager.getNameByAlias(alias));
  }, getByConfig:function(config, aliasPrefix) {
    var xclass = config.xclass, name;
    if (xclass) {
      name = xclass;
    } else {
      name = config.xtype;
      if (name) {
        aliasPrefix = 'widget.';
      } else {
        name = config.type;
      }
      name = Manager.getNameByAlias(aliasPrefix + name);
    }
    return Manager.get(name);
  }, getName:function(object) {
    return object && object.$className || '';
  }, getClass:function(object) {
    return object && object.self || null;
  }, create:function(className, data, createdFn) {
    var ctor = makeCtor(className);
    if (typeof data === 'function') {
      data = data(ctor);
    }
    data.$className = className;
    return new Class(ctor, data, function() {
      var postprocessorStack = data.postprocessors || Manager.defaultPostprocessors, registeredPostprocessors = Manager.postprocessors, postprocessors = [], postprocessor, i, ln, j, subLn, postprocessorProperties, postprocessorProperty;
      delete data.postprocessors;
      for (i = 0, ln = postprocessorStack.length; i < ln; i++) {
        postprocessor = postprocessorStack[i];
        if (typeof postprocessor === 'string') {
          postprocessor = registeredPostprocessors[postprocessor];
          postprocessorProperties = postprocessor.properties;
          if (postprocessorProperties === true) {
            postprocessors.push(postprocessor.fn);
          } else {
            if (postprocessorProperties) {
              for (j = 0, subLn = postprocessorProperties.length; j < subLn; j++) {
                postprocessorProperty = postprocessorProperties[j];
                if (data.hasOwnProperty(postprocessorProperty)) {
                  postprocessors.push(postprocessor.fn);
                  break;
                }
              }
            }
          }
        } else {
          postprocessors.push(postprocessor);
        }
      }
      data.postprocessors = postprocessors;
      data.createdFn = createdFn;
      Manager.processCreate(className, this, data);
    });
  }, processCreate:function(className, cls, clsData) {
    var me = this, postprocessor = clsData.postprocessors.shift(), createdFn = clsData.createdFn;
    if (!postprocessor) {
      if (className) {
        me.set(className, cls);
      }
      delete cls._classHooks;
      if (createdFn) {
        createdFn.call(cls, cls);
      }
      if (className) {
        me.triggerCreated(className);
      }
      return;
    }
    if (postprocessor.call(me, className, cls, clsData, me.processCreate) !== false) {
      me.processCreate(className, cls, clsData);
    }
  }, createOverride:function(className, data, createdFn) {
    var me = this, overriddenClassName = data.override, requires = data.requires, uses = data.uses, mixins = data.mixins, mixinsIsArray, compat = 1, dependenciesLoaded, classReady = function() {
      var cls, dependencies, i, key, temp;
      if (!dependenciesLoaded) {
        dependencies = requires ? requires.slice(0) : [];
        if (mixins) {
          if (!(mixinsIsArray = mixins instanceof Array)) {
            for (key in mixins) {
              if (Ext.isString(cls = mixins[key])) {
                dependencies.push(cls);
              }
            }
          } else {
            for (i = 0, temp = mixins.length; i < temp; ++i) {
              if (Ext.isString(cls = mixins[i])) {
                dependencies.push(cls);
              }
            }
          }
        }
        dependenciesLoaded = true;
        if (dependencies.length) {
          Ext.require(dependencies, classReady);
          return;
        }
      }
      if (mixinsIsArray) {
        for (i = 0, temp = mixins.length; i < temp; ++i) {
          if (Ext.isString(cls = mixins[i])) {
            mixins[i] = Ext.ClassManager.get(cls);
          }
        }
      } else {
        if (mixins) {
          for (key in mixins) {
            if (Ext.isString(cls = mixins[key])) {
              mixins[key] = Ext.ClassManager.get(cls);
            }
          }
        }
      }
      cls = overriddenClassName.$isClass ? overriddenClassName : me.get(overriddenClassName);
      delete data.override;
      delete data.compatibility;
      delete data.requires;
      delete data.uses;
      Ext.override(cls, data);
      Ext.Loader.history.push(className);
      if (uses) {
        Ext['Loader'].addUsedClasses(uses);
      }
      if (createdFn) {
        createdFn.call(cls, cls);
      }
    };
    if (className) {
      Manager.overrideMap[className] = true;
    }
    if ('compatibility' in data) {
      compat = data.compatibility;
      if (!compat) {
        compat = false;
      } else {
        if (typeof compat === 'number') {
          compat = true;
        } else {
          if (typeof compat !== 'boolean') {
            compat = Ext.checkVersion(compat);
          }
        }
      }
    }
    if (compat) {
      if (overriddenClassName.$isClass) {
        classReady();
      } else {
        me.onCreated(classReady, me, overriddenClassName);
      }
    }
    me.triggerCreated(className, 2);
    return me;
  }, instantiateByAlias:function() {
    var alias = arguments[0], args = arraySlice.call(arguments), className = this.getNameByAlias(alias);
    args[0] = className;
    return Ext.create.apply(Ext, args);
  }, instantiate:function() {
    return Ext.create.apply(Ext, arguments);
  }, dynInstantiate:function(name, args) {
    args = arrayFrom(args, true);
    args.unshift(name);
    return Ext.create.apply(Ext, args);
  }, getInstantiator:function(length) {
    var instantiators = this.instantiators, instantiator, i, args;
    instantiator = instantiators[length];
    if (!instantiator) {
      i = length;
      args = [];
      for (i = 0; i < length; i++) {
        args.push('a[' + i + ']');
      }
      instantiator = instantiators[length] = new Function('c', 'a', 'return new c(' + args.join(',') + ')');
    }
    return instantiator;
  }, postprocessors:{}, defaultPostprocessors:[], registerPostprocessor:function(name, fn, properties, position, relativeTo) {
    if (!position) {
      position = 'last';
    }
    if (!properties) {
      properties = [name];
    }
    this.postprocessors[name] = {name:name, properties:properties || false, fn:fn};
    this.setDefaultPostprocessorPosition(name, position, relativeTo);
    return this;
  }, setDefaultPostprocessors:function(postprocessors) {
    this.defaultPostprocessors = arrayFrom(postprocessors);
    return this;
  }, setDefaultPostprocessorPosition:function(name, offset, relativeName) {
    var defaultPostprocessors = this.defaultPostprocessors, index;
    if (typeof offset === 'string') {
      if (offset === 'first') {
        defaultPostprocessors.unshift(name);
        return this;
      } else {
        if (offset === 'last') {
          defaultPostprocessors.push(name);
          return this;
        }
      }
      offset = offset === 'after' ? 1 : -1;
    }
    index = Ext.Array.indexOf(defaultPostprocessors, relativeName);
    if (index !== -1) {
      Ext.Array.splice(defaultPostprocessors, Math.max(0, index + offset), 0, name);
    }
    return this;
  }});
  Manager.registerPostprocessor('platformConfig', function(name, Class, data) {
    Class.addPlatformConfig(data);
  });
  Manager.registerPostprocessor('alias', function(name, cls, data) {
    var aliases = Ext.Array.from(data.alias), i, ln;
    for (i = 0, ln = aliases.length; i < ln; i++) {
      alias = aliases[i];
      this.addAlias(cls, alias);
    }
  }, ['xtype', 'alias']);
  Manager.registerPostprocessor('singleton', function(name, cls, data, fn) {
    if (data.singleton) {
      fn.call(this, name, new cls, data);
    } else {
      return true;
    }
    return false;
  });
  Manager.registerPostprocessor('alternateClassName', function(name, cls, data) {
    var alternates = data.alternateClassName, i, ln, alternate;
    if (!(alternates instanceof Array)) {
      alternates = [alternates];
    }
    for (i = 0, ln = alternates.length; i < ln; i++) {
      alternate = alternates[i];
      this.set(alternate, cls);
    }
  });
  Manager.registerPostprocessor('debugHooks', function(name, Class, data) {
    var target = Class.isInstance ? Class.self : Class;
    delete target.prototype.debugHooks;
  });
  Manager.registerPostprocessor('deprecated', function(name, Class, data) {
    var target = Class.isInstance ? Class.self : Class;
    target.addDeprecations(data.deprecated);
    delete target.prototype.deprecated;
  });
  Ext.apply(Ext, {create:function() {
    var name = arguments[0], nameType = typeof name, args = arraySlice.call(arguments, 1), cls;
    if (nameType === 'function') {
      cls = name;
    } else {
      if (nameType !== 'string' && args.length === 0) {
        args = [name];
        if (!(name = name.xclass)) {
          name = args[0].xtype;
          if (name) {
            name = 'widget.' + name;
          }
        }
      }
      name = Manager.resolveName(name);
      cls = Manager.get(name);
    }
    if (!cls) {
      Ext.syncRequire(name);
      cls = Manager.get(name);
    }
    return Manager.getInstantiator(args.length)(cls, args);
  }, widget:function(name, config) {
    var xtype = name, alias, className, T;
    if (typeof xtype !== 'string') {
      config = name;
      xtype = config.xtype;
      className = config.xclass;
    } else {
      config = config || {};
    }
    if (config.isComponent) {
      return config;
    }
    if (!className) {
      alias = 'widget.' + xtype;
      className = Manager.getNameByAlias(alias);
    }
    if (className) {
      T = Manager.get(className);
    }
    if (!T) {
      return Ext.create(className || alias, config);
    }
    return new T(config);
  }, createByAlias:alias(Manager, 'instantiateByAlias'), define:function(className, data, createdFn) {
    if (data.override) {
      Manager.classState[className] = 20;
      return Manager.createOverride.apply(Manager, arguments);
    }
    Manager.classState[className] = 10;
    return Manager.create.apply(Manager, arguments);
  }, undefine:function(className) {
    var classes = Manager.classes;
    delete classes[className];
    delete Manager.existCache[className];
    delete Manager.classState[className];
    Manager.removeName(className);
    Ext.Factory.clearCaches();
    var entry = Manager.getNamespaceEntry(className), scope = entry.parent ? Manager.lookupName(entry.parent, false) : Ext.global, entryName;
    if (scope) {
      entryName = entry.name;
      try {
        delete scope[entryName];
      } catch (e$1) {
        scope[entryName] = undefined;
      }
    }
  }, getClassName:alias(Manager, 'getName'), getDisplayName:function(object) {
    if (object) {
      if (object.displayName) {
        return object.displayName;
      }
      if (object.$name && object.$class) {
        return Ext.getClassName(object.$class) + '#' + object.$name;
      }
      if (object.$className) {
        return object.$className;
      }
    }
    return 'Anonymous';
  }, getClass:alias(Manager, 'getClass'), namespace:function() {
    var root = global, i;
    for (i = arguments.length; i-- > 0;) {
      root = Manager.lookupName(arguments[i], true);
    }
    return root;
  }});
  Ext.addRootNamespaces = Manager.addRootNamespaces;
  Ext.createWidget = Ext.widget;
  Ext.ns = Ext.namespace;
  Class.registerPreprocessor('className', function(cls, data) {
    if ('$className' in data) {
      cls.$className = data.$className;
    }
  }, true, 'first');
  Class.registerPreprocessor('alias', function(cls, data) {
    var prototype = cls.prototype, xtypes = arrayFrom(data.xtype), aliases = arrayFrom(data.alias), widgetPrefix = 'widget.', widgetPrefixLength = widgetPrefix.length, xtypesChain = Array.prototype.slice.call(prototype.xtypesChain || []), xtypesMap = Ext.merge({}, prototype.xtypesMap || {}), i, ln, alias, xtype;
    for (i = 0, ln = aliases.length; i < ln; i++) {
      alias = aliases[i];
      if (alias.substring(0, widgetPrefixLength) === widgetPrefix) {
        xtype = alias.substring(widgetPrefixLength);
        Ext.Array.include(xtypes, xtype);
      }
    }
    cls.xtype = data.xtype = xtypes[0];
    data.xtypes = xtypes;
    for (i = 0, ln = xtypes.length; i < ln; i++) {
      xtype = xtypes[i];
      if (!xtypesMap[xtype]) {
        xtypesMap[xtype] = true;
        xtypesChain.push(xtype);
      }
    }
    data.xtypesChain = xtypesChain;
    data.xtypesMap = xtypesMap;
    Ext.Function.interceptAfterOnce(cls, 'onClassCreated', function() {
      var cls = this, prototype = cls.prototype, mixins = prototype.mixins, key, mixin;
      for (key in mixins) {
        if (mixins.hasOwnProperty(key)) {
          mixin = mixins[key];
          xtypes = mixin.xtypes;
          if (xtypes) {
            for (i = 0, ln = xtypes.length; i < ln; i++) {
              xtype = xtypes[i];
              if (!xtypesMap[xtype]) {
                xtypesMap[xtype] = true;
                xtypesChain.push(xtype);
              }
            }
          }
        }
      }
    });
    for (i = 0, ln = xtypes.length; i < ln; i++) {
      xtype = xtypes[i];
      Ext.Array.include(aliases, widgetPrefix + xtype);
    }
    data.alias = aliases;
  }, ['xtype', 'alias']);
  if (Ext.manifest) {
    var manifest = Ext.manifest, classes = manifest.classes, paths = manifest.paths, aliases = {}, alternates = {}, className, obj, name, path, baseUrl;
    if (paths) {
      if (manifest.bootRelative) {
        baseUrl = Ext.Boot.baseUrl;
        for (path in paths) {
          if (paths.hasOwnProperty(path)) {
            paths[path] = baseUrl + paths[path];
          }
        }
      }
      Manager.setPath(paths);
    }
    if (classes) {
      for (className in classes) {
        alternates[className] = [];
        aliases[className] = [];
        obj = classes[className];
        if (obj.alias) {
          aliases[className] = obj.alias;
        }
        if (obj.alternates) {
          alternates[className] = obj.alternates;
        }
      }
    }
    Manager.addAlias(aliases);
    Manager.addAlternate(alternates);
  }
  return Manager;
}(Ext.Class, Ext.Function.alias, Array.prototype.slice, Ext.Array.from, Ext.global);
(Ext.env || (Ext.env = {})).Browser = function(userAgent, publish) {
  var me = this, browserPrefixes = Ext.Boot.browserPrefixes, browserNames = Ext.Boot.browserNames, enginePrefixes = me.enginePrefixes, engineNames = me.engineNames, browserMatch = userAgent.match(new RegExp('((?:' + Ext.Object.getValues(browserPrefixes).join(')|(?:') + '))([\\w\\._]+)')), engineMatch = userAgent.match(new RegExp('((?:' + Ext.Object.getValues(enginePrefixes).join(')|(?:') + '))([\\w\\._]+)')), browserName = browserNames.other, engineName = engineNames.other, browserVersion = '', engineVersion = 
  '', majorVer = '', isWebView = false, edgeRE = /(Edge\/)([\w.]+)/, ripple = '', i, prefix, name;
  me.userAgent = userAgent;
  this.is = function(name) {
    return !!this.is[name];
  };
  if (/Edge\//.test(userAgent)) {
    browserMatch = userAgent.match(edgeRE);
    engineMatch = userAgent.match(edgeRE);
  }
  if (browserMatch) {
    browserName = browserNames[Ext.Object.getKey(browserPrefixes, browserMatch[1])];
    if (browserName === 'Safari' && /^Opera/.test(userAgent)) {
      browserName = 'Opera';
    }
    browserVersion = new Ext.Version(browserMatch[2]);
  }
  if (engineMatch) {
    engineName = engineNames[Ext.Object.getKey(enginePrefixes, engineMatch[1])];
    engineVersion = new Ext.Version(engineMatch[2]);
  }
  if (engineName === 'Trident' && browserName !== 'IE') {
    browserName = 'IE';
    var version = userAgent.match(/.*rv:(\d+.\d+)/);
    if (version && version.length) {
      version = version[1];
      browserVersion = new Ext.Version(version);
    }
  }
  if (browserName && browserVersion) {
    Ext.setVersion(browserName, browserVersion);
  }
  if (userAgent.match(/FB/) && browserName === 'Other') {
    browserName = browserNames.safari;
    engineName = engineNames.webkit;
  } else {
    if (userAgent.match(/Android.*Chrome/g)) {
      browserName = 'ChromeMobile';
    } else {
      browserMatch = userAgent.match(/OPR\/(\d+.\d+)/);
      if (browserMatch) {
        browserName = 'Opera';
        browserVersion = new Ext.Version(browserMatch[1]);
      }
    }
  }
  Ext.apply(this, {engineName:engineName, engineVersion:engineVersion, name:browserName, version:browserVersion});
  this.setFlag(browserName, true, publish);
  if (browserVersion) {
    majorVer = browserVersion.getMajor() || '';
    if (me.is.IE) {
      majorVer = document.documentMode || parseInt(majorVer, 10);
      for (i = 7; i <= 11; ++i) {
        prefix = 'isIE' + i;
        Ext[prefix] = majorVer === i;
        Ext[prefix + 'm'] = majorVer <= i;
        Ext[prefix + 'p'] = majorVer >= i;
      }
    }
    if (me.is.Opera && parseInt(majorVer, 10) <= 12) {
      Ext.isOpera12m = true;
    }
    Ext.chromeVersion = Ext.isChrome ? majorVer : 0;
    Ext.firefoxVersion = Ext.isFirefox ? majorVer : 0;
    Ext.ieVersion = Ext.isIE ? majorVer : 0;
    Ext.operaVersion = Ext.isOpera ? majorVer : 0;
    Ext.safariVersion = Ext.isSafari ? majorVer : 0;
    Ext.webKitVersion = Ext.isWebKit ? majorVer : 0;
    this.setFlag(browserName + majorVer, true, publish);
    this.setFlag(browserName + browserVersion.getShortVersion());
  }
  for (i in browserNames) {
    if (browserNames.hasOwnProperty(i)) {
      name = browserNames[i];
      this.setFlag(name, browserName === name);
    }
  }
  this.setFlag(name);
  if (engineVersion) {
    this.setFlag(engineName + (engineVersion.getMajor() || ''));
    this.setFlag(engineName + engineVersion.getShortVersion());
  }
  for (i in engineNames) {
    if (engineNames.hasOwnProperty(i)) {
      name = engineNames[i];
      this.setFlag(name, engineName === name, publish);
    }
  }
  this.setFlag('Standalone', !!navigator.standalone);
  try {
    ripple = window.top.ripple;
  } catch (e$2) {
  }
  this.setFlag('Ripple', !!document.getElementById('tinyhippos-injected') && !Ext.isEmpty(ripple));
  this.setFlag('WebWorks', !!window.blackberry);
  if (window.PhoneGap !== undefined || window.Cordova !== undefined || window.cordova !== undefined) {
    isWebView = true;
    this.setFlag('PhoneGap');
    this.setFlag('Cordova');
  }
  if (/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)(?!.*FBAN)/i.test(userAgent)) {
    isWebView = true;
  }
  this.setFlag('WebView', isWebView);
  this.isStrict = Ext.isStrict = document.compatMode === 'CSS1Compat';
  this.isSecure = Ext.isSecure;
  this.identity = browserName + majorVer + (this.isStrict ? 'Strict' : 'Quirks');
};
Ext.env.Browser.prototype = {constructor:Ext.env.Browser, engineNames:{edge:'Edge', webkit:'WebKit', gecko:'Gecko', presto:'Presto', trident:'Trident', other:'Other'}, enginePrefixes:{edge:'Edge/', webkit:'AppleWebKit/', gecko:'Gecko/', presto:'Presto/', trident:'Trident/'}, styleDashPrefixes:{WebKit:'-webkit-', Gecko:'-moz-', Trident:'-ms-', Presto:'-o-', Other:''}, stylePrefixes:{WebKit:'Webkit', Gecko:'Moz', Trident:'ms', Presto:'O', Other:''}, propertyPrefixes:{WebKit:'webkit', Gecko:'moz', Trident:'ms', 
Presto:'o', Other:''}, name:null, version:null, engineName:null, engineVersion:null, setFlag:function(name, value, publish) {
  if (value === undefined) {
    value = true;
  }
  this.is[name] = value;
  this.is[name.toLowerCase()] = value;
  if (publish) {
    Ext['is' + name] = value;
  }
  return this;
}, getStyleDashPrefix:function() {
  return this.styleDashPrefixes[this.engineName];
}, getStylePrefix:function() {
  return this.stylePrefixes[this.engineName];
}, getVendorProperyName:function(name) {
  var prefix = this.propertyPrefixes[this.engineName];
  if (prefix.length > 0) {
    return prefix + Ext.String.capitalize(name);
  }
  return name;
}};
(function(userAgent) {
  Ext.browser = new Ext.env.Browser(userAgent, true);
  Ext.userAgent = userAgent.toLowerCase();
  Ext.SSL_SECURE_URL = Ext.isSecure && Ext.isIE ? "javascript:''" : 'about:blank';
})(Ext.global.navigator.userAgent);
Ext.env.OS = function(userAgent, platform, browserScope) {
  var me = this, names = Ext.Boot.osNames, prefixes = Ext.Boot.osPrefixes, name, version = '', is = me.is, i, prefix, match, item, match1;
  browserScope = browserScope || Ext.browser;
  for (i in prefixes) {
    if (prefixes.hasOwnProperty(i)) {
      prefix = prefixes[i];
      match = userAgent.match(new RegExp('(?:' + prefix + ')([^\\s;]+)'));
      if (match) {
        name = names[i];
        match1 = match[1];
        if (match1 && match1 === 'HTC_') {
          version = new Ext.Version('2.3');
        } else {
          if (match1 && match1 === 'Silk/') {
            version = new Ext.Version('2.3');
          } else {
            version = new Ext.Version(match[match.length - 1]);
          }
        }
        break;
      }
    }
  }
  if (!name) {
    name = names[(userAgent.toLowerCase().match(/mac|win|linux/) || ['other'])[0]];
    version = new Ext.Version('');
  }
  this.name = name;
  this.version = version;
  if (userAgent.match(/ipad/i)) {
    platform = 'iPad';
  }
  if (platform) {
    this.setFlag(platform.replace(/ simulator$/i, ''));
  }
  this.setFlag(name);
  if (version) {
    this.setFlag(name + (version.getMajor() || ''));
    this.setFlag(name + version.getShortVersion());
  }
  for (i in names) {
    if (names.hasOwnProperty(i)) {
      item = names[i];
      if (!is.hasOwnProperty(name)) {
        this.setFlag(item, name === item);
      }
    }
  }
  if (this.name === 'iOS' && window.screen.height === 568) {
    this.setFlag('iPhone5');
  }
  if (browserScope.is.Safari || browserScope.is.Silk) {
    if (this.is.Android2 || this.is.Android3 || browserScope.version.shortVersion === 501) {
      browserScope.setFlag('AndroidStock');
    }
    if (this.is.Android4) {
      browserScope.setFlag('AndroidStock');
      browserScope.setFlag('AndroidStock4');
    }
  }
};
Ext.env.OS.prototype = {constructor:Ext.env.OS, is:function(name) {
  return !!this[name];
}, name:null, version:null, setFlag:function(name, value) {
  if (value === undefined) {
    value = true;
  }
  if (this.flags) {
    this.flags[name] = value;
  }
  this.is[name] = value;
  this.is[name.toLowerCase()] = value;
  return this;
}};
(function() {
  var navigation = Ext.global.navigator, userAgent = navigation.userAgent, OS = Ext.env.OS, is = Ext.is || (Ext.is = {}), osEnv, osName, deviceType;
  OS.prototype.flags = is;
  Ext.os = osEnv = new OS(userAgent, navigation.platform);
  osName = osEnv.name;
  Ext['is' + osName] = true;
  Ext.isMac = is.Mac = is.MacOS;
  Ext.isApple = Ext.isMac || Ext.isiOS;
  var search = window.location.search.match(/deviceType=(Tablet|Phone)/), nativeDeviceType = window.deviceType;
  if (search && search[1]) {
    deviceType = search[1];
  } else {
    if (nativeDeviceType === 'iPhone') {
      deviceType = 'Phone';
    } else {
      if (nativeDeviceType === 'iPad') {
        deviceType = 'Tablet';
      } else {
        if (!osEnv.is.Android && !osEnv.is.iOS && !osEnv.is.WindowsPhone && /Windows|Linux|MacOS|ChromeOS/.test(osName)) {
          deviceType = 'Desktop';
          Ext.browser.is.WebView = !!Ext.browser.is.Ripple;
        } else {
          if (osEnv.is.iPad || osEnv.is.RIMTablet || osEnv.is.Android3 || Ext.browser.is.Silk || osEnv.is.Android && userAgent.search(/mobile/i) === -1) {
            deviceType = 'Tablet';
          } else {
            deviceType = 'Phone';
          }
        }
      }
    }
  }
  osEnv.setFlag(deviceType, true);
  osEnv.deviceType = deviceType;
  delete OS.prototype.flags;
})();
Ext.feature = {has:function(name) {
  return !!this.has[name];
}, testElements:{}, getTestElement:function(tag, createNew) {
  if (tag === undefined) {
    tag = 'div';
  } else {
    if (typeof tag !== 'string') {
      return tag;
    }
  }
  if (createNew) {
    return document.createElement(tag);
  }
  if (!this.testElements[tag]) {
    this.testElements[tag] = document.createElement(tag);
  }
  return this.testElements[tag];
}, isStyleSupported:function(name, tag) {
  var elementStyle = this.getTestElement(tag).style, cName = Ext.String.capitalize(name);
  if (typeof elementStyle[name] !== 'undefined' || typeof elementStyle[Ext.browser.getStylePrefix(name) + cName] !== 'undefined') {
    return true;
  }
  return false;
}, isStyleSupportedWithoutPrefix:function(name, tag) {
  var elementStyle = this.getTestElement(tag).style;
  if (typeof elementStyle[name] !== 'undefined') {
    return true;
  }
  return false;
}, isEventSupported:function(name, tag) {
  if (tag === undefined) {
    tag = window;
  }
  var element = this.getTestElement(tag), eventName = 'on' + name.toLowerCase(), isSupported = eventName in element;
  if (!isSupported) {
    if (element.setAttribute && element.removeAttribute) {
      element.setAttribute(eventName, '');
      isSupported = typeof element[eventName] === 'function';
      if (typeof element[eventName] !== 'undefined') {
        element[eventName] = undefined;
      }
      element.removeAttribute(eventName);
    }
  }
  return isSupported;
}, getStyle:function(element, styleName) {
  var view = element.ownerDocument.defaultView, style = view ? view.getComputedStyle(element, null) : element.currentStyle;
  return (style || element.style)[styleName];
}, getSupportedPropertyName:function(object, name) {
  var vendorName = Ext.browser.getVendorProperyName(name);
  if (vendorName in object) {
    return vendorName;
  } else {
    if (name in object) {
      return name;
    }
  }
  return null;
}, detect:function(isReady) {
  var me = this, doc = document, toRun = me.toRun || me.tests, n = toRun.length, div = doc.createElement('div'), notRun = [], supports = Ext.supports, has = me.has, name, names, test, vector, value;
  div.innerHTML = '\x3cdiv style\x3d"height:30px;width:50px;"\x3e\x3cdiv style\x3d"height:20px;width:20px;"\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv style\x3d"width: 200px; height: 200px; position: relative; padding: 5px;"\x3e\x3cdiv style\x3d"position: absolute; top: 0; left: 0; width: 100%; height: 100%;"\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv style\x3d"position: absolute; left: 10%; top: 10%;"\x3e\x3c/div\x3e\x3cdiv style\x3d"float:left; background-color:transparent;"\x3e\x3c/div\x3e';
  if (isReady) {
    doc.body.appendChild(div);
  }
  vector = me.preDetected[Ext.browser.identity] || [];
  while (n--) {
    test = toRun[n];
    value = vector[n];
    name = test.name;
    names = test.names;
    if (value === undefined) {
      if (!isReady && test.ready) {
        notRun.push(test);
        continue;
      }
      value = test.fn.call(me, doc, div);
    }
    if (name) {
      supports[name] = has[name] = value;
    } else {
      if (names) {
        while (names.length) {
          name = names.pop();
          supports[name] = has[name] = value;
        }
      }
    }
  }
  if (isReady) {
    doc.body.removeChild(div);
  }
  me.toRun = notRun;
}, report:function() {
  var values = [], len = this.tests.length, i;
  for (i = 0; i < len; ++i) {
    values.push(this.has[this.tests[i].name] ? 1 : 0);
  }
  Ext.log(Ext.browser.identity + ': [' + values.join(',') + ']');
}, preDetected:{}, tests:[{name:'CloneNodeCopiesExpando', fn:function() {
  var el = document.createElement('div');
  el.expandoProp = {};
  return el.cloneNode().expandoProp === el.expandoProp;
}}, {name:'CSSPointerEvents', fn:function(doc) {
  return 'pointerEvents' in doc.documentElement.style;
}}, {name:'CSS3BoxShadow', fn:function(doc) {
  return 'boxShadow' in doc.documentElement.style || 'WebkitBoxShadow' in doc.documentElement.style || 'MozBoxShadow' in doc.documentElement.style;
}}, {name:'CSS3NegationSelector', fn:function(doc) {
  try {
    doc.querySelectorAll('foo:not(bar)');
  } catch (e$3) {
    return false;
  }
  return true;
}}, {name:'ClassList', fn:function(doc) {
  return !!doc.documentElement.classList;
}}, {name:'Canvas', fn:function() {
  var element = this.getTestElement('canvas');
  return !!(element && element.getContext && element.getContext('2d'));
}}, {name:'Svg', fn:function(doc) {
  return !!(doc.createElementNS && !!doc.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect);
}}, {name:'Vml', fn:function() {
  var element = this.getTestElement(), ret = false;
  element.innerHTML = '\x3c!--[if vml]\x3e\x3cbr\x3e\x3c![endif]--\x3e';
  ret = element.childNodes.length === 1;
  element.innerHTML = '';
  return ret;
}}, {name:'Touch', fn:function() {
  var maxTouchPoints = navigator.msMaxTouchPoints || navigator.maxTouchPoints;
  if (Ext.browser.is.Chrome && Ext.browser.version.isLessThanOrEqual(39)) {
    return Ext.supports.TouchEvents && maxTouchPoints !== 1 || maxTouchPoints > 1;
  } else {
    return Ext.supports.TouchEvents || maxTouchPoints > 0;
  }
}}, {name:'PointerEvents', fn:function() {
  return !!(window.PointerEvent && !Ext.supports.TouchEvents);
}}, {name:'MSPointerEvents', fn:function() {
  return Ext.isIE10;
}}, {name:'TouchEvents', fn:function() {
  return this.isEventSupported('touchend');
}}, {name:'TouchAction', ready:true, fn:function(doc, div) {
  if (!window.getComputedStyle) {
    return 0;
  }
  var values = ['pan-x', 'pan-y', 'pinch-zoom', 'double-tap-zoom'], flags = [1, 2, 4, 8], ln = values.length, flag = 0, i, value;
  for (i = 0; i < ln; i++) {
    value = values[i];
    div.style.touchAction = value;
    if (getComputedStyle(div).touchAction === value) {
      flag |= flags[i];
    }
  }
  return flag;
}}, {name:'Orientation', fn:function() {
  return 'orientation' in window && this.isEventSupported('orientationchange');
}}, {name:'OrientationChange', fn:function() {
  return this.isEventSupported('orientationchange');
}}, {name:'DeviceMotion', fn:function() {
  return this.isEventSupported('devicemotion');
}}, {names:['Geolocation', 'GeoLocation'], fn:function() {
  return 'geolocation' in window.navigator;
}}, {name:'SqlDatabase', fn:function() {
  return 'openDatabase' in window;
}}, {name:'WebSockets', fn:function() {
  return 'WebSocket' in window;
}}, {name:'Range', fn:function() {
  return !!document.createRange;
}}, {name:'CreateContextualFragment', fn:function() {
  var range = !!document.createRange ? document.createRange() : false;
  return range && !!range.createContextualFragment;
}}, {name:'History', fn:function() {
  return 'history' in window && 'pushState' in window.history;
}}, {name:'Css3dTransforms', fn:function() {
  return this.has('CssTransforms') && this.isStyleSupported('perspective');
}}, {name:'CssTransforms', fn:function() {
  return this.isStyleSupported('transform');
}}, {name:'CssTransformNoPrefix', fn:function() {
  return this.isStyleSupportedWithoutPrefix('transform');
}}, {name:'CssAnimations', fn:function() {
  return this.isStyleSupported('animationName');
}}, {names:['CssTransitions', 'Transitions'], fn:function() {
  return this.isStyleSupported('transitionProperty');
}}, {names:['Audio', 'AudioTag'], fn:function() {
  return !!this.getTestElement('audio').canPlayType;
}}, {name:'Video', fn:function() {
  return !!this.getTestElement('video').canPlayType;
}}, {name:'LocalStorage', fn:function() {
  try {
    if ('localStorage' in window && window['localStorage'] !== null) {
      localStorage.setItem('sencha-localstorage-test', 'test success');
      localStorage.removeItem('sencha-localstorage-test');
      return true;
    }
  } catch (e$4) {
  }
  return false;
}}, {name:'XmlQuerySelector', fn:function() {
  var xmlString = '\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8" standalone\x3d"yes" ?\x3e\x3croot\x3e\x3c/root\x3e', xmlDoc;
  if (window.ActiveXObject) {
    xmlDoc = new ActiveXObject('Microsoft.xmlDOM');
    xmlDoc.async = false;
    xmlDoc.loadXML(xmlString);
  } else {
    if (window.DOMParser) {
      var parser = new DOMParser;
      xmlDoc = parser.parseFromString(xmlString, 'text/xml');
    }
  }
  return xmlDoc ? !!xmlDoc.lastChild.querySelector : false;
}}, {name:'XHR2', fn:function() {
  return window.ProgressEvent && window.FormData && window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest;
}}, {name:'XHRUploadProgress', fn:function() {
  if (window.XMLHttpRequest && !Ext.browser.is.AndroidStock) {
    var xhr = new XMLHttpRequest;
    return xhr && 'upload' in xhr && 'onprogress' in xhr.upload;
  }
  return false;
}}, {name:'NumericInputPlaceHolder', fn:function() {
  return !(Ext.browser.is.AndroidStock4 && Ext.os.version.getMinor() < 2);
}}, {name:'matchesSelector', fn:function() {
  var el = document.documentElement, w3 = 'matches', wk = 'webkitMatchesSelector', ms = 'msMatchesSelector', mz = 'mozMatchesSelector';
  return el[w3] ? w3 : el[wk] ? wk : el[ms] ? ms : el[mz] ? mz : null;
}}, {name:'RightMargin', ready:true, fn:function(doc, div) {
  var view = doc.defaultView;
  return !(view && view.getComputedStyle(div.firstChild.firstChild, null).marginRight !== '0px');
}}, {name:'DisplayChangeInputSelectionBug', fn:function() {
  var webKitVersion = Ext.webKitVersion;
  return 0 < webKitVersion && webKitVersion < 533;
}}, {name:'DisplayChangeTextAreaSelectionBug', fn:function() {
  var webKitVersion = Ext.webKitVersion;
  return 0 < webKitVersion && webKitVersion < 534.24;
}}, {name:'TransparentColor', ready:true, fn:function(doc, div, view) {
  view = doc.defaultView;
  return !(view && view.getComputedStyle(div.lastChild, null).backgroundColor !== 'transparent');
}}, {name:'ComputedStyle', ready:true, fn:function(doc, div, view) {
  view = doc.defaultView;
  return !!(view && view.getComputedStyle);
}}, {name:'Float', fn:function(doc) {
  return 'cssFloat' in doc.documentElement.style;
}}, {name:'CSS3BorderRadius', ready:true, fn:function(doc) {
  var domPrefixes = ['borderRadius', 'BorderRadius', 'MozBorderRadius', 'WebkitBorderRadius', 'OBorderRadius', 'KhtmlBorderRadius'], pass = false, i;
  for (i = 0; i < domPrefixes.length; i++) {
    if (doc.documentElement.style[domPrefixes[i]] !== undefined) {
      pass = true;
    }
  }
  return pass && !Ext.isIE9;
}}, {name:'CSS3LinearGradient', fn:function(doc, div) {
  var property = 'background-image:', webkit = '-webkit-gradient(linear, left top, right bottom, from(black), to(white))', w3c = 'linear-gradient(left top, black, white)', moz = '-moz-' + w3c, ms = '-ms-' + w3c, opera = '-o-' + w3c, options = [property + webkit, property + w3c, property + moz, property + ms, property + opera];
  div.style.cssText = options.join(';');
  return ('' + div.style.backgroundImage).indexOf('gradient') !== -1 && !Ext.isIE9;
}}, {name:'MouseEnterLeave', fn:function(doc) {
  return 'onmouseenter' in doc.documentElement && 'onmouseleave' in doc.documentElement;
}}, {name:'MouseWheel', fn:function(doc) {
  return 'onmousewheel' in doc.documentElement;
}}, {name:'Opacity', fn:function(doc, div) {
  if (Ext.isIE8) {
    return false;
  }
  div.firstChild.style.cssText = 'opacity:0.73';
  return div.firstChild.style.opacity == '0.73';
}}, {name:'Placeholder', fn:function(doc) {
  return 'placeholder' in doc.createElement('input');
}}, {name:'Direct2DBug', fn:function(doc) {
  return Ext.isString(doc.documentElement.style.msTransformOrigin) && Ext.isIE9m;
}}, {name:'BoundingClientRect', fn:function(doc) {
  return 'getBoundingClientRect' in doc.documentElement;
}}, {name:'RotatedBoundingClientRect', ready:true, fn:function(doc) {
  var body = doc.body, supports = false, el = doc.createElement('div'), style = el.style;
  if (el.getBoundingClientRect) {
    style.position = 'absolute';
    style.top = '0';
    style.WebkitTransform = style.MozTransform = style.msTransform = style.OTransform = style.transform = 'rotate(90deg)';
    style.width = '100px';
    style.height = '30px';
    body.appendChild(el);
    supports = el.getBoundingClientRect().height !== 100;
    body.removeChild(el);
  }
  return supports;
}}, {name:'ChildContentClearedWhenSettingInnerHTML', ready:true, fn:function() {
  var el = this.getTestElement(), child;
  el.innerHTML = '\x3cdiv\x3ea\x3c/div\x3e';
  child = el.firstChild;
  el.innerHTML = '\x3cdiv\x3eb\x3c/div\x3e';
  return child.innerHTML !== 'a';
}}, {name:'IncludePaddingInWidthCalculation', ready:true, fn:function(doc, div) {
  return div.childNodes[1].firstChild.offsetWidth === 210;
}}, {name:'IncludePaddingInHeightCalculation', ready:true, fn:function(doc, div) {
  return div.childNodes[1].firstChild.offsetHeight === 210;
}}, {name:'TextAreaMaxLength', fn:function(doc) {
  return 'maxlength' in doc.createElement('textarea');
}}, {name:'GetPositionPercentage', ready:true, fn:function(doc, div) {
  return Ext.feature.getStyle(div.childNodes[2], 'left') === '10%';
}}, {name:'PercentageHeightOverflowBug', ready:true, fn:function(doc) {
  var hasBug = false, style, el;
  if (Ext.getScrollbarSize().height) {
    el = this.getTestElement('div', true);
    style = el.style;
    style.height = '50px';
    style.width = '50px';
    style.overflow = 'auto';
    style.position = 'absolute';
    el.innerHTML = ['\x3cdiv style\x3d"display:table;height:100%;"\x3e', '\x3cdiv style\x3d"width:51px;"\x3e\x3c/div\x3e', '\x3c/div\x3e'].join('');
    doc.body.appendChild(el);
    if (el.firstChild.offsetHeight === 50) {
      hasBug = true;
    }
    doc.body.removeChild(el);
  }
  return hasBug;
}}, {name:'xOriginBug', ready:true, fn:function(doc, div) {
  div.innerHTML = '\x3cdiv id\x3d"b1" style\x3d"height:100px;width:100px;direction:rtl;position:relative;overflow:scroll"\x3e\x3cdiv id\x3d"b2" style\x3d"position:relative;width:100%;height:20px;"\x3e\x3c/div\x3e\x3cdiv id\x3d"b3" style\x3d"position:absolute;width:20px;height:20px;top:0px;right:0px"\x3e\x3c/div\x3e\x3c/div\x3e';
  var outerBox = document.getElementById('b1').getBoundingClientRect(), b2 = document.getElementById('b2').getBoundingClientRect(), b3 = document.getElementById('b3').getBoundingClientRect();
  return b2.left !== outerBox.left && b3.right !== outerBox.right;
}}, {name:'ScrollWidthInlinePaddingBug', ready:true, fn:function(doc) {
  var hasBug = false, style, el;
  el = doc.createElement('div');
  style = el.style;
  style.height = '50px';
  style.width = '50px';
  style.padding = '10px';
  style.overflow = 'hidden';
  style.position = 'absolute';
  el.innerHTML = '\x3cspan style\x3d"display:inline-block;zoom:1;height:60px;width:60px;"\x3e\x3c/span\x3e';
  doc.body.appendChild(el);
  if (el.scrollWidth === 70) {
    hasBug = true;
  }
  doc.body.removeChild(el);
  return hasBug;
}}, {name:'rtlVertScrollbarOnRight', ready:true, fn:function(doc, div) {
  div.innerHTML = '\x3cdiv style\x3d"height:100px;width:100px;direction:rtl;overflow:scroll"\x3e\x3cdiv style\x3d"width:20px;height:200px;"\x3e\x3c/div\x3e\x3c/div\x3e';
  var outerBox = div.firstChild, innerBox = outerBox.firstChild;
  return innerBox.offsetLeft + innerBox.offsetWidth !== outerBox.offsetLeft + outerBox.offsetWidth;
}}, {name:'rtlVertScrollbarOverflowBug', ready:true, fn:function(doc, div) {
  div.innerHTML = '\x3cdiv style\x3d"height:100px;width:100px;direction:rtl;overflow:auto"\x3e\x3cdiv style\x3d"width:95px;height:200px;"\x3e\x3c/div\x3e\x3c/div\x3e';
  var outerBox = div.firstChild, style = div.style, pos = style.position;
  style.position = 'absolute';
  outerBox.offsetHeight;
  style.position = pos;
  return outerBox.clientHeight === outerBox.offsetHeight;
}}, {identity:'defineProperty', fn:function() {
  if (Ext.isIE8m) {
    Ext.Object.defineProperty = Ext.emptyFn;
    return false;
  }
  return true;
}}, {identify:'nativeXhr', fn:function() {
  if (typeof XMLHttpRequest !== 'undefined') {
    return true;
  }
  XMLHttpRequest = function() {
    try {
      return new ActiveXObject('MSXML2.XMLHTTP.3.0');
    } catch (ex) {
      return null;
    }
  };
  return false;
}}, {name:'SpecialKeyDownRepeat', fn:function() {
  return Ext.isWebKit ? parseInt(navigator.userAgent.match(/AppleWebKit\/(\d+)/)[1], 10) >= 525 : !(!(Ext.isGecko || Ext.isIE || Ext.isEdge) || Ext.isOpera && Ext.operaVersion < 12);
}}, {name:'EmulatedMouseOver', fn:function() {
  return Ext.os.is.iOS;
}}, {name:'Hashchange', fn:function() {
  var docMode = document.documentMode;
  return 'onhashchange' in window && (docMode === undefined || docMode > 7);
}}, {name:'FixedTableWidthBug', ready:true, fn:function() {
  if (Ext.isIE8) {
    return false;
  }
  var outer = document.createElement('div'), inner = document.createElement('div'), width;
  outer.setAttribute('style', 'display:table;table-layout:fixed;');
  inner.setAttribute('style', 'display:table-cell;min-width:50px;');
  outer.appendChild(inner);
  document.body.appendChild(outer);
  outer.offsetWidth;
  outer.style.width = '25px';
  width = outer.offsetWidth;
  document.body.removeChild(outer);
  return width === 50;
}}, {name:'FocusinFocusoutEvents', fn:function() {
  return !(Ext.isGecko && Ext.firefoxVersion < 52);
}}, {name:'AsyncFocusEvents', fn:function() {
  return Ext.asyncFocus = !!Ext.isIE;
}}, {name:'accessibility', ready:true, fn:function(doc) {
  var body = doc.body, div, img, style, supports, bgImg;
  function getColor(colorTxt) {
    var values = [], colorValue = 0, regex, match;
    if (colorTxt.indexOf('rgb(') !== -1) {
      values = colorTxt.replace('rgb(', '').replace(')', '').split(', ');
    } else {
      if (colorTxt.indexOf('#') !== -1) {
        regex = colorTxt.length === 7 ? /^#(\S\S)(\S\S)(\S\S)$/ : /^#(\S)(\S)(\S)$/;
        match = colorTxt.match(regex);
        if (match) {
          values = ['0x' + match[1], '0x' + match[2], '0x' + match[3]];
        }
      }
    }
    for (var i = 0; i < values.length; i++) {
      colorValue += parseInt(values[i]);
    }
    return colorValue;
  }
  div = doc.createElement('div');
  img = doc.createElement('img');
  style = div.style;
  Ext.apply(style, {width:'2px', position:'absolute', clip:'rect(1px,1px,1px,1px)', borderWidth:'1px', borderStyle:'solid', borderTopTolor:'#f00', borderRightColor:'#ff0', backgroundColor:'#fff', backgroundImage:'url(' + Ext.BLANK_IMAGE_URL + ')'});
  img.alt = '';
  img.src = Ext.BLANK_IMAGE_URL;
  div.appendChild(img);
  body.appendChild(div);
  style = div.currentStyle || div.style;
  bgImg = style.backgroundImage;
  supports = {Images:img.offsetWidth === 1 && img.readyState !== 'uninitialized', BackgroundImages:!(bgImg !== null && (bgImg === 'none' || bgImg === 'url(invalid-url:)')), BorderColors:style.borderTopColor !== style.borderRightColor, LightOnDark:getColor(style.color) - getColor(style.backgroundColor) > 0};
  Ext.supports.HighContrastMode = !supports.BackgroundImages;
  body.removeChild(div);
  div = img = null;
  return supports;
}}, {name:'ViewportUnits', ready:true, fn:function(doc) {
  if (Ext.isIE8) {
    return false;
  }
  var body = doc.body, div = document.createElement('div'), style = div.currentStyle || div.style, width, divWidth;
  body.appendChild(div);
  Ext.apply(style, {width:'50vw'});
  width = parseInt(window.innerWidth / 2, 10);
  divWidth = parseInt((window.getComputedStyle ? getComputedStyle(div, null) : div.currentStyle).width, 10);
  body.removeChild(div);
  div = null;
  return width === divWidth;
}}, {name:'CSSVariables', ready:false, fn:function(doc) {
  if (!window.getComputedStyle) {
    return false;
  }
  var style = window.getComputedStyle(doc.documentElement);
  return style.getPropertyValue && !!style.getPropertyValue('--x-supports-variables');
}}, {name:'Selectors2', ready:false, fn:function(doc) {
  try {
    return !!doc.querySelectorAll(':scope');
  } catch (e$5) {
    return false;
  }
}}, {name:'CSSScrollSnap', ready:false, fn:function(doc) {
  var style = doc.documentElement.style;
  return 'scrollSnapType' in style || 'webkitScrollSnapType' in style || 'msScrollSnapType' in style;
}}, {name:'TranslateYCausesHorizontalScroll', ready:true, fn:function(doc, div) {
  div.innerHTML = '\x3cdiv style\x3d"position: relative; overflow: auto; height: 200px; width: 200px;"\x3e\x3cdiv\x3e\x3cdiv style\x3d"transform: translateY(260px); width: 50px;"\x3ea\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e';
  return div.firstChild.scrollWidth > div.firstChild.clientWidth;
}}, {name:'PercentageSizeFlexBug', ready:true, fn:function(doc, div) {
  if (Ext.isIE9m) {
    return false;
  }
  var style = div.style;
  style.display = 'flex';
  style.flexDirection = 'column';
  style.height = style.width = '100px';
  div.innerHTML = '\x3cdiv style\x3d"flex: 1 1;"\x3e\x3cdiv style\x3d"height:50%"\x3e\x3c/div\x3e\x3c/div\x3e';
  return div.firstChild.firstChild.offsetHeight !== 50;
}}, {name:'CannotScrollExactHeight', fn:function() {
  return Ext.isIE10p;
}}, {name:'WebKitInputTableBoxModelBug', ready:true, fn:function(doc, div) {
  var table = document.createElement('div'), cell = document.createElement('div'), input = document.createElement('input'), tableStyle = table.style, cellStyle = cell.style, inputStyle = input.style, body = doc.body, hasBug;
  input.type = 'text';
  tableStyle.display = 'table';
  tableStyle.height = '100px';
  cellStyle.display = 'table-cell';
  inputStyle.border = '0';
  inputStyle.padding = '10px';
  inputStyle.boxSizing = 'border-box';
  inputStyle.height = '100%';
  cell.appendChild(input);
  table.appendChild(cell);
  body.appendChild(table);
  hasBug = input.offsetHeight === 80;
  body.removeChild(table);
  return hasBug;
}}, {name:'PassiveEventListener', fn:function(doc, div) {
  var supportsPassive = false, options;
  try {
    options = Object.defineProperty({}, 'passive', {get:function() {
      supportsPassive = true;
    }});
    window.addEventListener('e', null, options);
    window.removeEventListener('e', null, options);
  } catch (e$6) {
  }
  return supportsPassive;
}}, {name:'CSSMinContent', ready:true, fn:function(doc, div) {
  div.innerHTML = '\x3cdiv style\x3d"height:4px;width:4px;min-height:-webkit-min-content;min-height:-moz-min-content;min-height:min-content"\x3e\x3cdiv style\x3d"height:8px;width:8px"\x3e\x3c/div\x3e\x3c/div\x3e';
  return div.firstChild.offsetHeight === 8;
}}, {name:'ComputedSizeIncludesPadding', ready:true, fn:function(doc, div) {
  var ret = false, bd = document.body, el, w;
  if (window.getComputedStyle) {
    el = document.createElement('div');
    el.style.cssText = 'width:10px;padding:2px;-webkit-box-sizing:border-box;box-sizing:border-box;';
    bd.appendChild(el);
    w = window.getComputedStyle(el, null).width;
    ret = w === '10px';
    bd.removeChild(el);
  }
  return ret;
}}, 0]};
Ext.feature.tests.pop();
Ext.supports = {};
Ext.feature.detect();
Ext.env.Ready = {blocks:(location.search || '').indexOf('ext-pauseReadyFire') > 0 ? 1 : 0, bound:0, delay:1, firing:false, generation:0, listeners:[], nextId:0, sortGeneration:0, state:0, timer:null, bind:function() {
  var me = Ext.env.Ready, doc = document;
  if (!me.bound) {
    if (doc.readyState === 'complete') {
      me.onReadyEvent({type:doc.readyState || 'body'});
    } else {
      me.bound = 1;
      if (Ext.browser.is.PhoneGap && !Ext.os.is.Desktop) {
        me.bound = 2;
        doc.addEventListener('deviceready', me.onReadyEvent, false);
      }
      doc.addEventListener('DOMContentLoaded', me.onReadyEvent, false);
      window.addEventListener('load', me.onReadyEvent, false);
    }
  }
}, block:function() {
  ++this.blocks;
  Ext.isReady = false;
}, fireReady:function() {
  var me = Ext.env.Ready;
  if (!me.state) {
    Ext._readyTime = Ext.ticks();
    Ext.isDomReady = true;
    me.state = 1;
    Ext.feature.detect(true);
    if (!me.delay) {
      me.handleReady();
    } else {
      if (navigator.standalone) {
        me.timer = Ext.defer(function() {
          me.timer = null;
          me.handleReadySoon();
        }, 1);
      } else {
        me.handleReadySoon();
      }
    }
  }
}, handleReady:function() {
  var me = this;
  if (me.state === 1) {
    me.state = 2;
    Ext._beforeReadyTime = Ext.ticks();
    me.invokeAll();
    Ext._afterReadyTime = Ext.ticks();
  }
}, handleReadySoon:function(delay) {
  var me = this;
  if (!me.timer) {
    me.timer = Ext.defer(function() {
      me.timer = null;
      me.handleReady();
    }, delay || me.delay);
  }
}, invoke:function(listener) {
  var delay = listener.delay;
  if (delay) {
    Ext.defer(listener.fn, delay, listener.scope);
  } else {
    if (Ext.elevateFunction) {
      Ext.elevateFunction(listener.fn, listener.scope);
    } else {
      listener.fn.call(listener.scope);
    }
  }
}, invokeAll:function() {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doInvokeAll, this);
  } else {
    this.doInvokeAll();
  }
}, doInvokeAll:function() {
  var me = this, listeners = me.listeners, listener;
  if (!me.blocks) {
    Ext.isReady = true;
  }
  me.firing = true;
  while (listeners.length) {
    if (me.sortGeneration !== me.generation) {
      me.sortGeneration = me.generation;
      listeners.sort(me.sortFn);
    }
    listener = listeners.pop();
    if (me.blocks && !listener.dom) {
      listeners.push(listener);
      break;
    }
    me.invoke(listener);
  }
  me.firing = false;
}, makeListener:function(fn, scope, options) {
  var ret = {fn:fn, id:++this.nextId, scope:scope, dom:false, priority:0};
  if (options) {
    Ext.apply(ret, options);
  }
  ret.phase = ret.dom ? 0 : 1;
  return ret;
}, on:function(fn, scope, options) {
  var me = Ext.env.Ready, listener = me.makeListener(fn, scope, options);
  if (me.state === 2 && !me.firing && (listener.dom || !me.blocks)) {
    me.invoke(listener);
  } else {
    me.listeners.push(listener);
    ++me.generation;
    if (!me.bound) {
      me.bind();
    }
  }
}, onReadyEvent:function(ev) {
  var me = Ext.env.Ready;
  if (Ext.elevateFunction) {
    Ext.elevateFunction(me.doReadyEvent, me, arguments);
  } else {
    me.doReadyEvent(ev);
  }
}, doReadyEvent:function(ev) {
  var me = this;
  if (me.bound > 0) {
    me.unbind();
    me.bound = -1;
  }
  if (!me.state) {
    me.fireReady();
  }
}, sortFn:function(a, b) {
  return -(a.phase - b.phase || b.priority - a.priority || a.id - b.id);
}, unblock:function() {
  var me = this;
  if (me.blocks) {
    if (!--me.blocks) {
      if (me.state === 2 && !me.firing) {
        me.invokeAll();
      }
    }
  }
}, unbind:function() {
  var me = this, doc = document;
  if (me.bound > 1) {
    doc.removeEventListener('deviceready', me.onReadyEvent, false);
  }
  doc.removeEventListener('DOMContentLoaded', me.onReadyEvent, false);
  window.removeEventListener('load', me.onReadyEvent, false);
}};
(function() {
  var Ready = Ext.env.Ready;
  if (Ext.isIE9m) {
    Ext.apply(Ready, {scrollTimer:null, readyStatesRe:/complete/i, pollScroll:function() {
      var scrollable = true;
      try {
        document.documentElement.doScroll('left');
      } catch (e$7) {
        scrollable = false;
      }
      if (scrollable && document.body) {
        Ready.onReadyEvent({type:'doScroll'});
      } else {
        Ready.scrollTimer = Ext.defer(Ready.pollScroll, 20);
      }
      return scrollable;
    }, bind:function() {
      if (Ready.bound) {
        return;
      }
      var doc = document, topContext;
      try {
        topContext = window.frameElement === undefined;
      } catch (e$8) {
      }
      if (!topContext || !doc.documentElement.doScroll) {
        Ready.pollScroll = Ext.emptyFn;
      } else {
        if (Ready.pollScroll()) {
          return;
        }
      }
      if (doc.readyState === 'complete') {
        Ready.onReadyEvent({type:'already ' + (doc.readyState || 'body')});
      } else {
        doc.attachEvent('onreadystatechange', Ready.onReadyStateChange);
        window.attachEvent('onload', Ready.onReadyEvent);
        Ready.bound = 1;
      }
    }, unbind:function() {
      document.detachEvent('onreadystatechange', Ready.onReadyStateChange);
      window.detachEvent('onload', Ready.onReadyEvent);
      if (Ext.isNumber(Ready.scrollTimer)) {
        Ext.undefer(Ready.scrollTimer);
        Ready.scrollTimer = null;
      }
    }, onReadyStateChange:function() {
      var state = document.readyState;
      if (Ready.readyStatesRe.test(state)) {
        Ready.onReadyEvent({type:state});
      }
    }});
  }
  Ext.onDocumentReady = function(fn, scope, options) {
    var opt = {dom:true};
    if (options) {
      Ext.apply(opt, options);
    }
    Ready.on(fn, scope, opt);
  };
  Ext.onReady = function(fn, scope, options) {
    Ready.on(fn, scope, options);
  };
  Ext.onInternalReady = function(fn, scope, options) {
    Ready.on(fn, scope, Ext.apply({priority:1000}, options));
  };
  Ready.bind();
})();
Ext.Loader = new function() {
  var Loader = this, Manager = Ext.ClassManager, Boot = Ext.Boot, Class = Ext.Class, Ready = Ext.env.Ready, alias = Ext.Function.alias, dependencyProperties = ['extend', 'mixins', 'requires'], isInHistory = {}, history = [], readyListeners = [], usedClasses = [], _requiresMap = {}, _config = {enabled:true, scriptChainDelay:false, disableCaching:true, disableCachingParam:'_dc', paths:Manager.paths, preserveScripts:true, scriptCharset:undefined}, delegatedConfigs = {disableCaching:true, disableCachingParam:true, 
  preserveScripts:true, scriptChainDelay:'loadDelay'};
  Ext.apply(Loader, {isInHistory:isInHistory, isLoading:false, history:history, config:_config, readyListeners:readyListeners, optionalRequires:usedClasses, requiresMap:_requiresMap, hasFileLoadError:false, scriptsLoading:0, classesLoading:{}, missingCount:0, missingQueue:{}, syncModeEnabled:false, init:function() {
    var scripts = document.getElementsByTagName('script'), src = scripts[scripts.length - 1].src, path = src.substring(0, src.lastIndexOf('/') + 1), meta = Ext._classPathMetadata, microloader = Ext.Microloader, manifest = Ext.manifest, loadOrder, classes, className, idx, baseUrl, loadlen, l, loadItem;
    if (!Manager.getPath('Ext')) {
      Manager.setPath('Ext', path + 'src');
    }
    if (meta) {
      Ext._classPathMetadata = null;
      Loader.addClassPathMappings(meta);
    }
    if (manifest) {
      loadOrder = manifest.loadOrder;
      baseUrl = Ext.Boot.baseUrl;
      if (loadOrder && manifest.bootRelative) {
        for (loadlen = loadOrder.length, l = 0; l < loadlen; l++) {
          loadItem = loadOrder[l];
          loadItem.path = baseUrl + loadItem.path;
          loadItem.canonicalPath = true;
        }
      }
    }
    if (microloader) {
      Ready.block();
      microloader.onMicroloaderReady(function() {
        Ready.unblock();
      });
    }
  }, setConfig:Ext.Function.flexSetter(function(name, value) {
    if (name === 'paths') {
      Loader.setPath(value);
    } else {
      _config[name] = value;
      var delegated = delegatedConfigs[name];
      if (delegated) {
        Boot.setConfig(delegated === true ? name : delegated, value);
      }
    }
    return Loader;
  }), getConfig:function(name) {
    return name ? _config[name] : _config;
  }, setPath:function() {
    Manager.setPath.apply(Manager, arguments);
    return Loader;
  }, addClassPathMappings:function(paths) {
    Manager.setPath(paths);
    return Loader;
  }, addBaseUrlClassPathMappings:function(pathConfig) {
    for (var name in pathConfig) {
      pathConfig[name] = Boot.baseUrl + pathConfig[name];
    }
    Ext.Loader.addClassPathMappings(pathConfig);
  }, getPath:function(className) {
    return Manager.getPath(className);
  }, require:function(expressions, fn, scope, excludes) {
    if (excludes) {
      return Loader.exclude(excludes).require(expressions, fn, scope);
    }
    var classNames = Manager.getNamesByExpression(expressions);
    return Loader.load(classNames, fn, scope);
  }, syncRequire:function() {
    var wasEnabled = Loader.syncModeEnabled;
    Loader.syncModeEnabled = true;
    var ret = Loader.require.apply(Loader, arguments);
    Loader.syncModeEnabled = wasEnabled;
    return ret;
  }, exclude:function(excludes) {
    var selector = Manager.select({require:function(classNames, fn, scope) {
      return Loader.load(classNames, fn, scope);
    }, syncRequire:function(classNames, fn, scope) {
      var wasEnabled = Loader.syncModeEnabled;
      Loader.syncModeEnabled = true;
      var ret = Loader.load(classNames, fn, scope);
      Loader.syncModeEnabled = wasEnabled;
      return ret;
    }});
    selector.exclude(excludes);
    return selector;
  }, load:function(classNames, callback, scope) {
    if (callback) {
      if (callback.length) {
        callback = Loader.makeLoadCallback(classNames, callback);
      }
      callback = callback.bind(scope || Ext.global);
    }
    var state = Manager.classState, missingClassNames = [], urls = [], urlByClass = {}, numClasses = classNames.length, url, className, i, numMissing;
    for (i = 0; i < numClasses; ++i) {
      className = Manager.resolveName(classNames[i]);
      if (!Manager.isCreated(className)) {
        missingClassNames.push(className);
        if (!state[className]) {
          urlByClass[className] = Loader.getPath(className);
          urls.push(urlByClass[className]);
        }
      }
    }
    numMissing = missingClassNames.length;
    if (numMissing) {
      Loader.missingCount += numMissing;
      Manager.onCreated(function() {
        if (callback) {
          Ext.callback(callback, scope, arguments);
        }
        Loader.checkReady();
      }, Loader, missingClassNames);
      if (!_config.enabled) {
        Ext.raise('Ext.Loader is not enabled, so dependencies cannot be resolved dynamically. Missing required class' + (missingClassNames.length > 1 ? 'es' : '') + ': ' + missingClassNames.join(', '));
      }
      if (urls.length) {
        Loader.loadScripts({url:urls, _classNames:missingClassNames, _urlByClass:urlByClass});
      } else {
        Loader.checkReady();
      }
    } else {
      if (callback) {
        callback.call(scope);
      }
      Loader.checkReady();
    }
    if (Loader.syncModeEnabled) {
      if (numClasses === 1) {
        return Manager.get(classNames[0]);
      }
    }
    return Loader;
  }, makeLoadCallback:function(classNames, callback) {
    return function() {
      var classes = [], i = classNames.length;
      while (i-- > 0) {
        classes[i] = Manager.get(classNames[i]);
      }
      return callback.apply(this, classes);
    };
  }, onLoadFailure:function(request) {
    var options = this, entries = request.entries || [], onError = options.onError, error, entry, i;
    Loader.hasFileLoadError = true;
    --Loader.scriptsLoading;
    if (onError) {
      for (i = 0; i < entries.length; i++) {
        entry = entries[i];
        if (entry.error) {
          error = new Error('Failed to load: ' + entry.url);
          break;
        }
      }
      error = error || new Error('Failed to load');
      onError.call(options.userScope, options, error, request);
    }
    Loader.checkReady();
  }, onLoadSuccess:function() {
    var options = this, onLoad = options.onLoad, classNames = options._classNames, urlByClass = options._urlByClass, state = Manager.classState, missingQueue = Loader.missingQueue, className, i, len;
    --Loader.scriptsLoading;
    if (onLoad) {
      onLoad.call(options.userScope, options);
    }
    for (i = 0, len = classNames.length; i < len; i++) {
      className = classNames[i];
      if (!state[className]) {
        missingQueue[className] = urlByClass[className];
      }
    }
    Loader.checkReady();
  }, onReady:function(fn, scope, withDomReady, options) {
    if (withDomReady) {
      Ready.on(fn, scope, options);
    } else {
      var listener = Ready.makeListener(fn, scope, options);
      if (Loader.isLoading) {
        readyListeners.push(listener);
      } else {
        Ready.invoke(listener);
      }
    }
  }, addUsedClasses:function(classes) {
    var cls, i, ln;
    if (classes) {
      classes = typeof classes === 'string' ? [classes] : classes;
      for (i = 0, ln = classes.length; i < ln; i++) {
        cls = classes[i];
        if (typeof cls === 'string' && !Ext.Array.contains(usedClasses, cls)) {
          usedClasses.push(cls);
        }
      }
    }
    return Loader;
  }, triggerReady:function() {
    var listener, refClasses = usedClasses;
    if (Loader.isLoading && refClasses.length) {
      usedClasses = [];
      Loader.require(refClasses);
    } else {
      Loader.isLoading = false;
      readyListeners.sort(Ready.sortFn);
      while (readyListeners.length && !Loader.isLoading) {
        listener = readyListeners.pop();
        Ready.invoke(listener);
      }
      Ready.unblock();
    }
  }, historyPush:function(className) {
    if (className && !isInHistory[className] && !Manager.overrideMap[className]) {
      isInHistory[className] = true;
      history.push(className);
    }
    return Loader;
  }, loadScripts:function(params) {
    var manifest = Ext.manifest, loadOrder = manifest && manifest.loadOrder, loadOrderMap = manifest && manifest.loadOrderMap, options;
    ++Loader.scriptsLoading;
    if (loadOrder && !loadOrderMap) {
      manifest.loadOrderMap = loadOrderMap = Boot.createLoadOrderMap(loadOrder);
    }
    Loader.checkReady();
    options = Ext.apply({loadOrder:loadOrder, loadOrderMap:loadOrderMap, charset:_config.scriptCharset, success:Loader.onLoadSuccess, failure:Loader.onLoadFailure, sync:Loader.syncModeEnabled, _classNames:[]}, params);
    options.userScope = options.scope;
    options.scope = options;
    Boot.load(options);
  }, loadScriptsSync:function(urls) {
    var syncwas = Loader.syncModeEnabled;
    Loader.syncModeEnabled = true;
    Loader.loadScripts({url:urls});
    Loader.syncModeEnabled = syncwas;
  }, loadScriptsSyncBasePrefix:function(urls) {
    var syncwas = Loader.syncModeEnabled;
    Loader.syncModeEnabled = true;
    Loader.loadScripts({url:urls, prependBaseUrl:true});
    Loader.syncModeEnabled = syncwas;
  }, loadScript:function(options) {
    var isString = typeof options === 'string', isArray = options instanceof Array, isObject = !isArray && !isString, url = isObject ? options.url : options, onError = isObject && options.onError, onLoad = isObject && options.onLoad, scope = isObject && options.scope, request = {url:url, scope:scope, onLoad:onLoad, onError:onError, _classNames:[]};
    Loader.loadScripts(request);
  }, checkMissingQueue:function() {
    var missingQueue = Loader.missingQueue, newQueue = {}, name, missing = 0;
    for (name in missingQueue) {
      if (!(Manager.classState[name] || Manager.isCreated(name))) {
        newQueue[name] = missingQueue[name];
        missing++;
      }
    }
    Loader.missingCount = missing;
    Loader.missingQueue = newQueue;
  }, checkReady:function() {
    var wasLoading = Loader.isLoading, isLoading;
    Loader.checkMissingQueue();
    isLoading = Loader.missingCount + Loader.scriptsLoading;
    if (isLoading && !wasLoading) {
      Ready.block();
      Loader.isLoading = !!isLoading;
    } else {
      if (!isLoading && wasLoading) {
        Loader.triggerReady();
      }
    }
  }});
  Ext.require = alias(Loader, 'require');
  Ext.syncRequire = alias(Loader, 'syncRequire');
  Ext.exclude = alias(Loader, 'exclude');
  Class.registerPreprocessor('loader', function(cls, data, hooks, continueFn) {
    var me = this, dependencies = [], dependency, className = Manager.getName(cls), i, j, ln, subLn, value, propertyName, propertyValue, requiredMap;
    for (i = 0, ln = dependencyProperties.length; i < ln; i++) {
      propertyName = dependencyProperties[i];
      if (data.hasOwnProperty(propertyName)) {
        propertyValue = data[propertyName];
        if (typeof propertyValue === 'string') {
          dependencies.push(propertyValue);
        } else {
          if (propertyValue instanceof Array) {
            for (j = 0, subLn = propertyValue.length; j < subLn; j++) {
              value = propertyValue[j];
              if (typeof value === 'string') {
                dependencies.push(value);
              }
            }
          } else {
            if (typeof propertyValue !== 'function') {
              for (j in propertyValue) {
                if (propertyValue.hasOwnProperty(j)) {
                  value = propertyValue[j];
                  if (typeof value === 'string') {
                    dependencies.push(value);
                  }
                }
              }
            }
          }
        }
      }
    }
    if (dependencies.length === 0) {
      return;
    }
    if (className) {
      _requiresMap[className] = dependencies;
    }
    (className ? Loader.exclude(className) : Loader).require(dependencies, function() {
      for (i = 0, ln = dependencyProperties.length; i < ln; i++) {
        propertyName = dependencyProperties[i];
        if (data.hasOwnProperty(propertyName)) {
          propertyValue = data[propertyName];
          if (typeof propertyValue === 'string') {
            data[propertyName] = Manager.get(propertyValue);
          } else {
            if (propertyValue instanceof Array) {
              for (j = 0, subLn = propertyValue.length; j < subLn; j++) {
                value = propertyValue[j];
                if (typeof value === 'string') {
                  data[propertyName][j] = Manager.get(value);
                }
              }
            } else {
              if (typeof propertyValue !== 'function') {
                for (var k in propertyValue) {
                  if (propertyValue.hasOwnProperty(k)) {
                    value = propertyValue[k];
                    if (typeof value === 'string') {
                      data[propertyName][k] = Manager.get(value);
                    }
                  }
                }
              }
            }
          }
        }
      }
      continueFn.call(me, cls, data, hooks);
    });
    return false;
  }, true, 'after', 'className');
  Manager.registerPostprocessor('uses', function(name, cls, data) {
    var uses = data.uses, classNames;
    if (uses) {
      classNames = Manager.getNamesByExpression(data.uses);
      Loader.addUsedClasses(classNames);
    }
  });
  Manager.onCreated(Loader.historyPush);
  Loader.init();
};
Ext._endTime = Ext.ticks();
if (Ext._beforereadyhandler) {
  Ext._beforereadyhandler();
}
Ext.cmd.derive('Ext.Mixin', Ext.Base, function(Mixin) {
  return {statics:{addHook:function(hookFn, targetClass, methodName, mixinClassPrototype) {
    var isFunc = Ext.isFunction(hookFn), hook = function() {
      var a = arguments, fn = isFunc ? hookFn : mixinClassPrototype[hookFn], result = this.callParent(a);
      fn.apply(this, a);
      return result;
    }, existingFn = targetClass.hasOwnProperty(methodName) && targetClass[methodName];
    if (isFunc) {
      hookFn.$previous = Ext.emptyFn;
    }
    hook.$name = methodName;
    hook.$owner = targetClass.self;
    if (existingFn) {
      hook.$previous = existingFn.$previous;
      existingFn.$previous = hook;
    } else {
      targetClass[methodName] = hook;
    }
  }}, onClassExtended:function(cls, data) {
    var mixinConfig = data.mixinConfig, hooks = data.xhooks, superclass = cls.superclass, onClassMixedIn = data.onClassMixedIn, parentMixinConfig, befores, afters, extended;
    if (hooks) {
      delete data.xhooks;
      (mixinConfig || (data.mixinConfig = mixinConfig = {})).on = hooks;
    }
    if (mixinConfig) {
      parentMixinConfig = superclass.mixinConfig;
      if (parentMixinConfig) {
        data.mixinConfig = mixinConfig = Ext.merge({}, parentMixinConfig, mixinConfig);
      }
      data.mixinId = mixinConfig.id;
      befores = mixinConfig.before;
      afters = mixinConfig.after;
      hooks = mixinConfig.on;
      extended = mixinConfig.extended;
    }
    if (befores || afters || hooks || extended) {
      data.onClassMixedIn = function(targetClass) {
        var mixin = this.prototype, targetProto = targetClass.prototype, key;
        if (befores) {
          Ext.Object.each(befores, function(key, value) {
            targetClass.addMember(key, function() {
              if (mixin[value].apply(this, arguments) !== false) {
                return this.callParent(arguments);
              }
            });
          });
        }
        if (afters) {
          Ext.Object.each(afters, function(key, value) {
            targetClass.addMember(key, function() {
              var ret = this.callParent(arguments);
              mixin[value].apply(this, arguments);
              return ret;
            });
          });
        }
        if (hooks) {
          for (key in hooks) {
            Mixin.addHook(hooks[key], targetProto, key, mixin);
          }
        }
        if (extended) {
          targetClass.onExtended(function() {
            var args = Ext.Array.slice(arguments, 0);
            args.unshift(targetClass);
            return extended.apply(this, args);
          }, this);
        }
        if (onClassMixedIn) {
          onClassMixedIn.apply(this, arguments);
        }
      };
    }
  }};
}, 0, 0, 0, 0, 0, 0, [Ext, 'Mixin'], 0);
Ext.util = Ext.util || {};
Ext.util.DelayedTask = function(fn, scope, args, cancelOnDelay, fireIdleEvent) {
  var me = this, delay, call = function() {
    me.id = null;
    if (!(scope && scope.destroyed)) {
      args ? fn.apply(scope, args) : fn.call(scope);
    }
    if (fireIdleEvent === false) {
      Ext._suppressIdle = true;
    }
  };
  cancelOnDelay = typeof cancelOnDelay === 'boolean' ? cancelOnDelay : true;
  me.id = null;
  me.delay = function(newDelay, newFn, newScope, newArgs) {
    if (cancelOnDelay) {
      me.cancel();
    }
    if (typeof newDelay === 'number') {
      delay = newDelay;
    }
    fn = newFn || fn;
    scope = newScope || scope;
    args = newArgs || args;
    me.delayTime = delay;
    if (!me.id) {
      if (delay === -1) {
        me.id = Ext.raf(call);
      } else {
        me.id = Ext.defer(call, delay || 1);
      }
    }
    return me.id;
  };
  me.cancel = function() {
    if (me.id) {
      if (me.delayTime === -1) {
        Ext.unraf(me.id);
      } else {
        Ext.undefer(me.id);
      }
      me.id = null;
    }
  };
  me.flush = function() {
    if (me.id) {
      me.cancel();
      var was = fireIdleEvent;
      fireIdleEvent = true;
      call();
      fireIdleEvent = was;
    }
  };
  me.stop = function(stopFn, stopScope) {
    if (stopFn && stopFn === fn && (!stopScope || stopScope === scope)) {
      me.cancel();
    }
  };
};
Ext.cmd.derive('Ext.util.Event', Ext.Base, function() {
  var arraySlice = Array.prototype.slice, arrayInsert = Ext.Array.insert, toArray = Ext.Array.toArray, fireArgs = {};
  return {isEvent:true, suspended:0, noOptions:{}, constructor:function(observable, name) {
    this.name = name;
    this.observable = observable;
    this.listeners = [];
  }, addListener:function(fn, scope, options, caller, manager) {
    var me = this, added = false, observable = me.observable, eventName = me.name, listeners, listener, priority, isNegativePriority, highestNegativePriorityIndex, hasNegativePriorityIndex, length, index, i, listenerPriority, managedListeners;
    if (me.findListener(fn, scope) === -1) {
      listener = me.createListener(fn, scope, options, caller, manager);
      if (me.firing) {
        me.listeners = me.listeners.slice(0);
      }
      listeners = me.listeners;
      index = length = listeners.length;
      priority = options && options.priority;
      highestNegativePriorityIndex = me._highestNegativePriorityIndex;
      hasNegativePriorityIndex = highestNegativePriorityIndex !== undefined;
      if (priority) {
        isNegativePriority = priority < 0;
        if (!isNegativePriority || hasNegativePriorityIndex) {
          for (i = isNegativePriority ? highestNegativePriorityIndex : 0; i < length; i++) {
            listenerPriority = listeners[i].o ? listeners[i].o.priority || 0 : 0;
            if (listenerPriority < priority) {
              index = i;
              break;
            }
          }
        } else {
          me._highestNegativePriorityIndex = index;
        }
      } else {
        if (hasNegativePriorityIndex) {
          index = highestNegativePriorityIndex;
        }
      }
      if (!isNegativePriority && index <= highestNegativePriorityIndex) {
        me._highestNegativePriorityIndex++;
      }
      if (index === length) {
        listeners[length] = listener;
      } else {
        arrayInsert(listeners, index, [listener]);
      }
      if (observable.isElement) {
        observable._getPublisher(eventName, options.translate === false).subscribe(observable, eventName, options.delegated !== false, options.capture);
      }
      if (manager) {
        managedListeners = manager.managedListeners || (manager.managedListeners = []);
        managedListeners.push({item:me.observable, ename:options && options.managedName || me.name, fn:fn, scope:scope, options:options});
      }
      added = true;
    }
    return added;
  }, createListener:function(fn, scope, o, caller, manager) {
    var me = this, namedScope = Ext._namedScopes[scope], listener = {fn:fn, scope:scope, ev:me, caller:caller, manager:manager, namedScope:namedScope, defaultScope:namedScope ? scope || me.observable : undefined, lateBound:typeof fn === 'string'}, handler = fn, wrapped = false, type;
    if (o) {
      listener.o = o;
      if (o.single) {
        handler = me.createSingle(handler, listener, o, scope);
        wrapped = true;
      }
      if (o.target) {
        handler = me.createTargeted(handler, listener, o, scope, wrapped);
        wrapped = true;
      }
      if (o.onFrame) {
        handler = me.createAnimFrame(handler, listener, o, scope, wrapped);
        wrapped = true;
      }
      if (o.delay) {
        handler = me.createDelayed(handler, listener, o, scope, wrapped);
        wrapped = true;
      }
      if (o.buffer) {
        handler = me.createBuffered(handler, listener, o, scope, wrapped);
        wrapped = true;
      }
      if (me.observable.isElement) {
        type = o.type;
        if (type) {
          listener.type = type;
        }
      }
    }
    listener.fireFn = handler;
    listener.wrapped = wrapped;
    return listener;
  }, findListener:function(fn, scope) {
    var listeners = this.listeners, i = listeners.length, listener;
    while (i--) {
      listener = listeners[i];
      if (listener) {
        if (listener.fn === fn && listener.scope == scope) {
          return i;
        }
      }
    }
    return -1;
  }, removeListener:function(fn, scope, index) {
    var me = this, removed = false, observable = me.observable, eventName = me.name, listener, options, manager, managedListeners, managedListener, i;
    index = index != null ? index : me.findListener(fn, scope);
    if (index !== -1) {
      listener = me.listeners[index];
      if (me.firing) {
        me.listeners = me.listeners.slice(0);
      }
      me.listeners.splice(index, 1);
      if (me._highestNegativePriorityIndex) {
        if (index < me._highestNegativePriorityIndex) {
          me._highestNegativePriorityIndex--;
        } else {
          if (index === me._highestNegativePriorityIndex && index === me.listeners.length) {
            delete me._highestNegativePriorityIndex;
          }
        }
      }
      if (listener) {
        options = listener.o;
        if (listener.task) {
          listener.task.cancel();
          delete listener.task;
        }
        i = listener.tasks && listener.tasks.length;
        if (i) {
          while (i--) {
            listener.tasks[i].cancel();
          }
          delete listener.tasks;
        }
        listener.fireFn.timerId = Ext.undefer(listener.fireFn.timerId);
        manager = listener.manager;
        if (manager) {
          managedListeners = manager.managedListeners;
          if (managedListeners) {
            for (i = managedListeners.length; i--;) {
              managedListener = managedListeners[i];
              if (managedListener.item === me.observable && managedListener.ename === eventName && managedListener.fn === fn && managedListener.scope === scope) {
                managedListeners.splice(i, 1);
              }
            }
          }
        }
        if (observable.isElement) {
          observable._getPublisher(eventName, options.translate === false).unsubscribe(observable, eventName, options.delegated !== false, options.capture);
        }
      }
      removed = true;
    }
    return removed;
  }, clearListeners:function() {
    var listeners = this.listeners, i = listeners.length, listener;
    while (i--) {
      listener = listeners[i];
      this.removeListener(listener.fn, listener.scope);
    }
  }, suspend:function() {
    ++this.suspended;
  }, resume:function() {
    if (this.suspended) {
      --this.suspended;
    }
  }, isSuspended:function() {
    return this.suspended > 0;
  }, fireDelegated:function(firingObservable, args) {
    this.firingObservable = firingObservable;
    return this.fire.apply(this, args);
  }, fire:function() {
    var me = this, CQ = Ext.ComponentQuery, listeners = me.listeners, count = listeners.length, observable = me.observable, isElement = observable.isElement, isComponent = observable.isComponent, firingObservable = me.firingObservable, options, delegate, fireInfo, i, args, listener, len, delegateEl, currentTarget, type, chained, firingArgs, e, fireFn, fireScope;
    if (!me.suspended && count > 0) {
      me.firing = true;
      args = arguments.length ? arraySlice.call(arguments, 0) : [];
      len = args.length;
      if (isElement) {
        e = args[0];
      }
      for (i = 0; i < count; i++) {
        listener = listeners[i];
        if (!listener) {
          continue;
        }
        options = listener.o;
        if (isElement) {
          if (currentTarget) {
            e.setCurrentTarget(currentTarget);
          }
          type = listener.type;
          if (type) {
            chained = e;
            e = args[0] = chained.chain({type:type, isGesture:false});
          }
          Ext.EventObject = e;
        }
        firingArgs = args;
        if (options) {
          delegate = options.delegate;
          if (delegate) {
            if (isElement) {
              delegateEl = e.getTarget(typeof delegate === 'function' ? delegate : '#' + e.currentTarget.id + ' ' + delegate);
              if (delegateEl) {
                args[1] = delegateEl;
                currentTarget = e.currentTarget;
                e.setCurrentTarget(delegateEl);
              } else {
                continue;
              }
            } else {
              if (isComponent && !CQ.is(firingObservable, delegate, observable)) {
                continue;
              }
            }
          }
          if (isElement) {
            if (options.preventDefault) {
              e.preventDefault();
            }
            if (options.stopPropagation) {
              e.stopPropagation();
            }
            if (options.stopEvent) {
              e.stopEvent();
            }
          }
          args[len] = options;
          if (options.args) {
            firingArgs = options.args.concat(args);
          }
        }
        fireInfo = me.getFireInfo(listener);
        fireFn = fireInfo.fn;
        fireScope = fireInfo.scope;
        fireInfo.fn = fireInfo.scope = null;
        if (fireScope && fireScope.destroyed) {
          me.removeListener(fireFn, fireScope, i);
          fireFn = null;
        }
        if (fireFn && fireFn.apply(fireScope, firingArgs) === false) {
          Ext.EventObject = null;
          return me.firing = false;
        }
        if (options) {
          args.length--;
        }
        if (chained) {
          e = args[0] = chained;
          chained = null;
        }
        Ext.EventObject = null;
      }
    }
    me.firing = false;
    return true;
  }, getFireInfo:function(listener, fromWrapped) {
    var observable = this.observable, fireFn = listener.fireFn, scope = listener.scope, namedScope = listener.namedScope, fn;
    if (!fromWrapped && listener.wrapped) {
      fireArgs.fn = fireFn;
      return fireArgs;
    }
    fn = fromWrapped ? listener.fn : fireFn;
    if (listener.lateBound) {
      if (!scope || namedScope) {
        scope = (listener.caller || observable).resolveListenerScope(listener.defaultScope);
      }
      fn = scope[fn];
    } else {
      if (namedScope && namedScope.isController) {
        scope = (listener.caller || observable).resolveListenerScope(listener.defaultScope);
      } else {
        if (!scope || namedScope) {
          scope = observable;
        }
      }
    }
    fireArgs.fn = fn;
    fireArgs.scope = scope;
    return fireArgs;
  }, createAnimFrame:function(handler, listener, o, scope, wrapped) {
    var fireInfo;
    if (!wrapped) {
      fireInfo = listener.ev.getFireInfo(listener, true);
      handler = fireInfo.fn;
      scope = fireInfo.scope;
      fireInfo.fn = fireInfo.scope = null;
    }
    return Ext.Function.createAnimationFrame(handler, scope, o.args);
  }, createTargeted:function(handler, listener, o, scope, wrapped) {
    return function() {
      if (o.target === arguments[0]) {
        var fireInfo;
        if (!wrapped) {
          fireInfo = listener.ev.getFireInfo(listener, true);
          handler = fireInfo.fn;
          scope = fireInfo.scope;
          fireInfo.fn = fireInfo.scope = null;
        }
        return handler.apply(scope, arguments);
      }
    };
  }, createBuffered:function(handler, listener, o, scope, wrapped) {
    listener.task = new Ext.util.DelayedTask;
    return function() {
      if (listener.task) {
        var fireInfo;
        if (!wrapped) {
          fireInfo = listener.ev.getFireInfo(listener, true);
          handler = fireInfo.fn;
          scope = fireInfo.scope;
          fireInfo.fn = fireInfo.scope = null;
        }
        listener.task.delay(o.buffer, handler, scope, toArray(arguments));
      }
    };
  }, createDelayed:function(handler, listener, o, scope, wrapped) {
    return function() {
      var task = new Ext.util.DelayedTask, fireInfo;
      if (!wrapped) {
        fireInfo = listener.ev.getFireInfo(listener, true);
        handler = fireInfo.fn;
        scope = fireInfo.scope;
        fireInfo.fn = fireInfo.scope = null;
      }
      if (!listener.tasks) {
        listener.tasks = [];
      }
      listener.tasks.push(task);
      task.delay(o.delay || 10, handler, scope, toArray(arguments));
    };
  }, createSingle:function(handler, listener, o, scope, wrapped) {
    return function() {
      var event = listener.ev, observable = event.observable, fn = listener.fn, fireInfo;
      if (observable) {
        if (!observable.destroyed) {
          observable.removeListener(event.name, fn, scope);
        }
      } else {
        event.removeListener(fn, scope);
      }
      if (!wrapped) {
        fireInfo = event.getFireInfo(listener, true);
        handler = fireInfo.fn;
        scope = fireInfo.scope;
        fireInfo.fn = fireInfo.scope = null;
      }
      return handler.apply(scope, arguments);
    };
  }};
}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Event'], 0);
Ext.cmd.derive('Ext.mixin.Identifiable', Ext.Base, {statics:{uniqueIds:{}}, isIdentifiable:true, mixinId:'identifiable', idCleanRegex:/\.|[^\w\-]/g, defaultIdPrefix:'ext-', defaultIdSeparator:'-', getOptimizedId:function() {
  return this.id;
}, getUniqueId:function() {
  var id = this.id, prototype, separator, xtype, uniqueIds, prefix;
  if (!(id || id === 0)) {
    prototype = this.self.prototype;
    separator = this.defaultIdSeparator;
    uniqueIds = Ext.mixin.Identifiable.uniqueIds;
    if (!prototype.hasOwnProperty('identifiablePrefix')) {
      xtype = this.xtype;
      if (xtype) {
        prefix = this.defaultIdPrefix + xtype.replace(this.idCleanRegex, separator) + separator;
      } else {
        if (!(prefix = prototype.$className)) {
          prefix = this.defaultIdPrefix + 'anonymous' + separator;
        } else {
          prefix = prefix.replace(this.idCleanRegex, separator).toLowerCase() + separator;
        }
      }
      prototype.identifiablePrefix = prefix;
    }
    prefix = this.identifiablePrefix;
    if (!uniqueIds.hasOwnProperty(prefix)) {
      uniqueIds[prefix] = 0;
    }
    id = this.id = this.id = prefix + ++uniqueIds[prefix];
  }
  this.getUniqueId = this.getOptimizedId;
  return id;
}, setId:function(id) {
  this.id = this.id = id;
}, getId:function() {
  var id = this.id;
  if (!id) {
    id = this.getUniqueId();
  }
  this.getId = this.getOptimizedId;
  return id;
}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Identifiable'], 0);
Ext.cmd.derive('Ext.mixin.Observable', Ext.Mixin, function(Observable) {
  var emptyFn = Ext.emptyFn, emptyArray = [], arrayProto = Array.prototype, arraySlice = arrayProto.slice, ListenerRemover = function(observable) {
    if (observable instanceof ListenerRemover) {
      return observable;
    }
    this.observable = observable;
    if (arguments[1].isObservable) {
      this.managedListeners = true;
    }
    this.args = arraySlice.call(arguments, 1);
  }, protectedProps = ['events', 'hasListeners', 'managedListeners', 'eventedBeforeEventNames'];
  ListenerRemover.prototype.destroy = function() {
    var me = this, args = me.args, observable = me.observable, elementName = args[0].element || args[3] && args[3].element;
    if (elementName) {
      observable = observable[elementName];
    }
    if (!observable.destroyed) {
      observable[me.managedListeners ? 'mun' : 'un'].apply(observable, me.args);
    }
    me.destroy = Ext.emptyFn;
  };
  return {mixinConfig:{id:'observable', after:{destroy:'destroyObservable'}}, statics:{releaseCapture:function(o) {
    o.fireEventArgs = this.prototype.fireEventArgs;
  }, capture:function(o, fn, scope) {
    var newFn = function(eventName, args) {
      return fn.apply(scope, [eventName].concat(args));
    };
    this.captureArgs(o, newFn, scope);
  }, captureArgs:function(o, fn, scope) {
    o.fireEventArgs = Ext.Function.createInterceptor(o.fireEventArgs, fn, scope);
  }, observe:function(cls, listeners) {
    if (cls) {
      if (!cls.isObservable) {
        Ext.applyIf(cls, new this);
        this.captureArgs(cls.prototype, cls.fireEventArgs, cls);
      }
      if (Ext.isObject(listeners)) {
        cls.on(listeners);
      }
    }
    return cls;
  }, prepareClass:function(T, mixin, data) {
    var listeners = T.listeners = [], target = data || T.prototype, targetListeners = target.listeners, superListeners = mixin ? mixin.listeners : T.superclass.self.listeners, name, scope, namedScope, i, len;
    if (superListeners) {
      listeners.push(superListeners);
    }
    if (targetListeners) {
      scope = targetListeners.scope;
      if (!scope) {
        targetListeners.scope = 'self';
      } else {
        namedScope = Ext._namedScopes[scope];
        if (namedScope && namedScope.isController) {
          targetListeners.scope = 'self.controller';
        }
      }
      listeners.push(targetListeners);
      target.listeners = null;
    }
    if (!T.HasListeners) {
      var HasListeners = function() {
      }, SuperHL = T.superclass.HasListeners || mixin && mixin.HasListeners || Observable.HasListeners;
      T.prototype.HasListeners = T.HasListeners = HasListeners;
      HasListeners.prototype = T.hasListeners = new SuperHL;
    }
    scope = T.prototype.$noClearOnDestroy || {};
    for (i = 0, len = protectedProps.length; i < len; i++) {
      scope[protectedProps[i]] = true;
    }
    T.prototype.$noClearOnDestroy = scope;
  }}, isObservable:true, $vetoClearingPrototypeOnDestroy:true, eventsSuspended:0, constructor:function(config) {
    var me = this, self = me.self, declaredListeners, listeners, bubbleEvents, len, i;
    if (me.$observableInitialized) {
      return;
    }
    me.$observableInitialized = true;
    me.hasListeners = me.hasListeners = new me.HasListeners;
    me.eventedBeforeEventNames = {};
    me.events = me.events || {};
    declaredListeners = self.listeners;
    if (declaredListeners && !me._addDeclaredListeners(declaredListeners)) {
      self.listeners = null;
    }
    listeners = config && config.listeners || me.listeners;
    if (listeners) {
      if (listeners instanceof Array) {
        for (i = 0, len = listeners.length; i < len; ++i) {
          me.addListener(listeners[i]);
        }
      } else {
        me.addListener(listeners);
      }
    }
    bubbleEvents = config && config.bubbleEvents || me.bubbleEvents;
    if (bubbleEvents) {
      me.enableBubble(bubbleEvents);
    }
    if (me.$applyConfigs) {
      if (config) {
        Ext.apply(me, config);
      }
    } else {
      me.initConfig(config);
    }
    if (listeners) {
      me.listeners = null;
    }
  }, onClassExtended:function(T, data) {
    if (!T.HasListeners) {
      Observable.prepareClass(T, T.prototype.$observableMixedIn ? undefined : data);
    }
  }, $eventOptions:{scope:1, delay:1, buffer:1, onFrame:1, single:1, args:1, destroyable:1, priority:1, order:1}, $orderToPriority:{before:100, current:0, after:-100}, _addDeclaredListeners:function(listeners) {
    var me = this;
    if (listeners instanceof Array) {
      Ext.each(listeners, me._addDeclaredListeners, me);
    } else {
      me._addedDeclaredListeners = true;
      me.addListener(listeners);
    }
    return me._addedDeclaredListeners;
  }, addManagedListener:function(item, ename, fn, scope, options, noDestroy) {
    var me = this, managedListeners = me.managedListeners = me.managedListeners || [], config, passedOptions;
    if (typeof ename !== 'string') {
      passedOptions = arguments.length > 4 ? options : ename;
      options = ename;
      for (ename in options) {
        if (options.hasOwnProperty(ename)) {
          config = options[ename];
          if (!item.$eventOptions[ename]) {
            me.addManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope, config.fn ? config : passedOptions, true);
          }
        }
      }
      if (options && options.destroyable) {
        return new ListenerRemover(me, item, options);
      }
    } else {
      if (fn !== emptyFn) {
        item.doAddListener(ename, fn, scope, options, null, me, me);
        if (!noDestroy && options && options.destroyable) {
          return new ListenerRemover(me, item, ename, fn, scope);
        }
      }
    }
  }, removeManagedListener:function(item, ename, fn, scope) {
    var me = this, options, config, managedListeners, length, i;
    if (item.$observableDestroyed) {
      return;
    }
    if (typeof ename !== 'string') {
      options = ename;
      for (ename in options) {
        if (options.hasOwnProperty(ename)) {
          config = options[ename];
          if (!item.$eventOptions[ename]) {
            me.removeManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope);
          }
        }
      }
    } else {
      managedListeners = me.managedListeners ? me.managedListeners.slice() : [];
      ename = Ext.canonicalEventName(ename);
      for (i = 0, length = managedListeners.length; i < length; i++) {
        me.removeManagedListenerItem(false, managedListeners[i], item, ename, fn, scope);
      }
    }
  }, fireEvent:function(eventName) {
    return this.fireEventArgs(eventName, arraySlice.call(arguments, 1));
  }, resolveListenerScope:function(defaultScope) {
    var namedScope = Ext._namedScopes[defaultScope];
    if (namedScope) {
      if (namedScope.isSelf || namedScope.isThis) {
        defaultScope = null;
      }
    }
    return defaultScope || this;
  }, fireEventArgs:function(eventName, args) {
    eventName = Ext.canonicalEventName(eventName);
    var me = this, events = me.events, event = events && events[eventName], ret = true;
    if (me.hasListeners[eventName]) {
      ret = me.doFireEvent(eventName, args || emptyArray, event ? event.bubble : false);
    }
    return ret;
  }, fireAction:function(eventName, args, fn, scope, options, order) {
    if (typeof fn === 'string' && !scope) {
      fn = this[fn];
    }
    options = options ? Ext.Object.chain(options) : {};
    options.single = true;
    options.priority = order === 'after' ? -99.5 : 99.5;
    this.doAddListener(eventName, fn, scope, options);
    this.fireEventArgs(eventName, args);
  }, $eventedController:{_paused:1, pause:function() {
    ++this._paused;
  }, resume:function() {
    var me = this, fn = me.fn, scope = me.scope, fnArgs = me.fnArgs, owner = me.owner, args, ret;
    if (!--me._paused) {
      if (fn) {
        args = Ext.Array.slice(fnArgs || me.args);
        if (fnArgs === false) {
          args.shift();
        }
        me.fn = null;
        args.push(me);
        if (Ext.isFunction(fn)) {
          ret = fn.apply(scope, args);
        } else {
          if (scope && Ext.isString(fn) && Ext.isFunction(scope[fn])) {
            ret = scope[fn].apply(scope, args);
          }
        }
        if (ret === false) {
          return false;
        }
      }
      if (!me._paused) {
        return me.owner.fireEventArgs(me.eventName, me.args);
      }
    }
  }}, fireEventedAction:function(eventName, args, fn, scope, fnArgs) {
    var me = this, eventedBeforeEventNames = me.eventedBeforeEventNames, beforeEventName = eventedBeforeEventNames[eventName] || (eventedBeforeEventNames[eventName] = 'before' + eventName), controller = Ext.apply({owner:me, eventName:eventName, fn:fn, scope:scope, fnArgs:fnArgs, args:args}, me.$eventedController), value;
    args.push(controller);
    value = me.fireEventArgs(beforeEventName, args);
    args.pop();
    if (value === false) {
      return false;
    }
    return controller.resume();
  }, doFireEvent:function(eventName, args, bubbles) {
    var target = this, queue, event, ret = true;
    do {
      if (target.eventsSuspended) {
        if (queue = target.eventQueue) {
          queue.push([eventName, args]);
        }
        return ret;
      } else {
        event = target.events && target.events[eventName];
        if (event && event !== true) {
          if ((ret = event.fire.apply(event, args)) === false) {
            break;
          }
        }
      }
    } while (bubbles && (target = target.getBubbleParent()));
    return ret;
  }, getBubbleParent:function() {
    var me = this, parent = me.getBubbleTarget && me.getBubbleTarget();
    if (parent && parent.isObservable) {
      return parent;
    }
    return null;
  }, addListener:function(eventName, fn, scope, options, order, caller) {
    var me = this, namedScopes = Ext._namedScopes, config, namedScope, isClassListener, innerScope, eventOptions;
    if (typeof eventName !== 'string') {
      options = eventName;
      scope = options.scope;
      namedScope = scope && namedScopes[scope];
      isClassListener = namedScope && namedScope.isSelf;
      eventOptions = (me.isComponent || me.isWidget) && options.element ? me.$elementEventOptions : me.$eventOptions;
      for (eventName in options) {
        config = options[eventName];
        if (!eventOptions[eventName]) {
          innerScope = config.scope;
          if (innerScope && isClassListener) {
            namedScope = namedScopes[innerScope];
            if (namedScope && namedScope.isController) {
              innerScope = 'self.controller';
            }
          }
          me.doAddListener(eventName, config.fn || config, innerScope || scope, config.fn ? config : options, order, caller);
        }
      }
      if (options && options.destroyable) {
        return new ListenerRemover(me, options);
      }
    } else {
      me.doAddListener(eventName, fn, scope, options, order, caller);
      if (options && options.destroyable) {
        return new ListenerRemover(me, eventName, fn, scope, options);
      }
    }
    return me;
  }, removeListener:function(eventName, fn, scope, eventOptions) {
    var me = this, config, options;
    if (typeof eventName !== 'string') {
      options = eventName;
      eventOptions = eventOptions || me.$eventOptions;
      for (eventName in options) {
        if (options.hasOwnProperty(eventName)) {
          config = options[eventName];
          if (!me.$eventOptions[eventName]) {
            me.doRemoveListener(eventName, config.fn || config, config.scope || options.scope);
          }
        }
      }
    } else {
      me.doRemoveListener(eventName, fn, scope);
    }
    return me;
  }, onBefore:function(eventName, fn, scope, options) {
    return this.addListener(eventName, fn, scope, options, 'before');
  }, onAfter:function(eventName, fn, scope, options) {
    return this.addListener(eventName, fn, scope, options, 'after');
  }, unBefore:function(eventName, fn, scope, options) {
    return this.removeListener(eventName, fn, scope, options, 'before');
  }, unAfter:function(eventName, fn, scope, options) {
    return this.removeListener(eventName, fn, scope, options, 'after');
  }, addBeforeListener:function() {
    return this.onBefore.apply(this, arguments);
  }, addAfterListener:function() {
    return this.onAfter.apply(this, arguments);
  }, removeBeforeListener:function() {
    return this.unBefore.apply(this, arguments);
  }, removeAfterListener:function() {
    return this.unAfter.apply(this, arguments);
  }, clearListeners:function() {
    var me = this, events = me.events, hasListeners = me.hasListeners, event, key;
    if (events) {
      for (key in events) {
        if (events.hasOwnProperty(key)) {
          event = events[key];
          if (event.isEvent) {
            delete hasListeners[key];
            event.clearListeners();
          }
        }
      }
      me.events = null;
    }
    me.clearManagedListeners();
  }, clearManagedListeners:function() {
    var me = this, managedListeners = me.managedListeners, i, len;
    if (managedListeners) {
      me.managedListeners = null;
      for (i = 0, len = managedListeners.length; i < len; i++) {
        me.removeManagedListenerItem(true, managedListeners[i]);
      }
      managedListeners.length = 0;
    }
    me.managedListeners = managedListeners;
  }, removeManagedListenerItem:function(isClear, managedListener, item, ename, fn, scope) {
    if (isClear || managedListener.item === item && managedListener.ename === ename && (!fn || managedListener.fn === fn) && (!scope || managedListener.scope === scope)) {
      if (!managedListener.item.destroyed) {
        managedListener.item.doRemoveListener(managedListener.ename, managedListener.fn, managedListener.scope, managedListener.options);
      }
      if (!isClear) {
        Ext.Array.remove(this.managedListeners, managedListener);
      }
    }
  }, hasListener:function(eventName) {
    eventName = Ext.canonicalEventName(eventName);
    return !!this.hasListeners[eventName];
  }, isSuspended:function(event) {
    var suspended = this.eventsSuspended > 0, events = this.events;
    if (!suspended && event && events) {
      event = events[event];
      if (event && event.isEvent) {
        return event.isSuspended();
      }
    }
    return suspended;
  }, suspendEvents:function(queueSuspended) {
    ++this.eventsSuspended;
    if (queueSuspended && !this.eventQueue) {
      this.eventQueue = [];
    }
  }, suspendEvent:function() {
    var me = this, events = me.events, len = arguments.length, i, event, ename;
    for (i = 0; i < len; i++) {
      ename = arguments[i];
      ename = Ext.canonicalEventName(ename);
      event = events[ename];
      if (!event || !event.isEvent) {
        event = me._initEvent(ename);
      }
      event.suspend();
    }
  }, resumeEvent:function() {
    var events = this.events || 0, len = events && arguments.length, i, event, ename;
    for (i = 0; i < len; i++) {
      ename = Ext.canonicalEventName(arguments[i]);
      event = events[ename];
      if (event && event.resume) {
        event.resume();
      }
    }
  }, resumeEvents:function(discardQueue) {
    var me = this, queued = me.eventQueue, qLen, q;
    if (me.eventsSuspended && !--me.eventsSuspended) {
      delete me.eventQueue;
      if (!discardQueue && queued) {
        qLen = queued.length;
        for (q = 0; q < qLen; q++) {
          me.fireEventArgs.apply(me, queued[q]);
        }
      }
    }
  }, relayEvents:function(origin, events, prefix) {
    var me = this, len = events.length, i = 0, oldName, newName, relayers = {};
    if (Ext.isObject(events)) {
      for (i in events) {
        newName = events[i];
        relayers[i] = me.createRelayer(newName);
      }
    } else {
      for (; i < len; i++) {
        oldName = events[i];
        relayers[oldName] = me.createRelayer(prefix ? prefix + oldName : oldName);
      }
    }
    me.mon(origin, relayers, null, null, undefined);
    return new ListenerRemover(me, origin, relayers);
  }, createRelayer:function(newName, beginEnd) {
    var me = this;
    return function() {
      return me.fireEventArgs.call(me, newName, beginEnd ? arraySlice.apply(arguments, beginEnd) : arguments);
    };
  }, enableBubble:function(eventNames) {
    if (eventNames) {
      var me = this, names = typeof eventNames == 'string' ? arguments : eventNames, events = me.events, length = events && names.length, ename, event, i;
      for (i = 0; i < length; ++i) {
        ename = names[i];
        ename = Ext.canonicalEventName(ename);
        event = events[ename];
        if (!event || !event.isEvent) {
          event = me._initEvent(ename);
        }
        me.hasListeners._incr_(ename);
        event.bubble = true;
      }
    }
  }, destroy:function() {
    this.clearListeners();
    this.callParent();
    this.destroyObservable(true);
  }, destroyObservable:function(skipClearListeners) {
    var me = this, clearPropertiesOnDestroy = me.clearPropertiesOnDestroy;
    if (me.$observableDestroyed) {
      return;
    }
    if (!skipClearListeners) {
      me.clearListeners();
    }
    if (me.destroyed) {
      if (clearPropertiesOnDestroy) {
        if (clearPropertiesOnDestroy === true && !me.$nulled) {
          me.$reap();
        }
        if (!me.clearPrototypeOnDestroy) {
          me.fireEvent = me.fireEventArgs = me.fireAction = me.fireEventedAction = Ext.emptyFn;
        }
        me.events = me.managedListeners = me.eventedBeforeEventNames = null;
        me.$observableDestroyed = true;
      }
    }
  }, privates:{doAddListener:function(ename, fn, scope, options, order, caller, manager) {
    var me = this, ret = false, event, priority;
    order = order || options && options.order;
    if (order) {
      priority = options && options.priority;
      if (!priority) {
        options = options ? Ext.Object.chain(options) : {};
        options.priority = me.$orderToPriority[order];
      }
    }
    ename = Ext.canonicalEventName(ename);
    event = (me.events || (me.events = {}))[ename];
    if (!event || !event.isEvent) {
      event = me._initEvent(ename);
    }
    if (fn !== emptyFn) {
      if (!manager && (scope && scope.isObservable && scope !== me)) {
        manager = scope;
      }
      if (event.addListener(fn, scope, options, caller, manager)) {
        me.hasListeners._incr_(ename);
        ret = true;
      }
    }
    return ret;
  }, doRemoveListener:function(ename, fn, scope) {
    var me = this, ret = false, events = me.events, event;
    ename = Ext.canonicalEventName(ename);
    event = events && events[ename];
    if (event && event.isEvent) {
      if (event.removeListener(fn, scope)) {
        me.hasListeners._decr_(ename);
        ret = true;
      }
    }
    return ret;
  }, _initEvent:function(eventName) {
    return this.events[eventName] = new Ext.util.Event(this, eventName);
  }}, deprecated:{'5.0':{methods:{addEvents:null}}}};
}, 1, 0, 0, 0, 0, [[Ext.mixin.Identifiable.prototype.mixinId || Ext.mixin.Identifiable.$className, Ext.mixin.Identifiable]], [Ext.mixin, 'Observable'], function() {
  var Observable = this, proto = Observable.prototype, HasListeners = function() {
  }, prepareMixin = function(T) {
    if (!T.HasListeners) {
      var proto = T.prototype;
      proto.$observableMixedIn = 1;
      Observable.prepareClass(T, this);
      T.onExtended(function(U, data) {
        Observable.prepareClass(U, null, data);
      });
      if (proto.onClassMixedIn) {
        Ext.override(T, {onClassMixedIn:function(U) {
          prepareMixin.call(this, U);
          this.callParent(arguments);
        }});
      } else {
        proto.onClassMixedIn = function(U) {
          prepareMixin.call(this, U);
        };
      }
    }
    superOnClassMixedIn.call(this, T);
  }, superOnClassMixedIn = proto.onClassMixedIn;
  HasListeners.prototype = {_decr_:function(ev, count) {
    if (count == null) {
      count = 1;
    }
    if (!(this[ev] -= count)) {
      delete this[ev];
    }
  }, _incr_:function(ev) {
    if (this.hasOwnProperty(ev)) {
      ++this[ev];
    } else {
      this[ev] = 1;
    }
  }};
  proto.HasListeners = Observable.HasListeners = HasListeners;
  Observable.createAlias({on:'addListener', un:'removeListener', mon:'addManagedListener', mun:'removeManagedListener', setListeners:'addListener'});
  Observable.observeClass = Observable.observe;
  function getMethodEvent(method) {
    var event = (this.methodEvents = this.methodEvents || {})[method], returnValue, v, cancel, me = this, makeCall;
    if (!event) {
      me.methodEvents[method] = event = {};
      event.originalFn = me[method];
      event.methodName = method;
      event.before = [];
      event.after = [];
      makeCall = function(fn, scope, args) {
        scope = scope || me;
        if (typeof fn === 'string') {
          fn = scope[fn];
        }
        if ((v = fn.apply(scope, args)) !== undefined) {
          if (typeof v == 'object') {
            if (v.returnValue !== undefined) {
              returnValue = v.returnValue;
            } else {
              returnValue = v;
            }
            cancel = !!v.cancel;
          } else {
            if (v === false) {
              cancel = true;
            } else {
              returnValue = v;
            }
          }
        }
      };
      me[method] = function() {
        var args = Array.prototype.slice.call(arguments, 0), argsLen = args.length, b, i, len;
        returnValue = v = undefined;
        cancel = false;
        for (i = 0, len = event.before.length; i < len; i++) {
          b = event.before[i];
          if (b.extraArgs) {
            args.push.apply(args, b.extraArgs);
          }
          makeCall(b.fn, b.scope, args);
          args.length = argsLen;
          if (cancel || b.preventDefault) {
            return returnValue;
          }
        }
        if ((v = event.originalFn.apply(me, args)) !== undefined) {
          returnValue = v;
        }
        for (i = 0, len = event.after.length; i < len; i++) {
          b = event.after[i];
          if (b.extraArgs) {
            args.push.apply(args, b.extraArgs);
          }
          makeCall(b.fn, b.scope, args);
          args.length = argsLen;
          if (cancel || b.preventDefault) {
            return returnValue;
          }
        }
        return returnValue;
      };
    }
    return event;
  }
  Ext.apply(proto, {onClassMixedIn:prepareMixin, beforeMethod:function(method, fn, scope, preventDefault, extraArgs) {
    getMethodEvent.call(this, method).before.push({fn:fn, scope:scope, extraArgs:extraArgs, preventDefault:preventDefault});
  }, afterMethod:function(method, fn, scope, preventDefault, extraArgs) {
    getMethodEvent.call(this, method).after.push({fn:fn, scope:scope, extraArgs:extraArgs, preventDefault:preventDefault});
  }, removeMethodListener:function(method, fn, scope) {
    var e = getMethodEvent.call(this, method), i, len;
    for (i = 0, len = e.before.length; i < len; i++) {
      if (e.before[i].fn == fn && e.before[i].scope == scope) {
        Ext.Array.erase(e.before, i, 1);
        return;
      }
    }
    for (i = 0, len = e.after.length; i < len; i++) {
      if (e.after[i].fn == fn && e.after[i].scope == scope) {
        Ext.Array.erase(e.after, i, 1);
        return;
      }
    }
  }, toggleEventLogging:function(toggle) {
    Ext.util.Observable[toggle ? 'capture' : 'releaseCapture'](this, function(en) {
      if (Ext.isDefined(Ext.global.console)) {
        Ext.global.console.log(en, arguments);
      }
    });
  }});
});
Ext.cmd.derive('Ext.util.HashMap', Ext.Base, {generation:0, config:{keyFn:null}, constructor:function(config) {
  var me = this, fn;
  me.mixins.observable.constructor.call(me, config);
  me.clear(true);
  fn = me.getKeyFn();
  if (fn) {
    me.getKey = fn;
  }
}, getCount:function() {
  return this.length;
}, getData:function(key, value) {
  if (value === undefined) {
    value = key;
    key = this.getKey(value);
  }
  return [key, value];
}, getKey:function(o) {
  return o.id;
}, add:function(key, value) {
  var me = this;
  if (arguments.length === 1) {
    value = key;
    key = me.getKey(value);
  }
  if (me.containsKey(key)) {
    return me.replace(key, value);
  }
  me.map[key] = value;
  ++me.length;
  me.generation++;
  if (me.hasListeners.add) {
    me.fireEvent('add', me, key, value);
  }
  return value;
}, replace:function(key, value) {
  var me = this, map = me.map, old;
  if (arguments.length === 1) {
    value = key;
    key = me.getKey(value);
  }
  if (!me.containsKey(key)) {
    me.add(key, value);
  }
  old = map[key];
  map[key] = value;
  me.generation++;
  if (me.hasListeners.replace) {
    me.fireEvent('replace', me, key, value, old);
  }
  return value;
}, remove:function(o) {
  var key = this.findKey(o);
  if (key !== undefined) {
    return this.removeAtKey(key);
  }
  return false;
}, removeAtKey:function(key) {
  var me = this, value;
  if (me.containsKey(key)) {
    value = me.map[key];
    delete me.map[key];
    --me.length;
    me.generation++;
    if (me.hasListeners.remove) {
      me.fireEvent('remove', me, key, value);
    }
    return true;
  }
  return false;
}, get:function(key) {
  var map = this.map;
  return map.hasOwnProperty(key) ? map[key] : undefined;
}, clear:function(initial) {
  var me = this;
  if (initial || me.generation) {
    me.map = {};
    me.length = 0;
    me.generation = initial ? 0 : me.generation + 1;
  }
  if (initial !== true && me.hasListeners.clear) {
    me.fireEvent('clear', me);
  }
  return me;
}, containsKey:function(key) {
  var map = this.map;
  return map.hasOwnProperty(key) && map[key] !== undefined;
}, contains:function(value) {
  return this.containsKey(this.findKey(value));
}, getKeys:function() {
  return this.getArray(true);
}, getValues:function() {
  return this.getArray(false);
}, getArray:function(isKey) {
  var arr = [], key, map = this.map;
  for (key in map) {
    if (map.hasOwnProperty(key)) {
      arr.push(isKey ? key : map[key]);
    }
  }
  return arr;
}, each:function(fn, scope) {
  var items = Ext.apply({}, this.map), key, length = this.length;
  scope = scope || this;
  for (key in items) {
    if (items.hasOwnProperty(key)) {
      if (fn.call(scope, key, items[key], length) === false) {
        break;
      }
    }
  }
  return this;
}, clone:function() {
  var hash = new this.self(this.initialConfig), map = this.map, key;
  hash.suspendEvents();
  for (key in map) {
    if (map.hasOwnProperty(key)) {
      hash.add(key, map[key]);
    }
  }
  hash.resumeEvents();
  return hash;
}, findKey:function(value) {
  var key, map = this.map;
  for (key in map) {
    if (map.hasOwnProperty(key) && map[key] === value) {
      return key;
    }
  }
  return undefined;
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.util, 'HashMap'], function(HashMap) {
  var prototype = HashMap.prototype;
  prototype.removeByKey = prototype.removeAtKey;
});
Ext.cmd.derive('Ext.promise.Consequence', Ext.Base, function(Consequence) {
  return {promise:null, deferred:null, onFulfilled:null, onRejected:null, onProgress:null, constructor:function(onFulfilled, onRejected, onProgress) {
    var me = this;
    me.onFulfilled = onFulfilled;
    me.onRejected = onRejected;
    me.onProgress = onProgress;
    me.deferred = new Ext.promise.Deferred;
    me.promise = me.deferred.promise;
  }, trigger:function(action, value) {
    var me = this, deferred = me.deferred;
    switch(action) {
      case 'fulfill':
        me.propagate(value, me.onFulfilled, deferred, deferred.resolve);
        break;
      case 'reject':
        me.propagate(value, me.onRejected, deferred, deferred.reject);
        break;
    }
  }, update:function(progress) {
    if (Ext.isFunction(this.onProgress)) {
      progress = this.onProgress(progress);
    }
    this.deferred.update(progress);
  }, propagate:function(value, callback, deferred, deferredMethod) {
    if (Ext.isFunction(callback)) {
      this.schedule(function() {
        try {
          deferred.resolve(callback(value));
        } catch (e$9) {
          deferred.reject(e$9);
        }
      });
    } else {
      deferredMethod.call(this.deferred, value);
    }
  }, schedule:function(callback) {
    var n = Consequence.queueSize++;
    Consequence.queue[n] = callback;
    if (!n) {
      Ext.asap(Consequence.dispatch);
    }
  }, statics:{queue:new Array(10000), queueSize:0, dispatch:function() {
    var queue = Consequence.queue, fn, i;
    for (i = 0; i < Consequence.queueSize; ++i) {
      fn = queue[i];
      queue[i] = null;
      fn();
    }
    Consequence.queueSize = 0;
  }}};
}, 1, 0, 0, 0, 0, 0, [Ext.promise, 'Consequence'], 0);
Ext.cmd.derive('Ext.promise.Deferred', Ext.Base, {promise:null, consequences:[], completed:false, completionAction:null, completionValue:null, constructor:function() {
  var me = this;
  me.promise = new Ext.promise.Promise(me);
  me.consequences = [];
  me.completed = false;
  me.completionAction = null;
  me.completionValue = null;
}, then:function(onFulfilled, onRejected, onProgress) {
  var me = this, consequence = new Ext.promise.Consequence(onFulfilled, onRejected, onProgress);
  if (me.completed) {
    consequence.trigger(me.completionAction, me.completionValue);
  } else {
    me.consequences.push(consequence);
  }
  return consequence.promise;
}, resolve:function(value) {
  var me = this, isHandled, thenFn;
  if (me.completed) {
    return;
  }
  try {
    if (value === me.promise) {
      throw new TypeError('A Promise cannot be resolved with itself.');
    }
    if (value != null && (typeof value === 'object' || Ext.isFunction(value)) && Ext.isFunction(thenFn = value.then)) {
      isHandled = false;
      try {
        thenFn.call(value, function(value) {
          if (!isHandled) {
            isHandled = true;
            me.resolve(value);
          }
        }, function(error) {
          if (!isHandled) {
            isHandled = true;
            me.reject(error);
          }
        });
      } catch (e1) {
        if (!isHandled) {
          me.reject(e1);
        }
      }
    } else {
      me.complete('fulfill', value);
    }
  } catch (e2) {
    me.reject(e2);
  }
}, reject:function(reason) {
  if (this.completed) {
    return;
  }
  this.complete('reject', reason);
}, update:function(progress) {
  var consequences = this.consequences, consequence, i, len;
  if (this.completed) {
    return;
  }
  for (i = 0, len = consequences.length; i < len; i++) {
    consequence = consequences[i];
    consequence.update(progress);
  }
}, complete:function(action, value) {
  var me = this, consequences = me.consequences, consequence, i, len;
  me.completionAction = action;
  me.completionValue = value;
  me.completed = true;
  for (i = 0, len = consequences.length; i < len; i++) {
    consequence = consequences[i];
    consequence.trigger(me.completionAction, me.completionValue);
  }
  me.consequences = null;
}}, 1, 0, 0, 0, 0, 0, [Ext.promise, 'Deferred'], 0);
Ext.cmd.derive('Ext.promise.Promise', Ext.Base, function(ExtPromise) {
  var Deferred;
  return {statics:{CancellationError:Ext.global.CancellationError || Error, _ready:function() {
    Deferred = Ext.promise.Deferred;
  }, all:function(promisesOrValues) {
    return ExtPromise.when(promisesOrValues).then(function(promisesOrValues) {
      var deferred = new Deferred, remainingToResolve = promisesOrValues.length, results = new Array(remainingToResolve), index, promiseOrValue, resolve, i, len;
      if (!remainingToResolve) {
        deferred.resolve(results);
      } else {
        resolve = function(item, index) {
          return ExtPromise.when(item).then(function(value) {
            results[index] = value;
            if (!--remainingToResolve) {
              deferred.resolve(results);
            }
            return value;
          }, function(reason) {
            return deferred.reject(reason);
          });
        };
        for (index = i = 0, len = promisesOrValues.length; i < len; index = ++i) {
          promiseOrValue = promisesOrValues[index];
          if (index in promisesOrValues) {
            resolve(promiseOrValue, index);
          } else {
            remainingToResolve--;
          }
        }
      }
      return deferred.promise;
    });
  }, is:function(value) {
    return value != null && (typeof value === 'object' || Ext.isFunction(value)) && Ext.isFunction(value.then);
  }, race:function(promises) {
    var deferred = new Deferred, len = promises.length, i;
    for (i = 0; i < len; ++i) {
      deferred.resolve(promises[i]);
    }
    return deferred.promise;
  }, rethrowError:function(error) {
    Ext.asap(function() {
      throw error;
    });
  }, when:function(value) {
    var deferred = new Deferred;
    deferred.resolve(value);
    return deferred.promise;
  }}, owner:null, constructor:function(owner) {
    this.owner = owner;
  }, then:function(onFulfilled, onRejected, onProgress, scope) {
    var ref;
    if (arguments.length === 1 && Ext.isObject(arguments[0])) {
      ref = arguments[0];
      onFulfilled = ref.success;
      onRejected = ref.failure;
      onProgress = ref.progress;
      scope = ref.scope;
    }
    if (scope) {
      if (onFulfilled) {
        onFulfilled = onFulfilled.bind(scope);
      }
      if (onRejected) {
        onRejected = onRejected.bind(scope);
      }
      if (onProgress) {
        onProgress = onProgress.bind(scope);
      }
    }
    return this.owner.then(onFulfilled, onRejected, onProgress);
  }, 'catch':function(onRejected, scope) {
    var ref;
    if (arguments.length === 1 && Ext.isObject(arguments[0])) {
      ref = arguments[0];
      onRejected = ref.fn;
      scope = ref.scope;
    }
    if (scope != null) {
      onRejected = onRejected.bind(scope);
    }
    return this.owner.then(null, onRejected);
  }, otherwise:function(onRejected, scope) {
    return this['catch'].apply(this, arguments);
  }, always:function(onCompleted, scope) {
    var ref;
    if (arguments.length === 1 && Ext.isObject(arguments[0])) {
      ref = arguments[0];
      onCompleted = ref.fn;
      scope = ref.scope;
    }
    if (scope != null) {
      onCompleted = onCompleted.bind(scope);
    }
    return this.owner.then(function(value) {
      try {
        onCompleted();
      } catch (e$10) {
        ExtPromise.rethrowError(e$10);
      }
      return value;
    }, function(reason) {
      try {
        onCompleted();
      } catch (e$11) {
        ExtPromise.rethrowError(e$11);
      }
      throw reason;
    });
  }, done:function() {
    this.owner.then(null, ExtPromise.rethrowError);
  }, cancel:function(reason) {
    if (reason == null) {
      reason = null;
    }
    this.owner.reject(new this.self.CancellationError(reason));
  }, log:function(identifier) {
    if (identifier == null) {
      identifier = '';
    }
    return this.owner.then(function(value) {
      Ext.log('' + (identifier || 'Promise') + ' resolved with value: ' + value);
      return value;
    }, function(reason) {
      Ext.log('' + (identifier || 'Promise') + ' rejected with reason: ' + reason);
      throw reason;
    });
  }};
}, 1, 0, 0, 0, 0, 0, [Ext.promise, 'Promise'], function(ExtPromise) {
  ExtPromise._ready();
});
Ext.cmd.derive('Ext.Promise', Ext.Base, function() {
  var Polyfiller;
  return {statics:{_ready:function() {
    Polyfiller = Ext.promise.Promise;
  }, all:function() {
    return Polyfiller.all.apply(Polyfiller, arguments);
  }, race:function() {
    return Polyfiller.race.apply(Polyfiller, arguments);
  }, reject:function(reason) {
    var deferred = new Ext.promise.Deferred;
    deferred.reject(reason);
    return deferred.promise;
  }, resolve:function(value) {
    var deferred = new Ext.promise.Deferred;
    deferred.resolve(value);
    return deferred.promise;
  }}, constructor:function(action) {
    var deferred = new Ext.promise.Deferred;
    action(deferred.resolve.bind(deferred), deferred.reject.bind(deferred));
    return deferred.promise;
  }};
}, 1, 0, 0, 0, 0, 0, [Ext, 'Promise'], function(ExtPromise) {
  var P = Ext.global.Promise;
  if (P && P.resolve && !Ext.useExtPromises) {
    Ext.Promise = P;
  } else {
    ExtPromise._ready();
  }
});
Ext.cmd.derive('Ext.Deferred', Ext.promise.Deferred, function(Deferred) {
  var ExtPromise, rejected, resolved, when;
  return {statics:{_ready:function() {
    ExtPromise = Ext.promise.Promise;
    when = Ext.Promise.resolve;
  }, all:function() {
    return ExtPromise.all.apply(ExtPromise, arguments);
  }, any:function(promisesOrValues) {
    return Deferred.some(promisesOrValues, 1).then(function(array) {
      return array[0];
    }, function(error) {
      if (error instanceof Error && error.message === 'Too few Promises were resolved.') {
        Ext.raise('No Promises were resolved.');
      } else {
        throw error;
      }
    });
  }, delay:function(promiseOrValue, milliseconds) {
    var deferred;
    if (arguments.length === 1) {
      milliseconds = promiseOrValue;
      promiseOrValue = undefined;
    }
    milliseconds = Math.max(milliseconds, 1);
    deferred = new Deferred;
    deferred.timeoutId = Ext.defer(function() {
      delete deferred.timeoutId;
      deferred.resolve(promiseOrValue);
    }, milliseconds);
    return deferred.promise;
  }, getCachedRejected:function() {
    if (!rejected) {
      rejected = Ext.Promise.reject();
    }
    return rejected;
  }, getCachedResolved:function() {
    if (!resolved) {
      resolved = Ext.Promise.resolve();
    }
    return resolved;
  }, map:function(promisesOrValues, mapFn) {
    return Deferred.resolved(promisesOrValues).then(function(promisesOrValues) {
      var deferred, index, promiseOrValue, remainingToResolve, resolve, results, i, len;
      remainingToResolve = promisesOrValues.length;
      results = new Array(promisesOrValues.length);
      deferred = new Deferred;
      if (!remainingToResolve) {
        deferred.resolve(results);
      } else {
        resolve = function(item, index) {
          return Deferred.resolved(item).then(function(value) {
            return mapFn(value, index, results);
          }).then(function(value) {
            results[index] = value;
            if (!--remainingToResolve) {
              deferred.resolve(results);
            }
            return value;
          }, function(reason) {
            return deferred.reject(reason);
          });
        };
        for (index = i = 0, len = promisesOrValues.length; i < len; index = ++i) {
          promiseOrValue = promisesOrValues[index];
          if (index in promisesOrValues) {
            resolve(promiseOrValue, index);
          } else {
            remainingToResolve--;
          }
        }
      }
      return deferred.promise;
    });
  }, memoize:function(fn, scope, hashFn) {
    var memoizedFn = Ext.Function.memoize(fn, scope, hashFn);
    return function() {
      return Deferred.all(Ext.Array.slice(arguments)).then(function(values) {
        return memoizedFn.apply(scope, values);
      });
    };
  }, parallel:function(fns, scope) {
    if (scope == null) {
      scope = null;
    }
    var args = Ext.Array.slice(arguments, 2);
    return Deferred.map(fns, function(fn) {
      if (!Ext.isFunction(fn)) {
        throw new Error('Invalid parameter: expected a function.');
      }
      return fn.apply(scope, args);
    });
  }, pipeline:function(fns, initialValue, scope) {
    if (scope == null) {
      scope = null;
    }
    return Deferred.reduce(fns, function(value, fn) {
      if (!Ext.isFunction(fn)) {
        throw new Error('Invalid parameter: expected a function.');
      }
      return fn.call(scope, value);
    }, initialValue);
  }, race:function() {
    return ExtPromise.race.apply(ExtPromise, arguments);
  }, reduce:function(values, reduceFn, initialValue) {
    var initialValueSpecified = arguments.length === 3;
    return Deferred.resolved(values).then(function(promisesOrValues) {
      var reduceArguments = [promisesOrValues, function(previousValueOrPromise, currentValueOrPromise, currentIndex) {
        return Deferred.resolved(previousValueOrPromise).then(function(previousValue) {
          return Deferred.resolved(currentValueOrPromise).then(function(currentValue) {
            return reduceFn(previousValue, currentValue, currentIndex, promisesOrValues);
          });
        });
      }];
      if (initialValueSpecified) {
        reduceArguments.push(initialValue);
      }
      return Ext.Array.reduce.apply(Ext.Array, reduceArguments);
    });
  }, rejected:function(reason) {
    var deferred = new Ext.Deferred;
    deferred.reject(reason);
    return deferred.promise;
  }, resolved:function(promiseOrValue) {
    var deferred = new Ext.Deferred;
    deferred.resolve(promiseOrValue);
    return deferred.promise;
  }, sequence:function(fns, scope) {
    if (scope == null) {
      scope = null;
    }
    var args = Ext.Array.slice(arguments, 2);
    return Deferred.reduce(fns, function(results, fn) {
      if (!Ext.isFunction(fn)) {
        throw new Error('Invalid parameter: expected a function.');
      }
      return Deferred.resolved(fn.apply(scope, args)).then(function(result) {
        results.push(result);
        return results;
      });
    }, []);
  }, some:function(promisesOrValues, howMany) {
    return Deferred.resolved(promisesOrValues).then(function(promisesOrValues) {
      var deferred, index, onReject, onResolve, promiseOrValue, remainingToReject, remainingToResolve, values, i, len;
      values = [];
      remainingToResolve = howMany;
      remainingToReject = promisesOrValues.length - remainingToResolve + 1;
      deferred = new Deferred;
      if (promisesOrValues.length < howMany) {
        deferred.reject(new Error('Too few Promises were resolved.'));
      } else {
        onResolve = function(value) {
          if (remainingToResolve > 0) {
            values.push(value);
          }
          remainingToResolve--;
          if (remainingToResolve === 0) {
            deferred.resolve(values);
          }
          return value;
        };
        onReject = function(reason) {
          remainingToReject--;
          if (remainingToReject === 0) {
            deferred.reject(new Error('Too few Promises were resolved.'));
          }
          return reason;
        };
        for (index = i = 0, len = promisesOrValues.length; i < len; index = ++i) {
          promiseOrValue = promisesOrValues[index];
          if (index in promisesOrValues) {
            Deferred.resolved(promiseOrValue).then(onResolve, onReject);
          }
        }
      }
      return deferred.promise;
    });
  }, timeout:function(promiseOrValue, milliseconds) {
    var deferred = new Deferred, timeoutId;
    timeoutId = Ext.defer(function() {
      if (timeoutId) {
        deferred.reject(new Error('Promise timed out.'));
      }
    }, milliseconds);
    Deferred.resolved(promiseOrValue).then(function(value) {
      Ext.undefer(timeoutId);
      timeoutId = null;
      deferred.resolve(value);
    }, function(reason) {
      Ext.undefer(timeoutId);
      timeoutId = null;
      deferred.reject(reason);
    });
    return deferred.promise;
  }}};
}, 0, 0, 0, 0, 0, 0, [Ext, 'Deferred'], function(Deferred) {
  Deferred._ready();
});
Ext.Factory = function(type) {
  var me = this;
  me.aliasPrefix = type + '.';
  me.cache = {};
  me.name = type.replace(me.fixNameRe, me.fixNameFn);
  me.type = type;
  me.creator = 'create' + Ext.String.capitalize(me.name);
};
Ext.Factory.prototype = {defaultProperty:'type', instanceProp:'isInstance', typeProperty:'type', create:function(config, defaultType) {
  var me = this, Manager = Ext.ClassManager, cache = me.cache, typeProperty = me.typeProperty, alias, className, klass, suffix;
  if (config) {
    if (config[me.instanceProp]) {
      return config;
    }
    if (typeof config === 'string') {
      suffix = config;
      config = {};
      config[me.defaultProperty] = suffix;
    }
    className = config.xclass;
    suffix = config[typeProperty];
  }
  if (defaultType && defaultType.constructor === Object) {
    config = Ext.apply({}, config, defaultType);
    defaultType = defaultType[typeProperty];
  }
  if (className) {
    if (!(klass = Manager.get(className))) {
      return Manager.instantiate(className, config);
    }
  } else {
    if (!(suffix = suffix || defaultType || me.defaultType)) {
      klass = me.defaultClass;
    }
    if (!klass && !(klass = cache[suffix])) {
      alias = me.aliasPrefix + suffix;
      className = Manager.getNameByAlias(alias);
      if (!(klass = className && Manager.get(className))) {
        return Manager.instantiateByAlias(alias, config);
      }
      cache[suffix] = klass;
    }
  }
  return klass.isInstance ? klass : new klass(config);
}, fixNameRe:/\.[a-z]/ig, fixNameFn:function(match) {
  return match.substring(1).toUpperCase();
}, clearCache:function() {
  this.cache = {};
  this.instanceCache = {};
}, hook:function(fn) {
  var me = this, original = me.create;
  me.create = function(config, defaultType) {
    var ret = fn.call(me, original, config, defaultType);
    if (ret === undefined) {
      ret = original.call(me, config, defaultType);
    }
    return ret;
  };
}, update:function(instance, config, creator, creatorMethod, defaultsConfig) {
  var me = this, aliases, defaults, reuse, type;
  if (!config || config.isInstance) {
    if (instance && instance !== config) {
      instance.destroy();
    }
    return config;
  }
  if (typeof config === 'string') {
    type = config;
    config = {};
    config[me.defaultProperty] = type;
  }
  if (instance) {
    if (config === true) {
      return instance;
    }
    if (!(type = config.xclass)) {
      if (!(type = config.xtype)) {
        type = config[me.typeProperty];
        if (type) {
          type = me.aliasPrefix + type;
          aliases = instance.self.prototype;
          if (aliases.hasOwnProperty('alias')) {
            aliases = aliases.alias;
            if (aliases) {
              reuse = aliases === type || aliases.indexOf(type) > -1;
            }
          }
        }
      } else {
        reuse = instance.isXType(type, true);
      }
    } else {
      reuse = instance.$className === type;
    }
    if (reuse) {
      instance.setConfig(config);
      return instance;
    }
    instance.destroy();
  }
  if (config === true) {
    config = {};
  }
  if (creator) {
    if (defaultsConfig) {
      defaults = Ext.Config.map[defaultsConfig];
      defaults = creator[defaults.names.get]();
      if (defaults) {
        config = Ext.merge(Ext.clone(defaults), config);
      }
    }
    creatorMethod = creatorMethod || me.creator;
    if (creator[creatorMethod]) {
      config = creator[creatorMethod](config);
    }
  }
  return me.create(config);
}};
Ext.Factory.define = function(type, config) {
  var Factory = Ext.Factory, cacheable = config && config.cacheable, defaultClass, factory, fn;
  if (type.constructor === Object) {
    Ext.Object.each(type, Factory.define, Factory);
  } else {
    factory = new Ext.Factory(type);
    if (config) {
      if (config.constructor === Object) {
        Ext.apply(factory, config);
        if (typeof(defaultClass = factory.xclass) === 'string') {
          factory.defaultClass = Ext.ClassManager.get(defaultClass);
        }
      } else {
        factory.defaultType = config;
      }
    }
    Factory[factory.name] = fn = function(config, defaultType) {
      return factory.create(config, defaultType);
    };
    if (cacheable) {
      factory.instanceCache = {};
      factory.hook(function(original, config, defaultType) {
        var cache = this.instanceCache, v;
        if (typeof config === 'string' && !(v = cache[config])) {
          v = original.call(this, config, defaultType);
          if (v.cacheable !== false) {
            cache[config] = v;
          }
        }
        return v;
      });
    }
    fn.instance = factory;
    fn.update = function(instance, config, creator, creatorMethod, defaultsConfig) {
      return factory.update(instance, config, creator, creatorMethod, defaultsConfig);
    };
  }
  return fn;
};
Ext.Factory.clearCaches = function() {
  var Factory = Ext.Factory, key, item;
  for (key in Factory) {
    item = Factory[key];
    item = item.instance;
    if (item) {
      item.clearCache();
    }
  }
};
Ext.Factory.on = function(name, fn) {
  Ext.Factory[name].instance.hook(fn);
};
Ext.cmd.derive('Ext.mixin.Factoryable', Ext.Base, {mixinId:'factoryable', onClassMixedIn:function(targetClass) {
  var proto = targetClass.prototype, factoryConfig = proto.factoryConfig, alias = proto.alias, config = {}, dot, createFn;
  alias = alias && alias.length && alias[0];
  if (alias && (dot = alias.lastIndexOf('.')) > 0) {
    config.type = alias.substring(0, dot);
    config.defaultType = alias.substring(dot + 1);
  }
  if (factoryConfig) {
    delete proto.factoryConfig;
    Ext.apply(config, factoryConfig);
  }
  createFn = Ext.Factory.define(config.type, config);
  if (targetClass.create === Ext.Base.create) {
    targetClass.create = createFn;
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Factoryable'], 0);
Ext.cmd.derive('Ext.data.request.Base', Ext.Base, {factoryConfig:{type:'request', defaultType:'ajax'}, result:null, success:null, timer:null, constructor:function(config) {
  var me = this;
  Ext.apply(me, config.options || {}, config.ownerConfig);
  me.id = ++Ext.data.Connection.requestId;
  me.owner = config.owner;
  me.options = config.options;
  me.requestOptions = config.requestOptions;
}, start:function() {
  var me = this, timeout = me.getTimeout();
  if (timeout && me.async) {
    me.timer = Ext.defer(me.onTimeout, timeout, me);
  }
}, abort:function() {
  var me = this;
  me.clearTimer();
  if (!me.timedout) {
    me.aborted = true;
  }
  me.abort = Ext.emptyFn;
}, createDeferred:function() {
  var me = this, result = me.result, d = new Ext.Deferred;
  if (me.completed) {
    if (me.success) {
      d.resolve(result);
    } else {
      d.reject(result);
    }
  }
  me.deferred = d;
  return d;
}, getDeferred:function() {
  return this.deferred || this.createDeferred();
}, getPromise:function() {
  return this.getDeferred().promise;
}, then:function() {
  var promise = this.getPromise();
  return promise.then.apply(promise, arguments);
}, onComplete:function() {
  var me = this, deferred = me.deferred, result = me.result;
  me.clearTimer();
  if (deferred) {
    if (me.success) {
      deferred.resolve(result);
    } else {
      deferred.reject(result);
    }
  }
  me.completed = true;
}, onTimeout:function() {
  var me = this;
  me.timedout = true;
  me.timer = null;
  me.abort(true);
}, getTimeout:function() {
  return this.timeout;
}, clearTimer:function() {
  this.timer = Ext.undefer(this.timer);
}, destroy:function() {
  var me = this;
  me.abort();
  me.owner = me.options = me.requestOptions = me.result = null;
  me.callParent();
}, privates:{createException:function() {
  var me = this, result;
  result = {request:me, requestId:me.id, status:me.aborted ? -1 : 0, statusText:me.aborted ? 'transaction aborted' : 'communication failure', getResponseHeader:me._getHeader, getAllResponseHeaders:me._getHeaders};
  if (me.aborted) {
    result.aborted = true;
  }
  if (me.timedout) {
    result.timedout = true;
  }
  return result;
}, _getHeader:function(name) {
  var headers = this.headers;
  return headers && headers[name.toLowerCase()];
}, _getHeaders:function() {
  return this.headers;
}}}, 1, 0, 0, 0, 0, [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.request, 'Base'], 0);
Ext.cmd.derive('Ext.data.flash.BinaryXhr', Ext.Base, {statics:{flashPluginActivated:function() {
  Ext.data.flash.BinaryXhr.flashPluginActive = true;
  Ext.data.flash.BinaryXhr.flashPlugin = document.getElementById('ext-flash-polyfill');
  Ext.GlobalEvents.fireEvent('flashready');
}, flashPluginActive:false, flashPluginInjected:false, connectionIndex:1, liveConnections:{}, flashPlugin:null, onFlashStateChange:function(javascriptId, state, data) {
  var connection;
  connection = this.liveConnections[Number(javascriptId)];
  if (connection) {
    connection.onFlashStateChange(state, data);
  }
}, registerConnection:function(conn) {
  var i = this.connectionIndex;
  this.conectionIndex = this.connectionIndex + 1;
  this.liveConnections[i] = conn;
  return i;
}, injectFlashPlugin:function() {
  var me = this, flashLoaderPath, flashObjectPath;
  me.flashPolyfillEl = Ext.getBody().appendChild({id:'ext-flash-polyfill', cn:[{tag:'p', html:'To view this page ensure that Adobe Flash Player version 11.1.0 or greater is installed.'}, {tag:'a', href:'http://www.adobe.com/go/getflashplayer', cn:[{tag:'img', src:window.location.protocol + '//www.adobe.com/images/shared/download_buttons/get_flash_player.gif', alt:'Get Adobe Flash player'}]}]});
  flashLoaderPath = [Ext.Loader.getPath('Ext.data.Connection'), '../../../plugins/flash/swfobject.js'].join('/');
  flashObjectPath = '/plugins/flash/FlashPlugin.swf';
  if (Ext.flashPluginPath) {
    flashObjectPath = Ext.flashPluginPath;
  }
  Ext.Loader.loadScript({url:flashLoaderPath, onLoad:function() {
    var swfVersionStr = '11.4.0';
    var xiSwfUrlStr = 'playerProductInstall.swf';
    var flashvars = {};
    var params = {};
    params.quality = 'high';
    params.bgcolor = '#ffffff';
    params.allowscriptaccess = 'sameDomain';
    params.allowfullscreen = 'true';
    var attributes = {};
    attributes.id = 'ext-flash-polyfill';
    attributes.name = 'polyfill';
    attributes.align = 'middle';
    swfobject.embedSWF(flashObjectPath, 'ext-flash-polyfill', '0', '0', swfVersionStr, xiSwfUrlStr, flashvars, params, attributes);
  }, onError:function() {
  }, scope:me});
  Ext.data.flash.BinaryXhr.flashPluginInjected = true;
}}, readyState:0, status:0, statusText:'', responseBytes:null, javascriptId:null, constructor:function(config) {
  if (!Ext.data.flash.BinaryXhr.flashPluginInjected) {
    Ext.data.flash.BinaryXhr.injectFlashPlugin();
  }
  var me = this;
  Ext.apply(me, config);
  me.requestHeaders = {};
}, abort:function() {
  var me = this;
  if (me.readyState == 4) {
    return;
  }
  me.aborted = true;
  if (!Ext.data.flash.BinaryXhr.flashPluginActive) {
    Ext.GlobalEvents.removeListener('flashready', me.onFlashReady, me);
    return;
  }
  Ext.data.flash.BinaryXhr.flashPlugin.abortRequest(me.javascriptId);
  delete Ext.data.flash.BinaryXhr.liveConnections[me.javascriptId];
}, getAllResponseHeaders:function() {
  var headers = [];
  Ext.Object.each(this.responseHeaders, function(name, value) {
    headers.push(name + ': ' + value);
  });
  return headers.join('\r\n');
}, getResponseHeader:function(header) {
  var headers = this.responseHeaders;
  return headers && headers[header] || null;
}, open:function(method, url, async, user, password) {
  var me = this;
  me.method = method;
  me.url = url;
  me.async = async !== false;
  me.user = user;
  me.password = password;
}, overrideMimeType:function(mimeType) {
  this.mimeType = mimeType;
}, send:function(body) {
  var me = this;
  me.body = body;
  if (!Ext.data.flash.BinaryXhr.flashPluginActive) {
    Ext.GlobalEvents.addListener('flashready', me.onFlashReady, me);
  } else {
    this.onFlashReady();
  }
}, onFlashReady:function() {
  var me = this, req, status;
  me.javascriptId = Ext.data.flash.BinaryXhr.registerConnection(me);
  req = {method:me.method, url:me.url, user:me.user, password:me.password, mimeType:me.mimeType, requestHeaders:me.requestHeaders, body:me.body, javascriptId:me.javascriptId};
  status = Ext.data.flash.BinaryXhr.flashPlugin.postBinary(req);
}, setReadyState:function(state) {
  var me = this;
  if (me.readyState != state) {
    me.readyState = state;
    me.onreadystatechange();
  }
}, setRequestHeader:function(header, value) {
  this.requestHeaders[header] = value;
}, onreadystatechange:Ext.emptyFn, parseData:function(data) {
  var me = this;
  this.status = data.status || 0;
  me.responseHeaders = {};
  if (me.mimeType) {
    me.responseHeaders['content-type'] = me.mimeType;
  }
  if (data.reason == 'complete') {
    this.responseBytes = data.data;
    me.responseHeaders['content-length'] = data.data.length;
  } else {
    if (data.reason == 'error' || data.reason == 'securityError') {
      this.statusText = data.text;
      me.responseHeaders['content-length'] = 0;
    }
  }
}, onFlashStateChange:function(state, data) {
  var me = this;
  if (state == 4) {
    me.parseData(data);
    delete Ext.data.flash.BinaryXhr.liveConnections[me.javascriptId];
  }
  me.setReadyState(state);
}}, 1, 0, 0, 0, 0, 0, [Ext.data.flash, 'BinaryXhr'], 0);
Ext.cmd.derive('Ext.data.request.Ajax', Ext.data.request.Base, {statics:{parseStatus:function(status, response) {
  var len;
  if (response) {
    if (response.responseType === 'arraybuffer') {
      len = response.byteLength;
    } else {
      if (response.responseText) {
        len = response.responseText.length;
      }
    }
  }
  status = status == 1223 ? 204 : status;
  var success = status >= 200 && status < 300 || status == 304 || status == 0 && Ext.isNumber(len), isException = false;
  if (!success) {
    switch(status) {
      case 12002:
      case 12029:
      case 12030:
      case 12031:
      case 12152:
      case 13030:
        isException = true;
        break;
    }
  }
  return {success:success, isException:isException};
}}, start:function(data) {
  var me = this, options = me.options, requestOptions = me.requestOptions, isXdr = me.isXdr, xhr, headers;
  xhr = me.xhr = me.openRequest(options, requestOptions, me.async, me.username, me.password);
  if (!isXdr) {
    headers = me.setupHeaders(xhr, options, requestOptions.data, requestOptions.params);
  }
  if (me.async) {
    if (!isXdr) {
      xhr.onreadystatechange = me.bindStateChange();
    }
  }
  if (isXdr) {
    me.processXdrRequest(me, xhr);
  }
  Ext.data.request.Base.prototype.start.call(this, data);
  xhr.send(data);
  if (!me.async) {
    return me.onComplete();
  }
  return me;
}, abort:function(force) {
  var me = this, xhr = me.xhr;
  if (force || me.isLoading()) {
    try {
      xhr.onreadystatechange = null;
    } catch (e$12) {
      xhr.onreadystatechange = Ext.emptyFn;
    }
    xhr.abort();
    Ext.data.request.Base.prototype.abort.call(this, force);
    me.onComplete();
    me.cleanup();
  }
}, cleanup:function() {
  this.xhr = null;
  delete this.xhr;
}, isLoading:function() {
  var me = this, xhr = me.xhr, state = xhr && xhr.readyState, C = Ext.data.flash && Ext.data.flash.BinaryXhr;
  if (!xhr || me.aborted || me.timedout) {
    return false;
  }
  if (C && xhr instanceof C) {
    return state !== 4;
  }
  return state !== 0 && state !== 4;
}, openRequest:function(options, requestOptions, async, username, password) {
  var me = this, xhr = me.newRequest(options);
  if (username) {
    xhr.open(requestOptions.method, requestOptions.url, async, username, password);
  } else {
    if (me.isXdr) {
      xhr.open(requestOptions.method, requestOptions.url);
    } else {
      xhr.open(requestOptions.method, requestOptions.url, async);
    }
  }
  if (options.binary || me.binary) {
    if (window.Uint8Array) {
      xhr.responseType = 'arraybuffer';
    } else {
      if (xhr.overrideMimeType) {
        xhr.overrideMimeType('text/plain; charset\x3dx-user-defined');
      }
    }
  }
  if (options.withCredentials || me.withCredentials) {
    xhr.withCredentials = true;
  }
  return xhr;
}, newRequest:function(options) {
  var me = this, xhr;
  if (options.binaryData) {
    if (window.Uint8Array) {
      xhr = me.getXhrInstance();
    } else {
      xhr = new Ext.data.flash.BinaryXhr;
    }
  } else {
    if (me.cors && Ext.isIE9m) {
      xhr = me.getXdrInstance();
      me.isXdr = true;
    } else {
      xhr = me.getXhrInstance();
      me.isXdr = false;
    }
  }
  return xhr;
}, setupHeaders:function(xhr, options, data, params) {
  var me = this, headers = Ext.apply({}, options.headers || {}, me.defaultHeaders), contentType = me.defaultPostHeader, jsonData = options.jsonData, xmlData = options.xmlData, type = 'Content-Type', useHeader = me.useDefaultXhrHeader, key, header;
  if (!headers.hasOwnProperty(type) && (data || params)) {
    if (data) {
      if (options.rawData) {
        contentType = 'text/plain';
      } else {
        if (xmlData && Ext.isDefined(xmlData)) {
          contentType = 'text/xml';
        } else {
          if (jsonData && Ext.isDefined(jsonData)) {
            contentType = 'application/json';
          }
        }
      }
    }
    headers[type] = contentType;
  }
  if (useHeader && !headers['X-Requested-With']) {
    headers['X-Requested-With'] = me.defaultXhrHeader;
  }
  if (headers[type] === undefined || headers[type] === null) {
    delete headers[type];
  }
  try {
    for (key in headers) {
      if (headers.hasOwnProperty(key)) {
        header = headers[key];
        xhr.setRequestHeader(key, header);
      }
    }
  } catch (e$13) {
    me.owner.fireEvent('exception', key, header);
  }
  return headers;
}, getXdrInstance:function() {
  var xdr;
  if (Ext.ieVersion >= 8) {
    xdr = new XDomainRequest;
  } else {
    Ext.raise({msg:'Your browser does not support CORS'});
  }
  return xdr;
}, getXhrInstance:function() {
  var options = [function() {
    return new XMLHttpRequest;
  }, function() {
    return new ActiveXObject('MSXML2.XMLHTTP.3.0');
  }, function() {
    return new ActiveXObject('MSXML2.XMLHTTP');
  }, function() {
    return new ActiveXObject('Microsoft.XMLHTTP');
  }], i = 0, len = options.length, xhr;
  for (; i < len; ++i) {
    try {
      xhr = options[i];
      xhr();
      break;
    } catch (e$14) {
    }
  }
  return xhr;
}(), processXdrRequest:function(request, xhr) {
  var me = this;
  delete request.headers;
  request.contentType = request.options.contentType || me.defaultXdrContentType;
  xhr.onload = me.bindStateChange(true);
  xhr.onerror = xhr.ontimeout = me.bindStateChange(false);
}, processXdrResponse:function(response, xhr) {
  response.getAllResponseHeaders = function() {
    return [];
  };
  response.getResponseHeader = function() {
    return '';
  };
  response.contentType = xhr.contentType || this.defaultXdrContentType;
}, bindStateChange:function(xdrResult) {
  var me = this;
  return function() {
    Ext.elevate(function() {
      me.onStateChange(xdrResult);
    });
  };
}, onStateChange:function(xdrResult) {
  var me = this, xhr = me.xhr;
  if (xhr && xhr.readyState == 4 || me.isXdr) {
    me.clearTimer();
    me.onComplete(xdrResult);
    me.cleanup();
  }
}, onComplete:function(xdrResult) {
  var me = this, owner = me.owner, options = me.options, xhr = me.xhr, failure = {success:false, isException:false}, result, success, response;
  if (!xhr || me.destroyed) {
    return me.result = failure;
  }
  try {
    result = Ext.data.request.Ajax.parseStatus(xhr.status, xhr);
    if (result.success) {
      result.success = xhr.readyState === 4;
    }
  } catch (e$15) {
    result = failure;
  }
  success = me.success = me.isXdr ? xdrResult : result.success;
  if (success) {
    response = me.createResponse(xhr);
    if (owner.hasListeners.requestcomplete) {
      owner.fireEvent('requestcomplete', owner, response, options);
    }
    if (options.success) {
      Ext.callback(options.success, options.scope, [response, options]);
    }
  } else {
    if (result.isException || me.aborted || me.timedout) {
      response = me.createException(xhr);
    } else {
      response = me.createResponse(xhr);
    }
    if (owner.hasListeners.requestexception) {
      owner.fireEvent('requestexception', owner, response, options);
    }
    if (options.failure) {
      Ext.callback(options.failure, options.scope, [response, options]);
    }
  }
  me.result = response;
  if (options.callback) {
    Ext.callback(options.callback, options.scope, [options, success, response]);
  }
  owner.onRequestComplete(me);
  Ext.data.request.Base.prototype.onComplete.call(this, xdrResult);
  return response;
}, createResponse:function(xhr) {
  var me = this, isXdr = me.isXdr, headers = {}, lines = isXdr ? [] : xhr.getAllResponseHeaders().replace(/\r\n/g, '\n').split('\n'), count = lines.length, line, index, key, response, byteArray;
  while (count--) {
    line = lines[count];
    index = line.indexOf(':');
    if (index >= 0) {
      key = line.substr(0, index).toLowerCase();
      if (line.charAt(index + 1) == ' ') {
        ++index;
      }
      headers[key] = line.substr(index + 1);
    }
  }
  response = {request:me, requestId:me.id, status:xhr.status, statusText:xhr.statusText, getResponseHeader:function(header) {
    return headers[header.toLowerCase()];
  }, getAllResponseHeaders:function() {
    return headers;
  }};
  if (isXdr) {
    me.processXdrResponse(response, xhr);
  }
  if (me.binary) {
    response.responseBytes = me.getByteArray(xhr);
  } else {
    response.responseText = xhr.responseText;
    response.responseXML = xhr.responseXML;
  }
  return response;
}, destroy:function() {
  this.xhr = null;
  Ext.data.request.Base.prototype.destroy.call(this);
}, privates:{getByteArray:function(xhr) {
  var response = xhr.response, responseBody = xhr.responseBody, Cls = Ext.data.flash && Ext.data.flash.BinaryXhr, byteArray, responseText, len, i;
  if (xhr instanceof Cls) {
    byteArray = xhr.responseBytes;
  } else {
    if (window.Uint8Array) {
      byteArray = response ? new Uint8Array(response) : [];
    } else {
      if (Ext.isIE9p) {
        try {
          byteArray = (new VBArray(responseBody)).toArray();
        } catch (e$16) {
          byteArray = [];
        }
      } else {
        if (Ext.isIE) {
          if (!this.self.vbScriptInjected) {
            this.injectVBScript();
          }
          getIEByteArray(xhr.responseBody, byteArray = []);
        } else {
          byteArray = [];
          responseText = xhr.responseText;
          len = responseText.length;
          for (i = 0; i < len; i++) {
            byteArray.push(responseText.charCodeAt(i) & 255);
          }
        }
      }
    }
  }
  return byteArray;
}, injectVBScript:function() {
  var scriptTag = document.createElement('script');
  scriptTag.type = 'text/vbscript';
  scriptTag.text = ['Function getIEByteArray(byteArray, out)', 'Dim len, i', 'len \x3d LenB(byteArray)', 'For i \x3d 1 to len', 'out.push(AscB(MidB(byteArray, i, 1)))', 'Next', 'End Function'].join('\n');
  Ext.getHead().dom.appendChild(scriptTag);
  this.self.vbScriptInjected = true;
}}}, 0, 0, 0, 0, ['request.ajax'], 0, [Ext.data.request, 'Ajax'], 0);
Ext.cmd.derive('Ext.data.request.Form', Ext.data.request.Base, {start:function(data) {
  var me = this, options = me.options, requestOptions = me.requestOptions;
  Ext.data.request.Base.prototype.start.call(this, data);
  me.form = me.upload(options.form, requestOptions.url, requestOptions.data, options);
  return me;
}, abort:function(force) {
  var me = this, frame;
  if (me.isLoading()) {
    try {
      frame = me.frame.dom;
      if (frame.stop) {
        frame.stop();
      } else {
        frame.document.execCommand('Stop');
      }
    } catch (e$17) {
    }
  }
  Ext.data.request.Base.prototype.abort.call(this, force);
  me.onComplete();
  me.cleanup();
}, cleanup:function() {
  var me = this, frame = me.frame;
  if (frame) {
    frame.un('load', me.onComplete, me);
    Ext.removeNode(frame);
  }
  me.frame = me.form = null;
}, isLoading:function() {
  return !!this.frame;
}, upload:function(form, url, params, options) {
  form = Ext.getDom(form);
  options = options || {};
  var frameDom = document.createElement('iframe'), frame = Ext.get(frameDom), id = frame.id, hiddens = [], encoding = 'multipart/form-data', buf = {target:form.target, method:form.method, encoding:form.encoding, enctype:form.enctype, action:form.action}, addField = function(name, value) {
    hiddenItem = document.createElement('input');
    Ext.fly(hiddenItem).set({type:'hidden', value:value, name:name});
    form.appendChild(hiddenItem);
    hiddens.push(hiddenItem);
  }, hiddenItem, obj, value, name, vLen, v, hLen, h;
  frame.set({name:id, cls:'x-hidden-display', src:Ext.SSL_SECURE_URL, tabIndex:-1});
  document.body.appendChild(frameDom);
  document.body.appendChild(form);
  if (document.frames) {
    document.frames[id].name = id;
  }
  Ext.fly(form).set({target:id, method:'POST', enctype:encoding, encoding:encoding, action:url || buf.action});
  if (params) {
    obj = Ext.Object.fromQueryString(params) || {};
    for (name in obj) {
      if (obj.hasOwnProperty(name)) {
        value = obj[name];
        if (Ext.isArray(value)) {
          vLen = value.length;
          for (v = 0; v < vLen; v++) {
            addField(name, value[v]);
          }
        } else {
          addField(name, value);
        }
      }
    }
  }
  this.frame = frame;
  frame.on({load:this.onComplete, scope:this, single:!Ext.isOpera});
  form.submit();
  document.body.removeChild(form);
  Ext.fly(form).set(buf);
  for (hLen = hiddens.length, h = 0; h < hLen; h++) {
    Ext.removeNode(hiddens[h]);
  }
  return form;
}, getDoc:function() {
  var frame = this.frame.dom;
  return frame && (frame.contentWindow.document || frame.contentDocument) || (window.frames[frame.id] || {}).document;
}, getTimeout:function() {
  return this.options.timeout;
}, onComplete:function() {
  var me = this, frame = me.frame, owner = me.owner, options = me.options, callback, doc, success, contentNode, response;
  if (!frame) {
    return;
  }
  if (me.aborted || me.timedout) {
    me.result = response = me.createException();
    response.responseXML = null;
    response.responseText = Ext.encode({success:false, message:Ext.String.trim(response.statusText)});
    response.request = me;
    callback = options.failure;
    success = false;
  } else {
    try {
      doc = me.getDoc();
      me.result = response = {responseText:'', responseXML:null, request:me};
      if (doc) {
        if (Ext.isOpera && doc.location == Ext.SSL_SECURE_URL) {
          return;
        }
        if (doc.body) {
          if ((contentNode = doc.body.firstChild) && /pre/i.test(contentNode.tagName)) {
            response.responseText = contentNode.textContent || contentNode.innerText;
          } else {
            if (contentNode = doc.getElementsByTagName('textarea')[0]) {
              response.responseText = contentNode.value;
            } else {
              response.responseText = doc.body.textContent || doc.body.innerText;
            }
          }
        }
        response.responseXML = doc.XMLDocument || doc;
        callback = options.success;
        success = true;
        response.status = 200;
      } else {
        Ext.raise('Could not acquire a suitable connection for the file upload service.');
      }
    } catch (e$18) {
      me.result = response = me.createException();
      response.status = 400;
      response.statusText = (e$18.message || e$18.description) + '';
      response.responseText = Ext.encode({success:false, message:Ext.String.trim(response.statusText)});
      response.responseXML = null;
      callback = options.failure;
      success = false;
    }
  }
  me.frame = null;
  me.success = success;
  owner.fireEvent(success ? 'requestcomplete' : 'requestexception', owner, response, options);
  Ext.callback(callback, options.scope, [response, options]);
  Ext.callback(options.callback, options.scope, [options, success, response]);
  owner.onRequestComplete(me);
  Ext.asap(frame.destroy, frame);
  Ext.data.request.Base.prototype.onComplete.call(this);
}, destroy:function() {
  this.cleanup();
  Ext.data.request.Base.prototype.destroy.call(this);
}}, 0, 0, 0, 0, ['request.form'], 0, [Ext.data.request, 'Form'], 0);
Ext.cmd.derive('Ext.data.Connection', Ext.Base, {statics:{requestId:0}, enctypeRe:/multipart\/form-data/i, config:{url:null, async:true, username:'', password:'', disableCaching:true, withCredentials:false, binary:false, cors:false, isXdr:false, defaultXdrContentType:'text/plain', disableCachingParam:'_dc', timeout:30000, extraParams:null, autoAbort:false, method:null, defaultHeaders:null, defaultPostHeader:'application/x-www-form-urlencoded; charset\x3dUTF-8', useDefaultXhrHeader:true, defaultXhrHeader:'XMLHttpRequest'}, 
constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
  this.requests = {};
}, request:function(options) {
  options = options || {};
  var me = this, requestOptions, request;
  if (me.fireEvent('beforerequest', me, options) !== false) {
    requestOptions = me.setOptions(options, options.scope || Ext.global);
    request = me.createRequest(options, requestOptions);
    return request.start(requestOptions.data);
  }
  request = {status:-1, statusText:'Request cancelled in beforerequest event handler'};
  Ext.callback(options.callback, options.scope, [options, false, request]);
  return Ext.Deferred.rejected([options, false, request]);
}, createRequest:function(options, requestOptions) {
  var me = this, type = options.type || requestOptions.type, request;
  if (!type) {
    type = me.isFormUpload(options) ? 'form' : 'ajax';
  }
  if (options.autoAbort || me.getAutoAbort()) {
    me.abort();
  }
  request = Ext.Factory.request({type:type, owner:me, options:options, requestOptions:requestOptions, ownerConfig:me.getConfig()});
  me.requests[request.id] = request;
  me.latestId = request.id;
  return request;
}, isFormUpload:function(options) {
  var form = this.getForm(options);
  if (form) {
    return options.isUpload || this.enctypeRe.test(form.getAttribute('enctype'));
  }
  return false;
}, getForm:function(options) {
  return Ext.getDom(options.form);
}, setOptions:function(options, scope) {
  var me = this, params = options.params || {}, extraParams = me.getExtraParams(), urlParams = options.urlParams, url = options.url || me.getUrl(), cors = options.cors, jsonData = options.jsonData, method, disableCache, data;
  if (cors !== undefined) {
    me.setCors(cors);
  }
  if (Ext.isFunction(params)) {
    params = params.call(scope, options);
  }
  if (Ext.isFunction(url)) {
    url = url.call(scope, options);
  }
  url = this.setupUrl(options, url);
  data = options.rawData || options.binaryData || options.xmlData || jsonData || null;
  if (jsonData && !Ext.isPrimitive(jsonData)) {
    data = Ext.encode(data);
  }
  if (options.binaryData) {
    if (me.nativeBinaryPostSupport()) {
      data = new Uint8Array(options.binaryData);
      if (Ext.isChrome && Ext.chromeVersion < 22 || Ext.isSafari || Ext.isGecko) {
        data = data.buffer;
      }
    }
  }
  if (Ext.isObject(params)) {
    params = Ext.Object.toQueryString(params);
  }
  if (Ext.isObject(extraParams)) {
    extraParams = Ext.Object.toQueryString(extraParams);
  }
  params = params + (extraParams ? (params ? '\x26' : '') + extraParams : '');
  urlParams = Ext.isObject(urlParams) ? Ext.Object.toQueryString(urlParams) : urlParams;
  params = this.setupParams(options, params);
  method = (options.method || me.getMethod() || (params || data ? 'POST' : 'GET')).toUpperCase();
  this.setupMethod(options, method);
  disableCache = options.disableCaching !== false ? options.disableCaching || me.getDisableCaching() : false;
  if (method === 'GET' && disableCache) {
    url = Ext.urlAppend(url, (options.disableCachingParam || me.getDisableCachingParam()) + '\x3d' + (new Date).getTime());
  }
  if ((method == 'GET' || data) && params) {
    url = Ext.urlAppend(url, params);
    params = null;
  }
  if (urlParams) {
    url = Ext.urlAppend(url, urlParams);
  }
  return {url:url, method:method, data:data || params || null};
}, setupUrl:function(options, url) {
  var form = this.getForm(options);
  if (form) {
    url = url || form.action;
  }
  return url;
}, setupParams:function(options, params) {
  var form = this.getForm(options), serializedForm;
  if (form && !this.isFormUpload(options)) {
    serializedForm = Ext.Element.serializeForm(form);
    params = params ? params + '\x26' + serializedForm : serializedForm;
  }
  return params;
}, setupMethod:function(options, method) {
  if (this.isFormUpload(options)) {
    return 'POST';
  }
  return method;
}, isLoading:function(request) {
  if (!request) {
    request = this.getLatest();
  }
  return request ? request.isLoading() : false;
}, abort:function(request) {
  if (!request) {
    request = this.getLatest();
  }
  if (request && request.isLoading()) {
    request.abort();
  }
}, abortAll:function() {
  var requests = this.requests, id;
  for (id in requests) {
    this.abort(requests[id]);
  }
}, getLatest:function() {
  var id = this.latestId, request;
  if (id) {
    request = this.requests[id];
  }
  return request || null;
}, clearTimeout:function(request) {
  if (!request) {
    request = this.getLatest();
  }
  if (request) {
    request.clearTimer();
  }
}, onRequestComplete:function(request) {
  delete this.requests[request.id];
}, nativeBinaryPostSupport:function() {
  return Ext.isChrome || Ext.isSafari && Ext.isDefined(window.Uint8Array) || Ext.isGecko && Ext.isDefined(window.Uint8Array);
}}, 1, 0, 0, 0, 0, [['observable', Ext.mixin.Observable]], [Ext.data, 'Connection'], 0);
Ext.cmd.derive('Ext.Ajax', Ext.data.Connection, {singleton:true, autoAbort:false}, 0, 0, 0, 0, 0, 0, [Ext, 'Ajax'], 0);
Ext.cmd.derive('Ext.AnimationQueue', Ext.Base, {singleton:true, constructor:function() {
  var me = this;
  me.queue = [];
  me.taskQueue = [];
  me.runningQueue = [];
  me.idleQueue = [];
  me.isRunning = false;
  me.isIdle = true;
  me.run = me.run.bind(me);
  if (Ext.os.is.iOS) {
    me.watchdogTimer = Ext.interval(me.watch, 500, me);
  }
}, start:function(fn, scope, args) {
  var me = this;
  me.queue.push(arguments);
  if (!me.isRunning) {
    if (me.hasOwnProperty('idleTimer')) {
      Ext.undefer(me.idleTimer);
      delete me.idleTimer;
    }
    if (me.hasOwnProperty('idleQueueTimer')) {
      Ext.undefer(me.idleQueueTimer);
      delete me.idleQueueTimer;
    }
    me.isIdle = false;
    me.isRunning = true;
    me.doStart();
  }
}, clear:function() {
  var me = this;
  Ext.undefer(me.idleTimer);
  Ext.undefer(me.idleQueueTimer);
  Ext.unraf(me.animationFrameId);
  me.idleTimer = me.idleQueueTimer = me.animationFrameId = null;
  me.queue.length = me.taskQueue.length = me.runningQueue.length = me.idleQueue.length = 0;
  me.isRunning = false;
  me.isIdle = true;
}, watch:function() {
  if (this.isRunning && Ext.now() - this.lastRunTime >= 500) {
    this.run();
  }
}, run:function() {
  var me = this, item, element;
  me.animationFrameId = null;
  if (!me.isRunning) {
    return;
  }
  var queue = me.runningQueue, now = Ext.now(), i, ln;
  me.lastRunTime = now;
  me.frameStartTime = now;
  i = me.queue.length;
  while (i--) {
    item = me.queue[i];
    element = item[1] && item[1].getElement && item[1].getElement();
    if (element && element.destroyed) {
      me.queue.splice(i, 1);
    }
  }
  queue.push.apply(queue, me.queue);
  for (i = 0, ln = queue.length; i < ln; i++) {
    me.invoke(queue[i]);
  }
  queue.length = 0;
  if (!me.queue.length) {
    me.stop();
  }
  if (me.isRunning) {
    me.doIterate();
  }
}, doStart:function() {
  if (!this.animationFrameId) {
    this.animationFrameId = Ext.raf(this.run);
  }
  this.lastRunTime = Ext.now();
}, doIterate:function() {
  if (!this.animationFrameId) {
    this.animationFrameId = Ext.raf(this.run);
  }
}, doStop:function() {
  if (this.animationFrameId) {
    Ext.unraf(this.animationFrameId);
  }
  this.animationFrameId = null;
}, stop:function(fn, scope, args) {
  var me = this;
  if (!me.isRunning) {
    return;
  }
  var queue = me.queue, ln = queue.length, i, item;
  for (i = 0; i < ln; i++) {
    item = queue[i];
    if (item[0] === fn && item[1] === scope && item[2] === args) {
      queue.splice(i, 1);
      i--;
      ln--;
    }
  }
  if (ln === 0) {
    me.doStop();
    me.isRunning = false;
    if (me.idleQueue.length && !me.idleTimer) {
      me.idleTimer = Ext.defer(me.whenIdle, 100, me);
    }
  }
}, onIdle:function(fn, scope, args) {
  var me = this, listeners = me.idleQueue, i, ln, listener;
  for (i = 0, ln = listeners.length; i < ln; i++) {
    listener = listeners[i];
    if (fn === listener[0] && scope === listener[1] && args === listener[2]) {
      return;
    }
  }
  listeners.push(arguments);
  if (me.isIdle) {
    me.processIdleQueue();
  } else {
    if (!me.idleTimer) {
      me.idleTimer = Ext.defer(me.whenIdle, 100, me);
    }
  }
}, unIdle:function(fn, scope, args) {
  var me = this, listeners = me.idleQueue, i, ln, listener;
  for (i = 0, ln = listeners.length; i < ln; i++) {
    listener = listeners[i];
    if (fn === listener[0] && scope === listener[1] && args === listener[2]) {
      listeners.splice(i, 1);
      return true;
    }
  }
  if (!listeners.length && me.idleTimer) {
    Ext.undefer(me.idleTimer);
    delete me.idleTimer;
  }
  if (!listeners.length && me.idleQueueTimer) {
    Ext.undefer(me.idleQueueTimer);
    delete me.idleQueueTimer;
  }
  return false;
}, queueTask:function(fn, scope, args) {
  this.taskQueue.push(arguments);
  this.processTaskQueue();
}, dequeueTask:function(fn, scope, args) {
  var listeners = this.taskQueue, i, ln, listener;
  for (i = 0, ln = listeners.length; i < ln; i++) {
    listener = listeners[i];
    if (fn === listener[0] && scope === listener[1] && args === listener[2]) {
      listeners.splice(i, 1);
      i--;
      ln--;
    }
  }
}, invoke:function(listener) {
  var fn = listener[0], scope = listener[1], args = listener[2];
  fn = typeof fn == 'string' ? scope[fn] : fn;
  if (Ext.isArray(args)) {
    fn.apply(scope, args);
  } else {
    fn.call(scope, args);
  }
}, whenIdle:function() {
  delete this.idleTimer;
  this.isIdle = true;
  this.processIdleQueue();
}, processIdleQueue:function() {
  if (!this.hasOwnProperty('idleQueueTimer')) {
    this.idleQueueTimer = Ext.defer(this.processIdleQueueItem, 1, this);
  }
}, processIdleQueueItem:function() {
  delete this.idleQueueTimer;
  if (!this.isIdle) {
    return;
  }
  var listeners = this.idleQueue, listener;
  if (listeners.length > 0) {
    listener = listeners.shift();
    this.invoke(listener);
    this.processIdleQueue();
  }
}, processTaskQueue:function() {
  if (!this.hasOwnProperty('taskQueueTimer')) {
    this.taskQueueTimer = Ext.defer(this.processTaskQueueItem, 15, this);
  }
}, processTaskQueueItem:function() {
  delete this.taskQueueTimer;
  var listeners = this.taskQueue, listener;
  if (listeners.length > 0) {
    listener = listeners.shift();
    this.invoke(listener);
    this.processTaskQueue();
  }
}}, 1, 0, 0, 0, 0, 0, [Ext, 'AnimationQueue'], 0);
Ext.cmd.derive('Ext.mixin.Bufferable', Ext.Mixin, function(Bufferable) {
  return {mixinConfig:{id:'bufferable', before:{destroy:'cancelAllCalls'}, extended:function(baseClass, derivedClass, classBody) {
    var bufferableMethods = classBody.bufferableMethods;
    if (bufferableMethods) {
      delete classBody.bufferableMethods;
      Bufferable.processClass(derivedClass, bufferableMethods);
    }
  }}, afterClassMixedIn:function(targetClass) {
    Bufferable.processClass(targetClass);
  }, privates:{cancelAllCalls:function() {
    var bufferables = this.bufferables, name;
    if (bufferables) {
      for (name in bufferables) {
        bufferables[name].cancel();
        delete bufferables[name];
      }
    }
  }, cancelBufferedCall:function(name, invoke) {
    var bufferables = this.bufferables, timer = bufferables && bufferables[name];
    if (timer) {
      timer[invoke ? 'invoke' : 'cancel']();
    }
    return !!timer;
  }, flushBufferedCall:function(name) {
    return this.cancelBufferedCall(name, true);
  }, initBufferables:function() {
    var me = this, methods = me.hasOwnProperty('bufferableMethods') && me.bufferableMethods, classMethods;
    if (methods) {
      Bufferable._canonicalize(methods);
      classMethods = me.self.prototype.bufferableMethods;
      me.bufferableMethods = Ext.merge(Ext.clone(classMethods), methods);
    }
    return me.bufferables = {};
  }, isCallPending:function(name) {
    var bufferables = this.bufferables, timer = bufferables && bufferables[name];
    return !!timer;
  }, statics:{SINGLE:{single:true}, _canonicalize:function(methods) {
    var t, def, s, name;
    for (name in methods) {
      s = Ext.String.capitalize(name);
      def = methods[name];
      t = typeof def;
      if (t === 'number' || t === 'string') {
        methods[name] = def = {delay:def};
      }
      if (typeof(t = def.delay) === 'string') {
        def[t] = true;
        delete def.delay;
      }
      def.capitalized = s;
      def.name = name;
      if (!def.fn) {
        def.fn = 'do' + s;
      }
      if (!def.flag) {
        def.flag = 'is' + s + 'Pending';
      }
    }
  }, _canceller:function() {
    var timer = this, id = timer.id;
    if (id) {
      if (timer.delay) {
        Ext.undefer(id);
      } else {
        if (timer.asap) {
          Ext.unasap(id);
        } else {
          if (timer.idle) {
            Ext.un('idle', id, null, Bufferable.SINGLE);
          } else {
            if (timer.raf) {
              Ext.unraf(id);
            }
          }
        }
      }
      timer.id = null;
    }
    timer.args = null;
    timer.target[timer.flag] = false;
  }, _invoker:function() {
    var timer = this, args = timer.args || Ext.emptyArray, target = timer.target;
    timer.cancel();
    target[timer.fn].apply(target, args);
  }, delayCall:function(target, def, args) {
    var bufferables = target.bufferables || target.initBufferables(), name = def.name, timer = bufferables[name] || (bufferables[name] = Ext.apply({args:null, cancel:Bufferable._canceller, id:null, target:target, invoke:Bufferable._invoker}, def)), delay = def.delay, exec = function() {
      if (timer.id) {
        timer.id = null;
        timer.invoke();
      }
    };
    if (timer.id) {
      timer.cancel();
    }
    timer.args = args;
    target[timer.flag] = true;
    if (delay) {
      timer.id = Ext.defer(exec, delay);
    } else {
      if (def.asap) {
        timer.id = Ext.asap(exec);
      } else {
        if (def.idle) {
          timer.id = exec;
          Ext.on('idle', exec, null, Bufferable.SINGLE);
        } else {
          if (def.raf) {
            timer.id = Ext.raf(exec);
          } else {
            timer.invoke();
          }
        }
      }
    }
  }, processClass:function(cls, bufferableMethods) {
    var proto = cls.prototype, inherited = proto.bufferableMethods, def, name;
    if (bufferableMethods) {
      Bufferable._canonicalize(bufferableMethods);
      if (inherited) {
        inherited = Ext.merge(Ext.clone(inherited), bufferableMethods);
      }
      proto.bufferableMethods = inherited || bufferableMethods;
    } else {
      bufferableMethods = inherited;
      Bufferable._canonicalize(bufferableMethods);
      proto.bufferables = null;
    }
    if (bufferableMethods) {
      for (name in bufferableMethods) {
        if (!proto[name]) {
          def = bufferableMethods[name];
          Bufferable.processMethod(proto, def, Array.prototype.slice);
        }
      }
    }
  }, processMethod:function(proto, def, slice) {
    var name = def.name, cap = def.capitalized;
    proto[name] = function() {
      return Bufferable.delayCall(this, def, slice.call(arguments));
    };
    proto['cancel' + cap] = function() {
      return this.cancelBufferedCall(name);
    };
    proto['flush' + cap] = function() {
      return this.flushBufferedCall(name);
    };
  }}}};
}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Bufferable'], 0);
Ext.cmd.derive('Ext.ComponentManager', Ext.Base, {alternateClassName:'Ext.ComponentMgr', singleton:true, count:0, referencesDirty:true, referenceRepairs:0, typeName:'xtype', bufferableMethods:{handleDocumentMouseDown:'asap'}, constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  me.all = {};
  me.byInstanceId = {};
  me.holders = {};
  me.names = {};
  me.references = {};
  me.onAvailableCallbacks = {};
}, create:function(config, defaultType) {
  if (typeof config === 'string') {
    return Ext.widget(config);
  }
  if (config.isComponent) {
    return config;
  }
  if ('xclass' in config) {
    return Ext.create(config.xclass, config);
  }
  return Ext.widget(config.xtype || defaultType, config);
}, get:function(id) {
  return this.all[id];
}, register:function(component) {
  var me = this, id = component.getId(), onAvailableCallbacks = me.onAvailableCallbacks;
  me.all[id] = component;
  me.byInstanceId[component.$iid] = component;
  if (component.reference) {
    me.references[id] = component;
  }
  if (component.name && component.nameable) {
    me.names[id] = component;
  }
  if (component.nameHolder || component.referenceHolder) {
    me.holders[id] = component;
  }
  ++me.count;
  if (!me.hasFocusListener) {
    me.installFocusListener();
  }
  onAvailableCallbacks = onAvailableCallbacks && onAvailableCallbacks[id];
  if (onAvailableCallbacks && onAvailableCallbacks.length) {
    me.notifyAvailable(component);
  }
}, unregister:function(component) {
  var me = this, all = me.all, byInstanceId = me.byInstanceId, holders = me.holders, references = me.references, names = me.names, id = component.getId();
  if (id in holders) {
    holders[id] = null;
    delete holders[id];
  }
  if (id in names) {
    names[id] = null;
    delete names[id];
  }
  if (id in references) {
    references[id] = null;
    delete references[id];
  }
  all[id] = null;
  delete all[id];
  id = component.$iid;
  byInstanceId[id] = null;
  delete byInstanceId[id];
  --me.count;
}, markReferencesDirty:function() {
  var me = this, holders = me.holders, key;
  if (!me.referencesDirty) {
    for (key in holders) {
      holders[key].refs = holders[key].nameRefs = null;
    }
    me.referencesDirty = true;
  }
}, fixReferences:function() {
  var me = this, references = me.references, names = me.names, key;
  if (me.referencesDirty) {
    ++me.referenceRepairs;
    for (key in references) {
      references[key]._fixReference();
    }
    for (key in names) {
      names[key]._fixName();
    }
    me.referencesDirty = false;
  }
}, onAvailable:function(id, fn, scope) {
  var me = this, callbacks = me.onAvailableCallbacks, all = me.all, item;
  if (id in all) {
    item = all[id];
    fn.call(scope || item, item);
  } else {
    if (id) {
      if (!Ext.isArray(callbacks[id])) {
        callbacks[id] = [];
      }
      callbacks[id].push(function(item) {
        fn.call(scope || item, item);
      });
    }
  }
}, notifyAvailable:function(item) {
  var callbacks = this.onAvailableCallbacks[item && item.getId()] || [];
  while (callbacks.length) {
    callbacks.shift()(item);
  }
}, each:function(fn, scope) {
  Ext.Object.each(this.all, fn, scope);
}, getCount:function() {
  return this.count;
}, getAll:function() {
  return Ext.Object.getValues(this.all);
}, getActiveComponent:function() {
  return Ext.Component.from(Ext.dom.Element.getActiveElement());
}, onGlobalFocus:function(e) {
  var me = this, event = e.event, toComponent = event.toComponent = e.toComponent = Ext.Component.from(e.toElement), fromComponent = event.fromComponent = e.fromComponent = Ext.Component.from(e.fromElement), commonAncestor = me.getCommonAncestor(fromComponent, toComponent), targetComponent;
  if (toComponent !== fromComponent) {
    if (fromComponent && !fromComponent.destroyed && !fromComponent.isDestructing()) {
      if (fromComponent.handleBlurEvent) {
        fromComponent.handleBlurEvent(e);
      }
      for (targetComponent = fromComponent; targetComponent && targetComponent !== commonAncestor; targetComponent = targetComponent.getRefOwner()) {
        if (!(targetComponent.destroyed || targetComponent.destroying)) {
          e.type = 'focusleave';
          targetComponent.onFocusLeave(event);
        }
      }
    }
    if (toComponent && !toComponent.destroyed && !toComponent.isDestructing()) {
      if (toComponent.handleFocusEvent) {
        toComponent.handleFocusEvent(e);
      }
      for (targetComponent = toComponent; targetComponent && targetComponent !== commonAncestor; targetComponent = targetComponent.getRefOwner()) {
        e.type = 'focusenter';
        targetComponent.onFocusEnter(event);
      }
    }
  }
  for (targetComponent = commonAncestor; targetComponent; targetComponent = targetComponent.getRefOwner()) {
    if (!(targetComponent.destroying || targetComponent.destroyed)) {
      targetComponent.onFocusMove(e);
    }
  }
}, getCommonAncestor:function(compA, compB) {
  if (compA === compB) {
    return compA;
  }
  while (compA && !(compA.isAncestor(compB) || compA === compB)) {
    compA = compA.getRefOwner();
  }
  return compA;
}, privates:{doHandleDocumentMouseDown:function(e) {
  var floatedSelector = Ext.Widget.prototype.floatedSelector, targetFloated;
  if (floatedSelector) {
    targetFloated = Ext.Component.from(e.getTarget(floatedSelector, Ext.getBody()));
    if (targetFloated) {
      targetFloated.toFront(true);
    }
  }
}, installFocusListener:function() {
  var me = this;
  Ext.on('focus', me.onGlobalFocus, me);
  me.hasFocusListener = true;
}, clearAll:function() {
  this.all = {};
  this.names = {};
  this.references = {};
  this.onAvailableCallbacks = {};
}, from:function(el, limit, selector) {
  if (el && el.isEvent) {
    el = el.target;
  }
  var target = Ext.getDom(el), cache = this.all, depth = 0, topmost, cmpId, cmp;
  if (typeof limit !== 'number') {
    topmost = Ext.getDom(limit);
    limit = Number.MAX_VALUE;
  }
  while (target && target.nodeType === 1 && depth < limit && target !== topmost) {
    cmpId = target.getAttribute('data-componentid') || target.id;
    if (cmpId) {
      cmp = cache[cmpId];
      if (cmp && (!selector || Ext.ComponentQuery.is(cmp, selector))) {
        return cmp;
      }
      depth++;
    }
    target = target.parentNode;
  }
  return null;
}}}, 1, 0, 0, 0, 0, [[Ext.mixin.Bufferable.prototype.mixinId || Ext.mixin.Bufferable.$className, Ext.mixin.Bufferable]], [Ext, 'ComponentManager', Ext, 'ComponentMgr'], function() {
  var ComponentManager = Ext.ComponentManager;
  ComponentManager.fromElement = ComponentManager.from;
  Ext.getCmp = function(id) {
    return ComponentManager.get(id);
  };
  Ext.iidToCmp = function(iid) {
    return ComponentManager.byInstanceId[iid] || null;
  };
  Ext.doEv = function(node, e) {
    var cmp, method, event;
    cmp = Ext.Component.from(e.target);
    if (cmp && !cmp.destroying && !cmp.destroyed && cmp.getEventHandlers) {
      method = cmp.getEventHandlers()[e.type];
      if (method && cmp[method]) {
        event = new Ext.event.Event(e);
        return cmp[method](event);
      }
    }
    return true;
  };
});
Ext.ns('Ext.util').Operators = {'\x3d':function(a, v) {
  return a == v;
}, '!\x3d':function(a, v) {
  return a != v;
}, '^\x3d':function(a, v) {
  return a && a.substr(0, v.length) == v;
}, '$\x3d':function(a, v) {
  return a && a.substr(a.length - v.length) == v;
}, '*\x3d':function(a, v) {
  return a && a.indexOf(v) !== -1;
}, '%\x3d':function(a, v) {
  return a % v === 0;
}, '|\x3d':function(a, v) {
  return a && (a == v || a.substr(0, v.length + 1) == v + '-');
}, '~\x3d':function(a, v) {
  return a && (' ' + a + ' ').indexOf(' ' + v + ' ') != -1;
}};
Ext.cmd.derive('Ext.util.LruCache', Ext.util.HashMap, {config:{maxSize:null}, add:function(key, newValue) {
  var me = this, entry, last;
  me.removeAtKey(key);
  last = me.last;
  entry = {prev:last, next:null, key:key, value:newValue};
  if (last) {
    last.next = entry;
  } else {
    me.first = entry;
  }
  me.last = entry;
  Ext.util.HashMap.prototype.add.call(this, key, entry);
  me.prune();
  return newValue;
}, insertBefore:function(key, newValue, sibling) {
  var me = this, existingKey, entry;
  if (sibling = this.map[this.findKey(sibling)]) {
    existingKey = me.findKey(newValue);
    if (existingKey) {
      me.unlinkEntry(entry = me.map[existingKey]);
    } else {
      entry = {prev:sibling.prev, next:sibling, key:key, value:newValue};
    }
    if (sibling.prev) {
      entry.prev.next = entry;
    } else {
      me.first = entry;
    }
    entry.next = sibling;
    sibling.prev = entry;
    me.prune();
    return newValue;
  } else {
    return me.add(key, newValue);
  }
}, get:function(key) {
  var entry = this.map[key];
  if (entry) {
    if (entry.next) {
      this.moveToEnd(entry);
    }
    return entry.value;
  }
}, removeAtKey:function(key) {
  this.unlinkEntry(this.map[key]);
  return Ext.util.HashMap.prototype.removeAtKey.apply(this, arguments);
}, clear:function(initial) {
  this.first = this.last = null;
  return Ext.util.HashMap.prototype.clear.call(this, initial);
}, unlinkEntry:function(entry) {
  if (entry) {
    if (entry.next) {
      entry.next.prev = entry.prev;
    } else {
      this.last = entry.prev;
    }
    if (entry.prev) {
      entry.prev.next = entry.next;
    } else {
      this.first = entry.next;
    }
    entry.prev = entry.next = null;
  }
}, moveToEnd:function(entry) {
  this.unlinkEntry(entry);
  if (entry.prev = this.last) {
    this.last.next = entry;
  } else {
    this.first = entry;
  }
  this.last = entry;
}, getArray:function(isKey) {
  var arr = [], entry = this.first;
  while (entry) {
    arr.push(isKey ? entry.key : entry.value);
    entry = entry.next;
  }
  return arr;
}, each:function(fn, scope, reverse) {
  var me = this, entry = reverse ? me.last : me.first, length = me.length;
  scope = scope || me;
  while (entry) {
    if (fn.call(scope, entry.key, entry.value, length) === false) {
      break;
    }
    entry = reverse ? entry.prev : entry.next;
  }
  return me;
}, findKey:function(value) {
  var key, map = this.map;
  for (key in map) {
    if (map.hasOwnProperty(key) && map[key].value === value) {
      return key;
    }
  }
  return undefined;
}, clone:function() {
  var newCache = new this.self(this.initialConfig), map = this.map, key;
  newCache.suspendEvents();
  for (key in map) {
    if (map.hasOwnProperty(key)) {
      newCache.add(key, map[key].value);
    }
  }
  newCache.resumeEvents();
  return newCache;
}, prune:function() {
  var me = this, max = me.getMaxSize(), purgeCount = max ? me.length - max : 0;
  if (purgeCount > 0) {
    for (; me.first && purgeCount; purgeCount--) {
      me.removeAtKey(me.first.key);
    }
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'LruCache'], 0);
Ext.cmd.derive('Ext.ComponentQuery', Ext.Base, {singleton:true}, 0, 0, 0, 0, 0, 0, [Ext, 'ComponentQuery'], function() {
  var cq = this, queryOperators = Ext.util.Operators, nthRe = /(\d*)n\+?(\d*)/, nthRe2 = /\D/, stripLeadingSpaceRe = /^(\s)+/, unescapeRe = /\\(.)/g, regexCache = new Ext.util.LruCache({maxSize:100}), filterFnPattern = ['var r \x3d [],', 'i \x3d 0,', 'it \x3d items,', 'l \x3d it.length,', 'c;', 'for (; i \x3c l; i++) {', 'c \x3d it[i];', 'if (c.{0}) {', 'r.push(c);', '}', '}', 'return r;'].join(''), filterItems = function(items, operation) {
    return operation.method.apply(this, [items].concat(operation.args));
  }, getItems = function(items, mode) {
    var result = [], i = 0, length = items.length, candidate, deep = mode !== '\x3e';
    for (; i < length; i++) {
      candidate = items[i];
      if (candidate.getRefItems) {
        result = result.concat(candidate.getRefItems(deep));
      }
    }
    return result;
  }, getAncestors = function(items) {
    var result = [], i = 0, length = items.length, candidate;
    for (; i < length; i++) {
      candidate = items[i];
      while (!!(candidate = candidate.getRefOwner())) {
        result.push(candidate);
      }
    }
    return result;
  }, filterByXType = function(items, xtype, shallow) {
    if (xtype === '*') {
      return items.slice();
    } else {
      var result = [], i = 0, length = items.length, candidate;
      for (; i < length; i++) {
        candidate = items[i];
        if (!candidate.destroyed && candidate.isXType(xtype, shallow)) {
          result.push(candidate);
        }
      }
      return result;
    }
  }, filterByAttribute = function(items, property, operator, compareTo) {
    var result = [], i = 0, length = items.length, mustBeOwnProperty, presenceOnly, candidate, propValue, j, propLen, config;
    if (property.charAt(0) === '@') {
      mustBeOwnProperty = true;
      property = property.substr(1);
    }
    if (property.charAt(0) === '?') {
      mustBeOwnProperty = true;
      presenceOnly = true;
      property = property.substr(1);
    }
    for (; i < length; i++) {
      candidate = items[i];
      config = candidate.self && candidate.self.getConfigurator && candidate.self.$config.configs[property];
      if (config) {
        propValue = candidate[config.names.get]();
      } else {
        if (mustBeOwnProperty && !candidate.hasOwnProperty(property)) {
          continue;
        } else {
          propValue = candidate[property];
        }
      }
      if (presenceOnly) {
        result.push(candidate);
      } else {
        if (operator === '~\x3d') {
          if (propValue) {
            if (!Ext.isArray(propValue)) {
              propValue = propValue.split(' ');
            }
            for (j = 0, propLen = propValue.length; j < propLen; j++) {
              if (queryOperators[operator](Ext.coerce(propValue[j], compareTo), compareTo)) {
                result.push(candidate);
                break;
              }
            }
          }
        } else {
          if (operator === '/\x3d') {
            if (propValue != null && compareTo.test(propValue)) {
              result.push(candidate);
            }
          } else {
            if (!compareTo ? !!propValue : queryOperators[operator](Ext.coerce(propValue, compareTo), compareTo)) {
              result.push(candidate);
            }
          }
        }
      }
    }
    return result;
  }, filterById = function(items, id, idOnly) {
    var result = [], i = 0, length = items.length, candidate, check;
    for (; i < length; i++) {
      candidate = items[i];
      check = idOnly ? candidate.id : candidate.getItemId();
      if (check === id) {
        result.push(candidate);
      }
    }
    return result;
  }, filterByPseudo = function(items, name, value) {
    return cq.pseudos[name](items, value);
  }, modeRe = /^(\s?([>\^])\s?|\s|$)/, tokenRe = /^(#)?((?:\\\.|[\w\-])+|\*)(?:\((true|false)\))?/, matchers = [{re:/^\.((?:\\\.|[\w\-])+)(?:\((true|false)\))?/, method:filterByXType, argTransform:function(args) {
    if (args[1] !== undefined) {
      args[1] = args[1].replace(unescapeRe, '$1');
    }
    return args.slice(1);
  }}, {re:/^(?:\[((?:[@?$])?[\w\-]*)\s*(?:([\^$*~%!\/]?=)\s*(['"])?((?:\\\]|.)*?)\3)?(?!\\)\])/, method:filterByAttribute, argTransform:function(args) {
    var selector = args[0], property = args[1], operator = args[2], compareTo = args[4], compareRe;
    if (compareTo !== undefined) {
      compareTo = compareTo.replace(unescapeRe, '$1');
    }
    if (operator === '/\x3d') {
      compareRe = regexCache.get(compareTo);
      if (compareRe) {
        compareTo = compareRe;
      } else {
        compareTo = regexCache.add(compareTo, new RegExp(compareTo));
      }
    }
    return [property, operator, compareTo];
  }}, {re:/^#((?:\\\.|[\w\-])+)/, method:filterById}, {re:/^\:([\w\-]+)(?:\(((?:\{[^\}]+\})|(?:(?!\{)[^\s>\/]*?(?!\})))\))?/, method:filterByPseudo, argTransform:function(args) {
    if (args[2] !== undefined) {
      args[2] = args[2].replace(unescapeRe, '$1');
    }
    return args.slice(1);
  }}, {re:/^(?:\{([^\}]+)\})/, method:filterFnPattern}];
  cq.Query = Ext.extend(Object, {constructor:function(cfg) {
    cfg = cfg || {};
    Ext.apply(this, cfg);
  }, execute:function(root) {
    var operations = this.operations, result = [], op, i, len;
    for (i = 0, len = operations.length; i < len; i++) {
      op = operations[i];
      result = result.concat(this._execute(root, op));
    }
    return result;
  }, _execute:function(root, operations) {
    var i = 0, length = operations.length, operation, workingItems;
    if (!root) {
      workingItems = Ext.ComponentManager.getAll();
    } else {
      if (Ext.isIterable(root)) {
        workingItems = root;
      } else {
        if (root.isMixedCollection) {
          workingItems = root.items;
        }
      }
    }
    for (; i < length; i++) {
      operation = operations[i];
      if (operation.mode === '^') {
        workingItems = getAncestors(workingItems || [root]);
      } else {
        if (operation.mode) {
          workingItems = getItems(workingItems || [root], operation.mode);
        } else {
          workingItems = filterItems(workingItems || getItems([root]), operation);
        }
      }
      if (i === length - 1) {
        return workingItems;
      }
    }
    return [];
  }, is:function(component, root) {
    var operations = this.operations, result = false, len = operations.length, op, i;
    if (len === 0) {
      return true;
    }
    for (i = 0; i < len; i++) {
      op = operations[i];
      result = this._is(component, root, op);
      if (result) {
        return result;
      }
    }
    return false;
  }, _is:function(component, root, operations) {
    var len = operations.length, active = [component], operation, i, j, mode, items, item;
    for (i = len - 1; i >= 0; --i) {
      operation = operations[i];
      mode = operation.mode;
      if (mode) {
        if (mode === '^') {
          active = getItems(active, ' ');
        } else {
          if (mode === '\x3e') {
            items = [];
            for (j = 0, len = active.length; j < len; ++j) {
              item = active[j].getRefOwner();
              if (item) {
                items.push(item);
              }
            }
            active = items;
          } else {
            active = getAncestors(active);
          }
        }
      } else {
        active = filterItems(active, operation);
      }
      if (active.length === 0) {
        return false;
      }
    }
    if (root) {
      if (!mode) {
        active = getAncestors(active);
      }
      if (active.length > 0) {
        active = filterItems(active, {method:filterById, args:[root.id, true]});
      }
      if (active.length === 0) {
        return false;
      }
    }
    return true;
  }, getMatches:function(components, operations) {
    var len = operations.length, i;
    for (i = 0; i < len; ++i) {
      components = filterItems(components, operations[i]);
      if (components.length === 0) {
        break;
      }
    }
    return components;
  }, isMultiMatch:function() {
    return this.operations.length > 1;
  }});
  Ext.apply(cq, {cache:new Ext.util.LruCache({maxSize:100}), pseudos:{not:function(components, selector) {
    var i = 0, length = components.length, results = [], index = -1, component;
    for (; i < length; ++i) {
      component = components[i];
      if (!cq.is(component, selector)) {
        results[++index] = component;
      }
    }
    return results;
  }, first:function(components) {
    var ret = [];
    if (components.length > 0) {
      ret.push(components[0]);
    }
    return ret;
  }, last:function(components) {
    var len = components.length, ret = [];
    if (len > 0) {
      ret.push(components[len - 1]);
    }
    return ret;
  }, focusable:function(cmps) {
    var len = cmps.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = cmps[i];
      if (c.isFocusable && c.isFocusable()) {
        results.push(c);
      }
    }
    return results;
  }, canfocus:function(cmps, value) {
    var len = cmps.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = cmps[i];
      if (c.canFocus && c.canFocus(false, value)) {
        results.push(c);
      }
    }
    return results;
  }, 'nth-child':function(c, a) {
    var result = [], m = nthRe.exec(a === 'even' && '2n' || a === 'odd' && '2n+1' || !nthRe2.test(a) && 'n+' + a || a), f = (m[1] || 1) - 0, len = m[2] - 0, i, n, nodeIndex;
    for (i = 0; n = c[i]; i++) {
      nodeIndex = i + 1;
      if (f === 1) {
        if (len === 0 || nodeIndex === len) {
          result.push(n);
        }
      } else {
        if ((nodeIndex + len) % f === 0) {
          result.push(n);
        }
      }
    }
    return result;
  }, scrollable:function(cmps) {
    var len = cmps.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = cmps[i];
      if (c.scrollable || c._scrollable) {
        results.push(c);
      }
    }
    return results;
  }, visible:function(cmps, deep) {
    deep = deep === 'true';
    var len = cmps.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = cmps[i];
      if (c.isVisible(deep)) {
        results.push(c);
      }
    }
    return results;
  }}, query:function(selector, root) {
    if (!selector) {
      return Ext.ComponentManager.getAll();
    }
    var results = [], noDupResults = [], dupMatcher = {}, query = cq.cache.get(selector), resultsLn, cmp, i;
    if (!query) {
      query = cq.cache.add(selector, cq.parse(selector));
    }
    results = query.execute(root);
    if (query.isMultiMatch()) {
      resultsLn = results.length;
      for (i = 0; i < resultsLn; i++) {
        cmp = results[i];
        if (!dupMatcher[cmp.id]) {
          noDupResults.push(cmp);
          dupMatcher[cmp.id] = true;
        }
      }
      results = noDupResults;
    }
    return results;
  }, visitPreOrder:function(selector, root, fn, scope, extraArgs) {
    cq._visit(true, selector, root, fn, scope, extraArgs);
  }, visitPostOrder:function(selector, root, fn, scope, extraArgs) {
    cq._visit(false, selector, root, fn, scope, extraArgs);
  }, _visit:function(preOrder, selector, root, fn, scope, extraArgs) {
    var query = cq.cache.get(selector), callArgs = [root], children, len = 0, i, rootMatch;
    if (!query) {
      query = cq.cache.add(selector, cq.parse(selector));
    }
    rootMatch = query.is(root);
    if (root.getRefItems) {
      children = root.getRefItems();
      len = children.length;
    }
    if (extraArgs) {
      Ext.Array.push(callArgs, extraArgs);
    }
    if (preOrder) {
      if (rootMatch) {
        if (fn.apply(scope || root, callArgs) === false) {
          return false;
        }
      }
    }
    for (i = 0; i < len; i++) {
      if (cq._visit.call(cq, preOrder, selector, children[i], fn, scope, extraArgs) === false) {
        return false;
      }
    }
    if (!preOrder) {
      if (rootMatch) {
        if (fn.apply(scope || root, callArgs) === false) {
          return false;
        }
      }
    }
  }, is:function(component, selector, root) {
    if (!selector) {
      return true;
    }
    if (typeof selector === 'function') {
      return selector(component);
    } else {
      var query = cq.cache.get(selector);
      if (!query) {
        query = cq.cache.add(selector, cq.parse(selector));
      }
      return query.is(component, root);
    }
  }, parse:function(selector) {
    var operations = [], selectors, sel, i, len;
    selectors = Ext.splitAndUnescape(selector, ',');
    for (i = 0, len = selectors.length; i < len; i++) {
      sel = Ext.String.trim(selectors[i]);
      operations.push(cq._parse(sel));
    }
    return new cq.Query({operations:operations});
  }, _parse:function(selector) {
    var operations = [], trim = Ext.String.trim, length = matchers.length, lastSelector, tokenMatch, token, matchedChar, modeMatch, selectorMatch, transform, i, matcher, method, args;
    while (selector && lastSelector !== selector) {
      lastSelector = selector;
      tokenMatch = selector.match(tokenRe);
      if (tokenMatch) {
        matchedChar = tokenMatch[1];
        token = trim(tokenMatch[2]).replace(unescapeRe, '$1');
        if (matchedChar === '#') {
          operations.push({method:filterById, args:[token]});
        } else {
          operations.push({method:filterByXType, args:[token, Boolean(tokenMatch[3])]});
        }
        selector = selector.replace(tokenMatch[0], '').replace(stripLeadingSpaceRe, '$1');
      }
      while (!(modeMatch = selector.match(modeRe))) {
        for (i = 0; selector && i < length; i++) {
          matcher = matchers[i];
          selectorMatch = selector.match(matcher.re);
          method = matcher.method;
          transform = matcher.argTransform;
          if (selectorMatch) {
            if (transform) {
              args = transform(selectorMatch);
            } else {
              args = selectorMatch.slice(1);
            }
            operations.push({method:Ext.isString(matcher.method) ? Ext.functionFactory('items', Ext.String.format.apply(Ext.String, [method].concat(selectorMatch.slice(1)))) : matcher.method, args:args});
            selector = selector.replace(selectorMatch[0], '').replace(stripLeadingSpaceRe, '$1');
            break;
          }
          if (i === length - 1) {
            Ext.raise('Invalid ComponentQuery selector: "' + arguments[0] + '"');
          }
        }
      }
      if (modeMatch[1]) {
        operations.push({mode:modeMatch[2] || modeMatch[1]});
        selector = selector.replace(modeMatch[0], '').replace(stripLeadingSpaceRe, '');
      }
    }
    return operations;
  }});
  Ext.all = function() {
    return cq.query.apply(cq, arguments);
  };
  Ext.first = function() {
    var matches = cq.query.apply(cq, arguments);
    return matches && matches[0] || null;
  };
});
Ext.cmd.derive('Ext.Evented', Ext.Base, {alternateClassName:'Ext.EventedBase', initialized:false, constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
  this.initialized = true;
}, onClassExtended:function(cls, data) {
  if (!data.hasOwnProperty('eventedConfig')) {
    return;
  }
  var config = data.config, eventedConfig = data.eventedConfig, name, cfg;
  if (config) {
    Ext.applyIf(config, eventedConfig);
  } else {
    cls.addConfig(eventedConfig);
  }
  for (name in eventedConfig) {
    if (eventedConfig.hasOwnProperty(name)) {
      cfg = Ext.Config.get(name);
      data[cfg.names.set] = cfg.eventedSetter || cfg.getEventedSetter();
    }
  }
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext, 'Evented', Ext, 'EventedBase'], 0);
Ext.cmd.derive('Ext.util.Positionable', Ext.Base, {mixinId:'positionable', _positionTopLeft:['position', 'top', 'left'], clippedCls:'x-clipped', afterSetPosition:Ext.emptyFn, adjustForConstraints:function(xy, parent) {
  var vector = this.getConstrainVector(parent, xy);
  if (vector) {
    xy[0] += vector[0];
    xy[1] += vector[1];
  }
  return xy;
}, alignTo:function(element, position, offsets, animate) {
  var me = this, el = me.el;
  return me.setXY(me.getAlignToXY(element, position, offsets), el.anim && !!animate ? el.anim(animate) : false);
}, calculateAnchorXY:function(anchor, extraX, extraY, size) {
  var region = this.getRegion();
  region.setPosition(0, 0);
  region.translateBy(extraX || 0, extraY || 0);
  if (size) {
    region.setWidth(size.width);
    region.setHeight(size.height);
  }
  return region.getAnchorPoint(anchor);
}, convertPositionSpec:function(posSpec) {
  return Ext.util.Region.getAlignInfo(posSpec);
}, getAlignToXY:function(alignToEl, position, offsets) {
  var newRegion = this.getAlignToRegion(alignToEl, position, offsets);
  return [newRegion.x, newRegion.y];
}, getAlignToRegion:function(alignToEl, posSpec, offset, minHeight) {
  var me = this, inside, newRegion, bodyScroll;
  alignToEl = Ext.fly(alignToEl.el || alignToEl);
  if (!alignToEl || !alignToEl.dom) {
  }
  posSpec = me.convertPositionSpec(posSpec);
  if (posSpec.constrain) {
    if (posSpec.constrain === '!') {
      inside = alignToEl;
    } else {
      inside = me.constrainTo || me.container || me.el.parent();
    }
    inside = Ext.fly(inside.el || inside).getConstrainRegion();
  }
  if (alignToEl === Ext.getBody()) {
    bodyScroll = alignToEl.getScroll();
    offset = [bodyScroll.left, bodyScroll.top];
  }
  newRegion = me.getRegion().alignTo({target:alignToEl.getRegion(), inside:inside, minHeight:minHeight, offset:offset, align:posSpec, axisLock:true});
  return newRegion;
}, getAnchorXY:function(anchor, local, size) {
  var me = this, region = me.getRegion(), el = me.el, isViewport = el.dom.nodeName === 'BODY' || el.dom.nodeType === 9, scroll = el.getScroll();
  if (local) {
    region.setPosition(0, 0);
  } else {
    if (isViewport) {
      region.setPosition(scroll.left, scroll.top);
    }
  }
  if (size) {
    region.setWidth(size.width);
    region.setHeight(size.height);
  }
  return region.getAnchorPoint(anchor);
}, getBox:function(contentBox, local) {
  var me = this, xy = local ? me.getLocalXY() : me.getXY(), x = xy[0], y = xy[1], w, h, borderPadding, beforeX, beforeY;
  if (me.el.dom.nodeName === 'BODY' || me.el.dom.nodeType === 9) {
    w = Ext.Element.getViewportWidth();
    h = Ext.Element.getViewportHeight();
  } else {
    w = me.getWidth();
    h = me.getHeight();
  }
  if (contentBox) {
    borderPadding = me.getBorderPadding();
    beforeX = borderPadding.beforeX;
    beforeY = borderPadding.beforeY;
    x += beforeX;
    y += beforeY;
    w -= beforeX + borderPadding.afterX;
    h -= beforeY + borderPadding.afterY;
  }
  return {x:x, left:x, 0:x, y:y, top:y, 1:y, width:w, height:h, right:x + w, bottom:y + h};
}, calculateConstrainedPosition:function(constrainTo, proposedPosition, local, proposedSize) {
  var me = this, vector, fp = me.floatParent, parentNode = fp ? fp.getTargetEl() : null, parentOffset, borderPadding, proposedConstrainPosition, xy = false;
  if (local && fp) {
    parentOffset = parentNode.getXY();
    borderPadding = parentNode.getBorderPadding();
    parentOffset[0] += borderPadding.beforeX;
    parentOffset[1] += borderPadding.beforeY;
    if (proposedPosition) {
      proposedConstrainPosition = [proposedPosition[0] + parentOffset[0], proposedPosition[1] + parentOffset[1]];
    }
  } else {
    proposedConstrainPosition = proposedPosition;
  }
  constrainTo = constrainTo || me.constrainTo || parentNode || me.container || me.el.parent();
  if (local && proposedConstrainPosition) {
    proposedConstrainPosition = me.reverseTranslateXY(proposedConstrainPosition);
  }
  vector = (me.constrainHeader && me.header.rendered ? me.header : me).getConstrainVector(constrainTo, proposedConstrainPosition, proposedSize);
  if (vector) {
    xy = proposedPosition || me.getPosition(local);
    xy[0] += vector[0];
    xy[1] += vector[1];
  }
  return xy;
}, getConstrainRegion:function() {
  var me = this, el = me.el, isBody = el.dom.nodeName === 'BODY', dom = el.dom, borders = el.getBorders(), pos = el.getXY(), left = pos[0] + borders.beforeX, top = pos[1] + borders.beforeY, scroll, width, height;
  if (isBody) {
    scroll = el.getScroll();
    left = scroll.left;
    top = scroll.top;
    width = Ext.Element.getViewportWidth();
    height = Ext.Element.getViewportHeight();
  } else {
    width = dom.clientWidth;
    height = dom.clientHeight;
  }
  return new Ext.util.Region(top, left + width, top + height, left);
}, getConstrainVector:function(constrainTo, proposedPosition, proposedSize) {
  var me = this, thisRegion = me.getRegion(), vector = [0, 0], shadowSize = me.shadow && me.constrainShadow && !me.shadowDisabled ? me.el.shadow.getShadowSize() : undefined, overflowed = false, constraintInsets = me.constraintInsets;
  if (!(constrainTo instanceof Ext.util.Region)) {
    constrainTo = Ext.get(constrainTo.el || constrainTo);
    constrainTo = constrainTo.getConstrainRegion();
  }
  if (constraintInsets) {
    constraintInsets = Ext.isObject(constraintInsets) ? constraintInsets : Ext.Element.parseBox(constraintInsets);
    constrainTo.adjust(constraintInsets.top, constraintInsets.right, constraintInsets.bottom, constraintInsets.left);
  }
  if (proposedPosition) {
    thisRegion.translateBy(proposedPosition[0] - thisRegion.x, proposedPosition[1] - thisRegion.y);
  }
  if (proposedSize) {
    thisRegion.right = thisRegion.left + proposedSize[0];
    thisRegion.bottom = thisRegion.top + proposedSize[1];
  }
  if (shadowSize) {
    constrainTo.adjust(shadowSize[0], -shadowSize[1], -shadowSize[2], shadowSize[3]);
  }
  if (thisRegion.right > constrainTo.right) {
    overflowed = true;
    vector[0] = constrainTo.right - thisRegion.right;
  }
  if (thisRegion.left + vector[0] < constrainTo.left) {
    overflowed = true;
    vector[0] = constrainTo.left - thisRegion.left;
  }
  if (thisRegion.bottom > constrainTo.bottom) {
    overflowed = true;
    vector[1] = constrainTo.bottom - thisRegion.bottom;
  }
  if (thisRegion.top + vector[1] < constrainTo.top) {
    overflowed = true;
    vector[1] = constrainTo.top - thisRegion.top;
  }
  return overflowed ? vector : false;
}, getOffsetsTo:function(offsetsTo) {
  var o = this.getXY(), e = offsetsTo.isRegion ? [offsetsTo.x, offsetsTo.y] : Ext.fly(offsetsTo.el || offsetsTo).getXY();
  return [o[0] - e[0], o[1] - e[1]];
}, getRegion:function(contentBox, local) {
  var box = this.getBox(contentBox, local);
  return new Ext.util.Region(box.top, box.right, box.bottom, box.left);
}, getClientRegion:function() {
  var me = this, el = me.el, dom = el.dom, viewContentBox = me.getBox(true), scrollbarHeight = dom.offsetHeight > dom.clientHeight, scrollbarWidth = dom.offsetWidth > dom.clientWidth, padding, scrollSize, isRTL;
  if (scrollbarHeight || scrollbarWidth) {
    scrollSize = Ext.getScrollbarSize();
    if (scrollbarWidth) {
      scrollbarWidth = scrollSize.width;
      isRTL = el.getStyle('direction') === 'rtl' && !Ext.supports.rtlVertScrollbarOnRight;
      if (isRTL) {
        padding = el.getPadding('l');
        viewContentBox.left -= padding + Math.max(padding, scrollbarWidth);
      } else {
        padding = el.getPadding('r');
        viewContentBox.right += padding - Math.max(padding, scrollbarWidth);
      }
    }
    if (scrollbarHeight) {
      scrollbarHeight = scrollSize.height;
      padding = el.getPadding('b');
      viewContentBox.bottom += padding - Math.max(padding, scrollbarHeight);
    }
  }
  return new Ext.util.Region(viewContentBox.top, viewContentBox.right, viewContentBox.bottom, viewContentBox.left);
}, getViewRegion:function() {
  var me = this, el = me.el, isBody = el.dom.nodeName === 'BODY', borderPadding, scroll, pos, top, left, width, height;
  if (isBody) {
    scroll = el.getScroll();
    left = scroll.left;
    top = scroll.top;
    width = Ext.Element.getViewportWidth();
    height = Ext.Element.getViewportHeight();
  } else {
    borderPadding = me.getBorderPadding();
    pos = me.getXY();
    left = pos[0] + borderPadding.beforeX;
    top = pos[1] + borderPadding.beforeY;
    width = me.getWidth(true);
    height = me.getHeight(true);
  }
  return new Ext.util.Region(top, left + width, top + height, left);
}, move:function(direction, distance, animate) {
  var me = this, xy = me.getXY(), x = xy[0], y = xy[1], left = [x - distance, y], right = [x + distance, y], top = [x, y - distance], bottom = [x, y + distance], hash = {l:left, left:left, r:right, right:right, t:top, top:top, up:top, b:bottom, bottom:bottom, down:bottom};
  direction = direction.toLowerCase();
  me.setXY([hash[direction][0], hash[direction][1]], animate);
}, setBox:function(box) {
  var me = this, x, y;
  if (box.isRegion) {
    box = {x:box.left, y:box.top, width:box.right - box.left, height:box.bottom - box.top};
  }
  me.constrainBox(box);
  x = box.x;
  y = box.y;
  me.setXY([x, y]);
  me.setSize(box.width, box.height);
  me.afterSetPosition(x, y);
  return me;
}, constrainBox:function(box) {
  var me = this, constrainedPos, x, y;
  if (me.constrain || me.constrainHeader) {
    x = 'x' in box ? box.x : box.left;
    y = 'y' in box ? box.y : box.top;
    constrainedPos = me.calculateConstrainedPosition(null, [x, y], false, [box.width, box.height]);
    if (constrainedPos) {
      box.x = constrainedPos[0];
      box.y = constrainedPos[1];
    }
  }
}, translatePoints:function(x, y) {
  var pos = this.translateXY(x, y);
  return {left:pos.x, top:pos.y};
}, translateXY:function(x, y) {
  var me = this, el = me.el, styles = el.getStyle(me._positionTopLeft), relative = styles.position === 'relative', left = parseFloat(styles.left), top = parseFloat(styles.top), xy = me.getXY();
  if (Ext.isArray(x)) {
    y = x[1];
    x = x[0];
  }
  if (isNaN(left)) {
    left = relative ? 0 : el.dom.offsetLeft;
  }
  if (isNaN(top)) {
    top = relative ? 0 : el.dom.offsetTop;
  }
  left = typeof x === 'number' ? x - xy[0] + left : undefined;
  top = typeof y === 'number' ? y - xy[1] + top : undefined;
  return {x:left, y:top};
}, reverseTranslateXY:function(xy) {
  var coords = xy, el = this.el, dom = el.dom, offsetParent = dom.offsetParent, relative, offsetParentXY, x, y;
  if (offsetParent) {
    relative = el.isStyle('position', 'relative'), offsetParentXY = Ext.fly(offsetParent).getXY(), x = xy[0] + offsetParentXY[0] + offsetParent.clientLeft;
    y = xy[1] + offsetParentXY[1] + offsetParent.clientTop;
    if (relative) {
      x += el.getPadding('l');
      y += el.getPadding('t');
    }
    coords = [x, y];
  }
  return coords;
}, privates:{clipTo:function(clippingEl, sides) {
  var clippingRegion, el = this.el, floaterRegion = el.getRegion(), overflow, i, clipValues = [], clippedCls = this.clippedCls, clipStyle, clipped, shadow;
  if (clippingEl.isRegion) {
    clippingRegion = clippingEl;
  } else {
    clippingRegion = (clippingEl.isComponent ? clippingEl.el : Ext.fly(clippingEl)).getConstrainRegion();
  }
  if (!sides) {
    sides = 15;
  }
  if (sides & 1 && (overflow = clippingRegion.top - floaterRegion.top) > 0) {
    clipValues[0] = overflow;
    clipped = true;
  } else {
    clipValues[0] = -10000;
  }
  if (sides & 2 && (overflow = floaterRegion.right - clippingRegion.right) > 0) {
    clipValues[1] = Math.max(0, el.getWidth() - overflow);
    clipped = true;
  } else {
    clipValues[1] = 10000;
  }
  if (sides & 4 && (overflow = floaterRegion.bottom - clippingRegion.bottom) > 0) {
    clipValues[2] = Math.max(0, el.getHeight() - overflow);
    clipped = true;
  } else {
    clipValues[2] = 10000;
  }
  if (sides & 8 && (overflow = clippingRegion.left - floaterRegion.left) > 0) {
    clipValues[3] = overflow;
    clipped = true;
  } else {
    clipValues[3] = -10000;
  }
  clipStyle = 'rect(';
  for (i = 0; i < 4; ++i) {
    clipStyle += Ext.Element.addUnits(clipValues[i], 'px');
    clipStyle += i === 3 ? ')' : ',';
  }
  el.dom.style.clip = clipStyle;
  el.addCls(clippedCls);
  if ((shadow = el.shadow) && (el = shadow.el) && el.dom) {
    clipValues[2] -= shadow.offsets.y;
    clipValues[3] -= shadow.offsets.x;
    clipStyle = 'rect(';
    for (i = 0; i < 4; ++i) {
      clipStyle += Ext.Element.addUnits(clipValues[i], 'px');
      clipStyle += i === 3 ? ')' : ',';
    }
    el.dom.style.clip = clipStyle;
    if (clipped && !Ext.supports.CSS3BoxShadow) {
      el.dom.style.display = 'none';
    } else {
      el.dom.style.display = '';
      el.addCls(clippedCls);
    }
  }
}, clearClip:function() {
  var el = this.el, clippedCls = this.clippedCls;
  el.dom.style.clip = Ext.isIE8 ? 'auto' : '';
  el.removeCls(clippedCls);
  if (el.shadow && el.shadow.el && el.shadow.el.dom) {
    el.shadow.el.dom.style.clip = Ext.isIE8 ? 'auto' : '';
    if (!Ext.supports.CSS3BoxShadow) {
      el.dom.style.display = '';
      el.removeCls(clippedCls);
    }
  }
}}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Positionable'], 0);
Ext.define('Ext.overrides.util.Positionable', {override:'Ext.util.Positionable', anchorTo:function(anchorToEl, alignment, offsets, animate, monitorScroll, callback) {
  var me = this, scroll = !Ext.isEmpty(monitorScroll), action = function() {
    me.mixins.positionable.alignTo.call(me, anchorToEl, alignment, offsets, animate);
    Ext.callback(callback, me);
  }, anchor = me.getAnchor();
  me.removeAnchor();
  Ext.apply(anchor, {fn:action, scroll:scroll});
  Ext.on('resize', action, null);
  if (scroll) {
    Ext.getWin().on('scroll', action, null, {buffer:!isNaN(monitorScroll) ? monitorScroll : 50});
  }
  action();
  return me;
}, getAnchor:function() {
  var el = this.el, data, anchor;
  if (!el || !el.dom) {
    return;
  }
  data = el.getData();
  anchor = data._anchor;
  if (!anchor) {
    anchor = data._anchor = {};
  }
  return anchor;
}, alignTo:function(element, position, offsets, animate) {
  var me = this, el = me.el, newMaxHeight, newRegion;
  if (me.isComponent && me.getSizeModel().height.shrinkWrap) {
    if (me.maxHeight) {
      me.setMaxHeight(null);
    }
    newMaxHeight = true;
  }
  newRegion = me.getAlignToRegion(element, position, offsets, me.minHeight || 150);
  me.setXY([newRegion.x, newRegion.y], el.anim && !!animate ? el.anim(animate) : false);
  if (newMaxHeight && (newMaxHeight = newRegion.getHeight()) !== me.getHeight()) {
    me.setMaxHeight(newMaxHeight);
  }
  return me;
}, removeAnchor:function() {
  var anchor = this.getAnchor();
  if (anchor && anchor.fn) {
    Ext.un('resize', anchor.fn);
    if (anchor.scroll) {
      Ext.getWin().on('scroll', anchor.fn);
    }
    delete anchor.fn;
  }
  return this;
}, setBox:function(box, animate) {
  var me = this;
  if (box.isRegion) {
    box = {x:box.left, y:box.top, width:box.right - box.left, height:box.bottom - box.top};
  }
  if (animate) {
    me.constrainBox(box);
    me.animate(Ext.applyIf({to:box, listeners:{afteranimate:Ext.Function.bind(me.afterSetPosition, me, [box.x, box.y])}}, animate));
  } else {
    arguments.callee.$previous.call(this, box);
  }
  return me;
}});
Ext.cmd.derive('Ext.dom.UnderlayPool', Ext.Base, {constructor:function(elementConfig) {
  this.elementConfig = elementConfig;
  this.cache = [];
}, checkOut:function() {
  var el = this.cache.shift();
  if (!el) {
    el = Ext.Element.create(this.elementConfig);
    el.setVisibilityMode(2);
  }
  return el;
}, checkIn:function(el) {
  this.cache.push(el);
  Ext.getDetachedBody().dom.appendChild(el.dom);
}, reset:function() {
  var cache = this.cache, i = cache.length;
  while (i--) {
    cache[i].destroy();
  }
  this.cache = [];
}}, 1, 0, 0, 0, 0, 0, [Ext.dom, 'UnderlayPool'], 0);
Ext.cmd.derive('Ext.dom.Underlay', Ext.Base, {constructor:function(config) {
  Ext.apply(this, config);
}, beforeShow:Ext.emptyFn, getInsertionTarget:function() {
  return this.target;
}, getPool:function() {
  return this.pool || (this.self.prototype.pool = new Ext.dom.UnderlayPool(this.elementConfig));
}, hide:function() {
  var me = this, el = me.el;
  if (el) {
    if (el.dom) {
      el.hide();
      me.getPool().checkIn(el);
    }
    me.el = null;
  }
  me.hidden = true;
}, realign:function(x, y, width, height) {
  var me = this, el = me.el, target = me.target, offsets = me.offsets, max = Math.max;
  if (el) {
    if (x == null) {
      x = target.getX();
    }
    if (y == null) {
      y = target.getY();
    }
    if (width == null) {
      width = target.getWidth();
    }
    if (height == null) {
      height = target.getHeight();
    }
    if (offsets) {
      x = x + offsets.x;
      y = y + offsets.y;
      width = max(width + offsets.w, 0);
      height = max(height + offsets.h, 0);
    }
    el.setXY([x, y]);
    el.setSize(width, height);
  }
}, setZIndex:function(zIndex) {
  this.zIndex = zIndex;
  if (this.el) {
    this.el.setStyle('z-index', zIndex);
  }
}, show:function() {
  var me = this, target = me.target, zIndex = me.zIndex, el = me.el, insertionTarget = me.getInsertionTarget().dom, dom;
  if (!el) {
    el = me.el = me.getPool().checkOut();
  }
  me.beforeShow();
  if (zIndex == null) {
    zIndex = parseInt(target.getStyle('z-index'), 10);
  }
  if (zIndex) {
    el.setStyle('z-index', zIndex);
  }
  el.setStyle('position', me.fixed ? 'fixed' : '');
  dom = el.dom;
  if (dom.nextSibling !== insertionTarget) {
    target.dom.parentNode.insertBefore(dom, insertionTarget);
  }
  el.show();
  me.realign();
  me.hidden = false;
}}, 1, 0, 0, 0, 0, 0, [Ext.dom, 'Underlay'], 0);
Ext.cmd.derive('Ext.dom.Shadow', Ext.dom.Underlay, {alternateClassName:'Ext.Shadow', mode:'drop', offset:4, cls:'x-' + (!Ext.supports.CSS3BoxShadow ? 'ie' : 'css') + '-shadow', constructor:function(config) {
  var me = this, outerOffsets, offsets, offset, rad;
  Ext.dom.Underlay.prototype.constructor.call(this, config);
  me.elementConfig = {cls:me.cls, role:'presentation'};
  offset = me.offset;
  rad = Math.floor(offset / 2);
  me.opacity = 50;
  switch(me.mode.toLowerCase()) {
    case 'drop':
      outerOffsets = {x:0, y:0, w:offset, h:offset};
      if (Ext.supports.CSS3BoxShadow) {
        offsets = {x:offset, y:offset, h:-offset, w:-offset};
      } else {
        offsets = {x:-rad, y:-rad, h:-rad, w:-rad};
      }
      break;
    case 'sides':
      outerOffsets = {x:-offset, y:0, w:offset * 2, h:offset};
      if (Ext.supports.CSS3BoxShadow) {
        offsets = {x:0, y:offset, h:-offset, w:0};
      } else {
        offsets = {x:1 + rad - 2 * offset, y:-(1 + rad), h:-1, w:rad - 1};
      }
      break;
    case 'frame':
      outerOffsets = {x:-offset, y:-offset, w:offset * 2, h:offset * 2};
      if (Ext.supports.CSS3BoxShadow) {
        offsets = {x:0, y:0, h:0, w:0};
      } else {
        offsets = {x:1 + rad - 2 * offset, y:1 + rad - 2 * offset, h:offset - rad - 1, w:offset - rad - 1};
      }
      break;
    case 'bottom':
      outerOffsets = {x:-offset, y:0, w:offset * 2, h:offset};
      if (Ext.supports.CSS3BoxShadow) {
        offsets = {x:0, y:offset, h:-offset, w:0};
      } else {
        offsets = {x:0, y:offset, h:0, w:0};
      }
      break;
  }
  me.offsets = offsets;
  me.outerOffsets = outerOffsets;
}, getShadowSize:function() {
  var me = this, offset = me.el ? me.offset : 0, result = [offset, offset, offset, offset], mode = me.mode.toLowerCase();
  if (me.el && mode !== 'frame') {
    result[0] = 0;
    if (mode == 'drop') {
      result[3] = 0;
    }
  }
  return result;
}, boxShadowProperty:function() {
  var property = 'boxShadow', style = document.documentElement.style;
  if (!('boxShadow' in style)) {
    if ('WebkitBoxShadow' in style) {
      property = 'WebkitBoxShadow';
    } else {
      if ('MozBoxShadow' in style) {
        property = 'MozBoxShadow';
      }
    }
  }
  return property;
}(), beforeShow:function() {
  var me = this, style = me.el.dom.style, shim = me.shim;
  if (Ext.supports.CSS3BoxShadow) {
    style[me.boxShadowProperty] = '0 0 ' + (me.offset + 2) + 'px #888';
  } else {
    style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity\x3d' + me.opacity + ') progid:DXImageTransform.Microsoft.Blur(pixelradius\x3d' + me.offset + ')';
  }
  if (shim) {
    shim.realign();
  }
}, setOpacity:function(opacity) {
  var el = this.el;
  if (el) {
    if (Ext.isIE && !Ext.supports.CSS3BoxShadow) {
      opacity = Math.floor(opacity * 100 / 2) / 100;
    }
    this.opacity = opacity;
    el.setOpacity(opacity);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.dom, 'Shadow', Ext, 'Shadow'], 0);
Ext.cmd.derive('Ext.dom.Shim', Ext.dom.Underlay, {cls:'x-shim', constructor:function(config) {
  Ext.dom.Underlay.prototype.constructor.call(this, config);
  this.elementConfig = {tag:'iframe', cls:this.cls, role:'presentation', frameBorder:'0', src:Ext.SSL_SECURE_URL, tabindex:'-1'};
}, getInsertionTarget:function() {
  var shadow = this.shadow;
  return shadow && shadow.el || this.target;
}}, 1, 0, 0, 0, 0, 0, [Ext.dom, 'Shim'], 0);
Ext.cmd.derive('Ext.dom.ElementEvent', Ext.util.Event, {addListener:function(fn, scope, options, caller, manager) {
  var me = this, added = false, name = me.name, isDirectEvent = Ext.event.publisher.Dom.instance.directEvents[name], captures, directs, directCaptures;
  options = options || {};
  if (options.delegated === false || isDirectEvent) {
    if (isDirectEvent && options.delegate) {
      options.capture = true;
    }
    if (options.capture) {
      directCaptures = me.directCaptures || (me.directCaptures = new Ext.util.Event(me.observable, name));
      added = directCaptures.addListener(fn, scope, options, caller, manager);
    } else {
      directs = me.directs || (me.directs = new Ext.util.Event(me.observable, name));
      added = directs.addListener(fn, scope, options, caller, manager);
    }
  } else {
    if (options.capture) {
      captures = me.captures || (me.captures = new Ext.util.Event(me.observable, name));
      added = captures.addListener(fn, scope, options, caller, manager);
    } else {
      added = Ext.util.Event.prototype.addListener.call(this, fn, scope, options, caller, manager);
    }
  }
  return added;
}, removeListener:function(fn, scope) {
  var me = this, captures = me.captures, directs = me.directs, directCaptures = me.directCaptures, removed = false, index = me.findListener(fn, scope);
  if (index !== -1) {
    removed = Ext.util.Event.prototype.removeListener.call(this, fn, scope, index);
  } else {
    if (directs) {
      index = directs.findListener(fn, scope);
    }
    if (index !== -1) {
      removed = directs.removeListener(fn, scope, index);
    } else {
      if (captures) {
        index = captures.findListener(fn, scope);
      }
      if (index !== -1) {
        removed = captures.removeListener(fn, scope, index);
      } else {
        if (directCaptures) {
          index = directCaptures.findListener(fn, scope);
          if (index !== -1) {
            removed = directCaptures.removeListener(fn, scope, index);
          }
        }
      }
    }
  }
  return removed;
}, clearListeners:function() {
  var me = this, directCaptures = me.directCaptures, directs = me.directs, captures = me.captures;
  if (directCaptures) {
    directCaptures.clearListeners();
  }
  if (directs) {
    directs.clearListeners();
  }
  if (captures) {
    captures.clearListeners();
  }
  Ext.util.Event.prototype.clearListeners.call(this);
}, suspend:function() {
  var me = this, directCaptures = me.directCaptures, directs = me.directs, captures = me.captures;
  if (directCaptures) {
    directCaptures.suspend();
  }
  if (directs) {
    directs.suspend();
  }
  if (captures) {
    captures.suspend();
  }
  Ext.util.Event.prototype.suspend.call(this);
}, resume:function() {
  var me = this, directCaptures = me.directCaptures, directs = me.directs, captures = me.captures;
  if (directCaptures) {
    directCaptures.resume();
  }
  if (directs) {
    directs.resume();
  }
  if (captures) {
    captures.resume();
  }
  Ext.util.Event.prototype.resume.call(this);
}}, 0, 0, 0, 0, 0, 0, [Ext.dom, 'ElementEvent'], 0);
Ext.cmd.derive('Ext.event.publisher.Publisher', Ext.Base, {isEventPublisher:true, $vetoClearingPrototypeOnDestroy:true, handledEvents:[], statics:{publishers:{}, publishersByEvent:{}}, constructor:function() {
  var me = this, type = me.type;
  me.handles = {};
  me.registerEvents();
  Ext.event.publisher.Publisher.publishers[type] = me;
}, registerEvents:function(events) {
  var me = this, publishersByEvent = Ext.event.publisher.Publisher.publishersByEvent, handledEvents = events || me.handledEvents, ln = handledEvents.length, eventName, i;
  for (i = 0; i < ln; i++) {
    eventName = handledEvents[i];
    me.handles[eventName] = 1;
    publishersByEvent[eventName] = me;
  }
}, fire:function(element, eventName, args) {
  var event;
  if (element.hasListeners[eventName]) {
    event = element.events[eventName];
    if (event) {
      event.fire.apply(event, args);
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, 'Publisher'], 0);
Ext.cmd.derive('Ext.util.Offset', Ext.Base, {statics:{fromObject:function(obj) {
  if (obj instanceof this) {
    return obj;
  }
  if (typeof obj === 'number') {
    return new this(obj, obj);
  }
  if (obj.length) {
    return new this(obj[0], obj[1]);
  }
  return new this(obj.x, obj.y);
}}, constructor:function(x, y) {
  this.x = x != null && !isNaN(x) ? x : 0;
  this.y = y != null && !isNaN(y) ? y : 0;
  return this;
}, copy:function() {
  return new Ext.util.Offset(this.x, this.y);
}, copyFrom:function(p) {
  this.x = p.x;
  this.y = p.y;
}, toString:function() {
  return 'Offset[' + this.x + ',' + this.y + ']';
}, equals:function(offset) {
  return this.x === offset.x && this.y === offset.y;
}, add:function(offset) {
  this.x += offset.x;
  this.y += offset.y;
}, round:function(to) {
  if (!isNaN(to)) {
    var factor = Math.pow(10, to);
    this.x = Math.round(this.x * factor) / factor;
    this.y = Math.round(this.y * factor) / factor;
  } else {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
  }
}, isZero:function() {
  return this.x === 0 && this.y === 0;
}}, 3, 0, 0, 0, 0, 0, [Ext.util, 'Offset'], 0);
Ext.cmd.derive('Ext.util.Region', Ext.Base, function() {
  var ExtUtil = Ext.util, constrainRe = /([^\?!]*)(!|\?)?$/, alignRe = /^(?:(?:([trbl])(\d+))|(tl|t|tc|tr|l|c|r|bl|b|bc|br))(?:-(?:(?:([trbl])(\d+))|(tl|t|tc|tr|l|c|r|bl|b|bc|br)))?$/i, LTROffsetFactors = {l:0, r:100, t:0, b:100, c:50}, RTLOffsetFactors = {l:100, r:0, t:0, b:100, c:50}, relativePositions = {b:0, l:1, t:2, r:3}, alignMap = {'tl-tr':'l0-r0', 'tl-r':'l0-r50', 'bl-r':'l100-r50', 'bl-br':'l100-r100', 'tr-tl':'r0-l0', 'tr-l':'r0-l50', 'br-l':'r100-l50', 'br-bl':'r100-l100'}, rtlAlignMap = 
  {'tl-tr':'r0-l0', 'tl-r':'r0-l50', 'bl-r':'r100-l50', 'bl-br':'r100-l100', 'tr-tl':'l0-r0', 'tr-l':'l0-r50', 'br-l':'l100-r50', 'br-bl':'l100-r100'}, adjustParams = [], zeroOffset = new ExtUtil.Offset(0, 0), parseRegion = function(box) {
    var Region = ExtUtil.Region, type = typeof box, top, right, bottom, left;
    if (box == null) {
      return Region.EMPTY;
    }
    if (box.isRegion) {
      return box;
    }
    if (box.isElement || box.nodeType === 1) {
      return this.getRegion(box);
    }
    if (type === 'string') {
      box = box.split(' ');
      switch(box.length) {
        case 1:
          box[1] = box[2] = box[3] = box[0];
          break;
        case 2:
          box[2] = box[0];
          box[3] = box[1];
          break;
        case 3:
          box[3] = box[1];
      }
      top = parseInt(box[0], 10) || 0;
      right = parseInt(box[1], 10) || 0;
      bottom = parseInt(box[2], 10) || 0;
      left = parseInt(box[3], 10) || 0;
    } else {
      if (type === 'number') {
        top = right = bottom = left = box;
      } else {
        if (typeof box.x === 'number') {
          top = box.y;
          left = box.x;
          if (typeof box.right === 'number') {
            right = box.right;
            bottom = box.bottom;
          } else {
            right = left + box.width;
            bottom = top + box.height;
          }
        }
      }
    }
    return new Region(top, right, bottom, left);
  }, magnitude = [-1, 1, 1, -1], addAnchorOffset = function(target, anchorSize, relativePosition) {
    if (relativePosition != null && anchorSize) {
      adjustParams[0] = adjustParams[1] = adjustParams[2] = adjustParams[3] = 0;
      adjustParams[relativePosition] = anchorSize.y * magnitude[relativePosition];
      target = ExtUtil.Region.from(target);
      target.adjust.apply(target, adjustParams);
    }
    return target;
  }, calculateAnchorPosition = function(target, result, relativePosition, anchorSize, inside) {
    var anchorWidth = Math.ceil(anchorSize.x), minOverlap = Math.ceil(anchorWidth / 2) + 3, min, max, anchorPos, isBefore, overlapLine, x, y;
    if (inside && !inside.intersect(target)) {
      return;
    }
    if (relativePosition != null) {
      if (relativePosition & 1) {
        if (result.getHeight() < anchorWidth + 4) {
          return;
        }
        min = target.top + minOverlap - result.height;
        max = target.bottom - minOverlap - 1;
        result.setPosition(result.x, Math.min(Math.max(result.y, min), max));
        min = result.top + 2;
        max = result.bottom - (anchorWidth + 2);
        isBefore = relativePosition === 3;
        x = isBefore ? result.right : result.left;
        overlapLine = new ExtUtil.Region(Math.max(result.top, target.top), x, Math.min(result.bottom, target.bottom), x);
        anchorPos = (new ExtUtil.Region(0, 0, 0, 0)).setWidth(anchorSize.y).setHeight(anchorWidth).alignTo({target:overlapLine, align:isBefore ? 'l-r' : 'r-l', overlap:true});
        anchorPos.setPosition(anchorPos.x, Math.min(Math.max(anchorPos.y, min), max));
        anchorPos.position = isBefore ? 'right' : 'left';
      } else {
        if (result.getWidth() < anchorWidth + 4) {
          return;
        }
        min = target.left + minOverlap - result.width;
        max = target.right - minOverlap - 1;
        result.setPosition(Math.min(Math.max(result.x, min), max), result.y);
        min = result.left + 2;
        max = result.right - (anchorWidth + 2);
        isBefore = relativePosition === 0;
        y = isBefore ? result.bottom : result.top;
        overlapLine = new ExtUtil.Region(y, Math.min(result.right, target.right), y, Math.max(result.left, target.left));
        anchorPos = (new ExtUtil.Region(0, 0, 0, 0)).setWidth(anchorWidth).setHeight(anchorSize.y).alignTo({target:overlapLine, align:isBefore ? 't-b' : 'b-t', overlap:true});
        anchorPos.setPosition(Math.min(Math.max(anchorPos.x, min), max), anchorPos.y);
        anchorPos.position = isBefore ? 'bottom' : 'top';
      }
      if (inside && !inside.contains(anchorPos)) {
        return;
      }
      result.anchor = anchorPos;
      result.anchor.align = relativePosition;
    }
  }, checkMinHeight = function(minHeight, result, target, inside) {
    var newHeight;
    if (minHeight && inside) {
      if (result.top >= target.bottom && result.bottom > inside.bottom) {
        result.setHeight(Math.max(result.getHeight() + inside.bottom - result.bottom, minHeight));
        result.constrainHeight = true;
      } else {
        if (result.bottom <= target.top && result.top < inside.top) {
          newHeight = Math.max(result.getHeight() + result.top - inside.top, minHeight);
          result.adjust(result.getHeight() - newHeight);
          result.constrainHeight = true;
        } else {
          if (result.getHeight() > inside.getHeight()) {
            result.setHeight(Math.max(minHeight, inside.getHeight()));
            result.setPosition(result.x, 0);
            result.constrainHeight = true;
          }
        }
      }
    }
  }, checkMinWidth = function(minWidth, result, target, inside) {
    var newWidth;
    if (minWidth && inside) {
      if (result.left >= target.right && result.right > inside.right) {
        result.setWidth(Math.max(result.getWidth() + inside.right - result.right, minWidth));
        result.constrainWidth = true;
      } else {
        if (result.right <= target.left && result.left < inside.left) {
          newWidth = Math.max(result.getWidth() + result.left - inside.left, minWidth);
          result.adjust(0, 0, 0, result.getWidth() - newWidth);
          result.constrainWidth = true;
        } else {
          if (result.getWidth() > inside.getWidth()) {
            result.setWidth(Math.max(minWidth, inside.getWidth()));
            result.setPosition(0, result.y);
            result.constrainWidth = true;
          }
        }
      }
    }
  };
  return {isRegion:true, statics:{getRegion:function(el) {
    return Ext.fly(el).getRegion();
  }, from:function(o) {
    return new this(o.top, o.right, o.bottom, o.left);
  }, getAlignInfo:function(align, rtl) {
    if (typeof align === 'object') {
      return align;
    }
    align = align ? align.indexOf('-') < 0 ? 'tl-' + align : align : 'tl-bl';
    constrain = constrainRe.exec(align);
    align = constrain[1];
    align = (rtl ? rtlAlignMap : alignMap)[align] || align;
    var offsetFactors = rtl ? RTLOffsetFactors : LTROffsetFactors, constrain, parts = alignRe.exec(align), result;
    result = {myEdge:parts[1], myOffset:parts[2], otherEdge:parts[4], otherOffset:parts[5], constrain:constrain[2]};
    if (parts[3]) {
      result.myEdge = parts[3][0];
      result.myOffset = offsetFactors[parts[3][1]];
      if (result.myOffset == null) {
        result.myOffset = 50;
      }
    }
    if (parts[6]) {
      result.otherEdge = parts[6][0];
      result.otherOffset = offsetFactors[parts[6][1]];
      if (result.otherOffset == null) {
        result.otherOffset = 50;
      }
    }
    result.position = relativePositions[result.myEdge];
    return result;
  }}, constructor:function(top, right, bottom, left) {
    var me = this;
    me.y = me.top = me[1] = top;
    me.right = right;
    me.bottom = bottom;
    me.x = me.left = me[0] = left;
    me.height = me.bottom - me.top;
    me.width = me.right - me.left;
  }, setPosition:function(x, y) {
    if (arguments.length === 1) {
      y = x[1];
      x = x[0];
    }
    return this.translateBy(x - this.x, y - this.y);
  }, contains:function(region) {
    var me = this;
    return region.x >= me.x && (region.right || region.x) <= me.right && region.y >= me.y && (region.bottom || region.y) <= me.bottom;
  }, intersect:function(region) {
    var me = this, t = Math.max(me.y, region.y), r = Math.min(me.right, region.right), b = Math.min(me.bottom, region.bottom), l = Math.max(me.x, region.x);
    if (b > t && r > l) {
      return new this.self(t, r, b, l);
    } else {
      return false;
    }
  }, union:function(region) {
    var me = this, t = Math.min(me.y, region.y), r = Math.max(me.right, region.right), b = Math.max(me.bottom, region.bottom), l = Math.min(me.x, region.x);
    return new this.self(t, r, b, l);
  }, constrainTo:function(targetRegion) {
    var me = this, constrain = Ext.Number.constrain;
    me.top = me.y = constrain(me.top, targetRegion.y, targetRegion.bottom);
    me.bottom = constrain(me.bottom, targetRegion.y, targetRegion.bottom);
    me.left = me.x = constrain(me.left, targetRegion.x, targetRegion.right);
    me.right = constrain(me.right, targetRegion.x, targetRegion.right);
    me.height = me.bottom - me.top;
    me.width = me.right - me.left;
    return me;
  }, adjust:function(top, right, bottom, left) {
    var me = this;
    me.top = me.y += top || 0;
    me.left = me.x += left || 0;
    me.right += right || 0;
    me.bottom += bottom || 0;
    me.height = me.bottom - me.top;
    me.width = me.right - me.left;
    return me;
  }, getOutOfBoundOffset:function(axis, p) {
    if (!Ext.isObject(axis)) {
      if (axis === 'x') {
        return this.getOutOfBoundOffsetX(p);
      } else {
        return this.getOutOfBoundOffsetY(p);
      }
    } else {
      p = axis;
      var d = new ExtUtil.Offset;
      d.x = this.getOutOfBoundOffsetX(p.x);
      d.y = this.getOutOfBoundOffsetY(p.y);
      return d;
    }
  }, getOutOfBoundOffsetX:function(p) {
    if (p <= this.x) {
      return this.x - p;
    } else {
      if (p >= this.right) {
        return this.right - p;
      }
    }
    return 0;
  }, getOutOfBoundOffsetY:function(p) {
    if (p <= this.y) {
      return this.y - p;
    } else {
      if (p >= this.bottom) {
        return this.bottom - p;
      }
    }
    return 0;
  }, isOutOfBound:function(axis, p) {
    if (!Ext.isObject(axis)) {
      if (axis === 'x') {
        return this.isOutOfBoundX(p);
      } else {
        return this.isOutOfBoundY(p);
      }
    } else {
      p = axis;
      return this.isOutOfBoundX(p.x) || this.isOutOfBoundY(p.y);
    }
  }, isOutOfBoundX:function(p) {
    return p < this.x || p > this.right;
  }, isOutOfBoundY:function(p) {
    return p < this.y || p > this.bottom;
  }, restrict:function(axis, p, factor) {
    if (Ext.isObject(axis)) {
      var newP;
      factor = p;
      p = axis;
      if (p.copy) {
        newP = p.copy();
      } else {
        newP = {x:p.x, y:p.y};
      }
      newP.x = this.restrictX(p.x, factor);
      newP.y = this.restrictY(p.y, factor);
      return newP;
    } else {
      if (axis === 'x') {
        return this.restrictX(p, factor);
      } else {
        return this.restrictY(p, factor);
      }
    }
  }, restrictX:function(p, factor) {
    if (!factor) {
      factor = 1;
    }
    if (p <= this.x) {
      p -= (p - this.x) * factor;
    } else {
      if (p >= this.right) {
        p -= (p - this.right) * factor;
      }
    }
    return p;
  }, restrictY:function(p, factor) {
    if (!factor) {
      factor = 1;
    }
    if (p <= this.y) {
      p -= (p - this.y) * factor;
    } else {
      if (p >= this.bottom) {
        p -= (p - this.bottom) * factor;
      }
    }
    return p;
  }, alignTo:function(options) {
    var me = this, Region = me.self, Offset = ExtUtil.Offset, Element = Ext.Element, target = parseRegion(options.target), targetPlusAnchorOffset, rtl = options.rtl, overlap = options.overlap, align = options.align, anchorSize = options.anchorSize, offset = options.offset, inside = options.inside, position = options.position, allowXTranslate = options.allowXTranslate, allowYTranslate = options.allowYTranslate, wasConstrained, result, initialPosition, constrainedPosition;
    if (offset) {
      offset = Offset.fromObject(offset);
    }
    if (anchorSize) {
      anchorSize = Offset.fromObject(anchorSize);
    }
    if (inside && !inside.isRegion) {
      if (Ext.getDom(inside) === document.body) {
        inside = new Region(0, Element.getDocumentWidth(), Element.getDocumentHeight(), 0);
      } else {
        inside = Ext.fly(inside).getRegion();
      }
    }
    if (position) {
      if (position.length === 2) {
        position = new ExtUtil.Point(position[0], position[1]);
      }
      result = (new Region).copyFrom(me).setPosition(position.x, position.y);
    } else {
      align = me.getAlignInfo(align, rtl);
      if (inside) {
        if (target.x >= inside.right) {
          target.setPosition(inside.right - 1, target.y);
          if (align.position !== 3) {
            align = me.getAlignInfo('r-l', rtl);
          }
        } else {
          if (target.right < inside.x) {
            target.setPosition(inside.x - target.getWidth() + 1, target.y);
            if (align.position !== 1) {
              align = me.getAlignInfo('l-r', rtl);
            }
          }
        }
        if (target.y >= inside.bottom) {
          target.setPosition(target.x, inside.bottom - 1);
          if (align.position !== 0) {
            align = me.getAlignInfo('b-t', rtl);
          }
        } else {
          if (target.bottom < inside.y) {
            target.setPosition(target.x, inside.y - target.getHeight() + 1);
            if (align.position !== 2) {
              align = me.getAlignInfo('t-b', rtl);
            }
          }
        }
      }
      targetPlusAnchorOffset = anchorSize ? addAnchorOffset(target, anchorSize, align.position) : target;
      result = Region.from(me).translateBy(me.getAlignToVector(targetPlusAnchorOffset, align));
      overlap = !!result.intersect(targetPlusAnchorOffset);
      if (offset && (overlap || !anchorSize)) {
        result.translateBy(offset);
      }
      if (anchorSize) {
        calculateAnchorPosition(target, result, align.position, anchorSize, inside);
      }
    }
    if (inside) {
      initialPosition = result.copy();
      if (result.left < inside.left) {
        result.translateBy(inside.left - result.left, 0);
        wasConstrained = true;
      }
      if (result.right > inside.right && result.left > inside.left) {
        result.translateBy(inside.right - result.right, 0);
        wasConstrained = true;
      }
      if (result.top < inside.top) {
        result.translateBy(0, inside.top - result.top);
        wasConstrained = true;
      }
      if (result.bottom > inside.bottom && result.top > inside.top) {
        result.translateBy(0, inside.bottom - result.bottom);
        wasConstrained = true;
      }
      if (wasConstrained && !overlap) {
        result.anchor = null;
        if (options.axisLock) {
          if (align.position & 1) {
            allowYTranslate = false;
          } else {
            allowXTranslate = false;
          }
        }
        if (position) {
          if (result.contains(position)) {
            position.exclude(result, {inside:inside, centerOnSideChange:false});
          }
        } else {
          constrainedPosition = result.copy();
          if (result.intersect(targetPlusAnchorOffset)) {
            align.position = target.exclude(result, {initialPosition:initialPosition, defaultPosition:align.position, inside:inside, minHeight:options.minHeight, minWidth:options.minWidth, allowX:allowXTranslate, allowY:allowYTranslate, offset:offset, anchorHeight:anchorSize ? anchorSize.y : 0, centerOnSideChange:!!anchorSize});
          } else {
            if (options.minWidth && result.getWidth() > inside.getWidth()) {
              result.setPosition(0, result.y);
              result.setWidth(Math.max(inside.getWidth(), options.minWidth));
              result.constrainWidth = true;
            } else {
              if (options.minHeight && result.getHeight() > inside.getHeight()) {
                result.setPosition(result.x, 0);
                result.setHeight(Math.max(inside.getHeight(), options.minHeight));
                result.constrainHeight = true;
              }
            }
          }
          result.align = align;
          if (inside.contains(result)) {
            if (anchorSize) {
              calculateAnchorPosition(target, result, align.position, anchorSize, inside);
            }
          } else {
            result = constrainedPosition;
          }
        }
      }
    }
    return result;
  }, exclude:function(other, options) {
    options = options || {};
    var me = this, initialPosition = options.initialPosition || other, inside = options.inside, defaultPosition = options.defaultPosition, centerOnSideChange = options.centerOnSideChange, minHeight = options.minHeight, minWidth = options.minWidth, allowX = options.allowX !== false, allowY = options.allowY !== false, anchorHeight = options.anchorHeight, offset = options.offset, translations = [], testRegion, t, i, sizeConstrainedSolution, leastBadSolution, intersection, result;
    if (!offset) {
      offset = zeroOffset;
    }
    if (allowY) {
      translations.push([0, me.top - other.bottom - anchorHeight + offset.y, 'b-t', 0, Math.abs(me.top - initialPosition.bottom - anchorHeight + offset.y)]);
      translations.push([0, me.bottom - other.top + anchorHeight + offset.y, 't-b', 2, Math.abs(me.bottom - initialPosition.top + anchorHeight + offset.y)]);
    } else {
      centerOnSideChange = false;
    }
    if (allowX) {
      translations.push([me.left - other.right - anchorHeight + offset.x, 0, 'r-l', 3, Math.abs(me.left - initialPosition.right - anchorHeight + offset.x)]);
      translations.push([me.right - other.left + anchorHeight + offset.x, 0, 'l-r', 1, Math.abs(me.right - initialPosition.left + anchorHeight + offset.x)]);
    } else {
      centerOnSideChange = false;
    }
    Ext.Array.sort(translations, function(l, r) {
      var result = l[4] - r[4];
      if (!result) {
        if (l[3] === defaultPosition) {
          return -1;
        }
        if (r[3] === defaultPosition) {
          return 1;
        }
      }
      return result;
    });
    if (inside) {
      for (i = 0; i < translations.length; i++) {
        t = translations[i];
        testRegion = ExtUtil.Region.from(other);
        testRegion.translateBy.apply(testRegion, t);
        if (inside.contains(testRegion)) {
          other.copyFrom(testRegion);
          result = {align:t[2], position:t[3], distance:t[4]};
          break;
        }
        if (minHeight) {
          checkMinHeight(minHeight, testRegion, me, inside);
          if (inside.contains(testRegion)) {
            if (!sizeConstrainedSolution || testRegion.getArea() > sizeConstrainedSolution.region.getArea()) {
              sizeConstrainedSolution = {region:testRegion, align:t[2], position:t[3], distance:t[4]};
            }
          }
        }
        if (minWidth) {
          checkMinWidth(minWidth, testRegion, me, inside);
          if (inside.contains(testRegion)) {
            if (!sizeConstrainedSolution || testRegion.getArea() > sizeConstrainedSolution.region.getArea()) {
              sizeConstrainedSolution = {region:testRegion, align:t[2], position:t[3], distance:t[4]};
            }
          }
        }
        intersection = inside.intersect(testRegion);
        if (intersection) {
          intersection = intersection.getArea();
          if (!leastBadSolution || intersection && leastBadSolution.area < intersection) {
            leastBadSolution = {region:testRegion, align:t[2], position:t[3], distance:t[4], area:intersection};
          }
        }
      }
      if (!result) {
        if (sizeConstrainedSolution) {
          other.copyFrom(sizeConstrainedSolution.region);
          result = sizeConstrainedSolution;
          other.constrainWidth = sizeConstrainedSolution.region.constrainWidth;
          other.constrainHeight = sizeConstrainedSolution.region.constrainHeight;
        } else {
          if (leastBadSolution) {
            other.copyFrom(leastBadSolution.region);
            result = leastBadSolution;
          }
        }
      }
      if (result) {
        if ((result.position & 1) !== (defaultPosition & 1)) {
          if (result.distance && centerOnSideChange) {
            t = other.alignTo({align:result.align, target:me, anchorSize:anchorHeight, offset:offset, axisLock:true, inside:inside, minHeight:options.minHeight, minWidth:options.minWidth});
            if (inside.contains(t)) {
              other.setPosition(t.x, t.y);
            }
          }
        }
        return result.position;
      }
    } else {
      other.translateBy.apply(other, translations[0]);
      return translations[0][3];
    }
    return defaultPosition;
  }, getAlignToXY:function(target, align, rtl) {
    var alignVector = this.getAlignToVector(target, align, rtl);
    return [this.x + alignVector[0], this.y + alignVector[1]];
  }, getAnchorPoint:function(align, rtl) {
    align = typeof align === 'string' ? this.getAlignInfo(align + '-tl', rtl) : align;
    return this['getAnchorPoint_' + align.myEdge](align.myOffset);
  }, getAlignToVector:function(target, align, rtl) {
    align = typeof align === 'string' ? this.getAlignInfo(align, rtl) : align;
    var myAnchorPoint = this['getAnchorPoint_' + align.myEdge](align.myOffset), targetAnchorPoint = target['getAnchorPoint_' + align.otherEdge](align.otherOffset);
    return [targetAnchorPoint[0] - myAnchorPoint[0], targetAnchorPoint[1] - myAnchorPoint[1]];
  }, getAnchorPoint_t:function(offset) {
    return [this.x + Math.round(this.getWidth() * (offset / 100)), this.y];
  }, getAnchorPoint_b:function(offset) {
    return [this.x + Math.round(this.getWidth() * (offset / 100)), this.bottom];
  }, getAnchorPoint_l:function(offset) {
    return [this.x, this.y + Math.round(this.getHeight() * (offset / 100))];
  }, getAnchorPoint_r:function(offset) {
    return [this.right, this.y + Math.round(this.getHeight() * (offset / 100))];
  }, getAnchorPoint_c:function() {
    return [this.x + Math.round(this.getWidth() / 2), this.y + Math.round(this.getHeight() / 2)];
  }, getCenter:function() {
    return [this.x + this.width / 2, this.y + this.height / 2];
  }, getHeight:function() {
    return this.bottom - this.y;
  }, getWidth:function() {
    return this.right - this.x;
  }, getArea:function() {
    return this.getHeight() * this.getWidth();
  }, setHeight:function(h) {
    this.height = h;
    this.bottom = this.top + h;
    return this;
  }, setWidth:function(w) {
    this.width = w;
    this.right = this.left + w;
    return this;
  }, getSize:function() {
    return {width:this.right - this.x, height:this.bottom - this.y};
  }, setSize:function(w, h) {
    if (h === undefined) {
      h = w;
    }
    this.setWidth(w);
    return this.setHeight(h);
  }, copy:function() {
    return new this.self(this.y, this.right, this.bottom, this.x);
  }, copyFrom:function(p) {
    var me = this;
    me.top = me.y = me[1] = p.y;
    me.right = p.right;
    me.bottom = p.bottom;
    me.left = me.x = me[0] = p.x;
    return me;
  }, toString:function() {
    return 'Region[' + this.top + ',' + this.right + ',' + this.bottom + ',' + this.left + ']';
  }, translateBy:function(x, y) {
    if (x.length) {
      y = x[1];
      x = x[0];
    } else {
      if (arguments.length === 1) {
        y = x.y;
        x = x.x;
      }
    }
    var me = this;
    me.top = me.y += y;
    me.right += x;
    me.bottom += y;
    me.left = me.x += x;
    return me;
  }, round:function() {
    var me = this;
    me.top = me.y = Math.round(me.y);
    me.right = Math.round(me.right);
    me.bottom = Math.round(me.bottom);
    me.left = me.x = Math.round(me.x);
    return me;
  }, equals:function(region) {
    return this.top === region.top && this.right === region.right && this.bottom === region.bottom && this.left === region.left;
  }, getOffsetsTo:function(offsetsTo) {
    return {x:this.x - offsetsTo.x, y:this.y - offsetsTo.y};
  }};
}, 3, 0, 0, 0, 0, 0, [Ext.util, 'Region'], function(Region) {
  Region.prototype.getAlignInfo = Region.getAlignInfo;
  Region.EMPTY = new Region(0, 0, 0, 0);
});
Ext.cmd.derive('Ext.util.Point', Ext.util.Region, {isPoint:true, radianToDegreeConstant:180 / Math.PI, origin:{x:0, y:0}, statics:{fromEvent:function(e) {
  var changedTouches = e.changedTouches, touch = changedTouches && changedTouches.length > 0 ? changedTouches[0] : e;
  return this.fromTouch(touch);
}, fromTouch:function(touch) {
  return new this(touch.pageX, touch.pageY);
}, from:function(object) {
  if (!object) {
    return new this(0, 0);
  }
  if (!(object instanceof this)) {
    return new this(object.x, object.y);
  }
  return object;
}}, constructor:function(x, y) {
  if (x == null) {
    x = 0;
  }
  if (y == null) {
    y = 0;
  }
  Ext.util.Region.prototype.constructor.call(this, y, x, y, x);
}, clone:function() {
  return new this.self(this.x, this.y);
}, copy:function() {
  return this.clone.apply(this, arguments);
}, copyFrom:function(point) {
  this.x = point.x;
  this.y = point.y;
  return this;
}, toString:function() {
  return 'Point[' + this.x + ',' + this.y + ']';
}, equals:function(point) {
  return this.x === point.x && this.y === point.y;
}, isCloseTo:function(point, threshold) {
  if (typeof threshold == 'number') {
    return this.getDistanceTo(point) <= threshold;
  }
  var x = point.x, y = point.y, thresholdX = threshold.x, thresholdY = threshold.y;
  return this.x <= x + thresholdX && this.x >= x - thresholdX && this.y <= y + thresholdY && this.y >= y - thresholdY;
}, isWithin:function() {
  return this.isCloseTo.apply(this, arguments);
}, isContainedBy:function(region) {
  if (!(region instanceof Ext.util.Region)) {
    region = Ext.get(region.el || region).getRegion();
  }
  return region.contains(this);
}, roundedEquals:function(point) {
  if (!point || typeof point !== 'object') {
    point = this.origin;
  }
  return Math.round(this.x) === Math.round(point.x) && Math.round(this.y) === Math.round(point.y);
}, getDistanceTo:function(point) {
  if (!point || typeof point !== 'object') {
    point = this.origin;
  }
  var deltaX = this.x - point.x, deltaY = this.y - point.y;
  return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
}, getAngleTo:function(point) {
  if (!point || typeof point !== 'object') {
    point = this.origin;
  }
  var deltaX = this.x - point.x, deltaY = this.y - point.y;
  return Math.atan2(deltaY, deltaX) * this.radianToDegreeConstant;
}}, 3, 0, 0, 0, 0, 0, [Ext.util, 'Point'], function() {
  this.prototype.translate = this.prototype.translateBy;
});
Ext.cmd.derive('Ext.event.Event', Ext.Base, {alternateClassName:'Ext.EventObjectImpl', stopped:false, claimed:false, defaultPrevented:false, isEvent:true, geckoRelatedTargetEvents:{blur:1, dragenter:1, dragleave:1, focus:1}, statics:{resolveTextNode:function(node) {
  return node && node.nodeType === 3 ? node.parentNode : node;
}, gestureEvents:{}, pointerEvents:{pointerdown:1, pointermove:1, pointerup:1, pointercancel:1, pointerover:1, pointerout:1, pointerenter:1, pointerleave:1, MSPointerDown:1, MSPointerMove:1, MSPointerUp:1, MSPointerOver:1, MSPointerOut:1, MSPointerCancel:1, MSPointerEnter:1, MSPointerLeave:1}, mouseEvents:{mousedown:1, mousemove:1, mouseup:1, mouseover:1, mouseout:1, mouseenter:1, mouseleave:1}, clickEvents:{click:1, dblclick:1}, touchEvents:{touchstart:1, touchmove:1, touchend:1, touchcancel:1}, 
focusEvents:{focus:1, focusin:1, focusenter:1}, blurEvents:{blur:1, focusout:1, focusleave:1}, pointerTypeMap:{2:'touch', 3:'pen', 4:'mouse', touch:'touch', pen:'pen', mouse:'mouse'}, keyEventRe:/^key/, keyFlags:{CTRL:'ctrlKey', CONTROL:'ctrlKey', ALT:'altKey', SHIFT:'shiftKey', CMD:'metaKey', COMMAND:'metaKey', CMDORCTRL:Ext.isMac ? 'metaKey' : 'ctrlKey', COMMANDORCONTROL:Ext.isMac ? 'metaKey' : 'ctrlKey', META:'metaKey'}, modifierGlyphs:{ctrlKey:'⌃', altKey:'⌥', metaKey:Ext.isMac ? '⌘' : '⊞', shiftKey:'⇧'}, 
specialKeyGlyphs:{BACKSPACE:'⌫', TAB:'⇥', ENTER:'⏎', RETURN:'⏎', SPACE:'␣', PAGE_UP:'⇞', PAGE_DOWN:'⇟', END:'⇲', HOME:'⌂', LEFT:'←', UP:'↑', RIGHT:'→', DOWN:'↓', PRINT_SCREEN:'⎙', INSERT:'⎀', DELETE:'⌦', CONTEXT_MENU:'☰'}, _hyphenRe:/^[a-z]+\-/i, getKeyId:function(keyName) {
  if (typeof keyName === 'number') {
    keyName = this.keyCodes[keyName];
  } else {
    keyName = keyName.toUpperCase();
  }
  var me = this, delim = me._hyphenRe.test(keyName) ? '-' : '+', parts = keyName === delim ? [delim] : keyName.split(delim), numModifiers = parts.length - 1, rawKey = parts[numModifiers], result = [], eventFlag, i;
  for (i = 0; i < numModifiers; i++) {
    eventFlag = me.keyFlags[parts[i]];
    result[eventFlag] = true;
  }
  if (result.ctrlKey) {
    result.push(me.modifierGlyphs.ctrlKey);
  }
  if (result.altKey) {
    result.push(me.modifierGlyphs.altKey);
  }
  if (result.shiftKey) {
    result.push(me.modifierGlyphs.shiftKey);
  }
  if (result.metaKey) {
    result.push(me.modifierGlyphs.metaKey);
  }
  result.push(this.specialKeyGlyphs[rawKey] || rawKey);
  return result.join('');
}, globalTabKeyDown:function(e) {
  if (e.keyCode === 9) {
    Ext.event.Event.forwardTab = !e.shiftKey;
  }
}, globalTabKeyUp:function(e) {
  if (e.keyCode === 9) {
    delete Ext.event.Event.forwardTab;
  }
}}, constructor:function(event) {
  var me = this, self = me.self, resolveTextNode = me.self.resolveTextNode, changedTouches = event.changedTouches, coordinateOwner = changedTouches ? changedTouches[0] : event, type = event.type, pointerType, relatedTarget;
  me.timeStamp = me.time = Ext.now();
  me.pageX = coordinateOwner.pageX;
  me.pageY = coordinateOwner.pageY;
  me.clientX = coordinateOwner.clientX;
  me.clientY = coordinateOwner.clientY;
  me.target = me.delegatedTarget = resolveTextNode(event.target);
  me.currentTarget = resolveTextNode(event.currentTarget);
  relatedTarget = event.relatedTarget;
  if (relatedTarget) {
    if (Ext.isGecko && me.geckoRelatedTargetEvents[type]) {
      try {
        me.relatedTarget = resolveTextNode(relatedTarget);
      } catch (e$19) {
        me.relatedTarget = null;
      }
    } else {
      me.relatedTarget = resolveTextNode(relatedTarget);
    }
  }
  me.browserEvent = me.event = event;
  me.type = type;
  me.button = event.button || 0;
  me.shiftKey = event.shiftKey;
  me.ctrlKey = event.ctrlKey || event.metaKey || false;
  me.altKey = event.altKey;
  me.charCode = event.charCode;
  me.keyCode = event.keyCode;
  me.buttons = event.buttons;
  if (me.button === 0 && me.buttons === 0) {
    me.buttons = 1;
  }
  if (self.focusEvents[type] || self.blurEvents[type]) {
    if (self.forwardTab !== undefined) {
      me.forwardTab = self.forwardTab;
    }
    if (self.focusEvents[type]) {
      me.fromElement = event.relatedTarget;
      me.toElement = event.target;
    } else {
      me.fromElement = event.target;
      me.toElement = event.relatedTarget;
    }
  } else {
    if (type !== 'keydown') {
      delete self.forwardTab;
    }
  }
  if (self.mouseEvents[type]) {
    pointerType = 'mouse';
  } else {
    if (self.clickEvents[type]) {
      pointerType = self.pointerTypeMap[event.pointerType] || (Ext.now() - Ext.event.publisher.Dom.lastTouchEndTime < 1000 ? 'touch' : 'mouse');
    } else {
      if (self.pointerEvents[type]) {
        pointerType = self.pointerTypeMap[event.pointerType] || 'mouse';
      } else {
        if (self.touchEvents[type]) {
          pointerType = 'touch';
        }
      }
    }
  }
  if (pointerType) {
    me.pointerType = pointerType;
  }
  me.isMultitouch = event.isPrimary === false || event.touches && event.touches.length > 1;
}, chain:function(props) {
  var e = Ext.Object.chain(this);
  e.parentEvent = this;
  return Ext.apply(e, props);
}, correctWheelDelta:function(delta) {
  var scale = this.WHEEL_SCALE, ret = Math.round(delta / scale);
  if (!ret && delta) {
    ret = delta < 0 ? -1 : 1;
  }
  return ret;
}, getChar:function() {
  var r = this.which();
  return String.fromCharCode(r);
}, getCharCode:function() {
  return this.charCode || this.keyCode;
}, getKey:function() {
  return this.keyCode || this.charCode;
}, getKeyName:function() {
  return this.type === 'keypress' ? String.fromCharCode(this.getCharCode()) : this.keyCodes[this.keyCode];
}, key:function() {
  return this.browserEvent.key;
}, which:function() {
  var me = this, e = me.browserEvent, r = e.which;
  if (r == null) {
    if (me.self.keyEventRe.test(e.type)) {
      r = e.charCode || e.keyCode;
    } else {
      if ((r = e.button) !== undefined) {
        r = r & 1 ? 1 : r & 4 ? 2 : r & 2 ? 3 : 0;
      }
    }
  }
  return r;
}, getClipboardData:function(type) {
  var clipboardData = this.browserEvent.clipboardData, clipIE = Ext.global.clipboardData, result = null, typeIE;
  type = type || 'text/plain';
  if (clipboardData && clipboardData.getData) {
    result = clipboardData.getData(type);
  } else {
    if (clipIE && clipIE.getData) {
      typeIE = this.ieMimeType[type];
      if (typeIE) {
        result = clipIE.getData(typeIE);
      }
    }
  }
  return result;
}, getPoint:function() {
  var me = this, point = me.point, xy;
  if (!point) {
    xy = me.getXY();
    point = me.point = new Ext.util.Point(xy[0], xy[1]);
  }
  return point;
}, getRelatedTarget:function(selector, maxDepth, returnEl) {
  var relatedTarget = this.relatedTarget, target = null;
  if (relatedTarget && relatedTarget.nodeType) {
    if (selector) {
      target = Ext.fly(relatedTarget).findParent(selector, maxDepth, returnEl);
    } else {
      target = returnEl ? Ext.get(relatedTarget) : relatedTarget;
    }
  }
  return target;
}, getTarget:function(selector, maxDepth, returnEl) {
  return selector ? Ext.fly(this.target).findParent(selector, maxDepth, returnEl) : returnEl ? Ext.get(this.target) : this.target;
}, getTime:function() {
  return this.time;
}, getWheelDelta:function() {
  var deltas = this.getWheelDeltas();
  return deltas.y;
}, getWheelDeltas:function() {
  var me = this, event = me.browserEvent, dx = 0, dy = 0;
  if (Ext.isDefined(event.wheelDeltaX)) {
    dx = event.wheelDeltaX;
    dy = event.wheelDeltaY;
  } else {
    if (event.wheelDelta) {
      dy = event.wheelDelta;
    } else {
      if ('deltaX' in event) {
        dx = event.deltaX;
        dy = -event.deltaY;
      } else {
        if (event.detail) {
          dy = -event.detail;
          if (dy > 100) {
            dy = 3;
          } else {
            if (dy < -100) {
              dy = -3;
            }
          }
          if (Ext.isDefined(event.axis) && event.axis === event.HORIZONTAL_AXIS) {
            dx = dy;
            dy = 0;
          }
        }
      }
    }
  }
  return {x:me.correctWheelDelta(dx), y:me.correctWheelDelta(dy)};
}, getX:function() {
  return this.getXY()[0];
}, getXY:function() {
  var me = this, xy = me.xy;
  if (!xy) {
    xy = me.xy = [me.pageX, me.pageY];
    var x = xy[0], browserEvent, doc, docEl, body;
    if (!x && x !== 0) {
      browserEvent = me.browserEvent;
      doc = document;
      docEl = doc.documentElement;
      body = doc.body;
      xy[0] = browserEvent.clientX + (docEl && docEl.scrollLeft || body && body.scrollLeft || 0) - (docEl && docEl.clientLeft || body && body.clientLeft || 0);
      xy[1] = browserEvent.clientY + (docEl && docEl.scrollTop || body && body.scrollTop || 0) - (docEl && docEl.clientTop || body && body.clientTop || 0);
    }
  }
  return xy;
}, getY:function() {
  return this.getXY()[1];
}, hasModifier:function() {
  var me = this;
  return !!(me.ctrlKey || me.altKey || me.shiftKey || me.metaKey);
}, isNavKeyPress:function(scrollableOnly) {
  var me = this, k = me.keyCode, isKeyPress = me.type === 'keypress';
  return (!isKeyPress || Ext.isGecko) && k >= 33 && k <= 40 || !scrollableOnly && (k === me.RETURN || k === me.TAB || k === me.ESC);
}, isSpecialKey:function() {
  var me = this, k = me.keyCode, isGecko = Ext.isGecko, isKeyPress = me.type === 'keypress';
  return isGecko && isKeyPress && me.charCode === 0 || this.isNavKeyPress() || k === me.BACKSPACE || k === me.ENTER || k >= 16 && k <= 20 || (!isKeyPress || isGecko) && k >= 44 && k <= 46;
}, makeUnpreventable:function() {
  this.browserEvent.preventDefault = Ext.emptyFn;
}, preventDefault:function() {
  var me = this, parentEvent = me.parentEvent;
  me.defaultPrevented = true;
  if (parentEvent) {
    parentEvent.defaultPrevented = true;
  }
  me.browserEvent.preventDefault();
  return me;
}, setCurrentTarget:function(target) {
  this.currentTarget = this.delegatedTarget = target;
}, stopEvent:function() {
  return this.preventDefault().stopPropagation();
}, mousedownEvents:{mousedown:1, pointerdown:1, touchstart:1}, mouseupEvents:{mouseup:1, pointerup:1, touchend:1}, stopPropagation:function() {
  var me = this, browserEvent = me.browserEvent, parentEvent = me.parentEvent;
  if (me.mousedownEvents[me.type]) {
    Ext.GlobalEvents.fireMouseDown(me);
  }
  if (me.mouseupEvents[me.type]) {
    Ext.GlobalEvents.fireMouseUp(me);
  }
  me.stopped = true;
  if (parentEvent && !me.isGesture) {
    parentEvent.stopped = true;
  }
  if (!browserEvent.stopPropagation) {
    browserEvent.cancelBubble = true;
    return me;
  }
  browserEvent.stopPropagation();
  return me;
}, claimGesture:function() {
  var me = this, parentEvent = me.parentEvent;
  me.claimed = true;
  if (parentEvent && !me.isGesture) {
    parentEvent.claimGesture();
  } else {
    me.preventDefault();
  }
  return me;
}, within:function(el, related, allowEl) {
  var t;
  if (el) {
    t = related ? this.getRelatedTarget() : this.getTarget();
  }
  if (!t || allowEl === false && t === Ext.getDom(el)) {
    return false;
  }
  return Ext.fly(el).contains(t);
}, privates:{ieMimeType:{'text/plain':'Text'}}, deprecated:{'4.0':{methods:{getPageX:'getX', getPageY:'getY'}}}}, 1, 0, 0, 0, 0, 0, [Ext.event, 'Event', Ext, 'EventObjectImpl'], function(Event) {
  var constants = {BACKSPACE:8, TAB:9, NUM_CENTER:12, ENTER:13, RETURN:13, SHIFT:16, CTRL:17, ALT:18, PAUSE:19, CAPS_LOCK:20, ESC:27, SPACE:32, PAGE_UP:33, PAGE_DOWN:34, END:35, HOME:36, LEFT:37, UP:38, RIGHT:39, DOWN:40, PRINT_SCREEN:44, INSERT:45, DELETE:46, ZERO:48, ONE:49, TWO:50, THREE:51, FOUR:52, FIVE:53, SIX:54, SEVEN:55, EIGHT:56, NINE:57, A:65, B:66, C:67, D:68, E:69, F:70, G:71, H:72, I:73, J:74, K:75, L:76, M:77, N:78, O:79, P:80, Q:81, R:82, S:83, T:84, U:85, V:86, W:87, X:88, Y:89, 
  Z:90, META:91, CONTEXT_MENU:93, NUM_ZERO:96, NUM_ONE:97, NUM_TWO:98, NUM_THREE:99, NUM_FOUR:100, NUM_FIVE:101, NUM_SIX:102, NUM_SEVEN:103, NUM_EIGHT:104, NUM_NINE:105, NUM_MULTIPLY:106, NUM_PLUS:107, NUM_MINUS:109, NUM_PERIOD:110, NUM_DIVISION:111, F1:112, F2:113, F3:114, F4:115, F5:116, F6:117, F7:118, F8:119, F9:120, F10:121, F11:122, F12:123, WHEEL_SCALE:120}, keyCodes = {}, gestureEvents = Event.gestureEvents, prototype = Event.prototype, i, keyName, keyCode, keys, s, scale;
  if (Ext.isGecko) {
    constants.WHEEL_SCALE = 3;
  } else {
    if (Ext.isMac) {
      if (Ext.isSafari && Ext.webKitVersion >= 532) {
        scale = 120;
      } else {
        scale = 12;
      }
      constants.WHEEL_SCALE = 3 * scale;
    }
  }
  Ext.apply(gestureEvents, Event.mouseEvents);
  Ext.apply(gestureEvents, Event.pointerEvents);
  Ext.apply(gestureEvents, Event.touchEvents);
  Ext.apply(Event, constants);
  Ext.apply(prototype, constants);
  delete constants.WHEEL_SCALE;
  delete constants.RETURN;
  for (keyName in constants) {
    keyCode = constants[keyName];
    keyCodes[keyCode] = keyName;
  }
  Event.keyCodes = prototype.keyCodes = keyCodes;
  if (!Ext.isIE9m) {
    document.addEventListener('keydown', Event.globalTabKeyDown, true);
    document.addEventListener('keyup', Event.globalTabKeyUp, true);
  }
  prototype.getTrueXY = prototype.getXY;
  if (typeof KeyboardEvent !== 'undefined' && !('key' in KeyboardEvent.prototype)) {
    prototype._keys = keys = {3:'Cancel', 6:'Help', 8:'Backspace', 9:'Tab', 12:'Clear', 13:'Enter', 16:'Shift', 17:'Control', 18:'Alt', 19:'Pause', 20:'CapsLock', 27:'Escape', 28:'Convert', 29:'NonConvert', 30:'Accept', 31:'ModeChange', 32:' ', 33:'PageUp', 34:'PageDown', 35:'End', 36:'Home', 37:'ArrowLeft', 38:'ArrowUp', 39:'ArrowRight', 40:'ArrowDown', 41:'Select', 42:'Print', 43:'Execute', 44:'PrintScreen', 45:'Insert', 46:'Delete', 48:['0', ')'], 49:['1', '!'], 50:['2', '@'], 51:['3', '#'], 52:['4', 
    '$'], 53:['5', '%'], 54:['6', '^'], 55:['7', '\x26'], 56:['8', '*'], 57:['9', '('], 91:'OS', 93:'ContextMenu', 144:'NumLock', 145:'ScrollLock', 181:'VolumeMute', 182:'VolumeDown', 183:'VolumeUp', 186:[';', ':'], 187:['\x3d', '+'], 188:[',', '\x3c'], 189:['-', '_'], 190:['.', '\x3e'], 191:['/', '?'], 192:['`', '~'], 219:['[', '{'], 220:['\\', '|'], 221:[']', '}'], 222:["'", '"'], 224:'Meta', 225:'AltGraph', 246:'Attn', 247:'CrSel', 248:'ExSel', 249:'EraseEof', 250:'Play', 251:'ZoomOut'};
    for (i = 1; i < 25; ++i) {
      keys[i + 111] = 'F' + i;
    }
    for (i = 0; i < 26; ++i) {
      keys[i] = [String.fromCharCode(i + 97), String.fromCharCode(i + 65)];
    }
    prototype.key = function() {
      var k = keys[this.browserEvent.which || this.keyCode];
      if (k && typeof k !== 'string') {
        k = k[+this.shiftKey];
      }
      return k;
    };
  }
});
Ext.define('Ext.overrides.event.Event', {override:'Ext.event.Event', injectEvent:function() {
  var API, dispatchers = {}, crazyIEButtons;
  if (!Ext.isIE9m && document.createEvent) {
    API = {createHtmlEvent:function(doc, type, bubbles, cancelable) {
      var event = doc.createEvent('HTMLEvents');
      event.initEvent(type, bubbles, cancelable);
      return event;
    }, createMouseEvent:function(doc, type, bubbles, cancelable, detail, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
      var event = doc.createEvent('MouseEvents'), view = doc.defaultView || window;
      if (event.initMouseEvent) {
        event.initMouseEvent(type, bubbles, cancelable, view, detail, clientX, clientY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget);
      } else {
        event = doc.createEvent('UIEvents');
        event.initEvent(type, bubbles, cancelable);
        event.view = view;
        event.detail = detail;
        event.screenX = clientX;
        event.screenY = clientY;
        event.clientX = clientX;
        event.clientY = clientY;
        event.ctrlKey = ctrlKey;
        event.altKey = altKey;
        event.metaKey = metaKey;
        event.shiftKey = shiftKey;
        event.button = button;
        event.relatedTarget = relatedTarget;
      }
      return event;
    }, createUIEvent:function(doc, type, bubbles, cancelable, detail) {
      var event = doc.createEvent('UIEvents'), view = doc.defaultView || window;
      event.initUIEvent(type, bubbles, cancelable, view, detail);
      return event;
    }, fireEvent:function(target, type, event) {
      target.dispatchEvent(event);
    }};
  } else {
    if (document.createEventObject) {
      crazyIEButtons = {0:1, 1:4, 2:2};
      API = {createHtmlEvent:function(doc, type, bubbles, cancelable) {
        var event = doc.createEventObject();
        event.bubbles = bubbles;
        event.cancelable = cancelable;
        return event;
      }, createMouseEvent:function(doc, type, bubbles, cancelable, detail, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
        var event = doc.createEventObject();
        event.bubbles = bubbles;
        event.cancelable = cancelable;
        event.detail = detail;
        event.screenX = clientX;
        event.screenY = clientY;
        event.clientX = clientX;
        event.clientY = clientY;
        event.ctrlKey = ctrlKey;
        event.altKey = altKey;
        event.shiftKey = shiftKey;
        event.metaKey = metaKey;
        event.button = crazyIEButtons[button] || button;
        event.relatedTarget = relatedTarget;
        return event;
      }, createUIEvent:function(doc, type, bubbles, cancelable, detail) {
        var event = doc.createEventObject();
        event.bubbles = bubbles;
        event.cancelable = cancelable;
        return event;
      }, fireEvent:function(target, type, event) {
        target.fireEvent('on' + type, event);
      }};
    }
  }
  Ext.Object.each({load:[false, false], unload:[false, false], select:[true, false], change:[true, false], submit:[true, true], reset:[true, false], resize:[true, false], scroll:[true, false]}, function(name, value) {
    var bubbles = value[0], cancelable = value[1];
    dispatchers[name] = function(targetEl, srcEvent) {
      var e = API.createHtmlEvent(name, bubbles, cancelable);
      API.fireEvent(targetEl, name, e);
    };
  });
  function createMouseEventDispatcher(type, detail) {
    var cancelable = type !== 'mousemove';
    return function(targetEl, srcEvent) {
      var xy = srcEvent.getXY(), e = API.createMouseEvent(targetEl.ownerDocument, type, true, cancelable, detail, xy[0], xy[1], srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button, srcEvent.relatedTarget);
      API.fireEvent(targetEl, type, e);
    };
  }
  Ext.each(['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mousemove', 'mouseout'], function(eventName) {
    dispatchers[eventName] = createMouseEventDispatcher(eventName, 1);
  });
  Ext.Object.each({focusin:[true, false], focusout:[true, false], activate:[true, true], focus:[false, false], blur:[false, false]}, function(name, value) {
    var bubbles = value[0], cancelable = value[1];
    dispatchers[name] = function(targetEl, srcEvent) {
      var e = API.createUIEvent(targetEl.ownerDocument, name, bubbles, cancelable, 1);
      API.fireEvent(targetEl, name, e);
    };
  });
  if (!API) {
    dispatchers = {};
    API = {};
  }
  function cannotInject(target, srcEvent) {
  }
  return function(target) {
    var me = this, dispatcher = dispatchers[me.type] || cannotInject, t = target ? target.dom || target : me.getTarget();
    dispatcher(t, me);
  };
}(), preventDefault:function(browserOnly) {
  var me = this, event = me.browserEvent, parentEvent = me.parentEvent, unselectable, target, fn;
  if (typeof event.type !== 'unknown') {
    if (!browserOnly) {
      me.defaultPrevented = true;
    }
    if (parentEvent) {
      parentEvent.defaultPrevented = true;
    }
    if (event.preventDefault) {
      event.preventDefault();
    } else {
      if (event.type === 'mousedown') {
        target = event.target;
        unselectable = target.getAttribute('unselectable');
        if (unselectable !== 'on') {
          target.setAttribute('unselectable', 'on');
          fn = function() {
            target.setAttribute('unselectable', unselectable);
          };
          Ext.defer(fn, 1);
        }
      }
      event.returnValue = false;
      if (event.ctrlKey || event.keyCode > 111 && event.keyCode < 124) {
        event.keyCode = -1;
      }
    }
  }
  return me;
}, deprecated:{'5.0':{methods:{clone:function() {
  return new this.self(this.browserEvent, this);
}}}}}, function() {
  var Event = this, btnMap;
  if (Ext.isIE9m) {
    btnMap = {0:0, 1:0, 4:1, 2:2};
    Event.override({statics:{enableIEAsync:function(browserEvent) {
      var name, fakeEvent = {};
      for (name in browserEvent) {
        fakeEvent[name] = browserEvent[name];
      }
      return fakeEvent;
    }}, constructor:function(event, info, touchesMap, identifiers) {
      var me = this;
      me.callParent([event, info, touchesMap, identifiers]);
      me.button = btnMap[event.button];
      if (event.type === 'contextmenu') {
        me.button = 2;
      }
      me.toElement = event.toElement;
      me.fromElement = event.fromElement;
    }, mouseLeaveRe:/(mouseout|mouseleave)/, mouseEnterRe:/(mouseover|mouseenter)/, enableIEAsync:function(browserEvent) {
      this.browserEvent = this.self.enableIEAsync(browserEvent);
    }, getRelatedTarget:function(selector, maxDepth, returnEl) {
      var me = this, type, target;
      if (!me.relatedTarget) {
        type = me.type;
        if (me.mouseLeaveRe.test(type)) {
          target = me.toElement;
        } else {
          if (me.mouseEnterRe.test(type)) {
            target = me.fromElement;
          }
        }
        if (target) {
          me.relatedTarget = me.self.resolveTextNode(target);
        }
      }
      return me.callParent([selector, maxDepth, returnEl]);
    }});
    document.attachEvent('onkeydown', Ext.event.Event.globalTabKeyDown);
    document.attachEvent('onkeyup', Ext.event.Event.globalTabKeyUp);
    window.attachEvent('onunload', function() {
      document.detachEvent('onkeydown', Ext.event.Event.globalTabKeyDown);
      document.detachEvent('onkeyup', Ext.event.Event.globalTabKeyUp);
    });
  }
});
Ext.cmd.derive('Ext.event.publisher.Dom', Ext.event.publisher.Publisher, {type:'dom', handledDomEvents:[], reEnterCount:0, captureEvents:{animationstart:1, animationend:1, resize:1, focus:1, blur:1}, directEvents:{mouseenter:1, mouseleave:1, pointerenter:1, pointerleave:1, MSPointerEnter:1, MSPointerLeave:1, load:1, unload:1, beforeunload:1, error:1, DOMContentLoaded:1, DOMFrameContentLoaded:1, hashchange:1, scroll:1, online:1, offline:1}, blockedPointerEvents:{pointerover:1, pointerout:1, pointerenter:1, 
pointerleave:1, MSPointerOver:1, MSPointerOut:1, MSPointerEnter:1, MSPointerLeave:1}, blockedCompatibilityMouseEvents:{mouseenter:1, mouseleave:1}, constructor:function() {
  var me = this, supportsPassive = Ext.supports.PassiveEventListener;
  me.listenerOptions = supportsPassive ? {passive:false} : false;
  me.captureOptions = supportsPassive ? {passive:false, capture:true} : true;
  me.bubbleSubscribers = {};
  me.captureSubscribers = {};
  me.directSubscribers = {};
  me.directCaptureSubscribers = {};
  me.delegatedListeners = {};
  me.initHandlers();
  Ext.onInternalReady(me.onReady, me);
  Ext.event.publisher.Publisher.prototype.constructor.call(this);
  me.registerDomEvents();
}, registerDomEvents:function() {
  var me = this, publishersByEvent = Ext.event.publisher.Publisher.publishersByEvent, domEvents = me.handledDomEvents, ln = domEvents.length, i, eventName;
  for (i = 0; i < ln; i++) {
    eventName = domEvents[i];
    me.handles[eventName] = 1;
    publishersByEvent[eventName] = me;
  }
}, onReady:function() {
  var me = this, domEvents = me.handledDomEvents, ln, i;
  if (domEvents) {
    for (i = 0, ln = domEvents.length; i < ln; i++) {
      me.addDelegatedListener(domEvents[i]);
    }
  }
  Ext.getWin().on('unload', me.destroy, me, {priority:-10000});
}, initHandlers:function() {
  var me = this;
  me.onDelegatedEvent = Ext.bind(me.onDelegatedEvent, me);
  me.onDirectEvent = Ext.bind(me.onDirectEvent, me);
  me.onDirectCaptureEvent = Ext.bind(me.onDirectCaptureEvent, me);
}, addDelegatedListener:function(eventName) {
  var me = this;
  me.delegatedListeners[eventName] = 1;
  me.target.addEventListener(eventName, me.onDelegatedEvent, me.captureEvents[eventName] ? me.captureOptions : me.listenerOptions);
}, removeDelegatedListener:function(eventName) {
  var me = this;
  delete me.delegatedListeners[eventName];
  me.target.removeEventListener(eventName, me.onDelegatedEvent, me.captureEvents[eventName] ? me.captureOptions : me.listenerOptions);
}, addDirectListener:function(eventName, element, capture) {
  var me = this;
  element.dom.addEventListener(eventName, capture ? me.onDirectCaptureEvent : me.onDirectEvent, capture ? me.captureOptions : me.listenerOptions);
}, removeDirectListener:function(eventName, element, capture) {
  var me = this;
  element.dom.removeEventListener(eventName, capture ? me.onDirectCaptureEvent : me.onDirectEvent, capture ? me.captureOptions : me.listenerOptions);
}, subscribe:function(element, eventName, delegated, capture) {
  var me = this, subscribers, id;
  if (delegated && !me.directEvents[eventName]) {
    subscribers = capture ? me.captureSubscribers : me.bubbleSubscribers;
    if (!me.handles[eventName] && !me.delegatedListeners[eventName]) {
      me.addDelegatedListener(eventName);
    }
    if (subscribers[eventName]) {
      ++subscribers[eventName];
    } else {
      subscribers[eventName] = 1;
    }
  } else {
    subscribers = capture ? me.directCaptureSubscribers : me.directSubscribers;
    id = element.id;
    subscribers = subscribers[eventName] || (subscribers[eventName] = {});
    if (subscribers[id]) {
      ++subscribers[id];
    } else {
      subscribers[id] = 1;
      me.addDirectListener(eventName, element, capture);
    }
  }
}, unsubscribe:function(element, eventName, delegated, capture) {
  var me = this, captureSubscribers, bubbleSubscribers, subscribers, id;
  if (delegated && !me.directEvents[eventName]) {
    captureSubscribers = me.captureSubscribers;
    bubbleSubscribers = me.bubbleSubscribers;
    subscribers = capture ? captureSubscribers : bubbleSubscribers;
    if (subscribers[eventName]) {
      --subscribers[eventName];
    }
    if (!me.handles[eventName] && !bubbleSubscribers[eventName] && !captureSubscribers[eventName]) {
      this.removeDelegatedListener(eventName);
    }
  } else {
    subscribers = capture ? me.directCaptureSubscribers : me.directSubscribers;
    id = element.id;
    subscribers = subscribers[eventName];
    if (subscribers[id]) {
      --subscribers[id];
    }
    if (!subscribers[id]) {
      delete subscribers[id];
      me.removeDirectListener(eventName, element, capture);
    }
  }
}, getPropagatingTargets:function(target) {
  var currentNode = target, targets = [], parentNode;
  while (currentNode) {
    targets.push(currentNode);
    parentNode = currentNode.parentNode;
    if (!parentNode) {
      parentNode = currentNode.defaultView;
    }
    currentNode = parentNode;
  }
  return targets;
}, publish:function(e, targets, claimed) {
  var me = this, hasCaptureSubscribers = false, hasBubbleSubscribers = false, events, type, target, el, i, ln, j, eLn;
  claimed = claimed || false;
  if (!targets) {
    target = e.target;
    if (me.captureEvents[e.type]) {
      el = Ext.cache[target.id];
      targets = el ? [el] : [];
    } else {
      targets = me.getPropagatingTargets(target);
    }
  }
  events = Ext.Array.from(e);
  ln = targets.length;
  eLn = events.length;
  for (i = 0; i < eLn; i++) {
    type = events[i].type;
    if (!hasCaptureSubscribers && me.captureSubscribers[type]) {
      hasCaptureSubscribers = true;
    }
    if (!hasBubbleSubscribers && me.bubbleSubscribers[type]) {
      hasBubbleSubscribers = true;
    }
  }
  if (hasCaptureSubscribers) {
    for (i = ln; i--;) {
      el = Ext.cache[targets[i].id];
      if (el) {
        for (j = 0; j < eLn; j++) {
          e = events[j];
          me.fire(el, e.type, e, false, true);
          if (!claimed && e.claimed) {
            claimed = true;
            j = me.filterClaimed(events, e);
            eLn = events.length;
          }
          if (e.stopped) {
            events.splice(j, 1);
            j--;
            eLn--;
          }
        }
      }
    }
  }
  if (hasBubbleSubscribers && !e.stopped) {
    for (i = 0; i < ln; i++) {
      el = Ext.cache[targets[i].id];
      if (el) {
        for (j = 0; j < eLn; j++) {
          e = events[j];
          me.fire(el, e.type, e, false, false);
          if (!claimed && e.claimed && me.filterClaimed) {
            claimed = true;
            j = me.filterClaimed(events, e);
            eLn = events.length;
          }
          if (e.stopped) {
            events.splice(j, 1);
            j--;
            eLn--;
          }
        }
      }
    }
  }
}, publishDelegatedDomEvent:function(e) {
  this.publish(e);
}, fire:function(element, eventName, e, direct, capture) {
  var event;
  if (element.hasListeners[eventName]) {
    event = element.events[eventName];
    if (event) {
      if (capture && direct) {
        event = event.directCaptures;
      } else {
        if (capture) {
          event = event.captures;
        } else {
          if (direct) {
            event = event.directs;
          }
        }
      }
      if (event) {
        e.setCurrentTarget(element.dom);
        event.fire(e, e.target);
      }
    }
  }
}, onDelegatedEvent:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doDelegatedEvent, this, [e]);
  } else {
    this.doDelegatedEvent(e);
  }
}, doDelegatedEvent:function(e) {
  var me = this, timeStamp;
  e = new Ext.event.Event(e);
  timeStamp = e.time;
  if (!me.isEventBlocked(e)) {
    me.beforeEvent(e);
    Ext.frameStartTime = timeStamp;
    me.reEnterCountAdjusted = false;
    me.reEnterCount++;
    me.publishDelegatedDomEvent(e);
    if (!me.reEnterCountAdjusted) {
      me.reEnterCount--;
    }
    me.afterEvent(e);
  }
}, onDirectEvent:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doDirectEvent, this, [e, false]);
  } else {
    this.doDirectEvent(e, false);
  }
}, onDirectCaptureEvent:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doDirectEvent, this, [e, true]);
  } else {
    this.doDirectEvent(e, true);
  }
}, doDirectEvent:function(e, capture) {
  var me = this, currentTarget = e.currentTarget, timeStamp, el;
  e = new Ext.event.Event(e);
  timeStamp = e.time;
  if (me.isEventBlocked(e)) {
    return;
  }
  me.beforeEvent(e);
  Ext.frameStartTime = timeStamp;
  el = Ext.cache[currentTarget.id];
  if (el) {
    me.reEnterCountAdjusted = false;
    me.reEnterCount++;
    me.fire(el, e.type, e, true, capture);
    if (!me.reEnterCountAdjusted) {
      me.reEnterCount--;
    }
  }
  me.afterEvent(e);
}, beforeEvent:function(e) {
  var browserEvent = e.browserEvent, self = Ext.event.publisher.Dom, touches, touch;
  if (browserEvent.type === 'touchstart') {
    touches = browserEvent.touches;
    if (touches.length === 1) {
      touch = touches[0];
      self.lastTouchStartX = touch.pageX;
      self.lastTouchStartY = touch.pageY;
    }
  }
}, afterEvent:function(e) {
  var browserEvent = e.browserEvent, type = browserEvent.type, self = Ext.event.publisher.Dom, GlobalEvents = Ext.GlobalEvents;
  if (e.self.pointerEvents[type] && e.pointerType !== 'mouse') {
    self.lastScreenPointerEventTime = Ext.now();
  }
  if (type === 'touchend') {
    self.lastTouchEndTime = Ext.now();
  }
  if (!this.reEnterCount && !GlobalEvents.idleEventMask[type]) {
    Ext.fireIdle();
  }
}, isEventBlocked:function(e) {
  var me = this, type = e.type, self = Ext.event.publisher.Dom, now = Ext.now();
  if (Ext.isGecko && e.type === 'click' && e.button === 2) {
    return true;
  }
  return me.blockedPointerEvents[type] && e.pointerType !== 'mouse' || me.blockedCompatibilityMouseEvents[type] && now - self.lastScreenPointerEventTime < 1000 || Ext.supports.TouchEvents && e.self.mouseEvents[e.type] && Math.abs(e.pageX - self.lastTouchStartX) < 15 && Math.abs(e.pageY - self.lastTouchStartY) < 15 && Ext.now() - self.lastTouchEndTime < 1000;
}, destroy:function() {
  var GC = Ext.dom['GarbageCollector'], eventName;
  for (eventName in this.delegatedListeners) {
    this.removeDelegatedListener(eventName);
  }
  Ext.Reaper.flush();
  if (GC) {
    GC.collect();
  }
  this.callParent();
}, reset:function() {
  var self = Ext.event.publisher.Dom;
  this.reEnterCount = 0;
  self.lastScreenPointerEventTime = self.lastTouchEndTime = self.lastTouchStartX = self.lastTouchStartY = undefined;
}}, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, 'Dom'], function(Dom) {
  var doc = document, defaultView = doc.defaultView, prototype = Dom.prototype;
  if (Ext.os.is.iOS && Ext.os.version.getMajor() < 5 || Ext.browser.is.AndroidStock || !(defaultView && defaultView.addEventListener)) {
    prototype.target = doc;
  } else {
    prototype.target = defaultView;
  }
  Dom.instance = new Dom;
});
Ext.define('Ext.overrides.event.publisher.Dom', {override:'Ext.event.publisher.Dom'}, function(DomPublisher) {
  var focusEvents = {focus:true, focusin:true, focusout:true, blur:true};
  if (Ext.isIE10m) {
    DomPublisher.override({isEventBlocked:function(e) {
      if (!focusEvents[e.type]) {
        return this.callParent([e]);
      }
      var body = document.body, ev = e.browserEvent, el = Ext.synchronouslyFocusing;
      if (el && (ev.type === 'focusout' && (ev.srcElement === el || ev.srcElement === window) && ev.toElement === body || ev.type === 'focusin' && (ev.srcElement === body || ev.srcElement === window) && ev.fromElement === el && ev.toElement === null)) {
        return true;
      }
      return false;
    }});
  }
  if (Ext.isIE9m) {
    var docElement = document.documentElement, docBody = document.body, prototype = DomPublisher.prototype, onDirectEvent, onDirectCaptureEvent;
    prototype.target = document;
    prototype.directBoundListeners = {};
    onDirectEvent = function(e, publisher, capture) {
      e.target = e.srcElement || window;
      e.currentTarget = this;
      if (capture) {
        publisher.onDirectCaptureEvent(e);
      } else {
        publisher.onDirectEvent(e);
      }
    };
    onDirectCaptureEvent = function(e, publisher) {
      e.target = e.srcElement || window;
      e.currentTarget = this;
      publisher.onDirectCaptureEvent(e);
    };
    DomPublisher.override({addDelegatedListener:function(eventName) {
      this.delegatedListeners[eventName] = 1;
      this.target.attachEvent('on' + eventName, this.onDelegatedEvent);
    }, removeDelegatedListener:function(eventName) {
      delete this.delegatedListeners[eventName];
      this.target.detachEvent('on' + eventName, this.onDelegatedEvent);
    }, addDirectListener:function(eventName, element, capture) {
      var me = this, dom = element.dom, boundFn = Ext.Function.bind(onDirectEvent, dom, [me, capture], true), directBoundListeners = me.directBoundListeners, handlers = directBoundListeners[eventName] || (directBoundListeners[eventName] = {});
      handlers[dom.id] = boundFn;
      if (dom.attachEvent) {
        dom.attachEvent('on' + eventName, boundFn);
      } else {
        me.callParent([eventName, element, capture]);
      }
    }, removeDirectListener:function(eventName, element, capture) {
      var dom = element.dom;
      if (dom.detachEvent) {
        dom.detachEvent('on' + eventName, this.directBoundListeners[eventName][dom.id]);
      } else {
        this.callParent([eventName, element, capture]);
      }
    }, doDelegatedEvent:function(e) {
      e.target = e.srcElement || window;
      if (e.type === 'focusin') {
        e.relatedTarget = e.fromElement === docBody || e.fromElement === docElement ? null : e.fromElement;
      } else {
        if (e.type === 'focusout') {
          e.relatedTarget = e.toElement === docBody || e.toElement === docElement ? null : e.toElement;
        }
      }
      return this.callParent([e]);
    }});
    Ext.apply(prototype.directEvents, prototype.captureEvents);
    Ext.apply(prototype.directEvents, {change:1, input:1, paste:1});
    prototype.captureEvents = {};
  }
});
Ext.cmd.derive('Ext.event.publisher.Gesture', Ext.event.publisher.Dom, {type:'gesture', isCancelEvent:{touchcancel:1, pointercancel:1, MSPointerCancel:1}, isEndEvent:{mouseup:1, touchend:1, pointerup:1, MSPointerUp:1}, handledEvents:[], handledDomEvents:[], constructor:function(config) {
  var me = this, handledDomEvents = me.handledDomEvents, supports = Ext.supports, supportsTouchEvents = supports.TouchEvents, onTouchStart = me.onTouchStart, onTouchMove = me.onTouchMove, onTouchEnd = me.onTouchEnd;
  me.handlers = {touchstart:onTouchStart, touchmove:onTouchMove, touchend:onTouchEnd, touchcancel:onTouchEnd, pointerdown:onTouchStart, pointermove:onTouchMove, pointerup:onTouchEnd, pointercancel:onTouchEnd, MSPointerDown:onTouchStart, MSPointerMove:onTouchMove, MSPointerUp:onTouchEnd, MSPointerCancel:onTouchEnd, mousedown:onTouchStart, mousemove:onTouchMove, mouseup:onTouchEnd};
  me.activeTouchesMap = {};
  me.activeTouches = [];
  me.changedTouches = [];
  me.recognizers = [];
  me.eventToRecognizer = {};
  me.cancelEvents = [];
  if (supportsTouchEvents) {
    me.onTargetTouchMove = me.onTargetTouchMove.bind(me);
    me.onTargetTouchEnd = me.onTargetTouchEnd.bind(me);
  }
  if (supports.PointerEvents) {
    handledDomEvents.push('pointerdown', 'pointermove', 'pointerup', 'pointercancel');
    me.mousePointerType = 'mouse';
  } else {
    if (supports.MSPointerEvents) {
      handledDomEvents.push('MSPointerDown', 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel');
      me.mousePointerType = 4;
    } else {
      if (supportsTouchEvents) {
        handledDomEvents.push('touchstart', 'touchmove', 'touchend', 'touchcancel');
      }
    }
  }
  if (!handledDomEvents.length || supportsTouchEvents && Ext.os.is.Desktop) {
    handledDomEvents.push('mousedown', 'mousemove', 'mouseup');
  }
  me.initConfig(config);
  return Ext.event.publisher.Dom.prototype.constructor.call(this);
}, onReady:function() {
  Ext.event.publisher.Dom.prototype.onReady.call(this);
  Ext.Array.sort(this.recognizers, function(recognizerA, recognizerB) {
    var a = recognizerA.priority, b = recognizerB.priority;
    return a > b ? 1 : a < b ? -1 : 0;
  });
}, registerRecognizer:function(recognizer) {
  var me = this, handledEvents = recognizer.handledEvents, ln = handledEvents.length, eventName, i;
  recognizer.setOnRecognized(me.onRecognized);
  recognizer.setCallbackScope(me);
  for (i = 0; i < ln; i++) {
    eventName = handledEvents[i];
    me.handledEvents.push(eventName);
    me.eventToRecognizer[eventName] = recognizer;
  }
  me.registerEvents(handledEvents);
  me.recognizers.push(recognizer);
}, onRecognized:function(recognizer, eventName, e, info, isCancel) {
  var me = this, touches = e.touches, changedTouches = e.changedTouches, ln = changedTouches.length, events = me.events, queueWasEmpty = !events.length, cancelEvents = me.cancelEvents, targetGroups, targets, i, touch;
  info = info || {};
  info.type = eventName;
  info.target = changedTouches[0].target;
  info.stopped = false;
  info.claimed = false;
  info.isGesture = true;
  e = e.chain(info);
  if (!me.gestureTargets) {
    if (ln > 1) {
      targetGroups = [];
      for (i = 0; i < ln; i++) {
        touch = changedTouches[i];
        targetGroups.push(touch.targets);
      }
      targets = me.getCommonTargets(targetGroups);
    } else {
      targets = changedTouches[0].targets;
    }
    me.gestureTargets = targets;
  }
  if (isCancel && recognizer.isSingleTouch && touches.length > 1) {
    e.target = touches[0].target;
    cancelEvents.push(e);
  } else {
    events.push(e);
  }
  if (queueWasEmpty) {
    me.publishGestures();
  }
}, getCommonTargets:function(targetGroups) {
  var firstTargetGroup = targetGroups[0], ln = targetGroups.length;
  if (ln === 1) {
    return firstTargetGroup;
  }
  var commonTargets = [], i = 1, target, targets, j;
  while (true) {
    target = firstTargetGroup[firstTargetGroup.length - i];
    if (!target) {
      return commonTargets;
    }
    for (j = 1; j < ln; j++) {
      targets = targetGroups[j];
      if (targets[targets.length - i] !== target) {
        return commonTargets;
      }
    }
    commonTargets.unshift(target);
    i++;
  }
  return commonTargets;
}, invokeRecognizers:function(methodName, e) {
  var recognizers = this.recognizers, ln = recognizers.length, i, recognizer;
  if (methodName === 'onStart') {
    for (i = 0; i < ln; i++) {
      recognizers[i].isActive = true;
    }
  }
  for (i = 0; i < ln; i++) {
    recognizer = recognizers[i];
    if (recognizer.isActive && recognizer[methodName].call(recognizer, e) === false) {
      recognizer.isActive = false;
    }
  }
}, filterClaimed:function(events, claimedEvent) {
  var me = this, eventToRecognizer = me.eventToRecognizer, claimedEventType = claimedEvent.type, claimedRecognizer = eventToRecognizer[claimedEventType], claimedEventIndex, recognizer, type, i;
  for (i = events.length; i--;) {
    type = events[i].type;
    if (type === claimedEventType) {
      claimedEventIndex = i;
    } else {
      recognizer = eventToRecognizer[type];
      if (!claimedRecognizer || recognizer && recognizer !== claimedRecognizer) {
        events.splice(i, 1);
        if (claimedEventIndex) {
          claimedEventIndex--;
        }
      }
    }
  }
  me.claimRecognizer(claimedRecognizer, events[0]);
  return claimedEventIndex;
}, claimRecognizer:function(claimedRecognizer, e) {
  var me = this, recognizers = me.recognizers, i, ln, recognizer;
  for (i = 0, ln = recognizers.length; i < ln; i++) {
    recognizer = recognizers[i];
    if (recognizer !== claimedRecognizer) {
      recognizer.isActive = false;
      recognizer.cancel(e);
    }
  }
  if (me.events.length) {
    me.publishGestures(true);
  }
}, publishGestures:function(claimed) {
  var me = this, cancelEvents = me.cancelEvents, events = me.events, gestureTargets = me.gestureTargets;
  if (cancelEvents.length) {
    me.cancelEvents = [];
    me.publish(cancelEvents, me.getPropagatingTargets(cancelEvents[0].target), true);
  }
  if (events.length) {
    me.events = [];
    me.gestureTargets = null;
    me.publish(events, gestureTargets || me.getPropagatingTargets(events[0].target), claimed);
  }
}, updateTouches:function(e) {
  var me = this, browserEvent = e.browserEvent, type = e.type, touchSources = browserEvent.changedTouches || [browserEvent], activeTouches = me.activeTouches, activeTouchesMap = me.activeTouchesMap, changedTouches = [], touchSource, identifier, touch, target, i, ln, x, y;
  for (i = 0, ln = touchSources.length; i < ln; i++) {
    touchSource = touchSources[i];
    if ('identifier' in touchSource) {
      identifier = touchSource.identifier;
    } else {
      if ('pointerId' in touchSource) {
        identifier = touchSource.pointerId;
      } else {
        identifier = 1;
      }
    }
    touch = activeTouchesMap[identifier];
    if (!touch) {
      target = Ext.event.Event.resolveTextNode(touchSource.target);
      touch = activeTouchesMap[identifier] = {identifier:identifier, target:target, targets:me.getPropagatingTargets(target)};
      activeTouches.push(touch);
    }
    if (me.isEndEvent[type] || me.isCancelEvent[type]) {
      delete activeTouchesMap[identifier];
      Ext.Array.remove(activeTouches, touch);
    }
    x = touchSource.pageX;
    y = touchSource.pageY;
    touch.pageX = x;
    touch.pageY = y;
    touch.point = new Ext.util.Point(x, y);
    changedTouches.push(touch);
  }
  e.touches = Ext.Array.clone(activeTouches);
  e.changedTouches = changedTouches;
}, publishDelegatedDomEvent:function(e) {
  var me = this;
  if (!e.button || e.button < 1) {
    me.events = [e];
    e.browserEvent.$extHandled = true;
    me.handlers[e.type].call(me, e);
  } else {
    Ext.event.publisher.Dom.prototype.publishDelegatedDomEvent.call(this, e);
  }
}, onTouchStart:function(e) {
  var me = this, target = e.target, touches = e.browserEvent.touches;
  if (e.browserEvent.type === 'touchstart') {
    target.addEventListener('touchmove', me.onTargetTouchMove);
    target.addEventListener('touchend', me.onTargetTouchEnd);
    target.addEventListener('touchcancel', me.onTargetTouchEnd);
  }
  if (touches && touches.length <= me.activeTouches.length) {
    me.removeGhostTouches(touches);
  }
  me.updateTouches(e);
  if (!me.isStarted) {
    if (Ext.enableGarbageCollector) {
      Ext.dom.GarbageCollector.pause();
    }
    me.isStarted = true;
    me.invokeRecognizers('onStart', e);
  }
  me.invokeRecognizers('onTouchStart', e);
  me.publishGestures();
}, onTouchMove:function(e) {
  var me = this, mousePointerType = me.mousePointerType, isStarted = me.isStarted;
  if (isStarted || e.pointerType !== 'mouse') {
    me.updateTouches(e);
  }
  if (isStarted) {
    if (mousePointerType && e.browserEvent.pointerType === mousePointerType && e.buttons === 0) {
      e.type = Ext.dom.Element.prototype.eventMap.touchend;
      e.button = 0;
      me.onTouchEnd(e);
      return;
    }
    if (e.changedTouches.length > 0) {
      me.invokeRecognizers('onTouchMove', e);
    }
  }
  me.publishGestures();
}, onTouchEnd:function(e) {
  var me = this, isStarted = me.isStarted, touchCount;
  if (isStarted || e.pointerType !== 'mouse') {
    me.updateTouches(e);
  }
  if (!isStarted) {
    me.publishGestures();
    return;
  }
  touchCount = me.activeTouches.length;
  try {
    me.invokeRecognizers(me.isCancelEvent[e.type] ? 'onTouchCancel' : 'onTouchEnd', e);
  } finally {
    try {
      if (!touchCount) {
        me.isStarted = false;
        me.invokeRecognizers('onEnd', e);
      }
    } finally {
      try {
        me.publishGestures();
      } finally {
        if (!touchCount) {
          if (Ext.enableGarbageCollector) {
            Ext.dom.GarbageCollector.resume();
          }
        }
        me.reEnterCountAdjusted = true;
        me.reEnterCount--;
      }
    }
  }
}, onTargetTouchMove:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doTargetTouchMove, this, [e]);
  } else {
    this.doTargetTouchMove(e);
  }
}, doTargetTouchMove:function(e) {
  var me = this;
  if (!Ext.getBody().contains(e.target)) {
    me.reEnterCountAdjusted = false;
    me.reEnterCount++;
    this.onTouchMove(new Ext.event.Event(e));
    if (!me.reEnterCountAdjusted) {
      me.reEnterCount--;
    }
  }
}, onTargetTouchEnd:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doTargetTouchEnd, this, [e]);
  } else {
    this.doTargetTouchEnd(e);
  }
}, doTargetTouchEnd:function(e) {
  var me = this, target = e.target;
  target.removeEventListener('touchmove', me.onTargetTouchMove);
  target.removeEventListener('touchend', me.onTargetTouchEnd);
  target.removeEventListener('touchcancel', me.onTargetTouchEnd);
  if (!Ext.getBody().contains(target)) {
    me.reEnterCountAdjusted = false;
    me.reEnterCount++;
    me.onTouchEnd(new Ext.event.Event(e));
    if (!me.reEnterCountAdjusted) {
      me.reEnterCount--;
    }
  }
}, reset:function() {
  var me = this, recognizers = me.recognizers, ln = recognizers.length, i, recognizer;
  me.activeTouchesMap = {};
  me.activeTouches = [];
  me.changedTouches = [];
  me.isStarted = false;
  me.gestureTargets = null;
  me.events = [];
  me.cancelEvents = [];
  for (i = 0; i < ln; i++) {
    recognizer = recognizers[i];
    recognizer.reset();
    recognizer.isActive = false;
  }
  Ext.event.publisher.Dom.prototype.reset.call(this);
}, privates:{removeGhostTouches:function(touches) {
  var ids = {}, len = touches.length, activeTouches = this.activeTouches, map = this.activeTouchesMap, i, id, touch;
  for (i = 0; i < len; ++i) {
    ids[touches[i].identifier] = true;
  }
  i = activeTouches.length;
  while (i--) {
    touch = activeTouches[i];
    id = touch.identifier;
    if (!touches[id]) {
      Ext.Array.remove(activeTouches, touch);
      delete map[id];
    }
  }
}}}, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, 'Gesture'], function(Gesture) {
  var EventProto = Event.prototype, stopPropagation = EventProto.stopPropagation;
  if (stopPropagation) {
    EventProto.stopPropagation = function() {
      var me = this, publisher = Gesture.instance, type = me.type, e;
      if (!me.$extHandled && publisher.handles[type]) {
        e = new Ext.event.Event(me);
        publisher.updateTouches(e);
        publisher.invokeRecognizers('onTouchCancel', e);
        publisher.reset();
        publisher.reEnterCountAdjusted = true;
      }
      stopPropagation.apply(me, arguments);
    };
  }
  Gesture.instance = Ext.$gesturePublisher = new Gesture;
});
Ext.define('Ext.overrides.event.publisher.Gesture', {override:'Ext.event.publisher.Gesture'}, function() {
  if (Ext.isIE9m) {
    this.override({updateTouches:function(e, isEnd) {
      var browserEvent = e.browserEvent, xy = e.getXY();
      browserEvent.pageX = xy[0];
      browserEvent.pageY = xy[1];
      this.callParent([e, isEnd]);
    }, doDelegatedEvent:function(e) {
      this.callParent([Ext.event.Event.enableIEAsync(e)]);
    }});
  }
});
Ext.cmd.derive('Ext.mixin.Templatable', Ext.Mixin, {mixinConfig:{id:'templatable'}, referenceAttributeName:'reference', referenceSelector:'[reference]', getElementConfig:function() {
  return {reference:'element'};
}, getElementTemplate:function() {
  var elementTemplate = document.createDocumentFragment();
  elementTemplate.appendChild(Ext.Element.create(this.getElementConfig(), true));
  return elementTemplate;
}, initElement:function() {
  var prototype = this.self.prototype;
  prototype.elementTemplate = this.getElementTemplate();
  prototype.initElement = prototype.doInitElement;
  this.initElement.apply(this, arguments);
}, linkElement:function(reference, node) {
  this.link(reference, node);
}, doInitElement:function() {
  var referenceAttributeName = this.referenceAttributeName, renderElement, referenceNodes, i, ln, referenceNode, reference;
  renderElement = this.elementTemplate.cloneNode(true);
  referenceNodes = renderElement.querySelectorAll(this.referenceSelector);
  for (i = 0, ln = referenceNodes.length; i < ln; i++) {
    referenceNode = referenceNodes[i];
    reference = referenceNode.getAttribute(referenceAttributeName);
    referenceNode.removeAttribute(referenceAttributeName);
    this.linkElement(reference, referenceNode);
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Templatable'], 0);
Ext.cmd.derive('Ext.TaskQueue', Ext.Base, {singleton:true, pending:false, mode:true, readQueue:[], writeQueue:[], readRequestId:0, writeRequestId:0, timer:null, constructor:function() {
  var me = this;
  me.run = me.run.bind(me);
  if (Ext.os.is.iOS) {
    me.watchdogTimer = Ext.interval(this.watch, 500, this);
  }
}, requestRead:function(fn, scope, args) {
  var request = {id:++this.readRequestId, fn:fn, scope:scope, args:args};
  this.readQueue.push(request);
  this.request(true);
  return request.id;
}, cancelRead:function(id) {
  this.cancelRequest(this.readQueue, id, true);
}, requestWrite:function(fn, scope, args) {
  var me = this, request = {id:++me.writeRequestId, fn:fn, scope:scope, args:args};
  me.writeQueue.push(request);
  me.request(false);
  return request.id;
}, cancelWrite:function(id) {
  this.cancelRequest(this.writeQueue, id, false);
}, request:function(mode, method) {
  var me = this;
  if (!me.pending) {
    me.pendingTime = Date.now();
    me.pending = true;
    me.mode = mode;
    if (mode) {
      me.timer = Ext.defer(me[method] || me.run, 1);
    } else {
      me.timer = Ext.raf(me[method] || me.run);
    }
  }
}, cancelRequest:function(queue, id, mode) {
  for (var i = 0; i < queue.length; i++) {
    if (queue[i].id === id) {
      queue.splice(i, 1);
      break;
    }
  }
  if (!queue.length && this.mode === mode && this.timer) {
    Ext.undefer(this.timer);
  }
}, watch:function() {
  if (this.pending && Date.now() - this.pendingTime >= 500) {
    this.run();
  }
}, run:function(readQueue, writeQueue, method) {
  var me = this, mode = null, queue, tasks, task, fn, scope, args, i, len;
  readQueue = readQueue || me.readQueue;
  writeQueue = writeQueue || me.writeQueue;
  me.pending = false;
  me.pending = me.timer = false;
  if (me.mode) {
    queue = readQueue;
    if (writeQueue.length > 0) {
      mode = false;
    }
  } else {
    queue = writeQueue;
    if (readQueue.length > 0) {
      mode = true;
    }
  }
  tasks = queue.slice();
  queue.length = 0;
  for (i = 0, len = tasks.length; i < len; i++) {
    task = tasks[i];
    fn = task.fn;
    scope = task.scope;
    args = task.args;
    if (scope && (scope.destroying || scope.destroyed)) {
      continue;
    }
    if (typeof fn === 'string') {
      fn = scope[fn];
    }
    if (args) {
      fn.apply(scope, args);
    } else {
      fn.call(scope);
    }
  }
  tasks.length = 0;
  if (mode !== null) {
    me.request(mode, method);
  }
}, clear:function() {
  var me = this, timer = me.timer;
  if (timer) {
    if (me.mode) {
      Ext.undefer(timer);
    } else {
      Ext.unraf(timer);
    }
  }
  me.readQueue.length = me.writeQueue.length = 0;
  me.pending = me.timer = false;
  me.mode = true;
}}, 1, 0, 0, 0, 0, 0, [Ext, 'TaskQueue'], 0);
Ext.cmd.derive('Ext.util.sizemonitor.Abstract', Ext.Base, {config:{element:null, callback:Ext.emptyFn, scope:null, args:[]}, width:null, height:null, contentWidth:null, contentHeight:null, constructor:function(config) {
  var me = this;
  me.refresh = me.refresh.bind(me);
  me.info = {width:0, height:0, contentWidth:0, contentHeight:0, flag:0};
  me.initElement();
  me.initConfig(config);
  me.bindListeners(true);
}, bindListeners:Ext.emptyFn, applyElement:function(element) {
  if (element) {
    return Ext.get(element);
  }
}, updateElement:function(element) {
  element.append(this.detectorsContainer, true);
  element.addCls('x-size-monitored');
}, applyArgs:function(args) {
  return args.concat([this.info]);
}, refreshMonitors:Ext.emptyFn, forceRefresh:function() {
  Ext.TaskQueue.requestRead('refresh', this);
}, getContentBounds:function() {
  return this.detectorsContainer.getBoundingClientRect();
}, getContentWidth:function() {
  return this.detectorsContainer.clientWidth;
}, getContentHeight:function() {
  return this.detectorsContainer.clientHeight;
}, refreshSize:function() {
  var element = this.getElement();
  if (!element || element.destroyed) {
    return false;
  }
  var me = this, size = element.measure(), width = size.width, height = size.height, contentWidth = me.getContentWidth(), contentHeight = me.getContentHeight(), currentContentWidth = me.contentWidth, currentContentHeight = me.contentHeight, info = me.info, resized = false, flag;
  me.width = width;
  me.height = height;
  me.contentWidth = contentWidth;
  me.contentHeight = contentHeight;
  flag = (currentContentWidth !== contentWidth ? 1 : 0) + (currentContentHeight !== contentHeight ? 2 : 0);
  if (flag > 0) {
    info.width = width;
    info.height = height;
    info.contentWidth = contentWidth;
    info.contentHeight = contentHeight;
    info.flag = flag;
    resized = true;
    me.getCallback().apply(me.getScope(), me.getArgs());
  }
  return resized;
}, refresh:function() {
  if (this.destroying || this.destroyed) {
    return;
  }
  this.refreshSize();
  Ext.TaskQueue.requestWrite('refreshMonitors', this);
}, destroy:function() {
  var me = this, element = me.getElement();
  me.bindListeners(false);
  if (element && !element.destroyed) {
    element.removeCls('x-size-monitored');
  }
  delete me._element;
  me.refresh = null;
  me.callParent();
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Templatable.prototype.mixinId || Ext.mixin.Templatable.$className, Ext.mixin.Templatable]], [Ext.util.sizemonitor, 'Abstract'], 0);
Ext.cmd.derive('Ext.util.sizemonitor.Scroll', Ext.util.sizemonitor.Abstract, {getElementConfig:function() {
  return {reference:'detectorsContainer', classList:['x-size-monitors', 'scroll'], children:[{reference:'expandMonitor', className:'expand'}, {reference:'shrinkMonitor', className:'shrink'}]};
}, constructor:function(config) {
  this.onScroll = this.onScroll.bind(this);
  Ext.util.sizemonitor.Abstract.prototype.constructor.apply(this, arguments);
}, bindListeners:function(bind) {
  var method = bind ? 'addEventListener' : 'removeEventListener';
  this.expandMonitor[method]('scroll', this.onScroll, true);
  this.shrinkMonitor[method]('scroll', this.onScroll, true);
}, onScroll:function() {
  if (!this.destroyed) {
    Ext.TaskQueue.requestRead('refresh', this);
  }
}, refreshMonitors:function() {
  var expandMonitor = this.expandMonitor, shrinkMonitor = this.shrinkMonitor, end = 1000000;
  if (expandMonitor && !expandMonitor.destroyed) {
    expandMonitor.scrollLeft = end;
    expandMonitor.scrollTop = end;
  }
  if (shrinkMonitor && !shrinkMonitor.destroyed) {
    shrinkMonitor.scrollLeft = end;
    shrinkMonitor.scrollTop = end;
  }
}, destroy:function() {
  this.onScroll = null;
  Ext.util.sizemonitor.Abstract.prototype.destroy.call(this);
}}, 1, 0, 0, 0, 0, 0, [Ext.util.sizemonitor, 'Scroll'], 0);
Ext.cmd.derive('Ext.util.SizeMonitor', Ext.Base, {constructor:function(config) {
  return new Ext.util.sizemonitor.Scroll(config);
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'SizeMonitor'], 0);
Ext.cmd.derive('Ext.event.publisher.ElementSize', Ext.event.publisher.Publisher, {type:'size', handledEvents:['resize'], constructor:function() {
  this.monitors = {};
  this.subscribers = {};
  Ext.event.publisher.Publisher.prototype.constructor.apply(this, arguments);
}, subscribe:function(element) {
  var id = element.id, subscribers = this.subscribers, monitors = this.monitors;
  if (subscribers[id]) {
    ++subscribers[id];
  } else {
    subscribers[id] = 1;
    monitors[id] = new Ext.util.SizeMonitor({element:element, callback:this.onElementResize, scope:this, args:[element]});
  }
  element.on('painted', 'forceRefresh', monitors[id]);
  return true;
}, unsubscribe:function(element) {
  var id = element.id, subscribers = this.subscribers, monitors = this.monitors, sizeMonitor;
  if (subscribers[id] && !--subscribers[id]) {
    delete subscribers[id];
    sizeMonitor = monitors[id];
    element.un('painted', 'forceRefresh', sizeMonitor);
    sizeMonitor.destroy();
    delete monitors[id];
  }
  if (element.activeRead) {
    Ext.TaskQueue.cancelRead(element.activeRead);
  }
}, fireElementResize:function(element, info) {
  delete element.activeRead;
  this.fire(element, 'resize', [element, info]);
}, onElementResize:function(element, info) {
  if (!element.activeRead) {
    element.activeRead = Ext.TaskQueue.requestRead('fireElementResize', this, [element, info]);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, 'ElementSize'], function(ElementSize) {
  ElementSize.instance = new ElementSize;
});
Ext.cmd.derive('Ext.util.paintmonitor.Abstract', Ext.Base, {config:{element:null, callback:Ext.emptyFn, scope:null, args:[]}, eventName:'', monitorClass:'', constructor:function(config) {
  this.onElementPainted = this.onElementPainted.bind(this);
  this.initConfig(config);
}, bindListeners:function(bind) {
  this.monitorElement[bind ? 'addEventListener' : 'removeEventListener'](this.eventName, this.onElementPainted, true);
}, applyElement:function(element) {
  if (element) {
    return Ext.get(element);
  }
}, updateElement:function(element) {
  this.monitorElement = Ext.Element.create({classList:['x-paint-monitor', this.monitorClass]}, true);
  element.appendChild(this.monitorElement, true);
  element.addCls('x-paint-monitored');
  this.bindListeners(true);
}, onElementPainted:function() {
}, destroy:function() {
  var me = this, monitorElement = me.monitorElement, parentNode = monitorElement.parentNode, element = me.getElement();
  me.bindListeners(false);
  delete me.monitorElement;
  if (element && !element.destroyed) {
    element.removeCls('x-paint-monitored');
    delete me._element;
  }
  if (parentNode) {
    parentNode.removeChild(monitorElement);
  }
  me.callParent();
}}, 1, 0, 0, 0, 0, 0, [Ext.util.paintmonitor, 'Abstract'], 0);
Ext.cmd.derive('Ext.util.paintmonitor.CssAnimation', Ext.util.paintmonitor.Abstract, {eventName:Ext.browser.is.WebKit ? 'webkitAnimationEnd' : 'animationend', monitorClass:'cssanimation', onElementPainted:function(e) {
  if (e.animationName === 'x-paint-monitor-helper') {
    this.getCallback().apply(this.getScope(), this.getArgs());
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.util.paintmonitor, 'CssAnimation'], 0);
Ext.cmd.derive('Ext.util.PaintMonitor', Ext.Base, {constructor:function(config) {
  return new Ext.util.paintmonitor.CssAnimation(config);
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'PaintMonitor'], 0);
Ext.cmd.derive('Ext.event.publisher.ElementPaint', Ext.event.publisher.Publisher, {type:'paint', handledEvents:['painted'], constructor:function() {
  this.monitors = {};
  this.subscribers = {};
  Ext.event.publisher.Publisher.prototype.constructor.apply(this, arguments);
}, subscribe:function(element) {
  var me = this, id = element.id, subscribers = me.subscribers;
  if (subscribers[id]) {
    ++subscribers[id];
  } else {
    subscribers[id] = 1;
    me.monitors[id] = new Ext.util.PaintMonitor({element:element, callback:me.onElementPainted, scope:me, args:[element]});
  }
}, unsubscribe:function(element) {
  var id = element.id, subscribers = this.subscribers, monitors = this.monitors;
  if (subscribers[id] && !--subscribers[id]) {
    delete subscribers[id];
    monitors[id].destroy();
    delete monitors[id];
  }
  if (element.activeRead) {
    Ext.TaskQueue.cancelRead(element.activeRead);
  }
}, fireElementPainted:function(element) {
  delete element.activeRead;
  this.fire(element, 'painted', [element]);
}, onElementPainted:function(element) {
  if (!element.activeRead) {
    element.activeRead = Ext.TaskQueue.requestRead('fireElementPainted', this, [element]);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, 'ElementPaint'], function(ElementPaint) {
  ElementPaint.instance = new ElementPaint;
});
Ext.cmd.derive('Ext.dom.Element', Ext.Base, function(Element) {
  var WIN = window, DOC = document, docEl = DOC.documentElement, WIN_TOP = WIN.top, EMPTY = [], elementIdCounter, windowId, documentId, WIDTH = 'width', HEIGHT = 'height', MIN_WIDTH = 'min-width', MIN_HEIGHT = 'min-height', MAX_WIDTH = 'max-width', MAX_HEIGHT = 'max-height', TOP = 'top', RIGHT = 'right', BOTTOM = 'bottom', LEFT = 'left', VISIBILITY = 'visibility', HIDDEN = 'hidden', DISPLAY = 'display', NONE = 'none', ZINDEX = 'z-index', POSITION = 'position', RELATIVE = 'relative', STATIC = 'static', 
  wordsRe = /\w/g, spacesRe = /\s+/, classNameSplitRegex = /[\s]+/, transparentRe = /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i, endsQuestionRe = /\?$/, topRe = /top/i, empty = {}, borders = {t:'border-top-width', r:'border-right-width', b:'border-bottom-width', l:'border-left-width'}, paddings = {t:'padding-top', r:'padding-right', b:'padding-bottom', l:'padding-left'}, margins = {t:'margin-top', r:'margin-right', b:'margin-bottom', l:'margin-left'}, selectDir = {b:'backward', 
  back:'backward', f:'forward'}, paddingsTLRB = [paddings.l, paddings.r, paddings.t, paddings.b], bordersTLRB = [borders.l, borders.r, borders.t, borders.b], numberRe = /\d+$/, unitRe = /\d+(px|r?em|%|vh|vw|vmin|vmax|en|ch|ex|pt|in|cm|mm|pc)$/i, defaultUnit = 'px', msRe = /^-ms-/, camelRe = /(-[a-z])/gi, cssRe = /([a-z0-9\-]+)\s*:\s*([^;\s]+(?:\s*[^;\s]+)*);?/gi, pxRe = /^\d+(?:\.\d*)?px$/i, relativeUnitRe = /(%|r?em|auto|vh|vw|vmin|vmax|ch|ex)$/i, propertyCache = {}, ORIGINALDISPLAY = 'originalDisplay', 
  camelReplaceFn = function(m, a) {
    return a.charAt(1).toUpperCase();
  }, clearData = function(node, deep) {
    var childNodes, i, len;
    if (node.nodeType === 1) {
      node._extData = null;
      if (deep) {
        childNodes = node.childNodes;
        for (i = 0, len = childNodes.length; i < len; ++i) {
          clearData(childNodes[i], deep);
        }
      }
    }
  }, toFloat = function(v) {
    return parseFloat(v) || 0;
  }, opacityCls = 'x-hidden-opacity', visibilityCls = 'x-hidden-visibility', displayCls = 'x-hidden-display', offsetsCls = 'x-hidden-offsets', clipCls = 'x-hidden-clip', lastFocusChange = 0, lastKeyboardClose = 0, editableHasFocus = false, isVirtualKeyboardOpen = false, inputTypeSelectionSupported = /text|password|search|tel|url/i, visFly, scrollFly, caFly, wrapFly, grannyFly, activeElFly;
  try {
    elementIdCounter = WIN_TOP.__elementIdCounter__;
  } catch (e$20) {
    WIN_TOP = WIN;
  }
  WIN_TOP.__elementIdCounter = elementIdCounter = (WIN_TOP.__elementIdCounter__ || 0) + 1;
  windowId = 'ext-window-' + elementIdCounter;
  documentId = 'ext-document-' + elementIdCounter;
  return {alternateClassName:['Ext.Element'], observableType:'element', isElement:true, skipGarbageCollection:true, $applyConfigs:true, identifiablePrefix:'ext-element-', _selectDir:selectDir, styleHooks:{transform:{set:function(dom, value, el) {
    var prop, result = '';
    if (typeof value !== 'string') {
      for (prop in value) {
        if (result) {
          result += ' ';
        }
        if (prop.indexOf('translate') === 0) {
          result += prop + '(' + Element.addUnits(value[prop], 'px') + ')';
        } else {
          result += prop + '(' + value[prop] + ')';
        }
      }
      value = result;
    }
    dom.style.transform = value;
  }}}, validIdRe:Ext.validIdRe, blockedEvents:Ext.supports.EmulatedMouseOver ? {mouseover:1} : {}, longpressEvents:{longpress:1, taphold:1}, constructor:function(dom) {
    var me = this, id;
    if (typeof dom === 'string') {
      dom = DOC.getElementById(dom);
    }
    if (!dom) {
      return null;
    }
    me.dom = dom;
    id = dom.id;
    if (id) {
      me.id = id;
    } else {
      id = dom.id = me.getUniqueId();
    }
    me.el = me;
    Ext.cache[id] = me;
    me.longpressListenerCount = 0;
    me.mixins.observable.constructor.call(me);
  }, inheritableStatics:{cache:Ext.cache = {}, editableSelector:'input,textarea,[contenteditable\x3d"true"]', VISIBILITY:1, DISPLAY:2, OFFSETS:3, CLIP:4, OPACITY:5, minKeyboardHeight:100, unitRe:unitRe, useDelegatedEvents:true, validNodeTypes:{1:1, 9:1}, selectableCls:'x-selectable', unselectableCls:'x-unselectable', maxRippleDiameter:75, addUnits:function(size, units) {
    if (typeof size === 'number') {
      return size + (units || defaultUnit);
    }
    if (size === '' || size === 'auto' || size == null) {
      return size || '';
    }
    if (numberRe.test(size)) {
      return size + (units || defaultUnit);
    }
    if (!unitRe.test(size)) {
      return size || '';
    }
    return size;
  }, create:function(attributes, domNode) {
    var me = this, classes, element, elementStyle, tag, value, name, i, ln, tmp;
    attributes = attributes || {};
    if (attributes.isElement) {
      return domNode ? attributes.dom : attributes;
    } else {
      if ('nodeType' in attributes) {
        return domNode ? attributes : Ext.get(attributes);
      }
    }
    if (typeof attributes === 'string') {
      return DOC.createTextNode(attributes);
    }
    tag = attributes.tag;
    if (!tag) {
      tag = 'div';
    }
    if (attributes.namespace) {
      element = DOC.createElementNS(attributes.namespace, tag);
    } else {
      element = DOC.createElement(tag);
    }
    elementStyle = element.style;
    for (name in attributes) {
      if (name !== 'tag') {
        value = attributes[name];
        switch(name) {
          case 'style':
            if (typeof value === 'string') {
              element.setAttribute(name, value);
            } else {
              for (i in value) {
                if (value.hasOwnProperty(i)) {
                  elementStyle[i] = value[i];
                }
              }
            }
            break;
          case 'className':
          case 'cls':
            tmp = value.split(spacesRe);
            classes = classes ? classes.concat(tmp) : tmp;
            break;
          case 'classList':
            classes = classes ? classes.concat(value) : value;
            break;
          case 'text':
            element.textContent = value;
            break;
          case 'html':
            element.innerHTML = value;
            break;
          case 'hidden':
            if (classes) {
              classes.push(displayCls);
            } else {
              classes = [displayCls];
            }
            break;
          case 'children':
            if (value != null) {
              for (i = 0, ln = value.length; i < ln; i++) {
                element.appendChild(me.create(value[i], true));
              }
            }
            break;
          default:
            if (value != null) {
              element.setAttribute(name, value);
            }
        }
      }
    }
    if (classes) {
      element.className = classes.join(' ');
    }
    if (domNode) {
      return element;
    } else {
      return me.get(element);
    }
  }, fly:function(dom, named) {
    return Ext.fly(dom, named);
  }, fromPoint:function() {
    var elementFromPointBug;
    if (Ext.isIE || Ext.isEdge) {
      try {
        elementFromPointBug = window.self !== window.top;
      } catch (e$21) {
        elementFromPointBug = true;
      }
    }
    return function(x, y, asDom) {
      var el = null;
      el = DOC.elementFromPoint(x, y);
      if (!el && elementFromPointBug) {
        el = DOC.elementFromPoint(x, y);
      }
      return asDom ? el : Ext.get(el);
    };
  }(), fromPagePoint:function(x, y, asDom) {
    var scroll = Ext.getDoc().getScroll();
    return Element.fromPoint(x - scroll.left, y - scroll.top, asDom);
  }, get:function(el) {
    var me = this, cache = Ext.cache, nodeType, dom, id, entry, isDoc, isWin, isValidNodeType;
    if (!el) {
      return null;
    }
    if (el.isFly) {
      el = el.dom;
    }
    if (typeof el === 'string') {
      id = el;
      if (cache.hasOwnProperty(id)) {
        entry = cache[id];
        if (entry.skipGarbageCollection || !Ext.isGarbage(entry.dom)) {
          return entry;
        } else {
          entry.destroy();
        }
      }
      if (id === windowId) {
        return Element.get(WIN);
      } else {
        if (id === documentId) {
          return Element.get(DOC);
        }
      }
      dom = Ext.getElementById ? Ext.getElementById(id) : DOC.getElementById(id);
      if (dom) {
        return new Element(dom);
      }
    }
    nodeType = el.nodeType;
    if (nodeType) {
      isDoc = nodeType === 9;
      isValidNodeType = me.validNodeTypes[nodeType];
    } else {
      isWin = el.window == el;
    }
    if (isValidNodeType || isWin) {
      id = el.id;
      if (cache.hasOwnProperty(id)) {
        entry = cache[id];
        if (entry.skipGarbageCollection || el === entry.dom || !Ext.isGarbage(entry.dom)) {
          return entry;
        } else {
          entry.destroy();
        }
      }
      if (el === DOC) {
        el.id = documentId;
      }
      if (el == WIN) {
        el.id = windowId;
      }
      el = new Element(el);
      if (isWin || isDoc) {
        el.skipGarbageCollection = true;
      }
      return el;
    }
    if (el.isElement) {
      return el;
    }
    if (el.isComposite) {
      return el;
    }
    if (Ext.isIterable(el)) {
      return me.select(el);
    }
    return null;
  }, getActiveElement:function(asElement) {
    var active = DOC.activeElement;
    if (!active || !active.focus) {
      active = DOC.body;
    }
    return asElement ? Ext.get(active) : active;
  }, getDocumentHeight:function() {
    return Math.max(!Ext.isStrict ? DOC.body.scrollHeight : docEl.scrollHeight, this.getViewportHeight());
  }, getDocumentWidth:function() {
    return Math.max(!Ext.isStrict ? DOC.body.scrollWidth : docEl.scrollWidth, this.getViewportWidth());
  }, getOrientation:function() {
    if (Ext.supports.OrientationChange) {
      return WIN.orientation == 0 ? 'portrait' : 'landscape';
    }
    return WIN.innerHeight > WIN.innerWidth ? 'portrait' : 'landscape';
  }, getViewportHeight:function() {
    var viewportHeight = Element._viewportHeight;
    if (Ext.isIE9m) {
      return DOC.documentElement.clientHeight;
    }
    return viewportHeight != null ? viewportHeight : docEl.clientHeight;
  }, getViewportWidth:function() {
    var viewportWidth = Element._viewportWidth;
    if (Ext.isIE9m) {
      return DOC.documentElement.clientWidth;
    }
    return viewportWidth != null ? viewportWidth : docEl.clientWidth;
  }, getViewportScale:function() {
    var top = WIN_TOP;
    return (Ext.isiOS || Ext.isAndroid ? 1 : top.devicePixelRatio || top.screen.deviceXDPI / top.screen.logicalXDPI) * this.getViewportTouchScale();
  }, getViewportTouchScale:function(forceRead) {
    var scale = 1, top = WIN_TOP, cachedScale;
    if (!forceRead) {
      cachedScale = this._viewportTouchScale;
      if (cachedScale) {
        return cachedScale;
      }
    }
    if (Ext.isIE10p || Ext.isEdge || Ext.isiOS) {
      scale = docEl.offsetWidth / WIN.innerWidth;
    } else {
      if (Ext.isChromeMobile) {
        scale = top.outerWidth / top.innerWidth;
      }
    }
    return scale;
  }, getViewSize:function() {
    return {width:Element.getViewportWidth(), height:Element.getViewportHeight()};
  }, hasUnit:function(size) {
    return !!(size && unitRe.test(size));
  }, isRelativeUnit:function(size) {
    return !size || relativeUnitRe.test(size);
  }, maskIframes:function() {
    var iframes = document.getElementsByTagName('iframe'), fly = new Ext.dom.Fly;
    Ext.each(iframes, function(iframe) {
      var myMask;
      myMask = fly.attach(iframe.parentNode).mask();
      myMask.setStyle('background-color', 'transparent');
    });
  }, normalize:function(prop) {
    return propertyCache[prop] || (propertyCache[prop] = prop.replace(msRe, 'ms-').replace(camelRe, camelReplaceFn));
  }, _onWindowFocusChange:function(e) {
    if (Ext.fly(e.target).is(Element.editableSelector)) {
      lastFocusChange = new Date;
      editableHasFocus = e.type === 'focusin' || e.type === 'pointerup';
    }
  }, _onWindowResize:function() {
    var documentWidth = docEl.clientWidth, documentHeight = docEl.clientHeight, now = new Date, threshold = 1000, deltaX, deltaY;
    deltaX = documentWidth - Element._documentWidth;
    deltaY = documentHeight - Element._documentHeight;
    Element._documentWidth = documentWidth;
    Element._documentHeight = documentHeight;
    if (now - lastFocusChange < threshold || now - lastKeyboardClose < threshold) {
      if (deltaX === 0 && (editableHasFocus && deltaY <= -Element.minKeyboardHeight)) {
        isVirtualKeyboardOpen = true;
        return;
      }
    }
    if (isVirtualKeyboardOpen && deltaX === 0 && deltaY >= Element.minKeyboardHeight) {
      isVirtualKeyboardOpen = false;
      lastKeyboardClose = new Date;
    }
    if (isVirtualKeyboardOpen) {
      return;
    }
    Element._viewportWidth = documentWidth;
    Element._viewportHeight = documentHeight;
  }, parseBox:function(box) {
    box = box || 0;
    var type = typeof box, parts, ln;
    if (type === 'number') {
      return {top:box, right:box, bottom:box, left:box};
    } else {
      if (type !== 'string') {
        return box;
      }
    }
    parts = box.split(' ');
    ln = parts.length;
    if (ln === 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else {
      if (ln === 2) {
        parts[2] = parts[0];
        parts[3] = parts[1];
      } else {
        if (ln === 3) {
          parts[3] = parts[1];
        }
      }
    }
    return {top:parseFloat(parts[0]) || 0, right:parseFloat(parts[1]) || 0, bottom:parseFloat(parts[2]) || 0, left:parseFloat(parts[3]) || 0};
  }, parseStyles:function(styles) {
    var out = {}, matches;
    if (styles) {
      cssRe.lastIndex = 0;
      while (matches = cssRe.exec(styles)) {
        out[matches[1]] = matches[2] || '';
      }
    }
    return out;
  }, select:function(selector, composite, root) {
    return Ext.fly(root || DOC).select(selector, composite);
  }, query:function(selector, asDom, root) {
    return Ext.fly(root || DOC).query(selector, asDom);
  }, unitizeBox:function(box, units) {
    var me = this;
    box = me.parseBox(box);
    return me.addUnits(box.top, units) + ' ' + me.addUnits(box.right, units) + ' ' + me.addUnits(box.bottom, units) + ' ' + me.addUnits(box.left, units);
  }, unmaskIframes:function() {
    var iframes = document.getElementsByTagName('iframe'), fly = new Ext.dom.Fly;
    Ext.each(iframes, function(iframe) {
      fly.attach(iframe.parentNode).unmask();
    });
  }, serializeForm:function(form) {
    var fElements = form.elements || (DOC.forms[form] || Ext.getDom(form)).elements, hasSubmit = false, encoder = encodeURIComponent, data = '', eLen = fElements.length, element, name, type, options, hasValue, e, o, oLen, opt;
    for (e = 0; e < eLen; e++) {
      element = fElements[e];
      name = element.name;
      type = element.type;
      options = element.options;
      if (!element.disabled && name) {
        if (/select-(one|multiple)/i.test(type)) {
          oLen = options.length;
          for (o = 0; o < oLen; o++) {
            opt = options[o];
            if (opt.selected) {
              hasValue = opt.hasAttribute('value');
              data += Ext.String.format('{0}\x3d{1}\x26', encoder(name), encoder(hasValue ? opt.value : opt.text));
            }
          }
        } else {
          if (!/file|undefined|reset|button/i.test(type)) {
            if (!(/radio|checkbox/i.test(type) && !element.checked) && !(type == 'submit' && hasSubmit)) {
              data += encoder(name) + '\x3d' + encoder(element.value) + '\x26';
              hasSubmit = /submit/i.test(type);
            }
          }
        }
      }
    }
    return data.substr(0, data.length - 1);
  }, getCommonAncestor:function(nodeA, nodeB, returnDom) {
    caFly = caFly || new Ext.dom.Fly;
    caFly.attach(Ext.getDom(nodeA));
    while (!caFly.isAncestor(nodeB)) {
      if (caFly.dom.parentNode) {
        caFly.attach(caFly.dom.parentNode);
      } else {
        caFly.attach(DOC.body);
        break;
      }
    }
    return returnDom ? caFly.dom : Ext.get(caFly);
  }}, selectable:function() {
    var me = this;
    me.dom.unselectable = '';
    me.removeCls(Element.unselectableCls);
    me.addCls(Element.selectableCls);
    return me;
  }, unselectable:function() {
    var me = this;
    if (Ext.isOpera) {
      me.dom.unselectable = 'on';
    }
    me.removeCls(Element.selectableCls);
    me.addCls(Element.unselectableCls);
    return me;
  }, statics:{tabbableSelector:Ext.supports.CSS3NegationSelector ? 'a[href],button,iframe,input,select,textarea,[tabindex]:not([tabindex\x3d"-1"]),[contenteditable\x3d"true"]' : 'a[href],button,iframe,input,select,textarea,[tabindex],[contenteditable\x3d"true"]', naturallyFocusableTags:{BUTTON:true, IFRAME:true, EMBED:true, INPUT:true, OBJECT:true, SELECT:true, TEXTAREA:true, HTML:Ext.isIE ? true : false, BODY:Ext.isIE ? false : true}, naturallyTabbableTags:{BUTTON:true, IFRAME:true, INPUT:true, 
  SELECT:true, TEXTAREA:true, OBJECT:Ext.isIE8m ? true : false}, inputTags:{INPUT:true, TEXTAREA:true}, tabbableSavedCounterAttribute:'data-tabindex-counter', tabbableSavedValueAttribute:'data-tabindex-value', splitCls:function(cls) {
    if (typeof cls === 'string') {
      cls = cls.split(spacesRe);
    }
    return cls;
  }}, _init:function(E) {
    E.tabbableSelector += ',[' + E.tabbableSavedCounterAttribute + ']';
  }, addCls:function(names, prefix, suffix) {
    return this.replaceCls(null, names, prefix, suffix);
  }, addClsOnClick:function(className, testFn, scope) {
    var me = this, hasTest = Ext.isFunction(testFn);
    me.on('mousedown', function() {
      if (hasTest && testFn.call(scope || me, me) === false) {
        return false;
      }
      me.addCls(className);
      Ext.getDoc().on({mouseup:function() {
        if (me.dom) {
          me.removeCls(className);
        }
      }, single:true});
    });
    return me;
  }, addClsOnFocus:function(className, testFn, scope) {
    var me = this, hasTest = Ext.isFunction(testFn);
    me.on('focus', function() {
      if (hasTest && testFn.call(scope || me, me) === false) {
        return false;
      }
      me.addCls(className);
    });
    me.on('blur', function() {
      if (me.dom) {
        me.removeCls(className);
      }
    });
    return me;
  }, addClsOnOver:function(className, testFn, scope) {
    var me = this, hasTest = Ext.isFunction(testFn);
    me.hover(function() {
      if (hasTest && testFn.call(scope || me, me) === false) {
        return;
      }
      me.addCls(className);
    }, function() {
      me.removeCls(className);
    });
    return me;
  }, addStyles:function(sides, styles) {
    var totalSize = 0, sidesArr = (sides || '').match(wordsRe), i, len = sidesArr.length, side, styleSides = [];
    if (len === 1) {
      totalSize = parseFloat(this.getStyle(styles[sidesArr[0]])) || 0;
    } else {
      if (len) {
        for (i = 0; i < len; i++) {
          side = sidesArr[i];
          styleSides.push(styles[side]);
        }
        styleSides = this.getStyle(styleSides);
        for (i = 0; i < len; i++) {
          side = sidesArr[i];
          totalSize += parseFloat(styleSides[styles[side]]) || 0;
        }
      }
    }
    return totalSize;
  }, addUnits:function(size, units) {
    return Element.addUnits(size, units);
  }, animate:function(animation) {
    animation = new Ext.fx.Animation(animation);
    animation.setElement(this);
    this._activeAnimation = animation;
    animation.on({animationend:this._onAnimationEnd, scope:this});
    Ext.Animator.run(animation);
    return animation;
  }, _onAnimationEnd:function() {
    this._activeAnimation = null;
  }, getActiveAnimation:function() {
    return this._activeAnimation;
  }, append:function() {
    return this.appendChild.apply(this, arguments);
  }, appendChild:function(el, returnDom) {
    var me = this, insertEl, eLen, e;
    if (el.nodeType || el.dom || typeof el === 'string') {
      el = Ext.getDom(el);
      me.dom.appendChild(el);
      return !returnDom ? Ext.get(el) : el;
    } else {
      if (el.length) {
        insertEl = Ext.fly(DOC.createDocumentFragment());
        eLen = el.length;
        for (e = 0; e < eLen; e++) {
          insertEl.appendChild(el[e], returnDom);
        }
        el = Ext.Array.toArray(insertEl.dom.childNodes);
        me.dom.appendChild(insertEl.dom);
        return returnDom ? el : new Ext.dom.CompositeElementLite(el);
      } else {
        return me.createChild(el, null, returnDom);
      }
    }
  }, appendTo:function(el) {
    Ext.getDom(el).appendChild(this.dom);
    return this;
  }, applyStyles:function(styles) {
    if (styles) {
      if (typeof styles === 'function') {
        styles = styles.call();
      }
      if (typeof styles === 'string') {
        styles = Element.parseStyles(styles);
      }
      if (typeof styles === 'object') {
        this.setStyle(styles);
      }
    }
    return this;
  }, blur:function() {
    var me = this, dom = me.dom;
    if (dom !== DOC.body) {
      try {
        dom.blur();
      } catch (e$22) {
      }
      return me;
    } else {
      return me.focus(undefined, dom);
    }
  }, cacheScrollValues:function() {
    var me = this, scrollValues = [], scrolledDescendants = [], descendants, descendant, i, len;
    scrollFly = scrollFly || new Ext.dom.Fly;
    descendants = me.query('*');
    for (i = 0, len = descendants.length; i < len; i++) {
      descendant = descendants[i];
      if (descendant.scrollTop > 0 || descendant.scrollLeft !== 0) {
        scrolledDescendants.push(descendant);
        scrollValues.push(scrollFly.attach(descendant).getScroll());
      }
    }
    return function() {
      var scroll, i, len;
      for (i = 0, len = scrolledDescendants.length; i < len; i++) {
        scroll = scrollValues[i];
        scrollFly.attach(scrolledDescendants[i]);
        scrollFly.setScrollLeft(scroll.left);
        scrollFly.setScrollTop(scroll.top);
      }
    };
  }, center:function(centerIn) {
    return this.alignTo(centerIn || DOC, 'c-c');
  }, child:function(selector, returnDom) {
    var me = this, id;
    if (Ext.supports.Selectors2) {
      return me.selectNode(':scope\x3e' + selector, !!returnDom);
    } else {
      id = me.id != null ? me.id : Ext.get(me).id;
      return me.selectNode(Ext.makeIdSelector(id) + ' \x3e ' + selector, !!returnDom);
    }
  }, clone:function(deep, returnDom) {
    var clone = this.dom.cloneNode(deep);
    if (Ext.supports.CloneNodeCopiesExpando) {
      clearData(clone, deep);
    }
    return returnDom ? clone : Ext.get(clone);
  }, constrainScrollLeft:function(left) {
    var dom = this.dom;
    return Math.max(Math.min(left, dom.scrollWidth - dom.clientWidth), 0);
  }, constrainScrollTop:function(top) {
    var dom = this.dom;
    return Math.max(Math.min(top, dom.scrollHeight - dom.clientHeight), 0);
  }, createChild:function(config, insertBefore, returnDom) {
    config = config || {tag:'div'};
    if (insertBefore) {
      return Ext.DomHelper.insertBefore(insertBefore, config, returnDom !== true);
    } else {
      return Ext.DomHelper.append(this.dom, config, returnDom !== true);
    }
  }, contains:function(element) {
    if (!element) {
      return false;
    }
    var me = this, dom = Ext.getDom(element);
    return dom === me.dom || me.isAncestor(dom);
  }, destroy:function() {
    var me = this, dom = me.dom;
    if (dom && dom.parentNode) {
      dom.parentNode.removeChild(dom);
    }
    if (me.$ripples) {
      me.destroyAllRipples();
    }
    me.collect();
  }, detach:function() {
    var dom = this.dom, component = this.component;
    if (dom && dom.parentNode && dom.tagName !== 'BODY') {
      if (component) {
        component.revertFocus();
      }
      dom.parentNode.removeChild(dom);
    }
    return this;
  }, disableShadow:function() {
    var shadow = this.shadow;
    if (shadow) {
      shadow.hide();
      shadow.disabled = true;
    }
  }, disableShim:function() {
    var shim = this.shim;
    if (shim) {
      shim.hide();
      shim.disabled = true;
    }
  }, doReplaceWith:function(element) {
    var dom = this.dom;
    dom.parentNode.replaceChild(Ext.getDom(element), dom);
  }, doScrollIntoView:function(container, hscroll, animate, highlight, getScrollX, scrollTo) {
    scrollFly = scrollFly || new Ext.dom.Fly;
    var me = this, dom = me.dom, scrollX = scrollFly.attach(container)[getScrollX](), scrollY = container.scrollTop, position = me.getScrollIntoViewXY(container, scrollX, scrollY), newScrollX = position.x, newScrollY = position.y;
    if (highlight) {
      if (animate) {
        animate = Ext.apply({listeners:{afteranimate:function() {
          scrollFly.attach(dom).highlight();
        }}}, animate);
      } else {
        scrollFly.attach(dom).highlight();
      }
    }
    if (newScrollY !== scrollY) {
      scrollFly.attach(container).scrollTo('top', newScrollY, animate);
    }
    if (hscroll !== false && newScrollX !== scrollX) {
      scrollFly.attach(container)[scrollTo]('left', newScrollX, animate);
    }
    return me;
  }, down:function(selector, returnDom) {
    return this.selectNode(selector, !!returnDom);
  }, enableShadow:function(options, isVisible) {
    var me = this, shadow = me.shadow || (me.shadow = new Ext.dom.Shadow(Ext.apply({target:me}, options))), shim = me.shim;
    if (shim) {
      shim.offsets = shadow.outerOffsets;
      shim.shadow = shadow;
      shadow.shim = shim;
    }
    if (isVisible === true || isVisible !== false && me.isVisible()) {
      shadow.show();
    } else {
      shadow.hide();
    }
    shadow.disabled = false;
  }, enableShim:function(options, isVisible) {
    var me = this, shim = me.shim || (me.shim = new Ext.dom.Shim(Ext.apply({target:me}, options))), shadow = me.shadow;
    if (shadow) {
      shim.offsets = shadow.outerOffsets;
      shim.shadow = shadow;
      shadow.shim = shim;
    }
    if (isVisible === true || isVisible !== false && me.isVisible()) {
      shim.show();
    } else {
      shim.hide();
    }
    shim.disabled = false;
    return shim;
  }, findParent:function(simpleSelector, limit, returnEl) {
    var me = this, target = me.dom, topmost = docEl, depth = 0;
    if (limit || limit === 0) {
      if (typeof limit !== 'number') {
        topmost = Ext.getDom(limit);
        limit = Number.MAX_VALUE;
      }
    } else {
      limit = 50;
    }
    while (target && target.nodeType === 1 && depth < limit && target !== topmost) {
      if (Ext.fly(target).is(simpleSelector)) {
        return returnEl ? Ext.get(target) : target;
      }
      depth++;
      target = target.parentNode;
    }
    return null;
  }, findParentNode:function(simpleSelector, limit, returnEl) {
    var p = Ext.fly(this.dom.parentNode);
    return p ? p.findParent(simpleSelector, limit, returnEl) : null;
  }, first:function(selector, returnDom) {
    return this.matchNode('nextSibling', 'firstChild', selector, returnDom);
  }, focus:function(defer, dom) {
    var me = this;
    dom = dom || me.dom;
    if (Number(defer)) {
      Ext.defer(me.focus, defer, me, [null, dom]);
    } else {
      Ext.GlobalEvents.fireEvent('beforefocus', dom);
      dom.focus();
    }
    return me;
  }, collect:function() {
    var me = this, dom = me.dom, shadow = me.shadow, shim = me.shim;
    if (!me.isFly) {
      me.mixins.observable.destroy.call(me);
      delete Ext.cache[me.id];
      me.el = null;
    }
    if (dom) {
      dom._extData = me.dom = null;
    }
    if (shadow) {
      shadow.hide();
      me.shadow = null;
    }
    if (shim) {
      shim.hide();
      me.shim = null;
    }
  }, getAnchorToXY:function(el, anchor, local, mySize) {
    return el.getAnchorXY(anchor, local, mySize);
  }, getAttribute:function(name, namespace) {
    var dom = this.dom;
    return namespace ? dom.getAttributeNS(namespace, name) || dom.getAttribute(namespace + ':' + name) : dom.getAttribute(name) || dom[name] || null;
  }, getAttributes:function() {
    var attributes = this.dom.attributes, result = {}, attr, i, len;
    for (i = 0, len = attributes.length; i < len; i++) {
      attr = attributes[i];
      result[attr.name] = attr.value;
    }
    return result;
  }, getBottom:function(local) {
    return (local ? this.getLocalY() : this.getY()) + this.getHeight();
  }, getById:function(id, asDom) {
    var dom = DOC.getElementById(id) || this.dom.querySelector(Ext.makeIdSelector(id));
    return asDom ? dom : dom ? Ext.get(dom) : null;
  }, getBorderPadding:function() {
    var paddingWidth = this.getStyle(paddingsTLRB), bordersWidth = this.getStyle(bordersTLRB);
    return {beforeX:(parseFloat(bordersWidth[borders.l]) || 0) + (parseFloat(paddingWidth[paddings.l]) || 0), afterX:(parseFloat(bordersWidth[borders.r]) || 0) + (parseFloat(paddingWidth[paddings.r]) || 0), beforeY:(parseFloat(bordersWidth[borders.t]) || 0) + (parseFloat(paddingWidth[paddings.t]) || 0), afterY:(parseFloat(bordersWidth[borders.b]) || 0) + (parseFloat(paddingWidth[paddings.b]) || 0)};
  }, getBorders:function() {
    var bordersWidth = this.getStyle(bordersTLRB);
    return {beforeX:parseFloat(bordersWidth[borders.l]) || 0, afterX:parseFloat(bordersWidth[borders.r]) || 0, beforeY:parseFloat(bordersWidth[borders.t]) || 0, afterY:parseFloat(bordersWidth[borders.b]) || 0};
  }, getBorderWidth:function(side) {
    return this.addStyles(side, borders);
  }, getClassMap:function(clone) {
    var data = this.getData();
    if (data) {
      data = data.classMap;
      if (clone !== false) {
        data = Ext.apply({}, data);
      }
    }
    return data;
  }, getData:function(sync) {
    var dom = this.dom, data;
    if (dom) {
      data = dom._extData || (dom._extData = {});
      if (sync !== false && !data.isSynchronized) {
        this.synchronize();
      }
    }
    return data || null;
  }, getFirstChild:function() {
    return Ext.get(this.dom.firstElementChild);
  }, getLastChild:function() {
    return Ext.get(this.dom.lastElementChild);
  }, getHeight:function(contentHeight, preciseHeight) {
    var me = this, dom = me.dom, hidden = me.isStyle('display', 'none'), height, floating;
    if (hidden) {
      return 0;
    }
    if (dom.nodeName === 'BODY') {
      height = Element.getViewportHeight();
    } else {
      if (preciseHeight) {
        height = dom.getBoundingClientRect().height;
      } else {
        height = dom.offsetHeight;
        if (height == null) {
          height = dom.getBoundingClientRect().height;
        }
      }
    }
    if (Ext.supports.Direct2DBug) {
      floating = me.adjustDirect2DDimension(HEIGHT);
      if (preciseHeight) {
        height += floating;
      } else {
        if (floating > 0 && floating < 0.5) {
          height++;
        }
      }
    }
    if (contentHeight) {
      height -= me.getBorderWidth('tb') + me.getPadding('tb');
    }
    return height < 0 ? 0 : height;
  }, getHtml:function() {
    return this.dom ? this.dom.innerHTML : '';
  }, getLeft:function(local) {
    return local ? this.getLocalX() : this.getX();
  }, getLocalX:function() {
    var me = this, offsetParent, x = me.getStyle('left');
    if (!x || x === 'auto') {
      x = 0;
    } else {
      if (pxRe.test(x)) {
        x = parseFloat(x);
      } else {
        x = me.getX();
        offsetParent = me.dom.offsetParent;
        if (offsetParent) {
          x -= Ext.fly(offsetParent).getX();
        }
      }
    }
    return x;
  }, getLocalXY:function() {
    var me = this, offsetParent, style = me.getStyle(['left', 'top']), x = style.left, y = style.top;
    if (!x || x === 'auto') {
      x = 0;
    } else {
      if (pxRe.test(x)) {
        x = parseFloat(x);
      } else {
        x = me.getX();
        offsetParent = me.dom.offsetParent;
        if (offsetParent) {
          x -= Ext.fly(offsetParent).getX();
        }
      }
    }
    if (!y || y === 'auto') {
      y = 0;
    } else {
      if (pxRe.test(y)) {
        y = parseFloat(y);
      } else {
        y = me.getY();
        offsetParent = me.dom.offsetParent;
        if (offsetParent) {
          y -= Ext.fly(offsetParent).getY();
        }
      }
    }
    return [x, y];
  }, getLocalY:function() {
    var me = this, offsetParent, y = me.getStyle('top');
    if (!y || y === 'auto') {
      y = 0;
    } else {
      if (pxRe.test(y)) {
        y = parseFloat(y);
      } else {
        y = me.getY();
        offsetParent = me.dom.offsetParent;
        if (offsetParent) {
          y -= Ext.fly(offsetParent).getY();
        }
      }
    }
    return y;
  }, getMargin:function() {
    var hash = {t:'top', l:'left', r:'right', b:'bottom'}, allMargins = ['margin-top', 'margin-left', 'margin-right', 'margin-bottom'];
    return function(side) {
      var me = this, style, key, o;
      if (!side) {
        style = me.getStyle(allMargins);
        o = {};
        if (style && typeof style === 'object') {
          o = {};
          for (key in margins) {
            o[key] = o[hash[key]] = parseFloat(style[margins[key]]) || 0;
          }
        }
      } else {
        o = me.addStyles(side, margins);
      }
      return o;
    };
  }(), getPadding:function(side) {
    return this.addStyles(side, paddings);
  }, getParent:function() {
    return Ext.get(this.dom.parentNode);
  }, getRight:function(local) {
    return (local ? this.getLocalX() : this.getX()) + this.getWidth();
  }, getScroll:function() {
    var me = this, dom = me.dom, docElement = docEl, left, top, body = DOC.body;
    if (dom === DOC || dom === body) {
      left = docElement.scrollLeft || (body ? body.scrollLeft : 0);
      top = docElement.scrollTop || (body ? body.scrollTop : 0);
    } else {
      left = dom.scrollLeft;
      top = dom.scrollTop;
    }
    return {left:left, top:top};
  }, getScrollIntoViewXY:function(container, scrollX, scrollY, align) {
    align = align || empty;
    var me = this, dom = me.dom, offsets, clientWidth, clientHeight;
    if (container.isRegion) {
      clientHeight = container.height;
      clientWidth = container.width;
    } else {
      container = Ext.getDom(container);
      clientHeight = container.clientHeight;
      clientWidth = container.clientWidth;
    }
    offsets = me.getOffsetsTo(container);
    return {y:me.calcScrollPos(offsets[1] + scrollY, dom.offsetHeight, scrollY, clientHeight, align.y), x:me.calcScrollPos(offsets[0] + scrollX, dom.offsetWidth, scrollX, clientWidth, align.x)};
  }, calcScrollPos:function(start, size, viewStart, viewSize, align) {
    var end = start + size, viewEnd = viewStart + viewSize, force = align && !endsQuestionRe.test(align), ret = viewStart;
    if (!force) {
      if (align) {
        align = align.slice(0, -1);
      }
      if (size > viewSize || start < viewStart) {
        align = align || 'start';
        force = true;
      } else {
        if (end > viewEnd) {
          align = align || 'end';
          force = true;
        }
      }
    }
    if (force) {
      if (align === 'start') {
        ret = start;
      } else {
        if (align === 'center') {
          ret = Math.max(0, start - Math.floor(viewSize / 2));
        } else {
          if (align === 'end') {
            ret = Math.max(0, end - viewSize);
          }
        }
      }
    }
    return ret;
  }, getScrollLeft:function() {
    var dom = this.dom;
    if (dom === DOC || dom === DOC.body) {
      return this.getScroll().left;
    } else {
      return dom.scrollLeft;
    }
  }, getScrollTop:function() {
    var dom = this.dom;
    if (dom === DOC || dom === DOC.body) {
      return this.getScroll().top;
    } else {
      return dom.scrollTop;
    }
  }, getSize:function(contentSize) {
    return {width:this.getWidth(contentSize), height:this.getHeight(contentSize)};
  }, getStyle:function(property, inline) {
    var me = this, dom = me.dom, multiple = typeof property !== 'string', hooks = me.styleHooks, prop = property, props = prop, len = 1, domStyle, camel, values, hook, out, style, i;
    if (multiple) {
      values = {};
      prop = props[0];
      i = 0;
      if (!(len = props.length)) {
        return values;
      }
    }
    if (!dom || dom.documentElement) {
      return values || '';
    }
    domStyle = dom.style;
    if (inline) {
      style = domStyle;
    } else {
      style = dom.ownerDocument.defaultView.getComputedStyle(dom, null);
      if (!style) {
        inline = true;
        style = domStyle;
      }
    }
    do {
      hook = hooks[prop];
      if (!hook) {
        hooks[prop] = hook = {name:Element.normalize(prop)};
      }
      if (hook.get) {
        out = hook.get(dom, me, inline, style);
      } else {
        camel = hook.name;
        out = style[camel];
      }
      if (!multiple) {
        return out;
      }
      values[prop] = out;
      prop = props[++i];
    } while (i < len);
    return values;
  }, getStyleValue:function(name) {
    return this.dom.style.getPropertyValue(name);
  }, getCaretPos:function() {
    var dom = this.dom, pos, selection;
    if (inputTypeSelectionSupported.test(dom.type)) {
      pos = dom.selectionStart;
      selection = typeof pos !== 'number' && this.getTextSelection();
      if (selection) {
        pos = selection[0];
      }
    }
    return pos;
  }, setCaretPos:function(pos) {
    this.selectText(pos, pos);
  }, getTextSelection:function() {
    var dom = this.dom;
    if (inputTypeSelectionSupported.test(dom.type)) {
      return [dom.selectionStart, dom.selectionEnd, dom.selectionDirection];
    } else {
      return [];
    }
  }, selectText:function(start, end, direction) {
    var me = this, range, dom = me.dom, len;
    if (dom && inputTypeSelectionSupported.test(dom.type)) {
      start = start || 0;
      len = dom.value.length;
      if (end === undefined) {
        end = len;
      }
      direction = selectDir[direction] || direction || 'forward';
      if (dom.setSelectionRange) {
        dom.setSelectionRange(start, end, direction);
      } else {
        if (dom.createTextRange) {
          if (start > end) {
            start = end;
          }
          range = dom.createTextRange();
          range.moveStart('character', start);
          range.moveEnd('character', -(len - end));
          range.select();
        }
      }
    }
    return me;
  }, getTop:function(local) {
    return local ? this.getLocalY() : this.getY();
  }, getTouchAction:function() {
    return Ext.dom.TouchAction.get(this.dom);
  }, getValue:function(asNumber) {
    var value = this.dom.value;
    return asNumber ? parseInt(value, 10) : value;
  }, getViewSize:function() {
    var dom = this.dom;
    if (dom === DOC || dom === DOC.body) {
      return {width:Element.getViewportWidth(), height:Element.getViewportHeight()};
    } else {
      return {width:dom.clientWidth, height:dom.clientHeight};
    }
  }, getVisibilityMode:function() {
    var me = this, data = me.getData(), mode = data.visibilityMode;
    if (mode === undefined) {
      data.visibilityMode = mode = Element.DISPLAY;
    }
    return mode;
  }, getWidth:function(contentWidth, preciseWidth) {
    var me = this, dom = me.dom, hidden = me.isStyle('display', 'none'), rect, width, floating;
    if (hidden) {
      return 0;
    }
    if (Ext.supports.BoundingClientRect) {
      rect = dom.getBoundingClientRect();
      width = me.vertical && !Ext.supports.RotatedBoundingClientRect ? rect.bottom - rect.top : rect.right - rect.left;
      width = preciseWidth ? width : Math.ceil(width);
    } else {
      width = dom.offsetWidth;
    }
    if (Ext.supports.Direct2DBug && !me.vertical) {
      floating = me.adjustDirect2DDimension(WIDTH);
      if (preciseWidth) {
        width += floating;
      } else {
        if (floating > 0 && floating < 0.5) {
          width++;
        }
      }
    }
    if (contentWidth) {
      width -= me.getBorderWidth('lr') + me.getPadding('lr');
    }
    return width < 0 ? 0 : width;
  }, getX:function() {
    return this.getXY()[0];
  }, getXY:function() {
    var round = Math.round, dom = this.dom, body = DOC.body, x = 0, y = 0, bodyRect, rect;
    if (dom !== DOC && dom !== body) {
      try {
        bodyRect = body.getBoundingClientRect();
        rect = dom.getBoundingClientRect();
        x = rect.left - bodyRect.left;
        y = rect.top - bodyRect.top;
      } catch (ex) {
      }
    }
    return [round(x), round(y)];
  }, getY:function() {
    return this.getXY()[1];
  }, getZIndex:function() {
    return parseInt(this.getStyle('z-index'), 10);
  }, hasCls:function(name) {
    var classMap = this.getClassMap();
    return classMap.hasOwnProperty(name);
  }, hide:function() {
    return this.setVisible(false);
  }, hover:function(overFn, outFn, scope, options) {
    var me = this;
    me.on('mouseenter', overFn, scope || me.dom, options);
    me.on('mouseleave', outFn, scope || me.dom, options);
    return me;
  }, indexOf:function(childEl) {
    var children = this.dom, c = childEl && Ext.getDom(childEl);
    children = children && children.childNodes;
    return c && children ? Array.prototype.indexOf.call(children, c) : -1;
  }, insertAfter:function(el) {
    el = Ext.getDom(el);
    el.parentNode.insertBefore(this.dom, el.nextSibling);
    return this;
  }, insertBefore:function(el) {
    el = Ext.getDom(el);
    el.parentNode.insertBefore(this.dom, el);
    return this;
  }, insertFirst:function(el, returnDom) {
    el = el || {};
    if (el.nodeType || el.dom || typeof el === 'string') {
      el = Ext.getDom(el);
      this.dom.insertBefore(el, this.dom.firstChild);
      return !returnDom ? Ext.get(el) : el;
    } else {
      return this.createChild(el, this.dom.firstChild, returnDom);
    }
  }, insertHtml:function(where, html, returnEl) {
    var el = Ext.DomHelper.insertHtml(where, this.dom, html);
    return returnEl ? Ext.get(el) : el;
  }, insertSibling:function(el, where, returnDom) {
    var me = this, DomHelper = Ext.DomHelper, isAfter = (where || 'before').toLowerCase() === 'after', rt, insertEl, eLen, e;
    if (Ext.isIterable(el)) {
      eLen = el.length;
      insertEl = Ext.fly(DOC.createDocumentFragment());
      if (Ext.isArray(el)) {
        for (e = 0; e < eLen; e++) {
          rt = insertEl.appendChild(el[e], returnDom);
        }
      } else {
        for (e = 0; e < eLen; e++) {
          insertEl.dom.appendChild(rt = el[0]);
        }
        if (returnDom === false) {
          rt = Ext.get(rt);
        }
      }
      me.dom.parentNode.insertBefore(insertEl.dom, isAfter ? me.dom.nextSibling : me.dom);
      return rt;
    }
    el = el || {};
    if (el.nodeType || el.dom) {
      rt = me.dom.parentNode.insertBefore(Ext.getDom(el), isAfter ? me.dom.nextSibling : me.dom);
      if (!returnDom) {
        rt = Ext.get(rt);
      }
    } else {
      if (isAfter && !me.dom.nextSibling) {
        rt = DomHelper.append(me.dom.parentNode, el, !returnDom);
      } else {
        rt = DomHelper[isAfter ? 'insertAfter' : 'insertBefore'](me.dom, el, !returnDom);
      }
    }
    return rt;
  }, is:function(selector) {
    var dom = this.dom, is;
    if (!selector) {
      is = true;
    } else {
      if (!dom.tagName) {
        is = false;
      } else {
        if (Ext.isFunction(selector)) {
          is = selector(dom);
        } else {
          is = dom[Ext.supports.matchesSelector](selector);
        }
      }
    }
    return is;
  }, isAncestor:function(el) {
    var ret = false, dom = this.dom, child = Ext.getDom(el);
    if (dom && child) {
      if (!child.nodeType) {
        return false;
      }
      if (dom.contains) {
        return dom.contains(child);
      } else {
        if (dom.compareDocumentPosition) {
          return !!(dom.compareDocumentPosition(child) & 16);
        } else {
          while (child = child.parentNode) {
            ret = child === dom || ret;
          }
        }
      }
    }
    return ret;
  }, isPainted:function() {
    return !Ext.browser.is.IE ? function() {
      var dom = this.dom;
      return Boolean(dom && dom.offsetParent);
    } : function() {
      var dom = this.dom;
      return Boolean(dom && (dom.offsetHeight !== 0 || dom.offsetWidth !== 0));
    };
  }(), isScrollable:function() {
    var dom = this.dom;
    return dom.scrollHeight > dom.clientHeight || dom.scrollWidth > dom.clientWidth;
  }, isStyle:function(style, val) {
    return this.getStyle(style) === val;
  }, isVisible:function(deep, mode) {
    var dom = this.dom, visible = true, end;
    if (!dom) {
      return false;
    }
    mode = mode || 3;
    if (!visFly) {
      visFly = new Ext.dom.Fly;
    }
    for (end = dom.ownerDocument.documentElement; dom !== end; dom = dom.parentNode) {
      if (!dom || dom.nodeType === 11) {
        visible = false;
      }
      if (visible) {
        visFly.attach(dom);
        if (mode & 1) {
          visible = !visFly.isStyle(DISPLAY, NONE);
        }
        if (visible && mode & 2) {
          visible = !visFly.isStyle(VISIBILITY, HIDDEN);
        }
      }
      if (!visible || !deep) {
        break;
      }
    }
    return visible;
  }, last:function(selector, returnDom) {
    return this.matchNode('previousSibling', 'lastChild', selector, returnDom);
  }, matchNode:function(dir, start, selector, returnDom) {
    var dom = this.dom, n;
    if (!dom) {
      return null;
    }
    n = dom[start];
    while (n) {
      if (n.nodeType === 1 && (!selector || Ext.fly(n, '_matchNode').is(selector))) {
        return !returnDom ? Ext.get(n) : n;
      }
      n = n[dir];
    }
    return null;
  }, measure:function(dimension) {
    var me = this, dom = me.dom, includeWidth = dimension !== 'h', includeHeight = dimension !== 'w', width = 0, height = 0, addPadding = !Ext.supports.ComputedSizeIncludesPadding, style, rect, offsetParent;
    if (dom.nodeName === 'BODY') {
      height = includeHeight && Element.getViewportHeight();
      width = includeWidth && Element.getViewportWidth();
    } else {
      offsetParent = dom.offsetParent;
      style = dom.ownerDocument.defaultView.getComputedStyle(dom, null);
      addPadding |= style.boxSizing === 'content-box';
      if (offsetParent !== null || style.position === 'fixed') {
        if (includeHeight) {
          height = toFloat(style.height);
          if (addPadding) {
            height += toFloat(style.paddingTop) + toFloat(style.paddingBottom) + toFloat(style.borderTopWidth) + toFloat(style.borderBottomWidth);
          }
        }
        if (includeWidth) {
          width = toFloat(style.width);
          if (addPadding) {
            width += toFloat(style.paddingLeft) + toFloat(style.paddingRight) + toFloat(style.borderLeftWidth) + toFloat(style.borderRightWidth);
          }
        }
      }
    }
    rect = dimension ? null : {width:width, height:height};
    return dimension ? includeWidth ? width : height : rect;
  }, measureContent:function(dimension) {
    var me = this, includeWidth = dimension !== 'h', size = me.measure(dimension), h = dimension ? size : size.height, w = dimension ? size : size.width;
    if (dimension !== 'w') {
      h -= me.getBorderWidth('tb') + me.getPadding('tb');
    }
    if (includeWidth) {
      w -= me.getBorderWidth('lr') + me.getPadding('lr');
    }
    return dimension ? includeWidth ? w : h : {width:w, height:h};
  }, monitorMouseLeave:function(delay, handler, scope) {
    var me = this, timer, listeners = {mouseleave:function(e) {
      if (Ext.isIE9m) {
        e.enableIEAsync();
      }
      timer = Ext.defer(handler, delay, scope || me, [e]);
    }, mouseenter:function() {
      Ext.undefer(timer);
    }, destroy:function() {
      Ext.undefer(timer);
      if (!me.destroyed) {
        me.un(listeners);
      }
    }};
    me.on(listeners);
    return listeners;
  }, next:function(selector, returnDom) {
    return this.matchNode('nextSibling', 'nextSibling', selector, returnDom);
  }, parent:function(selector, returnDom) {
    return this.matchNode('parentNode', 'parentNode', selector, returnDom);
  }, peekData:function() {
    var dom = this.dom;
    return dom && dom._extData || null;
  }, position:function(pos, zIndex, x, y) {
    var me = this;
    if (me.dom.tagName !== 'BODY') {
      if (!pos && me.isStyle(POSITION, STATIC)) {
        me.setStyle(POSITION, RELATIVE);
      } else {
        if (pos) {
          me.setStyle(POSITION, pos);
        }
      }
      if (zIndex) {
        me.setStyle(ZINDEX, zIndex);
      }
      if (x || y) {
        me.setXY([x || false, y || false]);
      }
    }
  }, prev:function(selector, returnDom) {
    return this.matchNode('previousSibling', 'previousSibling', selector, returnDom);
  }, query:function(selector, asDom, single) {
    var dom = this.dom, results, len, nlen, node, nodes, i, j;
    if (!dom) {
      return null;
    }
    asDom = asDom !== false;
    selector = selector.split(',');
    if (!single) {
      results = [];
    }
    for (i = 0, len = selector.length; i < len; i++) {
      if (typeof selector[i] === 'string') {
        if (single) {
          node = dom.querySelector(selector[i]);
          return asDom ? node : Ext.get(node);
        }
        nodes = dom.querySelectorAll(selector[i]);
        for (j = 0, nlen = nodes.length; j < nlen; j++) {
          results.push(asDom ? nodes[j] : Ext.get(nodes[j]));
        }
      }
    }
    return results;
  }, radioCls:function(className) {
    var cn = this.dom.parentNode.childNodes, v;
    className = Ext.isArray(className) ? className : [className];
    for (var i = 0, len = cn.length; i < len; i++) {
      v = cn[i];
      if (v && v.nodeType === 1) {
        Ext.fly(v).removeCls(className);
      }
    }
    return this.addCls(className);
  }, redraw:function() {
    var dom = this.dom, domStyle = dom.style;
    domStyle.display = 'none';
    dom.offsetHeight;
    domStyle.display = '';
  }, remove:function() {
    this.destroy();
  }, removeChild:function(element) {
    this.dom.removeChild(Ext.getDom(element));
    return this;
  }, removeCls:function(names, prefix, suffix) {
    return this.replaceCls(names, null, prefix, suffix);
  }, repaint:function() {
    var me = this;
    me.addCls('x-repaint');
    if (!me.repaintTimer) {
      me.repaintTimer = Ext.defer(function() {
        me.repaintTimer = null;
        if (me.dom) {
          me.removeCls('x-repaint');
        }
      }, 1);
    }
    return me;
  }, replace:function(el, destroy) {
    el = Ext.getDom(el);
    var parentNode = el.parentNode, id = el.id, dom = this.dom;
    if (destroy !== false && id && Ext.cache[id]) {
      parentNode.insertBefore(dom, el);
      Ext.get(el).destroy();
    } else {
      parentNode.replaceChild(dom, el);
    }
    return this;
  }, replaceCls:function(remove, add, prefix, suffix) {
    var me = this, added = 0, removed = 0, rem = remove, data = (add || remove) && me.getData(), list, map, i, n, name;
    if (data) {
      list = data.classList;
      map = data.classMap;
      add = add ? typeof add === 'string' ? add.split(spacesRe) : add : EMPTY;
      rem = rem ? typeof rem === 'string' ? rem.split(spacesRe) : rem : EMPTY;
      prefix = prefix || '';
      if (prefix && prefix[prefix.length - 1] !== '-') {
        prefix += '-';
      }
      suffix = suffix || '';
      if (suffix && suffix[0] !== '-') {
        suffix = '-' + suffix;
      }
      for (i = 0, n = rem.length; i < n; i++) {
        if (!(name = rem[i])) {
          continue;
        }
        name = prefix + name + suffix;
        if (map[name]) {
          delete map[name];
          ++removed;
        }
      }
      for (i = 0, n = add.length; i < n; i++) {
        if (!(name = add[i])) {
          continue;
        }
        name = prefix + name + suffix;
        if (!map[name]) {
          map[name] = true;
          if (!removed) {
            list.push(name);
            ++added;
          }
        }
      }
      if (removed) {
        me.setClassMap(map, true);
      } else {
        if (added) {
          me.dom.className = list.join(' ');
        }
      }
    }
    return me;
  }, replaceWith:function(el) {
    var me = this, dom = me.dom, parent = dom.parentNode, cache = Ext.cache, newDom;
    me.clearListeners();
    if (el.nodeType || el.dom || typeof el === 'string') {
      el = Ext.get(el);
      newDom = parent.insertBefore(el.dom, dom);
    } else {
      newDom = Ext.DomHelper.insertBefore(dom, el);
    }
    parent.removeChild(dom);
    me.dom = newDom;
    if (!me.isFly) {
      delete cache[me.id];
      cache[me.id = Ext.id(newDom)] = me;
    }
    return me;
  }, resolveListenerScope:function(defaultScope) {
    var component = this.component;
    return component ? component.resolveListenerScope(defaultScope) : this;
  }, scroll:function(direction, distance, animate) {
    if (!this.isScrollable()) {
      return false;
    }
    direction = direction.charAt(0);
    var me = this, dom = me.dom, side = direction === 'r' || direction === 'l' ? 'left' : 'top', scrolled = false, currentScroll, constrainedScroll;
    if (direction === 'l' || direction === 't' || direction === 'u') {
      distance = -distance;
    }
    if (side === 'left') {
      currentScroll = dom.scrollLeft;
      constrainedScroll = me.constrainScrollLeft(currentScroll + distance);
    } else {
      currentScroll = dom.scrollTop;
      constrainedScroll = me.constrainScrollTop(currentScroll + distance);
    }
    if (constrainedScroll !== currentScroll) {
      this.scrollTo(side, constrainedScroll, animate);
      scrolled = true;
    }
    return scrolled;
  }, scrollBy:function(deltaX, deltaY, animate) {
    var me = this, dom = me.dom;
    if (deltaX.length) {
      animate = deltaY;
      deltaY = deltaX[1];
      deltaX = deltaX[0];
    } else {
      if (typeof deltaX != 'number') {
        animate = deltaY;
        deltaY = deltaX.y;
        deltaX = deltaX.x;
      }
    }
    if (deltaX) {
      me.scrollTo('left', me.constrainScrollLeft(dom.scrollLeft + deltaX), animate);
    }
    if (deltaY) {
      me.scrollTo('top', me.constrainScrollTop(dom.scrollTop + deltaY), animate);
    }
    return me;
  }, scrollChildIntoView:function(child, hscroll) {
    Ext.fly(child).scrollIntoView(this, hscroll);
  }, scrollIntoView:function(container, hscroll, animate, highlight) {
    container = Ext.getDom(container) || Ext.getBody().dom;
    return this.doScrollIntoView(container, hscroll, animate, highlight, 'getScrollLeft', 'scrollTo');
  }, scrollTo:function(side, value, animate) {
    var top = topRe.test(side), me = this, prop = top ? 'scrollTop' : 'scrollLeft', dom = me.dom, animCfg;
    if (!animate || !me.anim) {
      dom[prop] = value;
      dom[prop] = value;
    } else {
      animCfg = {to:{}};
      animCfg.to[prop] = value;
      if (Ext.isObject(animate)) {
        Ext.applyIf(animCfg, animate);
      }
      me.animate(animCfg);
    }
    return me;
  }, select:function(selector, composite) {
    var isElementArray, elements;
    if (typeof selector === 'string') {
      elements = this.query(selector, !composite);
    } else {
      elements = selector;
      isElementArray = true;
    }
    return composite ? new Ext.CompositeElement(elements, !isElementArray) : new Ext.CompositeElementLite(elements, true);
  }, selectNode:function(selector, asDom) {
    return this.query(selector, asDom, true);
  }, set:function(attributes, useSet) {
    var me = this, dom = me.dom, attribute, value;
    for (attribute in attributes) {
      if (attributes.hasOwnProperty(attribute)) {
        value = attributes[attribute];
        if (attribute === 'style') {
          me.applyStyles(value);
        } else {
          if (attribute === 'cls') {
            dom.className = value;
          } else {
            if (useSet !== false) {
              if (value === undefined) {
                dom.removeAttribute(attribute);
              } else {
                dom.setAttribute(attribute, value);
              }
            } else {
              dom[attribute] = value;
            }
          }
        }
      }
    }
    return me;
  }, setBottom:function(bottom) {
    this.dom.style[BOTTOM] = Element.addUnits(bottom);
    return this;
  }, setClassMap:function(classMap, keep) {
    var data = this.getData(false), classList;
    if (data) {
      classMap = keep && classMap || Ext.apply({}, classMap);
      data.classMap = classMap;
      data.classList = classList = Ext.Object.getKeys(classMap);
      data.isSynchronized = true;
      this.dom.className = classList.join(' ');
    }
  }, setCls:function(className) {
    var me = this, elementData = me.getData(false), i, ln, map, classList;
    if (typeof className === 'string') {
      className = className.split(spacesRe);
    }
    elementData.classList = classList = className.slice();
    elementData.classMap = map = {};
    for (i = 0, ln = classList.length; i < ln; i++) {
      map[classList[i]] = true;
    }
    me.dom.className = classList.join(' ');
  }, setDisplayed:function(value) {
    var me = this;
    if (typeof value === 'boolean') {
      value = value ? me._getDisplay() : NONE;
    }
    me.setStyle(DISPLAY, value);
    if (me.shadow || me.shim) {
      me.setUnderlaysVisible(value !== NONE);
    }
    return me;
  }, setHeight:function(height) {
    var me = this;
    me.dom.style[HEIGHT] = Element.addUnits(height);
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setHtml:function(html) {
    if (this.dom) {
      this.dom.innerHTML = html;
    }
    return this;
  }, setId:function(id) {
    var me = this, currentId = me.id, cache = Ext.cache;
    if (currentId) {
      delete cache[currentId];
    }
    me.dom.id = id;
    me.id = id;
    cache[id] = me;
    return me;
  }, setLeft:function(left) {
    var me = this;
    me.dom.style[LEFT] = Element.addUnits(left);
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setLocalX:function(x) {
    var me = this, style = me.dom.style;
    style.right = '';
    style.left = x === null ? 'auto' : x + 'px';
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setLocalXY:function(x, y) {
    var me = this, style = me.dom.style;
    style.right = '';
    if (x && x.length) {
      y = x[1];
      x = x[0];
    }
    if (x === null) {
      style.left = 'auto';
    } else {
      if (x !== undefined) {
        style.left = x + 'px';
      }
    }
    if (y === null) {
      style.top = 'auto';
    } else {
      if (y !== undefined) {
        style.top = y + 'px';
      }
    }
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setLocalY:function(y) {
    var me = this;
    me.dom.style.top = y === null ? 'auto' : y + 'px';
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setMargin:function(margin) {
    var me = this, domStyle = me.dom.style;
    if (margin || margin === 0) {
      margin = me.self.unitizeBox(margin === true ? 5 : margin);
      domStyle.setProperty('margin', margin, 'important');
    } else {
      domStyle.removeProperty('margin-top');
      domStyle.removeProperty('margin-right');
      domStyle.removeProperty('margin-bottom');
      domStyle.removeProperty('margin-left');
    }
  }, setMaxHeight:function(height) {
    this.dom.style[MAX_HEIGHT] = Element.addUnits(height);
    return this;
  }, setMaxWidth:function(width) {
    this.dom.style[MAX_WIDTH] = Element.addUnits(width);
    return this;
  }, setMinHeight:function(height) {
    this.dom.style[MIN_HEIGHT] = Element.addUnits(height);
    return this;
  }, setMinWidth:function(width) {
    this.dom.style[MIN_WIDTH] = Element.addUnits(width);
    return this;
  }, setOpacity:function(opacity) {
    var me = this;
    if (me.dom) {
      me.setStyle('opacity', opacity);
    }
    return me;
  }, setPadding:function(padding) {
    var me = this, domStyle = me.dom.style;
    if (padding || padding === 0) {
      padding = me.self.unitizeBox(padding === true ? 5 : padding);
      domStyle.setProperty('padding', padding, 'important');
    } else {
      domStyle.removeProperty('padding-top');
      domStyle.removeProperty('padding-right');
      domStyle.removeProperty('padding-bottom');
      domStyle.removeProperty('padding-left');
    }
  }, setRight:function(right) {
    this.dom.style[RIGHT] = Element.addUnits(right);
    return this;
  }, setScrollLeft:function(left) {
    this.dom.scrollLeft = left;
    return this;
  }, setScrollTop:function(top) {
    this.dom.scrollTop = top;
    return this;
  }, setSize:function(width, height) {
    var me = this, style = me.dom.style;
    if (Ext.isObject(width)) {
      height = width.height;
      width = width.width;
    }
    if (width !== undefined) {
      style.width = Element.addUnits(width);
    }
    if (height !== undefined) {
      style.height = Element.addUnits(height);
    }
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setStyle:function(prop, value) {
    var me = this, dom = me.dom, hooks = me.styleHooks, style = dom.style, name = prop, hook;
    if (typeof name === 'string') {
      hook = hooks[name];
      if (!hook) {
        hooks[name] = hook = {name:Element.normalize(name)};
      }
      value = value == null ? '' : value;
      if (hook.set) {
        hook.set(dom, value, me);
      } else {
        style[hook.name] = value;
      }
      if (hook.afterSet) {
        hook.afterSet(dom, value, me);
      }
    } else {
      for (name in prop) {
        if (prop.hasOwnProperty(name)) {
          hook = hooks[name];
          if (!hook) {
            hooks[name] = hook = {name:Element.normalize(name)};
          }
          value = prop[name];
          value = value == null ? '' : value;
          if (hook.set) {
            hook.set(dom, value, me);
          } else {
            style[hook.name] = value;
          }
          if (hook.afterSet) {
            hook.afterSet(dom, value, me);
          }
        }
      }
    }
    return me;
  }, setText:function(text) {
    this.dom.textContent = text;
  }, setTop:function(top) {
    var me = this;
    me.dom.style[TOP] = Element.addUnits(top);
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setTouchAction:function(touchAction) {
    Ext.dom.TouchAction.set(this.dom, touchAction);
  }, setUnderlaysVisible:function(visible) {
    var shadow = this.shadow, shim = this.shim;
    if (shadow && !shadow.disabled) {
      if (visible) {
        shadow.show();
      } else {
        shadow.hide();
      }
    }
    if (shim && !shim.disabled) {
      if (visible) {
        shim.show();
      } else {
        shim.hide();
      }
    }
  }, setVisibility:function(isVisible) {
    var domStyle = this.dom.style;
    if (isVisible) {
      domStyle.removeProperty('visibility');
    } else {
      domStyle.setProperty('visibility', 'hidden', 'important');
    }
  }, setVisibilityMode:function(mode) {
    this.getData().visibilityMode = mode;
    return this;
  }, setVisible:function(visible) {
    var me = this, mode = me.getVisibilityMode(), addOrRemove = visible ? 'removeCls' : 'addCls';
    switch(mode) {
      case Element.DISPLAY:
        me.removeCls([visibilityCls, offsetsCls, clipCls, opacityCls]);
        me[addOrRemove](displayCls);
        break;
      case Element.VISIBILITY:
        me.removeCls([displayCls, offsetsCls, clipCls, opacityCls]);
        me[addOrRemove](visibilityCls);
        break;
      case Element.OFFSETS:
        me.removeCls([visibilityCls, displayCls, clipCls, opacityCls]);
        me[addOrRemove](offsetsCls);
        break;
      case Element.CLIP:
        me.removeCls([visibilityCls, displayCls, offsetsCls, opacityCls]);
        me[addOrRemove](clipCls);
        break;
      case Element.OPACITY:
        me.removeCls([visibilityCls, displayCls, offsetsCls, clipCls]);
        me[addOrRemove](opacityCls);
        break;
    }
    if (me.shadow || me.shim) {
      me.setUnderlaysVisible(visible);
    }
    if (!visible && me.$ripples) {
      me.destroyAllRipples();
    }
    return me;
  }, setWidth:function(width) {
    var me = this;
    me.dom.style[WIDTH] = Element.addUnits(width);
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setX:function(x) {
    return this.setXY([x, false]);
  }, setXY:function(xy) {
    var me = this, pts = me.translatePoints(xy), style = me.dom.style, pos;
    me.position();
    style.right = '';
    for (pos in pts) {
      if (!isNaN(pts[pos])) {
        style[pos] = pts[pos] + 'px';
      }
    }
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setY:function(y) {
    return this.setXY([false, y]);
  }, setZIndex:function(zindex) {
    var me = this;
    if (me.shadow) {
      me.shadow.setZIndex(zindex);
    }
    if (me.shim) {
      me.shim.setZIndex(zindex);
    }
    return me.setStyle('z-index', zindex);
  }, show:function() {
    return this.setVisible(true);
  }, swallowEvent:function(eventName, preventDefault) {
    var me = this, e, eLen, listeners = {destroyable:true}, fn = function(e) {
      e.stopPropagation();
      if (preventDefault) {
        e.preventDefault();
      }
    };
    if (Ext.isArray(eventName)) {
      eLen = eventName.length;
      for (e = 0; e < eLen; e++) {
        listeners[eventName[e]] = fn;
      }
    } else {
      listeners[eventName] = fn;
    }
    return me.on(listeners);
  }, swapCls:function(firstClass, secondClass, flag, prefix) {
    if (flag === undefined) {
      flag = true;
    }
    var me = this, addedClass = flag ? firstClass : secondClass, removedClass = flag ? secondClass : firstClass;
    if (removedClass) {
      me.removeCls(prefix ? prefix + '-' + removedClass : removedClass);
    }
    if (addedClass) {
      me.addCls(prefix ? prefix + '-' + addedClass : addedClass);
    }
    return me;
  }, synchronize:function() {
    var me = this, dom = me.dom, hasClassMap = {}, className = dom.className, classList, i, ln, name, elementData = me.getData(false);
    if (className && className.length > 0) {
      classList = dom.className.split(classNameSplitRegex);
      for (i = 0, ln = classList.length; i < ln; i++) {
        name = classList[i];
        hasClassMap[name] = true;
      }
    } else {
      classList = [];
    }
    elementData.classList = classList;
    elementData.classMap = hasClassMap;
    elementData.isSynchronized = true;
    return me;
  }, syncUnderlays:function() {
    var me = this, shadow = me.shadow, shim = me.shim, dom = me.dom, xy, x, y, w, h;
    if (me.isVisible()) {
      xy = me.getXY();
      x = xy[0];
      y = xy[1];
      w = dom.offsetWidth;
      h = dom.offsetHeight;
      if (shadow && !shadow.hidden) {
        shadow.realign(x, y, w, h);
      }
      if (shim && !shim.hidden) {
        shim.realign(x, y, w, h);
      }
    }
  }, toggleCls:function(className, state) {
    if (state == null) {
      state = !this.hasCls(className);
    }
    return state ? this.addCls(className) : this.removeCls(className);
  }, toggle:function() {
    this.setVisible(!this.isVisible());
    return this;
  }, translate:function() {
    var transformStyleName = 'webkitTransform' in DOC.createElement('div').style ? 'webkitTransform' : 'transform';
    return function(x, y, z) {
      x = Math.round(x);
      y = Math.round(y);
      z = Math.round(z);
      this.dom.style[transformStyleName] = 'translate3d(' + (x || 0) + 'px, ' + (y || 0) + 'px, ' + (z || 0) + 'px)';
    };
  }(), unwrap:function() {
    var dom = this.dom, parentNode = dom.parentNode, activeElement = (activeElFly || (activeElFly = new Ext.dom.Fly)).attach(Ext.Element.getActiveElement()), grandparentNode, cached, resumeFocus, tabIndex;
    grannyFly = grannyFly || new Ext.dom.Fly;
    cached = Ext.cache[activeElement.dom.id];
    if (cached) {
      activeElement = cached;
    }
    if (this.contains(activeElement)) {
      if (cached) {
        cached.suspendFocusEvents();
      }
      resumeFocus = true;
    }
    if (parentNode) {
      grandparentNode = parentNode.parentNode;
      if (resumeFocus) {
        tabIndex = grandparentNode.getAttribute('tabIndex');
        grannyFly.attach(grandparentNode);
        grannyFly.set({tabIndex:-1});
        grannyFly.suspendFocusEvents();
        grannyFly.focus();
      }
      grandparentNode.insertBefore(dom, parentNode);
      grandparentNode.removeChild(parentNode);
    } else {
      grandparentNode = DOC.createDocumentFragment();
      grandparentNode.appendChild(dom);
    }
    if (resumeFocus) {
      if (cached) {
        cached.focus();
        cached.resumeFocusEvents();
      } else {
        activeElement.focus();
      }
      if (grannyFly) {
        grannyFly.resumeFocusEvents();
        grannyFly.set({tabIndex:tabIndex});
      }
    }
    return this;
  }, up:function(simpleSelector, limit, returnDom) {
    return this.findParentNode(simpleSelector, limit, !returnDom);
  }, update:function(html) {
    return this.setHtml(html);
  }, wrap:function(config, returnDom, selector) {
    var me = this, dom = me.dom, result = Ext.DomHelper.insertBefore(dom, config || {tag:'div'}, !returnDom), newEl = (wrapFly || (wrapFly = new Ext.dom.Fly)).attach(Ext.getDom(result)), target = newEl, activeElement = (activeElFly || (activeElFly = new Ext.dom.Fly)).attach(Ext.Element.getActiveElement()), cached, resumeFocus, tabIndex;
    cached = Ext.cache[activeElement.dom.id];
    if (cached) {
      activeElement = cached;
    }
    if (selector) {
      target = newEl.selectNode(selector, returnDom);
    }
    if (me.contains(activeElement)) {
      if (cached) {
        cached.suspendFocusEvents();
      }
      tabIndex = Ext.getDom(newEl).getAttribute('tabIndex');
      newEl.set({tabIndex:-1});
      newEl.suspendFocusEvents();
      newEl.focus();
      resumeFocus = true;
    }
    (target.dom || target).appendChild(dom);
    if (resumeFocus) {
      if (cached) {
        cached.focus();
        cached.resumeFocusEvents();
      } else {
        activeElement.focus();
      }
      newEl.resumeFocusEvents();
      newEl.set({tabIndex:tabIndex});
    }
    return result;
  }, isFocusable:function(skipVisibility) {
    var dom = this.dom, focusable = false, nodeName;
    if (dom && !dom.disabled) {
      nodeName = dom.nodeName;
      focusable = !!Ext.Element.naturallyFocusableTags[nodeName] || (nodeName === 'A' || nodeName === 'LINK') && !!dom.href || dom.getAttribute('tabIndex') != null || dom.contentEditable === 'true';
      if (Ext.isIE8 && nodeName === 'INPUT' && dom.type === 'hidden') {
        focusable = false;
      }
      focusable = focusable && (skipVisibility || this.isVisible(true));
    }
    return focusable;
  }, isInputField:function() {
    var dom = this.dom, contentEditable = dom.contentEditable;
    if (Ext.Element.inputTags[dom.tagName] && dom.type !== 'button' || (contentEditable === '' || contentEditable === 'true')) {
      return true;
    }
    return false;
  }, isTabbable:function(includeHidden) {
    var dom = this.dom, tabbable = false, nodeName, hasIndex, tabIndex;
    if (dom && !dom.disabled) {
      nodeName = dom.nodeName;
      tabIndex = dom.getAttribute('tabIndex');
      hasIndex = tabIndex != null;
      tabIndex -= 0;
      if (nodeName === 'A' || nodeName === 'LINK') {
        if (dom.href) {
          tabbable = hasIndex && tabIndex < 0 ? false : true;
        } else {
          if (dom.contentEditable === 'true') {
            tabbable = !hasIndex || hasIndex && tabIndex >= 0 ? true : false;
          } else {
            tabbable = hasIndex && tabIndex >= 0 ? true : false;
          }
        }
      } else {
        if (dom.contentEditable === 'true' || Ext.Element.naturallyTabbableTags[nodeName]) {
          tabbable = hasIndex && tabIndex < 0 ? false : true;
        } else {
          if (hasIndex && tabIndex >= 0) {
            tabbable = true;
          }
        }
      }
      if (Ext.isIE8 && nodeName === 'INPUT' && dom.type === 'hidden') {
        tabbable = false;
      }
      tabbable = tabbable && (includeHidden || (!this.component || this.component.isVisible(true)) && this.isVisible(true));
    }
    return tabbable;
  }, ripplingCls:'x-rippling', ripplingTransitionCls:'x-ripple-transition', ripplingUnboundCls:'x-rippling-unbound', rippleBubbleCls:'x-ripple-bubble', rippleContainerCls:'x-ripple-container', rippleWrapperCls:'x-ripple-wrapper', noRippleDisplayMap:{table:1, 'table-row':1, 'table-row-group':1}, noRippleTagMap:{TABLE:1, TR:1, TBODY:1}, ripple:function(event, options) {
    if (options === true || !options) {
      options = {};
    } else {
      if (Ext.isString(options)) {
        options = {color:options};
      }
    }
    var me = this, rippleParent = Ext.isString(options.delegate) ? me.down(options.delegate) : me, rippleMeasureEl = Ext.isString(options.measureSelector) ? me.down(options.measureSelector) : null, color = window.getComputedStyle(rippleParent.dom).color, unbound = options.bound === false, position = options.position, ripplingCls = me.ripplingCls, ripplingTransitionCls = me.ripplingTransitionCls, ripplingUnboundCls = me.ripplingUnboundCls, rippleBubbleCls = me.rippleBubbleCls, rippleContainerCls = 
    me.rippleContainerCls, rippleWrapperCls = me.rippleWrapperCls, offset, width, height, rippleDiameter, center, measureElWidth, measureElHeight, rippleSize, pos, posX, posY, rippleWrapper, rippleContainer, rippleBubble, rippleDestructor, rippleClearFn, rippleDestructionTimer, rippleBox, unboundEl, unboundElData, timeout;
    if (rippleParent) {
      offset = rippleParent.getXY();
      width = rippleParent.getWidth();
      height = rippleParent.getHeight();
      timeout = rippleParent.$rippleClearTimeout;
      if (timeout) {
        rippleParent.$rippleClearTimeout = Ext.undefer(timeout);
      }
      if (rippleMeasureEl) {
        measureElWidth = rippleMeasureEl.getWidth();
        measureElHeight = rippleMeasureEl.getHeight();
        rippleDiameter = Math.max(measureElWidth, measureElHeight);
      } else {
        rippleDiameter = width > height ? width : height;
      }
      if (options.diameterLimit === undefined || options.diameterLimit === true) {
        rippleDiameter = Math.min(rippleDiameter, Element.maxRippleDiameter);
      } else {
        if (options.diameterLimit && options.diameterLimit !== false && options.diameterLimit !== 0) {
          rippleDiameter = Math.min(rippleDiameter, options.diameterLimit);
        }
      }
      center = [offset[0] + width / 2, offset[1] + height / 2];
      if (unbound) {
        if (options.fit !== false) {
          rippleSize = rippleDiameter * 2.15;
          rippleBox = rippleParent.getRegion();
          rippleBox.setPosition(rippleBox.getCenter()).setSize(rippleSize).translateBy(-rippleSize / 2, -rippleSize / 2);
          unboundEl = me.up(function(candidate) {
            var fly = Ext.fly(candidate, 'ripple');
            return !(candidate.tagName in me.noRippleTagMap) && !(fly.getStyle('display') in me.noRippleDisplayMap) && fly.getRegion().contains(rippleBox);
          }) || Ext.getBody();
        } else {
          unboundEl = rippleParent;
        }
      }
      if (Ext.isString(event)) {
        options.color = event;
        event = null;
      } else {
        if (event && !event.isEvent) {
          event = new Ext.event.Event(event);
        }
      }
      if (event && event.isEvent) {
        if (event.browserEvent.$preventRipple) {
          return;
        }
        position = event.getXY();
        event.browserEvent.$preventRipple = true;
      }
      pos = !unbound && !options.centered && position || center;
      posX = pos[0] - offset[0] - rippleDiameter / 2;
      posY = pos[1] - offset[1] - rippleDiameter / 2;
      rippleParent.addCls(ripplingTransitionCls);
      if (!unbound) {
        rippleParent.addCls(ripplingCls);
        rippleContainer = rippleParent.child('.' + rippleContainerCls);
      } else {
        unboundElData = unboundEl.getData();
        rippleWrapper = unboundElData.rippleWrapper;
        if (!rippleWrapper) {
          unboundElData.rippleWrapper = rippleWrapper = unboundEl.insertFirst({style:'position: absolute; top: 0; left: 0', cls:rippleWrapperCls + ' ' + ripplingCls + ' ' + ripplingUnboundCls});
        }
      }
      if (!rippleContainer) {
        if (unbound) {
          rippleContainer = rippleWrapper.append({cls:rippleContainerCls});
          rippleContainer.setXY(offset);
        } else {
          rippleContainer = rippleParent.append({cls:rippleContainerCls});
        }
      }
      rippleBubble = rippleContainer.append({cls:rippleBubbleCls});
      if (options.color !== 'default') {
        rippleBubble.setStyle('backgroundColor', options.color || color);
      }
      rippleBubble.setWidth(rippleDiameter);
      rippleBubble.setHeight(rippleDiameter);
      rippleBubble.setTop(posY);
      rippleBubble.setLeft(posX);
      rippleClearFn = function() {
        if (!rippleParent.destroyed) {
          rippleParent.$rippleClearTimeout = Ext.defer(function() {
            rippleParent.removeCls([ripplingCls, ripplingTransitionCls]);
            rippleParent.$rippleClearTimeout = null;
          }, 50);
        }
      };
      rippleDestructor = function() {
        var ripple, timeout;
        rippleBubble.destroy();
        if (me.$ripples) {
          delete me.$ripples[rippleBubble.id];
        }
        timeout = rippleParent.$rippleClearTimeout;
        if (timeout) {
          rippleParent.$rippleClearTimeout = Ext.undefer(timeout);
        }
        if (unbound) {
          rippleContainer.destroy();
          ripple = rippleWrapper.child('.' + rippleContainerCls);
          if (!ripple) {
            unboundElData.rippleWrapper = null;
            rippleWrapper.destroy();
            rippleClearFn();
          }
        } else {
          ripple = rippleContainer.child('.' + rippleBubbleCls);
          if (!ripple) {
            rippleContainer.destroy();
            rippleClearFn();
          }
        }
      };
      rippleDestructionTimer = Ext.defer(rippleDestructor, options.destroyTime || 1000, me);
      if (!me.$ripples) {
        me.$ripples = {};
      }
      me.$ripples[rippleBubble.id] = {timerId:rippleDestructionTimer, destructor:rippleDestructor};
      rippleBubble.addCls('x-ripple');
    }
  }, destroyAllRipples:function() {
    var me = this, rippleEl, ripple;
    for (rippleEl in me.$ripples) {
      ripple = me.$ripples[rippleEl];
      Ext.undefer(ripple.timerId);
      if (ripple.destructor) {
        ripple.destructor();
      }
    }
    me.$ripples = null;
  }, privates:{findTabbableElements:function(options) {
    var skipSelf, skipChildren, excludeRoot, includeSaved, includeHidden, dom = this.dom, cAttr = Ext.Element.tabbableSavedCounterAttribute, selection = [], idx = 0, nodes, node, fly, i, len, tabIndex;
    if (!dom) {
      return selection;
    }
    if (options) {
      skipSelf = options.skipSelf;
      skipChildren = options.skipChildren;
      excludeRoot = options.excludeRoot;
      includeSaved = options.includeSaved;
      includeHidden = options.includeHidden;
    }
    excludeRoot = excludeRoot && Ext.getDom(excludeRoot);
    if (excludeRoot && excludeRoot.contains(dom)) {
      return selection;
    }
    if (!skipSelf && (includeSaved && dom.hasAttribute(cAttr) || this.isTabbable(includeHidden))) {
      selection[idx++] = dom;
    }
    if (skipChildren) {
      return selection;
    }
    nodes = dom.querySelectorAll(Ext.Element.tabbableSelector);
    len = nodes.length;
    if (!len) {
      return selection;
    }
    fly = new Ext.dom.Fly;
    for (i = 0; i < len; i++) {
      node = nodes[i];
      tabIndex = +node.getAttribute('tabIndex');
      if ((includeSaved && node.hasAttribute(cAttr) || !(tabIndex < 0) && fly.attach(node).isTabbable(includeHidden)) && !(excludeRoot && (excludeRoot === node || excludeRoot.contains(node)))) {
        selection[idx++] = node;
      }
    }
    return selection;
  }, saveTabbableState:function(options) {
    var counterAttr = Ext.Element.tabbableSavedCounterAttribute, savedAttr = Ext.Element.tabbableSavedValueAttribute, counter, nodes, node, i, len;
    if (!options || options.includeSaved == null) {
      options = Ext.Object.chain(options || null);
      options.includeSaved = true;
    }
    nodes = this.findTabbableElements(options);
    for (i = 0, len = nodes.length; i < len; i++) {
      node = nodes[i];
      counter = +node.getAttribute(counterAttr);
      if (counter > 0) {
        node.setAttribute(counterAttr, ++counter);
      } else {
        if (node.hasAttribute('tabIndex')) {
          node.setAttribute(savedAttr, node.getAttribute('tabIndex'));
        } else {
          node.setAttribute(savedAttr, 'none');
        }
        node.setAttribute('tabIndex', '-1');
        node.setAttribute(counterAttr, '1');
      }
    }
    return nodes;
  }, restoreTabbableState:function(options) {
    var dom = this.dom, counterAttr = Ext.Element.tabbableSavedCounterAttribute, savedAttr = Ext.Element.tabbableSavedValueAttribute, nodes = [], skipSelf = options && options.skipSelf, skipChildren = options && options.skipChildren, reset = options && options.reset, idx, counter, node, i, len;
    if (!dom) {
      return this;
    }
    if (!skipChildren) {
      nodes = Ext.Array.from(dom.querySelectorAll('[' + counterAttr + ']'));
    }
    if (!skipSelf) {
      nodes.unshift(dom);
    }
    for (i = 0, len = nodes.length; i < len; i++) {
      node = nodes[i];
      if (!node.hasAttribute(counterAttr) || !node.hasAttribute(savedAttr)) {
        continue;
      }
      counter = +node.getAttribute(counterAttr);
      if (!reset && counter > 1) {
        node.setAttribute(counterAttr, --counter);
        continue;
      }
      idx = node.getAttribute(savedAttr);
      if (idx === 'none') {
        node.removeAttribute('tabIndex');
      } else {
        node.setAttribute('tabIndex', idx);
      }
      node.removeAttribute(savedAttr);
      node.removeAttribute(counterAttr);
    }
    return nodes;
  }, setTabIndex:function(tabIndex) {
    var dom = this.dom, savedAttr = Ext.Element.tabbableSavedValueAttribute;
    if (dom.hasAttribute(savedAttr)) {
      if (tabIndex == null) {
        dom.setAttribute(savedAttr, 'none');
        dom.removeAttribute('tabIndex');
      } else {
        dom.setAttribute(savedAttr, tabIndex);
      }
    } else {
      if (tabIndex == null) {
        dom.removeAttribute('tabIndex');
      } else {
        dom.setAttribute('tabIndex', tabIndex);
      }
    }
  }, doAddListener:function(eventName, fn, scope, options, order, caller, manager) {
    var me = this, originalName = eventName, observableDoAddListener, additiveEventName, translatedEventName;
    eventName = Ext.canonicalEventName(eventName);
    if (!me.blockedEvents[eventName]) {
      observableDoAddListener = me.mixins.observable.doAddListener;
      options = options || {};
      if (Element.useDelegatedEvents === false) {
        options.delegated = options.delegated || false;
      }
      if (options.translate !== false) {
        additiveEventName = me.additiveEvents[eventName];
        if (additiveEventName) {
          options.type = eventName;
          eventName = additiveEventName;
          observableDoAddListener.call(me, eventName, fn, scope, options, order, caller, manager);
        }
        translatedEventName = me.eventMap[eventName];
        if (translatedEventName) {
          options.type = options.type || eventName;
          if (manager) {
            options.managedName = originalName;
          }
          eventName = translatedEventName;
        }
      }
      if (observableDoAddListener.call(me, eventName, fn, scope, options, order, caller, manager)) {
        if (me.longpressEvents[eventName] && ++me.longpressListenerCount === 1) {
          me.on('MSHoldVisual', 'preventMsHoldVisual', me);
        }
      }
      if (manager && translatedEventName) {
        delete options.managedName;
      }
      delete options.type;
    }
  }, doRemoveListener:function(eventName, fn, scope) {
    var me = this, observableDoRemoveListener, translatedEventName, additiveEventName, removed;
    eventName = Ext.canonicalEventName(eventName);
    if (!me.blockedEvents[eventName]) {
      observableDoRemoveListener = me.mixins.observable.doRemoveListener;
      additiveEventName = me.additiveEvents[eventName];
      if (additiveEventName) {
        eventName = additiveEventName;
        observableDoRemoveListener.call(me, eventName, fn, scope);
      }
      translatedEventName = me.eventMap[eventName];
      if (translatedEventName) {
        removed = observableDoRemoveListener.call(me, translatedEventName, fn, scope);
      }
      removed = observableDoRemoveListener.call(me, eventName, fn, scope) || removed;
      if (removed) {
        if (me.longpressEvents[eventName] && !--me.longpressListenerCount) {
          me.un('MSHoldVisual', 'preventMsHoldVisual', me);
        }
      }
    }
  }, _initEvent:function(eventName) {
    return this.events[eventName] = new Ext.dom.ElementEvent(this, eventName);
  }, _getDisplay:function() {
    var data = this.getData(), display = data[ORIGINALDISPLAY];
    if (display === undefined) {
      data[ORIGINALDISPLAY] = display = '';
    }
    return display;
  }, _getPublisher:function(eventName, noTranslate) {
    var Publisher = Ext.event.publisher.Publisher, publisher = Publisher.publishersByEvent[eventName], isNative = noTranslate && !Ext.event.Event.gestureEvents[eventName];
    if (isNative || !publisher || this.dom === window && eventName === 'resize') {
      publisher = Publisher.publishers.dom;
    }
    return publisher;
  }, isFocusSuspended:function() {
    var data = this.peekData();
    return data && data.suspendFocusEvents;
  }, preventMsHoldVisual:function(e) {
    e.preventDefault();
  }, suspendFocusEvents:function() {
    if (!this.isFly) {
      this.suspendEvent('focus', 'blur');
    }
    this.getData().suspendFocusEvents = true;
  }, resumeFocusEvents:function() {
    function resumeFn() {
      var data;
      if (!this.destroyed) {
        data = this.getData();
        if (data) {
          data.suspendFocusEvents = false;
        }
        if (!this.isFly) {
          this.resumeEvent('focus', 'blur');
        }
      }
    }
    if (!this.destroyed && this.getData().suspendFocusEvents) {
      if (Ext.isIE && !this.isFly) {
        this.resumeFocusEventsTimer = Ext.asap(resumeFn, this);
      } else {
        resumeFn.call(this);
      }
    }
  }}, deprecated:{'5.0':{methods:{getHTML:'getHtml', getPageBox:function(getRegion) {
    var me = this, dom = me.dom, isDoc = dom.nodeName === 'BODY', w = isDoc ? Element.getViewportWidth() : dom.offsetWidth, h = isDoc ? Element.getViewportHeight() : dom.offsetHeight, xy = me.getXY(), t = xy[1], r = xy[0] + w, b = xy[1] + h, l = xy[0];
    if (getRegion) {
      return new Ext.util.Region(t, r, b, l);
    } else {
      return {left:l, top:t, width:w, height:h, right:r, bottom:b};
    }
  }, isTransparent:function(prop) {
    var value = this.getStyle(prop);
    return value ? transparentRe.test(value) : false;
  }, purgeAllListeners:'clearListeners', removeAllListeners:'clearListeners', setHTML:'setHtml'}}}};
}, 1, 0, 0, 0, 0, [[Ext.util.Positionable.prototype.mixinId || Ext.util.Positionable.$className, Ext.util.Positionable], [Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.dom, 'Element', Ext, 'Element'], function(Element) {
  var DOC = document, docEl = DOC.documentElement, prototype = Element.prototype, supports = Ext.supports, pointerdown = 'pointerdown', pointermove = 'pointermove', pointerup = 'pointerup', pointercancel = 'pointercancel', MSPointerDown = 'MSPointerDown', MSPointerMove = 'MSPointerMove', MSPointerUp = 'MSPointerUp', MSPointerCancel = 'MSPointerCancel', mousedown = 'mousedown', mousemove = 'mousemove', mouseup = 'mouseup', mouseover = 'mouseover', mouseout = 'mouseout', mouseenter = 'mouseenter', 
  mouseleave = 'mouseleave', touchstart = 'touchstart', touchmove = 'touchmove', touchend = 'touchend', touchcancel = 'touchcancel', click = 'click', dblclick = 'dblclick', tap = 'tap', doubletap = 'doubletap', eventMap = prototype.eventMap = {}, additiveEvents = prototype.additiveEvents = {}, oldId = Ext.id, eventOptions;
  prototype._init(Element);
  delete prototype._init;
  Ext.id = function(obj, prefix) {
    var el = obj && Ext.getDom(obj, true), sandboxPrefix, id;
    if (!el) {
      id = oldId(obj, prefix);
    } else {
      if (!(id = el.id)) {
        id = oldId(null, prefix || Element.prototype.identifiablePrefix);
        if (Ext.isSandboxed) {
          sandboxPrefix = Ext.sandboxPrefix || (Ext.sandboxPrefix = Ext.sandboxName.toLowerCase() + '-');
          id = sandboxPrefix + id;
        }
        el.id = id;
      }
    }
    return id;
  };
  if (supports.PointerEvents) {
    eventMap[mousedown] = pointerdown;
    eventMap[mousemove] = pointermove;
    eventMap[mouseup] = pointerup;
    eventMap[touchstart] = pointerdown;
    eventMap[touchmove] = pointermove;
    eventMap[touchend] = pointerup;
    eventMap[touchcancel] = pointercancel;
    eventMap[mouseover] = 'pointerover';
    eventMap[mouseout] = 'pointerout';
    eventMap[mouseenter] = 'pointerenter';
    if (!Ext.isIE11) {
      eventMap[mouseleave] = 'pointerleave';
    }
  } else {
    if (supports.MSPointerEvents) {
      eventMap[pointerdown] = MSPointerDown;
      eventMap[pointermove] = MSPointerMove;
      eventMap[pointerup] = MSPointerUp;
      eventMap[pointercancel] = MSPointerCancel;
      eventMap[mousedown] = MSPointerDown;
      eventMap[mousemove] = MSPointerMove;
      eventMap[mouseup] = MSPointerUp;
      eventMap[touchstart] = MSPointerDown;
      eventMap[touchmove] = MSPointerMove;
      eventMap[touchend] = MSPointerUp;
      eventMap[touchcancel] = MSPointerCancel;
      eventMap[mouseover] = 'MSPointerOver';
      eventMap[mouseout] = 'MSPointerOut';
    } else {
      if (supports.TouchEvents) {
        eventMap[pointerdown] = touchstart;
        eventMap[pointermove] = touchmove;
        eventMap[pointerup] = touchend;
        eventMap[pointercancel] = touchcancel;
        eventMap[mousedown] = touchstart;
        eventMap[mousemove] = touchmove;
        eventMap[mouseup] = touchend;
        eventMap[click] = tap;
        eventMap[dblclick] = doubletap;
        if (Ext.os.is.Desktop) {
          eventMap[touchstart] = mousedown;
          eventMap[touchmove] = mousemove;
          eventMap[touchend] = mouseup;
          eventMap[touchcancel] = mouseup;
          additiveEvents[mousedown] = mousedown;
          additiveEvents[mousemove] = mousemove;
          additiveEvents[mouseup] = mouseup;
          additiveEvents[touchstart] = touchstart;
          additiveEvents[touchmove] = touchmove;
          additiveEvents[touchend] = touchend;
          additiveEvents[touchcancel] = touchcancel;
          additiveEvents[pointerdown] = mousedown;
          additiveEvents[pointermove] = mousemove;
          additiveEvents[pointerup] = mouseup;
          additiveEvents[pointercancel] = mouseup;
        }
      } else {
        eventMap[pointerdown] = mousedown;
        eventMap[pointermove] = mousemove;
        eventMap[pointerup] = mouseup;
        eventMap[pointercancel] = mouseup;
        eventMap[touchstart] = mousedown;
        eventMap[touchmove] = mousemove;
        eventMap[touchend] = mouseup;
        eventMap[touchcancel] = mouseup;
      }
    }
  }
  if (Ext.isWebKit) {
    eventMap.transitionend = Ext.browser.getVendorProperyName('transitionEnd');
    eventMap.animationstart = Ext.browser.getVendorProperyName('animationStart');
    eventMap.animationend = Ext.browser.getVendorProperyName('animationEnd');
  }
  if (!Ext.supports.MouseWheel && !Ext.isOpera) {
    eventMap.mousewheel = 'DOMMouseScroll';
  }
  eventOptions = prototype.$eventOptions = Ext.Object.chain(prototype.$eventOptions);
  eventOptions.translate = eventOptions.capture = eventOptions.delegate = eventOptions.delegated = eventOptions.stopEvent = eventOptions.preventDefault = eventOptions.stopPropagation = eventOptions.element = 1;
  prototype.styleHooks.opacity = {name:'opacity', afterSet:function(dom, value, el) {
    var shadow = el.shadow;
    if (shadow) {
      shadow.setOpacity(value);
    }
  }};
  prototype.getTrueXY = prototype.getXY;
  Ext.getViewportHeight = Element.getViewportHeight;
  Ext.getViewportWidth = Element.getViewportWidth;
  Ext.select = Element.select;
  Ext.query = Element.query;
  Ext.apply(Ext, {get:function(element) {
    return Element.get(element);
  }, getDom:function(el) {
    if (!el || !DOC) {
      return null;
    }
    return typeof el === 'string' ? Ext.getElementById(el) : 'dom' in el ? el.dom : el;
  }, getBody:function() {
    if (!Ext._bodyEl) {
      if (!DOC.body) {
        throw new Error('[Ext.getBody] document.body does not yet exist');
      }
      Ext._bodyEl = Ext.get(DOC.body);
      Ext._bodyEl.skipGarbageCollection = true;
    }
    return Ext._bodyEl;
  }, getHead:function() {
    if (!Ext._headEl) {
      Ext._headEl = Ext.get(DOC.head || DOC.getElementsByTagName('head')[0]);
      Ext._headEl.skipGarbageCollection = true;
    }
    return Ext._headEl;
  }, getDoc:function() {
    if (!Ext._docEl) {
      Ext._docEl = Ext.get(DOC);
      Ext._docEl.skipGarbageCollection = true;
    }
    return Ext._docEl;
  }, getWin:function() {
    if (!Ext._winEl) {
      Ext._winEl = Ext.get(window);
      Ext._winEl.skipGarbageCollection = true;
    }
    return Ext._winEl;
  }, removeNode:function(node) {
    node = node.dom || node;
    var id = node && node.id, el = Ext.cache[id], parent;
    if (el) {
      el.destroy();
    } else {
      if (node && (node.nodeType === 3 || node.tagName.toUpperCase() !== 'BODY')) {
        parent = node.parentNode;
        if (parent) {
          parent.removeChild(node);
        }
      }
    }
  }});
  Ext.isGarbage = function(dom) {
    return dom && dom.nodeType === 1 && dom.tagName !== 'BODY' && dom.tagName !== 'HTML' && (!dom.parentNode || dom.offsetParent === null && (Ext.isIE8 ? DOC.all[dom.id] : DOC.getElementById(dom.id)) !== dom && !(Ext.detachedBodyEl && Ext.detachedBodyEl.isAncestor(dom)));
  };
  Ext.onInternalReady(function() {
    var bodyCls = [], theme;
    Ext.getDoc().on('selectstart', function(ev, dom) {
      var selectableCls = Element.selectableCls, unselectableCls = Element.unselectableCls, tagName = dom && dom.tagName, el = new Ext.dom.Fly;
      tagName = tagName && tagName.toLowerCase();
      if (tagName === 'input' || tagName === 'textarea') {
        return;
      }
      while (dom && dom.nodeType === 1 && dom !== DOC.documentElement) {
        el.attach(dom);
        if (el.hasCls(selectableCls)) {
          return;
        }
        if (el.hasCls(unselectableCls)) {
          ev.stopEvent();
          return;
        }
        dom = dom.parentNode;
      }
    });
    if (Ext.os.is.Android || Ext.os.is.Windows && Ext.supports.Touch) {
      var win = Ext.getWin();
      Element._documentWidth = Element._viewportWidth = docEl.clientWidth;
      Element._documentHeight = Element._viewportHeight = docEl.clientHeight;
      win.on({focusin:'_onWindowFocusChange', focusout:'_onWindowFocusChange', pointerup:'_onWindowFocusChange', capture:true, delegated:false, delay:1, scope:Element});
      win.on({resize:'_onWindowResize', priority:2000, scope:Element});
    }
    if (supports.Touch) {
      bodyCls.push('x-touch');
    }
    if (Ext.isIE && Ext.isIE9m) {
      bodyCls.push('x-ie', 'x-ie9m');
      bodyCls.push('x-ie8p');
      if (Ext.isIE8) {
        bodyCls.push('x-ie8');
      } else {
        bodyCls.push('x-ie9', 'x-ie9p');
      }
      if (Ext.isIE8m) {
        bodyCls.push('x-ie8m');
      }
    }
    if (Ext.isIE10) {
      bodyCls.push('x-ie10');
    }
    if (Ext.isIE10p) {
      bodyCls.push('x-ie10p');
    }
    if (Ext.isIE11) {
      bodyCls.push('x-ie11');
    }
    if (Ext.isEdge) {
      bodyCls.push('x-edge');
    }
    if (Ext.isGecko) {
      bodyCls.push('x-gecko');
    }
    if (Ext.isOpera) {
      bodyCls.push('x-opera');
    }
    if (Ext.isOpera12m) {
      bodyCls.push('x-opera12m');
    }
    if (Ext.isWebKit) {
      bodyCls.push('x-webkit');
    }
    if (Ext.isSafari) {
      bodyCls.push('x-safari');
    }
    if (Ext.isSafari && Ext.browser.version.isLessThan(11)) {
      bodyCls.push('x-safari10m');
    }
    if (Ext.isSafari9) {
      bodyCls.push('x-safari9');
    }
    if (Ext.isSafari && Ext.browser.version.isLessThan(9)) {
      bodyCls.push('x-safari8m');
    }
    if (Ext.isChrome) {
      bodyCls.push('x-chrome');
    }
    if (Ext.isMac) {
      bodyCls.push('x-mac');
    }
    if (Ext.isWindows) {
      bodyCls.push('x-windows');
    }
    if (Ext.isLinux) {
      bodyCls.push('x-linux');
    }
    if (!supports.CSS3BorderRadius) {
      bodyCls.push('x-nbr');
    }
    if (!supports.CSS3LinearGradient) {
      bodyCls.push('x-nlg');
    }
    if (supports.Touch) {
      bodyCls.push('x-touch');
    }
    if (Ext.os.deviceType) {
      bodyCls.push('x-' + Ext.os.deviceType.toLowerCase());
    }
    if (Ext.os.is.BlackBerry) {
      bodyCls.push('x-bb');
      if (Ext.browser.userAgent.match(/Kbd/gi)) {
        bodyCls.push('x-bb-keyboard');
      }
    }
    if (Ext.os.is.iOS && Ext.isSafari) {
      bodyCls.push('x-mobile-safari');
    }
    if (Ext.os.is.iOS && Ext.browser.is.WebView && !Ext.browser.is.Standalone) {
      bodyCls.push('x-ios-native');
    }
    Ext.getBody().addCls(bodyCls);
    theme = Ext.theme;
    if (theme && theme.getDocCls) {
      Ext.fly(document.documentElement).addCls(theme.getDocCls());
    }
  }, null, {priority:1500});
});
Ext.cmd.derive('Ext.util.Filter', Ext.Base, {isFilter:true, config:{property:null, value:null, filterFn:null, id:null, anyMatch:false, exactMatch:false, caseSensitive:false, disabled:false, disableOnEmpty:false, operator:null, root:null, serializer:null, convert:null}, scope:null, $configStrict:false, generation:0, statics:{createFilterFn:function(filters) {
  if (!filters) {
    return Ext.returnTrue;
  }
  return function(candidate) {
    var items = filters.isCollection ? filters.items : filters, length = items.length, match = true, i, filter;
    for (i = 0; match && i < length; i++) {
      filter = items[i];
      if (!filter.getDisabled()) {
        match = filter.filter(candidate);
      }
    }
    return match;
  };
}, isEqual:function(filter1, filter2) {
  if (filter1.getProperty() !== filter2.getProperty()) {
    return false;
  }
  if (filter1.getOperator() !== filter2.getOperator()) {
    return false;
  }
  if (filter1.getValue() === filter2.getValue()) {
    return true;
  } else {
    if (Ext.isArray(filter1) && Ext.isArray(filter2) && Ext.Array.equals(filter1, filter2)) {
      return true;
    }
  }
  return false;
}, isInvalid:function(cfg) {
  if (!cfg.filterFn) {
    if (!cfg.property) {
      return 'A Filter requires either a property or a filterFn to be set';
    }
    if (!cfg.hasOwnProperty('value') && !cfg.operator) {
      return 'A Filter requires either a property and value, or a filterFn to be set';
    }
  }
  return false;
}}, constructor:function(config) {
  this.initConfig(config);
}, preventConvert:{'in':1, notin:1}, filter:function(item) {
  var me = this, filterFn = me._filterFn || me.getFilterFn(), convert = me.getConvert(), value = me._value;
  me._filterValue = value;
  me.isDateValue = Ext.isDate(value);
  if (me.isDateValue) {
    me.dateValue = value.getTime();
  }
  if (convert && !me.preventConvert[me.getOperator()]) {
    me._filterValue = convert.call(me.scope || me, value);
  }
  return filterFn.call(me.scope || me, item);
}, getId:function() {
  var id = this._id;
  if (!id) {
    id = this.getProperty();
    if (!id) {
      id = Ext.id(null, 'ext-filter-');
    }
    this._id = id;
  }
  return id;
}, getFilterFn:function() {
  var me = this, filterFn = me._filterFn, operator;
  if (!filterFn) {
    operator = me.getOperator();
    if (operator) {
      filterFn = me.operatorFns[operator];
    } else {
      filterFn = me.createRegexFilter();
    }
    me._filterFn = filterFn;
    me.generatedFilterFn = true;
  }
  return filterFn;
}, createRegexFilter:function() {
  var me = this, anyMatch = !!me.getAnyMatch(), exact = !!me.getExactMatch(), value = me.getValue(), matcher = Ext.String.createRegex(value, !anyMatch, !anyMatch && exact, !me.getCaseSensitive());
  return function(item) {
    var val = me.getPropertyValue(item);
    return matcher ? matcher.test(val) : val == null;
  };
}, getPropertyValue:function(item) {
  var root = this._root, value = root == null ? item : item[root];
  return value[this._property];
}, getState:function() {
  var config = this.getInitialConfig(), result = {}, name;
  for (name in config) {
    if (config.hasOwnProperty(name)) {
      result[name] = config[name];
    }
  }
  delete result.root;
  result.value = this.getValue();
  return result;
}, getScope:function() {
  return this.scope;
}, serialize:function() {
  var result = this.getState(), serializer = this.getSerializer(), serialized;
  delete result.id;
  delete result.serializer;
  if (serializer) {
    serialized = serializer.call(this, result);
    if (serialized) {
      result = serialized;
    }
  }
  return result;
}, updateDisabled:function() {
  this.generation++;
}, updateOperator:function() {
  this.onConfigMutation();
}, updateConvert:function() {
  this.onConfigMutation();
}, updateProperty:function() {
  this.onConfigMutation();
}, updateAnyMatch:function() {
  this.onConfigMutation();
}, updateExactMatch:function() {
  this.onConfigMutation();
}, updateCaseSensitive:function() {
  this.onConfigMutation();
}, updateValue:function(value) {
  this.onConfigMutation();
  if (this.getDisableOnEmpty()) {
    this.setDisabled(Ext.isEmpty(value));
  }
}, updateFilterFn:function(filterFn) {
  delete this.generatedFilterFn;
}, onConfigMutation:function() {
  this.generation++;
  if (this.generatedFilterFn) {
    this._filterFn = null;
  }
}, updateDisableOnEmpty:function(disableOnEmpty) {
  if (disableOnEmpty) {
    this.setDisabled(Ext.isEmpty(this.getValue()));
  }
}, privates:{getCandidateValue:function(candidate, v, preventCoerce) {
  var me = this, convert = me._convert, result = me.getPropertyValue(candidate);
  if (convert) {
    result = convert.call(me.scope || me, result);
  } else {
    if (!preventCoerce) {
      result = Ext.coerce(result, v);
    }
  }
  return result;
}}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Filter'], function() {
  var prototype = this.prototype, operatorFns = prototype.operatorFns = {'\x3c':function(candidate) {
    var v = this._filterValue;
    return this.getCandidateValue(candidate, v) < v;
  }, '\x3c\x3d':function(candidate) {
    var v = this._filterValue;
    return this.getCandidateValue(candidate, v) <= v;
  }, '\x3d':function(candidate) {
    var me = this, v = me._filterValue;
    candidate = me.getCandidateValue(candidate, v);
    if (me.isDateValue && candidate instanceof Date) {
      candidate = candidate.getTime();
      v = me.dateValue;
    }
    return candidate == v;
  }, '\x3d\x3d\x3d':function(candidate) {
    var me = this, v = me._filterValue;
    candidate = me.getCandidateValue(candidate, v, true);
    if (me.isDateValue && candidate instanceof Date) {
      candidate = candidate.getTime();
      v = me.dateValue;
    }
    return candidate === v;
  }, '\x3e\x3d':function(candidate) {
    var v = this._filterValue;
    return this.getCandidateValue(candidate, v) >= v;
  }, '\x3e':function(candidate) {
    var v = this._filterValue;
    return this.getCandidateValue(candidate, v) > v;
  }, '!\x3d':function(candidate) {
    var me = this, v = me._filterValue;
    candidate = me.getCandidateValue(candidate, v);
    if (me.isDateValue && candidate instanceof Date) {
      candidate = candidate.getTime();
      v = me.dateValue;
    }
    return candidate != v;
  }, '!\x3d\x3d':function(candidate) {
    var me = this, v = me._filterValue;
    candidate = me.getCandidateValue(candidate, v, true);
    if (me.isDateValue && candidate instanceof Date) {
      candidate = candidate.getTime();
      v = me.dateValue;
    }
    return candidate !== v;
  }, 'in':function(candidate) {
    var v = this._filterValue;
    return Ext.Array.contains(v, this.getCandidateValue(candidate, v));
  }, notin:function(candidate) {
    var v = this._filterValue;
    return !Ext.Array.contains(v, this.getCandidateValue(candidate, v));
  }, like:function(candidate) {
    var v = this._filterValue;
    return v && this.getCandidateValue(candidate, v).toLowerCase().indexOf(v.toLowerCase()) > -1;
  }, '/\x3d':function(candidate) {
    var me = this, v = me._filterValue;
    candidate = me.getCandidateValue(candidate, v);
    if (v !== me.lastRegExpSource) {
      me.lastRegExpSource = v;
      try {
        me.regex = new RegExp(v, 'i');
      } catch (e$23) {
        me.regex = null;
      }
    }
    return me.regex ? me.regex.test(candidate) : false;
  }};
  operatorFns['\x3d\x3d'] = operatorFns['\x3d'];
  operatorFns.gt = operatorFns['\x3e'];
  operatorFns.ge = operatorFns['\x3e\x3d'];
  operatorFns.lt = operatorFns['\x3c'];
  operatorFns.le = operatorFns['\x3c\x3d'];
  operatorFns.eq = operatorFns['\x3d'];
  operatorFns.ne = operatorFns['!\x3d'];
});
Ext.cmd.derive('Ext.util.Observable', Ext.mixin.Observable, {$applyConfigs:true}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Observable'], function(Observable) {
  var Super = Ext.mixin.Observable;
  Observable.releaseCapture = Super.releaseCapture;
  Observable.capture = Super.capture;
  Observable.captureArgs = Super.captureArgs;
  Observable.observe = Observable.observeClass = Super.observe;
});
Ext.cmd.derive('Ext.util.AbstractMixedCollection', Ext.Base, {isMixedCollection:true, generation:0, indexGeneration:0, constructor:function(allowFunctions, keyFn) {
  var me = this;
  if (arguments.length === 1 && Ext.isObject(allowFunctions)) {
    me.initialConfig = allowFunctions;
    Ext.apply(me, allowFunctions);
  } else {
    me.allowFunctions = allowFunctions === true;
    if (keyFn) {
      me.getKey = keyFn;
    }
    me.initialConfig = {allowFunctions:me.allowFunctions, getKey:me.getKey};
  }
  me.items = [];
  me.map = {};
  me.keys = [];
  me.indexMap = {};
  me.length = 0;
  me.mixins.observable.constructor.call(me);
}, destroy:function() {
  var me = this;
  me.items = me.map = me.keys = me.indexMap = null;
  me.callParent();
}, allowFunctions:false, add:function(key, obj) {
  var len = this.length, out;
  if (arguments.length === 1) {
    out = this.insert(len, key);
  } else {
    out = this.insert(len, key, obj);
  }
  return out;
}, getKey:function(item) {
  return item.id;
}, replace:function(key, o) {
  var me = this, old, index;
  if (arguments.length == 1) {
    o = arguments[0];
    key = me.getKey(o);
  }
  old = me.map[key];
  if (typeof key == 'undefined' || key === null || typeof old == 'undefined') {
    return me.add(key, o);
  }
  me.generation++;
  index = me.indexOfKey(key);
  me.items[index] = o;
  me.map[key] = o;
  if (me.hasListeners.replace) {
    me.fireEvent('replace', key, old, o);
  }
  return o;
}, reorder:function(mapping) {
  var me = this, items = me.items, index = 0, length = items.length, order = [], remaining = [], oldIndex;
  me.suspendEvents();
  for (oldIndex in mapping) {
    order[mapping[oldIndex]] = items[oldIndex];
  }
  for (index = 0; index < length; index++) {
    if (mapping[index] == undefined) {
      remaining.push(items[index]);
    }
  }
  for (index = 0; index < length; index++) {
    if (order[index] == undefined) {
      order[index] = remaining.shift();
    }
  }
  me.clear();
  me.addAll(order);
  me.resumeEvents();
}, updateKey:function(oldKey, newKey) {
  var me = this, map = me.map, index = me.indexOfKey(oldKey), indexMap = me.indexMap, item;
  if (index > -1) {
    item = map[oldKey];
    delete map[oldKey];
    delete indexMap[oldKey];
    map[newKey] = item;
    indexMap[newKey] = index;
    me.keys[index] = newKey;
    me.indexGeneration = ++me.generation;
  }
}, addAll:function(objs) {
  var me = this, key;
  if (arguments.length > 1 || Ext.isArray(objs)) {
    me.insert(me.length, arguments.length > 1 ? arguments : objs);
  } else {
    for (key in objs) {
      if (objs.hasOwnProperty(key)) {
        if (me.allowFunctions || typeof objs[key] != 'function') {
          me.add(key, objs[key]);
        }
      }
    }
  }
}, each:function(fn, scope) {
  var items = Ext.Array.push([], this.items), i = 0, len = items.length, item;
  for (; i < len; i++) {
    item = items[i];
    if (fn.call(scope || item, item, i, len) === false) {
      break;
    }
  }
}, eachKey:function(fn, scope) {
  var keys = this.keys, items = this.items, i = 0, len = keys.length;
  for (; i < len; i++) {
    fn.call(scope || window, keys[i], items[i], i, len);
  }
}, findBy:function(fn, scope) {
  var keys = this.keys, items = this.items, i = 0, len = items.length;
  for (; i < len; i++) {
    if (fn.call(scope || window, items[i], keys[i])) {
      return items[i];
    }
  }
  return null;
}, insert:function(index, key, obj) {
  var out;
  if (Ext.isIterable(key)) {
    out = this.doInsert(index, key, obj);
  } else {
    if (arguments.length > 2) {
      out = this.doInsert(index, [key], [obj]);
    } else {
      out = this.doInsert(index, [key]);
    }
    out = out[0];
  }
  return out;
}, doInsert:function(index, keys, objects) {
  var me = this, itemKey, removeIndex, i, len = keys.length, deDupedLen = len, fireAdd = me.hasListeners.add, syncIndices, newKeys = {}, passedDuplicates, oldKeys, oldObjects;
  if (objects != null) {
    me.useLinearSearch = true;
  } else {
    objects = keys;
    keys = new Array(len);
    for (i = 0; i < len; i++) {
      keys[i] = this.getKey(objects[i]);
    }
  }
  me.suspendEvents();
  for (i = 0; i < len; i++) {
    itemKey = keys[i];
    removeIndex = me.indexOfKey(itemKey);
    if (removeIndex !== -1) {
      if (removeIndex < index) {
        index--;
      }
      me.removeAt(removeIndex);
    }
    if (itemKey != null) {
      if (newKeys[itemKey] != null) {
        passedDuplicates = true;
        deDupedLen--;
      }
      newKeys[itemKey] = i;
    }
  }
  me.resumeEvents();
  if (passedDuplicates) {
    oldKeys = keys;
    oldObjects = objects;
    keys = new Array(deDupedLen);
    objects = new Array(deDupedLen);
    i = 0;
    for (itemKey in newKeys) {
      keys[i] = oldKeys[newKeys[itemKey]];
      objects[i] = oldObjects[newKeys[itemKey]];
      i++;
    }
    len = deDupedLen;
  }
  syncIndices = index === me.length && me.indexGeneration === me.generation;
  Ext.Array.insert(me.items, index, objects);
  Ext.Array.insert(me.keys, index, keys);
  me.length += len;
  me.generation++;
  if (syncIndices) {
    me.indexGeneration = me.generation;
  }
  for (i = 0; i < len; i++, index++) {
    itemKey = keys[i];
    if (itemKey != null) {
      me.map[itemKey] = objects[i];
      if (syncIndices) {
        me.indexMap[itemKey] = index;
      }
    }
    if (fireAdd) {
      me.fireEvent('add', index, objects[i], itemKey);
    }
  }
  return objects;
}, remove:function(o) {
  var me = this, removeKey, index;
  if (!me.useLinearSearch && (removeKey = me.getKey(o))) {
    index = me.indexOfKey(removeKey);
  } else {
    index = Ext.Array.indexOf(me.items, o);
  }
  return index === -1 ? false : me.removeAt(index);
}, removeAll:function(items) {
  var me = this, i;
  if (items || me.hasListeners.remove) {
    if (items) {
      for (i = items.length - 1; i >= 0; --i) {
        me.remove(items[i]);
      }
    } else {
      while (me.length) {
        me.removeAt(0);
      }
    }
  } else {
    me.length = me.items.length = me.keys.length = 0;
    me.map = {};
    me.indexMap = {};
    me.generation++;
    me.indexGeneration = me.generation;
  }
}, removeAt:function(index) {
  var me = this, o, key;
  if (index < me.length && index >= 0) {
    me.length--;
    o = me.items[index];
    Ext.Array.erase(me.items, index, 1);
    key = me.keys[index];
    if (typeof key != 'undefined') {
      delete me.map[key];
    }
    Ext.Array.erase(me.keys, index, 1);
    if (me.hasListeners.remove) {
      me.fireEvent('remove', o, key);
    }
    me.generation++;
    return o;
  }
  return false;
}, removeRange:function(index, removeCount) {
  var me = this, o, key, i, limit, syncIndices, trimming;
  if (index < me.length && index >= 0) {
    if (!removeCount) {
      removeCount = 1;
    }
    limit = Math.min(index + removeCount, me.length);
    removeCount = limit - index;
    trimming = limit === me.length;
    syncIndices = trimming && me.indexGeneration === me.generation;
    for (i = index; i < limit; i++) {
      key = me.keys[i];
      if (key != null) {
        delete me.map[key];
        if (syncIndices) {
          delete me.indexMap[key];
        }
      }
    }
    o = me.items[i - 1];
    me.length -= removeCount;
    me.generation++;
    if (syncIndices) {
      me.indexGeneration = me.generation;
    }
    if (trimming) {
      me.items.length = me.keys.length = me.length;
    } else {
      me.items.splice(index, removeCount);
      me.keys.splice(index, removeCount);
    }
    return o;
  }
  return false;
}, removeAtKey:function(key) {
  var me = this, keys = me.keys, i;
  if (key == null) {
    for (i = keys.length - 1; i >= 0; i--) {
      if (keys[i] == null) {
        me.removeAt(i);
      }
    }
  } else {
    return me.removeAt(me.indexOfKey(key));
  }
}, getCount:function() {
  return this.length;
}, indexOf:function(o) {
  var me = this, key;
  if (o != null) {
    if (!me.useLinearSearch && (key = me.getKey(o))) {
      return this.indexOfKey(key);
    }
    return Ext.Array.indexOf(me.items, o);
  }
  return -1;
}, indexOfKey:function(key) {
  if (!this.map.hasOwnProperty(key)) {
    return -1;
  }
  if (this.indexGeneration !== this.generation) {
    this.rebuildIndexMap();
  }
  return this.indexMap[key];
}, rebuildIndexMap:function() {
  var me = this, indexMap = me.indexMap = {}, keys = me.keys, len = keys.length, i;
  for (i = 0; i < len; i++) {
    indexMap[keys[i]] = i;
  }
  me.indexGeneration = me.generation;
}, get:function(key) {
  var me = this, mk = me.map[key], item = mk !== undefined ? mk : typeof key == 'number' ? me.items[key] : undefined;
  return typeof item != 'function' || me.allowFunctions ? item : null;
}, getAt:function(index) {
  return this.items[index];
}, getByKey:function(key) {
  return this.map[key];
}, contains:function(o) {
  var me = this, key;
  if (o != null) {
    if (!me.useLinearSearch && (key = me.getKey(o))) {
      return this.map[key] != null;
    }
    return Ext.Array.indexOf(this.items, o) !== -1;
  }
  return false;
}, containsKey:function(key) {
  return this.map.hasOwnProperty(key);
}, clear:function() {
  var me = this;
  if (me.generation) {
    me.length = 0;
    me.items = [];
    me.keys = [];
    me.map = {};
    me.indexMap = {};
    me.generation++;
    me.indexGeneration = me.generation;
  }
  if (me.hasListeners.clear) {
    me.fireEvent('clear');
  }
}, first:function() {
  return this.items[0];
}, last:function() {
  return this.items[this.length - 1];
}, sum:function(property, root, start, end) {
  var values = this.extractValues(property, root), length = values.length, sum = 0, i;
  start = start || 0;
  end = end || end === 0 ? end : length - 1;
  for (i = start; i <= end; i++) {
    sum += values[i];
  }
  return sum;
}, collect:function(property, root, allowNull) {
  var values = this.extractValues(property, root), length = values.length, hits = {}, unique = [], value, strValue, i;
  for (i = 0; i < length; i++) {
    value = values[i];
    strValue = String(value);
    if ((allowNull || !Ext.isEmpty(value)) && !hits[strValue]) {
      hits[strValue] = true;
      unique.push(value);
    }
  }
  return unique;
}, extractValues:function(property, root) {
  var values = this.items;
  if (root) {
    values = Ext.Array.pluck(values, root);
  }
  return Ext.Array.pluck(values, property);
}, hasRange:function(start, end) {
  return end < this.length;
}, getRange:function(start, end) {
  var me = this, items = me.items, range = [], len = items.length, tmp, reverse;
  if (len < 1) {
    return range;
  }
  if (start > end) {
    reverse = true;
    tmp = start;
    start = end;
    end = tmp;
  }
  if (start < 0) {
    start = 0;
  }
  if (end == null || end >= len) {
    end = len - 1;
  }
  range = items.slice(start, end + 1);
  if (reverse && range.length) {
    range.reverse();
  }
  return range;
}, filter:function(property, value, anyMatch, caseSensitive) {
  var filters = [];
  if (Ext.isString(property)) {
    filters.push(new Ext.util.Filter({property:property, value:value, anyMatch:anyMatch, caseSensitive:caseSensitive}));
  } else {
    if (Ext.isArray(property) || property instanceof Ext.util.Filter) {
      filters = filters.concat(property);
    }
  }
  return this.filterBy(Ext.util.Filter.createFilterFn(filters));
}, filterBy:function(fn, scope) {
  var me = this, newMC = new me.self(me.initialConfig), keys = me.keys, items = me.items, length = items.length, i;
  newMC.getKey = me.getKey;
  for (i = 0; i < length; i++) {
    if (fn.call(scope || me, items[i], keys[i])) {
      newMC.add(keys[i], items[i]);
    }
  }
  newMC.useLinearSearch = me.useLinearSearch;
  return newMC;
}, findIndex:function(property, value, start, anyMatch, caseSensitive) {
  if (Ext.isEmpty(value, false)) {
    return -1;
  }
  value = this.createValueMatcher(value, anyMatch, caseSensitive);
  return this.findIndexBy(function(o) {
    return o && value.test(o[property]);
  }, null, start);
}, findIndexBy:function(fn, scope, start) {
  var me = this, keys = me.keys, items = me.items, i = start || 0, len = items.length;
  for (; i < len; i++) {
    if (fn.call(scope || me, items[i], keys[i])) {
      return i;
    }
  }
  return -1;
}, createValueMatcher:function(value, anyMatch, caseSensitive, exactMatch) {
  if (!value.exec) {
    var er = Ext.String.escapeRegex;
    value = String(value);
    if (anyMatch === true) {
      value = er(value);
    } else {
      value = '^' + er(value);
      if (exactMatch === true) {
        value += '$';
      }
    }
    value = new RegExp(value, caseSensitive ? '' : 'i');
  }
  return value;
}, clone:function() {
  var me = this, copy = new me.self(me.initialConfig);
  copy.add(me.keys, me.items);
  copy.useLinearSearch = me.useLinearSearch;
  return copy;
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.util, 'AbstractMixedCollection'], 0);
Ext.cmd.derive('Ext.util.Sorter', Ext.Base, {isSorter:true, config:{property:null, sorterFn:null, root:null, transform:null, direction:'ASC', id:undefined}, statics:{createComparator:function(sorters, nextFn) {
  nextFn = nextFn || 0;
  return function(lhs, rhs) {
    var items = sorters.isCollection ? sorters.items : sorters, n = items.length, comp, i;
    for (i = 0; i < n; ++i) {
      comp = items[i].sort(lhs, rhs);
      if (comp) {
        return comp;
      }
    }
    return nextFn && nextFn(lhs, rhs);
  };
}}, multiplier:1, constructor:function(config) {
  this.initConfig(config);
}, getId:function() {
  var id = this._id;
  if (!id) {
    id = this.getProperty();
    if (!id) {
      id = Ext.id(null, 'ext-sorter-');
    }
    this._id = id;
  }
  return id;
}, sort:function(lhs, rhs) {
  return this.multiplier * this.sortFn(lhs, rhs);
}, sortFn:function(item1, item2) {
  var me = this, transform = me._transform, root = me._root, property = me._property, lhs, rhs;
  if (root) {
    item1 = item1[root];
    item2 = item2[root];
  }
  lhs = item1[property];
  rhs = item2[property];
  if (transform) {
    lhs = transform(lhs);
    rhs = transform(rhs);
  }
  return lhs > rhs ? 1 : lhs < rhs ? -1 : 0;
}, applyDirection:function(direction) {
  return direction ? direction : 'ASC';
}, updateDirection:function(direction) {
  this.multiplier = direction.toUpperCase() === 'DESC' ? -1 : 1;
}, updateProperty:function(property) {
  if (property) {
    delete this.sortFn;
  }
}, updateSorterFn:function(sorterFn) {
  this.sortFn = sorterFn;
}, toggle:function() {
  this.setDirection(Ext.String.toggle(this.getDirection(), 'ASC', 'DESC'));
}, getState:function() {
  var me = this, result = {root:me.getRoot(), property:me.getProperty(), direction:me.getDirection()};
  if (me._id) {
    result.id = me._id;
  }
  return result;
}, serialize:function() {
  return {property:this.getProperty(), direction:this.getDirection()};
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Sorter'], 0);
Ext.cmd.derive('Ext.util.Sortable', Ext.Base, {isSortable:true, $configPrefixed:false, $configStrict:false, config:{sorters:null}, defaultSortDirection:'ASC', multiSortLimit:3, statics:{createComparator:function(sorters) {
  return sorters && sorters.length ? function(r1, r2) {
    var result = sorters[0].sort(r1, r2), length = sorters.length, i = 1;
    for (; !result && i < length; i++) {
      result = sorters[i].sort.call(sorters[i], r1, r2);
    }
    return result;
  } : function() {
    return 0;
  };
}}, applySorters:function(sorters) {
  var me = this, sortersCollection = me.getSorters() || new Ext.util.MixedCollection(false, Ext.returnId);
  if (sorters) {
    sortersCollection.addAll(me.decodeSorters(sorters));
  }
  return sortersCollection;
}, sort:function(sorters, direction, insertionPosition, doSort) {
  var me = this, sorter, overFlow, currentSorters = me.getSorters();
  if (!currentSorters) {
    me.setSorters(null);
    currentSorters = me.getSorters();
  }
  if (Ext.isArray(sorters)) {
    doSort = insertionPosition;
    insertionPosition = direction;
  } else {
    if (Ext.isObject(sorters)) {
      sorters = [sorters];
      doSort = insertionPosition;
      insertionPosition = direction;
    } else {
      if (Ext.isString(sorters)) {
        sorter = currentSorters.get(sorters);
        if (!sorter) {
          sorter = {property:sorters, direction:direction};
        } else {
          if (direction == null) {
            sorter.toggle();
          } else {
            sorter.setDirection(direction);
          }
        }
        sorters = [sorter];
      }
    }
  }
  if (sorters && sorters.length) {
    sorters = me.decodeSorters(sorters);
    switch(insertionPosition) {
      case 'multi':
        currentSorters.insert(0, sorters[0]);
        overFlow = currentSorters.getCount() - me.multiSortLimit;
        if (overFlow > 0) {
          currentSorters.removeRange(me.multiSortLimit, overFlow);
        }
        break;
      case 'prepend':
        currentSorters.insert(0, sorters);
        break;
      case 'append':
        currentSorters.addAll(sorters);
        break;
      case undefined:
      case null:
      case 'replace':
        currentSorters.clear();
        currentSorters.addAll(sorters);
        break;
      default:
    }
  }
  if (doSort !== false) {
    me.fireEvent('beforesort', me, sorters);
    me.onBeforeSort(sorters);
    if (me.getSorterCount()) {
      me.doSort(me.generateComparator());
    }
  }
  return sorters;
}, getSorterCount:function() {
  return this.getSorters().items.length;
}, generateComparator:function() {
  var sorters = this.getSorters().getRange();
  return sorters.length ? this.createComparator(sorters) : this.emptyComparator;
}, emptyComparator:function() {
  return 0;
}, onBeforeSort:Ext.emptyFn, decodeSorters:function(sorters) {
  if (!Ext.isArray(sorters)) {
    if (sorters === undefined) {
      sorters = [];
    } else {
      sorters = [sorters];
    }
  }
  var length = sorters.length, Sorter = Ext.util.Sorter, model = this.getModel ? this.getModel() : this.model, field, config, i;
  for (i = 0; i < length; i++) {
    config = sorters[i];
    if (!(config instanceof Sorter)) {
      if (Ext.isString(config)) {
        config = {property:config};
      }
      Ext.applyIf(config, {root:this.sortRoot, direction:'ASC'});
      if (config.fn) {
        config.sorterFn = config.fn;
      }
      if (typeof config == 'function') {
        config = {sorterFn:config};
      }
      if (model && !config.transform) {
        field = model.getField(config.property);
        config.transform = field && field.sortType !== Ext.identityFn ? field.sortType : undefined;
      }
      sorters[i] = new Ext.util.Sorter(config);
    }
  }
  return sorters;
}, getFirstSorter:function() {
  var sorters = this.getSorters().items, len = sorters.length, i = 0, sorter;
  for (; i < len; ++i) {
    sorter = sorters[i];
    if (!sorter.isGrouper) {
      return sorter;
    }
  }
  return null;
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Sortable'], function() {
  this.prototype.createComparator = this.createComparator;
});
Ext.cmd.derive('Ext.util.MixedCollection', Ext.util.AbstractMixedCollection, {constructor:function() {
  this.initConfig();
  Ext.util.AbstractMixedCollection.prototype.constructor.apply(this, arguments);
}, doSort:function(sorterFn) {
  this.sortBy(sorterFn);
}, _sort:function(property, dir, fn) {
  var me = this, i, len, dsc = String(dir).toUpperCase() == 'DESC' ? -1 : 1, c = [], keys = me.keys, items = me.items, o;
  fn = fn || function(a, b) {
    return a - b;
  };
  for (i = 0, len = items.length; i < len; i++) {
    c[c.length] = {key:keys[i], value:items[i], index:i};
  }
  Ext.Array.sort(c, function(a, b) {
    return fn(a[property], b[property]) * dsc || (a.index < b.index ? -1 : 1);
  });
  for (i = 0, len = c.length; i < len; i++) {
    o = c[i];
    items[i] = o.value;
    keys[i] = o.key;
    me.indexMap[o.key] = i;
  }
  me.generation++;
  me.indexGeneration = me.generation;
  me.fireEvent('sort', me);
}, sortBy:function(sorterFn) {
  var me = this, items = me.items, item, keys = me.keys, key, length = items.length, i;
  for (i = 0; i < length; i++) {
    items[i].$extCollectionIndex = i;
  }
  Ext.Array.sort(items, function(a, b) {
    return sorterFn(a, b) || (a.$extCollectionIndex < b.$extCollectionIndex ? -1 : 1);
  });
  for (i = 0; i < length; i++) {
    item = items[i];
    key = me.getKey(item);
    keys[i] = key;
    me.indexMap[key] = i;
    delete item.$extCollectionIndex;
  }
  me.generation++;
  me.indexGeneration = me.generation;
  me.fireEvent('sort', me, items, keys);
}, findInsertionIndex:function(newItem, sorterFn) {
  var me = this, items = me.items, start = 0, end = items.length - 1, middle, comparison;
  if (!sorterFn) {
    sorterFn = me.generateComparator();
  }
  while (start <= end) {
    middle = start + end >> 1;
    comparison = sorterFn(newItem, items[middle]);
    if (comparison >= 0) {
      start = middle + 1;
    } else {
      if (comparison < 0) {
        end = middle - 1;
      }
    }
  }
  return start;
}, reorder:function(mapping) {
  Ext.util.AbstractMixedCollection.prototype.reorder.call(this, mapping);
  this.fireEvent('sort', this);
}, sortByKey:function(dir, fn) {
  this._sort('key', dir, fn || function(a, b) {
    var v1 = String(a).toUpperCase(), v2 = String(b).toUpperCase();
    return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
  });
}}, 1, 0, 0, 0, 0, [['sortable', Ext.util.Sortable]], [Ext.util, 'MixedCollection'], 0);
Ext.cmd.derive('Ext.util.TaskRunner', Ext.Base, {fireIdleEvent:null, interval:10, timerId:null, constructor:function(interval) {
  var me = this;
  if (typeof interval === 'number') {
    me.interval = interval;
  } else {
    if (interval) {
      Ext.apply(me, interval);
    }
  }
  me.tasks = [];
  me.timerFn = me.onTick.bind(me);
}, newTask:function(config) {
  var task = new Ext.util.TaskRunner.Task(config);
  task.manager = this;
  return task;
}, start:function(task) {
  var me = this, now = Ext.Date.now();
  if (!task.pending) {
    me.tasks.push(task);
    task.pending = true;
  }
  task.stopped = false;
  task.taskStartTime = now;
  task.taskRunTime = task.fireOnStart !== false ? 0 : task.taskStartTime;
  task.taskRunCount = 0;
  if (!me.firing) {
    if (task.fireOnStart !== false) {
      me.startTimer(0, now);
    } else {
      me.startTimer(task.interval, now);
    }
  }
  return task;
}, stop:function(task, andRemove) {
  var me = this, tasks = me.tasks, pendingCount = 0, i;
  if (!task.stopped) {
    task.stopped = true;
    task.pending = false;
    if (task.onStop) {
      task.onStop.call(task.scope || task, task);
    }
  }
  if (andRemove) {
    Ext.Array.remove(tasks, task);
  }
  for (i = 0; !pendingCount && i < tasks.length; i++) {
    if (!tasks[i].stopped) {
      pendingCount++;
    }
  }
  if (!pendingCount) {
    Ext.undefer(me.timerId);
    me.timerId = null;
  }
  return task;
}, stopAll:function(andRemove) {
  var me = this;
  Ext.each(this.tasks, function(task) {
    me.stop(task, andRemove);
  }, null, true);
}, firing:false, nextExpires:1.0E99, onTick:function() {
  var me = this, tasks = me.tasks, fireIdleEvent = me.fireIdleEvent, now = Ext.Date.now(), nextExpires = 1.0E99, len = tasks.length, expires, newTasks, i, task, rt, remove, args;
  me.timerId = null;
  me.firing = true;
  for (i = 0; i < len || i < (len = tasks.length); ++i) {
    task = tasks[i];
    if (!(remove = task.stopped)) {
      expires = task.taskRunTime + task.interval;
      if (expires <= now) {
        rt = 1;
        if (fireIdleEvent === null && task.fireIdleEvent !== false) {
          fireIdleEvent = true;
        }
        task.taskRunCount++;
        if (task.args) {
          args = task.addCountToArgs ? task.args.concat([task.taskRunCount]) : task.args;
        } else {
          args = [task.taskRunCount];
        }
        try {
          rt = task.run.apply(task.scope || task, args);
        } catch (taskError) {
          try {
            if (task.onError) {
              rt = task.onError.call(task.scope || task, task, taskError);
            }
          } catch (ignore) {
          }
        }
        task.taskRunTime = now;
        if (rt === false || task.taskRunCount === task.repeat) {
          me.stop(task);
          remove = true;
        } else {
          remove = task.stopped;
          expires = now + task.interval;
        }
      }
      if (!remove && task.duration && task.duration <= now - task.taskStartTime) {
        me.stop(task);
        remove = true;
      }
    }
    if (remove) {
      task.pending = false;
      if (!newTasks) {
        newTasks = tasks.slice(0, i);
      }
    } else {
      if (newTasks) {
        newTasks.push(task);
      }
      if (nextExpires > expires) {
        nextExpires = expires;
      }
    }
  }
  if (newTasks) {
    me.tasks = newTasks;
  }
  me.firing = false;
  if (me.tasks.length) {
    me.startTimer(nextExpires - now, Ext.Date.now());
  }
  if (fireIdleEvent === null) {
    fireIdleEvent = false;
  }
  Ext._suppressIdle = !fireIdleEvent;
}, startTimer:function(timeout, now) {
  var me = this, expires = now + timeout, timerId = me.timerId;
  if (timerId && me.nextExpires - expires > me.interval) {
    timerId = Ext.undefer(timerId);
  }
  if (!timerId) {
    if (timeout < me.interval) {
      timeout = me.interval;
    }
    me.timerId = Ext.defer(me.timerFn, timeout);
    me.nextExpires = expires;
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'TaskRunner'], function() {
  var me = this, proto = me.prototype;
  proto.destroy = proto.stopAll;
  me.Task = new Ext.Class({isTask:true, stopped:true, fireOnStart:false, constructor:function(config) {
    Ext.apply(this, config);
  }, restart:function(interval) {
    if (interval !== undefined) {
      this.interval = interval;
    }
    this.manager.start(this);
  }, start:function(interval) {
    if (this.stopped) {
      this.restart(interval);
    }
  }, stop:function(andRemove) {
    this.manager.stop(this, andRemove);
  }, destroy:function() {
    this.stop(true);
  }});
  proto = me.Task.prototype;
  proto.destroy = proto.stop;
});
Ext.cmd.derive('Ext.fx.target.Target', Ext.Base, {isAnimTarget:true, constructor:function(target) {
  this.target = target;
  this.id = this.getId();
}, getId:function() {
  return this.target.id;
}, remove:function() {
  Ext.destroy(this.target);
}}, 1, 0, 0, 0, 0, 0, [Ext.fx.target, 'Target'], 0);
Ext.cmd.derive('Ext.fx.target.Element', Ext.fx.target.Target, {type:'element', constructor:function(target) {
  Ext.fx.target.Target.prototype.constructor.call(this, target);
  this.isAbsoluteOnPage = this.target.dom.parentNode === document.body && this.target.isStyle('position', 'absolute');
}, getElVal:function(el, attr, val) {
  if (val === undefined) {
    if (attr === 'x') {
      val = el.getX();
    } else {
      if (attr === 'y') {
        val = el.getY();
      } else {
        if (attr === 'scrollTop') {
          val = el.getScroll().top;
        } else {
          if (attr === 'scrollLeft') {
            val = el.getScroll().left;
          } else {
            if (attr === 'height') {
              val = el.getHeight();
            } else {
              if (attr === 'width') {
                val = el.getWidth();
              } else {
                val = el.getStyle(attr);
              }
            }
          }
        }
      }
    }
  }
  return val;
}, getAttr:function(attr, val) {
  var el = this.target;
  return [[el, this.getElVal(el, attr, val)]];
}, setAttr:function(targetData) {
  var ln = targetData.length, attrs, attr, o, i, j, ln2;
  for (i = 0; i < ln; i++) {
    attrs = targetData[i].attrs;
    for (attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        ln2 = attrs[attr].length;
        for (j = 0; j < ln2; j++) {
          o = attrs[attr][j];
          this.setElVal(o[0], attr, o[1]);
        }
      }
    }
  }
}, setElVal:function(element, attr, value) {
  if (attr === 'x') {
    if (this.isAbsoluteOnPage) {
      element.setLocalX(value);
    } else {
      element.setXY([value, null]);
    }
  } else {
    if (attr === 'y') {
      if (this.isAbsoluteOnPage) {
        element.setLocalY(value);
      } else {
        element.setXY([null, value]);
      }
    } else {
      if (attr === 'scrollTop') {
        element.scrollTo('top', value);
      } else {
        if (attr === 'scrollLeft') {
          element.scrollTo('left', value);
        } else {
          if (attr === 'width') {
            element.setWidth(value);
          } else {
            if (attr === 'height') {
              element.setHeight(value);
            } else {
              element.setStyle(attr, value);
            }
          }
        }
      }
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.fx.target, 'Element'], 0);
Ext.cmd.derive('Ext.fx.target.ElementCSS', Ext.fx.target.Element, {setAttr:function(targetData, isFirstFrame) {
  var cssArr = {attrs:[], duration:[], easing:[]}, ln = targetData.length, cleanerFn = function() {
    this.setStyle(Ext.supports.CSS3Prefix + 'TransitionProperty', null);
    this.setStyle(Ext.supports.CSS3Prefix + 'TransitionDuration', null);
    this.setStyle(Ext.supports.CSS3Prefix + 'TransitionTimingFunction', null);
  }, single = {single:true}, attributes, attrs, attr, easing, duration, o, i, j, ln2;
  for (i = 0; i < ln; i++) {
    attrs = targetData[i];
    duration = attrs.duration;
    easing = attrs.easing;
    attrs = attrs.attrs;
    for (attr in attrs) {
      if (Ext.Array.indexOf(cssArr.attrs, attr) == -1) {
        cssArr.attrs.push(attr.replace(/[A-Z]/g, function(v) {
          return '-' + v.toLowerCase();
        }));
        cssArr.duration.push(duration + 'ms');
        cssArr.easing.push(easing);
      }
    }
  }
  attributes = cssArr.attrs.join(',');
  duration = cssArr.duration.join(',');
  easing = cssArr.easing.join(', ');
  for (i = 0; i < ln; i++) {
    attrs = targetData[i].attrs;
    for (attr in attrs) {
      ln2 = attrs[attr].length;
      for (j = 0; j < ln2; j++) {
        o = attrs[attr][j];
        o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionProperty', isFirstFrame ? '' : attributes);
        o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionDuration', isFirstFrame ? '' : duration);
        o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionTimingFunction', isFirstFrame ? '' : easing);
        o[0].setStyle(attr, o[1]);
        if (isFirstFrame) {
          o = o[0].dom.offsetWidth;
        } else {
          o[0].on(Ext.supports.CSS3TransitionEnd, cleanerFn, o[0], single);
        }
      }
    }
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.target, 'ElementCSS'], 0);
Ext.cmd.derive('Ext.fx.target.CompositeElement', Ext.fx.target.Element, {isComposite:true, constructor:function(target) {
  target.id = target.id || Ext.id(null, 'ext-composite-');
  Ext.fx.target.Element.prototype.constructor.call(this, target);
}, getAttr:function(attr, val) {
  var out = [], target = this.target, elements = target.elements, length = elements.length, i, el;
  for (i = 0; i < length; i++) {
    el = elements[i];
    if (el) {
      el = target.getElement(el);
      out.push([el, this.getElVal(el, attr, val)]);
    }
  }
  return out;
}, setAttr:function(targetData) {
  var target = this.target, ln = targetData.length, elements = target.elements, ln3 = elements.length, value, k, attrs, attr, el, i, j, ln2;
  for (i = 0; i < ln; i++) {
    attrs = targetData[i].attrs;
    for (attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        ln2 = attrs[attr].length;
        for (j = 0; j < ln2; j++) {
          value = attrs[attr][j][1];
          for (k = 0; k < ln3; ++k) {
            el = elements[k];
            if (el) {
              el = target.getElement(el);
              this.setElVal(el, attr, value);
            }
          }
        }
      }
    }
  }
}, remove:function() {
  this.target.destroy();
}}, 1, 0, 0, 0, 0, 0, [Ext.fx.target, 'CompositeElement'], 0);
Ext.cmd.derive('Ext.fx.target.CompositeElementCSS', Ext.fx.target.CompositeElement, {setAttr:function() {
  return Ext.fx.target.ElementCSS.prototype.setAttr.apply(this, arguments);
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.target, 'CompositeElementCSS'], 0);
Ext.cmd.derive('Ext.fx.target.Sprite', Ext.fx.target.Target, {type:'draw', getFromPrim:function(sprite, attr) {
  var obj;
  switch(attr) {
    case 'rotate':
    case 'rotation':
      obj = sprite.attr.rotation;
      return {x:obj.x || 0, y:obj.y || 0, degrees:obj.degrees || 0};
    case 'scale':
    case 'scaling':
      obj = sprite.attr.scaling;
      return {x:obj.x || 1, y:obj.y || 1, cx:obj.cx || 0, cy:obj.cy || 0};
    case 'translate':
    case 'translation':
      obj = sprite.attr.translation;
      return {x:obj.x || 0, y:obj.y || 0};
    default:
      return sprite.attr[attr];
  }
}, getAttr:function(attr, val) {
  return [[this.target, val !== undefined ? val : this.getFromPrim(this.target, attr)]];
}, setAttr:function(targetData) {
  var ln = targetData.length, spriteArr = [], attrsConf, attr, attrArr, attrs, sprite, idx, value, i, j, x, y, ln2;
  for (i = 0; i < ln; i++) {
    attrsConf = targetData[i].attrs;
    for (attr in attrsConf) {
      attrArr = attrsConf[attr];
      ln2 = attrArr.length;
      for (j = 0; j < ln2; j++) {
        sprite = attrArr[j][0];
        attrs = attrArr[j][1];
        if (attr === 'translate' || attr === 'translation') {
          value = {x:attrs.x, y:attrs.y};
        } else {
          if (attr === 'rotate' || attr === 'rotation') {
            x = attrs.x;
            if (isNaN(x)) {
              x = null;
            }
            y = attrs.y;
            if (isNaN(y)) {
              y = null;
            }
            value = {degrees:attrs.degrees, x:x, y:y};
          } else {
            if (attr === 'scale' || attr === 'scaling') {
              x = attrs.x;
              if (isNaN(x)) {
                x = null;
              }
              y = attrs.y;
              if (isNaN(y)) {
                y = null;
              }
              value = {x:x, y:y, cx:attrs.cx, cy:attrs.cy};
            } else {
              if (attr === 'width' || attr === 'height' || attr === 'x' || attr === 'y') {
                value = parseFloat(attrs);
              } else {
                value = attrs;
              }
            }
          }
        }
        idx = Ext.Array.indexOf(spriteArr, sprite);
        if (idx === -1) {
          spriteArr.push([sprite, {}]);
          idx = spriteArr.length - 1;
        }
        spriteArr[idx][1][attr] = value;
      }
    }
  }
  ln = spriteArr.length;
  for (i = 0; i < ln; i++) {
    spriteArr[i][0].setAttributes(spriteArr[i][1]);
  }
  this.target.redraw();
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.target, 'Sprite'], 0);
Ext.cmd.derive('Ext.fx.target.CompositeSprite', Ext.fx.target.Sprite, {getAttr:function(attr, val) {
  var out = [], sprites = [].concat(this.target.items), length = sprites.length, i, sprite;
  for (i = 0; i < length; i++) {
    sprite = sprites[i];
    out.push([sprite, val !== undefined ? val : this.getFromPrim(sprite, attr)]);
  }
  return out;
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.target, 'CompositeSprite'], 0);
Ext.cmd.derive('Ext.fx.target.Component', Ext.fx.target.Target, {type:'component', getPropMethod:{top:function() {
  return this.getPosition(true)[1];
}, left:function() {
  return this.getPosition(true)[0];
}, x:function() {
  return this.getPosition()[0];
}, y:function() {
  return this.getPosition()[1];
}, height:function() {
  return this.getHeight();
}, width:function() {
  return this.getWidth();
}, opacity:function() {
  return this.el.getStyle('opacity');
}}, setMethods:{top:'setPosition', left:'setPosition', x:'setPagePosition', y:'setPagePosition', height:'setSize', width:'setSize', opacity:'setOpacity'}, getAttr:function(attr, val) {
  return [[this.target, val !== undefined ? val : this.getPropMethod[attr].call(this.target)]];
}, setAttr:function(targetData, isFirstFrame, isLastFrame) {
  var me = this, ln = targetData.length, attrs, attr, o, i, j, targets, left, top, w, h, methodsToCall = {}, methodProps;
  for (i = 0; i < ln; i++) {
    attrs = targetData[i].attrs;
    for (attr in attrs) {
      targets = attrs[attr].length;
      for (j = 0; j < targets; j++) {
        o = attrs[attr][j];
        methodProps = methodsToCall[me.setMethods[attr]] || (methodsToCall[me.setMethods[attr]] = {});
        methodProps.target = o[0];
        methodProps[attr] = o[1];
      }
    }
    if (methodsToCall.setPosition) {
      o = methodsToCall.setPosition;
      left = o.left === undefined ? undefined : parseFloat(o.left);
      top = o.top === undefined ? undefined : parseFloat(o.top);
      o.target.setPosition(left, top);
    }
    if (methodsToCall.setPagePosition) {
      o = methodsToCall.setPagePosition;
      o.target.setPagePosition(o.x, o.y);
    }
    if (methodsToCall.setSize) {
      o = methodsToCall.setSize;
      w = o.width === undefined ? o.target.getWidth() : parseFloat(o.width);
      h = o.height === undefined ? o.target.getHeight() : parseFloat(o.height);
      o.target.el.setSize(w, h);
      if (isLastFrame || me.dynamic) {
        Ext.GlobalEvents.on({idle:Ext.Function.bind(o.target.setSize, o.target, [w, h]), single:true});
      }
    }
    if (methodsToCall.setOpacity) {
      o = methodsToCall.setOpacity;
      o.target.el.setStyle('opacity', o.opacity);
    }
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.target, 'Component'], 0);
Ext.cmd.derive('Ext.fx.Queue', Ext.Base, {constructor:function() {
  this.targets = new Ext.util.HashMap;
  this.fxQueue = {};
}, getFxDefaults:function(targetId) {
  var target = this.targets.get(targetId);
  if (target) {
    return target.fxDefaults;
  }
  return {};
}, setFxDefaults:function(targetId, obj) {
  var target = this.targets.get(targetId);
  if (target) {
    target.fxDefaults = Ext.apply(target.fxDefaults || {}, obj);
  }
}, stopAnimation:function(targetId, suppressEvent) {
  var me = this, queue = me.getFxQueue(targetId), ln = queue.length, item;
  while (ln) {
    item = queue[ln - 1];
    if (item) {
      item.end(suppressEvent);
    }
    ln--;
  }
}, getActiveAnimation:function(targetId) {
  var queue = this.getFxQueue(targetId);
  return queue && !!queue.length ? queue[0] : false;
}, hasFxBlock:function(targetId) {
  var queue = this.getFxQueue(targetId);
  return queue && queue[0] && queue[0].block;
}, getFxQueue:function(targetId) {
  if (!targetId) {
    return false;
  }
  var me = this, fxQueue = me.fxQueue, queue = fxQueue[targetId], target = me.targets.get(targetId);
  if (!target) {
    return false;
  }
  if (!queue) {
    me.fxQueue[targetId] = fxQueue[targetId] = [];
    if (target.type !== 'element') {
      target.target.on('destroy', function() {
        fxQueue[targetId] = null;
        delete fxQueue[targetId];
      });
    }
  }
  return me.fxQueue[targetId];
}, clearFxQueue:function() {
  Ext.Object.clear(this.fxQueue);
}, queueFx:function(anim) {
  var me = this, target = anim.target, targetId = target.getId(), queue, ln;
  if (!target) {
    return;
  }
  queue = me.getFxQueue(targetId);
  ln = queue.length;
  if (ln) {
    if (anim.concurrent) {
      anim.paused = false;
    } else {
      queue[ln - 1].on('afteranimate', function() {
        anim.paused = false;
      });
    }
  } else {
    anim.paused = false;
  }
  anim.on('afteranimate', function() {
    Ext.Array.remove(queue, anim);
    if (queue.length === 0) {
      me.targets.remove(anim.target);
      me.fxQueue[targetId] = null;
      delete me.fxQueue[targetId];
    }
    if (anim.remove) {
      if (target.type === 'element') {
        var el = Ext.get(targetId);
        if (el) {
          el.destroy();
        }
      }
    }
  }, me, {single:true});
  queue.push(anim);
}}, 1, 0, 0, 0, 0, 0, [Ext.fx, 'Queue'], 0);
Ext.cmd.derive('Ext.fx.Manager', Ext.Base, {singleton:true, constructor:function() {
  var me = this;
  me.items = new Ext.util.MixedCollection;
  me.targetArr = {};
  me.mixins.queue.constructor.call(me);
  me.taskRunner = new Ext.util.TaskRunner;
}, interval:16, forceJS:true, createTarget:function(target) {
  var me = this, useCSS3 = !me.forceJS && Ext.supports.Transitions, targetObj;
  me.useCSS3 = useCSS3;
  if (target) {
    if (target.tagName || Ext.isString(target) || target.isFly) {
      target = Ext.get(target);
      targetObj = new Ext.fx.target['Element' + (useCSS3 ? 'CSS' : '')](target);
    } else {
      if (target.dom) {
        targetObj = new Ext.fx.target['Element' + (useCSS3 ? 'CSS' : '')](target);
      } else {
        if (target.isComposite) {
          targetObj = new Ext.fx.target['CompositeElement' + (useCSS3 ? 'CSS' : '')](target);
        } else {
          if (target.isSprite) {
            targetObj = new Ext.fx.target.Sprite(target);
          } else {
            if (target.isCompositeSprite) {
              targetObj = new Ext.fx.target.CompositeSprite(target);
            } else {
              if (target.isComponent) {
                targetObj = new Ext.fx.target.Component(target);
              } else {
                if (target.isAnimTarget) {
                  return target;
                } else {
                  return null;
                }
              }
            }
          }
        }
      }
    }
    me.targets.add(targetObj);
    return targetObj;
  } else {
    return null;
  }
}, addAnim:function(anim) {
  var me = this, items = me.items, task = me.task;
  items.add(anim.id, anim);
  if (!task && items.length) {
    task = me.task = {run:me.runner, interval:me.interval, scope:me};
    me.taskRunner.start(task);
  }
}, removeAnim:function(anim) {
  var me = this, items = me.items, task = me.task;
  items.removeAtKey(anim.id);
  if (task && !items.length) {
    me.taskRunner.stop(task);
    delete me.task;
  }
}, runner:function() {
  var me = this, items = me.items.getRange(), i = 0, len = items.length, anim;
  me.targetArr = {};
  me.timestamp = new Date;
  for (; i < len; i++) {
    anim = items[i];
    if (anim.isReady()) {
      me.startAnim(anim);
    }
  }
  for (i = 0; i < len; i++) {
    anim = items[i];
    if (anim.isRunning()) {
      me.runAnim(anim);
    }
  }
  me.applyPendingAttrs();
  me.targetArr = null;
}, startAnim:function(anim) {
  anim.start(this.timestamp);
}, runAnim:function(anim, forceEnd) {
  if (!anim) {
    return;
  }
  var me = this, useCSS3 = me.useCSS3 && anim.target.type === 'element', elapsedTime = me.timestamp - anim.startTime, lastFrame = elapsedTime >= anim.duration, target, o;
  if (forceEnd) {
    elapsedTime = anim.duration;
    lastFrame = true;
  }
  target = me.collectTargetData(anim, elapsedTime, useCSS3, lastFrame);
  if (useCSS3) {
    anim.target.setAttr(target.anims[anim.id].attributes, true);
    me.collectTargetData(anim, anim.duration, useCSS3, lastFrame);
    anim.paused = true;
    target = anim.target.target;
    if (anim.target.isComposite) {
      target = anim.target.target.last();
    }
    o = {};
    o[Ext.supports.CSS3TransitionEnd] = anim.lastFrame;
    o.scope = anim;
    o.single = true;
    target.on(o);
  }
  return target;
}, jumpToEnd:function(anim) {
  var me = this, target, clear;
  if (!me.targetArr) {
    me.targetArr = {};
    clear = true;
  }
  target = me.runAnim(anim, true);
  me.applyAnimAttrs(target, target.anims[anim.id]);
  if (clear) {
    me.targetArr = null;
  }
}, collectTargetData:function(anim, elapsedTime, useCSS3, isLastFrame) {
  var targetId = anim.target.getId(), target = this.targetArr[targetId];
  if (!target) {
    target = this.targetArr[targetId] = {id:targetId, el:anim.target, anims:{}};
  }
  target.anims[anim.id] = {id:anim.id, anim:anim, elapsed:elapsedTime, isLastFrame:isLastFrame, attributes:[{duration:anim.duration, easing:useCSS3 && anim.reverse ? anim.easingFn.reverse().toCSS3() : anim.easing, attrs:anim.runAnim(elapsedTime)}]};
  return target;
}, applyAnimAttrs:function(target, animWrap) {
  var anim = animWrap.anim;
  if (animWrap.attributes && anim.isRunning()) {
    target.el.setAttr(animWrap.attributes, false, animWrap.isLastFrame);
    if (animWrap.isLastFrame) {
      anim.lastFrame();
    }
  }
}, applyPendingAttrs:function() {
  var targetArr = this.targetArr, target, targetId, animWrap, anim, animId;
  for (targetId in targetArr) {
    if (targetArr.hasOwnProperty(targetId)) {
      target = targetArr[targetId];
      for (animId in target.anims) {
        if (target.anims.hasOwnProperty(animId)) {
          animWrap = target.anims[animId];
          anim = animWrap.anim;
          if (animWrap.attributes && anim.isRunning()) {
            target.el.setAttr(animWrap.attributes, false, animWrap.isLastFrame);
            if (animWrap.isLastFrame) {
              anim.lastFrame();
            }
          }
        }
      }
    }
  }
}, clear:function() {
  var me = this;
  if (me.taskRunner) {
    me.taskRunner.stopAll(true);
  }
  me.targetArr = {};
  me.items.clear();
  me.targets.clear();
  me.clearFxQueue();
}}, 1, 0, 0, 0, 0, [['queue', Ext.fx.Queue]], [Ext.fx, 'Manager'], 0);
Ext.cmd.derive('Ext.fx.Animator', Ext.Base, {isAnimator:true, duration:250, delay:0, delayStart:0, dynamic:false, easing:'ease', running:false, paused:false, damper:1, iterations:1, currentIteration:0, keyframeStep:0, animKeyFramesRE:/^(from|to|\d+%?)$/, constructor:function(config) {
  var me = this;
  config = Ext.apply(me, config || {});
  me.config = config;
  me.id = Ext.id(null, 'ext-animator-');
  me.mixins.observable.constructor.call(me, config);
  me.timeline = [];
  me.createTimeline(me.keyframes);
  if (me.target) {
    me.applyAnimator(me.target);
    Ext.fx.Manager.addAnim(me);
  }
}, sorter:function(a, b) {
  return a.pct - b.pct;
}, createTimeline:function(keyframes) {
  var me = this, attrs = [], to = me.to || {}, duration = me.duration, prevMs, ms, i, ln, pct, attr;
  for (pct in keyframes) {
    if (keyframes.hasOwnProperty(pct) && me.animKeyFramesRE.test(pct)) {
      attr = {attrs:Ext.apply(keyframes[pct], to)};
      if (pct === 'from') {
        pct = 0;
      } else {
        if (pct === 'to') {
          pct = 100;
        }
      }
      attr.pct = parseInt(pct, 10);
      attrs.push(attr);
    }
  }
  Ext.Array.sort(attrs, me.sorter);
  ln = attrs.length;
  for (i = 0; i < ln; i++) {
    prevMs = attrs[i - 1] ? duration * (attrs[i - 1].pct / 100) : 0;
    ms = duration * (attrs[i].pct / 100);
    me.timeline.push({duration:ms - prevMs, attrs:attrs[i].attrs});
  }
}, applyAnimator:function(target) {
  var me = this, anims = [], timeline = me.timeline, ln = timeline.length, anim, easing, damper, attrs, i;
  if (me.fireEvent('beforeanimate', me) !== false) {
    for (i = 0; i < ln; i++) {
      anim = timeline[i];
      attrs = anim.attrs;
      easing = attrs.easing || me.easing;
      damper = attrs.damper || me.damper;
      delete attrs.easing;
      delete attrs.damper;
      anim = new Ext.fx.Anim({target:target, easing:easing, damper:damper, duration:anim.duration, paused:true, to:attrs});
      anims.push(anim);
    }
    me.animations = anims;
    me.target = anim.target;
    for (i = 0; i < ln - 1; i++) {
      anim = anims[i];
      anim.nextAnim = anims[i + 1];
      anim.on('afteranimate', function() {
        this.nextAnim.paused = false;
      });
      anim.on('afteranimate', function() {
        this.fireEvent('keyframe', this, ++this.keyframeStep);
      }, me);
    }
    anims[ln - 1].on('afteranimate', function() {
      this.lastFrame();
    }, me);
  }
}, start:function(startTime) {
  var me = this, delay = me.delay, delayStart = me.delayStart, delayDelta;
  if (delay) {
    if (!delayStart) {
      me.delayStart = startTime;
      return;
    } else {
      delayDelta = startTime - delayStart;
      if (delayDelta < delay) {
        return;
      } else {
        startTime = new Date(delayStart.getTime() + delay);
      }
    }
  }
  if (me.fireEvent('beforeanimate', me) !== false) {
    me.startTime = startTime;
    me.running = true;
    me.animations[me.keyframeStep].paused = false;
  }
}, lastFrame:function() {
  var me = this, iter = me.iterations, iterCount = me.currentIteration;
  iterCount++;
  if (iterCount < iter) {
    me.startTime = new Date;
    me.currentIteration = iterCount;
    me.keyframeStep = 0;
    me.applyAnimator(me.target);
    me.animations[me.keyframeStep].paused = false;
  } else {
    me.currentIteration = 0;
    me.end();
  }
}, end:function() {
  var me = this;
  me.fireEvent('afteranimate', me, me.startTime, new Date - me.startTime);
}, isReady:function() {
  return this.paused === false && this.running === false && this.iterations > 0;
}, isRunning:function() {
  return false;
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.fx, 'Animator'], 0);
Ext.cmd.derive('Ext.fx.CubicBezier', Ext.Base, {singleton:true, cubicBezierAtTime:function(t, p1x, p1y, p2x, p2y, duration) {
  var cx = 3 * p1x, bx = 3 * (p2x - p1x) - cx, ax = 1 - cx - bx, cy = 3 * p1y, by = 3 * (p2y - p1y) - cy, ay = 1 - cy - by;
  function sampleCurveX(t) {
    return ((ax * t + bx) * t + cx) * t;
  }
  function solve(x, epsilon) {
    var t = solveCurveX(x, epsilon);
    return ((ay * t + by) * t + cy) * t;
  }
  function solveCurveX(x, epsilon) {
    var t0, t1, t2, x2, d2, i;
    for (t2 = x, i = 0; i < 8; i++) {
      x2 = sampleCurveX(t2) - x;
      if (Math.abs(x2) < epsilon) {
        return t2;
      }
      d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
      if (Math.abs(d2) < 1.0E-6) {
        break;
      }
      t2 = t2 - x2 / d2;
    }
    t0 = 0;
    t1 = 1;
    t2 = x;
    if (t2 < t0) {
      return t0;
    }
    if (t2 > t1) {
      return t1;
    }
    while (t0 < t1) {
      x2 = sampleCurveX(t2);
      if (Math.abs(x2 - x) < epsilon) {
        return t2;
      }
      if (x > x2) {
        t0 = t2;
      } else {
        t1 = t2;
      }
      t2 = (t1 - t0) / 2 + t0;
    }
    return t2;
  }
  return solve(t, 1 / (200 * duration));
}, cubicBezier:function(x1, y1, x2, y2) {
  var fn = function(pos) {
    return Ext.fx.CubicBezier.cubicBezierAtTime(pos, x1, y1, x2, y2, 1);
  };
  fn.toCSS3 = function() {
    return 'cubic-bezier(' + [x1, y1, x2, y2].join(',') + ')';
  };
  fn.reverse = function() {
    return Ext.fx.CubicBezier.cubicBezier(1 - x2, 1 - y2, 1 - x1, 1 - y1);
  };
  return fn;
}}, 0, 0, 0, 0, 0, 0, [Ext.fx, 'CubicBezier'], 0);
Ext.cmd.derive('Ext.fx.Easing', Ext.Base, function() {
  var math = Math, pi = math.PI, pow = math.pow, sin = math.sin, sqrt = math.sqrt, abs = math.abs, backInSeed = 1.70158;
  return {singleton:true, linear:Ext.identityFn, ease:function(n) {
    var q = 0.07813 - n / 2, Q = sqrt(0.0066 + q * q), x = Q - q, X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1), y = -Q - q, Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1), t = X + Y + 0.25;
    return pow(1 - t, 2) * 3 * t * 0.1 + (1 - t) * 3 * t * t + t * t * t;
  }, easeIn:function(n) {
    return pow(n, 1.7);
  }, easeOut:function(n) {
    return pow(n, 0.48);
  }, easeInOut:function(n) {
    var q = 0.48 - n / 1.04, Q = sqrt(0.1734 + q * q), x = Q - q, X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1), y = -Q - q, Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1), t = X + Y + 0.5;
    return (1 - t) * 3 * t * t + t * t * t;
  }, backIn:function(n) {
    return n * n * ((backInSeed + 1) * n - backInSeed);
  }, backOut:function(n) {
    n = n - 1;
    return n * n * ((backInSeed + 1) * n + backInSeed) + 1;
  }, elasticIn:function(n) {
    if (n === 0 || n === 1) {
      return n;
    }
    var p = 0.3, s = p / 4;
    return pow(2, -10 * n) * sin((n - s) * (2 * pi) / p) + 1;
  }, elasticOut:function(n) {
    return 1 - Ext.fx.Easing.elasticIn(1 - n);
  }, bounceIn:function(n) {
    return 1 - Ext.fx.Easing.bounceOut(1 - n);
  }, bounceOut:function(n) {
    var s = 7.5625, p = 2.75, l;
    if (n < 1 / p) {
      l = s * n * n;
    } else {
      if (n < 2 / p) {
        n -= 1.5 / p;
        l = s * n * n + 0.75;
      } else {
        if (n < 2.5 / p) {
          n -= 2.25 / p;
          l = s * n * n + 0.9375;
        } else {
          n -= 2.625 / p;
          l = s * n * n + 0.984375;
        }
      }
    }
    return l;
  }};
}, 0, 0, 0, 0, 0, 0, [Ext.fx, 'Easing'], function(me) {
  var Easing = me.self, proto = Easing.prototype;
  Easing.addMembers({'back-in':proto.backIn, 'back-out':proto.backOut, 'ease-in':proto.easeIn, 'ease-out':proto.easeOut, 'elastic-in':proto.elasticIn, 'elastic-out':proto.elasticOut, 'bounce-in':proto.bounceIn, 'bounce-out':proto.bounceOut, 'ease-in-out':proto.easeInOut});
});
Ext.cmd.derive('Ext.fx.DrawPath', Ext.Base, {singleton:true, pathToStringRE:/,?([achlmqrstvxz]),?/gi, pathCommandRE:/([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig, pathValuesRE:/(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig, stopsRE:/^(\d+%?)$/, radian:Math.PI / 180, is:function(o, type) {
  type = String(type).toLowerCase();
  return type == 'object' && o === Object(o) || type == 'undefined' && typeof o == type || type == 'null' && o === null || type == 'array' && Array.isArray && Array.isArray(o) || Object.prototype.toString.call(o).toLowerCase().slice(8, -1) == type;
}, path2string:function() {
  return this.join(',').replace(Ext.fx.DrawPath.pathToStringRE, '$1');
}, pathToString:function(arrayPath) {
  return arrayPath.join(',').replace(Ext.fx.DrawPath.pathToStringRE, '$1');
}, parsePathString:function(pathString) {
  if (!pathString) {
    return null;
  }
  var paramCounts = {a:7, c:6, h:1, l:2, m:2, q:4, s:4, t:2, v:1, z:0}, data = [], me = this;
  if (me.is(pathString, 'array') && me.is(pathString[0], 'array')) {
    data = me.pathClone(pathString);
  }
  if (!data.length) {
    String(pathString).replace(me.pathCommandRE, function(a, b, c) {
      var params = [], name = b.toLowerCase();
      c.replace(me.pathValuesRE, function(a, b) {
        if (b) {
          params.push(+b);
        }
      });
      if (name == 'm' && params.length > 2) {
        data.push([b].concat(Ext.Array.splice(params, 0, 2)));
        name = 'l';
        b = b == 'm' ? 'l' : 'L';
      }
      while (params.length >= paramCounts[name]) {
        data.push([b].concat(Ext.Array.splice(params, 0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    });
  }
  data.toString = me.path2string;
  return data;
}, pathClone:function(pathArray) {
  var res = [], j, jj, i, ii;
  if (!this.is(pathArray, 'array') || !this.is(pathArray && pathArray[0], 'array')) {
    pathArray = this.parsePathString(pathArray);
  }
  for (i = 0, ii = pathArray.length; i < ii; i++) {
    res[i] = [];
    for (j = 0, jj = pathArray[i].length; j < jj; j++) {
      res[i][j] = pathArray[i][j];
    }
  }
  res.toString = this.path2string;
  return res;
}, pathToAbsolute:function(pathArray) {
  if (!this.is(pathArray, 'array') || !this.is(pathArray && pathArray[0], 'array')) {
    pathArray = this.parsePathString(pathArray);
  }
  var res = [], x = 0, y = 0, mx = 0, my = 0, i = 0, ln = pathArray.length, r, pathSegment, j, ln2;
  if (ln && pathArray[0][0] == 'M') {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    i++;
    res[0] = ['M', x, y];
  }
  for (; i < ln; i++) {
    r = res[i] = [];
    pathSegment = pathArray[i];
    if (pathSegment[0] != pathSegment[0].toUpperCase()) {
      r[0] = pathSegment[0].toUpperCase();
      switch(r[0]) {
        case 'A':
          r[1] = pathSegment[1];
          r[2] = pathSegment[2];
          r[3] = pathSegment[3];
          r[4] = pathSegment[4];
          r[5] = pathSegment[5];
          r[6] = +(pathSegment[6] + x);
          r[7] = +(pathSegment[7] + y);
          break;
        case 'V':
          r[1] = +pathSegment[1] + y;
          break;
        case 'H':
          r[1] = +pathSegment[1] + x;
          break;
        case 'M':
          mx = +pathSegment[1] + x;
          my = +pathSegment[2] + y;
        default:
          j = 1;
          ln2 = pathSegment.length;
          for (; j < ln2; j++) {
            r[j] = +pathSegment[j] + (j % 2 ? x : y);
          }
      }
    } else {
      j = 0;
      ln2 = pathSegment.length;
      for (; j < ln2; j++) {
        res[i][j] = pathSegment[j];
      }
    }
    switch(r[0]) {
      case 'Z':
        x = mx;
        y = my;
        break;
      case 'H':
        x = r[1];
        break;
      case 'V':
        y = r[1];
        break;
      case 'M':
        pathSegment = res[i];
        ln2 = pathSegment.length;
        mx = pathSegment[ln2 - 2];
        my = pathSegment[ln2 - 1];
      default:
        pathSegment = res[i];
        ln2 = pathSegment.length;
        x = pathSegment[ln2 - 2];
        y = pathSegment[ln2 - 1];
    }
  }
  res.toString = this.path2string;
  return res;
}, interpolatePaths:function(path, path2) {
  var me = this, p = me.pathToAbsolute(path), p2 = me.pathToAbsolute(path2), attrs = {x:0, y:0, bx:0, by:0, X:0, Y:0, qx:null, qy:null}, attrs2 = {x:0, y:0, bx:0, by:0, X:0, Y:0, qx:null, qy:null}, fixArc = function(pp, i) {
    if (pp[i].length > 7) {
      pp[i].shift();
      var pi = pp[i];
      while (pi.length) {
        Ext.Array.splice(pp, i++, 0, ['C'].concat(Ext.Array.splice(pi, 0, 6)));
      }
      Ext.Array.erase(pp, i, 1);
      ii = Math.max(p.length, p2.length || 0);
    }
  }, fixM = function(path1, path2, a1, a2, i) {
    if (path1 && path2 && path1[i][0] == 'M' && path2[i][0] != 'M') {
      Ext.Array.splice(path2, i, 0, ['M', a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i][1];
      a1.y = path1[i][2];
      ii = Math.max(p.length, p2.length || 0);
    }
  }, i, ii, seg, seg2, seglen, seg2len;
  for (i = 0, ii = Math.max(p.length, p2.length || 0); i < ii; i++) {
    p[i] = me.command2curve(p[i], attrs);
    fixArc(p, i);
    p2[i] = me.command2curve(p2[i], attrs2);
    fixArc(p2, i);
    fixM(p, p2, attrs, attrs2, i);
    fixM(p2, p, attrs2, attrs, i);
    seg = p[i];
    seg2 = p2[i];
    seglen = seg.length;
    seg2len = seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = parseFloat(seg2[seg2len - 4]) || attrs2.x;
    attrs2.by = parseFloat(seg2[seg2len - 3]) || attrs2.y;
    attrs2.x = seg2[seg2len - 2];
    attrs2.y = seg2[seg2len - 1];
  }
  return [p, p2];
}, command2curve:function(pathCommand, d) {
  var me = this;
  if (!pathCommand) {
    return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
  }
  if (pathCommand[0] != 'T' && pathCommand[0] != 'Q') {
    d.qx = d.qy = null;
  }
  switch(pathCommand[0]) {
    case 'M':
      d.X = pathCommand[1];
      d.Y = pathCommand[2];
      break;
    case 'A':
      pathCommand = ['C'].concat(me.arc2curve.apply(me, [d.x, d.y].concat(pathCommand.slice(1))));
      break;
    case 'S':
      pathCommand = ['C', d.x + (d.x - (d.bx || d.x)), d.y + (d.y - (d.by || d.y))].concat(pathCommand.slice(1));
      break;
    case 'T':
      d.qx = d.x + (d.x - (d.qx || d.x));
      d.qy = d.y + (d.y - (d.qy || d.y));
      pathCommand = ['C'].concat(me.quadratic2curve(d.x, d.y, d.qx, d.qy, pathCommand[1], pathCommand[2]));
      break;
    case 'Q':
      d.qx = pathCommand[1];
      d.qy = pathCommand[2];
      pathCommand = ['C'].concat(me.quadratic2curve(d.x, d.y, pathCommand[1], pathCommand[2], pathCommand[3], pathCommand[4]));
      break;
    case 'L':
      pathCommand = ['C'].concat(d.x, d.y, pathCommand[1], pathCommand[2], pathCommand[1], pathCommand[2]);
      break;
    case 'H':
      pathCommand = ['C'].concat(d.x, d.y, pathCommand[1], d.y, pathCommand[1], d.y);
      break;
    case 'V':
      pathCommand = ['C'].concat(d.x, d.y, d.x, pathCommand[1], d.x, pathCommand[1]);
      break;
    case 'Z':
      pathCommand = ['C'].concat(d.x, d.y, d.X, d.Y, d.X, d.Y);
      break;
  }
  return pathCommand;
}, quadratic2curve:function(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3, _23 = 2 / 3;
  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
}, rotate:function(x, y, rad) {
  var cos = Math.cos(rad), sin = Math.sin(rad), X = x * cos - y * sin, Y = x * sin + y * cos;
  return {x:X, y:Y};
}, arc2curve:function(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
  var me = this, PI = Math.PI, radian = me.radian, _120 = PI * 120 / 180, rad = radian * (+angle || 0), res = [], math = Math, mcos = math.cos, msin = math.sin, msqrt = math.sqrt, mabs = math.abs, masin = math.asin, xy, x, y, h, rx2, ry2, k, cx, cy, f1, f2, df, c1, s1, c2, s2, t, hx, hy, m1, m2, m3, m4, newres, i, ln, f2old, x2old, y2old;
  if (!recursive) {
    xy = me.rotate(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = me.rotate(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    x = (x1 - x2) / 2;
    y = (y1 - y2) / 2;
    h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = msqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    rx2 = rx * rx;
    ry2 = ry * ry;
    k = (large_arc_flag == sweep_flag ? -1 : 1) * msqrt(mabs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = masin(((y1 - cy) / ry).toFixed(7));
    f2 = masin(((y2 - cy) / ry).toFixed(7));
    f1 = x1 < cx ? PI - f1 : f1;
    f2 = x2 < cx ? PI - f2 : f2;
    if (f1 < 0) {
      f1 = PI * 2 + f1;
    }
    if (f2 < 0) {
      f2 = PI * 2 + f2;
    }
    if (sweep_flag && f1 > f2) {
      f1 = f1 - PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  df = f2 - f1;
  if (mabs(df) > _120) {
    f2old = f2;
    x2old = x2;
    y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * mcos(f2);
    y2 = cy + ry * msin(f2);
    res = me.arc2curve(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  c1 = mcos(f1);
  s1 = msin(f1);
  c2 = mcos(f2);
  s2 = msin(f2);
  t = math.tan(df / 4);
  hx = 4 / 3 * rx * t;
  hy = 4 / 3 * ry * t;
  m1 = [x1, y1];
  m2 = [x1 + hx * s1, y1 - hy * c1];
  m3 = [x2 + hx * s2, y2 - hy * c2];
  m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  } else {
    res = [m2, m3, m4].concat(res).join().split(',');
    newres = [];
    ln = res.length;
    for (i = 0; i < ln; i++) {
      newres[i] = i % 2 ? me.rotate(res[i - 1], res[i], rad).y : me.rotate(res[i], res[i + 1], rad).x;
    }
    return newres;
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.fx, 'DrawPath'], 0);
Ext.cmd.derive('Ext.fx.PropertyHandler', Ext.Base, {statics:{defaultHandler:{pixelDefaultsRE:/width|height|top$|bottom$|left$|right$/i, unitRE:/^(-?\d*\.?\d*){1}(em|ex|px|in|cm|mm|pt|pc|%)*$/, scrollRE:/^scroll/i, computeDelta:function(from, end, damper, initial, attr) {
  damper = typeof damper == 'number' ? damper : 1;
  var unitRE = this.unitRE, match = unitRE.exec(from), start, units;
  if (match) {
    from = match[1];
    units = match[2];
    if (!this.scrollRE.test(attr) && !units && this.pixelDefaultsRE.test(attr)) {
      units = 'px';
    }
  }
  from = +from || 0;
  match = unitRE.exec(end);
  if (match) {
    end = match[1];
    units = match[2] || units;
  }
  end = +end || 0;
  start = initial != null ? initial : from;
  return {from:from, delta:(end - start) * damper, units:units};
}, get:function(from, end, damper, initialFrom, attr) {
  var ln = from.length, out = [], i, initial, res, j, len;
  for (i = 0; i < ln; i++) {
    if (initialFrom) {
      initial = initialFrom[i][1].from;
    }
    if (Ext.isArray(from[i][1]) && Ext.isArray(end)) {
      res = [];
      j = 0;
      len = from[i][1].length;
      for (; j < len; j++) {
        res.push(this.computeDelta(from[i][1][j], end[j], damper, initial, attr));
      }
      out.push([from[i][0], res]);
    } else {
      out.push([from[i][0], this.computeDelta(from[i][1], end, damper, initial, attr)]);
    }
  }
  return out;
}, set:function(values, easing) {
  var ln = values.length, out = [], i, val, res, len, j;
  for (i = 0; i < ln; i++) {
    val = values[i][1];
    if (Ext.isArray(val)) {
      res = [];
      j = 0;
      len = val.length;
      for (; j < len; j++) {
        res.push(val[j].from + val[j].delta * easing + (val[j].units || 0));
      }
      out.push([values[i][0], res]);
    } else {
      out.push([values[i][0], val.from + val.delta * easing + (val.units || 0)]);
    }
  }
  return out;
}}, stringHandler:{computeDelta:function(from, end, damper, initial, attr) {
  return {from:from, delta:end};
}, get:function(from, end, damper, initialFrom, attr) {
  var ln = from.length, out = [], i, initial;
  for (i = 0; i < ln; i++) {
    out.push([from[i][0], this.computeDelta(from[i][1], end, damper, initial, attr)]);
  }
  return out;
}, set:function(values, easing) {
  var ln = values.length, out = [], i, val;
  for (i = 0; i < ln; i++) {
    val = values[i][1];
    out.push([values[i][0], val.delta]);
  }
  return out;
}}, color:{rgbRE:/^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i, hexRE:/^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i, hex3RE:/^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i, parseColor:function(color, damper) {
  damper = typeof damper == 'number' ? damper : 1;
  var out = false, reList = [this.hexRE, this.rgbRE, this.hex3RE], length = reList.length, match, base, re, i;
  for (i = 0; i < length; i++) {
    re = reList[i];
    base = i % 2 === 0 ? 16 : 10;
    match = re.exec(color);
    if (match && match.length === 4) {
      if (i === 2) {
        match[1] += match[1];
        match[2] += match[2];
        match[3] += match[3];
      }
      out = {red:parseInt(match[1], base), green:parseInt(match[2], base), blue:parseInt(match[3], base)};
      break;
    }
  }
  return out || color;
}, computeDelta:function(from, end, damper, initial) {
  from = this.parseColor(from);
  end = this.parseColor(end, damper);
  var start = initial ? initial : from, tfrom = typeof start, tend = typeof end;
  if (tfrom === 'string' || tfrom === 'undefined' || tend === 'string' || tend === 'undefined') {
    return end || start;
  }
  return {from:from, delta:{red:Math.round((end.red - start.red) * damper), green:Math.round((end.green - start.green) * damper), blue:Math.round((end.blue - start.blue) * damper)}};
}, get:function(start, end, damper, initialFrom) {
  var ln = start.length, out = [], i, initial;
  for (i = 0; i < ln; i++) {
    if (initialFrom) {
      initial = initialFrom[i][1].from;
    }
    out.push([start[i][0], this.computeDelta(start[i][1], end, damper, initial)]);
  }
  return out;
}, set:function(values, easing) {
  var ln = values.length, out = [], i, val, parsedString, from, delta;
  for (i = 0; i < ln; i++) {
    val = values[i][1];
    if (val) {
      from = val.from;
      delta = val.delta;
      val = typeof val === 'object' && 'red' in val ? 'rgb(' + val.red + ', ' + val.green + ', ' + val.blue + ')' : val;
      val = typeof val === 'object' && val.length ? val[0] : val;
      if (typeof val === 'undefined') {
        return [];
      }
      parsedString = typeof val === 'string' ? val : 'rgb(' + [(from.red + Math.round(delta.red * easing)) % 256, (from.green + Math.round(delta.green * easing)) % 256, (from.blue + Math.round(delta.blue * easing)) % 256].join(',') + ')';
      out.push([values[i][0], parsedString]);
    }
  }
  return out;
}}, object:{interpolate:function(prop, damper) {
  damper = typeof damper === 'number' ? damper : 1;
  var out = {}, p;
  for (p in prop) {
    out[p] = parseFloat(prop[p]) * damper;
  }
  return out;
}, computeDelta:function(from, end, damper, initial) {
  from = this.interpolate(from);
  end = this.interpolate(end, damper);
  var start = initial ? initial : from, delta = {}, p;
  for (p in end) {
    delta[p] = end[p] - start[p];
  }
  return {from:from, delta:delta};
}, get:function(start, end, damper, initialFrom) {
  var ln = start.length, out = [], i, initial;
  for (i = 0; i < ln; i++) {
    if (initialFrom) {
      initial = initialFrom[i][1].from;
    }
    out.push([start[i][0], this.computeDelta(start[i][1], end, damper, initial)]);
  }
  return out;
}, set:function(values, easing) {
  var ln = values.length, out = [], outObject = {}, i, from, delta, val, p;
  for (i = 0; i < ln; i++) {
    val = values[i][1];
    from = val.from;
    delta = val.delta;
    for (p in from) {
      outObject[p] = from[p] + delta[p] * easing;
    }
    out.push([values[i][0], outObject]);
  }
  return out;
}}, path:{computeDelta:function(from, end, damper, initial) {
  damper = typeof damper === 'number' ? damper : 1;
  var start;
  from = +from || 0;
  end = +end || 0;
  start = initial != null ? initial : from;
  return {from:from, delta:(end - start) * damper};
}, forcePath:function(path) {
  if (!Ext.isArray(path) && !Ext.isArray(path[0])) {
    path = Ext.fx.DrawPath.parsePathString(path);
  }
  return path;
}, get:function(start, end, damper, initialFrom) {
  var endPath = this.forcePath(end), out = [], startLn = start.length, startPathLn, pointsLn, i, deltaPath, initial, j, k, path, startPath;
  for (i = 0; i < startLn; i++) {
    startPath = this.forcePath(start[i][1]);
    deltaPath = Ext.fx.DrawPath.interpolatePaths(startPath, endPath);
    startPath = deltaPath[0];
    endPath = deltaPath[1];
    startPathLn = startPath.length;
    path = [];
    for (j = 0; j < startPathLn; j++) {
      deltaPath = [startPath[j][0]];
      pointsLn = startPath[j].length;
      for (k = 1; k < pointsLn; k++) {
        initial = initialFrom && initialFrom[0][1][j][k].from;
        deltaPath.push(this.computeDelta(startPath[j][k], endPath[j][k], damper, initial));
      }
      path.push(deltaPath);
    }
    out.push([start[i][0], path]);
  }
  return out;
}, set:function(values, easing) {
  var ln = values.length, out = [], i, j, k, newPath, calcPath, deltaPath, deltaPathLn, pointsLn;
  for (i = 0; i < ln; i++) {
    deltaPath = values[i][1];
    newPath = [];
    deltaPathLn = deltaPath.length;
    for (j = 0; j < deltaPathLn; j++) {
      calcPath = [deltaPath[j][0]];
      pointsLn = deltaPath[j].length;
      for (k = 1; k < pointsLn; k++) {
        calcPath.push(deltaPath[j][k].from + deltaPath[j][k].delta * easing);
      }
      newPath.push(calcPath.join(','));
    }
    out.push([values[i][0], newPath.join(',')]);
  }
  return out;
}}}}, 0, 0, 0, 0, 0, 0, [Ext.fx, 'PropertyHandler'], function() {
  var props = ['outlineColor', 'backgroundColor', 'borderColor', 'borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor', 'fill', 'stroke'], length = props.length, i = 0, prop;
  for (; i < length; i++) {
    prop = props[i];
    this[prop] = this.color;
  }
  props = ['cursor'];
  length = props.length;
  i = 0;
  for (; i < length; i++) {
    prop = props[i];
    this[prop] = this.stringHandler;
  }
});
Ext.cmd.derive('Ext.fx.Anim', Ext.Base, {isAnimation:true, duration:250, delay:0, delayStart:0, dynamic:false, easing:'ease', damper:1, bezierRE:/^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/, reverse:false, running:false, paused:false, iterations:1, autoEnd:false, alternate:false, currentIteration:0, startTime:0, frameCount:0, constructor:function(config) {
  var me = this, curve;
  config = config || {};
  if (config.keyframes) {
    return new Ext.fx.Animator(config);
  }
  Ext.apply(me, config);
  if (me.from === undefined) {
    me.from = {};
  }
  me.propHandlers = {};
  me.config = config;
  me.target = Ext.fx.Manager.createTarget(me.target);
  me.easingFn = Ext.fx.Easing[me.easing];
  me.target.dynamic = me.dynamic;
  if (!me.easingFn) {
    me.easingFn = String(me.easing).match(me.bezierRE);
    if (me.easingFn && me.easingFn.length === 5) {
      curve = me.easingFn;
      me.easingFn = Ext.fx.CubicBezier.cubicBezier(+curve[1], +curve[2], +curve[3], +curve[4]);
    }
  }
  me.id = Ext.id(null, 'ext-anim-');
  me.mixins.observable.constructor.call(me);
  Ext.fx.Manager.addAnim(me);
  if (config.autoEnd) {
    me.running = true;
    me.jumpToEnd();
  }
}, setAttr:function(attr, value) {
  return Ext.fx.Manager.items.get(this.id).setAttr(this.target, attr, value);
}, initAttrs:function() {
  var me = this, from = me.from, to = me.to, initialFrom = me.initialFrom || {}, out = {}, start, end, propHandler, attr;
  for (attr in to) {
    if (to.hasOwnProperty(attr)) {
      start = me.target.getAttr(attr, from[attr]);
      end = to[attr];
      if (!Ext.fx.PropertyHandler[attr]) {
        if (Ext.isObject(end)) {
          propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler.object;
        } else {
          propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler.defaultHandler;
        }
      } else {
        propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler[attr];
      }
      out[attr] = propHandler.get(start, end, me.damper, initialFrom[attr], attr);
    }
  }
  me.currentAttrs = out;
}, start:function(startTime) {
  var me = this, delay = me.delay, delayStart = me.delayStart, delayDelta;
  if (delay) {
    if (!delayStart) {
      me.delayStart = startTime;
      return;
    } else {
      delayDelta = startTime - delayStart;
      if (delayDelta < delay) {
        return;
      } else {
        startTime = new Date(delayStart.getTime() + delay);
      }
    }
  }
  if (me.fireEvent('beforeanimate', me) !== false) {
    me.startTime = startTime;
    if (!me.paused && !me.currentAttrs) {
      me.initAttrs();
    }
    me.running = true;
    me.frameCount = 0;
  }
}, jumpToEnd:function(suppressEvent) {
  var me = this;
  if (!me.endWasCalled) {
    if (!me.currentAttrs) {
      me.initAttrs();
    }
    Ext.fx.Manager.jumpToEnd(me);
    me.end(suppressEvent);
  }
}, runAnim:function(elapsedTime) {
  var me = this, attrs = me.currentAttrs, duration = me.duration, easingFn = me.easingFn, propHandlers = me.propHandlers, ret = {}, easing, values, attr, lastFrame;
  if (elapsedTime >= duration) {
    elapsedTime = duration;
    lastFrame = true;
  }
  if (me.reverse) {
    elapsedTime = duration - elapsedTime;
  }
  for (attr in attrs) {
    if (attrs.hasOwnProperty(attr)) {
      values = attrs[attr];
      easing = lastFrame ? 1 : easingFn(elapsedTime / duration);
      ret[attr] = propHandlers[attr].set(values, easing);
    }
  }
  me.frameCount++;
  return ret;
}, lastFrame:function() {
  var me = this, iter = me.iterations, iterCount = me.currentIteration;
  iterCount++;
  if (iterCount < iter) {
    if (me.alternate) {
      me.reverse = !me.reverse;
    }
    me.startTime = new Date;
    me.currentIteration = iterCount;
    me.paused = false;
  } else {
    me.currentIteration = 0;
    me.end();
    me.fireEvent('lastframe', me, me.startTime);
  }
}, endWasCalled:0, end:function(suppressEvent) {
  var me = this;
  if (me.endWasCalled++) {
    return;
  }
  me.startTime = 0;
  me.paused = false;
  me.running = false;
  Ext.fx.Manager.removeAnim(me);
  if (!suppressEvent) {
    me.fireEvent('afteranimate', me, me.startTime);
    Ext.callback(me.callback, me.scope, [me, me.startTime]);
  }
  if (me.remove) {
    me.target.destroy();
  }
}, isReady:function() {
  return this.paused === false && this.running === false && this.iterations > 0;
}, isRunning:function() {
  return this.paused === false && this.running === true && this.isAnimator !== true;
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.fx, 'Anim'], 0);
Ext.enableFx = true;
Ext.cmd.derive('Ext.util.Animate', Ext.Base, {mixinId:'animate', isAnimate:true, animate:function(animObj) {
  var me = this;
  if (Ext.fx.Manager.hasFxBlock(me.id)) {
    return me;
  }
  Ext.fx.Manager.queueFx(new Ext.fx.Anim(me.anim(animObj)));
  return this;
}, anim:function(config) {
  if (!Ext.isObject(config)) {
    return config ? {} : false;
  }
  var me = this;
  if (config.stopAnimation) {
    me.stopAnimation();
  }
  Ext.applyIf(config, Ext.fx.Manager.getFxDefaults(me.id));
  return Ext.apply({target:me, paused:true}, config);
}, getAnimationProps:function() {
  var me = this, layout = me.layout;
  return layout && layout.animate ? layout.animate : {};
}, stopFx:Ext.Function.alias(Ext.util.Animate, 'stopAnimation'), stopAnimation:function(suppressEvent) {
  Ext.fx.Manager.stopAnimation(this.id, suppressEvent);
  return this;
}, syncFx:function() {
  Ext.fx.Manager.setFxDefaults(this.id, {concurrent:true});
  return this;
}, sequenceFx:function() {
  Ext.fx.Manager.setFxDefaults(this.id, {concurrent:false});
  return this;
}, hasActiveFx:Ext.Function.alias(Ext.util.Animate, 'getActiveAnimation'), getActiveAnimation:function() {
  return Ext.fx.Manager.getActiveAnimation(this.id);
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Animate'], 0);
Ext.cmd.derive('Ext.dom.Fly', Ext.dom.Element, {alternateClassName:'Ext.dom.Element.Fly', validNodeTypes:{1:1, 9:1, 11:1}, isFly:true, constructor:function(dom) {
  this.dom = dom;
  this.el = this;
}, attach:function(dom) {
  var me = this, data;
  if (!dom) {
    return me.detach();
  }
  me.dom = Ext.getDom(dom);
  if (!Ext.cache[dom.id]) {
    data = me.peekData();
    if (data) {
      data.isSynchronized = false;
    }
  }
  return me;
}, detach:function() {
  return this.dom = null;
}, addListener:null, removeListener:null}, 1, 0, 0, 0, 0, 0, [Ext.dom, 'Fly', Ext.dom.Element, 'Fly'], function(Fly) {
  var flyweights = {}, detachedBodyEl;
  Fly.cache = flyweights;
  Ext.fly = function(dom, named) {
    var fly = null, fn = Ext.fly, nodeType, data;
    named = named || fn.caller && (fn.caller.$name || fn.caller.name) || '_global';
    dom = Ext.getDom(dom);
    if (dom) {
      nodeType = dom.nodeType;
      if (Fly.prototype.validNodeTypes[nodeType] || !nodeType && dom.window == dom) {
        fly = Ext.cache[dom.id];
        if (!fly || fly.dom !== dom) {
          fly = flyweights[named] || (flyweights[named] = new Fly);
          fly.dom = dom;
          data = fly.peekData();
          if (data) {
            data.isSynchronized = false;
          }
        }
      }
    }
    return fly;
  };
  Ext.getDetachedBody = function() {
    if (!detachedBodyEl) {
      Ext.detachedBodyEl = detachedBodyEl = new Fly(document.createElement('div'));
      detachedBodyEl.isDetachedBody = true;
    }
    return detachedBodyEl;
  };
});
Ext.cmd.derive('Ext.dom.CompositeElementLite', Ext.Base, {alternateClassName:['Ext.CompositeElementLite'], isComposite:true, isLite:true, statics:{importElementMethods:function() {
  var Element = Ext.dom.Element, prototype = this.prototype;
  Ext.Object.each(Element.prototype, function(name, member) {
    if (typeof member === 'function' && !prototype[name]) {
      prototype[name] = function() {
        return this.invoke(name, arguments);
      };
    }
  });
}}, constructor:function(elements, skipValidation) {
  if (skipValidation) {
    this.elements = elements || [];
  } else {
    this.elements = [];
    this.add(elements);
  }
}, getElement:function(el) {
  var fly = this._fly || (this._fly = new Ext.dom.Fly);
  return fly.attach(el);
}, transformElement:function(el) {
  return Ext.getDom(el);
}, getCount:function() {
  return this.elements.length;
}, add:function(els, root) {
  var elements = this.elements, i, ln;
  if (!els) {
    return this;
  }
  if (typeof els == 'string') {
    els = Ext.fly(root || document).query(els);
  } else {
    if (els.isComposite) {
      els = els.elements;
    } else {
      if (!Ext.isIterable(els)) {
        els = [els];
      }
    }
  }
  for (i = 0, ln = els.length; i < ln; ++i) {
    elements.push(this.transformElement(els[i]));
  }
  return this;
}, invoke:function(fn, args) {
  var me = this, elements = me.elements, ln = elements.length, prototype, element, i;
  if (i !== 0) {
    prototype = (me.isLite ? Ext.dom.Fly : Ext.dom.Element).prototype;
    for (i = 0; i < ln; i++) {
      element = elements[i];
      if (element) {
        prototype[fn].apply(me.getElement(element), args);
      }
    }
  }
  return me;
}, item:function(index) {
  var el = this.elements[index], out = null;
  if (el) {
    out = this.getElement(el);
  }
  return out;
}, slice:function(start, end) {
  return Ext.Array.slice(this.elements, start, end);
}, each:function(fn, scope) {
  var me = this, els = me.elements, len = els.length, i, e;
  for (i = 0; i < len; i++) {
    e = els[i];
    if (e) {
      e = this.getElement(e);
      if (fn.call(scope || e, e, me, i) === false) {
        break;
      }
    }
  }
  return me;
}, fill:function(els) {
  var me = this;
  me.elements = [];
  me.add(els);
  return me;
}, insert:function(index, nodes) {
  Ext.Array.insert(this.elements, index, nodes);
}, filter:function(selector) {
  var me = this, els = me.elements, len = els.length, out = [], i = 0, isFunc = typeof selector == 'function', add, el;
  for (; i < len; i++) {
    el = els[i];
    add = false;
    if (el) {
      el = me.getElement(el);
      if (isFunc) {
        add = selector.call(el, el, me, i) !== false;
      } else {
        add = el.is(selector);
      }
      if (add) {
        out.push(me.transformElement(el));
      }
    }
  }
  me.elements = out;
  return me;
}, indexOf:function(el) {
  return Ext.Array.indexOf(this.elements, this.transformElement(el));
}, replaceElement:function(el, replacement, domReplace) {
  var index = !isNaN(el) ? el : this.indexOf(el), d;
  if (index > -1) {
    replacement = Ext.getDom(replacement);
    if (domReplace) {
      d = this.elements[index];
      d.parentNode.insertBefore(replacement, d);
      Ext.removeNode(d);
    }
    Ext.Array.splice(this.elements, index, 1, replacement);
  }
  return this;
}, clear:function(removeDom) {
  var me = this, els = me.elements, i = els.length - 1;
  if (removeDom) {
    for (; i >= 0; i--) {
      Ext.removeNode(els[i]);
    }
  }
  this.elements = [];
}, addElements:function(els, root) {
  if (!els) {
    return this;
  }
  if (typeof els === 'string') {
    els = Ext.dom.Element.selectorFunction(els, root);
  }
  var yels = this.elements, eLen = els.length, e;
  for (e = 0; e < eLen; e++) {
    yels.push(Ext.get(els[e]));
  }
  return this;
}, first:function() {
  return this.item(0);
}, last:function() {
  return this.item(this.getCount() - 1);
}, contains:function(el) {
  return this.indexOf(el) != -1;
}, removeElement:function(keys, removeDom) {
  keys = [].concat(keys);
  var me = this, elements = me.elements, kLen = keys.length, val, el, k;
  for (k = 0; k < kLen; k++) {
    val = keys[k];
    if (el = elements[val] || elements[val = me.indexOf(val)]) {
      if (removeDom) {
        if (el.dom) {
          el.destroy();
        } else {
          Ext.removeNode(el);
        }
      }
      Ext.Array.erase(elements, val, 1);
    }
  }
  return me;
}, destroy:function() {
  this.invoke('destroy', arguments);
  this.callParent();
}}, 1, 0, 0, 0, 0, 0, [Ext.dom, 'CompositeElementLite', Ext, 'CompositeElementLite'], function(CompositeElementLite) {
  var prototype = CompositeElementLite.prototype;
  CompositeElementLite.importElementMethods();
  prototype.on = prototype.addListener;
});
Ext.define('Ext.overrides.dom.Element', function() {
  var Element, WIN = window, DOC = document, HIDDEN = 'hidden', ISCLIPPED = 'isClipped', OVERFLOW = 'overflow', OVERFLOWX = 'overflow-x', OVERFLOWY = 'overflow-y', ORIGINALCLIP = 'originalClip', HEIGHT = 'height', WIDTH = 'width', VISIBILITY = 'visibility', DISPLAY = 'display', NONE = 'none', OFFSETS = 'offsets', CLIP = 'clip', ORIGINALDISPLAY = 'originalDisplay', VISMODE = 'visibilityMode', ISVISIBLE = 'isVisible', OFFSETCLASS = 'x-hidden-offsets', CLIPCLASS = 'x-hidden-clip', boxMarkup = ['\x3cdiv class\x3d"{0}-tl" role\x3d"presentation"\x3e', 
  '\x3cdiv class\x3d"{0}-tr" role\x3d"presentation"\x3e', '\x3cdiv class\x3d"{0}-tc" role\x3d"presentation"\x3e\x3c/div\x3e', '\x3c/div\x3e', '\x3c/div\x3e', '\x3cdiv class\x3d"{0}-ml" role\x3d"presentation"\x3e', '\x3cdiv class\x3d"{0}-mr" role\x3d"presentation"\x3e', '\x3cdiv class\x3d"{0}-mc" role\x3d"presentation"\x3e\x3c/div\x3e', '\x3c/div\x3e', '\x3c/div\x3e', '\x3cdiv class\x3d"{0}-bl" role\x3d"presentation"\x3e', '\x3cdiv class\x3d"{0}-br" role\x3d"presentation"\x3e', '\x3cdiv class\x3d"{0}-bc" role\x3d"presentation"\x3e\x3c/div\x3e', 
  '\x3c/div\x3e', '\x3c/div\x3e'].join(''), scriptTagRe = /(?:<script([^>]*)?>)((\n|\r|.)*?)(?:<\/script>)/ig, replaceScriptTagRe = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig, srcRe = /\ssrc=([\'\"])(.*?)\1/i, nonSpaceRe = /\S/, typeRe = /\stype=([\'\"])(.*?)\1/i, adjustDirect2DTableRe = /table-row|table-.*-group/, msRe = /^-ms-/, camelRe = /(-[a-z])/gi, camelReplaceFn = function(m, a) {
    return a.charAt(1).toUpperCase();
  }, XMASKED = 'x-masked', XMASKEDRELATIVE = 'x-masked-relative', EXTELMASKMSG = 'x-mask-msg', bodyRe = /^body/i, propertyCache = {}, getVisMode = function(el) {
    var data = el.getData(), visMode = data[VISMODE];
    if (visMode === undefined) {
      data[VISMODE] = visMode = Element.VISIBILITY;
    }
    return visMode;
  }, emptyRange = DOC.createRange ? DOC.createRange() : null, syncContentFly;
  if (Ext.isIE8) {
    var garbageBin = DOC.createElement('div'), destroyQueue = [], clearGarbage, clearGarbageFn = function() {
      var len = destroyQueue.length, i;
      for (i = 0; i < len; i++) {
        garbageBin.appendChild(destroyQueue[i]);
      }
      garbageBin.innerHTML = '';
      destroyQueue.length = 0;
    };
    clearGarbage = Ext.Function.createBuffered(clearGarbageFn, 10);
  }
  return {override:'Ext.dom.Element', mixins:[Ext.util.Animate], skipGarbageCollection:false, _init:function(E) {
    Element = E;
  }, statics:{normalize:function(prop) {
    if (prop === 'float') {
      prop = Ext.supports.Float ? 'cssFloat' : 'styleFloat';
    }
    return propertyCache[prop] || (propertyCache[prop] = prop.replace(msRe, 'ms-').replace(camelRe, camelReplaceFn));
  }}, addKeyListener:function(key, fn, scope) {
    var config;
    if (typeof key !== 'object' || Ext.isArray(key)) {
      config = {target:this, key:key, fn:fn, scope:scope};
    } else {
      config = {target:this, key:key.key, shift:key.shift, ctrl:key.ctrl, alt:key.alt, fn:fn, scope:scope};
    }
    return new Ext.util.KeyMap(config);
  }, addKeyMap:function(config) {
    return new Ext.util.KeyMap(Ext.apply({target:this}, config));
  }, adjustDirect2DDimension:function(dimension) {
    var me = this, dom = me.dom, display = me.getStyle('display'), inlineDisplay = dom.style.display, inlinePosition = dom.style.position, originIndex = dimension === WIDTH ? 0 : 1, currentStyle = dom.currentStyle, floating;
    if (display === 'inline') {
      dom.style.display = 'inline-block';
    }
    dom.style.position = display.match(adjustDirect2DTableRe) ? 'absolute' : 'static';
    floating = (parseFloat(currentStyle[dimension]) || parseFloat(currentStyle.msTransformOrigin.split(' ')[originIndex]) * 2) % 1;
    dom.style.position = inlinePosition;
    if (display === 'inline') {
      dom.style.display = inlineDisplay;
    }
    return floating;
  }, afterAnimate:function() {
    var shadow = this.shadow;
    if (shadow && !shadow.disabled && !shadow.animate) {
      shadow.show();
    }
  }, anchorAnimX:function(anchor) {
    var xName = anchor === 'l' ? 'right' : 'left';
    this.dom.style[xName] = '0px';
  }, anim:function(config) {
    if (!Ext.isObject(config)) {
      return config ? {} : false;
    }
    var me = this, duration = config.duration || Ext.fx.Anim.prototype.duration, easing = config.easing || 'ease', animConfig;
    if (config.stopAnimation) {
      me.stopAnimation();
    }
    Ext.applyIf(config, Ext.fx.Manager.getFxDefaults(me.id));
    Ext.fx.Manager.setFxDefaults(me.id, {delay:0});
    animConfig = {target:me.dom, remove:config.remove, alternate:config.alternate || false, duration:duration, easing:easing, callback:config.callback, listeners:config.listeners, iterations:config.iterations || 1, scope:config.scope, block:config.block, concurrent:config.concurrent, delay:config.delay || 0, paused:true, keyframes:config.keyframes, from:config.from || {}, to:Ext.apply({}, config), userConfig:config};
    Ext.apply(animConfig.to, config.to);
    delete animConfig.to.to;
    delete animConfig.to.from;
    delete animConfig.to.remove;
    delete animConfig.to.alternate;
    delete animConfig.to.keyframes;
    delete animConfig.to.iterations;
    delete animConfig.to.listeners;
    delete animConfig.to.target;
    delete animConfig.to.paused;
    delete animConfig.to.callback;
    delete animConfig.to.scope;
    delete animConfig.to.duration;
    delete animConfig.to.easing;
    delete animConfig.to.concurrent;
    delete animConfig.to.block;
    delete animConfig.to.stopAnimation;
    delete animConfig.to.delay;
    return animConfig;
  }, animate:function(config) {
    this.addAnimation(config);
    return this;
  }, addAnimation:function(config) {
    var me = this, animId = me.dom.id || Ext.id(me.dom), listeners, anim, end;
    if (!Ext.fx.Manager.hasFxBlock(animId)) {
      if (config.listeners) {
        listeners = config.listeners;
        delete config.listeners;
      }
      if (config.internalListeners) {
        config.listeners = config.internalListeners;
        delete config.internalListeners;
      }
      end = config.autoEnd;
      delete config.autoEnd;
      anim = new Ext.fx.Anim(me.anim(config));
      anim.on({afteranimate:'afterAnimate', beforeanimate:'beforeAnimate', scope:me, single:true});
      if (listeners) {
        anim.on(listeners);
      }
      Ext.fx.Manager.queueFx(anim);
      if (end) {
        anim.jumpToEnd();
      }
    }
    return anim;
  }, beforeAnimate:function() {
    var shadow = this.shadow;
    if (shadow && !shadow.disabled && !shadow.animate) {
      shadow.hide();
    }
  }, boxWrap:function(cls) {
    cls = cls || 'x-box';
    var el = Ext.get(this.insertHtml('beforeBegin', "\x3cdiv class\x3d'" + cls + "' role\x3d'presentation'\x3e" + Ext.String.format(boxMarkup, cls) + '\x3c/div\x3e'));
    el.selectNode('.' + cls + '-mc').appendChild(this.dom);
    return el;
  }, clean:function(forceReclean) {
    var me = this, dom = me.dom, data = me.getData(), n = dom.firstChild, ni = -1, nx;
    if (data.isCleaned && forceReclean !== true) {
      return me;
    }
    while (n) {
      nx = n.nextSibling;
      if (n.nodeType === 3) {
        if (!nonSpaceRe.test(n.nodeValue)) {
          dom.removeChild(n);
        } else {
          if (nx && nx.nodeType === 3) {
            n.appendData(Ext.String.trim(nx.data));
            dom.removeChild(nx);
            nx = n.nextSibling;
            n.nodeIndex = ++ni;
          }
        }
      } else {
        Ext.fly(n, '_clean').clean();
        n.nodeIndex = ++ni;
      }
      n = nx;
    }
    data.isCleaned = true;
    return me;
  }, empty:emptyRange ? function() {
    var dom = this.dom;
    if (dom.firstChild) {
      emptyRange.setStartBefore(dom.firstChild);
      emptyRange.setEndAfter(dom.lastChild);
      emptyRange.deleteContents();
    }
  } : function() {
    var dom = this.dom;
    while (dom.lastChild) {
      dom.removeChild(dom.lastChild);
    }
  }, clearListeners:function() {
    this.removeAnchor();
    arguments.callee.$previous.call(this);
  }, clearPositioning:function(value) {
    value = value || '';
    return this.setStyle({left:value, right:value, top:value, bottom:value, 'z-index':'', position:'static'});
  }, createProxy:function(config, renderTo, matchBox) {
    config = typeof config === 'object' ? config : {tag:'div', role:'presentation', cls:config};
    var me = this, proxy = renderTo ? Ext.DomHelper.append(renderTo, config, true) : Ext.DomHelper.insertBefore(me.dom, config, true);
    proxy.setVisibilityMode(Element.DISPLAY);
    proxy.hide();
    if (matchBox && me.setBox && me.getBox) {
      proxy.setBox(me.getBox());
    }
    return proxy;
  }, clearOpacity:function() {
    return this.setOpacity('');
  }, clip:function() {
    var me = this, data = me.getData(), style;
    if (!data[ISCLIPPED]) {
      data[ISCLIPPED] = true;
      style = me.getStyle([OVERFLOW, OVERFLOWX, OVERFLOWY]);
      data[ORIGINALCLIP] = {o:style[OVERFLOW], x:style[OVERFLOWX], y:style[OVERFLOWY]};
      me.setStyle(OVERFLOW, HIDDEN);
      me.setStyle(OVERFLOWX, HIDDEN);
      me.setStyle(OVERFLOWY, HIDDEN);
    }
    return me;
  }, destroy:function() {
    var me = this, dom = me.dom, data = me.peekData(), maskEl, maskMsg;
    if (dom) {
      if (me.isAnimate) {
        me.stopAnimation(true);
      }
      me.removeAnchor();
    }
    if (me.deferredFocusTimer) {
      Ext.undefer(me.deferredFocusTimer);
      me.deferredFocusTimer = null;
    }
    arguments.callee.$previous.call(this);
    if (dom && Ext.isIE8 && dom.window != dom && dom.nodeType !== 9 && dom.tagName !== 'BODY' && dom.tagName !== 'HTML') {
      destroyQueue[destroyQueue.length] = dom;
      clearGarbage();
    }
    if (data) {
      maskEl = data.maskEl;
      maskMsg = data.maskMsg;
      if (maskEl) {
        maskEl.destroy();
      }
      if (maskMsg) {
        maskMsg.destroy();
      }
    }
  }, enableDisplayMode:function(display) {
    var me = this;
    me.setVisibilityMode(Element.DISPLAY);
    if (display !== undefined) {
      me.getData()[ORIGINALDISPLAY] = display;
    }
    return me;
  }, fadeIn:function(options) {
    var me = this, dom = me.dom, animFly = new Ext.dom.Fly;
    me.animate(Ext.apply({}, options, {opacity:1, internalListeners:{beforeanimate:function(anim) {
      animFly.attach(dom);
      if (animFly.isStyle('display', 'none')) {
        animFly.setDisplayed('');
      } else {
        animFly.show();
      }
    }}}));
    return this;
  }, fadeOut:function(options) {
    var me = this, dom = me.dom, animFly = new Ext.dom.Fly;
    options = Ext.apply({opacity:0, internalListeners:{afteranimate:function(anim) {
      if (anim.to.opacity === 0) {
        animFly.attach(dom);
        animFly.attach(dom);
        if (options.useDisplay) {
          animFly.setDisplayed(false);
        } else {
          animFly.hide();
        }
      }
    }}}, options);
    me.animate(options);
    return me;
  }, fixDisplay:function() {
    var me = this;
    if (me.isStyle(DISPLAY, NONE)) {
      me.setStyle(VISIBILITY, HIDDEN);
      me.setStyle(DISPLAY, me._getDisplay());
      if (me.isStyle(DISPLAY, NONE)) {
        me.setStyle(DISPLAY, 'block');
      }
    }
  }, frame:function(color, count, obj) {
    var me = this, dom = me.dom, animFly = new Ext.dom.Fly, beforeAnim;
    color = color || '#C3DAF9';
    count = count || 1;
    obj = obj || {};
    beforeAnim = function() {
      var animScope = this, box, proxy, proxyAnim;
      animFly.attach(dom);
      animFly.show();
      box = animFly.getBox();
      proxy = Ext.getBody().createChild({role:'presentation', id:animFly.dom.id + '-anim-proxy', style:{position:'absolute', 'pointer-events':'none', 'z-index':35000, border:'0px solid ' + color}});
      proxyAnim = new Ext.fx.Anim({target:proxy, duration:obj.duration || 1000, iterations:count, from:{top:box.y, left:box.x, borderWidth:0, opacity:1, height:box.height, width:box.width}, to:{top:box.y - 20, left:box.x - 20, borderWidth:10, opacity:0, height:box.height + 40, width:box.width + 40}});
      proxyAnim.on('afteranimate', function() {
        proxy.destroy();
        animScope.end();
      });
    };
    me.animate({duration:Math.max(obj.duration, 500) * 2 || 2000, listeners:{beforeanimate:{fn:beforeAnim}}, callback:obj.callback, scope:obj.scope});
    return me;
  }, getColor:function(attr, defaultValue, prefix) {
    var v = this.getStyle(attr), color = prefix || prefix === '' ? prefix : '#', h, len, i = 0;
    if (!v || /transparent|inherit/.test(v)) {
      return defaultValue;
    }
    if (/^r/.test(v)) {
      v = v.slice(4, v.length - 1).split(',');
      len = v.length;
      for (; i < len; i++) {
        h = parseInt(v[i], 10);
        color += (h < 16 ? '0' : '') + h.toString(16);
      }
    } else {
      v = v.replace('#', '');
      color += v.length === 3 ? v.replace(/^(\w)(\w)(\w)$/, '$1$1$2$2$3$3') : v;
    }
    return color.length > 5 ? color.toLowerCase() : defaultValue;
  }, getLoader:function() {
    var me = this, data = me.getData(), loader = data.loader;
    if (!loader) {
      data.loader = loader = new Ext.ElementLoader({target:me});
    }
    return loader;
  }, getPositioning:function(autoPx) {
    var styles = this.getStyle(['left', 'top', 'position', 'z-index']), dom = this.dom;
    if (autoPx) {
      if (styles.left === 'auto') {
        styles.left = dom.offsetLeft + 'px';
      }
      if (styles.top === 'auto') {
        styles.top = dom.offsetTop + 'px';
      }
    }
    return styles;
  }, ghost:function(anchor, options) {
    var me = this, dom = me.dom, animFly = new Ext.dom.Fly, beforeAnim;
    anchor = anchor || 'b';
    beforeAnim = function() {
      animFly.attach(dom);
      var width = animFly.getWidth(), height = animFly.getHeight(), xy = animFly.getXY(), position = animFly.getPositioning(), to = {opacity:0};
      switch(anchor) {
        case 't':
          to.y = xy[1] - height;
          break;
        case 'l':
          to.x = xy[0] - width;
          break;
        case 'r':
          to.x = xy[0] + width;
          break;
        case 'b':
          to.y = xy[1] + height;
          break;
        case 'tl':
          to.x = xy[0] - width;
          to.y = xy[1] - height;
          break;
        case 'bl':
          to.x = xy[0] - width;
          to.y = xy[1] + height;
          break;
        case 'br':
          to.x = xy[0] + width;
          to.y = xy[1] + height;
          break;
        case 'tr':
          to.x = xy[0] + width;
          to.y = xy[1] - height;
          break;
      }
      this.to = to;
      this.on('afteranimate', function() {
        animFly.attach(dom);
        if (animFly) {
          animFly.hide();
          animFly.clearOpacity();
          animFly.setPositioning(position);
        }
      });
    };
    me.animate(Ext.applyIf(options || {}, {duration:500, easing:'ease-out', listeners:{beforeanimate:beforeAnim}}));
    return me;
  }, getTextSelection:function() {
    var ret = arguments.callee.$previous.call(this);
    if (typeof ret[0] !== 'number') {
      var dom = this.dom;
      var doc = dom.ownerDocument;
      var range = doc.selection.createRange();
      var textRange = dom.createTextRange();
      textRange.setEndPoint('EndToStart', range);
      ret[0] = textRange.text.length;
      ret[1] = ret[0] + range.text.length;
    }
    return ret;
  }, hide:function(animate) {
    if (typeof animate === 'string') {
      this.setVisible(false, animate);
      return this;
    }
    this.setVisible(false, this.anim(animate));
    return this;
  }, highlight:function(color, options) {
    var me = this, dom = me.dom, from = {}, animFly = new Ext.dom.Fly, restore, to, attr, lns, event, fn;
    options = options || {};
    lns = options.listeners || {};
    attr = options.attr || 'backgroundColor';
    from[attr] = color || 'ffff9c';
    if (!options.to) {
      to = {};
      to[attr] = options.endColor || me.getColor(attr, 'ffffff', '');
    } else {
      to = options.to;
    }
    options.listeners = Ext.apply(Ext.apply({}, lns), {beforeanimate:function() {
      animFly.attach(dom);
      restore = dom.style[attr];
      animFly.clearOpacity();
      animFly.show();
      event = lns.beforeanimate;
      if (event) {
        fn = event.fn || event;
        return fn.apply(event.scope || lns.scope || WIN, arguments);
      }
    }, afteranimate:function() {
      if (dom) {
        dom.style[attr] = restore;
      }
      event = lns.afteranimate;
      if (event) {
        fn = event.fn || event;
        fn.apply(event.scope || lns.scope || WIN, arguments);
      }
    }});
    me.animate(Ext.apply({}, options, {duration:1000, easing:'ease-in', from:from, to:to}));
    return me;
  }, initDD:function(group, config, overrides) {
    var dd = new Ext.dd.DD(Ext.id(this.dom), group, config);
    return Ext.apply(dd, overrides);
  }, initDDProxy:function(group, config, overrides) {
    var dd = new Ext.dd.DDProxy(Ext.id(this.dom), group, config);
    return Ext.apply(dd, overrides);
  }, initDDTarget:function(group, config, overrides) {
    var dd = new Ext.dd.DDTarget(Ext.id(this.dom), group, config);
    return Ext.apply(dd, overrides);
  }, isMasked:function(deep) {
    var me = this, data = me.getData(), maskEl = data.maskEl, maskMsg = data.maskMsg, hasMask = false, parent;
    if (maskEl && maskEl.isVisible()) {
      if (maskMsg) {
        maskMsg.center(me);
      }
      hasMask = true;
    } else {
      if (deep) {
        parent = me.findParentNode();
        if (parent) {
          return Ext.fly(parent).isMasked(deep);
        }
      }
    }
    return hasMask;
  }, load:function(options) {
    this.getLoader().load(options);
    return this;
  }, mask:function(msg, msgCls, elHeight) {
    var me = this, dom = me.dom, data = me.getData(), maskEl = data.maskEl, maskMsg;
    if (!(bodyRe.test(dom.tagName) && me.getStyle('position') === 'static')) {
      me.addCls(XMASKEDRELATIVE);
    }
    if (maskEl) {
      maskEl.destroy();
    }
    maskEl = Ext.DomHelper.append(dom, {role:'presentation', cls:'x-mask x-border-box', children:{role:'presentation', cls:msgCls ? EXTELMASKMSG + ' ' + msgCls : EXTELMASKMSG, cn:{tag:'div', role:'presentation', cls:'x-mask-msg-inner', cn:{tag:'div', role:'presentation', cls:'x-mask-msg-text', html:msg || ''}}}}, true);
    maskMsg = Ext.fly(maskEl.dom.firstChild);
    data.maskEl = maskEl;
    me.addCls(XMASKED);
    maskEl.setDisplayed(true);
    if (typeof msg === 'string') {
      maskMsg.setDisplayed(true);
      maskMsg.center(me);
    } else {
      maskMsg.setDisplayed(false);
    }
    if (dom === DOC.body) {
      maskEl.addCls('x-mask-fixed');
    }
    me.saveTabbableState({skipSelf:dom === DOC.body});
    if (Ext.isIE9m && dom !== DOC.body && me.isStyle('height', 'auto')) {
      maskEl.setSize(undefined, elHeight || me.getHeight());
    }
    return maskEl;
  }, puff:function(obj) {
    var me = this, dom = me.dom, animFly = new Ext.dom.Fly, beforeAnim, box = me.getBox(), originalStyles = me.getStyle(['width', 'height', 'left', 'right', 'top', 'bottom', 'position', 'z-index', 'font-size', 'opacity'], true);
    obj = Ext.applyIf(obj || {}, {easing:'ease-out', duration:500, useDisplay:false});
    beforeAnim = function() {
      animFly.attach(dom);
      animFly.clearOpacity();
      animFly.show();
      this.to = {width:box.width * 2, height:box.height * 2, x:box.x - box.width / 2, y:box.y - box.height / 2, opacity:0, fontSize:'200%'};
      this.on('afteranimate', function() {
        animFly.attach(dom);
        if (obj.useDisplay) {
          animFly.setDisplayed(false);
        } else {
          animFly.hide();
        }
        animFly.setStyle(originalStyles);
        Ext.callback(obj.callback, obj.scope);
      });
    };
    me.animate({duration:obj.duration, easing:obj.easing, listeners:{beforeanimate:{fn:beforeAnim}}});
    return me;
  }, setCapture:function() {
    var dom = this.dom;
    if (Ext.isIE9m && dom.setCapture) {
      dom.setCapture();
    }
  }, setHeight:function(height, animate) {
    var me = this;
    if (!animate || !me.anim) {
      arguments.callee.$previous.apply(this, arguments);
    } else {
      if (!Ext.isObject(animate)) {
        animate = {};
      }
      me.animate(Ext.applyIf({to:{height:height}}, animate));
    }
    return me;
  }, setHorizontal:function() {
    var me = this, cls = me.verticalCls;
    delete me.vertical;
    if (cls) {
      delete me.verticalCls;
      me.removeCls(cls);
    }
    delete me.setWidth;
    delete me.setHeight;
    if (!Ext.isIE8) {
      delete me.getWidth;
      delete me.getHeight;
    }
    delete me.styleHooks;
  }, updateText:function(text) {
    var me = this, dom, textNode;
    if (dom) {
      textNode = dom.firstChild;
      if (!textNode || (textNode.nodeType !== 3 || textNode.nextSibling)) {
        textNode = DOC.createTextNode();
        me.empty();
        dom.appendChild(textNode);
      }
      if (text) {
        textNode.data = text;
      }
    }
  }, setHtml:function(html, loadScripts, callback, scope) {
    var me = this, id, dom, interval;
    if (!me.dom) {
      return me;
    }
    html = html || '';
    dom = me.dom;
    if (loadScripts !== true) {
      dom.innerHTML = html;
      Ext.callback(callback, me);
      return me;
    }
    id = Ext.id();
    html += '\x3cspan id\x3d"' + id + '" role\x3d"presentation"\x3e\x3c/span\x3e';
    interval = Ext.interval(function() {
      var hd, match, attrs, srcMatch, typeMatch, el, s;
      if (!(el = DOC.getElementById(id))) {
        return false;
      }
      Ext.uninterval(interval);
      Ext.removeNode(el);
      hd = Ext.getHead().dom;
      while (match = scriptTagRe.exec(html)) {
        attrs = match[1];
        srcMatch = attrs ? attrs.match(srcRe) : false;
        if (srcMatch && srcMatch[2]) {
          s = DOC.createElement('script');
          s.src = srcMatch[2];
          typeMatch = attrs.match(typeRe);
          if (typeMatch && typeMatch[2]) {
            s.type = typeMatch[2];
          }
          hd.appendChild(s);
        } else {
          if (match[2] && match[2].length > 0) {
            if (scope) {
              Ext.functionFactory(match[2]).call(scope);
            } else {
              Ext.globalEval(match[2]);
            }
          }
        }
      }
      Ext.callback(callback, scope || me);
    }, 20);
    dom.innerHTML = html.replace(replaceScriptTagRe, '');
    return me;
  }, setOpacity:function(opacity, animate) {
    var me = this;
    if (!me.dom) {
      return me;
    }
    if (!animate || !me.anim) {
      me.setStyle('opacity', opacity);
    } else {
      if (typeof animate != 'object') {
        animate = {duration:350, easing:'ease-in'};
      }
      me.animate(Ext.applyIf({to:{opacity:opacity}}, animate));
    }
    return me;
  }, setPositioning:function(pc) {
    return this.setStyle(pc);
  }, setVertical:function(angle, cls) {
    var me = this, proto = Element.prototype;
    me.vertical = true;
    if (cls) {
      me.addCls(me.verticalCls = cls);
    }
    me.setWidth = proto.setHeight;
    me.setHeight = proto.setWidth;
    if (!Ext.isIE8) {
      me.getWidth = proto.getHeight;
      me.getHeight = proto.getWidth;
    }
    me.styleHooks = angle === 270 ? proto.verticalStyleHooks270 : proto.verticalStyleHooks90;
  }, setSize:function(width, height, animate) {
    var me = this;
    if (Ext.isObject(width)) {
      animate = height;
      height = width.height;
      width = width.width;
    }
    if (!animate || !me.anim) {
      me.dom.style.width = Element.addUnits(width);
      me.dom.style.height = Element.addUnits(height);
      if (me.shadow || me.shim) {
        me.syncUnderlays();
      }
    } else {
      if (animate === true) {
        animate = {};
      }
      me.animate(Ext.applyIf({to:{width:width, height:height}}, animate));
    }
    return me;
  }, setVisible:function(visible, animate) {
    var me = this, dom = me.dom, animFly, visMode = getVisMode(me);
    if (typeof animate === 'string') {
      switch(animate) {
        case DISPLAY:
          visMode = Element.DISPLAY;
          break;
        case VISIBILITY:
          visMode = Element.VISIBILITY;
          break;
        case OFFSETS:
          visMode = Element.OFFSETS;
          break;
        case CLIP:
          visMode = Element.CLIP;
          break;
      }
      me.setVisibilityMode(visMode);
      animate = false;
    }
    if (!animate || !me.anim) {
      if (visMode === Element.DISPLAY) {
        return me.setDisplayed(visible);
      } else {
        if (visMode === Element.OFFSETS) {
          me[visible ? 'removeCls' : 'addCls'](OFFSETCLASS);
        } else {
          if (visMode === Element.CLIP) {
            me[visible ? 'removeCls' : 'addCls'](CLIPCLASS);
          } else {
            if (visMode === Element.VISIBILITY) {
              me.fixDisplay();
              dom.style.visibility = visible ? '' : HIDDEN;
            }
          }
        }
      }
    } else {
      if (visible) {
        me.setOpacity(0.01);
        me.setVisible(true);
      }
      if (!Ext.isObject(animate)) {
        animate = {duration:350, easing:'ease-in'};
      }
      animFly = new Ext.dom.Fly, me.animate(Ext.applyIf({callback:function() {
        if (!visible) {
          animFly.attach(dom).setVisible(false).setOpacity(1);
        }
      }, to:{opacity:visible ? 1 : 0}}, animate));
    }
    me.getData()[ISVISIBLE] = visible;
    if (me.shadow || me.shim) {
      me.setUnderlaysVisible(visible);
    }
    return me;
  }, setWidth:function(width, animate) {
    var me = this;
    if (!animate || !me.anim) {
      arguments.callee.$previous.apply(this, arguments);
    } else {
      if (!Ext.isObject(animate)) {
        animate = {};
      }
      me.animate(Ext.applyIf({to:{width:width}}, animate));
    }
    return me;
  }, setX:function(x, animate) {
    return this.setXY([x, this.getY()], animate);
  }, setXY:function(xy, animate) {
    var me = this;
    if (!animate || !me.anim) {
      arguments.callee.$previous.call(this, xy);
    } else {
      if (!Ext.isObject(animate)) {
        animate = {};
      }
      me.animate(Ext.applyIf({to:{x:xy[0], y:xy[1]}}, animate));
    }
    return this;
  }, setY:function(y, animate) {
    return this.setXY([this.getX(), y], animate);
  }, show:function(animate) {
    if (typeof animate === 'string') {
      this.setVisible(true, animate);
      return this;
    }
    this.setVisible(true, this.anim(animate));
    return this;
  }, slideIn:function(anchor, options, slideOut) {
    var me = this, dom = me.dom, elStyle = dom.style, animFly = new Ext.dom.Fly, beforeAnim, wrapAnim, restoreScroll, wrapDomParentNode;
    anchor = anchor || 't';
    options = options || {};
    beforeAnim = function() {
      animFly.attach(dom);
      var animScope = this, listeners = options.listeners, box, originalStyles, anim, wrap;
      if (!slideOut) {
        animFly.fixDisplay();
      }
      box = animFly.getBox();
      if ((anchor === 't' || anchor === 'b') && box.height === 0) {
        box.height = dom.scrollHeight;
      } else {
        if ((anchor === 'l' || anchor === 'r') && box.width === 0) {
          box.width = dom.scrollWidth;
        }
      }
      originalStyles = animFly.getStyle(['width', 'height', 'left', 'right', 'top', 'bottom', 'position', 'z-index'], true);
      animFly.setSize(box.width, box.height);
      if (options.preserveScroll) {
        restoreScroll = animFly.cacheScrollValues();
      }
      wrap = animFly.wrap({role:'presentation', id:Ext.id() + '-anim-wrap-for-' + dom.id, style:{visibility:slideOut ? 'visible' : 'hidden'}});
      wrapDomParentNode = wrap.dom.parentNode;
      wrap.setPositioning(animFly.getPositioning());
      if (wrap.isStyle('position', 'static')) {
        wrap.position('relative');
      }
      animFly.clearPositioning('auto');
      wrap.clip();
      if (restoreScroll) {
        restoreScroll();
      }
      animFly.setStyle({visibility:'', position:'absolute'});
      if (slideOut) {
        wrap.setSize(box.width, box.height);
      }
      switch(anchor) {
        case 't':
          anim = {from:{width:box.width + 'px', height:'0px'}, to:{width:box.width + 'px', height:box.height + 'px'}};
          elStyle.bottom = '0px';
          break;
        case 'l':
          anim = {from:{width:'0px', height:box.height + 'px'}, to:{width:box.width + 'px', height:box.height + 'px'}};
          me.anchorAnimX(anchor);
          break;
        case 'r':
          anim = {from:{x:box.x + box.width, width:'0px', height:box.height + 'px'}, to:{x:box.x, width:box.width + 'px', height:box.height + 'px'}};
          me.anchorAnimX(anchor);
          break;
        case 'b':
          anim = {from:{y:box.y + box.height, width:box.width + 'px', height:'0px'}, to:{y:box.y, width:box.width + 'px', height:box.height + 'px'}};
          break;
        case 'tl':
          anim = {from:{x:box.x, y:box.y, width:'0px', height:'0px'}, to:{width:box.width + 'px', height:box.height + 'px'}};
          elStyle.bottom = '0px';
          me.anchorAnimX('l');
          break;
        case 'bl':
          anim = {from:{y:box.y + box.height, width:'0px', height:'0px'}, to:{y:box.y, width:box.width + 'px', height:box.height + 'px'}};
          me.anchorAnimX('l');
          break;
        case 'br':
          anim = {from:{x:box.x + box.width, y:box.y + box.height, width:'0px', height:'0px'}, to:{x:box.x, y:box.y, width:box.width + 'px', height:box.height + 'px'}};
          me.anchorAnimX('r');
          break;
        case 'tr':
          anim = {from:{x:box.x + box.width, width:'0px', height:'0px'}, to:{x:box.x, width:box.width + 'px', height:box.height + 'px'}};
          elStyle.bottom = '0px';
          me.anchorAnimX('r');
          break;
      }
      wrap.show();
      wrapAnim = Ext.apply({}, options);
      delete wrapAnim.listeners;
      wrapAnim = new Ext.fx.Anim(Ext.applyIf(wrapAnim, {target:wrap, duration:500, easing:'ease-out', from:slideOut ? anim.to : anim.from, to:slideOut ? anim.from : anim.to}));
      wrapAnim.on('afteranimate', function() {
        animFly.attach(dom);
        animFly.setStyle(originalStyles);
        if (slideOut) {
          if (options.useDisplay) {
            animFly.setDisplayed(false);
          } else {
            animFly.hide();
          }
        }
        if (wrap.dom) {
          if (wrap.dom.parentNode) {
            wrap.dom.parentNode.insertBefore(dom, wrap.dom);
          } else {
            wrapDomParentNode.appendChild(dom);
          }
          wrap.destroy();
        }
        if (restoreScroll) {
          restoreScroll();
        }
        animScope.end();
      });
      if (listeners) {
        wrapAnim.on(listeners);
      }
    };
    me.animate({duration:options.duration ? Math.max(options.duration, 500) * 2 : 1000, listeners:{beforeanimate:beforeAnim}});
    return me;
  }, slideOut:function(anchor, options) {
    return this.slideIn(anchor, options, true);
  }, switchOff:function(options) {
    var me = this, dom = me.dom, animFly = new Ext.dom.Fly, beforeAnim;
    options = Ext.applyIf(options || {}, {easing:'ease-in', duration:500, remove:false, useDisplay:false});
    beforeAnim = function() {
      animFly.attach(dom);
      var animScope = this, size = animFly.getSize(), xy = animFly.getXY(), keyframe, position;
      animFly.clearOpacity();
      animFly.clip();
      position = animFly.getPositioning();
      keyframe = new Ext.fx.Animator({target:dom, duration:options.duration, easing:options.easing, keyframes:{33:{opacity:0.3}, 66:{height:1, y:xy[1] + size.height / 2}, 100:{width:1, x:xy[0] + size.width / 2}}});
      keyframe.on('afteranimate', function() {
        animFly.attach(dom);
        if (options.useDisplay) {
          animFly.setDisplayed(false);
        } else {
          animFly.hide();
        }
        animFly.clearOpacity();
        animFly.setPositioning(position);
        animFly.setSize(size);
        animScope.end();
      });
    };
    me.animate({duration:Math.max(options.duration, 500) * 2, listeners:{beforeanimate:{fn:beforeAnim}}, callback:options.callback, scope:options.scope});
    return me;
  }, syncContent:function(source) {
    source = Ext.getDom(source);
    var sourceNodes = source.childNodes, sourceLen = sourceNodes.length, dest = this.dom, destNodes = dest.childNodes, destLen = destNodes.length, i, destNode, sourceNode, sourceStyle, nodeType, newAttrs, attLen, attName, value, elData = dest._extData;
    if (!syncContentFly) {
      syncContentFly = new Ext.dom.Fly;
    }
    newAttrs = source.attributes;
    attLen = newAttrs.length;
    for (i = 0; i < attLen; i++) {
      attName = newAttrs[i].name;
      value = newAttrs[i].value;
      if (attName !== 'id' && dest.getAttribute(attName) !== value) {
        dest.setAttribute(attName, newAttrs[i].value);
      }
    }
    if (elData) {
      elData.isSynchronized = false;
    }
    if (sourceLen !== destLen) {
      dest.innerHTML = source.innerHTML;
      return;
    }
    for (i = 0; i < sourceLen; i++) {
      sourceNode = sourceNodes[i];
      destNode = destNodes[i];
      nodeType = sourceNode.nodeType;
      sourceStyle = sourceNode.style;
      if (nodeType !== destNode.nodeType || nodeType === 1 && sourceNode.tagName !== destNode.tagName) {
        dest.innerHTML = source.innerHTML;
        return;
      }
      if (!sourceStyle) {
        destNode.data = sourceNode.data;
      } else {
        if (sourceNode.id && destNode.id !== sourceNode.id) {
          destNode.id = sourceNode.id;
        }
        destNode.style.cssText = sourceStyle.cssText;
        destNode.className = sourceNode.className;
        syncContentFly.attach(destNode).syncContent(sourceNode);
      }
    }
  }, toggle:function(animate) {
    var me = this;
    me.setVisible(!me.isVisible(), me.anim(animate));
    return me;
  }, unmask:function() {
    var me = this, data = me.getData(), maskEl = data.maskEl, style;
    if (maskEl) {
      style = maskEl.dom.style;
      if (style.clearExpression) {
        style.clearExpression('width');
        style.clearExpression('height');
      }
      if (maskEl) {
        maskEl.destroy();
        delete data.maskEl;
      }
      me.removeCls([XMASKED, XMASKEDRELATIVE]);
    }
    me.restoreTabbableState(me.dom === DOC.body);
  }, unclip:function() {
    var me = this, data = me.getData(), clip;
    if (data[ISCLIPPED]) {
      data[ISCLIPPED] = false;
      clip = data[ORIGINALCLIP];
      if (clip.o) {
        me.setStyle(OVERFLOW, clip.o);
      }
      if (clip.x) {
        me.setStyle(OVERFLOWX, clip.x);
      }
      if (clip.y) {
        me.setStyle(OVERFLOWY, clip.y);
      }
    }
    return me;
  }, translate:function(x, y, z) {
    if (Ext.supports.CssTransforms && !Ext.isIE9m) {
      arguments.callee.$previous.apply(this, arguments);
    } else {
      if (x != null) {
        this.dom.style.left = x + 'px';
      }
      if (y != null) {
        this.dom.style.top = y + 'px';
      }
    }
  }, deprecated:{'4.0':{methods:{pause:function(ms) {
    var me = this;
    Ext.fx.Manager.setFxDefaults(me.id, {delay:ms});
    return me;
  }, scale:function(width, height, options) {
    this.animate(Ext.apply({}, options, {width:width, height:height}));
    return this;
  }, shift:function(options) {
    this.animate(options);
    return this;
  }}}, '4.2':{methods:{moveTo:function(x, y, animate) {
    return this.setXY([x, y], animate);
  }, setBounds:function(x, y, width, height, animate) {
    return this.setBox({x:x, y:y, width:width, height:height}, animate);
  }, setLeftTop:function(left, top) {
    var me = this, style = me.dom.style;
    style.left = Element.addUnits(left);
    style.top = Element.addUnits(top);
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setLocation:function(x, y, animate) {
    return this.setXY([x, y], animate);
  }}}, '5.0':{methods:{getAttributeNS:function(namespace, name) {
    return this.getAttribute(name, namespace);
  }, getCenterXY:function() {
    return this.getAlignToXY(DOC, 'c-c');
  }, getComputedHeight:function() {
    return Math.max(this.dom.offsetHeight, this.dom.clientHeight) || parseFloat(this.getStyle(HEIGHT)) || 0;
  }, getComputedWidth:function() {
    return Math.max(this.dom.offsetWidth, this.dom.clientWidth) || parseFloat(this.getStyle(WIDTH)) || 0;
  }, getStyleSize:function() {
    var me = this, d = this.dom, isDoc = d === DOC || d === DOC.body, s, w, h;
    if (isDoc) {
      return {width:Element.getViewportWidth(), height:Element.getViewportHeight()};
    }
    s = me.getStyle(['height', 'width'], true);
    if (s.width && s.width !== 'auto') {
      w = parseFloat(s.width);
    }
    if (s.height && s.height !== 'auto') {
      h = parseFloat(s.height);
    }
    return {width:w || me.getWidth(true), height:h || me.getHeight(true)};
  }, isBorderBox:function() {
    return true;
  }, isDisplayed:function() {
    return !this.isStyle('display', 'none');
  }, focusable:'isFocusable'}}}};
}(), function() {
  var Element = Ext.dom.Element, proto = Element.prototype, useDocForId = !Ext.isIE8, DOC = document, view = DOC.defaultView, opacityRe = /alpha\(opacity=(.*)\)/i, trimRe = /^\s+|\s+$/g, styleHooks = proto.styleHooks, supports = Ext.supports, verticalStyleHooks90, verticalStyleHooks270, edges, k, edge, borderWidth, getBorderWidth;
  proto._init(Element);
  delete proto._init;
  Ext.plainTableCls = 'x-table-plain';
  Ext.plainListCls = 'x-list-plain';
  if (Ext.CompositeElementLite) {
    Ext.CompositeElementLite.importElementMethods();
  }
  if (!supports.Opacity && Ext.isIE) {
    Ext.apply(styleHooks.opacity, {get:function(dom) {
      var filter = dom.style.filter, match, opacity;
      if (filter.match) {
        match = filter.match(opacityRe);
        if (match) {
          opacity = parseFloat(match[1]);
          if (!isNaN(opacity)) {
            return opacity ? opacity / 100 : 0;
          }
        }
      }
      return 1;
    }, set:function(dom, value) {
      var style = dom.style, val = style.filter.replace(opacityRe, '').replace(trimRe, '');
      style.zoom = 1;
      if (typeof value === 'number' && value >= 0 && value < 1) {
        value *= 100;
        style.filter = val + (val.length ? ' ' : '') + 'alpha(opacity\x3d' + value + ')';
      } else {
        style.filter = val;
      }
    }});
  }
  if (!supports.matchesSelector) {
    var simpleSelectorRe = /^([a-z]+|\*)?(?:\.([a-z][a-z\-_0-9]*))?$/i, dashRe = /\-/g, fragment, classMatcher = function(tag, cls) {
      var classRe = new RegExp('(?:^|\\s+)' + cls.replace(dashRe, '\\-') + '(?:\\s+|$)');
      if (tag && tag !== '*') {
        tag = tag.toUpperCase();
        return function(el) {
          return el.tagName === tag && classRe.test(el.className);
        };
      }
      return function(el) {
        return classRe.test(el.className);
      };
    }, tagMatcher = function(tag) {
      tag = tag.toUpperCase();
      return function(el) {
        return el.tagName === tag;
      };
    }, cache = {};
    proto.matcherCache = cache;
    proto.is = function(selector) {
      if (!selector) {
        return true;
      }
      var dom = this.dom, cls, match, testFn, root, isOrphan, is, tag;
      if (dom.nodeType !== 1) {
        return false;
      }
      if (!(testFn = Ext.isFunction(selector) ? selector : cache[selector])) {
        if (!(match = selector.match(simpleSelectorRe))) {
          root = dom.parentNode;
          if (!root) {
            isOrphan = true;
            root = fragment || (fragment = DOC.createDocumentFragment());
            fragment.appendChild(dom);
          }
          is = Ext.Array.indexOf(Ext.fly(root, '_is').query(selector), dom) !== -1;
          if (isOrphan) {
            fragment.removeChild(dom);
          }
          return is;
        }
        tag = match[1];
        cls = match[2];
        cache[selector] = testFn = cls ? classMatcher(tag, cls) : tagMatcher(tag);
      }
      return testFn(dom);
    };
  }
  if (!view || !view.getComputedStyle) {
    proto.getStyle = function(property, inline) {
      var me = this, dom = me.dom, multiple = typeof property !== 'string', prop = property, props = prop, len = 1, isInline = inline, styleHooks = me.styleHooks, camel, domStyle, values, hook, out, style, i;
      if (multiple) {
        values = {};
        prop = props[0];
        i = 0;
        if (!(len = props.length)) {
          return values;
        }
      }
      if (!dom || dom.documentElement) {
        return values || '';
      }
      domStyle = dom.style;
      if (inline) {
        style = domStyle;
      } else {
        style = dom.currentStyle;
        if (!style) {
          isInline = true;
          style = domStyle;
        }
      }
      do {
        hook = styleHooks[prop];
        if (!hook) {
          styleHooks[prop] = hook = {name:Element.normalize(prop)};
        }
        if (hook.get) {
          out = hook.get(dom, me, isInline, style);
        } else {
          camel = hook.name;
          out = style[camel];
        }
        if (!multiple) {
          return out;
        }
        values[prop] = out;
        prop = props[++i];
      } while (i < len);
      return values;
    };
  }
  if (Ext.isIE8) {
    getBorderWidth = function(dom, el, inline, style) {
      if (style[this.styleName] === 'none') {
        return '0px';
      }
      return style[this.name];
    };
    edges = ['Top', 'Right', 'Bottom', 'Left'];
    k = edges.length;
    while (k--) {
      edge = edges[k];
      borderWidth = 'border' + edge + 'Width';
      styleHooks['border-' + edge.toLowerCase() + '-width'] = styleHooks[borderWidth] = {name:borderWidth, styleName:'border' + edge + 'Style', get:getBorderWidth};
    }
    var syncRepaintCls = 'x-sync-repaint';
    proto.syncRepaint = function() {
      this.addCls(syncRepaintCls);
      this.getWidth();
      this.removeCls(syncRepaintCls);
    };
  }
  if (Ext.isIE10m) {
    Ext.override(Element, {focus:function(defer, dom) {
      var me = this, ex;
      dom = dom || me.dom;
      if (me.deferredFocusTimer) {
        Ext.undefer(me.deferredFocusTimer);
      }
      me.deferredFocusTimer = null;
      if (Number(defer)) {
        me.deferredFocusTimer = Ext.defer(me.focus, defer, me, [null, dom]);
      } else {
        Ext.GlobalEvents.fireEvent('beforefocus', dom);
        if (dom && (dom.tagName === 'INPUT' || dom.tagname === 'TEXTAREA')) {
          Ext.synchronouslyFocusing = document.activeElement;
        }
        try {
          dom.focus();
        } catch (xcpt) {
          ex = xcpt;
        }
        if (Ext.synchronouslyFocusing && document.activeElement !== dom && !ex) {
          dom.focus();
        }
        Ext.synchronouslyFocusing = null;
      }
      return me;
    }});
  }
  Ext.apply(Ext, {enableGarbageCollector:true, isBorderBox:true, useShims:false, getElementById:function(id) {
    var el = DOC.getElementById(id), detachedBodyEl;
    if (!el && (detachedBodyEl = Ext.detachedBodyEl)) {
      el = detachedBodyEl.dom.querySelector(Ext.makeIdSelector(id));
    }
    return el;
  }, addBehaviors:function(obj) {
    if (!Ext.isReady) {
      Ext.onInternalReady(function() {
        Ext.addBehaviors(obj);
      });
    } else {
      var cache = {}, parts, b, s;
      for (b in obj) {
        if ((parts = b.split('@'))[1]) {
          s = parts[0];
          if (!cache[s]) {
            cache[s] = Ext.fly(document).select(s, true);
          }
          cache[s].on(parts[1], obj[b]);
        }
      }
      cache = null;
    }
  }});
  if (Ext.isIE9m) {
    Ext.getElementById = function(id) {
      var el = DOC.getElementById(id), detachedBodyEl;
      if (!el && (detachedBodyEl = Ext.detachedBodyEl)) {
        el = detachedBodyEl.dom.all[id];
      }
      return el;
    };
    proto.getById = function(id, asDom) {
      var dom = this.dom, ret = null, entry, el;
      if (dom) {
        el = useDocForId && DOC.getElementById(id) || dom.all[id];
        if (el) {
          if (asDom) {
            ret = el;
          } else {
            entry = Ext.cache[id];
            if (entry) {
              if (entry.skipGarbageCollection || !Ext.isGarbage(entry.dom)) {
                ret = entry;
              } else {
                entry.destroy();
              }
            }
            ret = ret || new Ext.Element(el);
          }
        }
      }
      return ret;
    };
  } else {
    if (!DOC.querySelector) {
      Ext.getDetachedBody = Ext.getBody;
      Ext.getElementById = function(id) {
        return DOC.getElementById(id);
      };
      proto.getById = function(id, asDom) {
        var dom = DOC.getElementById(id);
        return asDom ? dom : dom ? Ext.get(dom) : null;
      };
    }
  }
  if (Ext.isIE && !(Ext.isIE9p && DOC.documentMode >= 9)) {
    proto.getAttribute = function(name, ns) {
      var d = this.dom, type;
      if (ns) {
        type = typeof d[ns + ':' + name];
        if (type !== 'undefined' && type !== 'unknown') {
          return d[ns + ':' + name] || null;
        }
        return null;
      }
      if (name === 'for') {
        name = 'htmlFor';
      }
      return d[name] || null;
    };
  }
  Ext.onInternalReady(function() {
    var transparentRe = /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i, origSetWidth = proto.setWidth, origSetHeight = proto.setHeight, origSetSize = proto.setSize, origUnselectable = proto.unselectable, pxRe = /^\d+(?:\.\d*)?px$/i, colorStyles, i, name, camel;
    if (supports.FixedTableWidthBug) {
      styleHooks.width = {name:'width', set:function(dom, value, el) {
        var style = dom.style, needsFix = el._needsTableWidthFix, origDisplay = style.display;
        if (needsFix) {
          style.display = 'none';
        }
        style.width = value;
        if (needsFix) {
          dom.scrollWidth;
          style.display = origDisplay;
        }
      }};
      proto.setWidth = function(width, animate) {
        var me = this, dom = me.dom, style = dom.style, needsFix = me._needsTableWidthFix, origDisplay = style.display;
        if (needsFix && !animate) {
          style.display = 'none';
        }
        origSetWidth.call(me, width, animate);
        if (needsFix && !animate) {
          dom.scrollWidth;
          style.display = origDisplay;
        }
        return me;
      };
      proto.setSize = function(width, height, animate) {
        var me = this, dom = me.dom, style = dom.style, needsFix = me._needsTableWidthFix, origDisplay = style.display;
        if (needsFix && !animate) {
          style.display = 'none';
        }
        origSetSize.call(me, width, height, animate);
        if (needsFix && !animate) {
          dom.scrollWidth;
          style.display = origDisplay;
        }
        return me;
      };
    }
    if (Ext.isIE8) {
      styleHooks.height = {name:'height', set:function(dom, value, el) {
        var component = el.component, frameInfo, frameBodyStyle;
        if (component && component._syncFrameHeight && el === component.el) {
          frameBodyStyle = component.frameBody.dom.style;
          if (pxRe.test(value)) {
            frameInfo = component.getFrameInfo();
            if (frameInfo) {
              frameBodyStyle.height = parseInt(value, 10) - frameInfo.height + 'px';
            }
          } else {
            if (!value || value === 'auto') {
              frameBodyStyle.height = '';
            }
          }
        }
        dom.style.height = value;
      }};
      proto.setHeight = function(height, animate) {
        var component = this.component, frameInfo, frameBodyStyle;
        if (component && component._syncFrameHeight && this === component.el) {
          frameBodyStyle = component.frameBody.dom.style;
          if (!height || height === 'auto') {
            frameBodyStyle.height = '';
          } else {
            frameInfo = component.getFrameInfo();
            if (frameInfo) {
              frameBodyStyle.height = height - frameInfo.height + 'px';
            }
          }
        }
        return origSetHeight.call(this, height, animate);
      };
      proto.setSize = function(width, height, animate) {
        var component = this.component, frameInfo, frameBodyStyle;
        if (component && component._syncFrameHeight && this === component.el) {
          frameBodyStyle = component.frameBody.dom.style;
          if (!height || height === 'auto') {
            frameBodyStyle.height = '';
          } else {
            frameInfo = component.getFrameInfo();
            if (frameInfo) {
              frameBodyStyle.height = height - frameInfo.height + 'px';
            }
          }
        }
        return origSetSize.call(this, width, height, animate);
      };
      proto.setText = function(text) {
        var dom = this.dom;
        if (!(dom.childNodes.length === 1 && dom.firstChild.nodeType === 3)) {
          while (dom.lastChild && dom.lastChild.nodeType !== 3) {
            dom.removeChild(dom.lastChild);
          }
          dom.appendChild(document.createTextNode());
        }
        dom.firstChild.data = text;
      };
      proto.unselectable = function() {
        origUnselectable.call(this);
        this.dom.onselectstart = function() {
          return false;
        };
      };
    }
    function fixTransparent(dom, el, inline, style) {
      var value = style[this.name] || '';
      return transparentRe.test(value) ? 'transparent' : value;
    }
    function makeSelectionRestoreFn(activeEl, start, end) {
      return function() {
        activeEl.selectionStart = start;
        activeEl.selectionEnd = end;
      };
    }
    function getRightMarginFixCleaner(target) {
      var hasInputBug = supports.DisplayChangeInputSelectionBug, hasTextAreaBug = supports.DisplayChangeTextAreaSelectionBug, activeEl, tag, start, end;
      if (hasInputBug || hasTextAreaBug) {
        activeEl = Element.getActiveElement();
        tag = activeEl && activeEl.tagName;
        if (hasTextAreaBug && tag === 'TEXTAREA' || hasInputBug && tag === 'INPUT' && activeEl.type === 'text') {
          if (Ext.fly(target).isAncestor(activeEl)) {
            start = activeEl.selectionStart;
            end = activeEl.selectionEnd;
            if (Ext.isNumber(start) && Ext.isNumber(end)) {
              return makeSelectionRestoreFn(activeEl, start, end);
            }
          }
        }
      }
      return Ext.emptyFn;
    }
    function fixRightMargin(dom, el, inline, style) {
      var result = style.marginRight, domStyle, display;
      if (result !== '0px') {
        domStyle = dom.style;
        display = domStyle.display;
        domStyle.display = 'inline-block';
        result = (inline ? style : dom.ownerDocument.defaultView.getComputedStyle(dom, null)).marginRight;
        domStyle.display = display;
      }
      return result;
    }
    function fixRightMarginAndInputFocus(dom, el, inline, style) {
      var result = style.marginRight, domStyle, cleaner, display;
      if (result !== '0px') {
        domStyle = dom.style;
        cleaner = getRightMarginFixCleaner(dom);
        display = domStyle.display;
        domStyle.display = 'inline-block';
        result = (inline ? style : dom.ownerDocument.defaultView.getComputedStyle(dom, '')).marginRight;
        domStyle.display = display;
        cleaner();
      }
      return result;
    }
    if (!supports.RightMargin) {
      styleHooks.marginRight = styleHooks['margin-right'] = {name:'marginRight', get:supports.DisplayChangeInputSelectionBug || supports.DisplayChangeTextAreaSelectionBug ? fixRightMarginAndInputFocus : fixRightMargin};
    }
    if (!supports.TransparentColor) {
      colorStyles = ['background-color', 'border-color', 'color', 'outline-color'];
      for (i = colorStyles.length; i--;) {
        name = colorStyles[i];
        camel = Element.normalize(name);
        styleHooks[name] = styleHooks[camel] = {name:camel, get:fixTransparent};
      }
    }
    proto.verticalStyleHooks90 = verticalStyleHooks90 = Ext.Object.chain(styleHooks);
    proto.verticalStyleHooks270 = verticalStyleHooks270 = Ext.Object.chain(styleHooks);
    verticalStyleHooks90.width = styleHooks.height || {name:'height'};
    verticalStyleHooks90.height = styleHooks.width || {name:'width'};
    verticalStyleHooks90['margin-top'] = {name:'marginLeft'};
    verticalStyleHooks90['margin-right'] = {name:'marginTop'};
    verticalStyleHooks90['margin-bottom'] = {name:'marginRight'};
    verticalStyleHooks90['margin-left'] = {name:'marginBottom'};
    verticalStyleHooks90['padding-top'] = {name:'paddingLeft'};
    verticalStyleHooks90['padding-right'] = {name:'paddingTop'};
    verticalStyleHooks90['padding-bottom'] = {name:'paddingRight'};
    verticalStyleHooks90['padding-left'] = {name:'paddingBottom'};
    verticalStyleHooks90['border-top'] = {name:'borderLeft'};
    verticalStyleHooks90['border-right'] = {name:'borderTop'};
    verticalStyleHooks90['border-bottom'] = {name:'borderRight'};
    verticalStyleHooks90['border-left'] = {name:'borderBottom'};
    verticalStyleHooks270.width = styleHooks.height || {name:'height'};
    verticalStyleHooks270.height = styleHooks.width || {name:'width'};
    verticalStyleHooks270['margin-top'] = {name:'marginRight'};
    verticalStyleHooks270['margin-right'] = {name:'marginBottom'};
    verticalStyleHooks270['margin-bottom'] = {name:'marginLeft'};
    verticalStyleHooks270['margin-left'] = {name:'marginTop'};
    verticalStyleHooks270['padding-top'] = {name:'paddingRight'};
    verticalStyleHooks270['padding-right'] = {name:'paddingBottom'};
    verticalStyleHooks270['padding-bottom'] = {name:'paddingLeft'};
    verticalStyleHooks270['padding-left'] = {name:'paddingTop'};
    verticalStyleHooks270['border-top'] = {name:'borderRight'};
    verticalStyleHooks270['border-right'] = {name:'borderBottom'};
    verticalStyleHooks270['border-bottom'] = {name:'borderLeft'};
    verticalStyleHooks270['border-left'] = {name:'borderTop'};
    if (!Ext.scopeCss) {
      Ext.getBody().addCls('x-body');
    }
  }, null, {priority:1500});
});
Ext.cmd.derive('Sch.util.Patch', Ext.Base, {target:null, minVersion:null, maxVersion:null, reportUrl:null, obsoleteTestName:null, description:null, applyFn:null, ieOnly:false, macOnly:false, overrides:null, onClassExtended:function(cls, data) {
  if (Sch.disableOverrides) {
    return;
  }
  if (data.ieOnly && !Ext.isIE) {
    return;
  }
  if (data.macOnly && !Ext.isMac) {
    return;
  }
  if ((!data.minVersion || Ext.versions.extjs.equals(data.minVersion) || Ext.versions.extjs.isGreaterThan(data.minVersion)) && (!data.maxVersion || Ext.versions.extjs.equals(data.maxVersion) || Ext.versions.extjs.isLessThan(data.maxVersion))) {
    Ext.require(data.target, function() {
      if (data.applyFn) {
        data.applyFn();
      } else {
        if (data.overrides) {
          Ext.ClassManager.get(data.target).override(data.overrides);
        }
      }
    });
  }
}}, 0, 0, 0, 0, 0, 0, [Sch.util, 'Patch'], 0);
Ext.cmd.derive('Sch.patches.EXTJS_23846', Sch.util.Patch, {target:['Ext.dom.Element', 'Ext.event.publisher.Gesture'], maxVersion:'6.2.2', applyFn:function() {
  if (Ext.firefoxVersion < 51) {
    return;
  }
  Ext.define('EXTJS_23846.Element', {override:'Ext.dom.Element'}, function(Element) {
    var supports = Ext.supports, proto = Element.prototype, eventMap = proto.eventMap, additiveEvents = proto.additiveEvents;
    if (Ext.os.is.Desktop && supports.TouchEvents && !supports.PointerEvents) {
      eventMap.touchstart = 'mousedown';
      eventMap.touchmove = 'mousemove';
      eventMap.touchend = 'mouseup';
      eventMap.touchcancel = 'mouseup';
      additiveEvents.mousedown = 'mousedown';
      additiveEvents.mousemove = 'mousemove';
      additiveEvents.mouseup = 'mouseup';
      additiveEvents.touchstart = 'touchstart';
      additiveEvents.touchmove = 'touchmove';
      additiveEvents.touchend = 'touchend';
      additiveEvents.touchcancel = 'touchcancel';
      additiveEvents.pointerdown = 'mousedown';
      additiveEvents.pointermove = 'mousemove';
      additiveEvents.pointerup = 'mouseup';
      additiveEvents.pointercancel = 'mouseup';
    }
  });
  Ext.define('EXTJS_23846.Gesture', {override:'Ext.event.publisher.Gesture'}, function(Gesture) {
    var me = Gesture.instance;
    if (Ext.supports.TouchEvents && !Ext.isWebKit && Ext.os.is.Desktop) {
      me.handledDomEvents.push('mousedown', 'mousemove', 'mouseup');
      me.registerEvents();
    }
  });
}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'EXTJS_23846'], 0);
Ext.cmd.derive('Ext.GlobalEvents', Ext.mixin.Observable, {alternateClassName:'Ext.globalEvents', observableType:'global', singleton:true, resizeBuffer:100, idleEventMask:{mousemove:1, touchmove:1, pointermove:1, MSPointerMove:1, unload:1}, windowListeners:{resize:{fn:'fireResize'}}, constructor:function() {
  var me = this;
  me.callParent();
  Ext.onInternalReady(function() {
    me.attachListeners();
  });
}, setPressedComponent:function(component, e) {
  var me = this, pressedComponent = me.pressedComponent;
  if (pressedComponent && pressedComponent.onRelease) {
    pressedComponent.onRelease(e);
  }
  me.pressedComponent = component;
  if (component) {
    me.pressedScrollStart = Ext.on({scrollstart:function() {
      me.setPressedComponent(null, e);
    }, destroyable:true});
  } else {
    me.pressedScrollStart = Ext.destroy(me.pressedScrollStart);
  }
}, attachListeners:function() {
  var me = this, win = Ext.getWin(), winListeners = me.windowListeners;
  me.onlineState = Ext.isOnline();
  me.curHeight = Ext.Element.getViewportHeight();
  me.curWidth = Ext.Element.getViewportWidth();
  win.on({scope:me, online:'handleOnlineChange', offline:'handleOnlineChange'});
  if (winListeners) {
    winListeners.scope = me;
    if (Ext.isModern) {
      winListeners.resize.onFrame = true;
    } else {
      winListeners.resize.buffer = me.resizeBuffer;
    }
    win.on(winListeners);
  }
  Ext.getDoc().on({touchstart:'fireMouseDown', mousedown:'fireMouseDown', mouseup:'fireMouseUp', touchend:'fireMouseUp', drop:'fireMouseUp', dragend:'fireMouseUp', scope:me});
}, fireMouseDown:function(e) {
  this.fireEvent('mousedown', e);
  Ext.ComponentManager.handleDocumentMouseDown(e);
}, fireMouseUp:function(e) {
  this.fireEvent('mouseup', e);
  this.setPressedComponent(null, e);
}, fireResize:function() {
  var me = this, Element = Ext.Element, w = Element.getViewportWidth(), h = Element.getViewportHeight();
  if (me.curHeight !== h || me.curWidth !== w) {
    me.curHeight = h;
    me.curWidth = w;
    if (me.hasListeners.resize) {
      me.fireEvent('resize', w, h);
    }
  }
}, handleOnlineChange:function() {
  var online = Ext.isOnline();
  if (online !== this.onlineState) {
    this.onlineState = online;
    this.fireEvent('onlinechange', online);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext, 'GlobalEvents', Ext, 'globalEvents'], function(GlobalEvents) {
  Ext.on = function() {
    return GlobalEvents.addListener.apply(GlobalEvents, arguments);
  };
  Ext.un = function() {
    return GlobalEvents.removeListener.apply(GlobalEvents, arguments);
  };
  Ext.fireEvent = function() {
    return GlobalEvents.fireEvent.apply(GlobalEvents, arguments);
  };
  Ext.fireIdle = function() {
    if (GlobalEvents.hasListeners.idle && !Ext._suppressIdle) {
      GlobalEvents.fireEventArgs('idle');
    }
    Ext._suppressIdle = false;
  };
  Ext._suppressIdle = false;
});
Ext.define('Ext.overrides.GlobalEvents', {override:'Ext.GlobalEvents', attachListeners:function() {
  var me = this, docElement, bufferedFn;
  if (Ext.isIE8) {
    docElement = Ext.getDoc().dom.documentElement;
    bufferedFn = Ext.Function.createBuffered(me.fireResize, me.resizeBuffer, me);
    Ext.getWin().dom.attachEvent('onresize', function() {
      if (docElement.clientWidth !== Ext.GlobalEvents.curWidth || docElement.clientHeight !== Ext.GlobalEvents.curHeight) {
        bufferedFn();
      }
    });
  }
  me.callParent();
}, deprecated:{5:{methods:{addListener:function(ename, fn, scope, options, order, caller, eventOptions) {
  var name, readyFn;
  if (ename === 'ready') {
    readyFn = fn;
  } else {
    if (typeof ename !== 'string') {
      for (name in ename) {
        if (name === 'ready') {
          readyFn = ename[name];
        }
      }
    }
  }
  if (readyFn) {
    Ext.onReady(readyFn);
  }
  this.callParent([ename, fn, scope, options, order, caller, eventOptions]);
}}}}});
Ext.cmd.derive('Ext.Glyph', Ext.Base, {isGlyph:true, constructor:function(glyph) {
  glyph && this.setGlyph(glyph);
}, setGlyph:function(glyph) {
  var glyphParts;
  this.glyphConfig = glyph;
  if (typeof glyph === 'string') {
    glyphParts = glyph.split('@');
    if (isNaN(glyph = isNaN(glyphParts[0]) ? parseInt('0' + glyphParts[0], 16) : parseInt(glyphParts[0], 10)) || !glyph) {
      glyph = glyphParts[0].charCodeAt(0);
    }
    this.fontFamily = glyphParts[1] || Ext._glyphFontFamily;
  } else {
    this.fontFamily = Ext._glyphFontFamily;
  }
  this.codepoint = glyph;
  this.character = Ext.String.fromCodePoint(this.codepoint);
  return this;
}, getStyle:function() {
  return {'font-family':this.fontFamily};
}, isEqual:function(other) {
  return other && other.isGlyph && other.codepoint === this.codepoint && other.fontFamily === this.fontFamily;
}, statics:function() {
  var instance;
  return {fly:function(glyph) {
    return glyph.isGlyph ? glyph : (instance || (instance = new Ext.Glyph)).setGlyph(glyph);
  }};
}()}, 1, 0, 0, 0, 0, 0, [Ext, 'Glyph'], 0);
Ext.USE_NATIVE_JSON = false;
Ext.JSON = new function() {
  var me = this, hasNative = window.JSON && JSON.toString() === '[object JSON]', useHasOwn = !!{}.hasOwnProperty, pad = function(n) {
    return n < 10 ? '0' + n : n;
  }, doDecode = function(json) {
    return eval('(' + json + ')');
  }, doEncode = function(o, newline) {
    if (o === null || o === undefined) {
      return 'null';
    } else {
      if (Ext.isDate(o)) {
        return me.encodeDate(o);
      } else {
        if (Ext.isString(o)) {
          if (Ext.isMSDate(o)) {
            return me.encodeMSDate(o);
          } else {
            return me.encodeString(o);
          }
        } else {
          if (typeof o === 'number') {
            return isFinite(o) ? String(o) : 'null';
          } else {
            if (Ext.isBoolean(o)) {
              return String(o);
            } else {
              if (o.toJSON) {
                return o.toJSON();
              } else {
                if (Ext.isArray(o)) {
                  return encodeArray(o, newline);
                } else {
                  if (Ext.isObject(o)) {
                    return encodeObject(o, newline);
                  } else {
                    if (typeof o === 'function') {
                      return 'null';
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return 'undefined';
  }, m = {'\b':'\\b', '\t':'\\t', '\n':'\\n', '\f':'\\f', '\r':'\\r', '"':'\\"', '\\':'\\\\', '\x0B':'\\u000b'}, charToReplace = /[\\\"\x00-\x1f\x7f-\uffff]/g, encodeString = function(s) {
    return '"' + s.replace(charToReplace, function(a) {
      var c = m[a];
      return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"';
  }, encodeMSDate = function(o) {
    return '"' + o + '"';
  }, encodeArrayPretty = function(o, newline) {
    var len = o.length, cnewline = newline + '   ', sep = ',' + cnewline, a = ['[', cnewline], i;
    for (i = 0; i < len; i += 1) {
      a.push(me.encodeValue(o[i], cnewline), sep);
    }
    a[a.length - 1] = newline + ']';
    return a.join('');
  }, encodeObjectPretty = function(o, newline) {
    var cnewline = newline + '   ', sep = ',' + cnewline, a = ['{', cnewline], i, val;
    for (i in o) {
      val = o[i];
      if (!useHasOwn || o.hasOwnProperty(i)) {
        if (typeof val === 'function' || val === undefined || val.isInstance) {
          continue;
        }
        a.push(me.encodeValue(i) + ': ' + me.encodeValue(val, cnewline), sep);
      }
    }
    a[a.length - 1] = newline + '}';
    return a.join('');
  }, encodeArray = function(o, newline) {
    if (newline) {
      return encodeArrayPretty(o, newline);
    }
    var a = ['[', ''], len = o.length, i;
    for (i = 0; i < len; i += 1) {
      a.push(me.encodeValue(o[i]), ',');
    }
    a[a.length - 1] = ']';
    return a.join('');
  }, encodeObject = function(o, newline) {
    if (newline) {
      return encodeObjectPretty(o, newline);
    }
    var a = ['{', ''], i, val;
    for (i in o) {
      val = o[i];
      if (!useHasOwn || o.hasOwnProperty(i)) {
        if (typeof val === 'function' || val === undefined) {
          continue;
        }
        a.push(me.encodeValue(i), ':', me.encodeValue(val), ',');
      }
    }
    a[a.length - 1] = '}';
    return a.join('');
  };
  me.encodeString = encodeString;
  me.encodeValue = doEncode;
  me.encodeDate = function(o) {
    return '"' + o.getFullYear() + '-' + pad(o.getMonth() + 1) + '-' + pad(o.getDate()) + 'T' + pad(o.getHours()) + ':' + pad(o.getMinutes()) + ':' + pad(o.getSeconds()) + '"';
  };
  me.encode = function(o) {
    if (hasNative && Ext.USE_NATIVE_JSON) {
      return JSON.stringify(o);
    }
    return me.encodeValue(o);
  };
  me.decode = function(json, safe) {
    try {
      if (hasNative && Ext.USE_NATIVE_JSON) {
        return JSON.parse(json);
      }
      return doDecode(json);
    } catch (e$24) {
      if (safe) {
        return null;
      }
      Ext.raise({sourceClass:'Ext.JSON', sourceMethod:'decode', msg:"You're trying to decode an invalid JSON String: " + json});
    }
  };
  me.encodeMSDate = encodeMSDate;
  if (!Ext.util) {
    Ext.util = {};
  }
  Ext.util.JSON = me;
  Ext.encode = me.encode;
  Ext.decode = me.decode;
};
Ext.cmd.derive('Ext.mixin.Inheritable', Ext.Mixin, {mixinConfig:{id:'inheritable'}, getInherited:function(inner) {
  var me = this, inheritedState = inner && me.inheritedStateInner || me.inheritedState, ownerCt = me.getRefOwner(), isContainer = me.isContainer, parent, inheritedStateInner, getInner, ownerLayout;
  if (!inheritedState || inheritedState.invalid) {
    parent = me.getRefOwner();
    ownerLayout = me.ownerLayout;
    if (ownerCt) {
      getInner = ownerLayout ? ownerLayout === ownerCt.layout : true;
    }
    me.inheritedState = inheritedState = Ext.Object.chain(parent ? parent.getInherited(getInner) : Ext.rootInheritedState);
    if (isContainer) {
      me.inheritedStateInner = inheritedStateInner = Ext.Object.chain(inheritedState);
    }
    me.initInheritedState(inheritedState, inheritedStateInner);
    inheritedState = isContainer && inner ? me.inheritedStateInner : me.inheritedState;
  }
  return inheritedState;
}, getInheritedConfig:function(property, skipThis) {
  var state = this.inheritedState, old, ret;
  if (!state || state.invalid) {
    state = this.getInherited();
  }
  ret = state[property];
  if (skipThis && state.hasOwnProperty(property)) {
    old = ret;
    delete state[property];
    ret = state[property];
    state[property] = old;
  }
  return ret;
}, resolveListenerScope:function(defaultScope, skipThis) {
  var me = this, hasSkipThis = typeof skipThis === 'boolean', namedScope = Ext._namedScopes[defaultScope], ret;
  if (!namedScope) {
    ret = me.getInheritedConfig('defaultListenerScope', hasSkipThis ? skipThis : true) || defaultScope || me;
  } else {
    if (namedScope.isController) {
      ret = me.getInheritedConfig('controller', hasSkipThis ? skipThis : !namedScope.isSelf);
    } else {
      if (namedScope.isOwner) {
        ret = me.getRefOwner();
      } else {
        if (namedScope.isSelf) {
          ret = me.getInheritedConfig('defaultListenerScope', hasSkipThis && skipThis) || me;
        } else {
          if (namedScope.isThis) {
            ret = me;
          }
        }
      }
    }
  }
  return ret || null;
}, resolveSatelliteListenerScope:function(satellite, defaultScope) {
  var me = this, namedScope = Ext._namedScopes[defaultScope], ret;
  if (!namedScope) {
    ret = me.getInheritedConfig('defaultListenerScope') || defaultScope || me;
  } else {
    if (namedScope.isController) {
      ret = me.getInheritedConfig('controller');
    } else {
      if (namedScope.isSelf) {
        ret = me.getInheritedConfig('defaultListenerScope') || satellite;
      } else {
        if (namedScope.isThis) {
          ret = satellite;
        }
      }
    }
  }
  return ret || null;
}, lookupNameHolder:function(skipThis) {
  return this.getInheritedConfig('nameHolder', skipThis !== false) || null;
}, lookupReferenceHolder:function(skipThis) {
  return this.getInheritedConfig('referenceHolder', skipThis !== false) || null;
}, getRefOwner:function() {
  var me = this;
  return me.ownerCmp || me.ownerCt || me.parent || me.$initParent || me.floatParent;
}, bubble:function(fn, scope, args) {
  for (var target = this; target; target = target.getRefOwner()) {
    if (fn.apply(scope || target, args || [target]) === false) {
      break;
    }
  }
}, isDescendantOf:function(ancestor) {
  return ancestor ? ancestor.isAncestor(this) : false;
}, isAncestor:function(possibleDescendant) {
  while (possibleDescendant) {
    if (possibleDescendant.getRefOwner() === this) {
      return true;
    }
    possibleDescendant = possibleDescendant.getRefOwner();
  }
  return false;
}, invalidateInheritedState:function() {
  var inheritedState = this.inheritedState;
  if (inheritedState) {
    inheritedState.invalid = true;
    delete this.inheritedState;
  }
}, privates:{_fixName:function() {
  var me = this, owner;
  if (me.name) {
    owner = me.lookupNameHolder();
    if (owner && !owner.destroyed) {
      owner.attachNameRef(me);
    }
  }
}, _fixReference:function() {
  var me = this, refHolder;
  if (me.reference) {
    refHolder = me.lookupReferenceHolder();
    if (refHolder) {
      refHolder.attachReference(me);
    }
  }
}, onInheritedAdd:function(parent, instanced) {
  var me = this;
  if (me.inheritedState && instanced) {
    me.invalidateInheritedState();
  }
  if (me.name || me.reference) {
    Ext.ComponentManager.markReferencesDirty();
  }
}, onInheritedRemove:function(destroying) {
  var me = this;
  if (me.name || me.reference) {
    Ext.ComponentManager.markReferencesDirty();
  }
  if (me.inheritedState && !destroying) {
    me.invalidateInheritedState();
  }
}}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Inheritable'], function() {
  Ext.rootInheritedState = {};
});
Ext.cmd.derive('Ext.mixin.Bindable', Ext.Base, {mixinId:'bindable', config:{bind:{$value:null, lazy:true}, controller:null, defaultListenerScope:false, publishes:{$value:null, lazy:true, merge:function(newValue, oldValue) {
  return this.mergeSets(newValue, oldValue);
}}, session:{$value:null, lazy:true}, twoWayBindable:{$value:null, lazy:true, merge:function(newValue, oldValue) {
  return this.mergeSets(newValue, oldValue);
}}, viewModel:{$value:null, lazy:true}}, defaultBindProperty:null, nameable:false, shareableName:false, reference:null, validRefRe:/^[a-z_][a-z0-9_]*$/i, getReference:function() {
  return this.reference;
}, initInheritedState:function(inheritedState) {
  var me = this, reference = me.reference, controller = me.getController(), viewModel = me.getConfig('viewModel', true), session = me.getConfig('session', true), defaultListenerScope = me.getDefaultListenerScope();
  if (controller) {
    inheritedState.controller = controller;
  }
  if (defaultListenerScope) {
    inheritedState.defaultListenerScope = me;
  } else {
    if (controller) {
      inheritedState.defaultListenerScope = controller;
    }
  }
  if (viewModel) {
    if (!viewModel.isViewModel) {
      viewModel = me;
    }
    inheritedState.viewModel = viewModel;
  }
  if (session) {
    if (!session.isSession) {
      session = me;
    }
    inheritedState.session = session;
  }
  if (reference) {
    me.referenceKey = (inheritedState.referencePath || '') + reference;
    me.viewModelKey = (inheritedState.viewModelPath || '') + reference;
  }
}, isBound:function(name) {
  var bind = this.getBind();
  return !!(bind && bind[name || this.defaultBindProperty]);
}, lookupController:function(skipThis) {
  return this.getInheritedConfig('controller', skipThis) || null;
}, lookupSession:function(skipThis) {
  var ret = skipThis ? null : this.getSession();
  if (!ret) {
    ret = this.getInheritedConfig('session', skipThis);
    if (ret && !ret.isSession) {
      ret = ret.getInherited().session = ret.getSession();
    }
  }
  return ret || null;
}, lookupViewModel:function(skipThis) {
  var ret = skipThis ? null : this.getViewModel();
  if (!ret) {
    ret = this.getInheritedConfig('viewModel', skipThis);
    if (ret && !ret.isViewModel) {
      ret = ret.getInherited().viewModel = ret.getViewModel();
    }
  }
  return ret || null;
}, publishState:function(property, value) {
  var me = this, state = me.publishedState, binds = me.getBind(), binding = binds && property && binds[property], count = 0, name, publishes, vm, path;
  if (binding && !binding.syncing && !binding.isReadOnly()) {
    if (binding.calls || !(value == null || value === me.getInitialConfig()[property])) {
      binding.setValue(value);
    }
  }
  if (!(publishes = me.getPublishes())) {
    return;
  }
  if (!(vm = me.lookupViewModel())) {
    return;
  }
  if (!(path = me.viewModelKey)) {
    return;
  }
  state = state || (me.publishedState = {});
  if (property) {
    if (!publishes[property]) {
      return;
    }
    if (!(value && value.constructor === Object) && !(value instanceof Array)) {
      if (state[property] === value) {
        return;
      }
    }
    path += '.';
    path += property;
  } else {
    for (name in publishes) {
      ++count;
      state[name] = me.getConfig(name);
    }
    if (!count) {
      return;
    }
    value = state;
  }
  vm.set(path, value);
}, privates:{addBindableUpdater:function(property) {
  var me = this, configs = me.self.$config.configs, cfg = configs[property], updateName;
  if (cfg && !me.hasOwnProperty(updateName = cfg.names.update)) {
    me[updateName] = cfg.bindableUpdater || (cfg.root.bindableUpdater = me.makeBindableUpdater(cfg));
  }
}, applyBind:function(binds, currentBindings) {
  if (!binds) {
    return binds;
  }
  var me = this, viewModel = me.lookupViewModel(), twoWayable = me.getTwoWayBindable(), getBindTemplateScope = me._getBindTemplateScope, b, property, descriptor, destroy;
  me.$hasBinds = true;
  if (!currentBindings || typeof currentBindings === 'string') {
    currentBindings = {};
  }
  if (Ext.isString(binds)) {
    b = binds;
    binds = {};
    binds[me.defaultBindProperty] = b;
  }
  for (property in binds) {
    descriptor = binds[property];
    b = currentBindings[property];
    if (b && b.isBinding) {
      b.destroy();
      b = null;
      destroy = true;
    }
    if (descriptor) {
      b = viewModel.bind(descriptor, me.onBindNotify, me);
      b._config = Ext.Config.get(property);
      b.getTemplateScope = getBindTemplateScope;
    }
    if (destroy) {
      delete currentBindings[property];
    } else {
      currentBindings[property] = b;
    }
    if (twoWayable && twoWayable[property]) {
      if (destroy) {
        me.clearBindableUpdater(property);
      } else {
        if (!b.isReadOnly()) {
          me.addBindableUpdater(property);
        }
      }
    }
  }
  return currentBindings;
}, applyController:function(controller) {
  if (controller) {
    controller = Ext.Factory.controller(controller);
    controller.setView(this);
  }
  this.controller = controller;
  return controller;
}, updatePublishes:function(all) {
  var me = this;
  if (me.lookupViewModel()) {
    for (var property in all) {
      me.addBindableUpdater(property);
    }
  }
  return all;
}, applySession:function(session) {
  if (!session) {
    return null;
  }
  if (!session.isSession) {
    var parentSession = this.lookupSession(true), config = session === true ? {} : session;
    if (parentSession) {
      session = parentSession.spawn(config);
    } else {
      session = new Ext.data['Session'](config);
    }
  }
  return session;
}, applyViewModel:function(viewModel) {
  var me = this, config, session;
  if (!viewModel) {
    return null;
  }
  if (!viewModel.isViewModel) {
    config = {parent:me.lookupViewModel(true), view:me};
    config.session = me.getSession();
    if (!session && !config.parent) {
      config.session = me.lookupSession();
    }
    if (viewModel) {
      if (viewModel.constructor === Object) {
        Ext.apply(config, viewModel);
      } else {
        if (typeof viewModel === 'string') {
          config.type = viewModel;
        }
      }
    }
    viewModel = Ext.Factory.viewModel(config);
  }
  return viewModel;
}, _getBindTemplateScope:function() {
  return this.scope.resolveListenerScope();
}, clearBindableUpdater:function(property) {
  var me = this, configs = me.self.$config.configs, cfg = configs[property], updateName;
  if (cfg && me.hasOwnProperty(updateName = cfg.names.update)) {
    if (me[updateName].$bindableUpdater) {
      delete me[updateName];
    }
  }
}, destroyBindable:function() {
  var me = this, viewModel = me.getConfig('viewModel', true), session = me.getConfig('session', true), controller = me.getController();
  if (viewModel && viewModel.isViewModel) {
    viewModel.destroy();
    me.setViewModel(null);
  }
  if (session && session.isSession) {
    if (session.getAutoDestroy()) {
      session.destroy();
    }
    me.setSession(null);
  }
  if (controller) {
    me.setController(null);
    controller.destroy();
  }
}, initBindable:function() {
  var me = this, controller = me.controller;
  me.initBindable = Ext.emptyFn;
  me.getBind();
  me.getPublishes();
  if (!me.viewModel) {
    me.getViewModel();
  }
  if (controller) {
    controller.initBindings();
  }
  if (me.reference) {
    me.publishState();
  }
}, isSyncing:function(name) {
  var bindings = this.getBind(), ret = false, binding;
  if (bindings) {
    binding = bindings[name];
    if (binding) {
      ret = binding.syncing > 0;
    }
  }
  return ret;
}, makeBindableUpdater:function(cfg) {
  var updateName = cfg.names.update, fn = function(newValue, oldValue) {
    var me = this, updater = me.self.prototype[updateName];
    if (updater) {
      updater.call(me, newValue, oldValue);
    }
    me.publishState(cfg.name, me[cfg.getInternalName(me)]);
  };
  fn.$bindableUpdater = true;
  return fn;
}, notifyIf:function(skipThis) {
  var vm = this.lookupViewModel(skipThis);
  if (vm) {
    vm.notify();
  }
}, onBindNotify:function(value, oldValue, binding) {
  binding.syncing = binding.syncing + 1 || 1;
  this[binding._config.names.set](value);
  --binding.syncing;
}, removeBindings:function() {
  var me = this, bindings, key, binding;
  if (me.$hasBinds) {
    bindings = me.getBind();
    if (bindings && typeof bindings !== 'string') {
      for (key in bindings) {
        binding = bindings[key];
        binding.destroy();
        binding._config = binding.getTemplateScope = null;
      }
    }
  }
  me.setBind(null);
}, updateSession:function(session) {
  var state = this.getInherited();
  if (session) {
    state.session = session;
  } else {
    delete state.session;
  }
}, updateViewModel:function(viewModel, oldViewModel) {
  var me = this, state = me.getInherited(), controller = me.getController();
  if (viewModel) {
    me.hasVM = true;
    state.viewModel = viewModel;
    viewModel.setView(me);
    if (controller) {
      controller.initViewModel(viewModel);
    }
  } else {
    delete state.viewModel;
  }
  me.viewModel = viewModel;
}}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Bindable'], 0);
Ext.cmd.derive('Ext.mixin.ComponentDelegation', Ext.Mixin, {mixinConfig:{id:'componentDelegation'}, privates:{addDelegatedListener:function(eventName, fn, scope, options, order, caller, manager) {
  var me = this, delegatedEvents, event, priority;
  eventName = Ext.canonicalEventName(eventName);
  order = order || options.order;
  if (order) {
    priority = options && options.priority;
    if (!priority) {
      options = options ? Ext.Object.chain(options) : {};
      options.priority = me.$orderToPriority[order];
    }
  }
  delegatedEvents = me.$delegatedEvents || (me.$delegatedEvents = {});
  event = delegatedEvents[eventName] || (delegatedEvents[eventName] = new Ext.util.Event(me, eventName));
  if (event.addListener(fn, scope, options, caller, manager)) {
    me.$hasDelegatedListeners._incr_(eventName);
  }
}, clearDelegatedListeners:function() {
  var me = this, delegatedEvents = me.$delegatedEvents, eventName, event, listenerCount;
  if (delegatedEvents) {
    for (eventName in delegatedEvents) {
      event = delegatedEvents[eventName];
      listenerCount = event.listeners.length;
      event.clearListeners();
      me.$hasDelegatedListeners._decr_(eventName, listenerCount);
      delete delegatedEvents[eventName];
    }
  }
}, doFireDelegatedEvent:function(eventName, args) {
  var me = this, ret = true, owner, delegatedEvents, event;
  if (me.$hasDelegatedListeners[eventName]) {
    owner = me.getRefOwner();
    while (owner) {
      delegatedEvents = owner.$delegatedEvents;
      if (delegatedEvents) {
        event = delegatedEvents[eventName];
        if (event) {
          ret = event.fireDelegated(me, args);
          if (ret === false) {
            break;
          }
        }
      }
      owner = owner.getRefOwner();
    }
  }
  return ret;
}, removeDelegatedListener:function(eventName, fn, scope) {
  var me = this, delegatedEvents = me.$delegatedEvents, event;
  if (delegatedEvents) {
    event = delegatedEvents[eventName];
    if (event && event.removeListener(fn, scope)) {
      me.$hasDelegatedListeners._decr_(eventName);
      if (event.listeners.length === 0) {
        delete delegatedEvents[eventName];
      }
    }
  }
}, destroyComponentDelegation:function() {
  if (this.clearPropertiesOnDestroy) {
    this.$delegatedEvents = null;
  }
}}, onClassMixedIn:function(T) {
  function HasListeners() {
  }
  T.prototype.HasListeners = T.HasListeners = HasListeners;
  HasListeners.prototype = T.hasListeners = new Ext.mixin.ComponentDelegation.HasDelegatedListeners;
}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'ComponentDelegation'], function(ComponentDelegation) {
  function HasDelegatedListeners() {
  }
  ComponentDelegation.HasDelegatedListeners = HasDelegatedListeners;
  HasDelegatedListeners.prototype = ComponentDelegation.prototype.$hasDelegatedListeners = new Ext.mixin.Observable.HasListeners;
});
Ext.cmd.derive('Ext.plugin.Abstract', Ext.Base, {alternateClassName:'Ext.AbstractPlugin', isPlugin:true, constructor:function(config) {
  if (config) {
    this.pluginConfig = config;
    this.initConfig(config);
  }
}, clonePlugin:function(overrideCfg) {
  return new this.self(Ext.apply({}, overrideCfg, this.pluginConfig));
}, getCmp:function() {
  return this.cmp;
}, setCmp:function(host) {
  this.cmp = host;
}, init:Ext.emptyFn, destroy:function() {
  this.cmp = this.pluginConfig = null;
  this.callParent();
}, onClassExtended:function(cls, data, hooks) {
  var alias = data.alias, prototype = cls.prototype;
  if (alias && !data.ptype) {
    if (Ext.isArray(alias)) {
      alias = alias[0];
    }
    prototype.ptype = alias.split('plugin.')[1];
  }
}, resolveListenerScope:function(defaultScope) {
  var me = this, cmp = me.getCmp(), scope;
  if (cmp) {
    scope = cmp.resolveSatelliteListenerScope(me, defaultScope);
  }
  return scope || me.mixins.observable.resolveListenerScope.call(me, defaultScope);
}, statics:{decode:function(plugins, typeProp, include) {
  if (plugins) {
    var type = Ext.typeOf(plugins), entry, key, obj, value;
    if (type === 'string') {
      obj = {};
      obj[typeProp] = plugins;
      plugins = [obj];
    } else {
      if (plugins.isInstance) {
        plugins = [plugins];
      } else {
        if (type === 'object') {
          if (plugins[typeProp]) {
            plugins = [plugins];
          } else {
            obj = include ? Ext.merge(Ext.clone(include), plugins) : plugins;
            plugins = [];
            for (key in obj) {
              if (!(value = obj[key])) {
                continue;
              }
              entry = {id:key};
              entry[typeProp] = key;
              if (key === 'responsive') {
                entry.weight = -1000;
              }
              Ext.apply(entry, value);
              plugins.push(entry);
            }
            plugins.sort(Ext.weightSortFn);
          }
        } else {
          plugins = plugins.slice();
        }
      }
    }
  }
  return plugins;
}}}, 1, 0, 0, 0, 0, 0, [Ext.plugin, 'Abstract', Ext, 'AbstractPlugin'], 0);
Ext.define('Ext.overrides.plugin.Abstract', {override:'Ext.plugin.Abstract', $configStrict:false, $configPrefixed:false, disabled:false, getState:null, applyState:null, enable:function() {
  this.disabled = false;
}, disable:function() {
  this.disabled = true;
}});
Ext.cmd.derive('Ext.mixin.Pluggable', Ext.Base, function(Pluggable) {
  return {config:{plugins:null}, addPlugin:function(plugin) {
    var me = this, plugins = me.getPlugins();
    if (plugins) {
      plugin = me.createPlugin(plugin);
      plugin.init(me);
      plugins.push(plugin);
    } else {
      me.setPlugins(plugin);
      plugin = me.getPlugins()[0];
    }
    return plugin;
  }, destroyPlugin:function(plugin) {
    return this.removePlugin(plugin, true);
  }, findPlugin:function(type) {
    var plugins = this.getPlugins(), n = plugins && plugins.length, i, plugin, ret;
    for (i = 0; i < n && !ret; i++) {
      plugin = plugins[i];
      if (plugin.type === type || plugin.ptype === type) {
        ret = plugin;
      }
    }
    return ret || null;
  }, getPlugin:function(id) {
    var plugins = this.getPlugins(), n = plugins && plugins.length, i, plugin, ret;
    for (i = 0; i < n && !ret; i++) {
      plugin = plugins[i];
      if (plugin.id === id || plugin.pluginId === id) {
        ret = plugin;
      }
    }
    return ret || null;
  }, removePlugin:function(plugin, destroy) {
    var plugins = this.getPlugins(), i = plugins && plugins.length || 0, p;
    while (i-- > 0) {
      p = plugins[i];
      if (p === plugin || p.id === plugin) {
        plugins.splice(i, 1);
        if (destroy) {
          if (p.destroy) {
            p.destroy();
          }
        } else {
          if (p.detachCmp) {
            p.detachCmp();
            if (p.setCmp) {
              p.setCmp(null);
            }
          }
        }
        break;
      }
      p = null;
    }
    return p;
  }, privates:{statics:{idSeed:0}, activatePlugin:function(type) {
    var me = this, config = me.initialConfig, plugins = config && config.plugins, ret = null, i, include, p;
    if (plugins) {
      include = me.config.plugins;
      include = include && typeof include === 'object' ? include : null;
      plugins = Ext.plugin.Abstract.decode(plugins, 'type', include);
      for (i = plugins.length; i-- > 0;) {
        p = plugins[i];
        if (p === type || p.type === type) {
          me.initialConfig = config = Ext.apply({}, config);
          config.plugins = plugins;
          plugins[i] = ret = me.createPlugin(p);
          break;
        }
      }
    }
    return ret;
  }, applyPlugins:function(plugins, oldPlugins) {
    var me = this, oldCount = oldPlugins && oldPlugins.length || 0, count, i, plugin;
    if (plugins) {
      plugins = Ext.plugin.Abstract.decode(plugins, 'type');
    }
    for (i = 0; i < oldCount; ++i) {
      oldPlugins[i].$dead = true;
    }
    count = plugins && plugins.length || 0;
    for (i = 0; i < count; ++i) {
      plugins[i] = me.createPlugin(plugins[i]);
    }
    for (i = 0; i < count; ++i) {
      plugin = plugins[i];
      if (plugin.$dead) {
        delete plugin.$dead;
      } else {
        plugin.init(me);
      }
    }
    for (i = 0; i < oldCount; ++i) {
      if ((plugin = oldPlugins[i]).$dead) {
        delete plugin.$dead;
        Ext.destroy(plugin);
      }
    }
    return plugins;
  }, createPlugin:function(config) {
    if (typeof config === 'string') {
      config = {type:config};
    }
    var ret = config;
    if (!config.isInstance) {
      config.cmp = this;
      ret = Ext.factory(config, null, null, 'plugin');
      delete config.cmp;
    }
    if (!ret.id) {
      ret.id = ++Pluggable.idSeed;
    }
    if (ret.setCmp) {
      ret.setCmp(this);
    }
    return ret;
  }}};
}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Pluggable'], 0);
Ext.cmd.derive('Ext.mixin.Keyboard', Ext.Mixin, function(Keyboard) {
  return {mixinConfig:{id:'keyboard'}, config:{keyMap:{$value:null, cached:true, merge:function(value, baseValue, cls, mixin) {
    if (value === null) {
      return value;
    }
    var ret = baseValue && !cls.isInstance ? Ext.Object.chain(baseValue) : {}, key, ucKey, v, vs;
    for (key in value) {
      if (key !== 'scope') {
        ucKey = key.toUpperCase();
        if (!mixin || ret[ucKey] === undefined) {
          v = value[key];
          if (v) {
            if (typeof v === 'string' || typeof v === 'function') {
              v = {handler:v};
            } else {
              v = Ext.apply({handler:v.fn}, v);
            }
            vs = v.scope || value.scope || 'self';
            v.scope = vs === 'controller' ? 'self.controller' : vs;
          }
          ret[ucKey] = v;
        }
      }
    }
    return ret;
  }}, keyMapEnabled:null}, keyMapTarget:'el', applyKeyMap:function(keyMap, existingKeyMap) {
    var me = this, own = me.hasOwnProperty('config');
    if (own && existingKeyMap && existingKeyMap.$owner !== me) {
      existingKeyMap = Ext.apply({}, existingKeyMap);
    }
    keyMap = keyMap ? Keyboard.combineKeyMaps(existingKeyMap, keyMap, own && me) : null;
    if (me._keyMapReady) {
      me.setKeyMapListener(keyMap && me.getKeyMapEnabled());
    }
    return keyMap;
  }, initKeyMap:function() {
    var me = this, enabled = me.getKeyMapEnabled();
    me._keyMapReady = true;
    if (enabled === null) {
      me.setKeyMapEnabled(true);
    } else {
      me.setKeyMapListener(enabled && me.getKeyMap());
    }
  }, disableKeyMapGroup:function(group) {
    this.setKeyMapGroupEnabled(group, false);
  }, enableKeyMapGroup:function(group) {
    this.setKeyMapGroupEnabled(group, true);
  }, setKeyMapGroupEnabled:function(group, state) {
    var me = this, disabledGroups = me.disabledKeyMapGroups || (me.disabledKeyMapGroups = {});
    disabledGroups[group] = !state;
  }, updateKeyMapEnabled:function(enabled) {
    this.setKeyMapListener(enabled && this._keyMapReady && this.getKeyMap());
  }, privates:{_keyMapReady:false, comparePriorities:function(lhs, rhs) {
    return (rhs.priority || 0) - (lhs.priority || 0);
  }, findKeyMapEntries:function(e) {
    var me = this, disabledGroups = me.disabledKeyMapGroups, keyMap = me.getKeyMap(), entries = keyMap && Keyboard.getKeyName(e), entry, len, i, result = [];
    entries = entries && keyMap[entries];
    if (entries) {
      if (!entries.sorted) {
        Ext.Array.sort(entries, me.comparePriorities);
        entries.sorted = true;
      }
      len = entries.length;
      for (i = 0; i < len; i++) {
        entry = entries[i];
        if (!disabledGroups || !disabledGroups[entry.group]) {
          if (Keyboard.matchEntry(entry, e)) {
            result.push(entry);
          }
        }
      }
    }
    return result;
  }, onKeyMapEvent:function(e) {
    var me = this, entries = me.getKeyMapEnabled() ? me.findKeyMapEntries(e) : null, len = entries && entries.length, i, entry, result;
    for (i = 0; i < len && result !== false; i++) {
      entry = entries[i];
      result = Ext.callback(entry.handler, entry.scope, [e, this], 0, this);
    }
    return result;
  }, setKeyMapListener:function(enabled) {
    var me = this, listener = me._keyMapListener, eventSource;
    if (listener) {
      listener.destroy();
      listener = null;
    }
    if (enabled) {
      if (enabled) {
        eventSource = me[me.keyMapTarget];
        if (typeof eventSource === 'function') {
          eventSource = eventSource.call(me);
        }
        listener = eventSource.on({destroyable:true, scope:me, keydown:'onKeyMapEvent', keypress:'onKeyMapEvent'});
      }
    }
    me._keyMapListener = listener || null;
  }, statics:{_charCodeRe:/^#([\d]+)$/, _keySpecRe:/^(?:(?:(\*)[\+\-])|(?:([a-z\+\-]*)[\+\-]))?(?:([a-z0-9_]+|[\+\-]|(?:#?\d+))(?:\:([a-z]+))?)$/i, _delimiterRe:/\-|\+/, _keyMapEvents:{charCode:'keypress', keyCode:'keydown'}, combineKeyMaps:function(existingKeyMap, keyMap, owner) {
    var defaultScope = keyMap.scope || 'controller', entry, key, mapping, existingMapping;
    for (key in keyMap) {
      if (key === 'scope') {
        continue;
      }
      if (!(mapping = keyMap[key])) {
        if (!existingKeyMap) {
          continue;
        }
      } else {
        if (typeof mapping === 'string' || typeof mapping === 'function') {
          mapping = {handler:mapping, scope:defaultScope};
        } else {
          if (mapping) {
            mapping = Ext.apply({handler:mapping.fn, scope:defaultScope}, mapping);
          }
        }
        existingKeyMap = existingKeyMap || {};
      }
      if (Keyboard.parseEntry(key, entry = mapping || {})) {
        existingMapping = existingKeyMap[entry.name];
        if (existingMapping) {
          if (owner && existingMapping.$owner !== owner) {
            existingKeyMap[entry.name] = existingMapping = existingMapping.slice();
            existingMapping.$owner = owner;
          }
          existingMapping.push(mapping);
          existingMapping.sorted = false;
        } else {
          existingMapping = existingKeyMap[entry.name] = [mapping];
          existingMapping.$owner = owner;
          existingMapping.sorted = true;
        }
      }
    }
    if (existingKeyMap && owner) {
      existingKeyMap.$owner = owner;
    }
    return existingKeyMap || null;
  }, getKeyName:function(event) {
    var keyCode;
    if (event.isEvent) {
      keyCode = event.keyCode || event.charCode;
      event = event.browserEvent;
      if (keyCode === 229 && 'code' in event) {
        if (Ext.String.startsWith(event.code, 'Key')) {
          return event.key.substr(3);
        }
        if (Ext.String.startsWith(event.code, 'Digit')) {
          return event.key.substr(5);
        }
      }
    } else {
      keyCode = event;
    }
    return Ext.event.Event.keyCodes[keyCode] || String.fromCharCode(keyCode);
  }, matchEntry:function(entry, e) {
    var ev = e.browserEvent, code;
    if (e.type !== entry.event) {
      return false;
    }
    if (!(code = entry.charCode)) {
      if (entry.keyCode !== e.keyCode || !entry.ignoreModifiers && !entry.shiftKey !== !ev.shiftKey) {
        return false;
      }
    } else {
      if (e.getCharCode() !== code) {
        return false;
      }
    }
    return entry.ignoreModifiers || !entry.ctrlKey === !ev.ctrlKey && !entry.altKey === !ev.altKey && !entry.metaKey === !ev.metaKey && !entry.shiftKey === !ev.shiftKey;
  }, parseEntry:function(key, entry) {
    key = key.toUpperCase();
    var me = this, Event = Ext.event.Event, keyFlags = Event.keyFlags, parts = me._keySpecRe.exec(key), type = 'keyCode', name, code, i, match, n;
    if (parts) {
      name = parts[3];
      if (parts[4]) {
        entry.group = parts[4];
      }
      if (!(entry.ignoreModifiers = !!parts[1]) && parts[2]) {
        parts = parts[2].split(me._delimiterRe);
        n = parts.length;
        for (i = 0; i < n; i++) {
          entry[keyFlags[parts[i]]] = true;
        }
      }
      entry.name = name;
      if (isNaN(code = Event[name])) {
        if (!(match = me._charCodeRe.exec(name))) {
          if (name.length === 1) {
            code = name.charCodeAt(0);
          }
        } else {
          code = +match[1];
        }
        if (code) {
          type = 'charCode';
        } else {
          code = +name;
        }
        entry.name = Keyboard.getKeyName(code);
      }
      entry.event = entry.event || me._keyMapEvents[type];
      return !isNaN(code) && (entry[type] = code);
    }
  }}}};
}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Keyboard'], 0);
Ext.cmd.derive('Ext.mixin.Focusable', Ext.Base, {mixinId:'focusable', $isFocusableEntity:true, focusable:false, hasFocus:false, containsFocus:false, focusCls:'x-focused', focusEl:'el', getFocusEl:function() {
  var focusEl = this.focusEl;
  return focusEl && focusEl.dom ? focusEl : null;
}, getFocusClsEl:function() {
  return this.getFocusEl();
}, initFocusable:Ext.emptyFn, initFocusableEvents:function(force) {
  this.initFocusableElement(force);
}, enableFocusable:Ext.emptyFn, disableFocusable:function() {
  var me = this;
  if (me.hasFocus) {
    me.revertFocus();
  }
  me.removeFocusCls();
}, destroyFocusable:function() {
  var me = this;
  Ext.destroy(me.focusListeners);
  me.focusListeners = me.focusEnterEvent = me.focusTask = null;
  me.focusEl = me.ariaEl = null;
}, isFocusable:function(deep) {
  var me = this, focusEl;
  if (!me.focusable && (!me.isContainer || !deep)) {
    return false;
  }
  focusEl = me.getFocusEl();
  if (focusEl && me.canFocus()) {
    return focusEl && !focusEl.destroyed && focusEl.isFocusable(deep);
  }
  return false;
}, isDestructing:function() {
  for (var c = this; c; c = c.getRefOwner()) {
    if (c.destroying || c.destroyed) {
      return true;
    }
  }
  return false;
}, canFocus:function(skipVisibility, includeFocusTarget) {
  var me = this, ownerFC = me.ownerFocusableContainer, focusableIfDisabled = ownerFC && ownerFC.allowFocusingDisabledChildren, canFocus;
  canFocus = !me.destroyed && me.rendered && !me.isDestructing() && (me.isContainer || me.focusable) && (!me.isDisabled() || focusableIfDisabled) && (skipVisibility || me.isVisible(true));
  return canFocus || includeFocusTarget && !!me.findFocusTarget();
}, focus:function(selectText) {
  var me = this, focusTarget, focusElDom;
  if (!me.focusable && !me.isContainer || me.destroyed || me.destroying) {
    return false;
  }
  if (me.canFocus() && (focusTarget = me.getFocusEl())) {
    if (focusTarget.$isFocusableEntity) {
      return focusTarget.focus.apply(focusTarget, arguments);
    }
    focusElDom = focusTarget.dom;
    if (focusElDom) {
      focusTarget.focus();
      if (selectText && (me.selectText || focusElDom.select)) {
        if (me.selectText) {
          if (Ext.isArray(selectText)) {
            me.selectText.apply(me, selectText);
          } else {
            me.selectText();
          }
        } else {
          focusElDom.select();
        }
      }
    } else {
      if (focusTarget.focus) {
        focusTarget.focus();
      } else {
        return false;
      }
    }
  } else {
    focusTarget = me.findFocusTarget();
    if (focusTarget && focusTarget != me) {
      return focusTarget.focus.apply(focusTarget, arguments);
    } else {
      return false;
    }
  }
  return true;
}, onBlur:function(e) {
  var me = this, container = me.ownerFocusableContainer;
  me.hasFocus = false;
  if (me.beforeBlur && !me.beforeBlur.$emptyFn) {
    me.beforeBlur(e);
  }
  if (container) {
    container.beforeFocusableChildBlur(me, e);
  }
  me.removeFocusCls(e);
  if (me.hasListeners.blur) {
    me.fireEvent('blur', me, e);
  }
  if (me.postBlur && !me.postBlur.$emptyFn) {
    me.postBlur(e);
  }
  if (container) {
    container.afterFocusableChildBlur(me, e);
  }
}, onFocus:function(e) {
  var me = this, container = me.ownerFocusableContainer;
  if (me.canFocus()) {
    if (me.beforeFocus && !me.beforeFocus.$emptyFn) {
      me.beforeFocus(e);
    }
    if (container) {
      container.beforeFocusableChildFocus(me, e);
    }
    me.addFocusCls(e);
    if (!me.hasFocus) {
      me.hasFocus = true;
      me.fireEvent('focus', me, e);
    }
    if (me.postFocus && !me.postFocus.$emptyFn) {
      me.postFocus(e);
    }
    if (container) {
      container.afterFocusableChildFocus(me, e);
    }
  }
}, getTabIndex:function() {
  var me = this, el, index;
  if (!me.focusable) {
    return;
  }
  el = me.getFocusEl();
  if (el) {
    if (el.$isFocusableEntity) {
      index = el.getTabIndex();
    } else {
      if (el.isElement && el.dom) {
        index = el.dom.getAttribute('tabIndex');
        if (index !== null) {
          index -= 0;
        }
      } else {
        return;
      }
    }
  }
  if (typeof index !== 'number') {
    index = me.tabIndex;
  }
  return index;
}, setTabIndex:function(newTabIndex, focusEl) {
  var me = this, ownerFC = me.ownerFocusableContainer, focusableIfDisabled = ownerFC && ownerFC.allowFocusingDisabledChildren, el;
  if (!me.focusable && !me.forceTabIndex) {
    return;
  }
  me.tabIndex = newTabIndex;
  if (me.destroying || me.destroyed || me.isDisabled() && !focusableIfDisabled) {
    return;
  }
  el = focusEl || me.getFocusEl();
  if (el) {
    if (el.$isFocusableEntity) {
      el.setTabIndex(newTabIndex);
    } else {
      if (el.isElement && el.dom) {
        el.setTabIndex(newTabIndex);
      }
    }
  }
}, onFocusEnter:function(e) {
  var me = this;
  if (me.destroying || me.destroyed) {
    return;
  }
  me.focusEnterEvent = e;
  me.containsFocus = true;
  if (me.hasListeners.focusenter) {
    me.fireEvent('focusenter', me, e);
  }
}, onFocusLeave:function(e) {
  var me = this;
  if (me.destroying || me.destroyed) {
    return;
  }
  me.focusEnterEvent = null;
  me.containsFocus = false;
  if (me.hasListeners.focusleave) {
    me.fireEvent('focusleave', me, e);
  }
}, onFocusMove:Ext.emptyFn, privates:{forceTabIndex:false, revertFocus:function() {
  var me = this, focusEvent = me.focusEnterEvent, activeElement = Ext.Element.getActiveElement(), focusTarget, fromComponent, reverted;
  if (focusEvent && !me.preventRefocus && me.el.contains(activeElement)) {
    fromComponent = focusEvent.fromComponent;
    if (fromComponent && (fromComponent.destroyed || fromComponent.isDestructing())) {
      focusTarget = document.body;
    } else {
      focusTarget = focusEvent.relatedTarget;
    }
    if (focusTarget === document.body) {
      fromComponent = me.findFocusTarget();
      if (fromComponent) {
        focusTarget = fromComponent.getFocusEl();
      }
    }
    if (focusTarget && focusTarget.$isFocusableEntity) {
      if (!focusTarget.destroyed && focusTarget.isFocusable()) {
        focusTarget.focus();
      }
    } else {
      if (Ext.getDoc().contains(focusTarget) && Ext.fly(focusTarget).isFocusable()) {
        fromComponent = Ext.Component.from(focusTarget);
        if (fromComponent) {
          fromComponent.revertFocusTo(focusTarget);
        } else {
          focusTarget.focus();
        }
      } else {
        if (focusEvent.fromComponent && focusEvent.fromComponent.focus) {
          reverted = focusEvent.fromComponent.focus();
          if (!reverted) {
            activeElement.blur();
          }
        }
      }
    }
  }
}, revertFocusTo:function(target) {
  target.focus();
}, findFocusTarget:function() {
  var me = this, parentAxis, candidate, len, i, focusTargets, focusIndex;
  if (me.preventRefocus) {
    return null;
  }
  for (parentAxis = [], candidate = me.getRefOwner(); candidate; candidate = candidate.getRefOwner()) {
    if (!candidate.isDisabled()) {
      parentAxis.unshift(candidate);
    }
  }
  for (i = 0, len = parentAxis.length; i < len; i++) {
    candidate = parentAxis[i];
    if (candidate.destroying || !candidate.isVisible()) {
      parentAxis.length = i;
      break;
    }
  }
  for (i = parentAxis.length - 1; i >= 0; i--) {
    candidate = parentAxis[i];
    focusTargets = Ext.ComponentQuery.query(':canfocus()', candidate);
    if (focusTargets.length) {
      focusIndex = Ext.Array.indexOf(focusTargets, Ext.ComponentManager.getActiveComponent());
      return focusTargets[focusIndex + 1] || focusTargets[focusIndex - 1] || focusTargets[0];
    }
    if (candidate.isFocusable && candidate.isFocusable()) {
      return candidate;
    }
  }
}, initFocusableElement:function(force) {
  var me = this, tabIndex = me.getTabIndex(), focusEl = me.getFocusEl();
  if (focusEl && !focusEl.$isFocusableEntity) {
    if (tabIndex != null && (force || me.canFocus(true))) {
      me.setTabIndex(tabIndex, focusEl);
    }
    if (!focusEl.dom.hasAttribute('data-componentid')) {
      focusEl.dom.setAttribute('data-componentid', me.id);
    }
  }
}, addFocusCls:function(e) {
  var focusCls = this.focusCls, el;
  el = this.getFocusClsEl();
  if (focusCls) {
    el = this.getFocusClsEl(e);
    if (el) {
      el.addCls(focusCls);
    }
  }
}, removeFocusCls:function(e) {
  var focusCls = this.focusCls, el;
  if (focusCls) {
    el = this.getFocusClsEl(e);
    if (el) {
      el.removeCls(focusCls);
    }
  }
}, handleFocusEvent:function(e) {
  var me = this, event;
  if (!me.focusable || me.destroying || me.destroyed) {
    return;
  }
  if (me.isFocusing(e)) {
    event = new Ext.event.Event(e.event);
    event.type = 'focus';
    event.relatedTarget = e.fromElement;
    event.target = e.toElement;
    me.onFocus(event);
  }
}, handleBlurEvent:function(e) {
  var me = this, event;
  if (!me.focusable || me.destroying || me.destroyed) {
    return;
  }
  if (e.toElement === document.body || me.isBlurring(e)) {
    event = new Ext.event.Event(e.event);
    event.type = 'blur';
    event.target = e.fromElement;
    event.relatedTarget = e.toElement;
    me.onBlur(event);
  }
}, isFocusing:function(e) {
  var focusEl = this.getFocusEl();
  if (focusEl) {
    if (focusEl.isFocusing) {
      return focusEl.isFocusing(e);
    } else {
      return focusEl.dom === document.activeElement && e.toElement === focusEl.dom && e.fromElement !== e.toElement;
    }
  }
  return false;
}, isBlurring:function(e) {
  var focusEl = this.getFocusEl();
  if (focusEl) {
    if (focusEl.isFocusing) {
      return focusEl.isBlurring(e);
    } else {
      return focusEl.dom !== document.activeElement && e.fromElement === focusEl.dom && e.fromElement !== e.toElement;
    }
  }
  return false;
}, blur:function() {
  var me = this, focusEl;
  if (!me.focusable || !me.canFocus()) {
    return;
  }
  focusEl = me.getFocusEl();
  if (focusEl) {
    me.blurring = true;
    focusEl.blur();
    delete me.blurring;
  }
}, isTabbable:function() {
  var me = this, focusEl;
  if (me.focusable) {
    focusEl = me.getFocusEl();
    if (focusEl && focusEl.isTabbable()) {
      return focusEl.isTabbable();
    }
  }
  return false;
}, disableTabbing:function() {
  var me = this, el = me.el, focusEl;
  if (me.destroying || me.destroyed) {
    return;
  }
  if (el) {
    el.saveTabbableState();
  }
  focusEl = me.getFocusEl();
  if (focusEl) {
    if (focusEl.$isFocusableEntity) {
      focusEl.disableTabbing();
    } else {
      if (focusEl.isElement && el && !el.contains(focusEl)) {
        focusEl.saveTabbableState();
      }
    }
  }
}, enableTabbing:function(reset) {
  var me = this, el = me.el, focusEl;
  if (me.destroying || me.destroyed) {
    return;
  }
  focusEl = me.getFocusEl();
  if (focusEl) {
    if (focusEl.$isFocusableEntity) {
      focusEl.enableTabbing();
    } else {
      if (focusEl.isElement && el && !el.contains(focusEl)) {
        focusEl.restoreTabbableState();
      }
    }
  }
  if (el) {
    el.restoreTabbableState({reset:reset});
  }
}}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Focusable'], function() {
  var keyboardModeCls = 'x-keyboard-mode', keyboardMode = false;
  Ext.setKeyboardMode = Ext.setKeyboardMode || function(keyboardMode) {
    Ext.keyboardMode = keyboardMode;
    Ext.getBody().toggleCls(keyboardModeCls, keyboardMode);
  };
  Ext.isTouchMode = function() {
    return Ext.now() - Ext.lastTouchTime < 500;
  };
  function syncKeyboardMode(e) {
    var type = e.type;
    if (type === 'pointermove') {
      keyboardMode = false;
    } else {
      keyboardMode = type === 'keydown';
      Ext.lastTouchTime = e.pointerType === 'touch' && Ext.now();
      Ext.setKeyboardMode(keyboardMode);
    }
  }
  Ext.onReady(function() {
    Ext.getWin().on({pointerdown:syncKeyboardMode, pointermove:syncKeyboardMode, keydown:syncKeyboardMode, capture:true, delegated:false});
    Ext.on('focus', function() {
      if (keyboardMode !== Ext.getBody().hasCls(keyboardModeCls)) {
        Ext.setKeyboardMode(keyboardMode);
      }
    });
  });
});
Ext.cmd.derive('Ext.mixin.Accessible', Ext.Mixin, {mixinConfig:{id:'accessible'}, config:{ariaAttributes:{$value:null, lazy:true}}, ariaEl:'el', privates:{getAriaLabelEl:function(reference) {
  var ids = [], refHolder, i, len, cmp, result;
  if (reference) {
    if (Ext.isFunction(reference)) {
      return reference.call(this);
    } else {
      if (!Ext.isArray(reference)) {
        reference = [reference];
      }
      refHolder = this.lookupReferenceHolder();
      if (refHolder) {
        for (i = 0, len = reference.length; i < len; i++) {
          cmp = refHolder.lookupReference(reference[i]);
          if (cmp) {
            ids.push(cmp.ariaEl.id);
          }
        }
      }
    }
  }
  return ids.length ? ids.join(' ') : null;
}}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Accessible'], 0);
Ext.cmd.derive('Ext.Widget', Ext.Evented, {alternateClassName:'Ext.Gadget', isWidget:true, factoryConfig:{creator:null, defaultProperty:'xtype', defaultType:'component', typeProperty:'xtype'}, element:{reference:'element'}, observableType:'component', cachedConfig:{cls:null, style:null, border:null, touchAction:null, eventHandlers:{focus:'handleFocusEvent', blur:'handleBlurEvent'}}, name:null, config:{renderTo:null, ui:null, userCls:null, ripple:null, hideMode:null, instanceCls:null}, eventedConfig:{width:null, 
height:null, hidden:null, disabled:null}, template:[], baseCls:null, classCls:null, classClsRoot:true, classClsList:[], clearPropertiesOnDestroy:'async', focusEl:'element', ariaEl:'element', spaceRe:/\s+/, noBorderCls:'x-noborder-trbl', borderedCls:'x-bordered', disabledCls:'x-disabled', heightedCls:'x-heighted', widthedCls:'x-widthed', constructor:function(config) {
  var me = this, baseCls = me.baseCls, renderTo = config && config.renderTo, controller;
  me.$iid = ++Ext.$nextIid;
  if (baseCls == null || baseCls === true) {
    me.baseCls = me.classCls || 'x-' + me.xtype;
  }
  if (config && config.controller || me.config.controller) {
    me.referenceHolder = true;
  }
  me.initId(config);
  me.initElement();
  if (renderTo) {
    config = Ext.apply({}, config);
    delete config.renderTo;
  }
  me.mixins.observable.constructor.call(me, config);
  if (me.focusable) {
    me.initFocusableEvents(true);
  }
  if (renderTo) {
    me.setRenderTo(renderTo);
  }
  me.syncUiCls();
  Ext.ComponentManager.register(me);
  controller = me.getController();
  if (controller) {
    controller.init(me);
  }
}, afterCachedConfig:function() {
  var me = this, prototype = me.self.prototype, referenceList = me.referenceList, renderElement = me.renderElement, renderTemplate, element, i, ln, reference, elements;
  prototype.renderTemplate = renderTemplate = document.createDocumentFragment();
  renderTemplate.appendChild(renderElement.clone(true, true));
  elements = renderTemplate.querySelectorAll('[id]');
  for (i = 0, ln = elements.length; i < ln; i++) {
    element = elements[i];
    element.removeAttribute('id');
  }
  for (i = 0, ln = referenceList.length; i < ln; i++) {
    reference = referenceList[i];
    me[reference].dom.removeAttribute('reference');
  }
}, applyHidden:function(hidden) {
  return !!hidden;
}, applyDisabled:function(disabled) {
  return !!disabled;
}, updateDisabled:function(disabled) {
  var me = this, container = me.ownerFocusableContainer;
  if (container) {
    if (disabled) {
      if (!container.beforeFocusableChildDisable.$nullFn) {
        container.beforeFocusableChildDisable(me);
      }
    } else {
      if (!container.beforeFocusableChildEnable.$nullFn) {
        container.beforeFocusableChildEnable(me);
      }
    }
  }
  me.element.toggleCls(me.disabledCls, disabled);
  if (me.focusable) {
    if (disabled) {
      me.disableFocusable();
    } else {
      me.enableFocusable();
    }
  }
  if (container) {
    if (disabled) {
      if (!container.onFocusableChildDisable.$nullFn) {
        container.onFocusableChildDisable(me);
      }
    } else {
      if (!container.onFocusableChildEnable.$nullFn) {
        container.onFocusableChildEnable(me);
      }
    }
  }
}, disable:function() {
  this.setDisabled(true);
}, enable:function() {
  this.setDisabled(false);
}, isDisabled:function() {
  return this.getDisabled();
}, isEnabled:function() {
  return !this.getDisabled();
}, applyTouchAction:function(touchAction, oldTouchAction) {
  if (oldTouchAction != null) {
    touchAction = Ext.merge({}, oldTouchAction, touchAction);
  }
  return touchAction;
}, applyWidth:function(width) {
  return this.filterLengthValue(width);
}, applyHeight:function(height) {
  return this.filterLengthValue(height);
}, updateBorder:function(border) {
  var me = this;
  border = border || border === null;
  me.toggleCls(me.noBorderCls, !border);
  me.toggleCls(me.borderedCls, !!border);
}, clearListeners:function() {
  var me = this;
  me.mixins.observable.clearListeners.call(me);
  me.mixins.componentDelegation.clearDelegatedListeners.call(me);
}, destroy:function() {
  var me = this;
  me.isDestroying = me.destroying = true;
  me.doDestroy();
  me.clearListeners();
  me.isDestroying = me.destroying = false;
  me.mixins.componentDelegation.destroyComponentDelegation.call(me);
  Ext.Evented.prototype.destroy.call(this);
}, doDestroy:function() {
  var me = this, referenceList = me.referenceList, container = me.ownerFocusableContainer, i, ln, reference;
  me.ownerCmp = null;
  if (container && !container.onFocusableChildDestroy.$nullFn) {
    container.onFocusableChildDestroy(me);
  }
  for (i = 0, ln = referenceList.length; i < ln; i++) {
    reference = referenceList[i];
    if (me.hasOwnProperty(reference)) {
      me[reference].destroy();
      me[reference] = null;
    }
  }
  me.destroyBindable();
  Ext.ComponentManager.unregister(me);
}, doFireEvent:function(eventName, args, bubbles) {
  var me = this, ret;
  ret = me.mixins.observable.doFireEvent.call(me, eventName, args, bubbles);
  if (ret !== false && !me.destroyed) {
    ret = me.mixins.componentDelegation.doFireDelegatedEvent.call(me, eventName, args);
  }
  return ret;
}, getBubbleTarget:function() {
  return this.getRefOwner();
}, getElementConfig:function() {
  var me = this, el = me.element;
  if (!('children' in el)) {
    el = Ext.apply({children:me.getTemplate()}, el);
  }
  return el;
}, getSize:function() {
  return this.el.getSize();
}, getTemplate:function() {
  return Ext.clone(this.template);
}, getClassCls:function() {
  var proto = this.self.prototype, prototype = proto, classes, classCls, i, ln;
  while (prototype) {
    classCls = prototype.hasOwnProperty('classCls') ? prototype.classCls : null;
    if (classCls) {
      if (classCls instanceof Array) {
        for (i = 0, ln = classCls.length; i < ln; i++) {
          (classes || (classes = [])).push(classCls[i]);
        }
      } else {
        (classes || (classes = [])).push(classCls);
      }
    }
    if (prototype.classClsRoot && prototype.hasOwnProperty('classClsRoot')) {
      break;
    }
    prototype = prototype.superclass;
  }
  if (classes) {
    proto.classClsList = classes;
  }
  return classes;
}, hide:function() {
  this.setHidden(true);
}, initElement:function() {
  var me = this, prototype = me.self.prototype, id = me.getId(), referenceList = me.referenceList = me.referenceList = [], isFirstInstance = !prototype.hasOwnProperty('renderTemplate'), uiReferences = prototype.hasOwnProperty('uiReferences') ? prototype.uiReferences : prototype.uiReferences = {element:''}, renderTemplate, renderElement, renderConfig, element, referenceNodes, i, ln, referenceNode, reference, classCls, uiCls, baseCls, referenceElement;
  if (isFirstInstance) {
    renderTemplate = document.createDocumentFragment();
    renderConfig = me.processElementConfig.call(prototype);
    renderElement = Ext.Element.create(renderConfig, true);
    renderTemplate.appendChild(renderElement);
    referenceNodes = renderTemplate.querySelectorAll('[uiCls]');
    for (i = 0, ln = referenceNodes.length; i < ln; i++) {
      referenceNode = referenceNodes[i];
      reference = referenceNode.getAttribute('reference');
      uiCls = referenceNode.getAttribute('uiCls');
      uiReferences[reference] = uiCls;
      referenceNode.removeAttribute('uiCls');
    }
  } else {
    renderTemplate = me.renderTemplate.cloneNode(true);
    renderElement = renderTemplate.firstChild;
  }
  referenceNodes = renderTemplate.querySelectorAll('[reference]');
  for (i = 0, ln = referenceNodes.length; i < ln; i++) {
    referenceNode = referenceNodes[i];
    reference = referenceNode.getAttribute('reference');
    if (!isFirstInstance) {
      referenceNode.removeAttribute('reference');
    }
    if (reference === 'element') {
      referenceNode.id = id;
      element = me.el = me.addElementReference(reference, referenceNode);
      element.dom.setAttribute('data-componentid', id);
      if (isFirstInstance) {
        classCls = me.getClassCls();
        if (classCls) {
          element.addCls(classCls);
        }
        baseCls = me.baseCls;
        if (baseCls && baseCls !== me.classCls) {
          element.addCls(baseCls);
        }
      }
    } else {
      uiCls = uiReferences[reference];
      if (uiCls && isFirstInstance) {
        referenceElement = me.addElementReference(reference, referenceNode);
        me.initUiReference(reference, uiCls, false);
      } else {
        me.addElementReferenceOnDemand(reference, referenceNode);
      }
    }
    if (reference === me.focusEl) {
      me.addElementReference('focusEl', referenceNode);
    }
    if (reference === me.ariaEl) {
      me.addElementReferenceOnDemand('ariaEl', referenceNode);
    }
    referenceList.push(reference);
  }
  if (renderElement === element.dom) {
    me.renderElement = element;
  } else {
    me.addElementReferenceOnDemand('renderElement', renderElement);
  }
  renderElement.setAttribute(me.dataXid, me.$iid);
}, dataXid:'data-' + 'x-'.substr(0, 'x-'.length - 1) + 'id', is:function(selector) {
  return Ext.ComponentQuery.is(this, selector);
}, isHidden:function(deep) {
  var hidden = !!this.getHidden(), owner;
  if (!hidden && deep) {
    owner = this.getRefOwner();
    while (owner && owner !== deep && !hidden) {
      hidden = !!owner.getHidden();
      owner = owner.getRefOwner();
    }
  }
  return hidden;
}, isVisible:function(deep) {
  return this.rendered && !this.destroyed && !this.isHidden(deep);
}, isXType:function(xtype, shallow) {
  return shallow ? Ext.Array.indexOf(this.xtypes, xtype) !== -1 : !!this.xtypesMap[xtype];
}, lookupTpl:function(name) {
  return Ext.XTemplate.getTpl(this, name);
}, owns:function(element) {
  var result = false, cmp;
  if (element.isEvent) {
    element = element.target;
  } else {
    if (element.isElement) {
      element = element.dom;
    }
  }
  cmp = Ext.Component.from(element);
  if (cmp) {
    result = cmp === this || !!cmp.up(this);
  }
  return result;
}, render:function(container, insertBeforeElement) {
  if (container && container.isWidget) {
    container = container.el;
  }
  var dom = this.renderElement.dom, containerDom = Ext.getDom(container), insertBeforeChildDom;
  if (Ext.isNumber(insertBeforeChildDom)) {
    insertBeforeElement = containerDom.childNodes[insertBeforeElement];
  }
  insertBeforeChildDom = Ext.getDom(insertBeforeElement);
  if (containerDom) {
    if (insertBeforeChildDom) {
      containerDom.insertBefore(dom, insertBeforeChildDom);
    } else {
      containerDom.appendChild(dom);
    }
    this.setRendered(Ext.getBody().contains(dom), true);
  }
}, toggleCls:function(className, state) {
  this.element.toggleCls(className, state);
  return this;
}, resolveListenerScope:function(defaultScope, skipThis) {
  return this.mixins.inheritable.resolveListenerScope.call(this, defaultScope, skipThis);
}, setSize:function(width, height) {
  if (width && typeof width === 'object') {
    return this.setSize(width.width, width.height);
  }
  if (width !== undefined) {
    this.setWidth(width);
  }
  if (height !== undefined) {
    this.setHeight(height);
  }
}, show:function() {
  this.setHidden(false);
}, addCls:function(cls, prefix, suffix) {
  if (!this.destroyed) {
    this.el.replaceCls(null, cls, prefix, suffix);
  }
}, applyCls:function(cls) {
  return cls && Ext.dom.Element.splitCls(cls);
}, applyUi:function(ui) {
  return this.parseUi(ui, true);
}, removeCls:function(cls, prefix, suffix) {
  if (!this.destroyed) {
    this.el.replaceCls(cls, null, prefix, suffix);
  }
}, replaceCls:function(oldCls, newCls, prefix, suffix) {
  if (!this.destroyed) {
    this.el.replaceCls(oldCls, newCls, prefix, suffix);
  }
}, hasCls:function(className) {
  return this.el.hasCls(className);
}, updateCls:function(newCls, oldCls) {
  this.element.replaceCls(oldCls, newCls);
}, updateHidden:function(hidden) {
  var me = this, element = me.renderElement, container = me.ownerFocusableContainer;
  if (container) {
    if (hidden) {
      if (!container.beforeFocusableChildHide.$nullFn) {
        container.beforeFocusableChildHide(me);
      }
    } else {
      if (!container.beforeFocusableChildShow.$nullFn) {
        container.beforeFocusableChildShow(me);
      }
    }
  } else {
    if (hidden) {
      me.revertFocus();
    }
  }
  if (element && !element.destroyed) {
    if (hidden) {
      element.hide();
    } else {
      element.show();
    }
  }
  if (me.focusableContainer && me.activateFocusableContainer) {
    me.activateFocusableContainer(!hidden);
  }
  if (container) {
    if (hidden) {
      if (!container.onFocusableChildHide.$nullFn) {
        container.onFocusableChildHide(me);
      }
    } else {
      if (!container.onFocusableChildShow.$nullFn) {
        container.onFocusableChildShow(me);
      }
    }
  }
}, updateRipple:function(ripple) {
  var me = this, el = me.el;
  if (el) {
    el.un('touchstart', 'onRippleStart', me);
    el.un('touchend', 'onRippleStart', me);
    el.destroyAllRipples();
    if (ripple.release) {
      el.on('touchend', 'onRippleStart', me);
    } else {
      el.on('touchstart', 'onRippleStart', me);
    }
  }
}, shouldRipple:function(e) {
  var me = this, disabled = me.getDisabled && me.getDisabled(), el = me.el, ripple = !disabled && me.getRipple(), target;
  if (ripple && e) {
    target = e.getTarget(me.noRippleSelector);
    if (target) {
      if (el.dom === target || el.contains(target)) {
        ripple = null;
      }
    }
  }
  return ripple;
}, onRippleStart:function(e) {
  var ripple = this.shouldRipple(e);
  if (e.button === 0 && ripple) {
    this.el.ripple(e, ripple);
  }
}, applyStyle:function(style, oldStyle) {
  if (oldStyle && style === oldStyle && Ext.isObject(oldStyle)) {
    style = Ext.apply({}, style);
  }
  this.element.applyStyles(style);
  return null;
}, updateRenderTo:function(newContainer) {
  this.render(newContainer);
}, updateTouchAction:function(touchAction) {
  var name, childEl, value, hasRootActions;
  for (name in touchAction) {
    childEl = this[name];
    value = touchAction[name];
    if (childEl && childEl.isElement) {
      childEl.setTouchAction(value);
    } else {
      hasRootActions = true;
    }
  }
  if (hasRootActions) {
    this.el.setTouchAction(touchAction);
  }
}, updateUi:function() {
  if (!this.isConfiguring) {
    this.syncUiCls();
  }
}, updateWidth:function(width) {
  var el = this.el;
  el.setWidth(width);
  el.toggleCls(this.widthedCls, width != null && width !== 'auto');
}, updateHeight:function(height) {
  var el = this.el;
  el.setHeight(height);
  el.toggleCls(this.heightedCls, height != null && height !== 'auto');
}, isWidthed:function() {
  var width = this.getWidth();
  return width != null && width !== 'auto';
}, isHeighted:function() {
  var height = this.getHeight();
  return height != null && height !== 'auto';
}, up:function(selector, limit) {
  var result = this.getRefOwner(), limitSelector = typeof limit === 'string', limitCount = typeof limit === 'number', limitComponent = limit && limit.isComponent, steps = 0;
  if (selector) {
    for (; result; result = result.getRefOwner()) {
      if (result.destroyed) {
        return null;
      }
      steps++;
      if (selector.isComponent || selector.isWidget) {
        if (result === selector) {
          return result;
        }
      } else {
        if (Ext.ComponentQuery.is(result, selector)) {
          return result;
        }
      }
      if (limitSelector && result.is(limit)) {
        return;
      }
      if (limitCount && steps === limit) {
        return;
      }
      if (limitComponent && result === limit) {
        return;
      }
    }
  }
  return result;
}, updateLayout:Ext.emptyFn, updateInstanceCls:function(instanceCls, oldInstanceCls) {
  var me = this, el = me.el, classClsList = me.classClsList, Array = Ext.Array, uiReferences = me.uiReferences, referenceName, referenceElement, i, ln, cls, uiCls;
  if (oldInstanceCls) {
    el.removeCls(oldInstanceCls);
    oldInstanceCls = Array.from(oldInstanceCls);
    for (i = 0, ln = oldInstanceCls.length; i < ln; i++) {
      cls = oldInstanceCls[i];
      Array.remove(classClsList, cls);
      for (referenceName in uiReferences) {
        referenceElement = me[referenceName];
        uiCls = uiReferences[referenceName];
        referenceElement.removeCls(cls + '-' + uiCls);
      }
    }
  }
  if (instanceCls) {
    el.addCls(instanceCls);
    instanceCls = Array.from(instanceCls);
    me.classClsList = classClsList.concat(instanceCls);
    for (i = 0, ln = instanceCls.length; i < ln; i++) {
      cls = instanceCls[i];
      for (referenceName in uiReferences) {
        referenceElement = me[referenceName];
        uiCls = uiReferences[referenceName];
        referenceElement.addCls(cls + '-' + uiCls);
      }
    }
  }
  if (!me.isConfiguring) {
    me.syncUiCls();
  }
}, getBaseCls:function() {
  return this.baseCls;
}, privates:{_hideModes:{clip:'CLIP', display:'DISPLAY', offsets:'OFFSETS', opacity:'OPACITY', visibility:'VISIBILITY'}, noRippleSelector:'.x-no-ripple', addElementReferenceOnDemand:function(name, domNode) {
  if (this._elementListeners[name]) {
    this.addElementReference(name, domNode);
  } else {
    Ext.Object.defineProperty(this, name, {get:function() {
      if (this.destroyed) {
        return;
      }
      delete this[name];
      return this.addElementReference(name, domNode);
    }, configurable:true});
  }
}, addElementReference:function(name, domNode) {
  var me = this, referenceEl = me[name] = Ext.get(domNode), listeners = me._elementListeners[name], eventName, listener;
  referenceEl.skipGarbageCollection = true;
  referenceEl.component = me;
  if (listeners) {
    listeners = Ext.clone(listeners);
    for (eventName in listeners) {
      listener = listeners[eventName];
      if (typeof listener === 'object') {
        listener.scope = me;
      }
    }
    listeners.scope = me;
    referenceEl.on(listeners);
  }
  return referenceEl;
}, detachFromBody:function() {
  Ext.getDetachedBody().appendChild(this.element, true);
  this.isDetached = true;
}, reattachToBody:function() {
  var detachedBody;
  if (this.isDetached) {
    detachedBody = Ext.getDetachedBody();
    if (detachedBody.contains(this.element)) {
      Ext.getBody().appendChild(this.element, true);
    }
  }
  this.isDetached = false;
}, doAddListener:function(name, fn, scope, options, order, caller, manager) {
  var me = this, elementName = options && options.element, delegate = options && options.delegate, listeners, eventOptions, option;
  if (elementName) {
    listeners = {};
    listeners[name] = fn;
    if (scope) {
      listeners.scope = scope;
    }
    eventOptions = Ext.Element.prototype.$eventOptions;
    for (option in options) {
      if (eventOptions[option]) {
        listeners[option] = options[option];
      }
    }
    me.mon(me[elementName], listeners);
    return;
  } else {
    if (delegate) {
      me.mixins.componentDelegation.addDelegatedListener.call(me, name, fn, scope, options, order, caller, manager);
      return;
    }
  }
  Ext.Evented.prototype.doAddListener.call(this, name, fn, scope, options, order, caller, manager);
}, doRemoveListener:function(eventName, fn, scope) {
  var me = this;
  me.mixins.observable.doRemoveListener.call(me, eventName, fn, scope);
  me.mixins.componentDelegation.removeDelegatedListener.call(me, eventName, fn, scope);
}, filterLengthValue:function(value) {
  if (!value && value !== 0) {
    return null;
  }
  return value;
}, initElementListeners:function(elementConfig) {
  var prototype = this, superPrototype = prototype.self.superclass, superElementListeners = superPrototype._elementListeners, reference = elementConfig.reference, children = elementConfig.children, elementListeners, listeners, superListeners, ln, i;
  if (prototype.hasOwnProperty('_elementListeners')) {
    elementListeners = prototype._elementListeners;
  } else {
    elementListeners = prototype._elementListeners = superElementListeners ? Ext.Object.chain(superElementListeners) : {};
  }
  if (reference) {
    listeners = elementConfig.listeners;
    if (listeners) {
      if (superElementListeners) {
        superListeners = superElementListeners[reference];
        if (superListeners) {
          listeners = Ext.Object.chain(superListeners);
          Ext.apply(listeners, elementConfig.listeners);
        }
      }
      elementListeners[reference] = listeners;
      elementConfig.listeners = null;
    }
  }
  if (children) {
    for (i = 0, ln = children.length; i < ln; i++) {
      prototype.initElementListeners(children[i]);
    }
  }
}, initId:function(config) {
  var me = this, defaultConfig = me.config, id = config && config.id || defaultConfig && defaultConfig.id;
  if (id) {
    me.setId(id);
    me.id = id;
  } else {
    me.getId();
  }
}, measure:function(dimension) {
  return this.element.measure(dimension);
}, processElementConfig:function() {
  var prototype = this, superPrototype = prototype.self.superclass, elementConfig;
  if (prototype.hasOwnProperty('_elementConfig')) {
    elementConfig = prototype._elementConfig;
  } else {
    elementConfig = prototype._elementConfig = prototype.getElementConfig();
    if (superPrototype.isWidget) {
      prototype.processElementConfig.call(superPrototype);
    }
    prototype.initElementListeners(elementConfig);
  }
  return elementConfig;
}, parseUi:function(ui, asString) {
  ui = Ext.String.splitWords(ui);
  if (asString) {
    ui = ui.join(' ');
  }
  return ui;
}, addUi:function(ui) {
  this.setUi(this.doAddUi(ui, this.getUi()));
}, doAddUi:function(ui, oldUi) {
  var me = this, newUi = null, i, u, len;
  if (ui) {
    ui = me.parseUi(ui);
    len = ui.length;
    oldUi = me.parseUi(oldUi);
    for (i = 0; i < len; i++) {
      u = ui[i];
      if (Ext.Array.indexOf(oldUi, u) === -1) {
        oldUi.push(u);
      }
    }
    newUi = oldUi.join(' ');
  }
  return newUi;
}, removeUi:function(ui) {
  this.setUi(this.doRemoveUi(ui, this.getUi()));
}, doRemoveUi:function(ui, oldUi) {
  var me = this, newUi = null, i, u, index, len;
  if (ui) {
    ui = me.parseUi(ui);
    len = ui.length;
    oldUi = me.parseUi(oldUi);
    for (i = 0; i < len; i++) {
      u = ui[i];
      index = Ext.Array.indexOf(oldUi, u);
      if (index !== -1) {
        oldUi.splice(index, 1);
      }
    }
    newUi = oldUi.join(' ');
  }
  return newUi;
}, initUiReference:function(referenceName, uiCls, isInstance) {
  var me = this, referenceElement = me[referenceName], baseCls = me.baseCls, classClsList = me.classClsList, cls = [], i, n;
  isInstance = isInstance !== false;
  if (isInstance) {
    if (!me.hasOwnProperty('uiReferences')) {
      me.uiReferences = Ext.clone(me.uiReferences);
    }
    me.uiReferences[referenceName] = uiCls;
  }
  uiCls = '-' + uiCls;
  if (baseCls && baseCls !== me.classCls) {
    cls.push(baseCls + uiCls);
  }
  if (classClsList) {
    for (i = 0, n = classClsList.length; i < n; i++) {
      cls.push(classClsList[i] + uiCls);
    }
  }
  referenceElement.addCls(cls);
  if (isInstance && !me.isConfiguring) {
    me.syncUiCls();
  }
}, syncUiCls:function(refs) {
  var me = this, ui = me.getUi(), currentUiCls = me.currentUiCls || (me.currentUiCls = {}), baseCls = me.baseCls, uiReferences = refs || me.uiReferences, classClsList = me.classClsList, classClsListLen = classClsList ? classClsList.length : 0, uiCls, uiLen, refName, refEl, cls, suffix, uiSuffix, i, j;
  if (ui) {
    ui = me.parseUi(ui);
    uiLen = ui.length;
  }
  for (refName in uiReferences) {
    refEl = me[refName];
    uiCls = [];
    if (refEl) {
      cls = currentUiCls[refName];
      if (cls) {
        refEl.removeCls(cls);
      }
      if (ui) {
        suffix = uiReferences[refName];
        suffix = suffix ? '-' + suffix : '';
        for (i = 0; i < uiLen; i++) {
          uiSuffix = '-' + ui[i] + suffix;
          if (baseCls && baseCls !== me.classCls) {
            uiCls.push(baseCls + uiSuffix);
          }
          if (classClsList) {
            for (j = 0; j < classClsListLen; j++) {
              uiCls.push(classClsList[j] + uiSuffix);
            }
          }
        }
        refEl.addCls(uiCls);
        currentUiCls[refName] = uiCls;
      }
    }
  }
}, applyHideMode:function(mode) {
  return mode || 'display';
}, updateHideMode:function(mode) {
  var me = this, el = me.el, shouldToggle = me.getHidden();
  if (shouldToggle) {
    el.show();
  }
  me.renderElement.setVisibilityMode(Ext.Element[me._hideModes[mode]]);
  if (shouldToggle) {
    el.hide();
  }
}, updateUserCls:function(newCls, oldCls) {
  this.element.replaceCls(oldCls, newCls);
}}}, 1, ['widget'], ['widget'], {'widget':true}, ['widget.widget'], [[Ext.mixin.Inheritable.prototype.mixinId || Ext.mixin.Inheritable.$className, Ext.mixin.Inheritable], [Ext.mixin.Bindable.prototype.mixinId || Ext.mixin.Bindable.$className, Ext.mixin.Bindable], [Ext.mixin.ComponentDelegation.prototype.mixinId || Ext.mixin.ComponentDelegation.$className, Ext.mixin.ComponentDelegation], [Ext.mixin.Pluggable.prototype.mixinId || Ext.mixin.Pluggable.$className, Ext.mixin.Pluggable], [Ext.mixin.Keyboard.prototype.mixinId || 
Ext.mixin.Keyboard.$className, Ext.mixin.Keyboard], [Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable], [Ext.mixin.Focusable.prototype.mixinId || Ext.mixin.Focusable.$className, Ext.mixin.Focusable], [Ext.mixin.Accessible.prototype.mixinId || Ext.mixin.Accessible.$className, Ext.mixin.Accessible]], [Ext, 'Widget', Ext, 'Gadget'], function(Widget) {
  var prototype = Widget.prototype;
  (prototype.$elementEventOptions = Ext.Object.chain(Ext.Element.prototype.$eventOptions)).element = 1;
  (prototype.$eventOptions = Ext.Object.chain(prototype.$eventOptions)).delegate = 1;
  Ext.updateWidget = Ext.Factory.widget.update;
});
Ext.define('Ext.overrides.Widget', {override:'Ext.Widget', $configStrict:false, isComponent:true, liquidLayout:true, rendered:true, rendering:true, config:{renderTo:null}, constructor:function(config) {
  var me = this, renderTo;
  (arguments.callee.$previous || Ext.Evented.prototype.constructor).call(this, config);
  me.getComponentLayout();
  renderTo = me.getRenderTo();
  if (renderTo) {
    me.render(renderTo);
  }
}, addClsWithUI:function(cls) {
  this.el.addCls(cls);
}, afterComponentLayout:Ext.emptyFn, updateLayout:function() {
  var owner = this.getRefOwner();
  if (owner) {
    owner.updateLayout();
  }
}, destroy:function() {
  var me = this, ownerCt = me.ownerCt;
  if (ownerCt && ownerCt.remove) {
    ownerCt.remove(me, false);
  }
  (arguments.callee.$previous || Ext.Evented.prototype.destroy).call(this);
}, finishRender:function() {
  this.rendering = false;
  this.initBindable();
  this.initKeyMap();
}, getAnimationProps:function() {
  return {};
}, getComponentLayout:function() {
  var me = this, layout = me.componentLayout;
  if (!layout) {
    layout = me.componentLayout = new Ext.layout.component.Auto;
    layout.setOwner(me);
  }
  return layout;
}, getEl:function() {
  return this.element;
}, getTdCls:function() {
  return 'x-' + this.getTdType() + '-' + (this.ui || 'default') + '-cell';
}, getTdType:function() {
  return this.xtype;
}, getItemId:function() {
  return this.itemId || this.id;
}, getSizeModel:function() {
  return Ext.Component.prototype.getSizeModel.apply(this, arguments);
}, onAdded:function(container, pos, instanced) {
  var me = this;
  me.ownerCt = container;
  me.onInheritedAdd(me, instanced);
  me.isDetached = false;
}, onRemoved:function(destroying) {
  this.onInheritedRemove(destroying);
  this.ownerCt = this.ownerLayout = null;
}, parseBox:function(box) {
  return Ext.Element.parseBox(box);
}, removeClsWithUI:function(cls) {
  this.el.removeCls(cls);
}, render:function(container, position) {
  var me = this, element = me.element, proto = Ext.Component.prototype, nextSibling;
  if (!me.ownerCt || me.floating) {
    if (Ext.scopeCss) {
      element.addCls(proto.rootCls);
    }
    element.addCls(proto.borderBoxCls);
  }
  if (position) {
    nextSibling = container.childNodes[position];
    if (nextSibling) {
      Ext.fly(container).insertBefore(element, nextSibling);
      return;
    }
  }
  Ext.fly(container).appendChild(element);
  me.finishRender();
}, setPosition:function(x, y) {
  this.el.setLocalXY(x, y);
}, up:function() {
  return Ext.Component.prototype.up.apply(this, arguments);
}, isAncestor:function() {
  return Ext.Component.prototype.isAncestor.apply(this, arguments);
}, onFocusEnter:function() {
  return Ext.Component.prototype.onFocusEnter.apply(this, arguments);
}, onFocusLeave:function() {
  return Ext.Component.prototype.onFocusLeave.apply(this, arguments);
}, isLayoutChild:function(candidate) {
  var ownerCt = this.ownerCt;
  return ownerCt ? ownerCt === candidate || ownerCt.isLayoutChild(candidate) : false;
}, privates:{doAddListener:function(name, fn, scope, options, order, caller, manager) {
  if (name == 'painted' || name == 'resize') {
    this.element.doAddListener(name, fn, scope || this, options, order);
  }
  (arguments.callee.$previous || Ext.Evented.prototype.doAddListener).call(this, name, fn, scope, options, order, caller, manager);
}, doRemoveListener:function(name, fn, scope) {
  if (name == 'painted' || name == 'resize') {
    this.element.doRemoveListener(name, fn, scope);
  }
  (arguments.callee.$previous || Ext.Evented.prototype.doRemoveListener).call(this, name, fn, scope);
}}}, function(Cls) {
  var prototype = Cls.prototype;
  if (Ext.isIE9m) {
    prototype.addElementReferenceOnDemand = prototype.addElementReference;
  }
});
Ext.cmd.derive('Ext.ProgressBase', Ext.Base, {mixinId:'progressbase', config:{value:0, textTpl:null}, applyTextTpl:function(textTpl) {
  if (!textTpl.isTemplate) {
    textTpl = new Ext.XTemplate(textTpl);
  }
  return textTpl;
}, applyValue:function(value) {
  return value || 0;
}}, 0, 0, 0, 0, 0, 0, [Ext, 'ProgressBase'], 0);
Ext.cmd.derive('Ext.util.Format', Ext.Base, function() {
  var me;
  return {singleton:true, defaultDateFormat:'m/d/Y', thousandSeparator:',', decimalSeparator:'.', currencyPrecision:2, currencySign:'$', currencySpacer:'', percentSign:'%', currencyAtEnd:false, stripTagsRe:/<\/?[^>]+>/gi, stripScriptsRe:/(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig, nl2brRe:/\r?\n/g, hashRe:/#+$/, allHashes:/^#+$/, formatPattern:/[\d,\.#]+/, formatCleanRe:/[^\d\.#]/g, I18NFormatCleanRe:null, formatFns:{}, constructor:function() {
    me = this;
  }, nbsp:function(value, strict) {
    strict = strict !== false;
    if (strict ? value === '' || value == null : !value) {
      value = ' ';
    }
    return value;
  }, undef:function(value) {
    return value !== undefined ? value : '';
  }, defaultValue:function(value, defaultValue) {
    return value !== undefined && value !== '' ? value : defaultValue;
  }, substr:'ab'.substr(-1) != 'b' ? function(value, start, length) {
    var str = String(value);
    return start < 0 ? str.substr(Math.max(str.length + start, 0), length) : str.substr(start, length);
  } : function(value, start, length) {
    return String(value).substr(start, length);
  }, lowercase:function(value) {
    return String(value).toLowerCase();
  }, uppercase:function(value) {
    return String(value).toUpperCase();
  }, usMoney:function(value) {
    return me.currency(value, '$', 2);
  }, currency:function(value, currencySign, decimals, end, currencySpacer) {
    var negativeSign = '', format = ',0', i = 0;
    value = value - 0;
    if (value < 0) {
      value = -value;
      negativeSign = '-';
    }
    decimals = Ext.isDefined(decimals) ? decimals : me.currencyPrecision;
    format += decimals > 0 ? '.' : '';
    for (; i < decimals; i++) {
      format += '0';
    }
    value = me.number(value, format);
    if (currencySpacer == null) {
      currencySpacer = me.currencySpacer;
    }
    if ((end || me.currencyAtEnd) === true) {
      return Ext.String.format('{0}{1}{2}{3}', negativeSign, value, currencySpacer, currencySign || me.currencySign);
    } else {
      return Ext.String.format('{0}{1}{2}{3}', negativeSign, currencySign || me.currencySign, currencySpacer, value);
    }
  }, date:function(value, format) {
    if (!value) {
      return '';
    }
    if (!Ext.isDate(value)) {
      value = new Date(Date.parse(value));
    }
    return Ext.Date.dateFormat(value, format || Ext.Date.defaultFormat);
  }, dateRenderer:function(format) {
    return function(v) {
      return me.date(v, format);
    };
  }, hex:function(value, digits) {
    var s = parseInt(value || 0, 10).toString(16);
    if (digits) {
      if (digits < 0) {
        digits = -digits;
        if (s.length > digits) {
          s = s.substring(s.length - digits);
        }
      }
      while (s.length < digits) {
        s = '0' + s;
      }
    }
    return s;
  }, or:function(value, orValue) {
    return value || orValue;
  }, pick:function(value, firstValue, secondValue) {
    if (Ext.isNumber(value)) {
      var ret = arguments[value + 1];
      if (ret) {
        return ret;
      }
    }
    return value ? secondValue : firstValue;
  }, lessThanElse:function(value, threshold, below, above, equal) {
    var v = Ext.Number.from(value, 0), t = Ext.Number.from(threshold, 0), missing = !Ext.isDefined(equal);
    return v < t ? below : v > t ? above : missing ? above : equal;
  }, sign:function(value, negative, positive, zero) {
    if (zero === undefined) {
      zero = positive;
    }
    return me.lessThanElse(value, 0, negative, positive, zero);
  }, stripTags:function(value) {
    return !value ? value : String(value).replace(me.stripTagsRe, '');
  }, stripScripts:function(value) {
    return !value ? value : String(value).replace(me.stripScriptsRe, '');
  }, fileSize:function() {
    var byteLimit = 1024, kbLimit = 1048576, mbLimit = 1073741824;
    return function(size) {
      var out;
      if (size < byteLimit) {
        if (size === 1) {
          out = '1 byte';
        } else {
          out = size + ' bytes';
        }
      } else {
        if (size < kbLimit) {
          out = Math.round(size * 10 / byteLimit) / 10 + ' KB';
        } else {
          if (size < mbLimit) {
            out = Math.round(size * 10 / kbLimit) / 10 + ' MB';
          } else {
            out = Math.round(size * 10 / mbLimit) / 10 + ' GB';
          }
        }
      }
      return out;
    };
  }(), math:function() {
    var fns = {};
    return function(v, a) {
      if (!fns[a]) {
        fns[a] = Ext.functionFactory('v', 'return v ' + a + ';');
      }
      return fns[a](v);
    };
  }(), round:function(value, precision) {
    var result = Number(value);
    if (typeof precision === 'number') {
      precision = Math.pow(10, precision);
      result = Math.round(value * precision) / precision;
    } else {
      if (precision === undefined) {
        result = Math.round(result);
      }
    }
    return result;
  }, number:function(v, formatString) {
    if (!formatString) {
      return v;
    }
    if (isNaN(v)) {
      return '';
    }
    var formatFn = me.formatFns[formatString];
    if (!formatFn) {
      var originalFormatString = formatString, comma = me.thousandSeparator, decimalSeparator = me.decimalSeparator, precision = 0, trimPart = '', hasComma, splitFormat, extraChars, trimTrailingZeroes, code, len;
      if (formatString.substr(formatString.length - 2) === '/i') {
        if (!me.I18NFormatCleanRe || me.lastDecimalSeparator !== decimalSeparator) {
          me.I18NFormatCleanRe = new RegExp('[^\\d\\' + decimalSeparator + '#]', 'g');
          me.lastDecimalSeparator = decimalSeparator;
        }
        formatString = formatString.substr(0, formatString.length - 2);
        hasComma = formatString.indexOf(comma) !== -1;
        splitFormat = formatString.replace(me.I18NFormatCleanRe, '').split(decimalSeparator);
      } else {
        hasComma = formatString.indexOf(',') !== -1;
        splitFormat = formatString.replace(me.formatCleanRe, '').split('.');
      }
      extraChars = formatString.replace(me.formatPattern, '');
      if (splitFormat.length > 2) {
      } else {
        if (splitFormat.length === 2) {
          precision = splitFormat[1].length;
          trimTrailingZeroes = splitFormat[1].match(me.hashRe);
          if (trimTrailingZeroes) {
            len = trimTrailingZeroes[0].length;
            trimPart = 'trailingZeroes\x3dnew RegExp(Ext.String.escapeRegex(utilFormat.decimalSeparator) + "*0{0,' + len + '}$")';
          }
        }
      }
      code = ['var utilFormat\x3dExt.util.Format,extNumber\x3dExt.Number,neg,absVal,fnum,parts' + (hasComma ? ',thousandSeparator,thousands\x3d[],j,n,i' : '') + (extraChars ? ',formatString\x3d"' + formatString + '",formatPattern\x3d/[\\d,\\.#]+/' : '') + ',trailingZeroes;return function(v){if(typeof v!\x3d\x3d"number"\x26\x26isNaN(v\x3dextNumber.from(v,NaN)))return"";neg\x3dv\x3c0;', 'absVal\x3dMath.abs(v);', 'fnum\x3dExt.Number.toFixed(absVal, ' + precision + ');', trimPart, ';'];
      if (hasComma) {
        if (precision) {
          code[code.length] = 'parts\x3dfnum.split(".");';
          code[code.length] = 'fnum\x3dparts[0];';
        }
        code[code.length] = 'if(absVal\x3e\x3d1000) {';
        code[code.length] = 'thousandSeparator\x3dutilFormat.thousandSeparator;thousands.length\x3d0;j\x3dfnum.length;n\x3dfnum.length%3||3;for(i\x3d0;i\x3cj;i+\x3dn){if(i!\x3d\x3d0){n\x3d3;}thousands[thousands.length]\x3dfnum.substr(i,n);}fnum\x3dthousands.join(thousandSeparator);}';
        if (precision) {
          code[code.length] = 'fnum +\x3d utilFormat.decimalSeparator+parts[1];';
        }
      } else {
        if (precision) {
          code[code.length] = 'if(utilFormat.decimalSeparator!\x3d\x3d"."){parts\x3dfnum.split(".");fnum\x3dparts[0]+utilFormat.decimalSeparator+parts[1];}';
        }
      }
      code[code.length] = 'if(neg\x26\x26fnum!\x3d\x3d"' + (precision ? '0.' + Ext.String.repeat('0', precision) : '0') + '") { fnum\x3d"-"+fnum; }';
      if (trimTrailingZeroes) {
        code[code.length] = 'fnum\x3dfnum.replace(trailingZeroes,"");';
      }
      code[code.length] = 'return ';
      if (extraChars) {
        code[code.length] = 'formatString.replace(formatPattern, fnum);';
      } else {
        code[code.length] = 'fnum;';
      }
      code[code.length] = '};';
      formatFn = me.formatFns[originalFormatString] = Ext.functionFactory('Ext', code.join(''))(Ext);
    }
    return formatFn(v);
  }, numberRenderer:function(format) {
    return function(v) {
      return me.number(v, format);
    };
  }, percent:function(value, formatString) {
    return me.number(value * 100, formatString || '0') + me.percentSign;
  }, repeat:function(value, text, sep) {
    return Ext.String.repeat(text, value, sep);
  }, attributes:function(attributes) {
    if (typeof attributes === 'object') {
      var result = [], name;
      for (name in attributes) {
        if (attributes.hasOwnProperty(name)) {
          result.push(name, '\x3d"', name === 'style' ? Ext.DomHelper.generateStyles(attributes[name], null, true) : Ext.htmlEncode(attributes[name]), '" ');
        }
      }
      attributes = result.join('');
    }
    return attributes || '';
  }, plural:function(value, singular, plural) {
    return value + ' ' + (value === 1 ? singular : plural ? plural : singular + 's');
  }, nl2br:function(v) {
    return Ext.isEmpty(v) ? '' : v.replace(me.nl2brRe, '\x3cbr/\x3e');
  }, capitalize:Ext.String.capitalize, uncapitalize:Ext.String.uncapitalize, ellipsis:Ext.String.ellipsis, escape:Ext.String.escape, escapeRegex:Ext.String.escapeRegex, htmlDecode:Ext.String.htmlDecode, htmlEncode:Ext.String.htmlEncode, leftPad:Ext.String.leftPad, toggle:Ext.String.toggle, trim:Ext.String.trim, parseBox:function(box) {
    box = box || 0;
    if (typeof box === 'number') {
      return {top:box, right:box, bottom:box, left:box};
    }
    var parts = box.split(' '), ln = parts.length;
    if (ln === 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else {
      if (ln === 2) {
        parts[2] = parts[0];
        parts[3] = parts[1];
      } else {
        if (ln === 3) {
          parts[3] = parts[1];
        }
      }
    }
    return {top:parseInt(parts[0], 10) || 0, right:parseInt(parts[1], 10) || 0, bottom:parseInt(parts[2], 10) || 0, left:parseInt(parts[3], 10) || 0};
  }, resource:function(url, prefix) {
    prefix = prefix || '';
    return Ext.resolveResource(prefix + url);
  }, uri:function(value) {
    return encodeURI(value);
  }, uriCmp:function(value) {
    return encodeURIComponent(value);
  }, wordBreakRe:/[\W\s]+/, word:function(value, index, sep) {
    var re = sep ? typeof sep === 'string' ? new RegExp(sep) : sep : me.wordBreakRe, parts = (value || '').split(re);
    return parts[index || 0] || '';
  }};
}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Format'], 0);
Ext.cmd.derive('Ext.Template', Ext.Base, {inheritableStatics:{from:function(el, config) {
  el = Ext.getDom(el);
  return new this(el.value || el.innerHTML, config || '');
}}, useEval:Ext.isGecko, constructor:function(html) {
  var me = this, args = arguments, buffer = [], length = args.length, i, value;
  me.initialConfig = {};
  if (length === 1 && Ext.isArray(html)) {
    args = html;
    length = args.length;
  }
  if (length > 1) {
    for (i = 0; i < length; i++) {
      value = args[i];
      if (typeof value === 'object') {
        Ext.apply(me.initialConfig, value);
        Ext.apply(me, value);
      } else {
        buffer.push(value);
      }
    }
  } else {
    buffer.push(html);
  }
  me.html = buffer.join('');
}, isTemplate:true, disableFormats:false, tokenRe:/\{(?:(?:(\d+)|([a-z_][\w\-]*))(?::([a-z_\.]+)(?:\(([^\)]*?)?\))?)?)\}/gi, apply:function(values) {
  var me = this;
  if (me.compiled) {
    if (!me.fn) {
      me.compile();
    }
    return me.fn(values).join('');
  }
  return me.evaluate(values);
}, evaluate:function(values) {
  var me = this, useFormat = !me.disableFormats, fm = Ext.util.Format, tpl = me;
  function fn(match, index, name, formatFn, args) {
    if (name == null || name === '') {
      name = index;
    }
    if (formatFn && useFormat) {
      if (args) {
        args = [values[name]].concat(Ext.functionFactory('return [' + args + '];')());
      } else {
        args = [values[name]];
      }
      if (formatFn.substr(0, 5) === 'this.') {
        return tpl[formatFn.substr(5)].apply(tpl, args);
      } else {
        if (fm[formatFn]) {
          return fm[formatFn].apply(fm, args);
        } else {
          return match;
        }
      }
    } else {
      return values[name] !== undefined ? values[name] : '';
    }
  }
  return me.html.replace(me.tokenRe, fn);
}, applyOut:function(values, out) {
  var me = this;
  if (me.compiled) {
    if (!me.fn) {
      me.compile();
    }
    out.push.apply(out, me.fn(values));
  } else {
    out.push(me.apply(values));
  }
  return out;
}, applyTemplate:function() {
  return this.apply.apply(this, arguments);
}, set:function(html, compile) {
  var me = this;
  me.html = html;
  me.compiled = !!compile;
  me.fn = null;
  return me;
}, compileARe:/\\/g, compileBRe:/(\r\n|\n)/g, compileCRe:/'/g, compile:function() {
  var me = this, code;
  code = me.html.replace(me.compileARe, '\\\\').replace(me.compileBRe, '\\n').replace(me.compileCRe, "\\'").replace(me.tokenRe, me.regexReplaceFn.bind(me));
  code = (this.disableFormats !== true ? 'var fm\x3dExt.util.Format;' : '') + (me.useEval ? '$\x3d' : 'return') + " function(v){return ['" + code + "'];};";
  me.fn = me.useEval ? me.evalCompiled(code) : (new Function('Ext', code))(Ext);
  me.compiled = true;
  return me;
}, evalCompiled:function($) {
  eval($);
  return $;
}, regexReplaceFn:function(match, index, name, formatFn, args) {
  if (index == null || index === '') {
    index = '"' + name + '"';
  } else {
    if (this.stringFormat) {
      index = parseInt(index) + 1;
    }
  }
  if (formatFn && this.disableFormats !== true) {
    args = args ? ',' + args : '';
    if (formatFn.substr(0, 5) === 'this.') {
      formatFn = formatFn + '(';
    } else {
      if (Ext.util.Format[formatFn]) {
        formatFn = 'fm.' + formatFn + '(';
      } else {
        return match;
      }
    }
    return "'," + formatFn + 'v[' + index + ']' + args + "),'";
  } else {
    return "',v[" + index + "] \x3d\x3d undefined ? '' : v[" + index + "],'";
  }
}, insertFirst:function(el, values, returnElement) {
  return this.doInsert('afterBegin', el, values, returnElement);
}, insertBefore:function(el, values, returnElement) {
  return this.doInsert('beforeBegin', el, values, returnElement);
}, insertAfter:function(el, values, returnElement) {
  return this.doInsert('afterEnd', el, values, returnElement);
}, append:function(el, values, returnElement) {
  return this.doInsert('beforeEnd', el, values, returnElement);
}, doInsert:function(where, el, values, returnElement) {
  var newNode = Ext.DomHelper.insertHtml(where, Ext.getDom(el), this.apply(values));
  return returnElement ? Ext.get(newNode) : newNode;
}, overwrite:function(el, values, returnElement) {
  var newNode = Ext.DomHelper.overwrite(Ext.getDom(el), this.apply(values));
  return returnElement ? Ext.get(newNode) : newNode;
}}, 1, 0, 0, 0, 0, 0, [Ext, 'Template'], function(Template) {
  var formatRe = /\{\d+\}/, generateFormatFn = function(format) {
    if (formatRe.test(format)) {
      format = new Template(format, formatTplConfig);
      return function() {
        return format.apply(arguments);
      };
    } else {
      return function() {
        return format;
      };
    }
  }, formatTplConfig = {useFormat:false, compiled:true, stringFormat:true}, formatFns = {};
  Ext.String.format = Ext.util.Format.format = function(format) {
    var formatFn = formatFns[format] || (formatFns[format] = generateFormatFn(format));
    return formatFn.apply(this, arguments);
  };
  Ext.String.formatEncode = function() {
    return Ext.String.htmlEncode(Ext.String.format.apply(this, arguments));
  };
});
Ext.cmd.derive('Ext.util.XTemplateParser', Ext.Base, {constructor:function(config) {
  Ext.apply(this, config);
}, doTpl:Ext.emptyFn, parse:function(str) {
  var me = this, len = str.length, aliases = {elseif:'elif'}, topRe = me.topRe, actionsRe = me.actionsRe, index, stack, s, m, t, prev, frame, subMatch, begin, end, actions, prop, expectTplNext;
  me.level = 0;
  me.stack = stack = [];
  for (index = 0; index < len; index = end) {
    topRe.lastIndex = index;
    m = topRe.exec(str);
    if (!m) {
      me.doText(str.substring(index, len));
      break;
    }
    begin = m.index;
    end = topRe.lastIndex;
    if (index < begin) {
      s = str.substring(index, begin);
      if (!(expectTplNext && Ext.String.trim(s) === '')) {
        me.doText(s);
      }
    }
    expectTplNext = false;
    if (m[1]) {
      end = str.indexOf('%}', begin + 2);
      me.doEval(str.substring(begin + 2, end));
      end += 2;
    } else {
      if (m[2]) {
        end = str.indexOf(']}', begin + 2);
        me.doExpr(str.substring(begin + 2, end));
        end += 2;
      } else {
        if (m[3]) {
          me.doTag(m[3]);
        } else {
          if (m[4]) {
            actions = null;
            while ((subMatch = actionsRe.exec(m[4])) !== null) {
              s = subMatch[2] || subMatch[3];
              if (s) {
                s = Ext.String.htmlDecode(s);
                t = subMatch[1];
                t = aliases[t] || t;
                actions = actions || {};
                prev = actions[t];
                if (typeof prev == 'string') {
                  actions[t] = [prev, s];
                } else {
                  if (prev) {
                    actions[t].push(s);
                  } else {
                    actions[t] = s;
                  }
                }
              }
            }
            if (!actions) {
              if (me.elseRe.test(m[4])) {
                me.doElse();
              } else {
                if (me.defaultRe.test(m[4])) {
                  me.doDefault();
                } else {
                  me.doTpl();
                  stack.push({type:'tpl'});
                }
              }
            } else {
              if (actions['if']) {
                me.doIf(actions['if'], actions);
                stack.push({type:'if'});
              } else {
                if (actions['switch']) {
                  me.doSwitch(actions['switch'], actions);
                  stack.push({type:'switch'});
                  expectTplNext = true;
                } else {
                  if (actions['case']) {
                    me.doCase(actions['case'], actions);
                  } else {
                    if (actions['elif']) {
                      me.doElseIf(actions['elif'], actions);
                    } else {
                      if (actions['for']) {
                        ++me.level;
                        if (prop = me.propRe.exec(m[4])) {
                          actions.propName = prop[1] || prop[2];
                        }
                        me.doFor(actions['for'], actions);
                        stack.push({type:'for', actions:actions});
                      } else {
                        if (actions['foreach']) {
                          ++me.level;
                          if (prop = me.propRe.exec(m[4])) {
                            actions.propName = prop[1] || prop[2];
                          }
                          me.doForEach(actions['foreach'], actions);
                          stack.push({type:'foreach', actions:actions});
                        } else {
                          if (actions.exec) {
                            me.doExec(actions.exec, actions);
                            stack.push({type:'exec', actions:actions});
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (m[0].length === 5) {
              stack.push({type:'tpl'});
            } else {
              frame = stack.pop();
              me.doEnd(frame.type, frame.actions);
              if (frame.type == 'for' || frame.type == 'foreach') {
                --me.level;
              }
            }
          }
        }
      }
    }
  }
}, topRe:/(?:(\{\%)|(\{\[)|\{([^{}]+)\})|(?:<tpl([^>]*)\>)|(?:<\/tpl>)/g, actionsRe:/\s*(elif|elseif|if|for|foreach|exec|switch|case|eval|between)\s*\=\s*(?:(?:"([^"]*)")|(?:'([^']*)'))\s*/g, propRe:/prop=(?:(?:"([^"]*)")|(?:'([^']*)'))/, defaultRe:/^\s*default\s*$/, elseRe:/^\s*else\s*$/}, 1, 0, 0, 0, 0, 0, [Ext.util, 'XTemplateParser'], 0);
Ext.cmd.derive('Ext.util.XTemplateCompiler', Ext.util.XTemplateParser, {useEval:Ext.isGecko, useIndex:Ext.isIE8m, useFormat:true, propNameRe:/^[\w\d\$]*$/, compile:function(tpl) {
  var me = this, code = me.generate(tpl);
  return me.useEval ? me.evalTpl(code) : (new Function('Ext', code))(Ext);
}, generate:function(tpl) {
  var me = this, definitions = 'var fm\x3dExt.util.Format,ts\x3dObject.prototype.toString;', code;
  me.maxLevel = 0;
  me.body = ['var c0\x3dvalues, a0\x3d' + me.createArrayTest(0) + ', p0\x3dparent, n0\x3dxcount, i0\x3dxindex, k0, v;\n'];
  if (me.definitions) {
    if (typeof me.definitions === 'string') {
      me.definitions = [me.definitions, definitions];
    } else {
      me.definitions.push(definitions);
    }
  } else {
    me.definitions = [definitions];
  }
  me.switches = [];
  me.parse(tpl);
  me.definitions.push((me.useEval ? '$\x3d' : 'return') + ' function (' + me.fnArgs + ') {', me.body.join(''), '}');
  code = me.definitions.join('\n');
  me.definitions.length = me.body.length = me.switches.length = 0;
  me.definitions = me.body = me.switches = 0;
  return code;
}, doText:function(text) {
  var me = this, out = me.body;
  text = text.replace(me.aposRe, "\\'").replace(me.newLineRe, '\\n');
  if (me.useIndex) {
    out.push("out[out.length]\x3d'", text, "'\n");
  } else {
    out.push("out.push('", text, "')\n");
  }
}, doExpr:function(expr) {
  var out = this.body;
  out.push('if ((v\x3d' + expr + ') !\x3d null) out');
  if (this.useIndex) {
    out.push('[out.length]\x3dv\n');
  } else {
    out.push('.push(v)\n');
  }
}, doTag:function(tag) {
  var expr = this.parseTag(tag);
  if (expr) {
    this.doExpr(expr);
  } else {
    this.doText('{' + tag + '}');
  }
}, doElse:function() {
  this.body.push('} else {\n');
}, doEval:function(text) {
  this.body.push(text, '\n');
}, doIf:function(action, actions) {
  var me = this;
  if (action === '.') {
    me.body.push('if (values) {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('if (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('if (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  if (actions.exec) {
    me.doExec(actions.exec);
  }
}, doElseIf:function(action, actions) {
  var me = this;
  if (action === '.') {
    me.body.push('else if (values) {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('} else if (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('} else if (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  if (actions.exec) {
    me.doExec(actions.exec);
  }
}, doSwitch:function(action) {
  var me = this, key;
  if (action === '.' || action === '#') {
    key = action === '.' ? 'values' : 'xindex';
    me.body.push('switch (', key, ') {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('switch (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('switch (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  me.switches.push(0);
}, doCase:function(action) {
  var me = this, cases = Ext.isArray(action) ? action : [action], n = me.switches.length - 1, match, i;
  if (me.switches[n]) {
    me.body.push('break;\n');
  } else {
    me.switches[n]++;
  }
  for (i = 0, n = cases.length; i < n; ++i) {
    match = me.intRe.exec(cases[i]);
    cases[i] = match ? match[1] : "'" + cases[i].replace(me.aposRe, "\\'") + "'";
  }
  me.body.push('case ', cases.join(': case '), ':\n');
}, doDefault:function() {
  var me = this, n = me.switches.length - 1;
  if (me.switches[n]) {
    me.body.push('break;\n');
  } else {
    me.switches[n]++;
  }
  me.body.push('default:\n');
}, doEnd:function(type, actions) {
  var me = this, L = me.level - 1;
  if (type == 'for' || type == 'foreach') {
    if (actions.exec) {
      me.doExec(actions.exec);
    }
    me.body.push('}\n');
    me.body.push('parent\x3dp', L, ';values\x3dr', L + 1, ';xcount\x3dn' + L + ';xindex\x3di', L, '+1;xkey\x3dk', L, ';\n');
  } else {
    if (type == 'if' || type == 'switch') {
      me.body.push('}\n');
    }
  }
}, doFor:function(action, actions) {
  var me = this, s, L = me.level, up = L - 1, parentAssignment;
  if (action === '.') {
    s = 'values';
  } else {
    if (me.propNameRe.test(action)) {
      s = me.parseTag(action);
    } else {
      s = me.addFn(action) + me.callFn;
    }
  }
  if (me.maxLevel < L) {
    me.maxLevel = L;
    me.body.push('var ');
  }
  if (action == '.') {
    parentAssignment = 'c' + L;
  } else {
    parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:c' + up;
  }
  me.body.push('i', L, '\x3d0,n', L, '\x3d0,c', L, '\x3d', s, ',a', L, '\x3d', me.createArrayTest(L), ',r', L, '\x3dvalues,p', L, ',k', L, ';\n', 'p', L, '\x3dparent\x3d', parentAssignment, '\n', 'if (c', L, '){if(a', L, '){n', L, '\x3dc', L, '.length;}else if (c', L, '.isMixedCollection){c', L, '\x3dc', L, '.items;n', L, '\x3dc', L, '.length;}else if(c', L, '.isStore){c', L, '\x3dc', L, '.data.items;n', L, '\x3dc', L, '.length;}else{c', L, '\x3d[c', L, '];n', L, '\x3d1;}}\n', 'for (xcount\x3dn', 
  L, ';i', L, '\x3cn' + L + ';++i', L, '){\n', 'values\x3dc', L, '[i', L, ']');
  if (actions.propName) {
    me.body.push('.', actions.propName);
  }
  me.body.push('\n', 'xindex\x3di', L, '+1\n');
  if (actions.between) {
    me.body.push('if(xindex\x3e1){ out.push("', actions.between, '"); } \n');
  }
}, doForEach:function(action, actions) {
  var me = this, s, L = me.level, up = L - 1, parentAssignment;
  if (action === '.') {
    s = 'values';
  } else {
    if (me.propNameRe.test(action)) {
      s = me.parseTag(action);
    } else {
      s = me.addFn(action) + me.callFn;
    }
  }
  if (me.maxLevel < L) {
    me.maxLevel = L;
    me.body.push('var ');
  }
  if (action == '.') {
    parentAssignment = 'c' + L;
  } else {
    parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:c' + up;
  }
  me.body.push('i', L, '\x3d-1,n', L, '\x3d0,c', L, '\x3d', s, ',a', L, '\x3d', me.createArrayTest(L), ',r', L, '\x3dvalues,p', L, ',k', L, ';\n', 'p', L, '\x3dparent\x3d', parentAssignment, '\n', 'for(k', L, ' in c', L, '){\n', 'xindex\x3d++i', L, '+1;\n', 'xkey\x3dk', L, ';\n', 'values\x3dc', L, '[k', L, '];');
  if (actions.propName) {
    me.body.push('.', actions.propName);
  }
  if (actions.between) {
    me.body.push('if(xindex\x3e1){ out.push("', actions.between, '"); } \n');
  }
}, createArrayTest:'isArray' in Array ? function(L) {
  return 'Array.isArray(c' + L + ')';
} : function(L) {
  return 'ts.call(c' + L + ')\x3d\x3d\x3d"[object Array]"';
}, doExec:function(action, actions) {
  var me = this, name = 'f' + me.definitions.length, guards = me.guards[me.strict ? 0 : 1];
  me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', guards.doTry, ' var $v \x3d values; with($v) {', '  ' + action, ' }', guards.doCatch, '}');
  me.body.push(name + me.callFn + '\n');
}, guards:[{doTry:'', doCatch:''}, {doTry:'try { ', doCatch:' } catch(e) {\n}'}], addFn:function(body) {
  var me = this, name = 'f' + me.definitions.length, guards = me.guards[me.strict ? 0 : 1];
  if (body === '.') {
    me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' return values', '}');
  } else {
    if (body === '..') {
      me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' return parent', '}');
    } else {
      me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', guards.doTry, ' var $v \x3d values; with($v) {', '  return(' + body + ')', ' }', guards.doCatch, '}');
    }
  }
  return name;
}, parseTag:function(tag) {
  var me = this, m = me.tagRe.exec(tag), name, format, args, math, v;
  if (!m) {
    return null;
  }
  name = m[1];
  format = m[2];
  args = m[3];
  math = m[4];
  if (name == '.') {
    if (!me.validTypes) {
      me.definitions.push('var validTypes\x3d{string:1,number:1,boolean:1};');
      me.validTypes = true;
    }
    v = 'validTypes[typeof values] || ts.call(values) \x3d\x3d\x3d "[object Date]" ? values : ""';
  } else {
    if (name == '#') {
      v = 'xindex';
    } else {
      if (name == '$') {
        v = 'xkey';
      } else {
        if (name.substr(0, 7) == 'parent.') {
          v = name;
        } else {
          if (isNaN(name) && name.indexOf('-') == -1 && name.indexOf('.') != -1) {
            v = 'values.' + name;
          } else {
            v = "values['" + name + "']";
          }
        }
      }
    }
  }
  if (math) {
    v = '(' + v + math + ')';
  }
  if (format && me.useFormat) {
    args = args ? ',' + args : '';
    if (format.substr(0, 5) != 'this.') {
      format = 'fm.' + format + '(';
    } else {
      format += '(';
    }
  } else {
    return v;
  }
  return format + v + args + ')';
}, evalTpl:function($) {
  eval($);
  return $;
}, newLineRe:/\r\n|\r|\n/g, aposRe:/[']/g, intRe:/^\s*(\d+)\s*$/, tagRe:/^([\w-\.\#\$]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?(\s?[\+\-\*\/]\s?[\d\.\+\-\*\/\(\)]+)?$/}, 0, 0, 0, 0, 0, 0, [Ext.util, 'XTemplateCompiler'], function() {
  var proto = this.prototype;
  proto.fnArgs = 'out,values,parent,xindex,xcount,xkey';
  proto.callFn = '.call(this,' + proto.fnArgs + ')';
});
Ext.cmd.derive('Ext.XTemplate', Ext.Template, {isXTemplate:true, emptyObj:{}, fn:null, strict:false, apply:function(values, parent, xindex, xcount) {
  var buffer = this.applyOut(values, [], parent, xindex, xcount);
  return buffer.length === 1 ? buffer[0] : buffer.join('');
}, applyOut:function(values, out, parent, xindex, xcount) {
  var me = this, compiler;
  if (!me.fn) {
    compiler = new Ext.util.XTemplateCompiler({useFormat:me.disableFormats !== true, definitions:me.definitions, strict:me.strict});
    me.fn = compiler.compile(me.html);
  }
  xindex = xindex || 1;
  xcount = xcount || 1;
  if (me.strict) {
    me.fn(out, values, parent || me.emptyObj, xindex, xcount);
  } else {
    try {
      me.fn(out, values, parent || me.emptyObj, xindex, xcount);
    } catch (e$25) {
    }
  }
  return out;
}, compile:function() {
  return this;
}, statics:{get:function(config, source, defaultTpl) {
  var ret = config;
  if (config == null) {
    if (source && defaultTpl) {
      ret = this.getTpl(source, defaultTpl);
    }
  } else {
    if ((config || config === '') && !config.isTemplate) {
      ret = new this(config);
    }
  }
  return ret;
}, getTpl:function(instance, name) {
  var tpl = instance[name], owner;
  if (tpl) {
    if (!tpl.isTemplate) {
      tpl = Ext.XTemplate.get(tpl);
    }
    if (!tpl.owner) {
      if (instance.hasOwnProperty(name)) {
        owner = instance;
      } else {
        for (owner = instance.self.prototype; owner && !owner.hasOwnProperty(name); owner = owner.superclass) {
        }
      }
      owner[name] = tpl;
      tpl.owner = owner;
    }
  }
  return tpl || null;
}}}, 0, 0, 0, 0, 0, 0, [Ext, 'XTemplate'], 0);
Ext.cmd.derive('Ext.app.EventDomain', Ext.Base, {statics:{instances:{}}, isEventDomain:true, isInstance:false, constructor:function() {
  var me = this;
  if (!me.isInstance) {
    Ext.app.EventDomain.instances[me.type] = me;
  }
  me.bus = {};
  me.monitoredClasses = [];
}, dispatch:function(target, ev, args) {
  ev = Ext.canonicalEventName(ev);
  var me = this, bus = me.bus, selectors = bus[ev], selector, controllers, id, info, events, len, i, event;
  if (!selectors) {
    return true;
  }
  for (selector in selectors) {
    if (selectors.hasOwnProperty(selector) && me.match(target, selector, me.controller)) {
      controllers = selectors[selector];
      for (id in controllers) {
        if (controllers.hasOwnProperty(id)) {
          info = controllers[id];
          if (info.controller.isActive()) {
            events = info.list;
            len = events.length;
            for (i = 0; i < len; i++) {
              event = events[i];
              if (event.fire.apply(event, args) === false) {
                return false;
              }
            }
          }
        }
      }
    }
  }
  return true;
}, listen:function(selectors, controller) {
  var me = this, bus = me.bus, idProperty = me.idProperty, monitoredClasses = me.monitoredClasses, monitoredClassesCount = monitoredClasses.length, controllerId = controller.getId(), isComponentDomain = me.type === 'component', refMap = isComponentDomain ? controller.getRefMap() : null, i, tree, info, selector, options, listener, scope, event, listeners, ev, classHasListeners;
  for (selector in selectors) {
    listeners = selectors[selector];
    if (isComponentDomain) {
      selector = refMap[selector] || selector;
    }
    if (listeners) {
      if (idProperty) {
        selector = selector === '*' ? selector : selector.substring(1);
      }
      for (ev in listeners) {
        options = null;
        listener = listeners[ev];
        scope = controller;
        ev = Ext.canonicalEventName(ev);
        event = new Ext.util.Event(controller, ev);
        if (Ext.isObject(listener)) {
          options = listener;
          listener = options.fn;
          scope = options.scope || controller;
          delete options.fn;
          delete options.scope;
        }
        if (typeof listener === 'string') {
          listener = scope[listener];
        }
        event.addListener(listener, scope, options);
        for (i = 0; i < monitoredClassesCount; ++i) {
          classHasListeners = monitoredClasses[i].hasListeners;
          if (classHasListeners) {
            classHasListeners._incr_(ev);
          }
        }
        tree = bus[ev] || (bus[ev] = {});
        tree = tree[selector] || (tree[selector] = {});
        info = tree[controllerId] || (tree[controllerId] = {controller:controller, list:[]});
        info.list.push(event);
      }
    }
  }
}, match:function(target, selector) {
  var idProperty = this.idProperty;
  if (idProperty) {
    return selector === '*' || target[idProperty] === selector;
  }
  return false;
}, monitor:function(observable) {
  var domain = this, prototype = observable.isInstance ? observable : observable.prototype, doFireEvent = prototype.doFireEvent;
  domain.monitoredClasses.push(observable);
  prototype.doFireEvent = function(ev, args) {
    var me = this, ret;
    ret = doFireEvent.apply(me, arguments);
    if (ret !== false && !me.destroyed && !me.isSuspended(ev)) {
      ret = domain.dispatch(me, ev, args);
    }
    return ret;
  };
}, unlisten:function(controllerId) {
  var bus = this.bus, id = controllerId, monitoredClasses = this.monitoredClasses, monitoredClassesCount = monitoredClasses.length, controllers, ev, events, len, item, selector, selectors, i, j, info, classHasListeners;
  if (controllerId.isController) {
    id = controllerId.getId();
  }
  for (ev in bus) {
    ev = Ext.canonicalEventName(ev);
    if (bus.hasOwnProperty(ev) && (selectors = bus[ev])) {
      for (selector in selectors) {
        controllers = selectors[selector];
        info = controllers[id];
        if (info) {
          events = info.list;
          if (events) {
            for (i = 0, len = events.length; i < len; ++i) {
              item = events[i];
              item.clearListeners();
              for (j = 0; j < monitoredClassesCount; ++j) {
                classHasListeners = monitoredClasses[j].hasListeners;
                if (classHasListeners) {
                  classHasListeners._decr_(item.name);
                }
              }
            }
            delete controllers[id];
          }
        }
      }
    }
  }
}, destroy:function() {
  this.monitoredClasses = this.bus = null;
  this.callParent();
}}, 1, 0, 0, 0, 0, 0, [Ext.app, 'EventDomain'], 0);
Ext.cmd.derive('Ext.app.domain.Component', Ext.app.EventDomain, {singleton:true, type:'component', constructor:function() {
  this.callParent();
  this.monitor(Ext.Widget);
}, dispatch:function(target, ev, args) {
  var controller = target.lookupController(false), domain, view;
  while (controller) {
    domain = controller.compDomain;
    if (domain) {
      if (domain.dispatch(target, ev, args) === false) {
        return false;
      }
    }
    view = controller.getView();
    controller = view ? view.lookupController(true) : null;
  }
  return this.callParent([target, ev, args]);
}, match:function(target, selector) {
  return target.is(selector);
}}, 1, 0, 0, 0, 0, 0, [Ext.app.domain, 'Component'], 0);
Ext.cmd.derive('Ext.util.ProtoElement', Ext.Base, function() {
  var splitWords = Ext.String.splitWords, toMap = Ext.Array.toMap;
  return {isProtoEl:true, clsProp:'cls', styleProp:'style', removedProp:'removed', styleIsText:false, constructor:function(config) {
    var me = this, cls, style;
    if (config) {
      Ext.apply(me, config);
      cls = me.cls;
      style = me.style;
      delete me.cls;
    }
    me.classList = cls ? splitWords(cls) : [];
    me.classMap = cls ? toMap(me.classList) : {};
    if (style) {
      if (typeof style === 'string') {
        me.style = Ext.Element.parseStyles(style);
      } else {
        if (Ext.isFunction(style)) {
          me.styleFn = style;
          delete me.style;
        } else {
          me.style = Ext.apply({}, style);
        }
      }
    }
  }, flush:function() {
    this.flushClassList = [];
    this.removedClasses = {};
    delete this.style;
    delete this.unselectableAttr;
  }, addCls:function(cls) {
    if (!cls) {
      return this;
    }
    var me = this, add = typeof cls === 'string' ? splitWords(cls) : cls, length = add.length, list = me.classList, map = me.classMap, flushList = me.flushClassList, i = 0, c;
    for (; i < length; ++i) {
      c = add[i];
      if (!map[c]) {
        map[c] = true;
        list.push(c);
        if (flushList) {
          flushList.push(c);
          delete me.removedClasses[c];
        }
      }
    }
    return me;
  }, hasCls:function(cls) {
    return cls in this.classMap;
  }, removeCls:function(cls) {
    var me = this, list = me.classList, newList = me.classList = [], remove = toMap(splitWords(cls)), length = list.length, map = me.classMap, removedClasses = me.removedClasses, i, c;
    for (i = 0; i < length; ++i) {
      c = list[i];
      if (remove[c]) {
        if (removedClasses) {
          if (map[c]) {
            removedClasses[c] = true;
            Ext.Array.remove(me.flushClassList, c);
          }
        }
        delete map[c];
      } else {
        newList.push(c);
      }
    }
    return me;
  }, setStyle:function(prop, value) {
    var me = this, style = me.style || (me.style = {});
    if (typeof prop === 'string') {
      if (arguments.length === 1) {
        me.setStyle(Ext.Element.parseStyles(prop));
      } else {
        style[prop] = value;
      }
    } else {
      Ext.apply(style, prop);
    }
    return me;
  }, unselectable:function() {
    this.addCls(Ext.dom.Element.unselectableCls);
    if (Ext.isOpera) {
      this.unselectableAttr = true;
    }
  }, writeTo:function(to) {
    var me = this, classList = me.flushClassList || me.classList, removedClasses = me.removedClasses, style;
    if (me.styleFn) {
      style = Ext.apply({}, me.styleFn());
      Ext.apply(style, me.style);
    } else {
      style = me.style;
    }
    to[me.clsProp] = classList.join(' ');
    if (style) {
      to[me.styleProp] = me.styleIsText ? Ext.DomHelper.generateStyles(style, null, true) : style;
    }
    if (removedClasses) {
      removedClasses = Ext.Object.getKeys(removedClasses);
      if (removedClasses.length) {
        to[me.removedProp] = removedClasses.join(' ');
      }
    }
    if (me.unselectableAttr) {
      to.unselectable = 'on';
    }
    return to;
  }};
}, 1, 0, 0, 0, 0, 0, [Ext.util, 'ProtoElement'], 0);
Ext.cmd.derive('Ext.dom.CompositeElement', Ext.dom.CompositeElementLite, {alternateClassName:'Ext.CompositeElement', isLite:false, getElement:function(el) {
  return el;
}, transformElement:function(el) {
  return Ext.get(el);
}}, 0, 0, 0, 0, 0, 0, [Ext.dom, 'CompositeElement', Ext, 'CompositeElement'], 0);
Ext.cmd.derive('Ext.plugin.Manager', Ext.Base, {alternateClassName:['Ext.PluginManager', 'Ext.PluginMgr'], singleton:true, typeName:'ptype', create:function(config, defaultType, host) {
  var result, type;
  if (config.init) {
    result = config;
  } else {
    if (host) {
      config = Ext.apply({}, config);
      config.cmp = host;
    } else {
      host = config.cmp;
    }
    if (config.xclass) {
      result = Ext.create(config);
    } else {
      type = 'plugin.' + (config.ptype || defaultType);
      result = Ext.ClassManager.instantiateByAlias(type, config);
    }
  }
  if (result && host && result.setCmp && !result.setCmpCalled) {
    result.setCmp(host);
    result.setCmpCalled = true;
  }
  return result;
}}, 0, 0, 0, 0, 0, 0, [Ext.plugin, 'Manager', Ext, 'PluginManager', Ext, 'PluginMgr'], 0);
Ext.cmd.derive('Ext.util.CSS', Ext.Base, function() {
  var CSS, rules = null, doc = document, camelRe = /(-[a-z])/gi, camelFn = function(m, a) {
    return a.charAt(1).toUpperCase();
  };
  return {singleton:true, rules:rules, initialized:false, constructor:function() {
    CSS = this;
  }, createStyleSheet:function(cssText, id) {
    var ss, head = doc.getElementsByTagName('head')[0], styleEl = doc.createElement('style');
    styleEl.setAttribute('type', 'text/css');
    if (id) {
      styleEl.setAttribute('id', id);
    }
    ss = styleEl.styleSheet;
    if (ss) {
      head.appendChild(styleEl);
      ss.cssText = cssText;
    } else {
      styleEl.appendChild(doc.createTextNode(cssText));
      head.appendChild(styleEl);
      ss = styleEl.sheet;
    }
    CSS.cacheStyleSheet(ss);
    return ss;
  }, removeStyleSheet:function(stylesheet) {
    var styleEl = typeof stylesheet === 'string' ? doc.getElementById(stylesheet) : stylesheet.ownerNode;
    if (styleEl) {
      styleEl.parentNode.removeChild(styleEl);
    }
  }, swapStyleSheet:function(id, url) {
    var ss;
    CSS.removeStyleSheet(id);
    ss = doc.createElement('link');
    ss.setAttribute('rel', 'stylesheet');
    ss.setAttribute('type', 'text/css');
    ss.setAttribute('id', id);
    ss.setAttribute('href', url);
    doc.getElementsByTagName('head')[0].appendChild(ss);
  }, cacheStyleSheet:function(ss) {
    if (!rules) {
      rules = CSS.rules = {};
    }
    try {
      var ssRules = ss.cssRules || ss.rules, i = ssRules.length - 1, imports = ss.imports, len = imports ? imports.length : 0, rule, j;
      for (j = 0; j < len; ++j) {
        CSS.cacheStyleSheet(imports[j]);
      }
      for (; i >= 0; --i) {
        rule = ssRules[i];
        if (rule.styleSheet) {
          CSS.cacheStyleSheet(rule.styleSheet);
        }
        CSS.cacheRule(rule, ss);
      }
    } catch (e$26) {
    }
  }, cacheRule:function(cssRule, styleSheet) {
    if (cssRule.styleSheet) {
      return CSS.cacheStyleSheet(cssRule.styleSheet);
    }
    var selectorText = cssRule.selectorText, selectorCount, j;
    if (selectorText) {
      selectorText = selectorText.split(',');
      selectorCount = selectorText.length;
      for (j = 0; j < selectorCount; j++) {
        rules[Ext.String.trim(selectorText[j]).toLowerCase()] = {parentStyleSheet:styleSheet, cssRule:cssRule};
      }
    }
  }, getRules:function(refreshCache) {
    var result = {}, selector;
    if (rules === null || refreshCache) {
      CSS.refreshCache();
    }
    for (selector in rules) {
      result[selector] = rules[selector].cssRule;
    }
    return result;
  }, refreshCache:function() {
    var ds = doc.styleSheets, i = 0, len = ds.length;
    rules = CSS.rules = {};
    for (; i < len; i++) {
      try {
        if (!ds[i].disabled) {
          CSS.cacheStyleSheet(ds[i]);
        }
      } catch (e$27) {
      }
    }
  }, getRule:function(selector, refreshCache, rawCache) {
    var i, result;
    if (!rules || refreshCache) {
      CSS.refreshCache();
    }
    if (!Ext.isArray(selector)) {
      result = rules[selector.toLowerCase()];
      if (result && !rawCache) {
        result = result.cssRule;
      }
      return result || null;
    }
    for (i = 0; i < selector.length; i++) {
      if (rules[selector[i]]) {
        return rawCache ? rules[selector[i].toLowerCase()] : rules[selector[i].toLowerCase()].cssRule;
      }
    }
    return null;
  }, createRule:function(styleSheet, selector, cssText) {
    var result, ruleSet = styleSheet.cssRules || styleSheet.rules, index = ruleSet.length;
    if (styleSheet.insertRule) {
      styleSheet.insertRule(selector + ' {' + cssText + '}', index);
    } else {
      styleSheet.addRule(selector, cssText || ' ');
    }
    CSS.cacheRule(result = ruleSet[index], styleSheet);
    return result;
  }, updateRule:function(selector, property, value) {
    var rule, i, styles;
    if (!Ext.isArray(selector)) {
      rule = CSS.getRule(selector);
      if (rule) {
        if (arguments.length === 2) {
          styles = Ext.Element.parseStyles(property);
          for (property in styles) {
            rule.style[property.replace(camelRe, camelFn)] = styles[property];
          }
        } else {
          rule.style[property.replace(camelRe, camelFn)] = value;
        }
        return true;
      }
    } else {
      for (i = 0; i < selector.length; i++) {
        if (CSS.updateRule(selector[i], property, value)) {
          return true;
        }
      }
    }
    return false;
  }, deleteRule:function(selector) {
    var rule = CSS.getRule(selector, false, true), styleSheet, index;
    if (rule) {
      styleSheet = rule.parentStyleSheet;
      index = Ext.Array.indexOf(styleSheet.cssRules || styleSheet.rules, rule.cssRule);
      if (styleSheet.deleteRule) {
        styleSheet.deleteRule(index);
      } else {
        styleSheet.removeRule(index);
      }
      delete rules[selector];
    }
  }};
}, 1, 0, 0, 0, 0, 0, [Ext.util, 'CSS'], 0);
Ext.cmd.derive('Ext.fx.easing.Abstract', Ext.Base, {config:{startTime:0, startValue:0}, isEasing:true, isEnded:false, constructor:function(config) {
  this.initConfig(config);
  return this;
}, applyStartTime:function(startTime) {
  if (!startTime) {
    startTime = Ext.Date.now();
  }
  return startTime;
}, updateStartTime:function(startTime) {
  this.reset();
}, reset:function() {
  this.isEnded = false;
}, getValue:Ext.emptyFn}, 1, 0, 0, 0, 0, 0, [Ext.fx.easing, 'Abstract'], 0);
Ext.cmd.derive('Ext.fx.easing.Linear', Ext.fx.easing.Abstract, {config:{duration:0, endValue:0}, updateStartValue:function(startValue) {
  this.distance = this.getEndValue() - startValue;
}, updateEndValue:function(endValue) {
  this.distance = endValue - this.getStartValue();
}, getValue:function() {
  var deltaTime = Ext.Date.now() - this.getStartTime(), duration = this.getDuration();
  if (deltaTime > duration) {
    this.isEnded = true;
    return this.getEndValue();
  } else {
    return this.getStartValue() + deltaTime / duration * this.distance;
  }
}}, 0, 0, 0, 0, ['easing.linear'], 0, [Ext.fx.easing, 'Linear'], 0);
Ext.cmd.derive('Ext.util.translatable.Abstract', Ext.Evented, {factoryConfig:{type:'translatable', defaultType:'csstransform'}, config:{easing:null, easingX:{duration:300}, easingY:{duration:300}}, x:0, y:0, activeEasingX:null, activeEasingY:null, isAnimating:false, isTranslatable:true, constructor:function(config) {
  Ext.Evented.prototype.constructor.call(this, config);
  this.position = {x:0, y:0};
}, factoryEasing:function(easing) {
  return Ext.factory(easing, Ext.fx.easing.Linear, null, 'easing');
}, applyEasing:function(easing) {
  if (!this.getEasingX()) {
    this.setEasingX(this.factoryEasing(easing));
  }
  if (!this.getEasingY()) {
    this.setEasingY(this.factoryEasing(easing));
  }
}, applyEasingX:function(easing) {
  return this.factoryEasing(easing);
}, applyEasingY:function(easing) {
  return this.factoryEasing(easing);
}, doTranslate:function(x, y) {
  if (this.hasListeners.translate) {
    this.fireEvent('translate', this, x, y);
  }
}, translate:function(x, y, animation) {
  if (animation) {
    return this.translateAnimated(x, y, animation);
  }
  if (this.isAnimating) {
    this.stopAnimation();
  }
  if (!isNaN(x) && typeof x === 'number') {
    this.x = x;
  }
  if (!isNaN(y) && typeof y === 'number') {
    this.y = y;
  }
  this.doTranslate(x, y);
}, translateAxis:function(axis, value, animation) {
  var x, y;
  if (axis === 'x') {
    x = value;
  } else {
    y = value;
  }
  return this.translate(x, y, animation);
}, getPosition:function() {
  var me = this, position = me.position;
  position.x = -me.x;
  position.y = -me.y;
  return position;
}, animate:function(easingX, easingY) {
  var me = this;
  me.activeEasingX = easingX;
  me.activeEasingY = easingY;
  me.isAnimating = true;
  if (me.ownerCmp) {
    me.ownerCmp.isTranslating = true;
  }
  me.lastX = null;
  me.lastY = null;
  Ext.AnimationQueue.start(me.doAnimationFrame, me);
  me.fireEvent('animationstart', me, me.x, me.y);
  return me;
}, translateAnimated:function(x, y, animation) {
  var me = this, now, easing, easingX, easingY;
  if (!Ext.isObject(animation)) {
    animation = {};
  }
  if (me.isAnimating) {
    me.stopAnimation();
  }
  me.callback = animation.callback;
  me.callbackScope = animation.scope;
  now = Ext.Date.now();
  easing = animation.easing;
  easingX = typeof x === 'number' ? animation.easingX || easing || me.getEasingX() || true : null;
  easingY = typeof y === 'number' ? animation.easingY || easing || me.getEasingY() || true : null;
  if (easingX) {
    easingX = me.factoryEasing(easingX);
    easingX.setStartTime(now);
    easingX.setStartValue(me.x);
    easingX.setEndValue(x);
    if ('duration' in animation) {
      easingX.setDuration(animation.duration);
    }
  }
  if (easingY) {
    easingY = me.factoryEasing(easingY);
    easingY.setStartTime(now);
    easingY.setStartValue(me.y);
    easingY.setEndValue(y);
    if ('duration' in animation) {
      easingY.setDuration(animation.duration);
    }
  }
  return me.animate(easingX, easingY);
}, doAnimationFrame:function() {
  var me = this, easingX = me.activeEasingX, easingY = me.activeEasingY, now = Date.now(), x, y;
  if (!me.isAnimating) {
    return;
  }
  me.lastRun = now;
  if (easingX === null && easingY === null) {
    me.stopAnimation();
    return;
  }
  if (easingX !== null) {
    me.x = x = Math.round(easingX.getValue());
    if (easingX.isEnded) {
      me.activeEasingX = null;
      me.fireEvent('axisanimationend', me, 'x', x);
    }
  } else {
    x = me.x;
  }
  if (easingY !== null) {
    me.y = y = Math.round(easingY.getValue());
    if (easingY.isEnded) {
      me.activeEasingY = null;
      me.fireEvent('axisanimationend', me, 'y', y);
    }
  } else {
    y = me.y;
  }
  if (me.lastX !== x || me.lastY !== y) {
    me.doTranslate(x, y);
    me.lastX = x;
    me.lastY = y;
  }
  me.fireEvent('animationframe', me, x, y);
}, stopAnimation:function() {
  var me = this;
  if (!me.isAnimating) {
    return;
  }
  me.activeEasingX = null;
  me.activeEasingY = null;
  me.isAnimating = false;
  if (me.ownerCmp) {
    me.ownerCmp.isTranslating = false;
  }
  Ext.AnimationQueue.stop(me.doAnimationFrame, me);
  me.fireEvent('animationend', me, me.x, me.y);
  if (me.callback) {
    me.callback.call(me.callbackScope);
    me.callback = null;
  }
}, refresh:function() {
  this.translate(this.x, this.y);
}, resolveListenerScope:function() {
  var ownerCmp = this.ownerCmp, a = arguments;
  if (ownerCmp) {
    return ownerCmp.resolveListenerScope.apply(ownerCmp, a);
  }
  return Ext.Evented.prototype.resolveListenerScope.apply(this, a);
}, destroy:function() {
  var me = this;
  me.destroying = true;
  if (me.isAnimating) {
    me.stopAnimation();
  }
  Ext.Evented.prototype.destroy.call(this);
  me.destroying = false;
  me.destroyed = true;
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.util.translatable, 'Abstract'], 0);
Ext.cmd.derive('Ext.util.translatable.Dom', Ext.util.translatable.Abstract, {config:{element:null}, applyElement:function(element) {
  if (!element) {
    return;
  }
  return Ext.get(element);
}, updateElement:function() {
  this.refresh();
}}, 0, 0, 0, 0, ['translatable.dom'], 0, [Ext.util.translatable, 'Dom'], 0);
Ext.cmd.derive('Ext.util.translatable.ScrollPosition', Ext.util.translatable.Dom, {constructor:function(config) {
  if (config && config.element) {
    this.x = config.element.getScrollLeft();
    this.y = config.element.getScrollTop();
  }
  Ext.util.translatable.Dom.prototype.constructor.call(this, config);
}, translateAnimated:function() {
  var element = this.getElement();
  this.x = element.getScrollLeft();
  this.y = element.getScrollTop();
  Ext.util.translatable.Dom.prototype.translateAnimated.apply(this, arguments);
}, doTranslate:function(x, y) {
  var element = this.getElement();
  element.setScrollLeft(Math.round(x));
  element.setScrollTop(Math.round(y));
}, getPosition:function() {
  var me = this, position = me.position, element = me.getElement();
  position.x = element.getScrollLeft();
  position.y = element.getScrollTop();
  return position;
}}, 1, 0, 0, 0, ['translatable.scrollposition'], 0, [Ext.util.translatable, 'ScrollPosition'], 0);
Ext.cmd.derive('Ext.scroll.Scroller', Ext.Evented, {factoryConfig:{defaultType:'scroller'}, bufferableMethods:{onDomScrollEnd:100}, isScroller:true, config:{direction:undefined, element:undefined, scrollbars:null, snapSelector:null, snapOffset:null, msSnapInterval:null, x:true, y:true, scrollElement:null, size:null, spacerXY:null, touchAction:null}, snappableCls:'x-scroller-snappable', elementCls:'x-scroller', spacerCls:'x-scroller-spacer', noScrollbarsCls:'x-no-scrollbars', statics:{create:function(config, 
type) {
  return Ext.Factory.scroller(config, type);
}, getScrollingElement:function() {
  var doc = document, standard = this.$standardScrollElement, el = doc.scrollingElement, iframe, frameDoc;
  if (el) {
    return el;
  }
  if (standard === undefined) {
    iframe = document.createElement('iframe');
    iframe.style.height = '1px';
    document.body.appendChild(iframe);
    frameDoc = iframe.contentWindow.document;
    frameDoc.write('\x3c!DOCTYPE html\x3e\x3cdiv style\x3d"height:9999em"\x3ex\x3c/div\x3e');
    frameDoc.close();
    standard = frameDoc.documentElement.scrollHeight > frameDoc.body.scrollHeight;
    iframe.parentNode.removeChild(iframe);
    this.$standardScrollElement = standard;
  }
  return standard ? doc.documentElement : doc.body;
}, initViewportScroller:function() {
  var scroller = Ext.getViewportScroller();
  if (!scroller.getElement()) {
    scroller.setElement(Ext.getBody());
  }
}}, constructor:function(config) {
  var me = this;
  me.position = {x:0, y:0};
  Ext.Evented.prototype.constructor.call(this, config);
}, destroy:function() {
  var me = this, partners = me._partners, key;
  Ext.undefer(me.restoreTimer);
  me.setX(Ext.emptyString);
  me.setY(Ext.emptyString);
  if (me._spacer) {
    me._spacer.destroy();
  }
  if (me.scrollListener) {
    me.scrollListener.destroy();
  }
  if (partners) {
    for (key in partners) {
      me.removePartner(partners[key].scroller);
    }
  }
  me.setElement(null);
  me._partners = me.component = null;
  if (me.translatable) {
    me.translatable.destroy();
    me.translatable = null;
  }
  me.removeSnapStylesheet();
  Ext.Evented.prototype.destroy.call(this);
}, addPartner:function(partner, axis) {
  var me = this, partners = me._partners || (me._partners = {}), otherPartners = partner._partners || (partner._partners = {});
  axis = me.axisConfigs[axis || 'both'];
  partners[partner.getId()] = {scroller:partner, axes:axis};
  otherPartners[me.getId()] = {scroller:me, axes:axis};
}, applyElement:function(element, oldElement) {
  var me = this;
  if (oldElement && me.scrollListener) {
    me.scrollListener.destroy();
  }
  if (element) {
    element = Ext.get(element);
  }
  return element;
}, applySize:function(size, oldSize) {
  var x, y;
  if (size === null || typeof size === 'number') {
    x = y = size;
  } else {
    if (size) {
      x = size.x;
      y = size.y;
    }
  }
  if (x === null) {
    x = 0;
  } else {
    if (x === undefined) {
      x = oldSize ? oldSize.x : 0;
    }
  }
  if (y === null) {
    y = 0;
  } else {
    if (y === undefined) {
      y = oldSize ? oldSize.y : 0;
    }
  }
  if (!oldSize || x !== oldSize.x || y !== oldSize.y) {
    return {x:x, y:y};
  }
}, getClientSize:function() {
  var dom = this.getElement().dom;
  return {x:dom.clientWidth, y:dom.clientHeight};
}, getScrollbarSize:function() {
  var me = this, width = 0, height = 0, element = me.getElement(), dom, x, y, hasXScroll, hasYScroll, scrollbarSize;
  if (element && !element.destroyed) {
    x = me.getX();
    y = me.getY();
    dom = element.dom;
    if (x || y) {
      scrollbarSize = Ext.getScrollbarSize();
    }
    if (x === 'scroll') {
      hasXScroll = true;
    } else {
      if (x) {
        hasXScroll = dom.scrollWidth > dom.clientWidth;
      }
    }
    if (y === 'scroll') {
      hasYScroll = true;
    } else {
      if (y) {
        hasYScroll = dom.scrollHeight > dom.clientHeight;
      }
    }
    if (hasXScroll) {
      height = scrollbarSize.height;
    }
    if (hasYScroll) {
      width = scrollbarSize.width;
    }
  }
  return {width:width, height:height};
}, getPosition:function() {
  var me = this;
  if (me.positionDirty) {
    me.updateDomScrollPosition();
  }
  return me.position;
}, getSize:function() {
  var element = this.getElement(), size, dom;
  if (element && !element.destroyed) {
    dom = element.dom;
    size = {x:dom.scrollWidth, y:dom.scrollHeight};
  } else {
    size = {x:0, y:0};
  }
  return size;
}, getMaxPosition:function() {
  var element = this.getElement(), x = 0, y = 0, dom;
  if (element && !element.destroyed) {
    dom = element.dom;
    x = dom.scrollWidth - dom.clientWidth;
    y = dom.scrollHeight - dom.clientHeight;
  }
  return {x:x, y:y};
}, getMaxUserPosition:function() {
  var me = this, element = me.getElement(), x = 0, y = 0, dom;
  if (element && !element.destroyed) {
    dom = element.dom;
    if (me.getX()) {
      x = dom.scrollWidth - dom.clientWidth;
    }
    if (me.getY()) {
      y = dom.scrollHeight - dom.clientHeight;
    }
  }
  return {x:x, y:y};
}, refresh:function() {
  this.positionDirty = true;
  this.fireEvent('refresh', this);
  return this;
}, removePartner:function(partner) {
  var partners = this._partners, otherPartners = partner._partners;
  if (partners) {
    delete partners[partner.getId()];
  }
  if (otherPartners) {
    delete otherPartners[this.getId()];
  }
}, scrollBy:function(deltaX, deltaY, animate) {
  var position = this.getPosition();
  if (deltaX) {
    if (deltaX.length) {
      animate = deltaY;
      deltaY = deltaX[1];
      deltaX = deltaX[0];
    } else {
      if (typeof deltaX !== 'number') {
        animate = deltaY;
        deltaY = deltaX.y;
        deltaX = deltaX.x;
      }
    }
  }
  deltaX = typeof deltaX === 'number' ? deltaX + position.x : null;
  deltaY = typeof deltaY === 'number' ? deltaY + position.y : null;
  return this.doScrollTo(deltaX, deltaY, animate);
}, ensureVisible:function(el, options) {
  var me = this, position = me.getPosition(), highlight, newPosition, ret;
  if (el) {
    if (el && el.element && !el.isElement) {
      options = el;
      el = options.element;
    }
    options = options || {};
    highlight = options.highlight;
    newPosition = me.getEnsureVisibleXY(el, options);
    if (newPosition.y !== position.y || newPosition.x !== position.x) {
      if (highlight) {
        me.on({scrollend:'doHighlight', scope:me, single:true, args:[el, highlight]});
      }
      ret = me.doScrollTo(newPosition.x, newPosition.y, options.animation);
    } else {
      if (highlight) {
        me.doHighlight(el, highlight);
      }
      ret = Ext.Deferred.getCachedResolved();
    }
  } else {
    ret = Ext.Deferred.getCachedRejected();
  }
  return ret;
}, scrollIntoView:function(el, hscroll, animate, highlight) {
  return this.ensureVisible(el, {animation:animate, highlight:highlight, x:hscroll});
}, isInView:function(el) {
  return this.doIsInView(el);
}, scrollTo:function(x, y, animation) {
  var maxPosition;
  if (x) {
    if (x.length) {
      animation = y;
      y = x[1];
      x = x[0];
    } else {
      if (typeof x !== 'number') {
        animation = y;
        y = x.y;
        x = x.x;
      }
    }
  }
  if (x < 0 || y < 0) {
    maxPosition = this.getMaxPosition();
    if (x < 0) {
      x += maxPosition.x;
    }
    if (y < 0) {
      y += maxPosition.y;
    }
  }
  return this.doScrollTo(x, y, animation);
}, updateDirection:function(direction) {
  var me = this, x, y;
  if (!direction) {
    x = me.getX();
    y = me.getY();
    if (x && y) {
      direction = y === 'scroll' && x === 'scroll' ? 'both' : 'auto';
    } else {
      if (y) {
        direction = 'vertical';
      } else {
        if (x) {
          direction = 'horizontal';
        }
      }
    }
    me._direction = direction;
  } else {
    if (direction === 'auto') {
      x = true;
      y = true;
    } else {
      if (direction === 'vertical') {
        x = false;
        y = true;
      } else {
        if (direction === 'horizontal') {
          x = true;
          y = false;
        } else {
          if (direction === 'both') {
            x = 'scroll';
            y = 'scroll';
          }
        }
      }
    }
    me.setX(x);
    me.setY(y);
  }
}, updateScrollbars:function(scrollbars, oldScrollbars) {
  this.syncScrollbarCls();
}, updateSize:function(size) {
  var me = this, element = me.getElement(), x = size.x, y = size.y, spacer;
  if (element) {
    me.positionDirty = true;
    spacer = me.getSpacer();
    if (!x && !y) {
      spacer.hide();
    } else {
      if (x > 0) {
        x -= 1;
      }
      if (y > 0) {
        y -= 1;
      }
      me.setSpacerXY({x:x, y:y});
      spacer.show();
    }
  }
}, updateMsSnapInterval:function() {
  this.initMsSnapInterval();
}, updateSnapSelector:function() {
  this.initSnap();
}, updateSnapOffset:function() {
  this.initSnap();
}, updateTouchAction:function(touchAction) {
  var element = this.getElement();
  if (element) {
    element.setTouchAction(touchAction);
  }
}, updateElement:function(element, oldElement) {
  var me = this, touchAction = me.getTouchAction(), scrollListener = me.scrollListener, elementCls = me.elementCls, eventSource, scrollEl;
  if (scrollListener) {
    scrollListener.destroy();
    me.scrollListener = null;
    me.setScrollElement(null);
  }
  if (oldElement && !oldElement.destroyed) {
    oldElement.setStyle('overflow', 'hidden');
    oldElement.removeCls(elementCls);
  }
  if (element) {
    if (element.dom === document.documentElement || element.dom === document.body) {
      eventSource = Ext.getWin();
      scrollEl = Ext.scroll.Scroller.getScrollingElement();
    } else {
      scrollEl = eventSource = element;
    }
    me.setScrollElement(Ext.get(scrollEl));
    me.scrollListener = eventSource.on({scroll:me.onDomScroll, scope:me, destroyable:true});
    if (touchAction) {
      element.setTouchAction(touchAction);
    }
    me.initXStyle();
    me.initYStyle();
    element.addCls(elementCls);
    me.initSnap();
    me.initMsSnapInterval();
    me.syncScrollbarCls();
  }
}, updateX:function(x) {
  this.initXStyle();
}, updateY:function(y) {
  this.initYStyle();
}, deprecated:{5:{methods:{getScroller:function() {
  return this;
}}}, '5.1.0':{methods:{scrollToTop:function(animate) {
  return this.scrollTo(0, 0, animate);
}, scrollToEnd:function(animate) {
  return this.scrollTo(Infinity, Infinity, animate);
}}}}, privates:{axisConfigs:{x:{x:true}, y:{y:true}, both:{x:true, y:true}}, getEnsureVisibleXY:function(el, options) {
  var position = this.getPosition(), viewport = this.component ? this.component.getScrollableClientRegion() : this.getElement(), newPosition, align;
  if (el && el.element && !el.isElement) {
    options = el;
    el = options.element;
  }
  options = options || {};
  align = options.align;
  if (align) {
    if (Ext.isString(align)) {
      align = {x:options.x === false ? null : align, y:options.y === false ? null : align};
    } else {
      if (Ext.isObject(align)) {
        if (align.x && options.x === false) {
          align.x = null;
        }
        if (align.y && options.y === false) {
          align.y = null;
        }
      }
    }
  }
  newPosition = Ext.fly(el).getScrollIntoViewXY(viewport, position.x, position.y, align);
  newPosition.x = options.x === false ? position.x : newPosition.x;
  newPosition.y = options.y === false ? position.y : newPosition.y;
  return newPosition;
}, getSpacer:function() {
  var me = this, spacer = me._spacer, element;
  if (!spacer) {
    element = me.getElement();
    spacer = me._spacer = element.createChild({cls:me.spacerCls, role:'presentation'}, element.dom.firstChild);
    spacer.setVisibilityMode(2);
    spacer.hide();
    element.position();
  }
  return spacer;
}, applySpacerXY:function(pos, oldPos) {
  if (oldPos && pos.x === oldPos.x && pos.y === oldPos.y) {
    pos = undefined;
  }
  return pos;
}, updateSpacerXY:function(pos) {
  var me = this, spacer = me.getSpacer(), sStyle = spacer.dom.style, scrollHeight = pos.y, shortfall;
  sStyle.marginTop = '';
  me.translateSpacer(pos.x, me.constrainScrollRange(scrollHeight));
  sStyle.lineHeight = Number(!parseInt(sStyle.lineHeight, 10)) + 'px';
  if (scrollHeight > 1000000) {
    shortfall = scrollHeight - me.getElement().dom.scrollHeight;
    if (shortfall > 0) {
      sStyle.marginTop = Math.min(shortfall, me.maxSpacerMargin || 0) + 'px';
    }
  }
}, translateSpacer:function(x, y) {
  this.getSpacer().translate(x, y);
}, doIsInView:function(el, skipCheck) {
  var me = this, c = me.component, result = {x:false, y:false}, elRegion, myEl = me.getElement(), myElRegion;
  if (el && (skipCheck || (myEl.contains(el) || c && c.owns(el)))) {
    myElRegion = myEl.getRegion();
    elRegion = Ext.fly(el).getRegion();
    result.x = elRegion.right > myElRegion.left && elRegion.left < myElRegion.right;
    result.y = elRegion.bottom > myElRegion.top && elRegion.top < myElRegion.bottom;
  }
  return result;
}, contains:function(component) {
  var el = this.getElement(), owner = component;
  while (owner && owner !== Ext.Viewport) {
    if (el.contains(owner.el)) {
      return true;
    }
    owner = owner.getRefOwner();
  }
  return false;
}, constrainScrollRange:function(scrollRange) {
  if (scrollRange < 1000000) {
    return scrollRange;
  }
  if (!this.maxSpacerTranslate) {
    var maxScrollHeight = Math.pow(2, 32), tooHigh = maxScrollHeight, tooLow = 500, scrollTest = Ext.getBody().createChild({style:{position:'absolute', left:'-10000px', top:'0', width:'500px', height:'500px'}, cn:{cls:this.spacerCls}}, null, true), stretcher = Ext.get(scrollTest.firstChild), sStyle = stretcher.dom.style;
    stretcher.translate(0, maxScrollHeight - 1);
    sStyle.lineHeight = Number(!parseInt(sStyle.lineHeight, 10)) + 'px';
    while (tooHigh !== tooLow + 1) {
      stretcher.translate(0, maxScrollHeight = tooLow + Math.floor((tooHigh - tooLow) / 2));
      sStyle.lineHeight = Number(!parseInt(sStyle.lineHeight, 10)) + 'px';
      if (scrollTest.scrollHeight < maxScrollHeight) {
        tooHigh = maxScrollHeight;
      } else {
        tooLow = maxScrollHeight;
      }
    }
    stretcher.translate(0, Ext.scroll.Scroller.prototype.maxSpacerTranslate = tooLow);
    tooHigh = tooLow * 2;
    while (tooHigh !== tooLow + 1) {
      stretcher.dom.style.marginTop = (maxScrollHeight = tooLow + Math.floor((tooHigh - tooLow) / 2)) + 'px';
      sStyle.lineHeight = Number(!parseInt(sStyle.lineHeight, 10)) + 'px';
      if (scrollTest.scrollHeight < maxScrollHeight) {
        tooHigh = maxScrollHeight;
      } else {
        tooLow = maxScrollHeight;
      }
    }
    Ext.fly(scrollTest).destroy();
    Ext.scroll.Scroller.prototype.maxSpacerMargin = tooLow - Ext.scroll.Scroller.prototype.maxSpacerTranslate;
  }
  return Math.min(scrollRange, this.maxSpacerTranslate);
}, convertX:function(x) {
  return x;
}, doHighlight:function(el, highlight) {
  if (highlight !== true) {
    Ext.fly(el).highlight(highlight);
  } else {
    Ext.fly(el).highlight();
  }
}, doScrollTo:function(x, y, animate) {
  var me = this, element = me.getScrollElement(), maxPosition, dom, xInf, yInf, ret, translatable, deferred;
  if (element && !element.destroyed) {
    dom = element.dom;
    xInf = x === Infinity;
    yInf = y === Infinity;
    if (xInf || yInf) {
      maxPosition = me.getMaxPosition();
      if (xInf) {
        x = maxPosition.x;
      }
      if (yInf) {
        y = maxPosition.y;
      }
    }
    if (x !== null) {
      x = me.convertX(x);
    }
    if (animate) {
      translatable = me.translatable;
      if (!translatable) {
        me.translatable = translatable = new Ext.util.translatable.ScrollPosition({element:element});
      }
      deferred = new Ext.Deferred;
      translatable.on('animationend', function() {
        if (me.destroyed) {
          deferred.reject();
        } else {
          deferred.resolve();
        }
      }, Ext.global, {single:true, onFrame:true});
      translatable.translate(x, y, animate);
      ret = deferred.promise;
    } else {
      if (y != null) {
        dom.scrollTop = y;
      }
      if (x != null) {
        dom.scrollLeft = x;
      }
      ret = Ext.Deferred.getCachedResolved();
    }
    me.positionDirty = true;
  } else {
    ret = Ext.Deferred.getCachedRejected();
  }
  return ret;
}, fireScrollStart:function(x, y, xDelta, yDelta) {
  var me = this, component = me.component;
  me.invokePartners('onPartnerScrollStart', x, y, xDelta, yDelta);
  me.startX = x - xDelta;
  me.startY = y - yDelta;
  if (me.hasListeners.scrollstart) {
    me.fireEvent('scrollstart', me, x, y);
  }
  if (component && component.onScrollStart) {
    component.onScrollStart(x, y);
  }
  Ext.GlobalEvents.fireEvent('scrollstart', me, x, y);
}, fireScroll:function(x, y, xDelta, yDelta) {
  var me = this, component = me.component;
  me.invokePartners('onPartnerScroll', x, y, xDelta, yDelta);
  if (me.hasListeners.scroll) {
    me.fireEvent('scroll', me, x, y, xDelta, yDelta);
  }
  if (component && component.onScrollMove) {
    component.onScrollMove(x, y);
  }
  Ext.GlobalEvents.fireEvent('scroll', me, x, y, xDelta, yDelta);
}, fireScrollEnd:function(x, y, xDelta, yDelta) {
  var me = this, component = me.component, dx = x - me.startX, dy = y - me.startY;
  me.startX = me.startY = null;
  me.invokePartners('onPartnerScrollEnd', x, y, xDelta, yDelta);
  if (me.hasListeners.scrollend) {
    me.fireEvent('scrollend', me, x, y, dx, dy);
  }
  if (component && component.onScrollEnd) {
    component.onScrollEnd(x, y);
  }
  Ext.GlobalEvents.fireEvent('scrollend', me, x, y, dx, dy);
}, getElementScroll:function(element) {
  return element.getScroll();
}, initSnap:function() {
  var me = this, snapOffset = me.getSnapOffset(), snapSelector = me.getSnapSelector(), element = me.getElement(), offsetX, offsetY, snapCoordinate;
  if (element && snapSelector) {
    element.addCls(me.snappableCls);
    me.removeSnapStylesheet();
    if (snapOffset) {
      offsetX = snapOffset.x || 0;
      offsetY = snapOffset.y || 0;
      if (offsetX) {
        offsetX = -offsetX + 'px';
      }
      if (offsetY) {
        offsetY = -offsetY + 'px';
      }
    }
    snapCoordinate = offsetX + ' ' + offsetY + ';';
    me.snapStylesheet = Ext.util.CSS.createStyleSheet('#' + element.id + ' ' + snapSelector + '{-webkit-scroll-snap-coordinate:' + snapCoordinate + 'scroll-snap-coordinate:' + snapCoordinate + '}');
  }
}, initMsSnapInterval:function() {
  var element = this.getElement(), interval, x, y, style;
  if (element) {
    interval = this.getMsSnapInterval();
    if (interval) {
      x = interval.x;
      y = interval.y;
      style = element.dom.style;
      if (x) {
        style['-ms-scroll-snap-points-x'] = 'snapInterval(0px, ' + x + 'px)';
      }
      if (y) {
        style['-ms-scroll-snap-points-y'] = 'snapInterval(0px, ' + y + 'px)';
      }
    }
  }
}, initXStyle:function() {
  var element = this.getElement(), x = this.getX();
  if (element && element.dom) {
    if (!x) {
      x = 'hidden';
    } else {
      if (x === true) {
        x = 'auto';
      }
    }
    element.setStyle('overflow-x', x);
  }
}, initYStyle:function() {
  var element = this.getElement(), y = this.getY();
  if (element && element.dom) {
    if (!y) {
      y = 'hidden';
    } else {
      if (y === true) {
        y = 'auto';
      }
    }
    element.setStyle('overflow-y', y);
  }
}, invokePartners:function(method, x, y, xDelta, yDelta) {
  var me = this, partners = me._partners, partner, id, axes;
  if (!me.suspendSync) {
    me.invokingPartners = true;
    for (id in partners) {
      axes = partners[id].axes;
      partner = partners[id].scroller;
      if (!partner.invokingPartners && (xDelta && axes.x || yDelta && axes.y)) {
        partner[method](me, axes.x ? x : null, axes.y ? y : null, xDelta, yDelta);
      }
    }
    me.invokingPartners = false;
  }
}, suspendPartnerSync:function() {
  this.suspendSync = (this.suspendSync || 0) + 1;
}, resumePartnerSync:function(syncNow) {
  var me = this, position;
  if (me.suspendSync) {
    me.suspendSync--;
  }
  if (!me.suspendSync && syncNow) {
    position = me.getPosition();
    me.invokePartners('onPartnerScroll', position.x, position.y);
    me.invokePartners('onPartnerScrollEnd', position.x, position.y);
  }
}, readPosition:function(position) {
  var me = this, element = me.getScrollElement(), elScroll;
  position = position || {};
  if (element && !element.destroyed) {
    elScroll = me.getElementScroll(element);
    position.x = elScroll.left;
    position.y = elScroll.top;
  }
  return position;
}, updateDomScrollPosition:function(silent) {
  var me = this, position = me.position, oldX = position.x, oldY = position.y, x, y, xDelta, yDelta;
  me.readPosition(position);
  x = position.x;
  y = position.y;
  me.positionDirty = false;
  if (!silent) {
    xDelta = x - oldX;
    yDelta = y - oldY;
    if (xDelta || yDelta) {
      if (!me.isScrolling) {
        me.isScrolling = Ext.isScrolling = true;
        me.fireScrollStart(x, y, xDelta, yDelta);
      }
      me.fireScroll(x, y, xDelta, yDelta);
      me.onDomScrollEnd(x, y, xDelta, yDelta);
    }
  }
  return position;
}, syncWithPartners:function() {
  var me = this, partners = me._partners, id, partner, position;
  me.suspendPartnerSync();
  for (id in partners) {
    partner = partners[id].scroller;
    position = partner.getPosition();
    me.onPartnerScroll(partner, position.x, position.y);
  }
  me.resumePartnerSync();
}, syncScrollbarCls:function() {
  var element = this.getElement();
  if (element) {
    element.toggleCls(this.noScrollbarsCls, this.getScrollbars() === false);
  }
}, onDomScroll:function() {
  var hasTimer = !!this.restoreTimer;
  this.updateDomScrollPosition(hasTimer);
  if (hasTimer) {
    Ext.undefer(this.onDomScrollEnd.timer);
    return;
  }
}, doOnDomScrollEnd:function(x, y, xDelta, yDelta) {
  var me = this;
  if (me.destroying || me.destroyed) {
    return;
  }
  me.isScrolling = Ext.isScrolling = false;
  if (x === undefined) {
    return;
  }
  me.trackingScrollLeft = x;
  me.trackingScrollTop = y;
  me.fireScrollEnd(x, y, xDelta, yDelta);
}, onPartnerScrollStart:function(partner, x, y, xDelta, yDelta) {
  this.isScrolling = true;
  this.fireScrollStart(x, y, xDelta, yDelta);
}, onPartnerScroll:function(partner, x, y, xDelta, yDelta) {
  this.doScrollTo(x, y, false);
  this.updateDomScrollPosition(true);
  this.fireScroll(x, y, xDelta, yDelta);
}, onPartnerScrollEnd:function(partner, x, y, xDelta, yDelta) {
  this.cancelOnDomScrollEnd();
  this.doOnDomScrollEnd(x, y, xDelta, yDelta);
}, removeSnapStylesheet:function() {
  var stylesheet = this.snapStylesheet;
  if (stylesheet) {
    Ext.util.CSS.removeStyleSheet(stylesheet);
    this.snapStylesheet = null;
  }
}, restoreState:function() {
  var me = this, el = me.getScrollElement();
  if (el) {
    if (me.trackingScrollTop !== undefined) {
      if (!me.restoreTimer) {
        me.restoreTimer = Ext.defer(function() {
          me.restoreTimer = null;
        }, 50);
      }
      me.doScrollTo(me.trackingScrollLeft, me.trackingScrollTop, false);
    }
  }
}}}, 1, 0, 0, 0, ['scroller.scroller'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable], [Ext.mixin.Bufferable.prototype.mixinId || Ext.mixin.Bufferable.$className, Ext.mixin.Bufferable]], [Ext.scroll, 'Scroller'], function(Scroller) {
  Ext.getViewportScroller = function() {
    var scroller = Scroller.viewport;
    if (!scroller) {
      Scroller.viewport = scroller = new Scroller;
      Scroller.initViewportScroller();
    }
    return scroller;
  };
  Ext.setViewportScroller = function(scroller) {
    if (Scroller.viewport !== scroller) {
      Ext.destroy(Scroller.viewport);
      if (scroller && !scroller.isScroller) {
        scroller = new Scroller(scroller);
      }
      Scroller.viewport = scroller;
    }
  };
  Ext.onReady(function() {
    Scroller.initViewportScrollerTimer = Ext.defer(Scroller.initViewportScroller, 100);
  });
});
Ext.cmd.derive('Ext.util.Floating', Ext.Base, {mixinId:'floating', focusOnToFront:true, shadow:'sides', animateShadow:false, constrain:false, alignOnScroll:true, config:{activeCounter:0, alwaysOnTop:false}, preventDefaultAlign:false, _visModeMap:{visibility:1, display:2, offsets:3}, constructor:function() {
  var me = this, el = me.el, shadow = me.shadow, shadowOffset, shadowConfig;
  if (shadow) {
    shadowConfig = {mode:shadow === true ? 'sides' : shadow};
    shadowOffset = me.shadowOffset;
    if (shadowOffset) {
      shadowConfig.offset = shadowOffset;
    }
    shadowConfig.animate = me.animateShadow;
    shadowConfig.fixed = me.fixed;
    el.enableShadow(shadowConfig, false);
  }
  if (me.shim || Ext.useShims) {
    el.enableShim({fixed:me.fixed}, false);
  }
  el.setVisibilityMode(me._visModeMap[me.hideMode]);
  me.el.on({mousedown:me.onMouseDown, scope:me, capture:true});
  me.registerWithOwnerCt();
  me.initHierarchyEvents();
}, alignTo:function(alignTarget, position, offsets, animate, monitorScroll) {
  var me = this, alignEl, destroyed, dom, myXY, anchorXY, listeners;
  if (alignTarget.isComponent) {
    alignEl = alignTarget.el;
    destroyed = alignTarget.destroyed;
  } else {
    me.alignTargetFly = me.alignTargetFly || new Ext.dom.Fly;
    alignEl = alignTarget = me.alignTargetFly.attach(alignTarget);
    dom = alignEl.dom;
    destroyed = !dom || Ext.isGarbage(dom);
  }
  if (destroyed) {
    me._lastAlignTarget = null;
    if (me.alignListeners) {
      me.alignListeners.destroy();
    }
    return;
  }
  me.mixins.positionable.alignTo.call(me, alignEl, position, offsets, animate, monitorScroll !== false);
  myXY = me.getXY();
  anchorXY = alignTarget.getXY();
  me.alignVector = [myXY[0] - anchorXY[0], myXY[1] - anchorXY[1]];
  me._lastAlignTarget = alignTarget;
  me._lastAlignToPos = position;
  me._lastAlignToOffsets = offsets;
  me._topAlignTarget = me.getTopAlignTarget();
  me.clearClip();
  if (!me.alignListeners) {
    listeners = {resize:{fn:me.alignOnResize, buffer:100}, scope:me, destroyable:true};
    if (me.alignOnScroll && !alignEl.contains(me.el)) {
      listeners.scroll = me.doRealign;
    }
    me.alignListeners = Ext.on(listeners);
  }
}, initFloatConstrain:function() {
  var me = this, floatParent = me.floatParent;
  if ((me.constrain || me.constrainHeader) && !me.constrainTo) {
    me.constrainTo = floatParent ? floatParent.getTargetEl() : me.container;
  }
}, initHierarchyEvents:function() {
  var me = this;
  if (!me.hierarchyEventListeners) {
    me.hierarchyEventListeners = Ext.on({hide:'syncHidden', collapse:'syncHidden', show:'syncHidden', expand:'syncHidden', added:'syncHidden', scope:me, destroyable:true});
  }
}, registerWithOwnerCt:function() {
  var me = this, ownerCt = me.ownerCt, zip = me.zIndexParent;
  if (zip) {
    zip.unregisterFloatingItem(me);
  }
  zip = me.zIndexParent = me.up('[floating]');
  me.floatParent = ownerCt || zip;
  me.initFloatConstrain();
  delete me.ownerCt;
  if (zip) {
    zip.registerFloatingItem(me);
  } else {
    Ext.WindowManager.register(me);
  }
}, onMouseDown:function(e) {
  var me = this, focusTask = me.focusTask, owner = me.getRefOwner(), preventFocus = e.pointerType === 'touch', target, dom, skipFronting;
  if (me.floating && (!focusTask || !focusTask.id)) {
    if (me.owns(Ext.Element.getActiveElement())) {
      preventFocus = {ownsFocus:true};
    }
    target = e.target;
    dom = me.el.dom;
    while (!preventFocus && target && target !== dom) {
      if (Ext.fly(target).isFocusable()) {
        preventFocus = {ownsFocus:true};
      }
      target = target.parentNode;
    }
    skipFronting = Ext.WindowManager.getActive() === me && (target === dom || preventFocus);
    if (!skipFronting) {
      me.toFront(preventFocus);
    }
    if (!preventFocus && owner && owner.containsFocus) {
      e.preventDefault();
    }
  }
}, onBeforeFloatLayout:function() {
  this.el.preventSync = true;
}, onAfterFloatLayout:function() {
  var el = this.el;
  if (el.shadow || el.shim) {
    el.setUnderlaysVisible(true);
    el.syncUnderlays();
  }
}, syncHidden:function() {
  var me = this, hidden = me.hidden || !me.rendered, hierarchicallyHidden = me.hierarchicallyHidden = me.isHierarchicallyHidden(), pendingShow = me.pendingShow;
  if (hidden !== hierarchicallyHidden) {
    if (hierarchicallyHidden) {
      me.hide();
      me.pendingShow = true;
    } else {
      if (pendingShow) {
        delete me.pendingShow;
        if (pendingShow.length) {
          me.show.apply(me, pendingShow);
        } else {
          me.show();
        }
      }
    }
  }
}, setZIndex:function(index) {
  var me = this;
  me.el.setZIndex(index);
  index += 10;
  if (me.floatingDescendants) {
    index = Math.floor(me.floatingDescendants.setBase(index) / 100) * 100 + 10000;
  }
  return index;
}, doConstrain:function(constrainTo) {
  var me = this, xy = me.calculateConstrainedPosition(constrainTo, null, true);
  if (xy) {
    me.setPosition(xy);
  }
}, updateActiveCounter:function(activeCounter) {
  var me = this, zim = me.zIndexParent;
  if (zim && zim !== zim.zIndexManager.front && me.bringParentToFront !== false) {
    zim.setActiveCounter(++Ext.ZIndexManager.activeCounter);
  }
  zim = me.zIndexManager;
  if (zim) {
    zim.onComponentUpdate(me);
  }
}, updateAlwaysOnTop:function(alwaysOnTop) {
  var z = this.zIndexManager;
  if (z) {
    z.onComponentUpdate(this);
  }
}, toFront:function(preventFocus) {
  var me = this;
  if (me.zIndexManager.bringToFront(me, preventFocus || !me.focusOnToFront)) {
    if (me.hasListeners.tofront) {
      me.fireEvent('tofront', me, me.el.getZIndex());
    }
  }
  return me;
}, onZIndexChange:function(isTopMost) {
  var me = this;
  if (isTopMost) {
    if (me.el.shadow && me.el.getData().isVisible !== false && !me.maximized) {
      me.el.enableShadow(null, true);
    }
    me.fireEvent('activate', me);
  } else {
    me.fireEvent('deactivate', me);
  }
}, onFocusTopmost:function() {
  var activeCmp = Ext.ComponentManager.getActiveComponent();
  if (!activeCmp || !activeCmp.up(this)) {
    this.focus();
  }
}, toBack:function() {
  this.zIndexManager.sendToBack(this);
  return this;
}, center:function() {
  var me = this, parent = me.floatParent, xy;
  if (me.isVisible()) {
    xy = me.getAlignToXY(parent ? parent.getTargetEl() : me.container, 'c-c');
    me.setPagePosition(xy);
  } else {
    me.needsCenter = true;
  }
  return me;
}, onFloatShow:function() {
  var me = this, target = me._lastAlignTarget;
  if (me.needsCenter) {
    me.center();
  } else {
    if (target) {
      if (target.destroyed) {
        me._lastAlignTarget = null;
      } else {
        me.alignTo(target, me._lastAlignToPos, me._lastAlignToOffsets, false, !me.fixed);
      }
    }
  }
  me.needsCenter = false;
}, fitContainer:function(animate) {
  var me = this, parent = me.floatParent, container = parent ? parent.getTargetEl() : me.container, newBox = container.getViewSize(), newPosition = parent || container.dom !== document.body ? [0, 0] : container.getXY();
  newBox.x = newPosition[0];
  newBox.y = newPosition[1];
  me.setBox(newBox, animate);
}, privates:{onFloatDestroy:function() {
  var me = this, fly = me.alignTargetFly;
  if (me.hierarchyEventListeners) {
    me.hierarchyEventListeners.destroy();
    me.hierarchyEventListeners = null;
  }
  me.clearAlignEl();
  if (fly) {
    fly.detach();
    fly.destroy();
  }
}, getTopAlignTarget:function() {
  var next = this._lastAlignTarget, result = next;
  while (next && (result = next) && next.isComponent) {
    if (result.isFloating()) {
      next = result._lastAlignTarget;
    } else {
      next = result.up('{isFloating()}');
      next = next && next._lastAlignTarget;
    }
  }
  return result;
}, clearAlignEl:function() {
  var me = this;
  if (me._lastAlignTarget) {
    me.alignListeners = Ext.destroy(me.alignListeners);
    Ext.un('scroll', me.doRealign, me);
    me._lastAlignToPos = me._lastAlignTarget = me._lastAlignToOffsets = me._topAlignTarget = null;
  }
}, alignOnResize:function() {
  this.doRealign();
}, doRealign:function(scroller) {
  var me = this, alignEl = me._lastAlignTarget.el, destroyed, dom, anchorXY, myXY;
  if (alignEl && me.isVisible()) {
    if (alignEl.isComponent) {
      destroyed = alignEl.destroyed;
    } else {
      dom = alignEl.dom;
      destroyed = !dom || Ext.isGarbage(dom);
    }
    if (destroyed) {
      me.clearAlignEl();
    } else {
      if (!scroller || scroller.getElement().contains(me._topAlignTarget.el) && !scroller.getElement().contains(me.el)) {
        anchorXY = alignEl.getXY();
        myXY = [anchorXY[0] + me.alignVector[0], anchorXY[1] + me.alignVector[1]];
        me.setXY(myXY);
        if (scroller) {
          me.clipToScroller(scroller);
        }
      }
    }
  }
}, clipToScroller:function(scroller) {
  var me = this, anchorBox = me._topAlignTarget.getBox(), scrollerBox = scroller.getElement().getConstrainRegion(), sides = 0;
  if (anchorBox.top < scrollerBox.top) {
    sides = 1;
  }
  if (anchorBox.right > scrollerBox.right) {
    sides = sides | 2;
  }
  if (anchorBox.bottom > scrollerBox.bottom) {
    sides = sides | 4;
  }
  if (anchorBox.left < scrollerBox.left) {
    sides = sides | 8;
  }
  if (sides) {
    me.clipTo(scrollerBox, sides);
  } else {
    me.clearClip();
  }
}}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Floating'], 0);
Ext.cmd.derive('Ext.util.ElementContainer', Ext.Base, {mixinId:'elementCt', config:{childEls:{$value:{}, cached:true, lazy:true, merge:function(newValue, oldValue, target, mixinClass) {
  var childEls = oldValue ? Ext.Object.chain(oldValue) : {}, i, val;
  if (newValue instanceof Array) {
    for (i = newValue.length; i--;) {
      val = newValue[i];
      if (!mixinClass || !(val in childEls)) {
        if (typeof val === 'string') {
          childEls[val] = {name:val, itemId:val};
        } else {
          childEls[val.name] = val;
        }
      }
    }
  } else {
    if (newValue) {
      if (newValue.constructor === Object) {
        for (i in newValue) {
          if (!mixinClass || !(i in childEls)) {
            val = newValue[i];
            if (val === true) {
              childEls[i] = {itemId:i};
            } else {
              if (typeof val === 'string') {
                childEls[i] = {itemId:val};
              } else {
                childEls[i] = val;
                if (!('itemId' in val)) {
                  val.itemId = i;
                }
              }
            }
            childEls[i].name = i;
          }
        }
      } else {
        if (!mixinClass || !(newValue in childEls)) {
          childEls[newValue] = {name:newValue, itemId:newValue};
        }
      }
    }
  }
  return childEls;
}}}, destroy:function() {
  var me = this, childEls = me.getChildEls(), child, childName;
  for (childName in childEls) {
    child = me[childName];
    if (child) {
      if (child.destroy) {
        child.component = null;
        child.destroy();
      }
      me[childName] = null;
    }
  }
}, privates:{addChildEl:function(childEl) {
  var me = this, childEls = me.getChildEls();
  if (!me.hasOwnProperty('childEls')) {
    me.childEls = childEls = Ext.Object.chain(childEls);
  }
  if (typeof childEl === 'string') {
    childEl = {name:childEl, itemId:childEl};
  }
  childEls[childEl.name] = childEl;
}, afterClassMixedIn:function(targetClass) {
  var proto = targetClass.prototype, childEls = proto.childEls;
  if (childEls) {
    delete proto.childEls;
    targetClass.getConfigurator().add({childEls:childEls});
  }
}, attachChildEls:function(el, owner) {
  var me = this, childEls = me.getChildEls(), comp = owner || me, baseId = comp.id + '-', unframed = !comp.frame, childName, elements, entry, k, selector, value, id;
  for (childName in childEls) {
    entry = childEls[childName];
    if (unframed && entry.frame) {
      continue;
    }
    selector = entry.select;
    if (selector) {
      value = el.select(selector, true);
    } else {
      if (!(selector = entry.selectNode)) {
        if (!(id = entry.id)) {
          id = baseId + entry.itemId;
          value = Ext.cache[id];
        } else {
          value = Ext.cache[id] || el.getById(id);
        }
      } else {
        value = el.selectNode(selector, false);
      }
    }
    if (value) {
      if (value.isElement) {
        value.component = comp;
      } else {
        if (value.isComposite && !value.isLite) {
          elements = value.elements;
          for (k = elements.length; k--;) {
            elements[k].component = comp;
          }
        }
      }
    }
    me[childName] = value || null;
  }
}}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'ElementContainer'], 0);
Ext.cmd.derive('Ext.util.Renderable', Ext.Base, {mixinId:'renderable', frameCls:'x-frame', frameIdRegex:/[\-]frame\d+[TMB][LCR]$/, frameElNames:['TL', 'TC', 'TR', 'ML', 'MC', 'MR', 'BL', 'BC', 'BR', 'Table'], frameTpl:['\x3ctpl if\x3d"hasTabGuard"\x3e{% this.renderTabGuard(out, values, \'before\'); %}\x3c/tpl\x3e', '\x3ctpl if\x3d"top"\x3e', '\x3ctpl if\x3d"left"\x3e\x3cdiv id\x3d"{fgid}TL" data-ref\x3d"frameTL" class\x3d"{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-tl\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/tpl\x3e', 
'\x3ctpl if\x3d"right"\x3e\x3cdiv id\x3d"{fgid}TR" data-ref\x3d"frameTR" class\x3d"{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-tr\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/tpl\x3e', '\x3cdiv id\x3d"{fgid}TC" data-ref\x3d"frameTC" class\x3d"{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-tc\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/div\x3e', '\x3ctpl if\x3d"right"\x3e\x3c/div\x3e\x3c/tpl\x3e', 
'\x3ctpl if\x3d"left"\x3e\x3c/div\x3e\x3c/tpl\x3e', '\x3c/tpl\x3e', '\x3ctpl if\x3d"left"\x3e\x3cdiv id\x3d"{fgid}ML" data-ref\x3d"frameML" class\x3d"{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-ml\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/tpl\x3e', '\x3ctpl if\x3d"right"\x3e\x3cdiv id\x3d"{fgid}MR" data-ref\x3d"frameMR" class\x3d"{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-mr\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/tpl\x3e', 
'\x3cdiv id\x3d"{fgid}Body" data-ref\x3d"frameBody" class\x3d"{frameBodyCls} {frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-mc\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e', '{%this.applyRenderTpl(out, values)%}', '\x3c/div\x3e', '\x3ctpl if\x3d"right"\x3e\x3c/div\x3e\x3c/tpl\x3e', '\x3ctpl if\x3d"left"\x3e\x3c/div\x3e\x3c/tpl\x3e', '\x3ctpl if\x3d"bottom"\x3e', '\x3ctpl if\x3d"left"\x3e\x3cdiv id\x3d"{fgid}BL" data-ref\x3d"frameBL" class\x3d"{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-bl\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/tpl\x3e', 
'\x3ctpl if\x3d"right"\x3e\x3cdiv id\x3d"{fgid}BR" data-ref\x3d"frameBR" class\x3d"{frameCls}-br {baseCls}-br {baseCls}-{ui}-br\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-br\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/tpl\x3e', '\x3cdiv id\x3d"{fgid}BC" data-ref\x3d"frameBC" class\x3d"{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-bc\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/div\x3e', '\x3ctpl if\x3d"right"\x3e\x3c/div\x3e\x3c/tpl\x3e', 
'\x3ctpl if\x3d"left"\x3e\x3c/div\x3e\x3c/tpl\x3e', '\x3c/tpl\x3e', '\x3ctpl if\x3d"hasTabGuard"\x3e{% this.renderTabGuard(out, values, \'after\'); %}\x3c/tpl\x3e'], frameTableTpl:['\x3ctpl if\x3d"hasTabGuard"\x3e{% this.renderTabGuard(out, values, \'before\'); %}\x3c/tpl\x3e', '\x3ctable id\x3d"{fgid}Table" data-ref\x3d"frameTable" class\x3d"{frameCls} ', 'x-table-plain" cellpadding\x3d"0" role\x3d"presentation"\x3e', '\x3ctpl if\x3d"top"\x3e', '\x3ctr role\x3d"presentation"\x3e', '\x3ctpl if\x3d"left"\x3e\x3ctd id\x3d"{fgid}TL" data-ref\x3d"frameTL" class\x3d"{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-tl\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e\x3c/tpl\x3e', 
'\x3ctd id\x3d"{fgid}TC" data-ref\x3d"frameTC" class\x3d"{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-tc\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e', '\x3ctpl if\x3d"right"\x3e\x3ctd id\x3d"{fgid}TR" data-ref\x3d"frameTR" class\x3d"{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-tr\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e\x3c/tpl\x3e', '\x3c/tr\x3e', 
'\x3c/tpl\x3e', '\x3ctr role\x3d"presentation"\x3e', '\x3ctpl if\x3d"left"\x3e\x3ctd id\x3d"{fgid}ML" data-ref\x3d"frameML" class\x3d"{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-ml\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e\x3c/tpl\x3e', '\x3ctd id\x3d"{fgid}Body" data-ref\x3d"frameBody" class\x3d"{frameBodyCls} {frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-mc\x3c/tpl\x3e{frameElCls}" style\x3d"{mcStyle}" role\x3d"presentation"\x3e', 
'{%this.applyRenderTpl(out, values)%}', '\x3c/td\x3e', '\x3ctpl if\x3d"right"\x3e\x3ctd id\x3d"{fgid}MR" data-ref\x3d"frameMR" class\x3d"{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-mr\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e\x3c/tpl\x3e', '\x3c/tr\x3e', '\x3ctpl if\x3d"bottom"\x3e', '\x3ctr role\x3d"presentation"\x3e', '\x3ctpl if\x3d"left"\x3e\x3ctd id\x3d"{fgid}BL" data-ref\x3d"frameBL" class\x3d"{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-bl\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e\x3c/tpl\x3e', 
'\x3ctd id\x3d"{fgid}BC" data-ref\x3d"frameBC" class\x3d"{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-bc\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e', '\x3ctpl if\x3d"right"\x3e\x3ctd id\x3d"{fgid}BR" data-ref\x3d"frameBR" class\x3d"{frameCls}-br {baseCls}-br {baseCls}-{ui}-br\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-br\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e\x3c/tpl\x3e', '\x3c/tr\x3e', 
'\x3c/tpl\x3e', '\x3c/table\x3e', '\x3ctpl if\x3d"hasTabGuard"\x3e{% this.renderTabGuard(out, values, \'after\'); %}\x3c/tpl\x3e'], _renderState:0, _layerCls:'x-layer', _fixedLayerCls:'x-fixed-layer', ariaStaticRoles:{presentation:true, article:true, definition:true, directory:true, document:true, img:true, heading:true, math:true, note:true, banner:true, complementary:true, contentinfo:true, navigation:true, search:true, 'undefined':true, 'null':true}, statics:{makeRenderSetter:function(cfg, renderState) {
  var name = cfg.name;
  return function(value) {
    var me = this, bucket = me.renderConfigs || (me.renderConfigs = {}), pending = bucket[renderState];
    if (me._renderState >= renderState) {
      (cfg.setter || cfg.getSetter()).call(me, value);
    } else {
      if (!pending) {
        bucket[renderState] = pending = {};
      }
      if (!(name in pending)) {
        pending[name] = me[name];
      }
      me[name] = value;
    }
    return me;
  };
}, processRenderConfig:function(source, configName, state) {
  var proto = this.prototype, configurator = this.getConfigurator(), Renderable = Ext.util.Renderable, makeSetter = Renderable.makeRenderSetter, renderConfig = source[configName], cachedSetter, cfg, name, setterName;
  for (name in renderConfig) {
    cfg = Ext.Config.get(name);
    if (!proto[setterName = cfg.names.set]) {
      cachedSetter = cfg.renderSetter || (cfg.renderSetter = {});
      proto[setterName] = cachedSetter[state] || (cachedSetter[state] = makeSetter(cfg, state));
    }
  }
  delete source[configName];
  configurator.add(renderConfig);
}}, onClassMixedIn:function(targetClass) {
  var override = targetClass.override, processRenderConfig = this.processRenderConfig, processOverride = function(body) {
    if (body.beforeRenderConfig) {
      this.processRenderConfig(body, 'beforeRenderConfig', 1);
    }
    if (body.renderConfig) {
      this.processRenderConfig(body, 'renderConfig', 3);
    }
    override.call(this, body);
  }, processClass = function(theClass, classBody) {
    theClass.override = processOverride;
    theClass.processRenderConfig = processRenderConfig;
    if (classBody.beforeRenderConfig) {
      theClass.processRenderConfig(classBody, 'beforeRenderConfig', 1);
    }
    if (classBody.renderConfig) {
      theClass.processRenderConfig(classBody, 'renderConfig', 3);
    }
  };
  processClass(targetClass, targetClass.prototype);
  targetClass.onExtended(processClass);
}, afterRender:function() {
  var me = this, data = {}, protoEl = me.protoEl, target = me.el, controller, item, pre, hidden, contentEl;
  me.finishRenderChildren();
  me._renderState = 4;
  if (me.contentEl) {
    pre = 'x-';
    hidden = pre + 'hidden-';
    contentEl = me.contentEl = Ext.get(me.contentEl);
    contentEl.component = me;
    contentEl.removeCls([pre + 'hidden', hidden + 'display', hidden + 'offsets']);
    me.getContentTarget().appendChild(contentEl.dom);
  }
  protoEl.writeTo(data);
  item = data.removed;
  if (item) {
    target.removeCls(item);
  }
  item = data.cls;
  if (item.length) {
    target.addCls(item);
  }
  item = data.style;
  if (data.style) {
    target.setStyle(item);
  }
  me.protoEl = null;
  if (!me.ownerCt && !me.skipLayout) {
    me.updateLayout();
  }
  if (!(me.x && me.y) && (me.pageX || me.pageY)) {
    me.setPagePosition(me.pageX, me.pageY);
  }
  if (me.disableOnRender) {
    me.onDisable();
  }
  controller = me.controller;
  if (controller && controller.afterRender) {
    controller.afterRender(me);
  }
  if (me.focusableContainer && me.initFocusableContainer) {
    me.initFocusableContainer();
  }
}, afterFirstLayout:function(width, height) {
  var me = this, x = me.x, y = me.y, alignSpec = me.defaultAlign, alignOffset = me.alignOffset, controller, hasX, hasY, pos, xy;
  if (!me.ownerLayout) {
    hasX = x !== undefined;
    hasY = y !== undefined;
  }
  if (me.floating && !me.preventDefaultAlign && (!hasX || !hasY)) {
    if (me.floatParent) {
      pos = me.floatParent.getTargetEl().getViewRegion();
      xy = me.el.getAlignToXY(me.alignTarget || me.floatParent.getTargetEl(), alignSpec, alignOffset);
      pos.x = xy[0] - pos.x;
      pos.y = xy[1] - pos.y;
    } else {
      xy = me.el.getAlignToXY(me.alignTarget || me.container, alignSpec, alignOffset);
      pos = me.el.translateXY(xy[0], xy[1]);
    }
    x = hasX ? x : pos.x;
    y = hasY ? y : pos.y;
    hasX = hasY = true;
  }
  if (hasX || hasY) {
    me.setPosition(x, y);
  }
  me.onBoxReady(width, height);
  controller = me.controller;
  if (controller && controller.boxReady) {
    controller.boxReady(me, width, height);
  }
}, beforeRender:function() {
  var me = this, floating = me.floating, layout = me.getComponentLayout(), cls = me.userCls, controller;
  me._renderState = 1;
  me.ariaUsesMainElement = me.ariaEl === 'el';
  controller = me.controller;
  if (controller && controller.beforeRender) {
    controller.beforeRender(me);
  }
  me.initBindable();
  if (me.renderConfigs) {
    me.flushRenderConfigs();
  }
  if (cls) {
    me.addCls(cls);
  }
  if (floating) {
    me.addCls(me.fixed ? me._fixedLayerCls : me._layerCls);
    cls = floating.cls;
    if (cls) {
      me.addCls(cls);
    }
  }
  me.frame = me.frame || me.alwaysFramed;
  if (!layout.initialized) {
    layout.initLayout();
  }
  me.initOverflow();
  me.setUI(me.ui);
}, doApplyRenderTpl:function(out, values) {
  var me = values.$comp, tpl;
  if (!me.rendered) {
    tpl = me.initRenderTpl();
    tpl.applyOut(values.renderData, out);
  }
}, getElConfig:function() {
  var me = this, autoEl = me.autoEl, frameInfo = me.getFrameInfo(), config = {tag:'div', tpl:frameInfo ? me.initFramingTpl(frameInfo.table) : me.initRenderTpl()}, layoutTargetCls = me.layoutTargetCls, protoEl = me.protoEl, ariaRole = me.ariaRole, frameData;
  me.initStyles(protoEl);
  if (layoutTargetCls && !frameInfo) {
    protoEl.addCls(layoutTargetCls);
  }
  protoEl.writeTo(config);
  protoEl.flush();
  if (autoEl) {
    if (Ext.isString(autoEl)) {
      config.tag = autoEl;
    } else {
      Ext.apply(config, autoEl);
    }
  }
  if (ariaRole && me.ariaUsesMainElement) {
    config.role = ariaRole;
    if (!me.ariaStaticRoles[ariaRole]) {
      config['aria-hidden'] = !!me.hidden;
      config['aria-disabled'] = !!me.disabled;
      if (me.ariaLabel && !me.ariaLabelledBy) {
        config['aria-label'] = me.ariaLabel;
      }
      if (me.collapsible) {
        config['aria-expanded'] = !me.collapsed;
      }
      if (me.ariaRenderAttributes) {
        Ext.apply(config, me.ariaRenderAttributes);
      }
      if (me.config.ariaAttributes) {
        Ext.apply(config, me.getAriaAttributes());
      }
    }
  }
  config.id = me.id;
  if (config.tpl) {
    if (frameInfo) {
      config.tplData = frameData = me.getFrameRenderData();
      frameData.renderData = me.initRenderData();
    } else {
      config.tplData = me.initRenderData();
    }
  }
  me.ariaRenderAttributes = null;
  return config;
}, getInsertPosition:function(position) {
  if (position !== undefined) {
    if (Ext.isNumber(position)) {
      position = this.container.dom.childNodes[position];
    } else {
      position = Ext.getDom(position);
    }
  }
  return position;
}, getRenderTree:function() {
  var me = this, ret = null;
  if (!me.hasListeners.beforerender || me.fireEvent('beforerender', me) !== false) {
    me._renderState = 1;
    me.beforeRender();
    me.rendering = true;
    me._renderState = 2;
    ret = me.getElConfig();
    if (me.el) {
      ret.id = me.$pid = Ext.id(null, me.el.identifiablePrefix);
    }
  }
  return ret;
}, initRenderData:function() {
  var me = this, ariaRole = me.ariaRole, data, ariaAttr;
  data = Ext.apply({$comp:me, id:me.id, ui:me.ui, uiCls:me.uiCls, baseCls:me.baseCls, componentCls:me.componentCls, frame:me.frame, hasTabGuard:!!me.tabGuard, scrollerCls:me.scrollerCls, childElCls:'', ariaEl:me.ariaEl}, me.renderData);
  if (ariaRole && !me.ariaUsesMainElement) {
    ariaAttr = {role:ariaRole};
    if (!me.ariaStaticRoles[ariaRole]) {
      ariaAttr['aria-hidden'] = !!me.hidden;
      ariaAttr['aria-disabled'] = !!me.disabled;
      if (me.ariaLabel && !me.ariaLabelledBy) {
        ariaAttr['aria-label'] = me.ariaLabel;
      }
      if (me.collapsible) {
        ariaAttr['aria-expanded'] = !me.collapsed;
      }
      if (me.ariaRenderAttributes) {
        Ext.apply(ariaAttr, me.ariaRenderAttributes);
      }
      if (me.config.ariaAttributes) {
        Ext.apply(ariaAttr, me.getAriaAttributes());
      }
    }
    data.ariaAttributes = ariaAttr;
  }
  return data;
}, onRender:function(parentNode, containerIdx) {
  var me = this, x = me.x, y = me.y, lastBox = null, el = me.el, scroller = me.scrollable, width, height;
  me.applyRenderSelectors();
  if (scroller && scroller.isScroller) {
    scroller.setElement(me.getOverflowEl());
    if (Ext.isIE) {
      me.showListenerIE = Ext.on('show', me.onGlobalShow, me, {destroyable:true});
    }
  }
  me.rendering = null;
  me.rendered = true;
  me._renderState = 3;
  if (me.renderConfigs) {
    me.flushRenderConfigs();
  }
  if (x != null) {
    lastBox = {x:x};
  }
  if (y != null) {
    (lastBox = lastBox || {}).y = y;
  }
  if (!me.getFrameInfo()) {
    width = me.width;
    height = me.height;
    if (typeof width === 'number') {
      lastBox = lastBox || {};
      lastBox.width = width;
    }
    if (typeof height === 'number') {
      lastBox = lastBox || {};
      lastBox.height = height;
    }
  }
  me.lastBox = el.lastBox = lastBox;
}, render:function(container, position) {
  var me = this, el = me.el, ownerLayout = me.ownerLayout, vetoed, tree, nextSibling;
  if (el && !el.isElement) {
    me.wrapPrimaryEl(el);
    el = me.el;
  }
  if (!me.skipLayout) {
    Ext.suspendLayouts();
  }
  container = me.initContainer(container);
  nextSibling = me.getInsertPosition(position);
  if (!el) {
    tree = me.getRenderTree();
    if (ownerLayout && ownerLayout.transformItemRenderTree) {
      tree = ownerLayout.transformItemRenderTree(tree);
    }
    if (tree) {
      if (nextSibling) {
        el = Ext.DomHelper.insertBefore(nextSibling, tree);
      } else {
        el = Ext.DomHelper.append(container, tree);
      }
      me.wrapPrimaryEl(el);
      me.cacheRefEls(el);
    }
  } else {
    if (!me.hasListeners.beforerender || me.fireEvent('beforerender', me) !== false) {
      me.beforeRender();
      me.needsRenderTpl = me.rendering = true;
      me._renderState = 2;
      me.initStyles(el);
      if (me.allowDomMove !== false) {
        if (nextSibling) {
          container.dom.insertBefore(el.dom, nextSibling);
        } else {
          container.dom.appendChild(el.dom);
        }
      }
    } else {
      vetoed = true;
    }
  }
  if (el && !vetoed) {
    me.finishRender(position);
  }
  if (!me.skipLayout) {
    Ext.resumeLayouts(!me.hidden && !container.isDetachedBody);
  }
}, ensureAttachedToBody:function(runLayout) {
  var comp = this, body;
  while (comp.ownerCt) {
    comp = comp.ownerCt;
  }
  if (comp.container.isDetachedBody) {
    comp.container = body = Ext.getBody();
    body.appendChild(comp.el.dom);
    if (runLayout) {
      comp.updateLayout();
    }
    if (typeof comp.x === 'number' || typeof comp.y === 'number') {
      comp.setPosition(comp.x, comp.y);
    }
  }
}, privates:{applyRenderSelectors:function() {
  var me = this, selectors = me.renderSelectors, el = me.el, query, selector;
  me.attachChildEls(el);
  if (typeof me.focusEl === 'string') {
    me.focusEl = me[me.focusEl];
  }
  me.ariaEl = me[me.ariaEl] || me.el;
  if (selectors) {
    for (selector in selectors) {
      query = selectors[selector];
      if (query) {
        me[selector] = el.selectNode(query, false);
      }
    }
  }
}, cacheRefEls:function(el) {
  el = el || this.el;
  var cache = Ext.cache, El = Ext.dom.Element, dom = el.isElement ? el.dom : el, refs = dom.querySelectorAll('[data-ref]'), len = refs.length, ref, i;
  for (i = 0; i < len; i++) {
    ref = refs[i];
    if (!cache[ref.id]) {
      new El(ref);
    }
  }
}, doAutoRender:function() {
  var me = this;
  if (!me.rendered) {
    if (me.floating) {
      me.render(me.renderTo || document.body);
    } else {
      me.render(Ext.isBoolean(me.autoRender) ? Ext.getBody() : me.autoRender);
    }
  }
}, doRenderContent:function(out, renderData) {
  var me = renderData.$comp, data = me.data;
  if (me.html) {
    Ext.DomHelper.generateMarkup(me.html, out);
    delete me.html;
  }
  if (me.tpl) {
    if (!me.tpl.isTemplate) {
      me.tpl = new Ext.XTemplate(me.tpl);
    }
    if (data) {
      me.data = data = data.isEntity ? data.getData(true) : data;
      me.tpl.applyOut(data, out);
    }
  }
}, doRenderFramingTabGuard:function(out, renderData, position) {
  var layout = renderData.$comp.layout;
  renderData.renderData.$skipTabGuards = true;
  if (layout && layout.doRenderTabGuard) {
    layout.doRenderTabGuard.call(this, out, renderData, position);
  }
}, flushRenderConfigs:function() {
  var me = this, configs = me.renderConfigs, state = me._renderState, bucket, i, name, newConfigs, value;
  if (configs) {
    for (i = 0; i <= state; ++i) {
      bucket = configs[i];
      if (bucket) {
        configs[i] = null;
        for (name in bucket) {
          value = bucket[name];
          (newConfigs || (newConfigs = {}))[name] = me[name];
          me[name] = value;
        }
      }
    }
    if (newConfigs) {
      me.setConfig(newConfigs);
    }
  }
}, finishRender:function(containerIdx) {
  var me = this, cache = Ext.cache, proxy, first, id, tpl, data, dom, el;
  if (!me.el || me.$pid) {
    if (me.container) {
      el = cache[me.id];
      dom = el ? el.dom : me.container.getById(me.id, true);
    } else {
      id = me.$pid || me.id;
      el = cache[id];
      dom = el ? el.dom : Ext.getDom(id);
    }
    if (!me.el) {
      me.wrapPrimaryEl(dom);
    } else {
      delete me.$pid;
      if (!me.el.dom) {
        me.wrapPrimaryEl(me.el);
      }
      dom.parentNode.insertBefore(me.el.dom, dom);
      proxy = dom;
      dom = me.el.dom;
      first = dom.firstChild;
      while (proxy.firstChild) {
        dom.insertBefore(proxy.firstChild, first);
      }
      me.el.addCls(proxy.className);
      Ext.removeNode(proxy);
    }
  } else {
    if (me.needsRenderTpl) {
      tpl = me.initRenderTpl();
      if (tpl) {
        data = me.initRenderData();
        tpl.insertFirst(me.getTargetEl(), data);
      }
      me.cacheRefEls();
    }
  }
  me.el.component = me;
  if (!me.container) {
    me.container = Ext.get(me.el.dom.parentNode);
  }
  if (me.ctCls) {
    me.container.addCls(me.ctCls);
  }
  me.onRender(me.container, containerIdx);
  if (!me.overflowInited) {
    me.initOverflow();
  }
  me.el.setVisibilityMode(Ext.Element[me.hideMode.toUpperCase()]);
  if (me.overCls) {
    me.el.hover(me.addOverCls, me.removeOverCls, me);
  }
  if (me.hasListeners.render) {
    me.fireEvent('render', me);
  }
  me.afterRender();
  if (me.hasListeners.afterrender) {
    me.fireEvent('afterrender', me);
  }
  me.initEvents();
  if (me.hidden) {
    me.el.hide();
  }
}, finishRenderChildren:function() {
  var layout = this.getComponentLayout();
  layout.finishRender();
}, getFrameRenderData:function() {
  var me = this, frameInfo = me.frameSize, mcStyle = '';
  if (me._syncFrameHeight && me.height) {
    mcStyle = 'height:' + (me.height - frameInfo.height) + 'px';
  }
  return {$comp:me, id:me.id, fgid:me.id + '-frame', ui:me.ui, uiCls:me.uiCls, frameCls:me.frameCls, frameBodyCls:me.layoutTargetCls || '', baseCls:me.baseCls, hasTabGuard:me.tabGuard, top:!!frameInfo.top, left:!!frameInfo.left, right:!!frameInfo.right, bottom:!!frameInfo.bottom, mcStyle:mcStyle, frameElCls:''};
}, getFrameInfo:function() {
  if (Ext.supports.CSS3BorderRadius || !this.frame) {
    return false;
  }
  var me = this, frameInfoCache = me.frameInfoCache, cls = me.getFramingInfoCls() + '-frameInfo', frameInfo = frameInfoCache[cls], styleEl, info, frameTop, frameRight, frameBottom, frameLeft, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth, paddingTop, paddingRight, paddingBottom, paddingLeft;
  if (frameInfo == null) {
    styleEl = Ext.fly(me.getStyleProxy(cls), 'frame-style-el');
    info = styleEl.getStyle('font-family');
    info = info && info.split('-');
    if (info && info.length >= 5) {
      frameTop = parseInt(info[1], 10);
      frameRight = parseInt(info[2], 10);
      frameBottom = parseInt(info[3], 10);
      frameLeft = parseInt(info[4], 10);
      borderTopWidth = parseInt(info[5], 10) || 0;
      borderRightWidth = parseInt(info[6], 10) || 0;
      borderBottomWidth = parseInt(info[7], 10) || 0;
      borderLeftWidth = parseInt(info[8], 10) || 0;
      paddingTop = parseInt(info[9], 10) || 0;
      paddingRight = parseInt(info[10], 10) || 0;
      paddingBottom = parseInt(info[11], 10) || 0;
      paddingLeft = parseInt(info[12], 10) || 0;
      frameInfo = {table:info[0].charAt(0) === 't', vertical:info[0].charAt(1) === 'v', top:frameTop, right:frameRight, bottom:frameBottom, left:frameLeft, width:frameLeft + frameRight, height:frameTop + frameBottom, border:{top:borderTopWidth, right:borderRightWidth, bottom:borderBottomWidth, left:borderLeftWidth, width:borderLeftWidth + borderRightWidth, height:borderTopWidth + borderBottomWidth}, padding:{top:paddingTop, right:paddingRight, bottom:paddingBottom, left:paddingLeft, width:paddingLeft + 
      paddingRight, height:paddingTop + paddingBottom}};
    } else {
      frameInfo = false;
    }
    frameInfoCache[cls] = frameInfo;
  }
  me.frame = !!frameInfo;
  me.frameSize = frameInfo;
  return frameInfo;
}, getFramingInfoCls:function() {
  return this.baseCls + '-' + this.ui;
}, getStyleProxy:function(cls) {
  var result = this.styleProxyEl || (Ext.Component.prototype.styleProxyEl = Ext.getBody().createChild({role:'presentation', style:{position:'absolute', top:'-10000px'}}, null, true));
  result.className = cls;
  return result;
}, getFrameTpl:function(table) {
  return this.lookupTpl(table ? 'frameTableTpl' : 'frameTpl');
}, initContainer:function(container) {
  var me = this;
  if (!container && me.el) {
    container = me.el.dom.parentNode;
    me.allowDomMove = false;
  }
  me.container = container.dom ? container : Ext.get(container);
  return me.container;
}, initOverflow:function() {
  var me = this, overflowStyle = me.getOverflowStyle(), scrollFlags = me.scrollFlags, overflowEl = me.getOverflowEl(), hasOverflow = scrollFlags.y || scrollFlags.x;
  if (!hasOverflow || !overflowEl || !overflowEl.isElement) {
    return;
  }
  me.overflowInited = true;
  overflowEl.setStyle(overflowStyle);
}, initFramingTpl:function(table) {
  var tpl = this.getFrameTpl(table);
  if (tpl && !tpl.applyRenderTpl) {
    this.setupFramingTpl(tpl);
  }
  return tpl;
}, initRenderTpl:function() {
  var tpl = this.lookupTpl('renderTpl');
  if (tpl && !tpl.renderContent) {
    this.setupRenderTpl(tpl);
  }
  return tpl;
}, setupFramingTpl:function(frameTpl) {
  frameTpl.applyRenderTpl = this.doApplyRenderTpl;
  frameTpl.renderTabGuard = this.doRenderFramingTabGuard;
}, setupRenderTpl:function(renderTpl) {
  renderTpl.renderBody = renderTpl.renderContent = this.doRenderContent;
}, updateFrame:function() {
  if (Ext.supports.CSS3BorderRadius || !this.frame) {
    return;
  }
  var me = this, dom = me.el.dom, frameTable = me.frameTable, oldFrameBody = me.frameBody, oldFrameBodyDom = oldFrameBody.dom, frameInfo = me.getFrameInfo(), childEls, childElName, div, el, first, frameData, frameDom, frameTpl, i, newBody, newFrameEls;
  div = document.createElement('div');
  frameData = me.getFrameRenderData();
  frameData.hasTabGuard = false;
  frameTpl = me.getFrameTpl(frameInfo.table);
  frameTpl.insertFirst(div, frameData);
  newFrameEls = div.querySelectorAll('[data-ref]');
  newBody = div.querySelector('[data-ref\x3d"frameBody"]');
  for (first = oldFrameBodyDom; first.parentNode !== dom;) {
    first = first.parentNode;
  }
  while (div.firstChild) {
    dom.insertBefore(div.firstChild, first);
  }
  newBody.parentNode.replaceChild(oldFrameBodyDom, newBody);
  oldFrameBodyDom.className = newBody.className;
  oldFrameBody.setSize();
  childEls = me.getChildEls();
  if (frameTable) {
    frameTable.destroy();
    me.frameTable = null;
  }
  for (childElName in childEls) {
    if (childEls[childElName].frame) {
      el = me[childElName];
      if (el && el !== oldFrameBody) {
        el.destroy();
        me[childElName] = null;
      }
    }
  }
  for (i = newFrameEls.length; i--;) {
    childElName = (frameDom = newFrameEls[i]).getAttribute('data-ref');
    if (childElName !== 'frameBody') {
      me[childElName] = new Ext.dom.Element(frameDom);
    }
  }
}, frameInfoCache:{}}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Renderable'], 0);
Ext.cmd.derive('Ext.state.Provider', Ext.Base, {prefix:'ext-', constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  me.state = {};
  me.mixins.observable.constructor.call(me);
}, get:function(name, defaultValue) {
  var ret = this.state[name];
  return ret === undefined ? defaultValue : ret;
}, clear:function(name) {
  var me = this;
  delete me.state[name];
  me.fireEvent('statechange', me, name, null);
}, set:function(name, value) {
  var me = this;
  me.state[name] = value;
  me.fireEvent('statechange', me, name, value);
}, decodeValue:function(value) {
  var me = this, re = /^(a|n|d|b|s|o|e)\:(.*)$/, matches = re.exec(unescape(value)), all, type, keyValue, values, vLen, v;
  if (!matches || !matches[1]) {
    return;
  }
  type = matches[1];
  value = matches[2];
  switch(type) {
    case 'e':
      return null;
    case 'n':
      return parseFloat(value);
    case 'd':
      return new Date(Date.parse(value));
    case 'b':
      return value === '1';
    case 'a':
      all = [];
      if (value) {
        values = value.split('^');
        vLen = values.length;
        for (v = 0; v < vLen; v++) {
          value = values[v];
          all.push(me.decodeValue(value));
        }
      }
      return all;
    case 'o':
      all = {};
      if (value) {
        values = value.split('^');
        vLen = values.length;
        for (v = 0; v < vLen; v++) {
          value = values[v];
          keyValue = value.split('\x3d');
          all[keyValue[0]] = me.decodeValue(keyValue[1]);
        }
      }
      return all;
    default:
      return value;
  }
}, encodeValue:function(value) {
  var flat = '', i = 0, enc, len, key;
  if (value == null) {
    return 'e:1';
  } else {
    if (typeof value === 'number') {
      enc = 'n:' + value;
    } else {
      if (typeof value === 'boolean') {
        enc = 'b:' + (value ? '1' : '0');
      } else {
        if (Ext.isDate(value)) {
          enc = 'd:' + value.toUTCString();
        } else {
          if (Ext.isArray(value)) {
            for (len = value.length; i < len; i++) {
              flat += this.encodeValue(value[i]);
              if (i !== len - 1) {
                flat += '^';
              }
            }
            enc = 'a:' + flat;
          } else {
            if (typeof value === 'object') {
              for (key in value) {
                if (typeof value[key] !== 'function' && value[key] !== undefined) {
                  flat += key + '\x3d' + this.encodeValue(value[key]) + '^';
                }
              }
              enc = 'o:' + flat.substring(0, flat.length - 1);
            } else {
              enc = 's:' + value;
            }
          }
        }
      }
    }
  }
  return escape(enc);
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.state, 'Provider'], 0);
Ext.cmd.derive('Ext.state.Manager', Ext.Base, {singleton:true, constructor:function() {
  this.provider = new Ext.state.Provider;
}, setProvider:function(stateProvider) {
  this.provider = stateProvider;
}, get:function(key, defaultValue) {
  return this.provider.get(key, defaultValue);
}, set:function(key, value) {
  this.provider.set(key, value);
}, clear:function(key) {
  this.provider.clear(key);
}, getProvider:function() {
  return this.provider;
}}, 1, 0, 0, 0, 0, 0, [Ext.state, 'Manager'], 0);
Ext.cmd.derive('Ext.state.Stateful', Ext.Base, {mixinId:'state', config:{stateful:null}, saveDelay:100, constructor:function() {
  var me = this;
  if (!me.stateEvents) {
    me.stateEvents = [];
  }
  if (me.stateful) {
    me.addStateEvents(me.stateEvents);
    me.initState();
  }
}, addStateEvents:function(events) {
  var me = this, i, event, stateEventsByName, eventArray;
  if (me.stateful && me.getStateId()) {
    eventArray = typeof events === 'string' ? arguments : events;
    stateEventsByName = me.stateEventsByName || (me.stateEventsByName = {});
    for (i = eventArray.length; i--;) {
      event = eventArray[i];
      if (event && !stateEventsByName[event]) {
        stateEventsByName[event] = 1;
        me.on(event, me.onStateChange, me);
      }
    }
  }
}, onStateChange:function() {
  var me = this, delay = me.saveDelay, statics, runner;
  if (!me.stateful) {
    return;
  }
  if (delay) {
    if (!me.stateTask) {
      statics = Ext.state.Stateful;
      runner = statics.runner || (statics.runner = new Ext.util.TaskRunner);
      me.stateTask = runner.newTask({run:me.saveState, scope:me, interval:delay, repeat:1, fireIdleEvent:false});
    }
    me.stateTask.start();
  } else {
    me.saveState();
  }
}, saveState:function() {
  var me = this, stateful = me.getStateful(), id = stateful && me.getStateId(), hasListeners = me.hasListeners, cfg, configs, plugins, plugin, i, len, state, pluginState;
  if (id) {
    state = me.getState() || {};
    if (Ext.isObject(stateful)) {
      configs = me.self.getConfigurator();
      configs = configs.configs;
      for (i in stateful) {
        if (stateful[i]) {
          if (!(i in state)) {
            cfg = configs[i];
            state[i] = cfg ? me[cfg.get]() : me[i];
          }
        } else {
          delete state[i];
        }
      }
    }
    plugins = me.getPlugins() || [];
    for (i = 0, len = plugins.length; i < len; i++) {
      plugin = plugins[i];
      if (plugin && plugin.getState) {
        pluginState = plugin.getState(state);
        if (pluginState && !state[plugin.ptype]) {
          state[plugin.ptype] = pluginState;
        }
      }
    }
    if (!hasListeners.beforestatesave || me.fireEvent('beforestatesave', me, state) !== false) {
      Ext.state.Manager.set(id, state);
      if (hasListeners.statesave) {
        me.fireEvent('statesave', me, state);
      }
    }
  }
}, getState:function() {
  return null;
}, applyState:function(state) {
  if (state) {
    Ext.apply(this, state);
  }
}, getStateId:function() {
  var me = this;
  return me.stateId || (me.autoGenId ? null : me.id);
}, initState:function() {
  var me = this, id = me.stateful && me.getStateId(), hasListeners = me.hasListeners, state, combinedState, i, len, plugins, plugin, pluginType;
  if (id) {
    combinedState = Ext.state.Manager.get(id);
    if (combinedState) {
      state = Ext.apply({}, combinedState);
      if (!hasListeners.beforestaterestore || me.fireEvent('beforestaterestore', me, combinedState) !== false) {
        plugins = me.getPlugins() || [];
        for (i = 0, len = plugins.length; i < len; i++) {
          plugin = plugins[i];
          if (plugin) {
            pluginType = plugin.ptype;
            if (plugin.applyState) {
              plugin.applyState(state[pluginType], combinedState);
            }
            delete state[pluginType];
          }
        }
        me.applyState(state);
        if (hasListeners.staterestore) {
          me.fireEvent('staterestore', me, combinedState);
        }
      }
    }
  }
}, savePropToState:function(propName, state, stateName) {
  var me = this, value = me[propName], config = me.initialConfig;
  if (me.hasOwnProperty(propName)) {
    if (!config || config[propName] !== value) {
      if (state) {
        state[stateName || propName] = value;
      }
      return true;
    }
  }
  return false;
}, savePropsToState:function(propNames, state) {
  var me = this, i, n;
  if (typeof propNames === 'string') {
    me.savePropToState(propNames, state);
  } else {
    for (i = 0, n = propNames.length; i < n; ++i) {
      me.savePropToState(propNames[i], state);
    }
  }
  return state;
}, destroy:function() {
  var task = this.stateTask;
  if (task) {
    task.destroy();
    this.stateTask = null;
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.state, 'Stateful'], 0);
Ext.cmd.derive('Ext.Component', Ext.Base, {alternateClassName:'Ext.AbstractComponent', statics:{AUTO_ID:1000, pendingLayouts:null, layoutSuspendCount:0, DIRECTION_TOP:'top', DIRECTION_RIGHT:'right', DIRECTION_BOTTOM:'bottom', DIRECTION_LEFT:'left', VERTICAL_DIRECTION_Re:/^(?:top|bottom)$/, INVALID_ID_CHARS_Re:/[\.,\s]/g, ariaHighContrastModeCls:'x-aria-highcontrast', cancelLayout:function(comp, isDestroying) {
  var context = this.runningLayoutContext || this.pendingLayouts;
  if (context) {
    context.cancelComponent(comp, false, isDestroying);
  }
}, from:function(el, limit, selector) {
  return Ext.ComponentManager.from(el, limit, selector);
}, fromElement:function(el, limit, selector) {
  return Ext.ComponentManager.from(el, limit, selector);
}, flushLayouts:function() {
  var me = this, context = me.pendingLayouts;
  if (context && context.invalidQueue.length) {
    me.pendingLayouts = null;
    me.runningLayoutContext = context;
    Ext.override(context, {runComplete:function() {
      me.runningLayoutContext = null;
      var Scroller = Ext.scroll.Scroller, GlobalEvents = Ext.GlobalEvents, result;
      if (Scroller.viewport) {
        Scroller.viewport.restoreState();
      }
      result = this.callParent();
      if (GlobalEvents.hasListeners.afterlayout) {
        GlobalEvents.fireEvent('afterlayout');
      }
      return result;
    }});
    context.run();
  }
}, resumeLayouts:function(flush) {
  if (this.layoutSuspendCount && !--this.layoutSuspendCount) {
    if (flush) {
      this.flushLayouts();
    }
    if (Ext.GlobalEvents.hasListeners.resumelayouts) {
      Ext.GlobalEvents.fireEvent('resumelayouts');
    }
  }
}, suspendLayouts:function() {
  ++this.layoutSuspendCount;
}, updateLayout:function(comp, defer) {
  var me = this, running = me.runningLayoutContext, pending;
  if (running) {
    running.queueInvalidate(comp);
  } else {
    pending = me.pendingLayouts || (me.pendingLayouts = new Ext.layout.Context);
    pending.queueInvalidate(comp);
    if (!defer && !me.layoutSuspendCount && !comp.isLayoutSuspended()) {
      me.flushLayouts();
    }
  }
}}, $configPrefixed:false, $configStrict:false, clearPropertiesOnDestroy:'async', manageLayoutScroll:true, config:{data:null, maxHeight:null, maxWidth:null, minHeight:null, minWidth:null, scrollable:null}, renderConfig:{touchAction:null}, defaultBindProperty:'html', alignTarget:null, autoRender:false, autoShow:false, baseCls:'x-component', childEls:{frameTable:{frame:true}, frameTL:{frame:'tl'}, frameTC:{frame:'tc'}, frameTR:{frame:'tr'}, frameML:{frame:'ml'}, frameBody:{frame:'mc'}, frameMR:{frame:'mr'}, 
frameBL:{frame:'bl'}, frameBC:{frame:'bc'}, frameBR:{frame:'br'}}, componentLayout:'autocomponent', defaultAlign:'c-c', disabled:false, disabledRe:/^(?:button|input|select|textarea|optgroup|option|fieldset)$/i, nonMaskableRe:function() {
  var re = ['input', 'select', 'textarea', 'optgroup', 'option', 'table'];
  if (Ext.isIE9m && !(Ext.isIE9 && !Ext.isIEQuirks)) {
    re.push('p');
  }
  return new RegExp('^(?:' + re.join('|') + ')$', 'i');
}(), disabledCls:'x-item-disabled', draggable:false, floating:false, hidden:false, hideMode:'display', maskElement:null, renderTpl:'{%this.renderContent(out,values)%}', resizeHandles:'all', shrinkWrap:2, toFrontOnShow:true, synthetic:false, tplWriteMode:'overwrite', ui:'default', uiCls:[], userCls:null, weight:null, allowDomMove:true, autoGenId:false, borderBoxCls:'x-border-box', componentLayoutCounter:0, contentPaddingProperty:'padding', deferLayouts:false, frameSize:null, horizontalPosProp:'left', 
isComponent:true, _isLayoutRoot:false, layoutSuspendCount:0, liquidLayout:false, maskOnDisable:true, rendered:false, rootCls:'x-body', scrollerCls:'x-scroll-scroller', _scrollFlags:{auto:{auto:{overflowX:'auto', overflowY:'auto', x:true, y:true, both:true}, 'false':{overflowX:'auto', overflowY:'hidden', x:true, y:false, both:false}, scroll:{overflowX:'auto', overflowY:'scroll', x:true, y:true, both:true}}, 'false':{auto:{overflowX:'hidden', overflowY:'auto', x:false, y:true, both:false}, 'false':{overflowX:'hidden', 
overflowY:'hidden', x:false, y:false, both:false}, scroll:{overflowX:'hidden', overflowY:'scroll', x:false, y:true, both:false}}, scroll:{auto:{overflowX:'scroll', overflowY:'auto', x:true, y:true, both:true}, 'false':{overflowX:'scroll', overflowY:'hidden', x:true, y:false, both:false}, scroll:{overflowX:'scroll', overflowY:'scroll', x:true, y:true, both:true}}, none:{overflowX:'', overflowY:'', x:false, y:false, both:false}}, _scrollableCfg:{x:{x:true, y:false}, y:{x:false, y:true}, horizontal:{x:true, 
y:false}, vertical:{x:false, y:true}, both:{x:true, y:true}, 'true':{x:true, y:true}}, validIdRe:Ext.validIdRe, constructor:function(config) {
  var me = this, i, len, xhooks, controller, autoScroll, overflowX, overflowY, scrollable;
  config = config || {};
  if (config.initialConfig) {
    if (config.isAction) {
      me.baseAction = config;
    }
    config = config.initialConfig;
  } else {
    if (config.tagName || config.dom || Ext.isString(config)) {
      config = {applyTo:config, id:config.id || config};
    }
  }
  me.initialConfig = config;
  me.$iid = ++Ext.$nextIid;
  if (config && config.controller || me.config.controller) {
    me.referenceHolder = true;
  }
  me.getId();
  me.protoEl = new Ext.util.ProtoElement;
  me.initConfig(config);
  if (me.scrollable == null) {
    autoScroll = me.autoScroll;
    if (autoScroll) {
      scrollable = !!autoScroll;
    } else {
      overflowX = me.overflowX;
      overflowY = me.overflowY;
      if (overflowX || overflowY) {
        scrollable = {x:overflowX && overflowX !== 'hidden' ? overflowX : false, y:overflowY && overflowY !== 'hidden' ? overflowY : false};
      }
    }
    if (scrollable) {
      me.setScrollable(scrollable);
    }
  }
  xhooks = me.xhooks;
  if (xhooks) {
    delete me.xhooks;
    Ext.override(me, xhooks);
  }
  me.mixins.elementCt.constructor.call(me);
  me.setupProtoEl();
  if (me.cls) {
    me.initialCls = me.cls;
    me.protoEl.addCls(me.cls);
  }
  if (me.style) {
    me.initialStyle = me.style;
    me.protoEl.setStyle(me.style);
  }
  me.renderData = me.renderData || {};
  me.initComponent();
  if (!me.preventRegister) {
    Ext.ComponentManager.register(me);
  }
  me.mixins.state.constructor.call(me);
  me.addStateEvents('resize');
  controller = me.getController();
  if (controller) {
    controller.init(me);
  }
  if (me.plugins) {
    for (i = 0, len = me.plugins.length; i < len; i++) {
      me.plugins[i] = me.initPlugin(me.plugins[i]);
    }
  }
  me.loader = me.getLoader();
  if (me.disabled) {
    me.disabled = false;
    me.disable(true);
  }
  if (me.renderTo) {
    me.render(me.renderTo);
  }
  if (me.autoShow && !me.$initParent) {
    me.show();
  }
  if (me.baseAction) {
    me.baseAction.addComponent(me);
  }
}, beforeInitConfig:function() {
  this.mixins.observable.constructor.call(this);
}, addCls:function(cls) {
  var me = this, el = me.rendered ? me.el : me.protoEl;
  el.addCls.apply(el, arguments);
  return me;
}, addClsWithUI:function(classes, skip) {
  var me = this, clsArray = [], i = 0, uiCls = me.uiCls = Ext.Array.clone(me.uiCls), activeUI = me.activeUI, length, cls;
  if (typeof classes === 'string') {
    classes = classes.indexOf(' ') < 0 ? [classes] : Ext.String.splitWords(classes);
  }
  length = classes.length;
  for (; i < length; i++) {
    cls = classes[i];
    if (cls && !me.hasUICls(cls)) {
      uiCls.push(cls);
      if (activeUI) {
        clsArray = clsArray.concat(me.addUIClsToElement(cls));
      }
    }
  }
  if (skip !== true && activeUI) {
    me.addCls(clsArray);
  }
  return clsArray;
}, afterComponentLayout:function(width, height, oldWidth, oldHeight) {
  var me = this, scroller = me.scrollable;
  if (++me.componentLayoutCounter === 1) {
    me.afterFirstLayout(width, height);
  } else {
    if (me.manageLayoutScroll && scroller) {
      scroller.restoreState();
    }
  }
  if (width !== oldWidth || height !== oldHeight) {
    me.onResize(width, height, oldWidth, oldHeight);
  }
  if (me.floating) {
    me.onAfterFloatLayout();
  }
}, addPlugin:function(plugin) {
  var me = this;
  plugin = me.constructPlugin(plugin);
  if (me.plugins) {
    me.plugins.push(plugin);
  } else {
    me.plugins = [plugin];
  }
  if (me.pluginsInitialized) {
    me.initPlugin(plugin);
  }
  return plugin;
}, addPropertyToState:function(state, propName, value) {
  var me = this, len = arguments.length;
  if (len === 3 || me.hasOwnProperty(propName)) {
    if (len < 3) {
      value = me[propName];
    }
    if (value !== me.initialConfig[propName]) {
      (state || (state = {}))[propName] = value;
    }
  }
  return state;
}, addUIClsToElement:function(uiCls) {
  var me = this, baseClsUI = me.baseCls + '-' + me.ui + '-' + uiCls, result = ['x-' + uiCls, me.baseCls + '-' + uiCls, baseClsUI], childEls, childElName, el, suffix;
  if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
    baseClsUI += '-';
    childEls = me.getChildEls();
    for (childElName in childEls) {
      suffix = childEls[childElName].frame;
      if (suffix && suffix !== true) {
        el = me[childElName];
        if (el) {
          el.addCls(baseClsUI + suffix);
        }
      }
    }
  }
  return result;
}, removeUIClsFromElement:function(uiCls) {
  var me = this, baseClsUI = me.baseCls + '-' + me.ui + '-' + uiCls, result = ['x-' + uiCls, me.baseCls + '-' + uiCls, baseClsUI], childEls, childElName, el, suffix;
  if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
    baseClsUI += '-';
    childEls = me.getChildEls();
    for (childElName in childEls) {
      suffix = childEls[childElName].frame;
      if (suffix && suffix !== true) {
        el = me[childElName];
        if (el) {
          el.removeCls(baseClsUI + suffix);
        }
      }
    }
  }
  return result;
}, adjustPosition:function(x, y) {
  var me = this, floatParentBox;
  if (me.isContainedFloater()) {
    floatParentBox = me.floatParent.getTargetEl().getViewRegion();
    x += floatParentBox.left;
    y += floatParentBox.top;
  }
  return {x:x, y:y};
}, afterHide:function(callback, scope) {
  var me = this, container = me.ownerFocusableContainer;
  delete me.getInherited().topmostFocusEvent;
  me.hiddenByLayout = null;
  if (me.ownerLayout) {
    me.updateLayout({isRoot:false});
  }
  if (container && !container.onFocusableChildHide.$nullFn) {
    container.onFocusableChildHide(me);
  }
  me.fireHierarchyEvent('hide');
  me.fireEvent('hide', me);
  Ext.callback(callback, scope || me);
}, afterSetPosition:function(x, y) {
  var me = this;
  me.onPosition(x, y);
  if (me.hasListeners.move) {
    me.fireEvent('move', me, x, y);
  }
}, afterShow:function(animateTarget, callback, scope) {
  var me = this, myEl = me.el, zim = me.zIndexManager, fromBox, toBox, ghostPanel;
  animateTarget = me.getAnimateTarget(animateTarget);
  if (zim) {
    zim.suspendReflow();
  }
  if (!me.ghost) {
    animateTarget = null;
  }
  if (animateTarget) {
    toBox = {x:myEl.getX(), y:myEl.getY(), width:myEl.dom.offsetWidth, height:myEl.dom.offsetHeight};
    fromBox = {x:animateTarget.getX(), y:animateTarget.getY(), width:animateTarget.dom.offsetWidth, height:animateTarget.dom.offsetHeight};
    me.fireHierarchyEvent('show');
    ghostPanel = me.ghost();
    ghostPanel.el.stopAnimation();
    ghostPanel.setX(-10000);
    me.ghostBox = toBox;
    ghostPanel.el.animate({from:fromBox, to:toBox, listeners:{afteranimate:function() {
      if (!me.destroying) {
        ghostPanel.componentLayout.lastComponentSize = null;
        me.unghost();
        me.ghostBox = null;
        me.onShowComplete(callback, scope);
      }
    }}});
  } else {
    me.onShowComplete(callback, scope);
    me.fireHierarchyEvent('show');
  }
  if (zim) {
    zim.resumeReflow(true);
  }
}, animate:function(animObj) {
  var me = this, hasToWidth, hasToHeight, toHeight, toWidth, to, clearWidth, clearHeight, curWidth, w, curHeight, h, isExpanding, wasConstrained, wasConstrainedHeader, passedCallback, oldOverflow;
  animObj = animObj || {};
  to = animObj.to || {};
  if (Ext.fx.Manager.hasFxBlock(me.id)) {
    return me;
  }
  hasToWidth = Ext.isDefined(to.width);
  if (hasToWidth) {
    toWidth = Ext.Number.constrain(to.width, me.minWidth, me.maxWidth);
  }
  hasToHeight = Ext.isDefined(to.height);
  if (hasToHeight) {
    toHeight = Ext.Number.constrain(to.height, me.minHeight, me.maxHeight);
  }
  if (!animObj.dynamic && (hasToWidth || hasToHeight)) {
    curWidth = (animObj.from ? animObj.from.width : undefined) || me.getWidth();
    w = curWidth;
    curHeight = (animObj.from ? animObj.from.height : undefined) || me.getHeight();
    h = curHeight;
    isExpanding = false;
    if (hasToHeight && toHeight > curHeight) {
      h = toHeight;
      isExpanding = true;
    }
    if (hasToWidth && toWidth > curWidth) {
      w = toWidth;
      isExpanding = true;
    }
    if (hasToHeight || hasToWidth) {
      oldOverflow = me.el.getStyle('overflow');
      if (oldOverflow !== 'hidden') {
        me.el.setStyle('overflow', 'hidden');
      }
    }
    if (isExpanding) {
      clearWidth = !Ext.isNumber(me.width);
      clearHeight = !Ext.isNumber(me.height);
      me.setSize(w, h);
      me.el.setSize(curWidth, curHeight);
      if (clearWidth) {
        delete me.width;
      }
      if (clearHeight) {
        delete me.height;
      }
    }
    if (hasToWidth) {
      to.width = toWidth;
    }
    if (hasToHeight) {
      to.height = toHeight;
    }
  }
  wasConstrained = me.constrain;
  wasConstrainedHeader = me.constrainHeader;
  if (wasConstrained || wasConstrainedHeader) {
    me.constrain = me.constrainHeader = false;
    passedCallback = animObj.callback;
    animObj.callback = function() {
      me.constrain = wasConstrained;
      me.constrainHeader = wasConstrainedHeader;
      if (passedCallback) {
        passedCallback.call(animObj.scope || me, arguments);
      }
      if (oldOverflow !== 'hidden') {
        me.el.setStyle('overflow', oldOverflow);
      }
    };
  }
  return me.mixins.animate.animate.apply(me, arguments);
}, applyScrollable:function(scrollable, oldScrollable) {
  var me = this, rendered = me.rendered, scrollableCfg;
  if (scrollable) {
    if (scrollable === true || typeof scrollable === 'string') {
      scrollableCfg = me._scrollableCfg[scrollable];
      scrollable = scrollableCfg;
    }
    if (oldScrollable) {
      oldScrollable.setConfig(scrollable);
      scrollable = oldScrollable;
    } else {
      scrollable = Ext.Object.chain(scrollable);
      if (rendered) {
        scrollable.element = me.getOverflowEl();
      }
      scrollable = Ext.scroll.Scroller.create(scrollable, me.scrollableType);
      scrollable.component = me;
    }
  } else {
    if (oldScrollable) {
      scrollable = oldScrollable;
      oldScrollable.setConfig({x:false, y:false});
    }
  }
  if (me.rendered && !me.destroying && !me.destroyed) {
    if (scrollable) {
      me.getOverflowStyle();
    } else {
      me.scrollFlags = me._scrollFlags.none;
    }
    me.updateLayout();
  }
  return scrollable;
}, getScrollableClientRegion:function() {
  return this.getScrollable().getElement().getClientRegion();
}, applyTouchAction:function(touchAction, oldTouchAction) {
  if (oldTouchAction != null) {
    touchAction = Ext.merge({}, oldTouchAction, touchAction);
  }
  return touchAction;
}, beforeDestroy:Ext.emptyFn, beforeLayout:function() {
  if (this.floating) {
    this.onBeforeFloatLayout();
  }
}, beforeSetPosition:function(x, y, animate) {
  var me = this, pos = null, x0, hasX, hasY, adj;
  if (x) {
    if (Ext.isNumber(x0 = x[0])) {
      animate = y;
      y = x[1];
      x = x0;
    } else {
      if ((x0 = x.x) !== undefined) {
        animate = y;
        y = x.y;
        x = x0;
      }
    }
  }
  if (me.constrain || me.constrainHeader) {
    pos = me.calculateConstrainedPosition(null, [x, y], true);
    if (pos) {
      x = pos[0];
      y = pos[1];
    }
  }
  hasX = x !== undefined;
  hasY = y !== undefined;
  if (hasX || hasY) {
    me.x = x;
    me.y = y;
    adj = me.adjustPosition(x, y);
    pos = {x:adj.x, y:adj.y, anim:animate, hasX:hasX, hasY:hasY};
  }
  return pos;
}, beforeShow:Ext.emptyFn, bubble:function(fn, scope, args) {
  var p = this;
  while (p) {
    if (fn.apply(scope || p, args || [p]) === false) {
      break;
    }
    p = p.getBubbleTarget();
  }
  return this;
}, clearListeners:function() {
  var me = this;
  me.mixins.observable.clearListeners.call(me);
  me.mixins.componentDelegation.clearDelegatedListeners.call(me);
}, cloneConfig:function(overrides) {
  overrides = overrides || {};
  var id = overrides.id || Ext.id(), cfg = Ext.applyIf(overrides, this.initialConfig), self;
  cfg.id = id;
  self = Ext.getClass(this);
  return new self(cfg);
}, destroy:function() {
  var me = this;
  if (!me.hasListeners.beforedestroy || me.fireEvent('beforedestroy', me) !== false) {
    me.isDestroying = me.destroying = true;
    me.doDestroy();
    me.clearListeners();
    me.isDestroying = me.destroying = false;
    me.callParent();
    me.mixins.componentDelegation.destroyComponentDelegation.call(me);
    me.mixins.observable.destroyObservable.call(me, true);
  }
}, doDestroy:function() {
  var me = this, focusableContainer = me.ownerFocusableContainer, container = me.container, selectors = me.renderSelectors, selector, ownerCt, el;
  ownerCt = me.floatParent || me.ownerCt;
  if (me.floating) {
    delete me.floatParent;
    if (me.zIndexManager && !me.zIndexManager.destroyed) {
      me.zIndexManager.unregister(me);
    }
    me.floating = true;
  }
  me.removeBindings();
  if (!me.beforeDestroy.$emptyFn) {
    me.beforeDestroy();
  }
  me.destroyBindable();
  if (ownerCt && ownerCt.remove) {
    ownerCt.remove(me, {destroy:false});
  }
  me.stopAnimation();
  if (me.rendered) {
    Ext.destroy(me.loadMask, me.dd, me.resizer, me.proxy, me.proxyWrap, me.resizerComponent, me.scrollable, me.contentEl);
  }
  if (focusableContainer && !focusableContainer.onFocusableChildDestroy.$nullFn) {
    focusableContainer.onFocusableChildDestroy(me);
  }
  if (me.focusable) {
    me.destroyFocusable();
  }
  Ext.destroy(me.componentLayout, me.loadMask, me.floatingDescendants);
  if (!me.onDestroy.$emptyFn) {
    me.onDestroy();
  }
  Ext.destroy(me.plugins);
  if (me.rendered) {
    Ext.Component.cancelLayout(me, true);
  }
  me.componentLayout = null;
  if (me.hasListeners.destroy) {
    me.fireEvent('destroy', me);
  }
  if (!me.preventRegister) {
    Ext.ComponentManager.unregister(me);
  }
  me.mixins.state.destroy.call(me);
  if (me.floating) {
    me.onFloatDestroy();
  }
  if (me.rendered) {
    if (me.showListenerIE) {
      me.showListenerIE.destroy();
      me.showListenerIE = null;
    }
    if (!me.preserveElOnDestroy) {
      me.el.destroy();
    }
    if (me.collectContainerElement && container) {
      if (!container.destroyed) {
        container.collect();
      }
      me.container = null;
    }
    me.el.component = null;
    me.mixins.elementCt.destroy.call(me);
    if (selectors) {
      for (selector in selectors) {
        if (selectors.hasOwnProperty(selector)) {
          el = me[selector];
          if (el) {
            delete me[selector];
            el.destroy();
          }
        }
      }
    }
    me.rendered = false;
  }
}, disable:function(silent, fromParent) {
  var me = this, container = me.ownerFocusableContainer, inherited = me.getInherited();
  if (!fromParent) {
    inherited.disabled = true;
    me.savedDisabled = true;
  }
  if (me.maskOnDisable) {
    inherited.disableMask = true;
  }
  if (!me.disabled) {
    if (container && !container.beforeFocusableChildDisable.$nullFn) {
      container.beforeFocusableChildDisable(me);
    }
    me.addCls(me.disabledCls);
    if (me.rendered) {
      me.onDisable();
    } else {
      me.disableOnRender = true;
    }
    me.disabled = true;
    if (silent !== true) {
      me.fireEvent('disable', me);
    }
    if (container && !container.onFocusableChildDisable.$nullFn) {
      container.onFocusableChildDisable(me);
    }
  }
  return me;
}, doFireEvent:function(eventName, args, bubbles) {
  var me = this, ret;
  ret = me.mixins.observable.doFireEvent.call(me, eventName, args, bubbles);
  if (ret !== false && !me.destroyed) {
    ret = me.mixins.componentDelegation.doFireDelegatedEvent.call(me, eventName, args);
  }
  return ret;
}, enable:function(silent, fromParent) {
  var me = this, container = me.ownerFocusableContainer, inherited = me.getInherited();
  if (!fromParent) {
    delete me.getInherited().disabled;
    me.savedDisabled = false;
  }
  if (me.maskOnDisable) {
    delete inherited.disableMask;
  }
  if (me.disabled) {
    if (!(fromParent && inherited.hasOwnProperty('disabled'))) {
      if (container && !container.beforeFocusableChildEnable.$nullFn) {
        container.beforeFocusableChildEnable(me);
      }
      me.disableOnRender = false;
      me.removeCls(me.disabledCls);
      if (me.rendered) {
        me.onEnable();
      }
      me.disabled = false;
      if (silent !== true) {
        me.fireEvent('enable', me);
      }
      if (container && !container.onFocusableChildEnable.$nullFn) {
        container.onFocusableChildEnable(me);
      }
    }
  }
  return me;
}, findParentBy:function(fn) {
  var p;
  for (p = this.getRefOwner(); p && !fn(p, this); p = p.getRefOwner()) {
  }
  return p || null;
}, findParentByType:function(xtype) {
  return Ext.isFunction(xtype) ? this.findParentBy(function(p) {
    return p.self === xtype || p.constructor === xtype;
  }) : this.up(xtype);
}, findPlugin:function(ptype) {
  var i, plugins = this.plugins, ln = plugins && plugins.length;
  for (i = 0; i < ln; i++) {
    if (plugins[i].ptype === ptype) {
      return plugins[i];
    }
  }
}, getAnimateTarget:function(target) {
  target = target || this.animateTarget;
  if (target) {
    target = target.isComponent ? target.getEl() : Ext.get(target);
  }
  return target || null;
}, getBubbleTarget:function() {
  return this.getRefOwner();
}, getComponentLayout:function() {
  var me = this;
  if (!me.componentLayout || !me.componentLayout.isLayout) {
    me.setComponentLayout(Ext.layout.Layout.create(me.componentLayout, 'autocomponent'));
  }
  return me.componentLayout;
}, getEl:function() {
  return this.el;
}, getHeight:function() {
  return this.el.getHeight();
}, initInheritedState:function(inheritedState) {
  var me = this, layout = me.componentLayout;
  if (me.hidden) {
    inheritedState.hidden = true;
  }
  if (me.collapseImmune) {
    inheritedState.collapseImmune = true;
  }
  if (me.modelValidation !== undefined) {
    inheritedState.modelValidation = me.modelValidation;
  }
  if (me.savedDisabled) {
    inheritedState.disabled = true;
  }
  me.mixins.bindable.initInheritedState.call(me, inheritedState);
  if (layout && layout.initInheritedState) {
    layout.initInheritedState(inheritedState);
  }
}, getId:function() {
  var me = this, xtype;
  if (!(me.id || (me.id = me.initialConfig.id))) {
    xtype = me.getXType();
    if (xtype) {
      xtype = xtype.replace(Ext.Component.INVALID_ID_CHARS_Re, '-');
    } else {
      xtype = Ext.name.toLowerCase() + '-comp';
    }
    me.id = xtype + '-' + me.getAutoId();
  }
  return me.id;
}, getItemId:function() {
  return this.itemId || this.id;
}, getLoader:function() {
  var me = this, loader = me.loader;
  if (loader) {
    if (!loader.isLoader) {
      me.loader = new Ext.ComponentLoader(Ext.apply({target:me}, loader));
    } else {
      loader.setTarget(me);
    }
    return me.loader;
  }
  return null;
}, getMaskTarget:function() {
  return this.maskElement ? this[this.maskElement] : null;
}, getPlugin:function(id) {
  var i, plugins = this.plugins, ln = plugins && plugins.length, plugin;
  for (i = 0; i < ln; i++) {
    plugin = plugins[i];
    if (plugin.id === id || plugin.pluginId === id) {
      return plugin;
    }
  }
  return null;
}, getPosition:function(local) {
  var me = this, xy, isContainedFloater = me.isContainedFloater(), floatParentBox;
  if (local === true && !isContainedFloater) {
    return [me.getLocalX(), me.getLocalY()];
  }
  xy = me.getXY();
  if (local === true && isContainedFloater) {
    floatParentBox = me.floatParent.getTargetEl().getViewRegion();
    xy[0] -= floatParentBox.left;
    xy[1] -= floatParentBox.top;
  }
  return xy;
}, getScrollX:function() {
  var scroller = this.getScrollable();
  return scroller ? scroller.getPosition().x : 0;
}, getScrollY:function() {
  var scroller = this.getScrollable();
  return scroller ? scroller.getPosition().y : 0;
}, getSize:function(contentSize) {
  return this.el.getSize(contentSize);
}, getSizeModel:function(ownerCtSizeModel) {
  var me = this, models = Ext.layout.SizeModel, ownerContext = me.componentLayout.ownerContext, width = me.width, height = me.height, typeofWidth, typeofHeight, hasPixelWidth, hasPixelHeight, hasWidthStyle, hasHeightStyle, heightModel, ownerLayout, policy, shrinkWrap, topLevel, widthModel, isFloating = me.floating || me.floated;
  if (ownerContext) {
    widthModel = ownerContext.widthModel;
    heightModel = ownerContext.heightModel;
  }
  if (!widthModel || !heightModel) {
    hasPixelWidth = (typeofWidth = typeof width) === 'number';
    hasPixelHeight = (typeofHeight = typeof height) === 'number';
    topLevel = isFloating || !(ownerLayout = me.ownerLayout);
    if (topLevel) {
      policy = Ext.layout.Layout.prototype.autoSizePolicy;
      shrinkWrap = isFloating ? 3 : me.shrinkWrap;
      if (hasPixelWidth) {
        widthModel = models.configured;
      }
      if (hasPixelHeight) {
        heightModel = models.configured;
      }
    } else {
      policy = ownerLayout.getItemSizePolicy(me, ownerCtSizeModel);
      shrinkWrap = ownerLayout.isItemShrinkWrap(me);
    }
    if (ownerContext) {
      ownerContext.ownerSizePolicy = policy;
    }
    shrinkWrap = shrinkWrap === true ? 3 : shrinkWrap || 0;
    if (topLevel && shrinkWrap) {
      if (width && typeofWidth === 'string') {
        shrinkWrap &= 2;
        hasWidthStyle = true;
      }
      if (height && typeofHeight === 'string') {
        shrinkWrap &= 1;
        hasHeightStyle = true;
      }
    }
    if (shrinkWrap !== 3) {
      if (!ownerCtSizeModel) {
        ownerCtSizeModel = me.ownerCt && me.ownerCt.getSizeModel();
      }
      if (ownerCtSizeModel) {
        shrinkWrap |= (ownerCtSizeModel.width.shrinkWrap ? 1 : 0) | (ownerCtSizeModel.height.shrinkWrap ? 2 : 0);
      }
    }
    if (!widthModel) {
      if (!policy.setsWidth && !(me.frame && hasWidthStyle)) {
        if (hasPixelWidth) {
          widthModel = models.configured;
        } else {
          widthModel = shrinkWrap & 1 ? models.shrinkWrap : models.natural;
        }
      } else {
        if (policy.readsWidth) {
          if (hasPixelWidth) {
            widthModel = models.calculatedFromConfigured;
          } else {
            widthModel = shrinkWrap & 1 ? models.calculatedFromShrinkWrap : models.calculatedFromNatural;
          }
        } else {
          widthModel = models.calculated;
        }
      }
    }
    if (!heightModel) {
      if (!policy.setsHeight && !(me.frame && hasHeightStyle)) {
        if (hasPixelHeight) {
          heightModel = models.configured;
        } else {
          heightModel = shrinkWrap & 2 ? models.shrinkWrap : models.natural;
        }
      } else {
        if (policy.readsHeight) {
          if (hasPixelHeight) {
            heightModel = models.calculatedFromConfigured;
          } else {
            heightModel = shrinkWrap & 2 ? models.calculatedFromShrinkWrap : models.calculatedFromNatural;
          }
        } else {
          heightModel = models.calculated;
        }
      }
    }
  }
  return widthModel.pairsByHeightOrdinal[heightModel.ordinal];
}, getState:function() {
  var me = this, state = null, sizeModel = me.getSizeModel();
  if (sizeModel.width.configured) {
    state = me.addPropertyToState(state, 'width');
  }
  if (sizeModel.height.configured) {
    state = me.addPropertyToState(state, 'height');
  }
  return state;
}, getUserCls:function() {
  return this.userCls;
}, setUserCls:function(cls) {
  var me = this, was = me.userCls;
  if (cls !== was) {
    me.userCls = cls;
    if (me.rendered) {
      me.el.replaceCls(was, cls);
    }
  }
  return was;
}, getWidth:function() {
  return this.el.getWidth();
}, getXType:function() {
  return this.self.xtype;
}, getXTypes:function() {
  var self = this.self, xtypes, parentPrototype, parentXtypes;
  if (!self.xtypes) {
    xtypes = [];
    parentPrototype = this;
    while (parentPrototype) {
      parentXtypes = parentPrototype.xtypes;
      if (parentXtypes !== undefined) {
        xtypes.unshift.apply(xtypes, parentXtypes);
      }
      parentPrototype = parentPrototype.superclass;
    }
    self.xtypeChain = xtypes;
    self.xtypes = xtypes.join('/');
  }
  return self.xtypes;
}, hasCls:function(className) {
  var el = this.rendered ? this.el : this.protoEl;
  return el.hasCls.apply(el, arguments);
}, hasUICls:function(cls) {
  var me = this, uiCls = me.uiCls || [];
  return Ext.Array.contains(uiCls, cls);
}, hide:function(animateTarget, callback, scope) {
  var me = this, container = me.ownerFocusableContainer;
  if (me.pendingShow) {
    me.pendingShow = false;
  }
  if (!(me.rendered && !me.isVisible())) {
    if (!me.hasListeners.beforehide || me.fireEvent('beforehide', me) !== false || me.hierarchicallyHidden) {
      me.getInherited().hidden = me.hidden = true;
      if (container && !container.beforeFocusableChildHide.$nullFn) {
        container.beforeFocusableChildHide(me);
      }
      me.fireHierarchyEvent('beforehide');
      if (me.rendered) {
        me.onHide.apply(me, arguments);
      }
    }
  }
  return me;
}, initComponent:function() {
  var me = this, width = me.width, height = me.height;
  if (me.plugins && !me.plugins.processed) {
    me.constructPlugins();
  }
  me.pluginsInitialized = true;
  if (width != null || height != null) {
    me.setSize(width, height);
  }
  if (me.listeners) {
    me.on(me.listeners);
    me.listeners = null;
  }
  if (me.focusable) {
    me.initFocusable();
  }
}, initEvents:function() {
  var me = this, afterRenderEvents = me.afterRenderEvents, afterRenderEvent, el, property, index, len;
  if (afterRenderEvents) {
    for (property in afterRenderEvents) {
      el = me[property];
      if (el && el.on) {
        afterRenderEvent = afterRenderEvents[property];
        for (index = 0, len = afterRenderEvent.length; index < len; ++index) {
          me.mon(el, afterRenderEvent[index]);
        }
      }
    }
  }
  if (me.focusable) {
    me.initFocusableEvents();
  }
  me.initKeyMap();
}, is:function(selector) {
  return Ext.ComponentQuery.is(this, selector);
}, isDisabled:function() {
  return this.disabled;
}, isDraggable:function() {
  return !!this.draggable;
}, isDroppable:function() {
  return !!this.droppable;
}, isFloating:function() {
  return this.floating;
}, isHidden:function() {
  return this.hidden;
}, getHidden:function() {
  return this.hidden;
}, isHierarchicallyHidden:function() {
  var child = this, hidden = false, parent, parentInheritedState;
  for (; parent = child.ownerCt || child.floatParent; child = parent) {
    parentInheritedState = parent.getInherited();
    if (parentInheritedState.hidden) {
      hidden = true;
      break;
    }
    if (child.getInherited().collapseImmune) {
      if (parent.collapsed && !child.collapseImmune) {
        hidden = true;
        break;
      }
    } else {
      hidden = !!parentInheritedState.collapsed;
      break;
    }
  }
  return hidden;
}, isLayoutChild:function(ownerCandidate) {
  return !this.floating && !!this.up(ownerCandidate);
}, isLayoutRoot:function() {
  var me = this, ownerLayout = me.ownerLayout;
  if (!ownerLayout || me._isLayoutRoot || me.floating) {
    return true;
  }
  return ownerLayout.isItemLayoutRoot(me);
}, isLayoutSuspended:function() {
  var comp = this, ownerLayout;
  while (comp) {
    if (comp.layoutSuspendCount || comp.suspendLayout) {
      return true;
    }
    ownerLayout = comp.ownerLayout;
    if (!ownerLayout) {
      break;
    }
    comp = ownerLayout.owner;
  }
  return false;
}, isVisible:function(deep) {
  var me = this, hidden;
  if (me.hidden || !me.rendered || me.destroyed) {
    hidden = true;
  } else {
    if (deep) {
      hidden = me.isHierarchicallyHidden();
    }
  }
  return !hidden;
}, isXType:function(xtype, shallow) {
  return shallow ? Ext.Array.indexOf(this.xtypes, xtype) !== -1 : !!this.xtypesMap[xtype];
}, isMasked:function(deep) {
  var me = this;
  return !!(me.masked || me.loadMask && me.loadMask.isVisible() || deep && me.getInherited().masked);
}, lookupTpl:function(name) {
  return Ext.XTemplate.getTpl(this, name);
}, setMasked:function(isMasked) {
  var me = this, container = me.ownerFocusableContainer;
  if (isMasked) {
    me.masked = true;
    me.getInherited().masked = isMasked;
  } else {
    me.masked = false;
    delete me.getInherited().masked;
  }
  if (container && !container.onFocusableChildMasked.$nullFn) {
    container.onFocusableChildMasked(me, isMasked);
  }
  return me;
}, mask:function(msg, msgCls, elHeight) {
  var box = this.lastBox, target = this.getMaskTarget() || this.el;
  if (box) {
    elHeight = box.height;
  }
  target.mask(msg, msgCls, elHeight);
  this.setMasked(true);
}, nextNode:function(selector, includeSelf) {
  var node = this, ownerCt = node.ownerCt, result, it, len, i, sib;
  if (includeSelf && node.is(selector)) {
    return node;
  }
  if (ownerCt) {
    for (it = ownerCt.items.items, i = Ext.Array.indexOf(it, node) + 1, len = it.length; i < len; i++) {
      sib = it[i];
      if (sib.is(selector)) {
        return sib;
      }
      if (sib.down) {
        result = sib.down(selector);
        if (result) {
          return result;
        }
      }
    }
    return ownerCt.nextNode(selector);
  }
  return null;
}, nextSibling:function(selector) {
  var o = this.ownerCt, it, last, idx, c;
  if (o) {
    it = o.items;
    idx = it.indexOf(this) + 1;
    if (idx) {
      if (selector) {
        for (last = it.getCount(); idx < last; idx++) {
          if ((c = it.getAt(idx)).is(selector)) {
            return c;
          }
        }
      } else {
        if (idx < it.getCount()) {
          return it.getAt(idx);
        }
      }
    }
  }
  return null;
}, onAdded:function(container, pos, instanced) {
  var me = this;
  me.ownerCt = container;
  me.onInheritedAdd(me, instanced);
  if (me.hasListeners && me.hasListeners.added) {
    me.fireEvent('added', me, container, pos);
  }
  if (Ext.GlobalEvents.hasListeners.added) {
    me.fireHierarchyEvent('added');
  }
}, onRemoved:function(destroying) {
  var me = this, focusTarget;
  if (!me.isLayoutMoving && me.el && me.el.contains(Ext.Element.getActiveElement())) {
    focusTarget = me.findFocusTarget();
    if (focusTarget) {
      focusTarget.focus();
    }
  }
  if (Ext.GlobalEvents.hasListeners.removed) {
    me.fireHierarchyEvent('removed');
  }
  if (me.hasListeners.removed) {
    me.fireEvent('removed', me, me.ownerCt);
  }
  me.onInheritedRemove(destroying);
  me.ownerCt = me.ownerLayout = null;
}, onBoxReady:function(width, height) {
  var me = this, label;
  if (me.ariaLabelledBy || me.ariaDescribedBy) {
    if (me.ariaLabelledBy) {
      label = me.getAriaLabelEl(me.ariaLabelledBy);
      if (label) {
        me.ariaEl.dom.setAttribute('aria-labelledby', label);
      }
    }
    if (me.ariaDescribedBy) {
      label = me.getAriaLabelEl(me.ariaDescribedBy);
      if (label) {
        me.ariaEl.dom.setAttribute('aria-describedby', label);
      }
    }
  }
  if (me.resizable) {
    me.initResizable(me.resizable);
  }
  if (me.draggable) {
    me.initDraggable();
  }
  if (me.hasListeners.boxready) {
    me.fireEvent('boxready', me, width, height);
  }
}, onDestroy:Ext.emptyFn, onDisable:function() {
  var me = this, dom, nodeName;
  if (me.focusable) {
    me.disableFocusable();
  }
  if (!me.ariaStaticRoles[me.ariaRole]) {
    me.ariaEl.dom.setAttribute('aria-disabled', true);
  }
  if (me.maskOnDisable && !me.getInheritedConfig('disableMask', true)) {
    dom = me.el.dom;
    nodeName = dom.nodeName;
    if (me.disabledRe.test(nodeName)) {
      dom.disabled = true;
    }
    if (!me.nonMaskableRe.test(nodeName)) {
      me.mask();
    }
  }
}, onEnable:function() {
  var me = this, dom, nodeName;
  if (me.focusable) {
    me.enableFocusable();
  }
  if (!me.ariaStaticRoles[me.ariaRole]) {
    me.ariaEl.dom.setAttribute('aria-disabled', false);
  }
  if (me.maskOnDisable && me.getInherited().hasOwnProperty('masked')) {
    dom = me.el.dom;
    nodeName = dom.nodeName;
    if (me.disabledRe.test(nodeName)) {
      dom.disabled = false;
    }
    if (!me.nonMaskableRe.test(nodeName)) {
      me.unmask();
    }
  }
}, onGlobalShow:function(c) {
  if (this.up(c)) {
    this.getScrollable().restoreState();
  }
}, onHide:function(animateTarget, callback, scope) {
  var me = this, ghostPanel, fromSize, toBox;
  if (!me.ariaStaticRoles[me.ariaRole] && !me.destroying && !me.destroyed) {
    me.ariaEl.dom.setAttribute('aria-hidden', true);
  }
  me.revertFocus();
  animateTarget = me.getAnimateTarget(animateTarget);
  if (!me.ghost) {
    animateTarget = null;
  }
  if (animateTarget) {
    toBox = {x:animateTarget.getX(), y:animateTarget.getY(), width:animateTarget.dom.offsetWidth, height:animateTarget.dom.offsetHeight};
    ghostPanel = me.ghost();
    ghostPanel.el.stopAnimation();
    fromSize = me.getSize();
    ghostPanel.el.animate({to:toBox, listeners:{afteranimate:function() {
      if (!me.destroying) {
        ghostPanel.componentLayout.lastComponentSize = null;
        me.unghost(false);
        ghostPanel.el.setSize(fromSize);
        me.afterHide(callback, scope);
      }
    }}});
  } else {
    me.el.hide();
  }
  if (!animateTarget) {
    me.afterHide(callback, scope);
  }
}, onPosition:Ext.emptyFn, onResize:function(width, height, oldWidth, oldHeight) {
  var me = this;
  if (me.floating && me.constrain) {
    me.doConstrain();
  }
  if (me.hasListeners.resize) {
    me.fireEvent('resize', me, width, height, oldWidth, oldHeight);
  }
}, onShow:function() {
  var me = this;
  if (!me.ariaStaticRoles[me.ariaRole]) {
    me.ariaEl.dom.setAttribute('aria-hidden', false);
  }
  me.el.show();
  me.updateLayout({isRoot:false, context:me._showContext});
  if (me.floating) {
    if (me.maximized) {
      me.fitContainer();
    } else {
      if (me.constrain) {
        me.doConstrain();
      }
    }
  }
}, _showContext:{show:true}, onShowComplete:function(callback, scope) {
  var me = this, container = me.ownerFocusableContainer;
  if (me.floating) {
    me.onFloatShow();
  }
  Ext.callback(callback, scope || me);
  me.fireEvent('show', me);
  if (container && !container.onFocusableChildShow.$nullFn) {
    container.onFocusableChildShow(me);
  }
  delete me.hiddenByLayout;
}, onShowVeto:Ext.emptyFn, previousNode:function(selector, includeSelf) {
  var node = this, ownerCt = node.ownerCt, result, it, i, sib;
  if (includeSelf && node.is(selector)) {
    return node;
  }
  if (ownerCt) {
    for (it = ownerCt.items.items, i = Ext.Array.indexOf(it, node) - 1; i > -1; i--) {
      sib = it[i];
      if (sib.query) {
        result = sib.query(selector);
        result = result[result.length - 1];
        if (result) {
          return result;
        }
      }
      if (sib.is(selector)) {
        return sib;
      }
    }
    return ownerCt.previousNode(selector, true);
  }
  return null;
}, previousSibling:function(selector) {
  var o = this.ownerCt, it, idx, c;
  if (o) {
    it = o.items;
    idx = it.indexOf(this);
    if (idx !== -1) {
      if (selector) {
        for (--idx; idx >= 0; idx--) {
          if ((c = it.getAt(idx)).is(selector)) {
            return c;
          }
        }
      } else {
        if (idx) {
          return it.getAt(--idx);
        }
      }
    }
  }
  return null;
}, registerFloatingItem:function(cmp) {
  var me = this;
  if (!me.floatingDescendants) {
    me.floatingDescendants = new Ext.ZIndexManager(me);
  }
  me.floatingDescendants.register(cmp);
}, removeCls:function(cls) {
  var me = this, el = me.rendered ? me.el : me.protoEl;
  el.removeCls.apply(el, arguments);
  return me;
}, removeClsWithUI:function(classes, skip) {
  var me = this, clsArray = [], i = 0, extArray = Ext.Array, remove = extArray.remove, uiCls = me.uiCls = extArray.clone(me.uiCls), activeUI = me.activeUI, length, cls;
  if (typeof classes === 'string') {
    classes = classes.indexOf(' ') < 0 ? [classes] : Ext.String.splitWords(classes);
  }
  length = classes.length;
  for (i = 0; i < length; i++) {
    cls = classes[i];
    if (cls && me.hasUICls(cls)) {
      remove(uiCls, cls);
      if (activeUI) {
        clsArray = clsArray.concat(me.removeUIClsFromElement(cls));
      }
    }
  }
  if (skip !== true && activeUI) {
    me.removeCls(clsArray);
  }
  return clsArray;
}, resumeLayouts:function(flushOptions) {
  var me = this;
  if (!me.rendered) {
    return;
  }
  if (me.layoutSuspendCount && !--me.layoutSuspendCount) {
    me.suspendLayout = false;
    if (flushOptions && !me.isLayoutSuspended()) {
      me.updateLayout(flushOptions);
    }
  }
}, scrollBy:function(deltaX, deltaY, animate) {
  var scroller = this.getScrollable();
  if (scroller) {
    scroller.scrollBy(deltaX, deltaY, animate);
  }
}, scrollTo:function(x, y, animate) {
  var scroller = this.getScrollable();
  if (scroller) {
    scroller.scrollTo(x, y, animate);
  }
}, setAutoScroll:function(scroll) {
  this.setScrollable(!!scroll);
  return this;
}, setBorder:function(border, targetEl) {
  var me = this, initial = !!targetEl;
  if (me.rendered || initial) {
    if (!initial) {
      targetEl = me.el;
    }
    if (!border) {
      border = 0;
    } else {
      if (border === true) {
        border = '1px';
      } else {
        border = this.unitizeBox(border);
      }
    }
    targetEl.setStyle('border-width', border);
    if (!initial) {
      me.updateLayout();
    }
  }
  me.border = border;
}, setDock:function(dock) {
  var me = this, ownerCt = me.ownerCt;
  if (dock !== me.dock) {
    if (ownerCt && ownerCt.moveDocked) {
      ownerCt.moveDocked(me, dock);
    } else {
      me.dock = dock;
    }
  }
  return me;
}, setDisabled:function(disabled) {
  return this[disabled ? 'disable' : 'enable']();
}, setFlex:function(flex) {
  this.flex = flex;
}, setHeight:function(height) {
  return this.setSize(undefined, height);
}, setLoading:function(load, targetEl) {
  var me = this, config = {target:me};
  if (me.rendered) {
    if (load !== false) {
      if (Ext.isString(load)) {
        config.msg = load;
      } else {
        Ext.apply(config, load, me.maskDefaults);
      }
      if (!me.loadMask || !me.loadMask.isLoadMask) {
        if (targetEl && config.useTargetEl == null) {
          config.useTargetEl = true;
        }
        me.loadMask = new Ext.LoadMask(config);
      } else {
        Ext.apply(me.loadMask, config);
      }
      if (me.loadMask.isVisible()) {
        me.loadMask.syncMaskState();
      } else {
        me.loadMask.show();
      }
    } else {
      if (me.loadMask && me.loadMask.isLoadMask) {
        me.loadMask.hide();
      }
    }
  }
  return me.loadMask;
}, setMargin:function(margin, preventLayout) {
  var me = this;
  if (me.rendered) {
    if (!margin && margin !== 0) {
      margin = '';
    } else {
      if (margin === true) {
        margin = 5;
      }
      margin = this.unitizeBox(margin);
    }
    me.margin = margin;
    me.margin$ = null;
    me.getEl().setStyle('margin', margin);
    if (!preventLayout) {
      me.updateLayout(me._notAsLayoutRoot);
    }
  } else {
    me.margin = margin;
  }
}, setOverflowXY:function(overflowX, overflowY) {
  this.setScrollable({x:overflowX && overflowX !== 'hidden' ? overflowX : false, y:overflowY && overflowY !== 'hidden' ? overflowY : false});
  return this;
}, setPagePosition:function(x, y, animate) {
  var me = this, p, floatParentBox;
  if (Ext.isArray(x)) {
    y = x[1];
    x = x[0];
  }
  me.pageX = x;
  me.pageY = y;
  if (me.floating) {
    if (me.isContainedFloater()) {
      floatParentBox = me.floatParent.getTargetEl().getViewRegion();
      if (Ext.isNumber(x) && Ext.isNumber(floatParentBox.left)) {
        x -= floatParentBox.left;
      }
      if (Ext.isNumber(y) && Ext.isNumber(floatParentBox.top)) {
        y -= floatParentBox.top;
      }
    } else {
      p = me.el.translateXY(x, y);
      x = p.x;
      y = p.y;
    }
    me.setPosition(x, y, animate);
  } else {
    p = me.el.translateXY(x, y);
    me.setPosition(p.x, p.y, animate);
  }
  return me;
}, setPosition:function(x, y, animate) {
  var me = this, pos = me.beforeSetPosition.apply(me, arguments);
  if (pos && me.rendered) {
    x = pos.x;
    y = pos.y;
    if (animate) {
      if (x !== me.getLocalX() || y !== me.getLocalY()) {
        me.stopAnimation();
        me.animate(Ext.apply({duration:1000, listeners:{afteranimate:Ext.Function.bind(me.afterSetPosition, me, [x, y])}, to:{left:x, top:y}}, animate));
      }
    } else {
      me.setLocalXY(x, y);
      me.afterSetPosition(x, y);
    }
  }
  return me;
}, setScrollX:function(x, animate) {
  var scroller = this.getScrollable();
  if (scroller) {
    scroller.scrollTo(x, null, animate);
  }
}, setScrollY:function(y, animate) {
  var scroller = this.getScrollable();
  if (scroller) {
    scroller.scrollTo(null, y, animate);
  }
}, setSize:function(width, height) {
  var me = this, oldWidth = me.width, oldHeight = me.height, widthIsString, heightIsString;
  if (width && typeof width === 'object') {
    height = width.height;
    width = width.width;
  }
  if (typeof width === 'number') {
    me.width = Ext.Number.constrain(width, me.minWidth, me.maxWidth);
  } else {
    if (width === null) {
      delete me.width;
    } else {
      if (typeof width === 'string') {
        widthIsString = true;
        me.width = width;
      }
    }
  }
  if (typeof height === 'number') {
    me.height = Ext.Number.constrain(height, me.minHeight, me.maxHeight);
  } else {
    if (height === null) {
      delete me.height;
    } else {
      if (typeof height === 'string') {
        heightIsString = true;
        me.height = height;
      }
    }
  }
  if (me.rendered && me.isVisible()) {
    if (oldWidth !== me.width || oldHeight !== me.height) {
      if (me.liquidLayout || widthIsString || heightIsString) {
        me.el.setSize(me.width, me.height);
      }
      me.updateLayout(me._notAsLayoutRoot);
    }
  }
  return me;
}, setStyle:function(property, value) {
  var el = this.el || this.protoEl;
  el.setStyle(property, value);
  return this;
}, setUI:function(ui) {
  var me = this, uiCls = me.uiCls, activeUI = me.activeUI, classes;
  if (ui === activeUI) {
    return;
  }
  if (activeUI) {
    classes = me.removeClsWithUI(uiCls, true);
    if (classes.length) {
      me.removeCls(classes);
    }
    me.removeUIFromElement();
  } else {
    me.uiCls = [];
  }
  me.ui = ui;
  me.activeUI = ui;
  me.addUIToElement();
  classes = me.addClsWithUI(uiCls, true);
  if (classes.length) {
    me.addCls(classes);
  }
  if (me.rendered) {
    me.updateLayout();
  }
}, setVisible:function(visible) {
  return this[visible ? 'show' : 'hide']();
}, setHidden:function(hidden) {
  return this.setVisible(!hidden);
}, setWidth:function(width) {
  return this.setSize(width);
}, show:function(animateTarget, callback, scope) {
  var me = this, rendered = me.rendered, container = me.ownerFocusableContainer;
  if (me.hierarchicallyHidden || me.floating && !rendered && me.isHierarchicallyHidden()) {
    if (!rendered) {
      me.initHierarchyEvents();
    }
    if (arguments.length > 1) {
      arguments[0] = null;
      me.pendingShow = arguments;
    } else {
      me.pendingShow = true;
    }
  } else {
    if (rendered && me.isVisible()) {
      if (me.floating) {
        me.onFloatShow();
        if (me.toFrontOnShow) {
          me.toFront();
        }
      }
    } else {
      if (me.fireEvent('beforeshow', me) !== false) {
        me.hidden = false;
        delete this.getInherited().hidden;
        if (container && !container.beforeFocusableChildShow.$nullFn) {
          container.beforeFocusableChildShow(me);
        }
        Ext.suspendLayouts();
        if (!rendered && (me.autoRender || me.floating)) {
          me.doAutoRender();
          rendered = me.rendered;
        }
        if (rendered) {
          me.beforeShow();
          Ext.resumeLayouts();
          me.onShow.apply(me, arguments);
          me.afterShow.apply(me, arguments);
        } else {
          Ext.resumeLayouts(true);
        }
      } else {
        me.onShowVeto();
      }
    }
  }
  return me;
}, showAt:function(x, y, animate) {
  var me = this;
  if (!me.rendered && (me.autoRender || me.floating)) {
    me.x = x;
    me.y = y;
    return me.show();
  }
  if (me.floating) {
    me.setPosition(x, y, animate);
  } else {
    me.setPagePosition(x, y, animate);
  }
  return me.show();
}, showBy:function(component, position, offset) {
  var me = this;
  if (me.floating && component) {
    me._lastAlignTarget = component;
    me._lastAlignToPos = position || me.defaultAlign;
    me._lastAlignToOffsets = offset || me.alignOffset;
    me.show();
  }
  return me;
}, suspendLayouts:function() {
  var me = this;
  if (!me.rendered) {
    return;
  }
  if (++me.layoutSuspendCount === 1) {
    me.suspendLayout = true;
  }
}, toggleCls:function(className, state) {
  if (state === undefined) {
    state = !this.hasCls(className);
  }
  return this[state ? 'addCls' : 'removeCls'](className);
}, unitizeBox:function(box) {
  return Ext.Element.unitizeBox(box);
}, unmask:function() {
  (this.getMaskTarget() || this.el).unmask();
  this.setMasked(false);
}, unregisterFloatingItem:function(cmp) {
  var me = this;
  if (me.floatingDescendants) {
    me.floatingDescendants.unregister(cmp);
  }
}, up:function(selector, limit) {
  var result = this.getRefOwner(), limitSelector = typeof limit === 'string', limitCount = typeof limit === 'number', limitComponent = limit && limit.isComponent, steps = 0;
  if (selector) {
    for (; result; result = result.getRefOwner()) {
      if (result.destroyed) {
        return null;
      }
      steps++;
      if (selector.isComponent) {
        if (result === selector) {
          return result;
        }
      } else {
        if (Ext.ComponentQuery.is(result, selector)) {
          return result;
        }
      }
      if (limitSelector && result.is(limit)) {
        return;
      }
      if (limitCount && steps === limit) {
        return;
      }
      if (limitComponent && result === limit) {
        return;
      }
    }
  }
  return result;
}, update:function(htmlOrData, loadScripts, callback, scriptScope) {
  var me = this, isData = me.tpl && !Ext.isString(htmlOrData), container = me.ownerFocusableContainer, sizeModel, doLayout, el;
  if (isData) {
    me.data = htmlOrData && htmlOrData.isEntity ? htmlOrData.getData(true) : htmlOrData;
  } else {
    me.html = Ext.isObject(htmlOrData) ? Ext.DomHelper.markup(htmlOrData) : htmlOrData;
  }
  if (me.rendered) {
    sizeModel = me.getSizeModel();
    doLayout = sizeModel.width.shrinkWrap || sizeModel.height.shrinkWrap;
    if (me.isContainer) {
      el = me.layout.getRenderTarget();
      doLayout = doLayout || me.items.items.length > 0;
    } else {
      el = me.getTargetEl();
    }
    if (isData) {
      me.tpl[me.tplWriteMode](el, me.data || {});
    } else {
      el.setHtml(me.html, loadScripts, callback, scriptScope || me);
    }
    if (doLayout) {
      me.updateLayout();
    }
    if (container && !container.onFocusableChildUpdate.$nullFn) {
      container.onFocusableChildUpdate(me);
    }
  }
}, setHtml:function(html, loadScripts, callback, scriptScope) {
  this.update(html, loadScripts, null, scriptScope);
}, applyData:function(data) {
  this.update(data);
}, updateBox:function(box) {
  this.setSize(box.width, box.height);
  this.setPagePosition(box.x, box.y);
  return this;
}, _asLayoutRoot:{isRoot:true}, _notAsLayoutRoot:{isRoot:false}, updateLayout:function(options) {
  var me = this, defer, lastBox = me.lastBox, isRoot = options && options.isRoot, context = options && options.context;
  if (lastBox) {
    lastBox.invalid = true;
  }
  if (!me.rendered || me.isDetached || me.layoutSuspendCount || me.suspendLayout) {
    return;
  }
  if (me.hidden) {
    Ext.Component.cancelLayout(me);
  } else {
    if (typeof isRoot !== 'boolean') {
      isRoot = me.isLayoutRoot();
    }
  }
  if (isRoot || !me.ownerLayout || !me.ownerLayout.onContentChange(me, context)) {
    if (!me.isLayoutSuspended()) {
      defer = options && options.hasOwnProperty('defer') ? options.defer : me.deferLayouts;
      Ext.Component.updateLayout(me, defer);
    }
  }
}, updateMaxHeight:function(maxHeight, oldMaxHeight) {
  this.changeConstraint(maxHeight, oldMaxHeight, 'min', 'max-height', 'height');
}, updateMaxWidth:function(maxWidth, oldMaxWidth) {
  this.changeConstraint(maxWidth, oldMaxWidth, 'min', 'max-width', 'width');
}, updateMinHeight:function(minHeight, oldMinHeight) {
  this.changeConstraint(minHeight, oldMinHeight, 'max', 'min-height', 'height');
}, updateMinWidth:function(minWidth, oldMinWidth) {
  this.changeConstraint(minWidth, oldMinWidth, 'max', 'min-width', 'width');
}, updateTouchAction:function(touchAction) {
  var name, childEl, value, hasRootActions;
  for (name in touchAction) {
    childEl = this[name];
    value = touchAction[name];
    if (childEl && childEl.isElement) {
      childEl.setTouchAction(value);
    } else {
      hasRootActions = true;
    }
  }
  if (hasRootActions) {
    this.el.setTouchAction(touchAction);
  }
}, getAnchorToXY:function(el, anchor, local, mySize) {
  return el.getAnchorXY(anchor, local, mySize);
}, getBorderPadding:function() {
  return this.el.getBorderPadding();
}, getLocalX:function() {
  return this.el.getLocalX();
}, getLocalXY:function() {
  return this.el.getLocalXY();
}, getLocalY:function() {
  return this.el.getLocalY();
}, getX:function() {
  return this.el.getX();
}, getXY:function() {
  return this.el.getXY();
}, getY:function() {
  return this.el.getY();
}, setLocalX:function(x) {
  this.el.setLocalX(x);
}, setLocalXY:function(x, y) {
  this.el.setLocalXY(x, y);
}, setLocalY:function(y) {
  this.el.setLocalY(y);
}, setX:function(x, animate) {
  this.el.setX(x, animate);
}, setXY:function(xy, animate) {
  this.el.setXY(xy, animate);
}, setY:function(y, animate) {
  this.el.setY(y, animate);
}, privates:{addOverCls:function() {
  var me = this;
  if (!me.disabled) {
    me.el.addCls(me.overCls);
  }
}, addUIToElement:function() {
  var me = this, baseClsUI = me.baseCls + '-' + me.ui, childEls, childElName, el, suffix;
  me.addCls(baseClsUI);
  if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
    baseClsUI += '-';
    childEls = me.getChildEls();
    for (childElName in childEls) {
      suffix = childEls[childElName].frame;
      if (suffix && suffix !== true) {
        el = me[childElName];
        if (el) {
          el.addCls(baseClsUI + suffix);
        }
      }
    }
  }
}, changeConstraint:function(newValue, oldValue, constrainMethod, styleName, sizeName) {
  var me = this, size = me[sizeName];
  if (newValue != null && typeof size === 'number') {
    me[sizeName] = Math[constrainMethod](size, newValue);
  }
  if (me.liquidLayout) {
    if (newValue != null) {
      me.setStyle(styleName, newValue + 'px');
    } else {
      if (oldValue) {
        me.setStyle(styleName, '');
      }
    }
  }
  if (me.rendered) {
    me.updateLayout();
  }
}, constructPlugin:function(plugin) {
  var me = this, PM = Ext.plugin.Manager;
  if (typeof plugin === 'string') {
    plugin = PM.create({}, plugin, me);
  } else {
    plugin = PM.create(plugin, null, me);
  }
  return plugin;
}, constructPlugins:function() {
  var me = this, plugins = me.plugins, result, i, len;
  if (plugins) {
    me.plugins = result = Ext.plugin.Abstract.decode(plugins, 'ptype');
    result.processed = true;
    for (i = 0, len = result.length; i < len; i++) {
      result[i] = me.constructPlugin(result[i]);
    }
  }
  me.pluginsInitialized = true;
  return result;
}, detachFromBody:function() {
  var me = this;
  if (!me.isDetached) {
    Ext.getDetachedBody().appendChild(me.el, true);
    Ext.Component.cancelLayout(me);
    me.isDetached = true;
  }
}, doAddListener:function(ename, fn, scope, options, order, caller, manager) {
  var me = this, listeners, option, eventOptions, elementName, element, delegate;
  if (Ext.isObject(fn) || options && options.element) {
    if (options.element) {
      elementName = options.element;
      listeners = {};
      listeners[ename] = fn;
      if (scope) {
        listeners.scope = scope;
      }
      eventOptions = me.$elementEventOptions;
      for (option in options) {
        if (eventOptions[option]) {
          listeners[option] = options[option];
        }
      }
    } else {
      listeners = fn;
      elementName = ename;
    }
    element = me[elementName];
    if (element && element.isObservable) {
      me.mon(element, listeners);
    } else {
      me.afterRenderEvents = me.afterRenderEvents || {};
      if (!me.afterRenderEvents[elementName]) {
        me.afterRenderEvents[elementName] = [];
      }
      me.afterRenderEvents[elementName].push(listeners);
    }
    return;
  }
  if (options) {
    delegate = options.delegate;
    if (delegate) {
      me.mixins.componentDelegation.addDelegatedListener.call(me, ename, fn, scope, options, order, caller, manager);
      return;
    }
  }
  me.mixins.observable.doAddListener.call(me, ename, fn, scope, options, order, caller, manager);
}, doRemoveListener:function(eventName, fn, scope) {
  var me = this;
  me.mixins.observable.doRemoveListener.call(me, eventName, fn, scope);
  me.mixins.componentDelegation.removeDelegatedListener.call(me, eventName, fn, scope);
}, fireHierarchyEvent:function(eventName) {
  var globalEvents = Ext.GlobalEvents;
  if (globalEvents.hasListeners[eventName]) {
    globalEvents.fireEvent(eventName, this);
  }
}, getActionEl:function() {
  return this.el;
}, getAutoId:function() {
  this.autoGenId = true;
  return ++Ext.Component.AUTO_ID;
}, getContentTarget:function() {
  return this.el;
}, getDragEl:function() {
  return this.el;
}, getOverflowEl:function() {
  return this.getTargetEl();
}, getOverflowStyle:function() {
  var me = this, scroller = me.getScrollable(), flags = me._scrollFlags, x, y, scrollFlags;
  if (scroller) {
    x = scroller.getX();
    if (x === true) {
      x = 'auto';
    }
    y = scroller.getY();
    if (y === true) {
      y = 'auto';
    }
    scrollFlags = flags[x][y];
  } else {
    scrollFlags = flags.none;
  }
  me.scrollFlags = scrollFlags;
  return {overflowX:scrollFlags.overflowX, overflowY:scrollFlags.overflowY};
}, getPlugins:function() {
  var plugins = this.plugins;
  plugins = plugins && plugins.processed ? plugins : this.constructPlugins();
  return plugins || null;
}, getProxy:function() {
  var me = this, target;
  if (!me.proxy) {
    target = Ext.getBody();
    me.proxy = me.el.createProxy('x-proxy-el', target, true);
  }
  return me.proxy;
}, getTargetEl:function() {
  return this.frameBody || this.el;
}, getTdCls:function() {
  return 'x-' + this.getTdType() + '-' + this.ui + '-cell';
}, getTdType:function() {
  return this.xtype;
}, getTpl:function(name) {
  return this.lookupTpl(name);
}, initCls:function() {
  var me = this, cls = [me.baseCls], targetCls = me.getComponentLayout().targetCls;
  if (targetCls) {
    cls.push(targetCls);
  }
  if (me.componentCls) {
    cls.push(me.componentCls);
  } else {
    me.componentCls = me.baseCls;
  }
  return cls;
}, initDraggable:function() {
  var me = this, dragTarget = me.resizer && me.resizer.el !== me.el ? me.resizerComponent = new Ext.Component({el:me.resizer.el, rendered:true, container:me.container}) : me, ddConfig = Ext.applyIf({el:dragTarget.getDragEl(), constrainTo:me.constrain || me.draggable.constrain ? me.constrainTo || (me.floatParent ? me.floatParent.getTargetEl() : me.container) : undefined}, me.draggable);
  if (me.constrain || me.constrainDelegate) {
    ddConfig.constrain = me.constrain;
    ddConfig.constrainDelegate = me.constrainDelegate;
  }
  me.dd = new Ext.util.ComponentDragger(dragTarget, ddConfig);
}, initPadding:function(targetEl) {
  var me = this, padding = me.padding;
  if (padding != null) {
    if (me.layout && me.layout.managePadding && me.contentPaddingProperty === 'padding') {
      targetEl.setStyle('padding', 0);
    } else {
      targetEl.setStyle('padding', this.unitizeBox(padding === true ? 5 : padding));
    }
  }
}, initPlugin:function(plugin) {
  plugin.init(this);
  return plugin;
}, initResizable:function(resizable) {
  var me = this;
  resizable = Ext.apply({target:me, dynamic:false, constrainTo:me.constrain || resizable && resizable.constrain ? me.constrainTo || (me.floatParent ? me.floatParent.getTargetEl() : me.container) : undefined, handles:me.resizeHandles}, resizable);
  resizable.target = me;
  me.resizer = new Ext.resizer.Resizer(resizable);
}, initStyles:function(targetEl) {
  var me = this, margin = me.margin, border = me.border, cls = me.cls, style = me.style, x = me.x, y = me.y, liquidLayout = me.liquidLayout, width, height;
  me.initPadding(targetEl);
  if (margin != null) {
    targetEl.setStyle('margin', this.unitizeBox(margin === true ? 5 : margin));
  }
  if (border != null) {
    me.setBorder(border, targetEl);
  }
  if (cls && cls !== me.initialCls) {
    targetEl.addCls(cls);
    me.cls = me.initialCls = null;
  }
  if (style && style !== me.initialStyle) {
    targetEl.setStyle(style);
    me.style = me.initialStyle = null;
  }
  if (x != null) {
    targetEl.setStyle(me.horizontalPosProp, typeof x === 'number' ? x + 'px' : x);
  }
  if (y != null) {
    targetEl.setStyle('top', typeof y === 'number' ? y + 'px' : y);
  }
  if (!me.ownerCt || me.floating) {
    if (Ext.scopeCss) {
      targetEl.addCls(me.rootCls);
    }
    targetEl.addCls(me.borderBoxCls);
  }
  if (liquidLayout || !me.getFrameInfo()) {
    width = me.width;
    height = me.height;
    if (width != null) {
      if (typeof width === 'number') {
        targetEl.setStyle('width', width + 'px');
      } else {
        targetEl.setStyle('width', width);
      }
    }
    if (height != null) {
      if (typeof height === 'number') {
        targetEl.setStyle('height', height + 'px');
      } else {
        targetEl.setStyle('height', height);
      }
    }
  }
}, isContainedFloater:function() {
  return this.floating && this.floatParent;
}, isDescendant:function(ancestor) {
  if (ancestor.isContainer) {
    for (var c = this.ownerCt; c; c = c.ownerCt) {
      if (c === ancestor) {
        return true;
      }
    }
  }
  return false;
}, owns:function(element) {
  var result = false, cmp;
  if (element.isEvent) {
    element = element.target;
  } else {
    if (element.isElement) {
      element = element.dom;
    }
  }
  cmp = Ext.Component.fromElement(element);
  if (cmp) {
    result = cmp === this || !!cmp.up(this);
  }
  return result;
}, parseBox:function(box) {
  return Ext.Element.parseBox(box);
}, reattachToBody:function() {
  this.isDetached = false;
}, removeManagedListenerItem:function(isClear, managedListener, item, ename, fn, scope) {
  var me = this, element = managedListener.options ? managedListener.options.element : null;
  if (element) {
    element = me[element];
    if (element && element.un) {
      if (isClear || managedListener.item === item && managedListener.ename === ename && (!fn || managedListener.fn === fn) && (!scope || managedListener.scope === scope)) {
        element.un(managedListener.ename, managedListener.fn, managedListener.scope);
        if (!isClear) {
          Ext.Array.remove(me.managedListeners, managedListener);
        }
      }
    }
  } else {
    return me.mixins.observable.removeManagedListenerItem.apply(me, arguments);
  }
}, removeOverCls:function() {
  this.el.removeCls(this.overCls);
}, removePlugin:function(plugin) {
  Ext.Array.remove(this.plugins, plugin);
  plugin.destroy();
}, removeUIFromElement:function() {
  var me = this, baseClsUI = me.baseCls + '-' + me.ui, childEls, childElName, el, suffix;
  me.removeCls(baseClsUI);
  if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
    baseClsUI += '-';
    childEls = me.getChildEls();
    for (childElName in childEls) {
      suffix = childEls[childElName].frame;
      if (suffix && suffix !== true) {
        el = me[childElName];
        if (el) {
          el.removeCls(baseClsUI + suffix);
        }
      }
    }
  }
}, setComponentLayout:function(layout) {
  var currentLayout = this.componentLayout;
  if (currentLayout && currentLayout.isLayout && currentLayout !== layout) {
    currentLayout.setOwner(null);
  }
  this.componentLayout = layout;
  layout.setOwner(this);
}, setHiddenState:function(hidden) {
  var me = this, inheritedState = me.getInherited(), zIndexManager = me.zIndexManager;
  me.hidden = hidden;
  if (hidden) {
    inheritedState.hidden = true;
  } else {
    delete inheritedState.hidden;
  }
  if (zIndexManager) {
    zIndexManager.onComponentShowHide(me);
  }
}, setupProtoEl:function() {
  var cls = this.initCls();
  this.protoEl.addCls(cls);
}, wrapPrimaryEl:function(dom) {
  var me = this, el = me.el;
  if (!el || !el.isElement) {
    me.el = Ext.get(dom);
  }
  if (me.floating) {
    this.mixins.floating.constructor.call(this);
  }
}}, deprecated:{5:{methods:{addClass:'addCls', doComponentLayout:function() {
  this.updateLayout();
  return this;
}, removeClass:'removeCls', forceComponentLayout:'updateLayout', setDocked:'setDock'}}}}, 1, ['box', 'component'], ['component', 'box'], {'component':true, 'box':true}, ['widget.box', 'widget.component'], [[Ext.mixin.Inheritable.prototype.mixinId || Ext.mixin.Inheritable.$className, Ext.mixin.Inheritable], [Ext.util.Floating.prototype.mixinId || Ext.util.Floating.$className, Ext.util.Floating], [Ext.util.Positionable.prototype.mixinId || Ext.util.Positionable.$className, Ext.util.Positionable], [Ext.util.Observable.prototype.mixinId || 
Ext.util.Observable.$className, Ext.util.Observable], [Ext.mixin.ComponentDelegation.prototype.mixinId || Ext.mixin.ComponentDelegation.$className, Ext.mixin.ComponentDelegation], [Ext.mixin.Bindable.prototype.mixinId || Ext.mixin.Bindable.$className, Ext.mixin.Bindable], [Ext.util.Animate.prototype.mixinId || Ext.util.Animate.$className, Ext.util.Animate], [Ext.util.ElementContainer.prototype.mixinId || Ext.util.ElementContainer.$className, Ext.util.ElementContainer], [Ext.util.Renderable.prototype.mixinId || 
Ext.util.Renderable.$className, Ext.util.Renderable], [Ext.state.Stateful.prototype.mixinId || Ext.state.Stateful.$className, Ext.state.Stateful], [Ext.mixin.Focusable.prototype.mixinId || Ext.mixin.Focusable.$className, Ext.mixin.Focusable], [Ext.mixin.Accessible.prototype.mixinId || Ext.mixin.Accessible.$className, Ext.mixin.Accessible], [Ext.mixin.Keyboard.prototype.mixinId || Ext.mixin.Keyboard.$className, Ext.mixin.Keyboard]], [Ext, 'Component', Ext, 'AbstractComponent'], function(Component) {
  var prototype = Component.prototype;
  (prototype.$elementEventOptions = Ext.Object.chain(Ext.Element.prototype.$eventOptions)).element = 1;
  (prototype.$eventOptions = Ext.Object.chain(prototype.$eventOptions)).delegate = 1;
  Component.createAlias({on:'addListener', prev:'previousSibling', next:'nextSibling'});
  Ext.resumeLayouts = function(flush) {
    Component.resumeLayouts(flush);
  };
  Ext.suspendLayouts = function() {
    Component.suspendLayouts();
  };
  Ext.batchLayouts = function(fn, scope) {
    Component.suspendLayouts();
    try {
      fn.call(scope);
    } finally {
      Component.resumeLayouts(true);
    }
  };
  Ext.setGlyphFontFamily = function(fontFamily) {
    Ext._glyphFontFamily = fontFamily;
  };
  Component.hierarchyEventSource = prototype.hierarchyEventSource = Ext.GlobalEvents;
  Ext.onReady(function() {
    if (Ext.supports.HighContrastMode) {
      Ext.getBody().addCls(Component.ariaHighContrastModeCls);
    }
  });
});
Ext.define('Ext.overrides.mixin.Focusable', {override:'Ext.Component', focusCls:'focus', focus:function(selectText, delay, callback, scope) {
  var me = this, containerScrollTop;
  if (!me.focusable && !me.isContainer || me.destroyed || me.destroying) {
    return me;
  }
  if (delay) {
    me.getFocusTask().delay(Ext.isNumber(delay) ? delay : 10, me.focus, me, [selectText, false, callback, scope]);
    return me;
  }
  me.cancelFocus();
  if (me.floating && me.container && me.container.dom) {
    containerScrollTop = me.container.dom.scrollTop;
  }
  if (me.mixins.focusable.focus.apply(me, arguments) !== false) {
    if (callback) {
      Ext.callback(callback, scope);
    }
    if (me.floating && containerScrollTop !== undefined) {
      me.container.dom.scrollTop = containerScrollTop;
    }
  }
  return me;
}, cancelFocus:function() {
  var me = this, task = me.getFocusTask();
  if (task) {
    task.cancel();
  }
}, beforeBlur:Ext.emptyFn, postBlur:Ext.emptyFn, beforeFocus:Ext.emptyFn, postFocus:Ext.emptyFn, onFocusEnter:function(e) {
  var me = this;
  if (me.destroying || me.destroyed) {
    return;
  }
  if (me.floating && me !== me.zIndexManager.getActive()) {
    me.toFront(true);
  }
  arguments.callee.$previous.call(this, e);
}, destroyFocusable:function() {
  var me = this;
  if (me.focusTask) {
    me.focusTask.stop(me.focus, me);
  }
  arguments.callee.$previous.call(this);
}, privates:{addFocusCls:function(e) {
  var me = this, focusCls = me.focusCls, el;
  if (focusCls) {
    el = me.getFocusClsEl(e);
    if (el) {
      el.addCls(me.addClsWithUI(focusCls, true));
    }
  }
}, removeFocusCls:function(e) {
  var me = this, focusCls = me.focusCls, el;
  if (focusCls) {
    el = me.getFocusClsEl(e);
    if (el) {
      el.removeCls(me.removeClsWithUI(focusCls, true));
    }
  }
}, getFocusTask:function() {
  if (!this.focusTask) {
    this.focusTask = Ext.focusTask;
  }
  return this.focusTask;
}, updateMaskState:function(state, mask) {
  var me = this, ariaEl = me.ariaEl.dom, value;
  if (state) {
    me.disableTabbing();
    me.setMasked(true);
    if (ariaEl) {
      ariaEl.setAttribute('aria-busy', 'true');
      value = ariaEl.getAttribute('aria-describedby');
      if (value) {
        me._savedAriaDescribedBy = value;
      }
      ariaEl.setAttribute('aria-describedby', mask.ariaEl.id);
    }
  } else {
    me.enableTabbing();
    me.setMasked(false);
    if (ariaEl) {
      ariaEl.removeAttribute('aria-busy');
      value = ariaEl.getAttribute('aria-describedby');
      ariaEl.removeAttribute('aria-describedby');
      if (value === mask.ariaEl.id && me._savedAriaDescribedBy) {
        ariaEl.setAttribute('aria-describedby', me._savedAriaDescribedBy);
        delete me._savedAriaDescribedBy;
      }
    }
  }
}}}, function() {
  if (!Ext.focusTask) {
    Ext.focusTask = new Ext.util.DelayedTask;
  }
});
Ext.define('Ext.layout.container.border.Region', {override:'Ext.Component', initBorderRegion:function() {
  var me = this;
  if (!me._borderRegionInited) {
    me._borderRegionInited = true;
    me.addStateEvents(['changeregion', 'changeweight']);
    Ext.override(me, {getState:function() {
      var state = me.callParent();
      state = me.addPropertyToState(state, 'region');
      state = me.addPropertyToState(state, 'weight');
      return state;
    }});
  }
}, getOwningBorderContainer:function() {
  var layout = this.getOwningBorderLayout();
  return layout && layout.owner;
}, getOwningBorderLayout:function() {
  var layout = this.ownerLayout;
  return layout && layout.isBorderLayout ? layout : null;
}, setRegion:function(region) {
  var me = this, borderLayout, old = me.region;
  if (region !== old) {
    borderLayout = me.getOwningBorderLayout();
    if (borderLayout) {
      var regionFlags = borderLayout.regionFlags[region], placeholder = me.placeholder, splitter = me.splitter, owner = borderLayout.owner, regionMeta = borderLayout.regionMeta, collapsed = me.collapsed || me.floated, delta, items, index;
      if (me.fireEventArgs('beforechangeregion', [me, region]) === false) {
        return old;
      }
      Ext.suspendLayouts();
      me.region = region;
      Ext.apply(me, regionFlags);
      if (me.updateCollapseTool) {
        me.updateCollapseTool();
      }
      if (splitter) {
        Ext.apply(splitter, regionFlags);
        splitter.updateOrientation();
        items = owner.items;
        index = items.indexOf(me);
        if (index >= 0) {
          delta = regionMeta[region].splitterDelta;
          if (items.getAt(index + delta) !== splitter) {
            items.remove(splitter);
            index = items.indexOf(me);
            if (delta > 0) {
              ++index;
            }
            items.insert(index, splitter);
          }
        }
      }
      if (placeholder) {
        if (collapsed) {
          me.expand(false);
        }
        owner.remove(placeholder);
        me.placeholder = null;
        if (collapsed) {
          me.collapse(null, false);
        }
      }
      owner.updateLayout();
      Ext.resumeLayouts(true);
      me.fireEventArgs('changeregion', [me, old]);
    } else {
      me.region = region;
    }
  }
  return old;
}, setWeight:function(weight) {
  var me = this, ownerCt = me.getOwningBorderContainer(), placeholder = me.placeholder, old = me.weight;
  if (weight !== old) {
    if (me.fireEventArgs('beforechangeweight', [me, weight]) !== false) {
      me.weight = weight;
      if (placeholder) {
        placeholder.weight = weight;
      }
      if (ownerCt) {
        ownerCt.updateLayout();
      }
      me.fireEventArgs('changeweight', [me, old]);
    }
  }
  return old;
}}, function(Component) {
  var proto = Component.prototype;
  proto.setBorderRegion = proto.setRegion;
  proto.setRegionWeight = proto.setWeight;
});
Ext.define('Ext.theme.neptune.Component', {override:'Ext.Component', initComponent:function() {
  arguments.callee.$previous.call(this);
  if (this.dock && this.border === undefined) {
    this.border = false;
  }
}, privates:{initStyles:function() {
  var me = this, hasOwnBorder = me.hasOwnProperty('border'), border = me.border;
  if (me.dock) {
    me.border = null;
  }
  arguments.callee.$previous.apply(this, arguments);
  if (hasOwnBorder) {
    me.border = border;
  } else {
    delete me.border;
  }
}}}, function() {
  Ext.namespace('Ext.theme.is').Neptune = true;
  Ext.theme.name = 'Neptune';
});
Ext.define('Ext.theme.triton.Component', {override:'Ext.Component'}, function() {
  Ext.namespace('Ext.theme.is').Triton = true;
  Ext.theme.name = 'Triton';
});
Ext.define('Ext.overrides.app.domain.Component', {override:'Ext.app.domain.Component'}, function(ComponentDomain) {
  ComponentDomain.monitor(Ext.Component);
});
Ext.cmd.derive('Ext.app.EventBus', Ext.Base, {singleton:true, constructor:function() {
  var me = this, domains = Ext.app.EventDomain.instances;
  me.callParent();
  me.domains = domains;
  me.bus = domains.component.bus;
}, control:function(selectors, controller) {
  return this.domains.component.listen(selectors, controller);
}, listen:function(to, controller) {
  var domains = this.domains, domain;
  for (domain in to) {
    if (to.hasOwnProperty(domain)) {
      domains[domain].listen(to[domain], controller);
    }
  }
}, unlisten:function(controllerId) {
  var domains = Ext.app.EventDomain.instances, domain;
  for (domain in domains) {
    domains[domain].unlisten(controllerId);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.app, 'EventBus'], 0);
Ext.cmd.derive('Ext.app.domain.Global', Ext.app.EventDomain, {singleton:true, type:'global', constructor:function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.GlobalEvents);
}, listen:function(listeners, controller) {
  this.callParent([{global:listeners}, controller]);
}, match:Ext.returnTrue}, 1, 0, 0, 0, 0, 0, [Ext.app.domain, 'Global'], 0);
Ext.cmd.derive('Ext.route.Action', Ext.Base, {config:{actions:null, befores:null, urlParams:[]}, started:false, stopped:false, constructor:function(config) {
  var me = this;
  me.deferred = new Ext.Deferred;
  me.resume = me.resume.bind(me);
  me.stop = me.stop.bind(me);
  me.initConfig(config);
  me.callParent([config]);
}, applyActions:function(actions) {
  if (actions) {
    actions = Ext.Array.from(actions);
  }
  return actions;
}, applyBefores:function(befores) {
  if (befores) {
    befores = Ext.Array.from(befores);
  }
  return befores;
}, destroy:function() {
  this.deferred = null;
  this.setBefores(null).setActions(null).setUrlParams(null);
  this.callParent();
}, resume:function() {
  return this.next();
}, stop:function() {
  this.stopped = true;
  return this.done();
}, next:function() {
  var me = this, actions = me.getActions(), befores = me.getBefores(), urlParams = me.getUrlParams().slice(), config, ret;
  if (me.stopped || (befores ? !befores.length : true) && (actions ? !actions.length : true)) {
    me.done();
  } else {
    if (befores && befores.length) {
      config = befores.shift();
      urlParams.push(me);
      ret = Ext.callback(config.fn, config.scope, urlParams);
      if (ret && ret.then) {
        ret.then(function(arg) {
          me.resume(arg);
        }, function(arg) {
          me.stop(arg);
        });
      }
    } else {
      if (actions && actions.length) {
        config = actions.shift();
        Ext.callback(config.fn, config.scope, urlParams);
        me.next();
      } else {
        me.next();
      }
    }
  }
  return me;
}, run:function() {
  var deferred = this.deferred;
  if (!this.started) {
    this.next();
    this.started = true;
  }
  return deferred.promise;
}, done:function() {
  var deferred = this.deferred;
  if (this.stopped) {
    deferred.reject();
  } else {
    deferred.resolve();
  }
  this.destroy();
  return this;
}, before:function(first, fn, scope) {
  if (!Ext.isBoolean(first)) {
    scope = fn;
    fn = first;
    first = false;
  }
  var befores = this.getBefores(), config = {fn:fn, scope:scope};
  if (befores) {
    if (first) {
      befores.unshift(config);
    } else {
      befores.push(config);
    }
  } else {
    this.setBefores(config);
  }
  return this;
}, action:function(first, fn, scope) {
  if (!Ext.isBoolean(first)) {
    scope = fn;
    fn = first;
    first = false;
  }
  var actions = this.getActions(), config = {fn:fn, scope:scope};
  if (actions) {
    if (first) {
      actions.unshift(config);
    } else {
      actions.push(config);
    }
  } else {
    this.setActions(config);
  }
  return this;
}, then:function(resolve, reject) {
  return this.deferred.then(resolve, reject);
}}, 1, 0, 0, 0, 0, 0, [Ext.route, 'Action'], 0);
Ext.cmd.derive('Ext.route.Route', Ext.Base, {config:{name:null, url:null, allowInactive:false, caseInsensitive:false, handlers:[]}, defaultMatcher:'([%a-zA-Z0-9\\-\\_\\s,]+)', paramMatchingRegex:/:([0-9A-Za-z\_]*)/g, isRoute:true, constructor:function(config) {
  var me = this, url;
  this.initConfig(config);
  Ext.apply(me, config, {conditions:{}});
  url = me.getUrl();
  me.paramsInMatchString = url.match(me.paramMatchingRegex) || [];
  me.matcherRegex = me.createMatcherRegex(url);
}, recognize:function(url) {
  var me = this, recognized = me.recognizes(url), matches, urlParams;
  if (url === me.lastToken) {
    return true;
  }
  if (recognized) {
    matches = me.matchesFor(url);
    urlParams = url.match(me.matcherRegex);
    urlParams.shift();
    return Ext.applyIf(matches, {historyUrl:url, urlParams:urlParams});
  }
  return false;
}, recognizes:function(url) {
  return this.matcherRegex.test(url);
}, execute:function(token, argConfig) {
  var me = this, allowInactive = me.getAllowInactive(), handlers = me.getHandlers(), queue = Ext.route.Router.getQueueRoutes(), length = handlers.length, befores = [], actions = [], urlParams = argConfig && argConfig.urlParams || [], i, handler, scope, action, promises;
  me.lastToken = token;
  if (!queue) {
    promises = [];
  }
  return new Ext.Promise(function(resolve, reject) {
    for (i = 0; i < length; i++) {
      handler = handlers[i];
      scope = handler.scope;
      if (!allowInactive && scope.isActive && !scope.isActive()) {
        continue;
      }
      if (queue) {
        if (handler.before) {
          befores.push({fn:handler.before, scope:scope});
        }
        if (handler.action) {
          actions.push({fn:handler.action, scope:scope});
        }
      } else {
        action = {urlParams:urlParams};
        if (handler.before) {
          action.befores = {fn:handler.before, scope:scope};
        }
        if (handler.action) {
          action.actions = {fn:handler.action, scope:scope};
        }
        action = new Ext.route.Action(action);
        if (Ext.fireEvent('beforeroute', action, me) === false) {
          action.destroy();
        } else {
          promises.push(action.run());
        }
      }
    }
    if (queue) {
      action = new Ext.route.Action({actions:actions, befores:befores, urlParams:urlParams});
      if (Ext.fireEvent('beforeroute', action, me) === false) {
        action.destroy();
        reject();
      } else {
        action.run().then(resolve, reject);
      }
    } else {
      Ext.Promise.all(promises).then(resolve, reject);
    }
  });
}, matchesFor:function(url) {
  var params = {}, keys = this.paramsInMatchString, values = url.match(this.matcherRegex), length = keys.length, i;
  values.shift();
  for (i = 0; i < length; i++) {
    params[keys[i].replace(':', '')] = values[i];
  }
  return params;
}, createMatcherRegex:function(url) {
  var paramsInMatchString = this.paramsInMatchString, conditions = this.conditions, defaultMatcher = this.defaultMatcher, length = paramsInMatchString.length, modifiers = this.getCaseInsensitive() ? 'i' : '', i, params, matcher;
  if (url === '*') {
    url = url.replace('*', '\\*');
  } else {
    for (i = 0; i < length; i++) {
      params = paramsInMatchString[i];
      matcher = conditions[params] || defaultMatcher;
      url = url.replace(new RegExp(params), matcher);
    }
  }
  return new RegExp('^' + url + '$', modifiers);
}, addHandler:function(handler) {
  var handlers = this.getHandlers();
  handlers.push(handler);
  return this;
}, removeHandler:function(scope, config) {
  var handlers = this.getHandlers(), length = handlers.length, newHandlers = [], i, handler;
  for (i = 0; i < length; i++) {
    handler = handlers[i];
    if (handler.scope === scope) {
      if (!config || (Ext.isDefined(config.action) ? handler.action === config.action : true && Ext.isDefined(config.before) ? handler.before === config.before : true)) {
        continue;
      }
    }
    newHandlers.push(handler);
  }
  this.setHandlers(newHandlers);
  return this;
}}, 1, 0, 0, 0, 0, 0, [Ext.route, 'Route'], 0);
Ext.cmd.derive('Ext.util.History', Ext.Base, {singleton:true, alternateClassName:'Ext.History', useTopWindow:false, hashRe:/^(#?!?)/, constructor:function() {
  var me = this;
  me.ready = false;
  me.currentToken = null;
  me.mixins.observable.constructor.call(me);
}, getHash:function() {
  return this.win.location.hash.replace(this.hashRe, '');
}, setHash:function(hash, replace) {
  var me = this, hashRe = me.hashRe, loc = me.win.location;
  hash = hash.replace(hashRe, me.hashbang ? '#!' : '#');
  try {
    if (replace) {
      loc.replace(hash);
    } else {
      loc.hash = hash;
    }
    me.currentToken = hash.replace(hashRe, '');
  } catch (e$28) {
  }
}, handleStateChange:function(token) {
  token = token.replace(this.hashRe, '');
  this.fireEvent('change', this.currentToken = token);
}, startUp:function() {
  var me = this;
  me.currentToken = me.getHash();
  Ext.get(me.win).on('hashchange', me.onHashChange, me);
  me.ready = true;
  me.fireEvent('ready', me);
}, onHashChange:function() {
  var me = this, newHash = me.getHash();
  if (newHash !== me.hash) {
    me.hash = newHash;
    me.handleStateChange(newHash);
  }
}, init:function(onReady, scope) {
  var me = this;
  if (me.ready) {
    Ext.callback(onReady, scope, [me]);
    return;
  }
  if (!Ext.isReady) {
    Ext.onInternalReady(function() {
      me.init(onReady, scope);
    });
    return;
  }
  me.win = me.useTopWindow ? window.top : window;
  me.hash = me.getHash();
  if (onReady) {
    me.on('ready', onReady, scope, {single:true});
  }
  me.startUp();
}, add:function(token, preventDuplicates) {
  var me = this, set = false;
  if (preventDuplicates === false || me.getToken() !== token) {
    me.setHash(token);
    set = true;
  }
  return set;
}, replace:function(token, preventDuplicates) {
  var me = this, set = false;
  if (preventDuplicates === false || me.getToken() !== token) {
    this.setHash(token, true);
    set = true;
  }
  return set;
}, back:function() {
  this.win.history.go(-1);
}, forward:function() {
  this.win.history.go(1);
}, getToken:function() {
  return this.ready ? this.currentToken : this.getHash();
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.util, 'History', Ext, 'History'], 0);
Ext.cmd.derive('Ext.route.Router', Ext.Base, {singleton:true, config:{hashbang:null, multipleToken:'|', queueRoutes:true}, constructor:function() {
  var History = Ext.util.History;
  if (!History.ready) {
    History.init();
  }
  History.on('change', this.onStateChange, this);
  this.initConfig();
  this.clear();
}, updateHashbang:function(hashbang) {
  Ext.util.History.hashbang = hashbang;
}, onStateChange:function(token) {
  var me = this, tokens = token.split(me.getMultipleToken()), queue, i, length;
  if (me.isSuspended) {
    queue = me.suspendedQueue;
    i = 0;
    length = tokens.length;
    if (queue) {
      for (; i < length; i++) {
        token = tokens[i];
        if (!Ext.Array.contains(queue, token)) {
          queue.push(token);
        }
      }
    }
  } else {
    me.handleBefore(tokens);
  }
}, handleBefore:function(tokens) {
  var me = this, action = new Ext.route.Action;
  if (Ext.fireEvent('beforeroutes', action, tokens) === false) {
    action.destroy();
  } else {
    action.run().then(me.handleBeforeRoute.bind(me, tokens), Ext.emptyFn);
  }
}, handleBeforeRoute:function(tokens) {
  var me = this, beforeRoute = me.getByName('*');
  if (beforeRoute) {
    beforeRoute.execute().then(me.doRun.bind(me, tokens), Ext.emptyFn);
  } else {
    me.doRun(tokens);
  }
}, doRun:function(tokens) {
  var me = this, app = me.application, routes = me.routes, i = 0, length = tokens.length, matched = {}, unmatched = [], token, found, name, route, recognize;
  for (; i < length; i++) {
    token = tokens[i];
    found = false;
    for (name in routes) {
      route = routes[name];
      recognize = route.recognize(token);
      if (recognize) {
        found = true;
        if (recognize !== true) {
          route.execute(token, recognize).then(null, Ext.bind(me.onRouteRejection, me, [route]));
        }
        Ext.Array.remove(unmatched, route);
        if (!matched[name]) {
          matched[name] = 1;
        }
      } else {
        if (!matched[name]) {
          unmatched.push(route);
        }
      }
    }
    if (!found) {
      if (app) {
        app.fireEvent('unmatchedroute', token);
      }
      Ext.fireEvent('unmatchedroute', token);
    }
  }
  i = 0;
  length = unmatched.length;
  for (; i < length; i++) {
    route = unmatched[i];
    route.lastToken = null;
  }
}, onRouteRejection:function(route) {
  Ext.fireEvent('routereject', route);
}, connect:function(url, config, instance) {
  var routes = this.routes, name = config.name || url, route, name;
  if (url[0] === '!') {
    url = url.substr(1);
    this.setHashbang(true);
  }
  if (Ext.isString(config)) {
    config = {action:config, scope:instance};
  } else {
    config.scope = instance;
  }
  route = routes[name];
  if (!route) {
    route = routes[name] = new Ext.route.Route({conditions:config.conditions || {}, name:name, url:url});
  }
  route.addHandler(config);
}, disconnect:function(instance, config) {
  var routes = this.routes, route, name;
  if (config) {
    route = this.getByName(config.name || config.url);
    if (route) {
      route.removeHandler(instance, config);
    }
  } else {
    for (name in routes) {
      route = routes[name];
      route.removeHandler(instance);
    }
  }
}, recognize:function(url) {
  var routes = this.routes, matches = [], name, arr, i, length, route, urlParams;
  for (name in routes) {
    arr = routes[name];
    length = arr && arr.length;
    if (length) {
      i = 0;
      for (; i < length; i++) {
        route = arr[i];
        urlParams = route.recognize(url);
        if (urlParams) {
          matches.push({route:route, urlParams:urlParams});
        }
      }
    }
  }
  return matches.length ? matches : false;
}, draw:function(fn) {
  fn.call(this, this);
}, clear:function() {
  this.routes = {};
}, clearLastTokens:function(token) {
  var routes = this.routes, name, route;
  for (name in routes) {
    route = routes[name];
    if (!token || route.recognize(token)) {
      route.lastToken = null;
    }
  }
}, getByName:function(name) {
  var routes = this.routes;
  if (routes) {
    return routes[name];
  }
}, suspend:function(trackTokens) {
  this.isSuspended = true;
  if (!this.suspendedQueue && trackTokens !== false) {
    this.suspendedQueue = [];
  }
}, resume:function(discardQueue) {
  var me = this, queue = me.suspendedQueue, token;
  if (me.isSuspended) {
    me.isSuspended = false;
    me.suspendedQueue = null;
    if (!discardQueue && queue) {
      token = queue.join(me.getMultipleToken());
      me.onStateChange(token);
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.route, 'Router'], 0);
Ext.cmd.derive('Ext.route.Mixin', Ext.Mixin, {mixinConfig:{id:'routerable', before:{destroy:'destroyRouterable'}}, config:{routes:null}, destroyRouterable:function() {
  Ext.route.Router.disconnect(this);
}, updateRoutes:function(routes, oldRoutes) {
  var me = this, Router = Ext.route.Router, url, config, method;
  if (oldRoutes) {
    for (url in oldRoutes) {
      config = oldRoutes[url];
      if (Ext.isString(config)) {
        config = {action:config, name:url};
      }
      Router.disconnect(me, config);
    }
  }
  if (routes) {
    for (url in routes) {
      config = routes[url];
      if (Ext.isString(config)) {
        config = {action:config};
      }
      method = config.action;
      Router.connect(url, config, me);
    }
  }
}, redirectTo:function(hash, opt) {
  var me = this, currentHash = Ext.util.History.getToken(), Router = Ext.route.Router, delimiter = Router.getMultipleToken(), tokens = currentHash ? currentHash.split(delimiter) : [], length = tokens.length, force, i, name, obj, route, token, match;
  if (hash === -1) {
    return Ext.util.History.back();
  } else {
    if (hash === 1) {
      return Ext.util.History.forward();
    } else {
      if (hash.isModel) {
        hash = hash.toUrl();
      } else {
        if (Ext.isObject(hash)) {
          for (name in hash) {
            obj = hash[name];
            if (!Ext.isObject(obj)) {
              obj = {token:obj};
            }
            if (length) {
              route = Router.getByName(name);
              if (route) {
                match = false;
                for (i = 0; i < length; i++) {
                  token = tokens[i];
                  if (route.matcherRegex.test(token)) {
                    match = true;
                    if (obj.token) {
                      if (obj.fn && obj.fn.call(this, token, tokens, obj) === false) {
                        continue;
                      }
                      tokens[i] = obj.token;
                      if (obj.force) {
                        route.lastToken = null;
                      }
                    } else {
                      tokens.splice(i, 1);
                      i--;
                      length--;
                      route.lastToken = null;
                    }
                  }
                }
                if (obj && obj.token && !match) {
                  tokens.push(obj.token);
                }
              }
            } else {
              if (obj && obj.token) {
                tokens.push(obj.token);
              }
            }
          }
          hash = tokens.join(delimiter);
        }
      }
    }
  }
  if (opt === true) {
    force = opt;
    opt = null;
  } else {
    if (opt) {
      force = opt.force;
    }
  }
  length = tokens.length;
  if (force && length) {
    for (i = 0; i < length; i++) {
      token = tokens[i];
      Router.clearLastTokens(token);
    }
  }
  if (currentHash === hash) {
    if (force) {
      Router.onStateChange(hash);
    }
    return false;
  }
  if (opt && opt.replace) {
    Ext.util.History.replace(hash);
  } else {
    Ext.util.History.add(hash);
  }
  return true;
}, privates:{afterClassMixedIn:function(targetClass) {
  var proto = targetClass.prototype, routes = proto.routes;
  if (routes) {
    delete proto.routes;
    targetClass.getConfigurator().add({routes:routes});
  }
}}}, 0, 0, 0, 0, 0, 0, [Ext.route, 'Mixin'], 0);
Ext.cmd.derive('Ext.app.BaseController', Ext.Base, {isController:true, config:{id:undefined, control:null, listen:null}, constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  delete me.control;
  delete me.listen;
  me.eventbus = Ext.app.EventBus;
  me.mixins.observable.constructor.call(me, config);
}, updateId:function(id) {
  this.id = id;
}, applyListen:function(listen) {
  if (Ext.isObject(listen)) {
    listen = Ext.clone(listen);
  }
  return listen;
}, applyControl:function(control) {
  if (Ext.isObject(control)) {
    control = Ext.clone(control);
  }
  return control;
}, updateControl:function(control) {
  this.getId();
  if (control) {
    this.control(control);
  }
}, updateListen:function(listen) {
  this.getId();
  if (listen) {
    this.listen(listen);
  }
}, isActive:function() {
  return true;
}, control:function(selectors, listeners, controller) {
  var me = this, ctrl = controller, obj;
  if (Ext.isString(selectors)) {
    obj = {};
    obj[selectors] = listeners;
  } else {
    obj = selectors;
    ctrl = listeners;
  }
  me.eventbus.control(obj, ctrl || me);
}, listen:function(to, controller) {
  this.eventbus.listen(to, controller || this);
}, destroy:function() {
  var me = this, bus = me.eventbus;
  if (bus) {
    bus.unlisten(me);
    me.eventbus = null;
  }
  me.callParent();
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable], [Ext.route.Mixin.prototype.mixinId || Ext.route.Mixin.$className, Ext.route.Mixin]], [Ext.app, 'BaseController'], 0);
Ext.cmd.derive('Ext.app.Util', Ext.Base, {}, 0, 0, 0, 0, 0, 0, [Ext.app, 'Util'], function() {
  Ext.apply(Ext.app, {namespaces:{Ext:{}}, addNamespaces:function(namespace) {
    var namespaces = Ext.app.namespaces, i, l;
    if (!Ext.isArray(namespace)) {
      namespace = [namespace];
    }
    for (i = 0, l = namespace.length; i < l; i++) {
      namespaces[namespace[i]] = true;
    }
  }, clearNamespaces:function() {
    Ext.app.namespaces = {};
  }, getNamespace:function(className) {
    var namespaces = Ext.apply({}, Ext.ClassManager.paths, Ext.app.namespaces), deepestPrefix = '', prefix;
    for (prefix in namespaces) {
      if (namespaces.hasOwnProperty(prefix) && prefix.length > deepestPrefix.length && prefix + '.' === className.substring(0, prefix.length + 1)) {
        deepestPrefix = prefix;
      }
    }
    return deepestPrefix === '' ? undefined : deepestPrefix;
  }, setupPaths:function(appName, appFolder, paths) {
    var manifestPaths = Ext.manifest, ns;
    if (appName && appFolder !== null) {
      manifestPaths = manifestPaths && manifestPaths.paths;
      if (!manifestPaths || appFolder !== undefined) {
        Ext.Loader.setPath(appName, appFolder === undefined ? 'app' : appFolder);
      }
    }
    if (paths) {
      for (ns in paths) {
        if (paths.hasOwnProperty(ns)) {
          Ext.Loader.setPath(ns, paths[ns]);
        }
      }
    }
  }});
  Ext.getNamespace = Ext.app.getNamespace;
});
Ext.cmd.derive('Ext.util.CollectionKey', Ext.Base, {isCollectionKey:true, observerPriority:-200, config:{collection:null, keyFn:null, property:null, rootProperty:null, unique:true}, generation:0, map:null, mapRebuilds:0, constructor:function(config) {
  this.initConfig(config);
}, get:function(key) {
  var map = this.map || this.getMap();
  return map[key] || null;
}, clear:function() {
  this.map = null;
}, getRootProperty:function() {
  var me = this, root = (arguments.callee.$previous || Ext.Base.prototype.getRootProperty).call(this);
  return root !== null ? root : me.getCollection().getRootProperty();
}, indexOf:function(key, startAt) {
  var map = this.map || this.getMap(), item = map[key], collection = this.getCollection(), length = collection.length, i, index, items, n;
  if (!item) {
    return -1;
  }
  if (startAt === undefined) {
    startAt = -1;
  }
  if (item instanceof Array) {
    items = item;
    index = length;
    for (n = items.length; n-- > 0;) {
      i = collection.indexOf(items[n]);
      if (i < index && i > startAt) {
        index = i;
      }
    }
    if (index === length) {
      return -1;
    }
  } else {
    index = collection.indexOf(item);
  }
  return index > startAt ? index : -1;
}, updateKey:function(item, oldKey) {
  var me = this, map = me.map, bucket, index;
  if (map) {
    bucket = map[oldKey];
    if (bucket instanceof Array) {
      index = Ext.Array.indexOf(bucket, item);
      if (index >= 0) {
        if (bucket.length > 2) {
          bucket.splice(index, 1);
        } else {
          map[oldKey] = bucket[1 - index];
        }
      }
    } else {
      if (bucket) {
        delete map[oldKey];
      }
    }
    me.add([item]);
  }
}, onCollectionAdd:function(collection, add) {
  if (this.map) {
    this.add(add.items);
  }
}, onCollectionItemChange:function(collection, details) {
  this.map = null;
}, onCollectionRefresh:function() {
  this.map = null;
}, onCollectionRemove:function(collection, remove) {
  var me = this, map = me.map, items = remove.items, length = items.length, i, item, key;
  if (map) {
    if (me.getUnique() && length < collection.length / 2) {
      for (i = 0; i < length; ++i) {
        key = me.getKey(item = items[i]);
        delete map[key];
      }
    } else {
      me.map = null;
    }
  }
}, add:function(items) {
  var me = this, map = me.map, bucket, i, item, key, length, unique;
  length = items.length;
  unique = me.getUnique();
  for (i = 0; i < length; ++i) {
    key = me.getKey(item = items[i]);
    if (unique || !(key in map)) {
      map[key] = item;
    } else {
      if (!((bucket = map[key]) instanceof Array)) {
        map[key] = bucket = [bucket];
      }
      bucket.push(item);
    }
  }
}, applyKeyFn:function(keyFn) {
  if (Ext.isString(keyFn)) {
    this.getKey = function(item) {
      return item[keyFn]();
    };
  } else {
    this.getKey = keyFn;
  }
}, updateProperty:function(property) {
  var root = this.getRootProperty();
  this.getKey = function(item) {
    return (root ? item[root] : item)[property];
  };
}, getMap:function() {
  var me = this, map = me.map;
  if (!map) {
    me.map = map = {};
    me.keysByItemKey = {};
    ++me.mapRebuilds;
    me.add(me.getCollection().items);
  }
  return map;
}, updateCollection:function(collection, oldCollection) {
  if (collection) {
    collection.addObserver(this);
  }
  if (oldCollection) {
    oldCollection.removeObserver(this);
  }
}, clone:function() {
  return new Ext.util.CollectionKey(this.getCurrentConfig());
}, destroy:function() {
  this.clear();
  this.getCollection().removeObserver(this);
  this.destroyed = true;
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Identifiable.prototype.mixinId || Ext.mixin.Identifiable.$className, Ext.mixin.Identifiable]], [Ext.util, 'CollectionKey'], 0);
Ext.cmd.derive('Ext.util.Grouper', Ext.util.Sorter, {isGrouper:true, config:{groupFn:null, sortProperty:null}, constructor:function(config) {
  Ext.util.Sorter.prototype.constructor.apply(this, arguments);
}, getGroupString:function(item) {
  var group = this._groupFn(item);
  return group != null ? String(group) : '';
}, sortFn:function(item1, item2) {
  var me = this, lhs = me._groupFn(item1), rhs = me._groupFn(item2), property = me._sortProperty, root = me._root, sorterFn = me._sorterFn, transform = me._transform;
  if (lhs === rhs) {
    return 0;
  }
  if (property || sorterFn) {
    if (sorterFn) {
      return sorterFn.call(this, item1, item2);
    }
    if (root) {
      item1 = item1[root];
      item2 = item2[root];
    }
    lhs = item1[property];
    rhs = item2[property];
    if (transform) {
      lhs = transform(lhs);
      rhs = transform(rhs);
    }
  }
  return lhs > rhs ? 1 : lhs < rhs ? -1 : 0;
}, standardGroupFn:function(item) {
  var root = this._root;
  return (root ? item[root] : item)[this._property];
}, updateSorterFn:function() {
}, updateProperty:function() {
  if (!this.getGroupFn()) {
    this.setGroupFn(this.standardGroupFn);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Grouper'], 0);
Ext.cmd.derive('Ext.util.Collection', Ext.Base, {isCollection:true, config:{autoFilter:true, autoSort:true, autoGroup:true, decoder:null, extraKeys:null, filters:null, grouper:null, groups:null, groupConfig:null, rootProperty:null, sorters:null, multiSortLimit:3, defaultSortDirection:'ASC', source:null, trackGroups:true}, generation:0, indices:null, indexRebuilds:0, updating:0, grouped:false, sorted:false, filtered:false, $endUpdatePriority:1001, manageSorters:true, constructor:function(config) {
  var me = this;
  me.items = [];
  me.map = {};
  me.length = 0;
  if (config && config.keyFn) {
    me.getKey = config.keyFn;
  }
  me.mixins.observable.constructor.call(me, config);
}, destroy:function() {
  var me = this, filters = me._filters, sorters = me._sorters, groups = me._groups;
  if (filters) {
    filters.destroy();
    me._filters = null;
  }
  if (sorters) {
    me.grouped = me.sorted = false;
    me.setSorters(null);
    if (me.manageSorters) {
      sorters.destroy();
    }
  }
  if (groups) {
    groups.destroy();
    me._groups = null;
  }
  me.setSource(null);
  me.observers = me.items = me.map = null;
  me.callParent();
}, add:function(item) {
  var me = this, items = me.decodeItems(arguments, 0), ret = items;
  if (items.length) {
    me.splice(me.length, 0, items);
    ret = items.length === 1 ? items[0] : items;
  }
  return ret;
}, replaceAll:function() {
  var me = this, ret, items;
  items = me.decodeItems(arguments, 0);
  ret = items;
  if (items.length) {
    me.splice(0, me.length, items);
    ret = items.length === 1 ? items[0] : items;
  } else {
    me.removeAll();
  }
  return ret;
}, aggregate:function(property, operation, begin, end, scope) {
  var me = this, args = Ext.Array.slice(arguments);
  args.unshift(me.items);
  return me.aggregateItems.apply(me, args);
}, aggregateByGroup:function(property, operation, scope) {
  var groups = this.getGroups();
  return this.aggregateGroups(groups, property, operation, scope);
}, aggregateItems:function(items, property, operation, begin, end, scope) {
  var me = this, range = Ext.Number.clipIndices(items.length, [begin, end]), subsetRequested = begin !== 0 && end !== items.length, i, j, rangeLen, root, value, values, valueItems;
  begin = range[0];
  end = range[1];
  if (!Ext.isFunction(operation)) {
    operation = me._aggregators[operation];
    return operation.call(me, items, begin, end, property, me.getRootProperty());
  }
  root = me.getRootProperty();
  values = new Array(rangeLen);
  valueItems = subsetRequested ? new Array(rangeLen) : items;
  for (i = begin, j = 0; i < end; ++i, j++) {
    if (subsetRequested) {
      valueItems[j] = value = items[i];
    }
    values[j] = (root ? value[root] : value)[property];
  }
  return operation.call(scope || me, items, values, 0);
}, aggregateGroups:function(groups, property, operation, scope) {
  var items = groups.items, len = items.length, callDirect = !Ext.isFunction(operation), out = {}, i, group, result;
  for (i = 0; i < len; ++i) {
    group = items[i];
    if (!callDirect) {
      result = this.aggregateItems(group.items, property, operation, null, null, scope);
    } else {
      result = group[operation](property);
    }
    out[group.getGroupKey()] = result;
  }
  return out;
}, beginUpdate:function() {
  if (!this.updating++) {
    this.notify('beginupdate');
  }
}, clear:function() {
  var me = this, generation = me.generation, ret = generation ? me.items : [], extraKeys, indexName;
  if (generation) {
    me.items.length = me.length = 0;
    me.map = {};
    me.indices = {};
    me.generation++;
    extraKeys = me.getExtraKeys();
    if (extraKeys) {
      for (indexName in extraKeys) {
        extraKeys[indexName].clear();
      }
    }
  }
  return ret;
}, clone:function() {
  var me = this, copy = new me.self(me.initialConfig);
  copy.add(me.items);
  return copy;
}, collect:function(property, root, allowNull) {
  var items = this.items, length = items.length, map = {}, ret = [], i, strValue, value;
  for (i = 0; i < length; ++i) {
    value = items[i];
    value = (root ? value[root] : value)[property];
    strValue = String(value);
    if ((allowNull || !Ext.isEmpty(value)) && !map[strValue]) {
      map[strValue] = 1;
      ret.push(value);
    }
  }
  return ret;
}, contains:function(item) {
  var ret = false, key;
  if (item != null) {
    key = this.getKey(item);
    ret = this.map[key] === item;
  }
  return ret;
}, containsAll:function(items) {
  var all = Ext.isArray(items) ? items : arguments, i;
  for (i = all.length; i-- > 0;) {
    if (!this.contains(all[i])) {
      return false;
    }
  }
  return true;
}, containsKey:function(key) {
  return key in this.map;
}, createFiltered:function(property, value, anyMatch, caseSensitive, exactMatch) {
  var me = this, ret = new me.self(me.initialConfig), root = me.getRootProperty(), items = me.items, length, i, filters, fn, scope;
  if (Ext.isFunction(property)) {
    fn = property;
    scope = value;
  } else {
    if (Ext.isString(property)) {
      filters = [new Ext.util.Filter({property:property, value:value, root:root, anyMatch:anyMatch, caseSensitive:caseSensitive, exactMatch:exactMatch})];
    } else {
      if (property instanceof Ext.util.Filter) {
        filters = [property];
        property.setRoot(root);
      } else {
        if (Ext.isArray(property)) {
          filters = property.slice(0);
          for (i = 0, length = filters.length; i < length; ++i) {
            filters[i].setRoot(root);
          }
        }
      }
    }
    fn = Ext.util.Filter.createFilterFn(filters);
  }
  scope = scope || me;
  for (i = 0, length = items.length; i < length; i++) {
    if (fn.call(scope, items[i])) {
      ret.add(items[i]);
    }
  }
  return ret;
}, filterBy:function(fn, scope) {
  return this.createFiltered(fn, scope);
}, each:function(fn, scope) {
  var items = this.items, len = items.length, i, ret;
  if (len) {
    scope = scope || this;
    items = items.slice(0);
    for (i = 0; i < len; i++) {
      ret = fn.call(scope, items[i], i, len);
      if (ret === false) {
        break;
      }
    }
  }
  return ret;
}, eachKey:function(fn, scope) {
  var me = this, items = me.items, len = items.length, i, item, key, ret;
  if (len) {
    scope = scope || me;
    items = items.slice(0);
    for (i = 0; i < len; i++) {
      key = me.getKey(item = items[i]);
      ret = fn.call(scope, key, item, i, len);
      if (ret === false) {
        break;
      }
    }
  }
  return ret;
}, endUpdate:function() {
  if (!--this.updating) {
    this.notify('endupdate');
  }
}, find:function(property, value, start, startsWith, endsWith, ignoreCase) {
  if (Ext.isEmpty(value, false)) {
    return null;
  }
  var regex = Ext.String.createRegex(value, startsWith, endsWith, ignoreCase), root = this.getRootProperty();
  return this.findBy(function(item) {
    return item && regex.test((root ? item[root] : item)[property]);
  }, null, start);
}, findBy:function(fn, scope, start) {
  var me = this, items = me.items, len = items.length, i, item, key;
  scope = scope || me;
  for (i = start || 0; i < len; i++) {
    key = me.getKey(item = items[i]);
    if (fn.call(scope, item, key)) {
      return items[i];
    }
  }
  return null;
}, findIndex:function(property, value, start, startsWith, endsWith, ignoreCase) {
  var item = this.find(property, value, start, startsWith, endsWith, ignoreCase);
  return item ? this.indexOf(item) : -1;
}, findIndexBy:function(fn, scope, start) {
  var item = this.findBy(fn, scope, start);
  return item ? this.indexOf(item) : -1;
}, first:function(grouped) {
  var groups = grouped ? this.getGroups() : undefined;
  return groups ? this.aggregateGroups(groups, null, 'first') : this.items[0];
}, last:function(grouped) {
  var groups = grouped ? this.getGroups() : undefined;
  return groups ? this.aggregateGroups(groups, null, 'last') : this.items[this.length - 1];
}, get:function(key) {
  return this.map[key];
}, getAt:function(index) {
  return this.items[index];
}, getByKey:function(key) {
  return this.map[key];
}, getCount:function() {
  return this.length;
}, getKey:function(item) {
  var id = item.id;
  return id === 0 || id ? id : (id = item._id) === 0 || id ? id : item.getId();
}, getRange:function(begin, end) {
  var items = this.items, length = items.length, range;
  if (!length) {
    range = [];
  } else {
    range = Ext.Number.clipIndices(length, [begin, end]);
    range = items.slice(range[0], range[1]);
  }
  return range;
}, getValues:function(property, root, start, end) {
  var items = this.items, range = Ext.Number.clipIndices(items.length, [start, end]), ret = [], i, value;
  for (i = range[0], end = range[1]; i < end; ++i) {
    value = items[i];
    value = (root ? value[root] : value)[property];
    ret.push(value);
  }
  return ret;
}, indexOf:function(item) {
  if (!item) {
    return -1;
  }
  var key = this.getKey(item);
  return this.indexOfKey(key);
}, indexOfKey:function(key) {
  var me = this, indices = me.indices;
  if (key in me.map) {
    if (!indices) {
      indices = me.getIndices();
    }
    return indices[key];
  }
  return -1;
}, insert:function(index, item) {
  var me = this, items = me.decodeItems(arguments, 1), ret = items;
  if (items.length) {
    me.splice(index, 0, items);
    ret = items.length === 1 ? items[0] : items;
  }
  return ret;
}, itemChanged:function(item, modified, oldKey, meta) {
  var me = this, keyChanged = oldKey !== undefined, filtered = me.filtered && me.getAutoFilter(), filterChanged = false, itemMovement = 0, items = me.items, last = me.length - 1, sorted = me.sorted && last > 0 && me.getAutoSort(), source = me.getSource(), toRemove = 0, itemFiltered = false, wasFiltered = false, details, newKey, sortFn, toAdd, index, newIndex;
  if (source && !source.updating) {
    me.sourceUpdating = true;
    source.itemChanged(item, modified, oldKey, meta);
    me.sourceUpdating = false;
  } else {
    newKey = me.getKey(item);
    if (filtered) {
      index = me.indexOfKey(keyChanged ? oldKey : newKey);
      wasFiltered = index < 0;
      itemFiltered = me.isItemFiltered(item);
      filterChanged = wasFiltered !== itemFiltered;
    }
    if (filterChanged) {
      if (itemFiltered) {
        toRemove = [item];
        newIndex = -1;
      } else {
        toAdd = [item];
        newIndex = me.length;
      }
    } else {
      if (sorted && !itemFiltered) {
        if (!filtered) {
          index = me.indexOfKey(keyChanged ? oldKey : newKey);
        }
        sortFn = me.getSortFn();
        if (index !== -1) {
          if (index && sortFn(items[index - 1], items[index]) > 0) {
            itemMovement = -1;
            newIndex = Ext.Array.binarySearch(items, item, 0, index, sortFn);
          } else {
            if (index < last && sortFn(items[index], items[index + 1]) > 0) {
              itemMovement = 1;
              newIndex = Ext.Array.binarySearch(items, item, index + 1, sortFn);
            }
          }
          if (itemMovement) {
            toAdd = [item];
          }
        }
      }
    }
    details = {item:item, key:newKey, index:newIndex, filterChanged:filterChanged, keyChanged:keyChanged, indexChanged:!!itemMovement, filtered:itemFiltered, oldIndex:index, newIndex:newIndex, wasFiltered:wasFiltered, meta:meta};
    if (keyChanged) {
      details.oldKey = oldKey;
    }
    if (modified) {
      details.modified = modified;
    }
    ++me.generation;
    me.beginUpdate();
    me.notify('beforeitemchange', [details]);
    if (keyChanged) {
      me.updateKey(item, oldKey, details);
    }
    if (toAdd || toRemove) {
      me.splice(newIndex, toRemove, toAdd);
    }
    if (itemMovement > 0) {
      details.newIndex--;
    } else {
      if (itemMovement < 0) {
        details.oldIndex++;
      }
    }
    me.notify(itemFiltered ? 'filtereditemchange' : 'itemchange', [details]);
    me.endUpdate();
  }
}, remove:function(item) {
  var me = this, items = me.decodeRemoveItems(arguments, 0), length = me.length;
  me.splice(0, items);
  return length - me.length;
}, removeAll:function() {
  var me = this, length = me.length;
  if (me.generation && length) {
    me.splice(0, length);
  }
  return me;
}, removeAt:function(index, count) {
  var me = this, length = me.length, Num = Ext.Number, range = Num.clipIndices(length, [index, count === undefined ? 1 : count], Num.Clip.COUNT), n = range[0], removeCount = range[1] - n, item = removeCount === 1 && me.getAt(n), removed;
  me.splice(n, removeCount);
  removed = me.length - length;
  return item && removed ? item : removed;
}, removeByKey:function(key) {
  var item = this.getByKey(key);
  if (!item || !this.remove(item)) {
    return false;
  }
  return item;
}, replace:function(item) {
  var index = this.indexOf(item);
  if (index === -1) {
    this.add(item);
  } else {
    this.insert(index, item);
  }
}, splice:function(index, toRemove, toAdd) {
  var me = this, autoSort = me.sorted && me.getAutoSort(), map = me.map, items = me.items, length = me.length, removeItems = toRemove instanceof Array ? me.decodeRemoveItems(toRemove) : null, isRemoveCount = !removeItems, Num = Ext.Number, range = Num.clipIndices(length, [index, isRemoveCount ? toRemove : 0], Num.Clip.COUNT), begin = range[0], end = range[1], removeCount = end - begin, newItems = me.decodeItems(arguments, 2), newCount = newItems ? newItems.length : 0, addItems, newItemsMap, removeMap, 
  insertAt = begin, indices = me.indices || (newCount || removeItems ? me.getIndices() : null), adds = null, removes = removeCount ? [begin] : null, newKeys = null, source = me.getSource(), chunk, chunkItems, chunks, i, item, itemIndex, k, key, keys, n, duplicates, sorters;
  if (source && !source.updating) {
    if (isRemoveCount) {
      removeItems = [];
      for (i = 0; i < removeCount; ++i) {
        removeItems.push(items[begin + i]);
      }
    }
    if (begin < length) {
      i = source.indexOf(items[begin]);
    } else {
      i = source.length;
    }
    me.requestedIndex = index;
    source.splice(i, removeItems, newItems);
    delete me.requestedIndex;
    return me;
  }
  if (newCount) {
    addItems = newItems;
    newKeys = [];
    newItemsMap = {};
    if (autoSort) {
      sorters = me.getSorters();
      if (newCount > 1) {
        if (!addItems.$cloned) {
          newItems = addItems = addItems.slice(0);
        }
        me.sortData(addItems);
      }
    }
    for (i = 0; i < newCount; ++i) {
      key = me.getKey(item = newItems[i]);
      if ((k = newItemsMap[key]) !== undefined) {
        (duplicates || (duplicates = {}))[k] = 1;
      } else {
        itemIndex = indices[key];
        if (itemIndex < begin || end <= itemIndex) {
          (removes || (removes = [])).push(itemIndex);
        }
      }
      newItemsMap[key] = i;
      newKeys.push(key);
    }
    if (duplicates) {
      keys = newKeys;
      addItems = [];
      newKeys = [];
      addItems.$cloned = true;
      for (i = 0; i < newCount; ++i) {
        if (!duplicates[i]) {
          item = newItems[i];
          addItems.push(item);
          newKeys.push(keys[i]);
        }
      }
      newCount = addItems.length;
    }
    adds = {items:addItems, keys:newKeys};
  }
  for (i = removeItems ? removeItems.length : 0; i-- > 0;) {
    key = me.getKey(removeItems[i]);
    if ((itemIndex = indices[key]) !== undefined) {
      (removes || (removes = [])).push(itemIndex);
    }
  }
  if (!adds && !removes) {
    return me;
  }
  me.beginUpdate();
  if (removes) {
    chunk = null;
    chunks = [];
    removeMap = {};
    if (removes.length > 1) {
      removes.sort(Ext.Array.numericSortFn);
    }
    for (i = 0, n = removes.length; i < n; ++i) {
      key = me.getKey(item = items[itemIndex = removes[i]]);
      if (!(key in map)) {
        continue;
      }
      delete map[key];
      if (!chunk || itemIndex > chunk.at + chunkItems.length) {
        chunks.push(chunk = {at:itemIndex, items:chunkItems = [], keys:keys = [], map:removeMap, next:chunk, replacement:adds});
        if (adds) {
          adds.replaced = chunk;
        }
      }
      chunkItems.push(removeMap[key] = item);
      keys.push(key);
      if (itemIndex < insertAt - 1) {
        --insertAt;
      }
      if (removeCount > 1 && itemIndex === begin) {
        --removeCount;
        removes[i--] = ++begin;
      }
    }
    if (adds) {
      adds.at = insertAt;
    }
    for (k = chunks.length; k-- > 0;) {
      chunk = chunks[k];
      i = chunk.at;
      n = chunk.items.length;
      if (i + n < length) {
        me.indices = indices = null;
      }
      me.length = length -= n;
      items.splice(i, n);
      if (indices) {
        keys = chunk.keys;
        for (i = 0; i < n; ++i) {
          delete indices[keys[i]];
        }
      }
      ++me.generation;
      me.notify('remove', [chunk]);
    }
  }
  if (adds) {
    if (autoSort && newCount > 1 && length) {
      me.spliceMerge(addItems, newKeys);
    } else {
      if (autoSort) {
        if (newCount > 1) {
          insertAt = 0;
          me.indices = indices = null;
        } else {
          insertAt = sorters.findInsertionIndex(adds.items[0], items, me.getSortFn(), index);
        }
      }
      if (insertAt === length) {
        end = insertAt;
        for (i = addItems.length - 1; i >= 0; --i) {
          items[end + i] = addItems[i];
        }
        indices = me.indices;
        if (indices) {
          for (i = 0; i < newCount; ++i) {
            indices[newKeys[i]] = insertAt + i;
          }
        }
      } else {
        me.indices = null;
        Ext.Array.insert(items, insertAt, addItems);
      }
      for (i = 0; i < newCount; ++i) {
        map[newKeys[i]] = addItems[i];
      }
      me.length += newCount;
      adds.at = insertAt;
      adds.atItem = insertAt === 0 ? null : items[insertAt - 1];
      ++me.generation;
      me.notify('add', [adds]);
    }
  }
  me.endUpdate();
  return me;
}, update:function(fn, scope) {
  var me = this;
  me.beginUpdate();
  try {
    return fn.call(scope || me, me);
  } catch (e$29) {
    throw e$29;
  } finally {
    me.endUpdate();
  }
}, updateKey:function(item, oldKey, details) {
  var me = this, map = me.map, indices = me.indices, source = me.getSource(), newKey;
  if (source && !source.updating) {
    source.updateKey(item, oldKey);
  } else {
    if ((newKey = me.getKey(item)) !== oldKey) {
      if (map[oldKey] === item && !(newKey in map)) {
        delete map[oldKey];
        me.updating++;
        me.generation++;
        map[newKey] = item;
        if (indices) {
          indices[newKey] = indices[oldKey];
          delete indices[oldKey];
        }
        me.notify('updatekey', [Ext.apply({item:item, newKey:newKey, oldKey:oldKey}, details)]);
        me.updating--;
      }
    }
  }
}, findInsertIndex:function(item) {
  var source = this.getSource(), sourceItems = source.items, i = source.indexOf(item) - 1, sourceItem, index;
  while (i > -1) {
    sourceItem = sourceItems[i];
    index = this.indexOf(sourceItem);
    if (index > -1) {
      return index + 1;
    }
    --i;
  }
  return 0;
}, onCollectionAdd:function(source, details) {
  var me = this, atItem = details.atItem, items = details.items, requestedIndex = me.requestedIndex, filtered, index, copy, i, item, n;
  if (!me.sorted) {
    if (requestedIndex !== undefined) {
      index = requestedIndex;
    } else {
      if (atItem) {
        index = me.indexOf(atItem);
        if (index === -1) {
          index = me.findInsertIndex(items[0]);
        } else {
          ++index;
        }
      } else {
        index = 0;
      }
    }
  }
  if (me.getAutoFilter() && me.filtered) {
    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      if (me.isItemFiltered(item)) {
        if (!copy) {
          copy = items.slice(0, i);
        }
        if (!filtered) {
          filtered = [];
        }
        filtered.push(item);
      } else {
        if (copy) {
          copy.push(item);
        }
      }
    }
  }
  me.splice(index < 0 ? me.length : index, 0, copy || items);
  if (filtered) {
    me.notify('filteradd', [filtered]);
  }
}, onCollectionBeforeItemChange:function(source, details) {
  this.onCollectionUpdateKey = null;
  if (!this.sourceUpdating) {
    this.notify('beforeitemchange', [details]);
  }
}, onCollectionBeginUpdate:function() {
  this.beginUpdate();
}, onCollectionEndUpdate:function() {
  this.endUpdate();
}, onCollectionItemChange:function(source, details) {
  delete this.onCollectionUpdateKey;
  this.itemChanged(details.item, details.modified, details.oldKey, details.meta);
}, onCollectionFilteredItemChange:function() {
  delete this.onCollectionUpdateKey;
}, onCollectionRefresh:function(source) {
  var me = this, map = {}, indices = {}, items = me.items, sourceItems = source.items, filterFn = me.getFilterFn(), i, item, key, length, newLength;
  if (me.filtered && me.getAutoFilter()) {
    for (i = 0, newLength = 0, length = sourceItems.length; i < length; i++) {
      if (filterFn(sourceItems[i])) {
        items[newLength++] = sourceItems[i];
      }
    }
    items.length = newLength;
  } else {
    items.length = 0;
    items.push.apply(items, sourceItems);
  }
  if (me.sorted) {
    me.sortData(items);
  }
  me.length = length = items.length;
  me.map = map;
  me.indices = indices;
  for (i = 0; i < length; ++i) {
    key = me.getKey(item = items[i]);
    map[key] = item;
    indices[key] = i;
  }
  ++me.generation;
  me.notify('refresh');
}, onCollectionRemove:function(source, details) {
  this.splice(0, details.items);
}, onCollectionUpdateKey:function(source, details) {
  this.updateKey(details.item, details.oldKey, details);
}, _aggregators:{average:function(items, begin, end, property, root) {
  var n = end - begin;
  return n && this._aggregators.sum.call(this, items, begin, end, property, root) / n;
}, bounds:function(items, begin, end, property, root) {
  for (var value, max, min, i = begin; i < end; ++i) {
    value = items[i];
    value = (root ? value[root] : value)[property];
    if (!(value < max)) {
      max = value;
    }
    if (!(value > min)) {
      min = value;
    }
  }
  return [min, max];
}, count:function(items) {
  return items.length;
}, extremes:function(items, begin, end, property, root) {
  var most = null, least = null, i, item, max, min, value;
  for (i = begin; i < end; ++i) {
    item = items[i];
    value = (root ? item[root] : item)[property];
    if (!(value < max)) {
      max = value;
      most = item;
    }
    if (!(value > min)) {
      min = value;
      least = item;
    }
  }
  return [least, most];
}, max:function(items, begin, end, property, root) {
  var b = this._aggregators.bounds.call(this, items, begin, end, property, root);
  return b[1];
}, maxItem:function(items, begin, end, property, root) {
  var b = this._aggregators.extremes.call(this, items, begin, end, property, root);
  return b[1];
}, min:function(items, begin, end, property, root) {
  var b = this._aggregators.bounds.call(this, items, begin, end, property, root);
  return b[0];
}, minItem:function(items, begin, end, property, root) {
  var b = this._aggregators.extremes.call(this, items, begin, end, property, root);
  return b[0];
}, sum:function(items, begin, end, property, root) {
  for (var value, sum = 0, i = begin; i < end; ++i) {
    value = items[i];
    value = (root ? value[root] : value)[property];
    sum += value;
  }
  return sum;
}}, _eventToMethodMap:{add:'onCollectionAdd', beforeitemchange:'onCollectionBeforeItemChange', beginupdate:'onCollectionBeginUpdate', endupdate:'onCollectionEndUpdate', itemchange:'onCollectionItemChange', filtereditemchange:'onCollectionFilteredItemChange', refresh:'onCollectionRefresh', remove:'onCollectionRemove', beforesort:'beforeCollectionSort', sort:'onCollectionSort', filter:'onCollectionFilter', filteradd:'onCollectionFilterAdd', updatekey:'onCollectionUpdateKey'}, addObserver:function(observer) {
  var me = this, observers = me.observers;
  if (!observers) {
    me.observers = observers = [];
  }
  if (me.notifying) {
    me.observers = observers = observers.slice(0);
  }
  observers.push(observer);
  if (observers.length > 1) {
    Ext.Array.sort(observers, me.prioritySortFn);
  }
}, prioritySortFn:function(o1, o2) {
  var a = o1.observerPriority || 0, b = o2.observerPriority || 0;
  return a - b;
}, applyExtraKeys:function(extraKeys, oldExtraKeys) {
  var me = this, ret = oldExtraKeys || {}, config, name, value;
  for (name in extraKeys) {
    value = extraKeys[name];
    if (!value.isCollectionKey) {
      config = {collection:me};
      if (Ext.isString(value)) {
        config.property = value;
      } else {
        config = Ext.apply(config, value);
      }
      value = new Ext.util.CollectionKey(config);
    } else {
      value.setCollection(me);
    }
    ret[name] = me[name] = value;
    value.name = name;
  }
  return ret;
}, applyGrouper:function(grouper) {
  if (grouper) {
    grouper = this.getSorters().decodeSorter(grouper, Ext.util.Grouper);
  }
  return grouper;
}, decodeItems:function(args, index) {
  var me = this, ret = index === undefined ? args : args[index], cloned, decoder, i;
  if (!ret || !ret.$cloned) {
    cloned = args.length > index + 1 || !Ext.isIterable(ret);
    if (cloned) {
      ret = Ext.Array.slice(args, index);
      if (ret.length === 1 && ret[0] === undefined) {
        ret.length = 0;
      }
    }
    decoder = me.getDecoder();
    if (decoder) {
      if (!cloned) {
        ret = ret.slice(0);
        cloned = true;
      }
      for (i = ret.length; i-- > 0;) {
        if ((ret[i] = decoder.call(me, ret[i])) === false) {
          ret.splice(i, 1);
        }
      }
    }
    if (cloned) {
      ret.$cloned = true;
    }
  }
  return ret;
}, getIndices:function() {
  var me = this, indices = me.indices, items = me.items, n = items.length, i, key;
  if (!indices) {
    me.indices = indices = {};
    ++me.indexRebuilds;
    for (i = 0; i < n; ++i) {
      key = me.getKey(items[i]);
      indices[key] = i;
    }
  }
  return indices;
}, notify:function(eventName, args) {
  var me = this, observers = me.observers, methodName = me._eventToMethodMap[eventName], added = 0, index, length, method, observer;
  args = args || [];
  if (observers && methodName) {
    me.notifying = true;
    for (index = 0, length = observers.length; index < length; ++index) {
      method = (observer = observers[index])[methodName];
      if (method) {
        if (!added++) {
          args.unshift(me);
        }
        method.apply(observer, args);
      }
    }
    me.notifying = false;
  }
  if (!me.hasListeners) {
    return;
  }
  if (me.hasListeners[eventName]) {
    if (!added) {
      args.unshift(me);
    }
    me.fireEventArgs(eventName, args);
  }
}, getFilterFn:function() {
  return this.getFilters().getFilterFn();
}, getFilters:function(autoCreate) {
  var ret = this._filters;
  if (!ret && autoCreate !== false) {
    ret = new Ext.util.FilterCollection;
    this.setFilters(ret);
  }
  return ret;
}, isItemFiltered:function(item) {
  return !this.getFilters().filterFn(item);
}, onFilterChange:function(filters) {
  var me = this, source = me.getSource(), extraKeys, newKeys, key;
  if (!source) {
    extraKeys = me.getExtraKeys();
    if (extraKeys) {
      newKeys = {};
      for (key in extraKeys) {
        newKeys[key] = extraKeys[key].clone(me);
      }
    }
    source = new Ext.util.Collection({keyFn:me.getKey, extraKeys:newKeys, rootProperty:me.getRootProperty()});
    if (me.length) {
      source.add(me.items);
    }
    me.setSource(source);
    me.autoSource = source;
  } else {
    if (source.destroyed) {
      return;
    }
    if (source.length || me.length) {
      me.onCollectionRefresh(source);
    }
  }
  me.notify('filter');
}, applyFilters:function(filters, collection) {
  if (!filters || filters.isFilterCollection) {
    return filters;
  }
  if (filters) {
    if (!collection) {
      collection = this.getFilters();
    }
    collection.splice(0, collection.length, filters);
  }
  return collection;
}, updateFilters:function(newFilters, oldFilters) {
  var me = this;
  if (oldFilters) {
    oldFilters.un('endupdate', 'onEndUpdateFilters', me);
  }
  if (newFilters) {
    newFilters.on({endupdate:'onEndUpdateFilters', scope:me, priority:me.$endUpdatePriority});
    newFilters.$filterable = me;
  }
  me.onEndUpdateFilters(newFilters);
}, onEndUpdateFilters:function(filters) {
  var me = this, was = me.filtered, is = !!filters && filters.getFilterCount() > 0;
  if (was || is) {
    me.filtered = is;
    me.onFilterChange(filters);
  }
}, getSortFn:function() {
  return this._sortFn || this.createSortFn();
}, getSorters:function(autoCreate) {
  var ret = this._sorters;
  if (!ret && autoCreate !== false) {
    ret = new Ext.util.SorterCollection;
    this.setSorters(ret);
  }
  return ret;
}, onSortChange:function() {
  if (this.sorted) {
    this.sortItems();
  }
}, sort:function(property, direction, mode) {
  var sorters = this.getSorters();
  sorters.addSort.apply(sorters, arguments);
  return this;
}, sortData:function(data) {
  Ext.Array.sort(data, this.getSortFn());
  return data;
}, sortItems:function(sortFn) {
  var me = this;
  if (me.sorted) {
    sortFn = me.getSortFn();
  }
  me.indices = null;
  me.notify('beforesort', [me.getSorters(false)]);
  if (me.length) {
    Ext.Array.sort(me.items, sortFn);
  }
  me.notify('sort');
}, sortBy:function(sortFn) {
  return this.sortItems(sortFn);
}, findInsertionIndex:function(item, items, comparatorFn, index) {
  return Ext.Array.findInsertionIndex(item, items || this.items, comparatorFn || this.getSortFn(), index);
}, applySorters:function(sorters, collection) {
  if (!sorters || sorters.isSorterCollection) {
    return sorters;
  }
  if (sorters) {
    if (!collection) {
      collection = this.getSorters();
    }
    collection.splice(0, collection.length, sorters);
  }
  return collection;
}, createSortFn:function() {
  var me = this, grouper = me.getGrouper(), sorters = me.getSorters(false), sorterFn = sorters ? sorters.getSortFn() : null;
  if (!grouper) {
    return sorterFn;
  }
  return function(lhs, rhs) {
    var ret = grouper.sort(lhs, rhs);
    if (!ret && sorterFn) {
      ret = sorterFn(lhs, rhs);
    }
    return ret;
  };
}, updateGrouper:function(grouper) {
  var me = this, groups = me.getGroups(), sorters = me.getSorters(), populate;
  me.onSorterChange();
  me.grouped = !!grouper;
  if (grouper) {
    if (me.getTrackGroups()) {
      if (!groups) {
        groups = new Ext.util.GroupCollection({itemRoot:me.getRootProperty(), groupConfig:me.getGroupConfig()});
        groups.$groupable = me;
        me.setGroups(groups);
      }
      groups.setGrouper(grouper);
      populate = true;
    }
  } else {
    if (groups) {
      me.removeObserver(groups);
      groups.destroy();
    }
    me.setGroups(null);
  }
  if (!sorters.updating) {
    me.onEndUpdateSorters(sorters);
  }
  if (populate) {
    groups.onCollectionRefresh(me);
  }
}, updateSorters:function(newSorters, oldSorters) {
  var me = this;
  if (oldSorters && !oldSorters.destroyed) {
    oldSorters.un('endupdate', 'onEndUpdateSorters', me);
  }
  if (newSorters) {
    newSorters.on({endupdate:'onEndUpdateSorters', scope:me, priority:me.$endUpdatePriority});
    if (me.manageSorters) {
      newSorters.$sortable = me;
    }
  }
  me.onSorterChange();
  me.onEndUpdateSorters(newSorters);
}, onSorterChange:function() {
  this._sortFn = null;
}, onEndUpdateSorters:function(sorters) {
  var me = this, was = me.sorted, is = me.grouped && me.getAutoGroup() || sorters && sorters.length > 0;
  if (was || is) {
    me.sorted = !!is;
    me.onSortChange(sorters);
  }
}, removeObserver:function(observer) {
  var observers = this.observers;
  if (observers) {
    Ext.Array.remove(observers, observer);
  }
}, spliceMerge:function(newItems, newKeys) {
  var me = this, map = me.map, newLength = newItems.length, oldIndex = 0, oldItems = me.items, oldLength = oldItems.length, adds = [], count = 0, items = [], sortFn = me.getSortFn(), addItems, end, i, newItem, oldItem, newIndex;
  me.items = items;
  for (newIndex = 0; newIndex < newLength; newIndex = end) {
    newItem = newItems[newIndex];
    for (; oldIndex < oldLength; ++oldIndex) {
      if (sortFn(newItem, oldItem = oldItems[oldIndex]) < 0) {
        break;
      }
      items.push(oldItem);
    }
    if (oldIndex === oldLength) {
      adds[count++] = {at:items.length, itemAt:items[items.length - 1], items:addItems = []};
      if (count > 1) {
        adds[count - 2].next = adds[count - 1];
      }
      for (; newIndex < newLength; ++newIndex) {
        addItems.push(newItem = newItems[newIndex]);
        items.push(newItem);
      }
      break;
    }
    adds[count++] = {at:items.length, itemAt:items[items.length - 1], items:addItems = [newItem]};
    if (count > 1) {
      adds[count - 2].next = adds[count - 1];
    }
    items.push(newItem);
    for (end = newIndex + 1; end < newLength; ++end) {
      if (sortFn(newItem = newItems[end], oldItem) >= 0) {
        break;
      }
      items.push(newItem);
      addItems.push(newItem);
    }
  }
  for (; oldIndex < oldLength; ++oldIndex) {
    items.push(oldItems[oldIndex]);
  }
  for (i = 0; i < newLength; ++i) {
    map[newKeys[i]] = newItems[i];
  }
  me.length = items.length;
  ++me.generation;
  me.indices = null;
  for (i = 0; i < count; ++i) {
    me.notify('add', [adds[i]]);
  }
}, getGroups:function() {
  return (arguments.callee.$previous || Ext.Base.prototype.getGroups).call(this) || null;
}, updateAutoGroup:function(autoGroup) {
  var groups = this.getGroups();
  if (groups) {
    groups.setAutoGroup(autoGroup);
  }
  this.onEndUpdateSorters(this._sorters);
}, updateGroups:function(newGroups, oldGroups) {
  if (oldGroups) {
    this.removeObserver(oldGroups);
  }
  if (newGroups) {
    this.addObserver(newGroups);
  }
}, updateSource:function(newSource, oldSource) {
  var auto = this.autoSource;
  if (oldSource) {
    if (!oldSource.destroyed) {
      oldSource.removeObserver(this);
    }
    if (oldSource === auto) {
      auto.destroy();
      this.autoSource = null;
    }
  }
  if (newSource) {
    newSource.addObserver(this);
    if (newSource.length || this.length) {
      this.onCollectionRefresh(newSource);
    }
  }
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.util, 'Collection'], function() {
  var prototype = this.prototype;
  prototype.removeAtKey = prototype.removeByKey;
  prototype.decodeRemoveItems = prototype.decodeItems;
  Ext.Object.each(prototype._aggregators, function(name) {
    prototype[name] = function(property, begin, end) {
      return this.aggregate(property, name, begin, end);
    };
    prototype[name + 'ByGroup'] = function(property) {
      return this.aggregateByGroup(property, name);
    };
  });
});
Ext.cmd.derive('Ext.data.Range', Ext.Base, {isDataRange:true, begin:0, buffer:0, end:0, length:0, store:null, constructor:function(config) {
  var me = this, activeRanges, store;
  Ext.apply(me, config);
  store = me.store;
  if (!(activeRanges = store.activeRanges)) {
    store.activeRanges = activeRanges = [];
  }
  activeRanges.push(me);
  me.refresh();
  if ('begin' in config) {
    me.begin = me.end = 0;
    me['goto'](config.begin, config.end);
  }
}, destroy:function() {
  var me = this, store = me.store, activeRanges = store && store.activeRanges;
  Ext.destroy(me.storeListeners);
  if (activeRanges) {
    Ext.Array.remove(activeRanges, me);
  }
  me.callParent();
}, 'goto':function(begin, end) {
  var me = this, buffer = me.buffer, task = me.task;
  me.begin = begin;
  me.end = end;
  me.length = end - begin;
  if (buffer > 0) {
    if (!task) {
      me.task = task = new Ext.util.DelayedTask(me.doGoto, me);
    }
    task.delay(buffer);
  } else {
    me.doGoto();
  }
}, privates:{lastBegin:0, lastEnd:0, doGoto:Ext.privateFn, refresh:function() {
  this.records = this.store.getData().items;
}}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'Range'], 0);
Ext.cmd.derive('Ext.util.ObjectTemplate', Ext.Base, {isObjectTemplate:true, excludeProperties:{}, valueRe:/^[{][a-z\.]+[}]$/i, statics:{create:function(template, options) {
  return template.isObjectTemplate ? template : new Ext.util.ObjectTemplate(template, options);
}}, constructor:function(template, options) {
  Ext.apply(this, options);
  this.template = template;
}, apply:function(context) {
  var me = this;
  delete me.apply;
  me.apply = me.compile(me.template);
  return me.apply(context);
}, privates:{compile:function(template) {
  var me = this, exclude = me.excludeProperties, compiled, i, len, fn;
  if (Ext.isString(template)) {
    if (template.indexOf('{') < 0) {
      fn = function() {
        return template;
      };
    } else {
      if (me.valueRe.test(template)) {
        template = template.substring(1, template.length - 1).split('.');
        fn = function(context) {
          for (var v = context, i = 0; v && i < template.length; ++i) {
            v = v[template[i]];
          }
          return v;
        };
      } else {
        template = new Ext.XTemplate(template);
        fn = function(context) {
          return template.apply(context);
        };
      }
    }
  } else {
    if (!template || Ext.isPrimitive(template) || Ext.isFunction(template)) {
      fn = function() {
        return template;
      };
    } else {
      if (template instanceof Array) {
        compiled = [];
        for (i = 0, len = template.length; i < len; ++i) {
          compiled[i] = me.compile(template[i]);
        }
        fn = function(context) {
          var ret = [], i;
          for (i = 0; i < len; ++i) {
            ret[i] = compiled[i](context);
          }
          return ret;
        };
      } else {
        compiled = {};
        for (i in template) {
          if (!exclude[i]) {
            compiled[i] = me.compile(template[i]);
          }
        }
        fn = function(context) {
          var ret = {}, i, v;
          for (i in template) {
            v = exclude[i] ? template[i] : compiled[i](context);
            if (v !== undefined) {
              ret[i] = v;
            }
          }
          return ret;
        };
      }
    }
  }
  return fn;
}}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'ObjectTemplate'], 0);
Ext.cmd.derive('Ext.data.schema.Role', Ext.Base, {isRole:true, left:true, owner:false, side:'left', isMany:false, defaultReaderType:'json', _internalReadOptions:{recordsOnly:true, asRoot:true}, constructor:function(association, config) {
  var me = this, extra = config.extra;
  Ext.apply(me, config);
  if (extra) {
    extra = Ext.apply({}, extra);
    delete extra.type;
    Ext.apply(me, extra);
    delete me.extra;
  }
  me.association = association;
  if (association.owner === me.side) {
    association.owner = me;
    me.owner = true;
  }
}, processUpdate:function() {
  Ext.raise('Only the "many" for an association may be processed. "' + this.role + '" is not valid.');
}, processLoad:function(store, associatedEntity, records, session) {
  return records;
}, checkMembership:Ext.emptyFn, adoptAssociated:function(record, session) {
  var other = this.getAssociatedItem(record);
  if (other) {
    session.adopt(other);
  }
}, $roleFilterId:'$associationRoleFilter', createAssociationStore:function(session, from, records, isComplete) {
  var me = this, association = me.association, foreignKeyName = association.getFieldName(), isMany = association.isManyToMany, storeConfig = me.storeConfig, id = from.getId(), config = {asynchronousLoad:false, model:me.cls, role:me, session:session, associatedEntity:from, disableMetaChangeEvent:true, pageSize:null, remoteFilter:true, trackRemoved:!session}, store;
  if (isMany) {
    config.filters = [{id:me.$roleFilterId, property:me.inverse.field, value:id, exactMatch:true}];
  } else {
    if (foreignKeyName) {
      config.filters = [{id:me.$roleFilterId, property:foreignKeyName, value:id, exactMatch:true}];
      config.foreignKeyName = foreignKeyName;
    }
  }
  if (storeConfig) {
    Ext.apply(config, storeConfig);
  }
  store = Ext.Factory.store(config);
  me.onStoreCreate(store, session, id);
  if (!isMany || session) {
    store.on({scope:me, add:'onAddToMany', remove:'onRemoveFromMany', clear:'onRemoveFromMany'});
  }
  if (records) {
    store.loadData(records);
  }
  store.complete = !!isComplete;
  return store;
}, onStoreCreate:Ext.emptyFn, getAssociatedStore:function(inverseRecord, options, scope, records, allowInfer) {
  var me = this, storeName = me.getStoreName(), store = inverseRecord[storeName], hadStore = store, session = inverseRecord.session, load = options && options.reload, source = inverseRecord.$source, isComplete = false, phantom = false, hadSourceStore, args, i, len, raw, rec, sourceStore, hadRecords, isLoading;
  if (!store) {
    if (session) {
      if (source) {
        phantom = source.phantom;
      }
      if (!records && source) {
        sourceStore = source[storeName];
        if (sourceStore && !sourceStore.isLoading()) {
          records = [];
          raw = sourceStore.getData().items;
          for (i = 0, len = raw.length; i < len; ++i) {
            rec = raw[i];
            records.push(session.getRecord(rec.self, rec.id));
          }
          isComplete = !!sourceStore.complete;
          hadSourceStore = true;
        }
      }
      if (!hadSourceStore) {
        hadRecords = !!records;
        records = me.findRecords(session, inverseRecord, records, allowInfer);
        if (!hadRecords && (!records || !records.length)) {
          records = null;
        }
        isComplete = phantom || hadRecords;
      }
    } else {
      isComplete = !!records;
    }
    store = me.createAssociationStore(session, inverseRecord, records, isComplete || inverseRecord.phantom);
    store.$source = sourceStore;
    if (!records && (me.autoLoad || options)) {
      load = true;
    }
    inverseRecord[storeName] = store;
  }
  if (options) {
    if (load || store.isLoading()) {
      store.on('load', function(store, records, success, operation) {
        args = [store, operation];
        scope = scope || options.scope || inverseRecord;
        if (success) {
          Ext.callback(options.success, scope, args);
        } else {
          Ext.callback(options.failure, scope, args);
        }
        args.push(success);
        Ext.callback(options, scope, args);
        Ext.callback(options.callback, scope, args);
      }, null, {single:true});
    } else {
      args = [store, null];
      scope = scope || options.scope || inverseRecord;
      Ext.callback(options.success, scope, args);
      args.push(true);
      Ext.callback(options, scope, args);
      Ext.callback(options.callback, scope, args);
    }
  }
  isLoading = store.isLoading();
  if (load) {
    if (!isLoading) {
      store.load();
    }
  } else {
    if (hadStore && records && !isLoading) {
      store.loadData(records);
    }
  }
  return store;
}, getAssociatedItem:function(rec) {
  var key = this.isMany ? this.getStoreName() : this.getInstanceName();
  return rec[key] || null;
}, onDrop:Ext.emptyFn, onIdChanged:Ext.emptyFn, getReaderRoot:function() {
  var me = this;
  return me.associationKey || (me.associationKey = me.association.schema.getNamer().readerRoot(me.role));
}, getReader:function() {
  var me = this, reader = me.reader, Model = me.cls, useSimpleAccessors = !me.associationKey, root = this.getReaderRoot();
  if (reader && !reader.isReader) {
    if (Ext.isString(reader)) {
      reader = {type:reader};
    }
    Ext.applyIf(reader, {model:Model, rootProperty:root, useSimpleAccessors:useSimpleAccessors, type:me.defaultReaderType});
    reader = me.reader = Ext.createByAlias('reader.' + reader.type, reader);
  }
  return reader;
}, getInstanceName:function() {
  var me = this;
  return me.instanceName || (me.instanceName = me.association.schema.getNamer().instanceName(me.role));
}, getOldInstanceName:function() {
  return this.oldInstanceName || (this.oldInstanceName = '$old' + this.getInstanceName());
}, getStoreName:function() {
  var me = this;
  return me.storeName || (me.storeName = me.association.schema.getNamer().storeName(me.role));
}, constructReader:function(fromReader) {
  var me = this, reader = me.getReader(), Model = me.cls, useSimpleAccessors = !me.associationKey, root = me.getReaderRoot(), proxyReader, proxy;
  if (!reader) {
    proxy = Model.getProxy();
    if (proxy) {
      proxyReader = proxy.getReader();
      reader = new proxyReader.self;
      reader.copyFrom(proxyReader);
      reader.setRootProperty(root);
    } else {
      reader = new fromReader.self({model:Model, useSimpleAccessors:useSimpleAccessors, rootProperty:root});
    }
    me.reader = reader;
  }
  return reader;
}, read:function(record, data, fromReader, readOptions) {
  var reader = this.constructReader(fromReader), root = reader.getRoot(data);
  if (root) {
    return reader.readRecords(root, readOptions, this._internalReadOptions);
  }
}, getCallbackOptions:function(options, scope, defaultScope) {
  if (typeof options === 'function') {
    options = {callback:options, scope:scope || defaultScope};
  } else {
    if (options) {
      options = Ext.apply({}, options);
      options.scope = scope || options.scope || defaultScope;
    }
  }
  return options;
}, doGetFK:function(leftRecord, options, scope) {
  var me = this, cls = me.cls, foreignKey = me.association.getFieldName(), instanceName = me.getInstanceName(), rightRecord = leftRecord[instanceName], reload = options && options.reload, done = rightRecord !== undefined && !reload, session = leftRecord.session, foreignKeyId, args;
  if (!done) {
    if (session) {
      foreignKeyId = leftRecord.get(foreignKey);
      if (foreignKeyId || foreignKeyId === 0) {
        done = session.peekRecord(cls, foreignKeyId, true) && !reload;
        rightRecord = session.getRecord(cls, foreignKeyId, false);
      } else {
        done = true;
        leftRecord[instanceName] = rightRecord = null;
      }
    } else {
      if (foreignKey) {
        foreignKeyId = leftRecord.get(foreignKey);
        if (!foreignKeyId && foreignKeyId !== 0) {
          done = true;
          leftRecord[instanceName] = rightRecord = null;
        } else {
          if (!rightRecord) {
            rightRecord = cls.createWithId(foreignKeyId);
          }
        }
      } else {
        done = true;
        rightRecord = null;
      }
    }
  } else {
    if (rightRecord) {
      done = !rightRecord.isLoading();
    }
  }
  if (done) {
    if (options) {
      args = [rightRecord, null];
      scope = scope || options.scope || leftRecord;
      Ext.callback(options.success, scope, args);
      args.push(true);
      Ext.callback(options, scope, args);
      Ext.callback(options.callback, scope, args);
    }
  } else {
    leftRecord[instanceName] = rightRecord;
    options = me.getCallbackOptions(options, scope, leftRecord);
    rightRecord.load(options);
  }
  return rightRecord;
}, doSetFK:function(leftRecord, rightRecord, options, scope) {
  var me = this, foreignKey = me.association.getFieldName(), instanceName = me.getInstanceName(), current = leftRecord[instanceName], inverse = me.inverse, inverseSetter = inverse.setterName, session = leftRecord.session, modified, oldInstanceName;
  if (rightRecord && rightRecord.isEntity) {
    if (current !== rightRecord) {
      oldInstanceName = me.getOldInstanceName();
      leftRecord[oldInstanceName] = current;
      leftRecord[instanceName] = rightRecord;
      if (current && current.isEntity) {
        current[inverse.getInstanceName()] = undefined;
      }
      if (foreignKey) {
        leftRecord.set(foreignKey, rightRecord.getId());
      }
      delete leftRecord[oldInstanceName];
      leftRecord.onAssociatedRecordSet(rightRecord, me);
      if (inverseSetter) {
        rightRecord[inverseSetter](leftRecord);
      }
    }
  } else {
    modified = leftRecord.changingKey && !inverse.isMany || leftRecord.set(foreignKey, rightRecord);
    if (modified && current && current.isEntity && !current.isEqual(current.getId(), rightRecord)) {
      leftRecord[instanceName] = undefined;
      if (!inverse.isMany) {
        current[inverse.getInstanceName()] = undefined;
      }
    }
  }
  if (options) {
    if (Ext.isFunction(options)) {
      options = {callback:options, scope:scope || leftRecord};
    }
    return leftRecord.save(options);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.data.schema, 'Role'], 0);
Ext.cmd.derive('Ext.data.schema.Association', Ext.Base, {isOneToOne:false, isManyToOne:false, isManyToMany:false, owner:null, field:null, constructor:function(config) {
  var me = this, left, right;
  Ext.apply(me, config);
  me.left = left = new me.Left(me, me.left);
  me.right = right = new me.Right(me, me.right);
  left.inverse = right;
  right.inverse = left;
}, hasField:function() {
  return !!this.field;
}, getFieldName:function() {
  var field = this.field;
  return field ? field.name : '';
}}, 1, 0, 0, 0, 0, 0, [Ext.data.schema, 'Association'], 0);
Ext.cmd.derive('Ext.data.schema.OneToOne', Ext.data.schema.Association, {isOneToOne:true, isToOne:true, kind:'one-to-one', Left:Ext.define(null, {extend:'Ext.data.schema.Role', onDrop:function(rightRecord, session) {
  var leftRecord = this.getAssociatedItem(rightRecord);
  rightRecord[this.getInstanceName()] = null;
  if (leftRecord) {
    leftRecord[this.inverse.getInstanceName()] = null;
  }
}, onIdChanged:function(rightRecord, oldId, newId) {
  var leftRecord = this.getAssociatedItem(rightRecord), fieldName = this.association.getFieldName();
  if (!rightRecord.session && leftRecord && fieldName) {
    leftRecord.set(fieldName, newId);
  }
}, createGetter:function() {
  var me = this;
  return function() {
    return me.doGet(this);
  };
}, createSetter:function() {
  var me = this;
  return function(value) {
    return me.doSet(this, value);
  };
}, doGet:function(rightRecord) {
  var instanceName = this.getInstanceName(), ret = rightRecord[instanceName], session = rightRecord.session;
  if (!ret && session) {
  }
  return ret || null;
}, doSet:function(rightRecord, leftRecord) {
  var instanceName = this.getInstanceName(), ret = rightRecord[instanceName], inverseSetter = this.inverse.setterName;
  if (ret !== leftRecord) {
    rightRecord[instanceName] = leftRecord;
    if (inverseSetter) {
      leftRecord[inverseSetter](rightRecord);
    }
    rightRecord.onAssociatedRecordSet(leftRecord, this);
  }
  return ret;
}, read:function(rightRecord, node, fromReader, readOptions) {
  var me = this, leftRecords = me.callParent([rightRecord, node, fromReader, readOptions]), leftRecord;
  if (leftRecords) {
    leftRecord = leftRecords[0];
    if (leftRecord) {
      leftRecord[me.inverse.getInstanceName()] = rightRecord;
      rightRecord[me.getInstanceName()] = leftRecord;
      delete rightRecord.data[me.role];
    }
  }
}}), Right:Ext.define(null, {extend:'Ext.data.schema.Role', left:false, side:'right', createGetter:function() {
  var me = this;
  return function(options, scope) {
    return me.doGetFK(this, options, scope);
  };
}, createSetter:function() {
  var me = this;
  return function(value, options, scope) {
    return me.doSetFK(this, value, options, scope);
  };
}, onDrop:function(leftRecord, session) {
  var me = this, field = me.association.field, rightRecord = me.getAssociatedItem(leftRecord), id;
  if (me.inverse.owner) {
    if (session && field) {
      id = leftRecord.get(field.name);
      if (id || id === 0) {
        rightRecord = session.getEntry(me.cls, id).record;
        if (rightRecord) {
          rightRecord.drop();
        }
      }
    } else {
      if (rightRecord) {
        rightRecord.drop();
      }
    }
  }
  if (field) {
    leftRecord.set(field.name, null);
  }
  leftRecord[me.getInstanceName()] = null;
  if (rightRecord) {
    rightRecord[me.inverse.getInstanceName()] = null;
  }
}, onValueChange:function(leftRecord, session, newValue) {
  var me = this, rightRecord = leftRecord[me.getOldInstanceName()] || me.getAssociatedItem(leftRecord), hasNewValue = newValue || newValue === 0, instanceName = me.getInstanceName(), cls = me.cls;
  leftRecord.changingKey = true;
  me.doSetFK(leftRecord, newValue);
  if (!hasNewValue) {
    leftRecord[instanceName] = null;
  } else {
    if (session && cls) {
      leftRecord[instanceName] = session.peekRecord(cls, newValue) || undefined;
    }
  }
  if (me.inverse.owner && rightRecord) {
    me.association.schema.queueKeyCheck(rightRecord, me);
  }
  leftRecord.changingKey = false;
}, checkKeyForDrop:function(rightRecord) {
  var leftRecord = this.inverse.getAssociatedItem(rightRecord);
  if (!leftRecord) {
    rightRecord.drop();
  }
}, read:function(leftRecord, node, fromReader, readOptions) {
  var me = this, rightRecords = me.callParent([leftRecord, node, fromReader, readOptions]), rightRecord, field, fieldName, session, refs, id, oldId, setKey, data;
  if (rightRecords) {
    rightRecord = rightRecords[0];
    field = me.association.field;
    if (field) {
      fieldName = field.name;
    }
    session = leftRecord.session;
    data = leftRecord.data;
    if (rightRecord) {
      if (session) {
        refs = session.getRefs(rightRecord, this.inverse, true);
        setKey = refs && refs[leftRecord.id] || data[fieldName] === undefined;
      } else {
        setKey = true;
      }
      if (setKey) {
        if (field) {
          oldId = data[fieldName];
          id = rightRecord.id;
          if (oldId !== id) {
            data[fieldName] = id;
            if (session) {
              session.updateReference(leftRecord, field, id, oldId);
            }
          }
        }
        rightRecord[me.inverse.getInstanceName()] = leftRecord;
        leftRecord[me.getInstanceName()] = rightRecord;
      }
      delete data[me.role];
    }
  }
}})}, 0, 0, 0, 0, 0, 0, [Ext.data.schema, 'OneToOne'], 0);
Ext.cmd.derive('Ext.data.schema.ManyToOne', Ext.data.schema.Association, {isManyToOne:true, isToOne:true, kind:'many-to-one', Left:Ext.define(null, {extend:'Ext.data.schema.Role', isMany:true, onDrop:function(rightRecord, session) {
  var me = this, store = me.getAssociatedItem(rightRecord), leftRecords, len, i, refs, id;
  if (store) {
    leftRecords = store.removeAll();
    if (leftRecords && me.inverse.owner) {
      for (i = 0, len = leftRecords.length; i < len; ++i) {
        leftRecords[i].drop();
      }
    }
    store.destroy();
    rightRecord[me.getStoreName()] = null;
  } else {
    if (session) {
      leftRecords = session.getRefs(rightRecord, me);
      if (leftRecords) {
        for (id in leftRecords) {
          leftRecords[id].drop();
        }
      }
    }
  }
}, onIdChanged:function(rightRecord, oldId, newId) {
  var fieldName = this.association.getFieldName(), store = this.getAssociatedItem(rightRecord), leftRecords, i, len, filter;
  if (store) {
    filter = store.getFilters().get(this.$roleFilterId);
    if (filter) {
      filter.setValue(newId);
    }
    if (!rightRecord.session && fieldName) {
      leftRecords = store.getDataSource().items;
      for (i = 0, len = leftRecords.length; i < len; ++i) {
        leftRecords[i].set(fieldName, newId);
      }
    }
  }
}, processUpdate:function(session, associationData) {
  var me = this, entityType = me.inverse.cls, items = associationData.R, id, rightRecord, store, leftRecords;
  if (items) {
    for (id in items) {
      rightRecord = session.peekRecord(entityType, id);
      if (rightRecord) {
        leftRecords = session.getEntityList(me.cls, items[id]);
        store = me.getAssociatedItem(rightRecord);
        if (store) {
          store.loadData(leftRecords);
          store.complete = true;
        } else {
          rightRecord[me.getterName](null, null, leftRecords);
        }
      } else {
        session.onInvalidAssociationEntity(entityType, id);
      }
    }
  }
}, findRecords:function(session, rightRecord, leftRecords, allowInfer) {
  var ret = leftRecords, refs = session.getRefs(rightRecord, this, true), field = this.association.field, fieldName, leftRecord, id, i, len, seen;
  if (field && (refs || allowInfer)) {
    fieldName = field.name;
    ret = [];
    if (leftRecords) {
      seen = {};
      for (i = 0, len = leftRecords.length; i < len; ++i) {
        leftRecord = leftRecords[i];
        id = leftRecord.id;
        if (refs && refs[id]) {
          ret.push(leftRecord);
        } else {
          if (allowInfer && leftRecord.data[fieldName] === undefined) {
            ret.push(leftRecord);
            leftRecord.data[fieldName] = rightRecord.id;
            session.updateReference(leftRecord, field, rightRecord.id, undefined);
          }
        }
        seen[id] = true;
      }
    }
    if (refs) {
      for (id in refs) {
        if (!seen || !seen[id]) {
          ret.push(refs[id]);
        }
      }
    }
  }
  return ret;
}, processLoad:function(store, rightRecord, leftRecords, session) {
  var ret = leftRecords;
  if (session) {
    ret = this.findRecords(session, rightRecord, leftRecords, true);
  }
  this.onLoadMany(rightRecord, ret, session);
  return ret;
}, adoptAssociated:function(rightRecord, session) {
  var store = this.getAssociatedItem(rightRecord), leftRecords, i, len;
  if (store) {
    store.setSession(session);
    leftRecords = store.getData().items;
    for (i = 0, len = leftRecords.length; i < len; ++i) {
      session.adopt(leftRecords[i]);
    }
  }
}, createGetter:function() {
  var me = this;
  return function(options, scope, leftRecords) {
    return me.getAssociatedStore(this, options, scope, leftRecords, true);
  };
}, createSetter:null, onAddToMany:function(store, leftRecords) {
  var rightRecord = store.getAssociatedEntity();
  if (this.association.field) {
    this.syncFK(leftRecords, rightRecord, false);
  } else {
    this.setInstances(rightRecord, leftRecords);
  }
}, onLoadMany:function(rightRecord, leftRecords, session) {
  this.setInstances(rightRecord, leftRecords, session);
}, onRemoveFromMany:function(store, leftRecords) {
  if (this.association.field) {
    this.syncFK(leftRecords, store.getAssociatedEntity(), true);
  } else {
    this.setInstances(null, leftRecords);
  }
}, read:function(rightRecord, node, fromReader, readOptions) {
  var me = this, instanceName = me.inverse.getInstanceName(), leftRecords = me.callParent([rightRecord, node, fromReader, readOptions]), store, len, i;
  if (leftRecords) {
    store = rightRecord[me.getterName](null, null, leftRecords);
    delete rightRecord.data[me.role];
    leftRecords = store.getData().items;
    for (i = 0, len = leftRecords.length; i < len; ++i) {
      leftRecords[i][instanceName] = rightRecord;
    }
  }
}, setInstances:function(rightRecord, leftRecords, session) {
  var instanceName = this.inverse.getInstanceName(), id = rightRecord ? rightRecord.getId() : null, field = this.association.field, len = leftRecords.length, i, leftRecord, oldId, data, name;
  for (i = 0; i < len; ++i) {
    leftRecord = leftRecords[i];
    leftRecord[instanceName] = rightRecord;
    if (field) {
      name = field.name;
      data = leftRecord.data;
      oldId = data[name];
      if (oldId !== id) {
        data[name] = id;
        if (session) {
          session.updateReference(leftRecord, field, id, oldId);
        }
      }
    }
  }
}, syncFK:function(leftRecords, rightRecord, clearing) {
  var foreignKeyName = this.association.getFieldName(), inverse = this.inverse, setter = inverse.setterName, instanceName = inverse.getInstanceName(), i = leftRecords.length, id = rightRecord.getId(), different, leftRecord, val;
  while (i-- > 0) {
    leftRecord = leftRecords[i];
    different = !leftRecord.isEqual(id, leftRecord.get(foreignKeyName));
    val = clearing ? null : rightRecord;
    if (different !== clearing) {
      leftRecord.changingKey = true;
      leftRecord[setter](val);
      leftRecord.changingKey = false;
    } else {
      leftRecord[instanceName] = val;
    }
  }
}}), Right:Ext.define(null, {extend:'Ext.data.schema.Role', left:false, side:'right', onDrop:function(leftRecord, session) {
  var field = this.association.field;
  if (field) {
    leftRecord.set(field.name, null);
  }
  leftRecord[this.getInstanceName()] = null;
}, createGetter:function() {
  var me = this;
  return function(options, scope) {
    return me.doGetFK(this, options, scope);
  };
}, createSetter:function() {
  var me = this;
  return function(rightRecord, options, scope) {
    return me.doSetFK(this, rightRecord, options, scope);
  };
}, checkMembership:function(session, leftRecord) {
  var field = this.association.field, store;
  if (field) {
    store = this.getSessionStore(session, leftRecord.get(field.name));
    if (store && !store.contains(leftRecord)) {
      store.add(leftRecord);
    }
  }
}, onValueChange:function(leftRecord, session, newValue, oldValue) {
  var me = this, instanceName = me.getInstanceName(), cls = me.cls, hasNewValue, joined, store, i, associated, rightRecord;
  if (!leftRecord.changingKey) {
    hasNewValue = newValue || newValue === 0;
    if (!hasNewValue) {
      leftRecord[instanceName] = null;
    }
    if (session) {
      store = me.getSessionStore(session, oldValue);
      if (store) {
        store.remove(leftRecord);
      }
      if (hasNewValue) {
        store = me.getSessionStore(session, newValue);
        if (store && !store.isLoading()) {
          store.add(leftRecord);
        }
        if (cls) {
          rightRecord = session.peekRecord(cls, newValue);
        }
        leftRecord[instanceName] = rightRecord || undefined;
      }
    } else {
      joined = leftRecord.joined;
      if (joined) {
        for (i = joined.length - 1; i >= 0; i--) {
          store = joined[i];
          if (store.isStore) {
            associated = store.getAssociatedEntity();
            if (associated && associated.self === me.cls && associated.getId() === oldValue) {
              store.remove(leftRecord);
            }
          }
        }
      }
    }
  }
  if (me.owner && newValue === null) {
    me.association.schema.queueKeyCheck(leftRecord, me);
  }
}, checkKeyForDrop:function(leftRecord) {
  var field = this.association.field;
  if (leftRecord.get(field.name) === null) {
    leftRecord.drop();
  }
}, getSessionStore:function(session, value) {
  var cls = this.cls, rec;
  if (cls) {
    rec = session.peekRecord(cls, value);
    if (rec) {
      return this.inverse.getAssociatedItem(rec);
    }
  }
}, read:function(leftRecord, node, fromReader, readOptions) {
  var rightRecords = this.callParent([leftRecord, node, fromReader, readOptions]), rightRecord;
  if (rightRecords) {
    rightRecord = rightRecords[0];
    if (rightRecord) {
      leftRecord[this.getInstanceName()] = rightRecord;
      delete leftRecord.data[this.role];
    }
  }
}})}, 0, 0, 0, 0, 0, 0, [Ext.data.schema, 'ManyToOne'], 0);
Ext.cmd.derive('Ext.data.schema.ManyToMany', Ext.data.schema.Association, {isManyToMany:true, isToMany:true, kind:'many-to-many', Left:Ext.define(null, {extend:'Ext.data.schema.Role', isMany:true, digitRe:/^\d+$/, findRecords:function(session, rightRecord, leftRecords) {
  var slice = session.getMatrixSlice(this.inverse, rightRecord.id), members = slice.members, ret = [], cls = this.cls, seen, i, len, id, member, leftRecord;
  if (leftRecords) {
    seen = {};
    for (i = 0, len = leftRecords.length; i < len; ++i) {
      leftRecord = leftRecords[i];
      id = leftRecord.id;
      member = members[id];
      if (!(member && member[2] === -1)) {
        ret.push(leftRecord);
      }
      seen[id] = true;
    }
  }
  for (id in members) {
    member = members[id];
    if (!seen || !seen[id] && (member && member[2] !== -1)) {
      leftRecord = session.peekRecord(cls, id);
      if (leftRecord) {
        ret.push(leftRecord);
      }
    }
  }
  return ret;
}, onIdChanged:function(rightRecord, oldId, newId) {
  var store = this.getAssociatedItem(rightRecord);
  if (store) {
    store.getFilters().get(this.$roleFilterId).setValue(newId);
  }
}, processLoad:function(store, rightRecord, leftRecords, session) {
  var ret = leftRecords;
  if (session) {
    ret = this.findRecords(session, rightRecord, leftRecords);
    this.onAddToMany(store, ret, true);
  }
  return ret;
}, processUpdate:function(session, associationData) {
  var me = this, entityType = me.inverse.cls, items = associationData.R, id, rightRecord, store, leftRecords;
  if (items) {
    for (id in items) {
      rightRecord = session.peekRecord(entityType, id);
      if (rightRecord) {
        leftRecords = session.getEntityList(me.cls, items[id]);
        store = me.getAssociatedItem(rightRecord);
        if (store) {
          store.loadData(leftRecords);
          store.complete = true;
        } else {
          rightRecord[me.getterName](null, null, leftRecords);
        }
      } else {
        session.onInvalidAssociationEntity(entityType, id);
      }
    }
  }
  me.processMatrixBlock(session, associationData.C, 1);
  me.processMatrixBlock(session, associationData.D, -1);
}, checkMembership:function(session, rightRecord) {
  var matrix = session.getMatrix(this.association, true), side, entityType, inverse, slice, slices, id, members, member, leftRecord, store;
  if (!matrix) {
    return;
  }
  side = this.left ? matrix.right : matrix.left;
  entityType = side.inverse.role.cls;
  inverse = this.inverse;
  slices = side.slices;
  if (slices) {
    slice = slices[rightRecord.id];
    if (slice) {
      members = slice.members;
      for (id in members) {
        member = members[id];
        if (member[2] !== -1) {
          leftRecord = session.peekRecord(entityType, id);
          if (leftRecord) {
            store = inverse.getAssociatedItem(leftRecord);
            if (store) {
              store.matrixUpdate = 1;
              store.add(rightRecord);
              store.matrixUpdate = 0;
            }
          }
        }
      }
    }
  }
}, onStoreCreate:function(store, session, id) {
  var me = this, matrix;
  if (session) {
    matrix = session.getMatrixSlice(me.inverse, id);
    matrix.attach(store);
    matrix.notify = me.onMatrixUpdate;
    matrix.scope = me;
  }
}, processMatrixBlock:function(session, leftKeys, state) {
  var inverse = this.inverse, digitRe = this.digitRe, slice, id;
  if (leftKeys) {
    for (id in leftKeys) {
      if (digitRe.test(id)) {
        id = parseInt(id, 10);
      }
      slice = session.getMatrixSlice(inverse, id);
      slice.update(leftKeys[id], state);
    }
  }
}, createGetter:function() {
  var me = this;
  return function(options, scope, leftRecords) {
    return me.getAssociatedStore(this, options, scope, leftRecords, false);
  };
}, onAddToMany:function(store, leftRecords, load) {
  if (!store.matrixUpdate) {
    store.matrixUpdate = 1;
    store.matrix.update(leftRecords, load === true ? 0 : 1);
    store.matrixUpdate = 0;
  }
}, onRemoveFromMany:function(store, records) {
  if (!store.matrixUpdate) {
    store.matrixUpdate = 1;
    store.matrix.update(records, -1);
    store.matrixUpdate = 0;
  }
}, read:function(rightRecord, node, fromReader, readOptions) {
  var me = this, leftRecords = me.callParent([rightRecord, node, fromReader, readOptions]);
  if (leftRecords) {
    rightRecord[me.getterName](null, null, leftRecords);
    delete rightRecord.data[me.role];
  }
}, onMatrixUpdate:function(matrixSlice, id, state) {
  var store = matrixSlice.store, index, leftRecord, entry;
  if (store && !store.loading && !store.matrixUpdate) {
    store.matrixUpdate = 1;
    index = store.indexOfId(id);
    if (state < 0) {
      if (index >= 0) {
        store.remove([index]);
      }
    } else {
      if (index < 0) {
        entry = store.getSession().getEntry(this.type, id);
        leftRecord = entry && entry.record;
        if (leftRecord) {
          store.add(leftRecord);
        }
      }
    }
    store.matrixUpdate = 0;
  }
}, adoptAssociated:function(record, session) {
  var store = this.getAssociatedItem(record), records, i, len;
  if (store) {
    store.setSession(session);
    this.onStoreCreate(store, session, record.getId());
    records = store.getData().items;
    for (i = 0, len = records.length; i < len; ++i) {
      session.adopt(records[i]);
    }
  }
}}, function() {
  var Left = this;
  Ext.ClassManager.onCreated(function() {
    Ext.data.schema.ManyToMany.prototype.Right = Ext.define(null, {extend:Left, left:false, side:'right'});
  }, null, 'Ext.data.schema.ManyToMany');
})}, 0, 0, 0, 0, 0, 0, [Ext.data.schema, 'ManyToMany'], 0);
Ext.cmd.derive('Ext.util.Inflector', Ext.Base, {singleton:true, plurals:[[/(quiz)$/i, '$1zes'], [/^(ox)$/i, '$1en'], [/([m|l])ouse$/i, '$1ice'], [/(matr|vert|ind)ix|ex$/i, '$1ices'], [/(x|ch|ss|sh)$/i, '$1es'], [/([^aeiouy]|qu)y$/i, '$1ies'], [/(hive)$/i, '$1s'], [/(?:([^f])fe|([lr])f)$/i, '$1$2ves'], [/sis$/i, 'ses'], [/([ti])um$/i, '$1a'], [/(buffal|tomat|potat)o$/i, '$1oes'], [/(bu)s$/i, '$1ses'], [/(alias|status|sex)$/i, '$1es'], [/(octop|vir)us$/i, '$1i'], [/(ax|test)is$/i, '$1es'], [/^(p)erson$/i, 
'$1eople'], [/^(m)an$/i, '$1en'], [/(.*)(child)(ren)?$/i, '$1$2ren'], [/s$/i, 's'], [/$/, 's']], singulars:[[/(address)$/i, '$1'], [/(quiz)zes$/i, '$1'], [/(matr)ices$/i, '$1ix'], [/(vert|ind)ices$/i, '$1ex'], [/^(ox)en/i, '$1'], [/(alias|status)es$/i, '$1'], [/(octop|vir)i$/i, '$1us'], [/(cris|ax|test)es$/i, '$1is'], [/(shoe)s$/i, '$1'], [/(o)es$/i, '$1'], [/(bus)es$/i, '$1'], [/([m|l])ice$/i, '$1ouse'], [/(x|ch|ss|sh)es$/i, '$1'], [/(m)ovies$/i, '$1ovie'], [/(s)eries$/i, '$1eries'], [/([^aeiouy]|qu)ies$/i, 
'$1y'], [/([lr])ves$/i, '$1f'], [/(tive)s$/i, '$1'], [/(hive)s$/i, '$1'], [/([^f])ves$/i, '$1fe'], [/(^analy)ses$/i, '$1sis'], [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i, '$1$2sis'], [/([ti])a$/i, '$1um'], [/(n)ews$/i, '$1ews'], [/(p)eople$/i, '$1erson'], [/s$/i, '']], uncountable:['sheep', 'fish', 'series', 'species', 'money', 'rice', 'information', 'equipment', 'grass', 'mud', 'offspring', 'deer', 'means'], singular:function(matcher, replacer) {
  this.singulars.unshift([matcher, replacer]);
}, plural:function(matcher, replacer) {
  this.plurals.unshift([matcher, replacer]);
}, clearSingulars:function() {
  this.singulars = [];
}, clearPlurals:function() {
  this.plurals = [];
}, isTransnumeral:function(word) {
  return Ext.Array.indexOf(this.uncountable, word) != -1;
}, pluralize:function(word) {
  if (this.isTransnumeral(word)) {
    return word;
  }
  var plurals = this.plurals, length = plurals.length, tuple, regex, i;
  for (i = 0; i < length; i++) {
    tuple = plurals[i];
    regex = tuple[0];
    if (regex == word || regex.test && regex.test(word)) {
      return word.replace(regex, tuple[1]);
    }
  }
  return word;
}, singularize:function(word) {
  if (this.isTransnumeral(word)) {
    return word;
  }
  var singulars = this.singulars, length = singulars.length, tuple, regex, i;
  for (i = 0; i < length; i++) {
    tuple = singulars[i];
    regex = tuple[0];
    if (regex == word || regex.test && regex.test(word)) {
      return word.replace(regex, tuple[1]);
    }
  }
  return word;
}, classify:function(word) {
  return Ext.String.capitalize(this.singularize(word));
}, ordinalize:function(number) {
  var parsed = parseInt(number, 10), mod10 = parsed % 10, mod100 = parsed % 100;
  if (11 <= mod100 && mod100 <= 13) {
    return number + 'th';
  } else {
    switch(mod10) {
      case 1:
        return number + 'st';
      case 2:
        return number + 'nd';
      case 3:
        return number + 'rd';
      default:
        return number + 'th';
    }
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Inflector'], function() {
  var irregulars = {alumnus:'alumni', cactus:'cacti', focus:'foci', nucleus:'nuclei', radius:'radii', stimulus:'stimuli', ellipsis:'ellipses', paralysis:'paralyses', oasis:'oases', appendix:'appendices', index:'indexes', beau:'beaux', bureau:'bureaux', tableau:'tableaux', woman:'women', child:'children', man:'men', corpus:'corpora', criterion:'criteria', curriculum:'curricula', genus:'genera', memorandum:'memoranda', phenomenon:'phenomena', foot:'feet', goose:'geese', tooth:'teeth', antenna:'antennae', 
  formula:'formulae', nebula:'nebulae', vertebra:'vertebrae', vita:'vitae'}, singular;
  for (singular in irregulars) {
    if (irregulars.hasOwnProperty(singular)) {
      this.plural(singular, irregulars[singular]);
      this.singular(irregulars[singular], singular);
    }
  }
});
Ext.cmd.derive('Ext.data.schema.Namer', Ext.Base, {isNamer:true, capitalize:function(name) {
  return Ext.String.capitalize(name);
}, fieldRole:function(name) {
  var match = name.match(this.endsWithIdRe, '');
  if (match) {
    name = name.substr(0, name.length - (match[1] || match[2]).length);
  }
  return this.apply('uncapitalize', name);
}, idField:function(name) {
  return this.apply('uncapitalize,singularize', name) + 'Id';
}, instanceName:function(roleName) {
  return this.apply('underscore', roleName);
}, multiRole:function(name) {
  return this.apply('undotted,uncapitalize,pluralize', name);
}, pluralize:function(name) {
  return Ext.util.Inflector.pluralize(name);
}, readerRoot:function(roleName) {
  return this.apply('uncapitalize', roleName);
}, singularize:function(name) {
  return Ext.util.Inflector.singularize(name);
}, storeName:function(roleName) {
  return this.apply('underscore', roleName);
}, uncapitalize:function(name) {
  return Ext.String.uncapitalize(name);
}, underscore:function(name) {
  return '_' + name;
}, uniRole:function(name) {
  return this.apply('undotted,uncapitalize,singularize', name);
}, undotted:function(name) {
  if (name.indexOf('.') < 0) {
    return name;
  }
  var parts = name.split('.'), index = parts.length;
  while (index-- > 1) {
    parts[index] = this.apply('capitalize', parts[index]);
  }
  return parts.join('');
}, getterName:function(role) {
  var name = role.role;
  if (role && role.isMany) {
    return name;
  }
  return 'get' + this.apply('capitalize', name);
}, inverseFieldRole:function(leftType, unique, rightRole, rightType) {
  var me = this, leftRole = me.apply(unique ? 'uniRole' : 'multiRole', leftType), s1 = me.apply('pluralize', rightRole), s2 = me.apply('undotted,pluralize', rightType);
  if (s1.toLowerCase() !== s2.toLowerCase()) {
    leftRole = rightRole + me.apply('capitalize', leftRole);
  }
  return leftRole;
}, manyToMany:function(relation, leftType, rightType) {
  var me = this, ret = me.apply('undotted,capitalize,singularize', leftType) + me.apply('undotted,capitalize,pluralize', rightType);
  if (relation) {
    ret = me.apply('capitalize', relation + ret);
  }
  return ret;
}, manyToOne:function(leftType, leftRole, rightType, rightRole) {
  return this.apply('capitalize,singularize', rightType) + this.apply('capitalize', leftRole);
}, matrixRole:function(relation, entityType) {
  var ret = this.apply(relation ? 'multiRole,capitalize' : 'multiRole', entityType);
  return relation ? relation + ret : ret;
}, oneToOne:function(leftType, leftRole, rightType, rightRole) {
  return this.apply('undotted,capitalize,singularize', rightType) + this.apply('capitalize', leftRole);
}, setterName:function(role) {
  return 'set' + this.apply('capitalize', role.role);
}, endsWithIdRe:/(?:(_id)|[^A-Z](Id))$/, cache:{}, apply:function(operation, name) {
  var me = this, cache = me.cache, entry = cache[name] || (cache[name] = {}), ret = entry[operation], i, length, operations;
  if (!ret) {
    if (operation.indexOf(',') < 0) {
      ret = me[operation](name);
    } else {
      length = (operations = operation.split(',')).length;
      ret = name;
      for (i = 0; i < length; ++i) {
        ret = me.apply(operations[i], ret);
      }
    }
    entry[operation] = ret;
  }
  return ret;
}}, 0, 0, 0, 0, ['namer.default'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.schema, 'Namer'], 0);
Ext.cmd.derive('Ext.data.schema.Schema', Ext.Base, {aliasPrefix:'schema.', isSchema:true, type:'default', statics:{instances:{}, get:function(config) {
  var Schema = this, cache = Schema.instances, id = 'default', isString = config && Ext.isString(config), instance, newConfig;
  if (config) {
    if (config.isSchema) {
      return config;
    }
    id = isString ? config : config.id || id;
  }
  if (!(instance = cache[id])) {
    cache[id] = instance = Schema.create(config);
    instance.id = id;
  } else {
    if (config && !isString) {
      newConfig = Ext.merge({}, instance.config);
      Ext.merge(newConfig, config);
      instance.setConfig(newConfig);
      instance.config = newConfig;
    }
  }
  return instance;
}, lookupEntity:function(entity) {
  var ret = null, instances = this.instances, match, name, schema;
  if (entity) {
    if (entity.isEntity) {
      ret = entity.self;
    } else {
      if (Ext.isFunction(entity)) {
        ret = entity;
      } else {
        if (Ext.isString(entity)) {
          ret = Ext.ClassManager.get(entity);
          if (ret && (!ret.prototype || !ret.prototype.isEntity)) {
            ret = null;
          }
          if (!ret) {
            for (name in instances) {
              schema = instances[name];
              match = schema.getEntity(entity);
              if (match) {
                if (ret) {
                  Ext.raise('Ambiguous entity name "' + entity + '". Defined by schema "' + ret.schema.type + '" and "' + name + '"');
                }
                ret = match;
              }
            }
          }
          if (!ret) {
            Ext.raise('No such Entity "' + entity + '".');
          }
        }
      }
    }
  }
  return ret;
}}, assocCount:0, entityCount:0, config:{defaultIdentifier:null, keyCheckDelay:10, namer:'default', namespace:null, proxy:{type:'ajax', url:'{prefix}/{entityName}'}, urlPrefix:''}, onClassExtended:function(cls, data) {
  var alias = data.alias;
  if (alias && !data.type) {
    if (!Ext.isString(alias)) {
      alias = alias[0];
    }
    cls.prototype.type = alias.substring(this.prototype.aliasPrefix.length);
  }
}, constructor:function(config) {
  this.initConfig(config);
  this.clear();
}, applyDefaultIdentifier:function(identifier) {
  return identifier && Ext.Factory.dataIdentifier(identifier);
}, applyNamer:function(namer) {
  var ret = Ext.data.schema.Namer.create(namer);
  ret.schema = this;
  return ret;
}, applyNamespace:function(namespace) {
  if (namespace) {
    var end = namespace.length - 1;
    if (namespace.charAt(end) !== '.') {
      namespace += '.';
    }
  }
  return namespace;
}, applyProxy:function(proxy) {
  return Ext.util.ObjectTemplate.create(proxy);
}, eachAssociation:function(fn, scope) {
  var associations = this.associations, name;
  for (name in associations) {
    if (associations.hasOwnProperty(name)) {
      if (fn.call(scope, name, associations[name]) === false) {
        break;
      }
    }
  }
}, eachEntity:function(fn, scope) {
  var entities = this.entities, name;
  for (name in entities) {
    if (entities.hasOwnProperty(name)) {
      if (fn.call(scope, name, entities[name].cls) === false) {
        break;
      }
    }
  }
}, getAssociation:function(name) {
  var entry = this.associations[name];
  return entry || null;
}, getEntity:function(name) {
  var entry = this.entityClasses[name] || this.entities[name];
  return entry && entry.cls || null;
}, getEntityName:function(cls) {
  var ns = this.getNamespace(), index, name;
  if (typeof cls === 'string') {
    name = cls;
  } else {
    name = cls.$className || null;
  }
  if (name) {
    if (ns) {
      index = ns.length;
      if (name.substring(0, index) !== ns) {
        return name;
      }
    }
    if (index) {
      name = name.substring(index);
    }
  }
  return name;
}, hasAssociations:function(name) {
  name = name.entityName || name;
  return !!this.associationEntityMap[name];
}, hasEntity:function(entity) {
  var name = this.getEntityName(entity);
  return !!(this.entities[name] || this.entityClasses[name]);
}, addMatrix:function(entityType, matrixName, relation, left, right) {
  var me = this, namer = me.getNamer(), associations = me.associations, entities = me.entities, leftType = left.type, rightType = right.type, leftField = left.field || namer.apply('idField', leftType), rightField = right.field || namer.apply('idField', rightType), leftRole = left.role || namer.matrixRole(relation, leftType), rightRole = right.role || namer.matrixRole(relation, rightType), matrix, leftEntry, rightEntry;
  leftEntry = entities[leftType] || (entities[leftType] = {cls:null, name:leftType, associations:{}});
  rightEntry = entities[rightType] || (entities[rightType] = {cls:null, name:rightType, associations:{}});
  ++me.assocCount;
  associations[matrixName] = matrix = new Ext.data.schema.ManyToMany({name:matrixName, schema:me, definedBy:entityType, left:{cls:leftEntry.cls, type:leftType, role:leftRole, field:leftField, associationKey:left.associationKey}, right:{cls:rightEntry.cls, type:rightType, role:rightRole, field:rightField, associationKey:right.associationKey}});
  leftEntry.associations[matrix.right.role] = matrix.right;
  rightEntry.associations[matrix.left.role] = matrix.left;
  if (leftEntry.cls) {
    me.associationEntityMap[leftEntry.cls.entityName] = true;
  }
  if (rightEntry.cls) {
    me.associationEntityMap[rightEntry.cls.entityName] = true;
  }
  me.decorateModel(matrix);
}, addReference:function(entityType, referenceField, descr, unique, dupeCheck) {
  var me = this, namer = me.getNamer(), entities = me.entities, associations = me.associations, entityName = entityType.entityName, association = descr.association, child = descr.child, parent = descr.parent, rightRole = descr.role, rightType = descr.type || parent || child, leftVal = descr.inverse, left = Ext.isString(leftVal) ? {role:leftVal} : leftVal, leftRole = left && left.role, entry, T;
  if (!rightRole) {
    if (!referenceField || descr.legacy) {
      rightRole = namer.apply('uncapitalize', rightType);
    } else {
      rightRole = namer.apply('fieldRole', referenceField.name);
    }
  }
  if (!leftRole) {
    leftRole = namer.inverseFieldRole(entityName, unique, rightRole, rightType);
  }
  if (!association) {
    if (unique) {
      association = namer.oneToOne(entityType, leftRole, rightType, rightRole);
    } else {
      association = namer.manyToOne(entityType, leftRole, rightType, rightRole);
    }
  }
  if (dupeCheck && association in associations) {
    if (dupeCheck(associations[association], association, leftRole, rightRole) !== false) {
      return;
    }
  }
  entry = entities[rightType] || (entities[rightType] = {cls:null, name:rightType, associations:{}});
  T = unique ? Ext.data.schema.OneToOne : Ext.data.schema.ManyToOne;
  association = new T({name:association, owner:child ? 'left' : parent ? 'right' : null, definedBy:entityType, schema:me, field:referenceField, nullable:referenceField ? !!referenceField.allowBlank : true, left:{cls:entityType, type:entityName, role:leftRole, extra:left}, right:{cls:entry.cls, type:rightType, role:rightRole, extra:descr}, meta:descr});
  entityType.associations[rightRole] = association.right;
  entry.associations[leftRole] = association.left;
  if (referenceField) {
    referenceField.reference = association.right;
    entityType.references.push(referenceField);
  }
  ++me.assocCount;
  me.associationEntityMap[entityName] = true;
  if (entry.cls) {
    me.associationEntityMap[entry.cls.entityName] = true;
  }
  associations[association.name] = association;
  if (association.right.cls) {
    me.decorateModel(association);
  }
}, privates:{addEntity:function(entityType) {
  var me = this, entities = me.entities, entityName = entityType.entityName, entry = entities[entityName], fields = entityType.fields, associations, field, i, length, name;
  if (!entry) {
    entities[entityName] = entry = {name:entityName, associations:{}};
  } else {
    associations = entry.associations;
    for (name in associations) {
      associations[name].inverse.cls = entityType;
      me.associationEntityMap[entityName] = true;
      me.decorateModel(associations[name].association);
    }
  }
  entry.cls = entityType;
  entityType.prototype.associations = entityType.associations = entry.associations;
  me.entityClasses[entityType.$className] = entry;
  ++me.entityCount;
  for (i = 0, length = fields.length; i < length; ++i) {
    field = fields[i];
    if (field.reference) {
      me.addReferenceDescr(entityType, field);
    }
  }
}, addMatrices:function(entityType, matrices) {
  var me = this, i, length, matrixName;
  if (Ext.isString(matrices)) {
    me.addMatrixDescr(entityType, null, matrices);
  } else {
    if (matrices[0]) {
      for (i = 0, length = matrices.length; i < length; ++i) {
        me.addMatrixDescr(entityType, null, matrices[i]);
      }
    } else {
      for (matrixName in matrices) {
        me.addMatrixDescr(entityType, matrixName, matrices[matrixName]);
      }
    }
  }
}, addMatrixDescr:function(entityType, matrixName, matrixDef) {
  var me = this, entityName = entityType.entityName, associations = me.associations, namer = me.getNamer(), left = matrixDef.left, right = matrixDef.right, last, relation;
  if (Ext.isString(matrixDef)) {
    if (matrixDef.charAt(0) === '#') {
      left = {type:entityName};
      right = {type:matrixDef.substring(1)};
    } else {
      if (matrixDef.charAt(last = matrixDef.length - 1) === '#') {
        left = {type:matrixDef.substring(0, last)};
        right = {type:entityName};
      } else {
        if (namer.apply('multiRole', entityName) < namer.apply('multiRole', matrixDef)) {
          left = {type:entityName};
          right = {type:matrixDef};
        } else {
          left = {type:matrixDef};
          right = {type:entityName};
        }
      }
    }
  } else {
    relation = matrixDef.relation;
    if (left || !right && namer.apply('multiRole', entityName) < namer.apply('multiRole', matrixDef.type)) {
      if (!left || left === true) {
        left = {type:entityName};
      } else {
        left = Ext.apply({type:entityName}, left);
      }
      right = matrixDef;
    } else {
      if (!right || right === true) {
        right = {type:entityName};
      } else {
        right = Ext.apply({type:entityName}, right);
      }
      left = matrixDef;
    }
  }
  if (!matrixName) {
    matrixName = namer.manyToMany(relation, left.type, right.type);
  }
  if (!(matrixName in associations)) {
    me.addMatrix(entityType, matrixName, relation, left, right);
  }
}, addReferenceDescr:function(entityType, referenceField) {
  var me = this, descr = referenceField.$reference;
  if (Ext.isString(descr)) {
    descr = {type:descr};
  } else {
    descr = Ext.apply({}, descr);
  }
  me.addReference(entityType, referenceField, descr, referenceField.unique);
}, addBelongsTo:function(entityType, assoc) {
  this.addKeylessSingle(entityType, assoc, false);
}, addHasOne:function(entityType, assoc) {
  this.addKeylessSingle(entityType, assoc, true);
}, addKeylessSingle:function(entityType, assoc, unique) {
  var foreignKey, referenceField;
  assoc = Ext.apply({}, this.checkLegacyAssociation(entityType, assoc));
  assoc.type = this.getEntityName(assoc.child || assoc.parent || assoc.type);
  foreignKey = assoc.foreignKey || assoc.type.toLowerCase() + '_id';
  referenceField = entityType.getField(foreignKey);
  assoc.fromSingle = true;
  if (referenceField) {
    referenceField.$reference = assoc;
    referenceField.unique = true;
    assoc.legacy = true;
  }
  this.addReference(entityType, referenceField, assoc, unique);
}, addHasMany:function(entityType, assoc) {
  var me = this, entities = me.entities, pending = me.pending, cls, name, referenceField, target, foreignKey, inverseOptions, child, declaredInverse;
  assoc = Ext.apply({}, this.checkLegacyAssociation(entityType, assoc));
  assoc.type = this.getEntityName(assoc.child || assoc.parent || assoc.type);
  name = assoc.type;
  target = entities[name];
  cls = target && target.cls;
  if (cls) {
    name = entityType.entityName;
    foreignKey = assoc.foreignKey || name.toLowerCase() + '_id';
    delete assoc.foreignKey;
    declaredInverse = Ext.apply({}, assoc.inverse);
    delete assoc.inverse;
    inverseOptions = Ext.apply({}, assoc);
    delete inverseOptions.type;
    assoc = Ext.apply({type:name, inverse:inverseOptions}, declaredInverse);
    child = inverseOptions.child;
    if (child) {
      delete inverseOptions.child;
      assoc.parent = name;
    }
    referenceField = cls.getField(foreignKey);
    if (referenceField) {
      referenceField.$reference = assoc;
      assoc.legacy = true;
    }
    me.addReference(cls, referenceField, assoc, false);
  } else {
    if (!pending[name]) {
      pending[name] = [];
    }
    pending[name].push([entityType, assoc]);
  }
}, checkLegacyAssociation:function(entityType, assoc) {
  if (Ext.isString(assoc)) {
    assoc = {type:assoc};
  } else {
    assoc = Ext.apply({}, assoc);
  }
  if (assoc.model) {
    assoc.type = assoc.model;
    delete assoc.model;
  }
  var name = assoc.associatedName || assoc.name;
  if (name) {
    delete assoc.associatedName;
    delete assoc.name;
    assoc.role = name;
  }
  return assoc;
}, afterKeylessAssociations:function(cls) {
  var pending = this.pending, name = cls.entityName, mine = pending[name], i, len;
  if (mine) {
    for (i = 0, len = mine.length; i < len; ++i) {
      this.addHasMany.apply(this, mine[i]);
    }
    delete pending[name];
  }
}, clear:function(clearNamespace) {
  var me = this, timer = me.timer;
  delete me.setConfig;
  if (timer) {
    window.clearTimeout(timer);
    me.timer = null;
  }
  me.associations = {};
  me.associationEntityMap = {};
  me.entities = {};
  me.entityClasses = {};
  me.pending = {};
  me.assocCount = me.entityCount = 0;
  if (clearNamespace) {
    me.setNamespace(null);
  }
}, constructProxy:function(Model) {
  var me = this, data = Ext.Object.chain(Model), proxy = me.getProxy();
  data.schema = me;
  data.prefix = me.getUrlPrefix();
  return proxy.apply(data);
}, applyDecoration:function(role) {
  var me = this, cls = role.inverse.cls, namer = me.getNamer(), getterName, setterName, proto;
  if (cls && !role.decorated) {
    role.decorated = true;
    proto = cls.prototype;
    if (!(getterName = role.getterName)) {
      role.getterName = getterName = namer.getterName(role);
    }
    proto[getterName] = role.createGetter();
    if (role.createSetter) {
      if (!(setterName = role.setterName)) {
        role.setterName = setterName = namer.setterName(role);
      }
      proto[setterName] = role.createSetter();
    }
  }
}, decorateModel:function(association) {
  this.applyDecoration(association.left);
  this.applyDecoration(association.right);
}, processKeyChecks:function(processAll) {
  var me = this, keyCheckQueue = me.keyCheckQueue, timer = me.timer, len, i, item;
  if (timer) {
    window.clearTimeout(timer);
    me.timer = null;
  }
  if (!keyCheckQueue) {
    return;
  }
  do {
    keyCheckQueue = me.keyCheckQueue;
    me.keyCheckQueue = [];
    for (i = 0, len = keyCheckQueue.length; i < len; ++i) {
      item = keyCheckQueue[i];
      item.role.checkKeyForDrop(item.record);
    }
  } while (processAll && me.keyCheckQueue.length);
}, queueKeyCheck:function(record, role) {
  var me = this, keyCheckQueue = me.keyCheckQueue, timer = me.timer;
  if (!keyCheckQueue) {
    me.keyCheckQueue = keyCheckQueue = [];
  }
  keyCheckQueue.push({record:record, role:role});
  if (!timer) {
    me.timer = timer = Ext.defer(me.processKeyChecks, me.getKeyCheckDelay(), me);
  }
}, rankEntities:function() {
  var me = this, entities = me.entities, entityNames = Ext.Object.getKeys(entities), length = entityNames.length, entityType, i;
  me.nextRank = 1;
  entityNames.sort();
  for (i = 0; i < length; ++i) {
    entityType = entities[entityNames[i]].cls;
    if (!entityType.rank) {
      me.rankEntity(entityType);
    }
  }
}, rankEntity:function(entityType) {
  var associations = entityType.associations, associatedType, role, roleName;
  for (roleName in associations) {
    role = associations[roleName];
    if (!role.left && role.association.field) {
      associatedType = role.cls;
      if (!associatedType.rank) {
        this.rankEntity(associatedType);
      }
    }
  }
  entityType.rank = this.nextRank++;
}}}, 1, 0, 0, 0, ['schema.default'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.schema, 'Schema'], 0);
Ext.cmd.derive('Ext.data.AbstractStore', Ext.Base, {factoryConfig:{defaultType:'store', type:'store'}, $configPrefixed:false, $configStrict:false, config:{filters:null, autoDestroy:undefined, storeId:null, statefulFilters:false, sorters:null, remoteSort:{lazy:true, $value:false}, remoteFilter:{lazy:true, $value:false}, groupField:undefined, groupDir:'ASC', grouper:null, pageSize:25, autoSort:null, reloadOnClearSorters:false}, currentPage:1, loading:false, isStore:true, updating:0, constructor:function(config) {
  var me = this, storeId;
  me.isInitializing = true;
  me.mixins.observable.constructor.call(me, config);
  me.isInitializing = false;
  storeId = me.getStoreId();
  if (!storeId && (config && config.id)) {
    me.setStoreId(storeId = config.id);
  }
  if (storeId) {
    Ext.data.StoreManager.register(me);
  }
}, createActiveRange:function(config) {
  var range = Ext.apply({store:this}, config);
  return new Ext.data.Range(range);
}, syncActiveRanges:function() {
  var activeRanges = this.activeRanges, len = activeRanges && activeRanges.length, i;
  for (i = 0; i < len; i++) {
    activeRanges[i].refresh();
  }
}, getCount:function() {
  var data = this.getData();
  return data ? data.getCount() : 0;
}, rangeCached:function(start, end) {
  return this.getData().getCount() >= Math.max(start, end);
}, find:function(property, value, startIndex, anyMatch, caseSensitive, exactMatch) {
  var startsWith = !anyMatch, endsWith = !!(startsWith && exactMatch);
  return this.getData().findIndex(property, value, startIndex, startsWith, endsWith, !caseSensitive);
}, findRecord:function() {
  var me = this, index = me.find.apply(me, arguments);
  return index !== -1 ? me.getAt(index) : null;
}, findExact:function(fieldName, value, startIndex) {
  return this.getData().findIndexBy(function(rec) {
    return rec.isEqual(rec.get(fieldName), value);
  }, this, startIndex);
}, findBy:function(fn, scope, start) {
  return this.getData().findIndexBy(fn, scope, start);
}, getAt:function(index) {
  return this.getData().getAt(index) || null;
}, getRange:function(start, end, options) {
  var result = this.getData().getRange(start, Ext.isNumber(end) ? end + 1 : end);
  if (options && options.callback) {
    options.callback.call(options.scope || this, result, start, end, options);
  }
  return result;
}, getFilters:function(autoCreate) {
  var result = (arguments.callee.$previous || Ext.Base.prototype.getFilters).call(this);
  if (!result && autoCreate !== false) {
    this.setFilters([]);
    result = (arguments.callee.$previous || Ext.Base.prototype.getFilters).call(this);
  }
  return result;
}, applyFilters:function(filters, filtersCollection) {
  var created;
  if (!filtersCollection) {
    filtersCollection = this.createFiltersCollection();
    created = true;
  }
  filtersCollection.add(filters);
  if (created) {
    this.onRemoteFilterSet(filtersCollection, this.getRemoteFilter());
  }
  return filtersCollection;
}, getSorters:function(autoCreate) {
  var result = (arguments.callee.$previous || Ext.Base.prototype.getSorters).call(this);
  if (!result && autoCreate !== false) {
    this.setSorters([]);
    result = (arguments.callee.$previous || Ext.Base.prototype.getSorters).call(this);
  }
  return result;
}, applySorters:function(sorters, sortersCollection) {
  var created;
  if (!sortersCollection) {
    sortersCollection = this.createSortersCollection();
    created = true;
  }
  sortersCollection.add(sorters);
  if (created) {
    this.onRemoteSortSet(sortersCollection, this.getRemoteSort());
  }
  return sortersCollection;
}, filter:function(filters, value, suppressEvent) {
  if (Ext.isString(filters)) {
    filters = {property:filters, value:value};
  }
  this.suppressNextFilter = !!suppressEvent;
  this.getFilters().add(filters);
  this.suppressNextFilter = false;
}, removeFilter:function(toRemove, suppressEvent) {
  var me = this, filters = me.getFilters();
  me.suppressNextFilter = !!suppressEvent;
  if (toRemove instanceof Ext.util.Filter) {
    filters.remove(toRemove);
  } else {
    filters.removeByKey(toRemove);
  }
  me.suppressNextFilter = false;
}, updateAutoSort:function(autoSort) {
  this.getData().setAutoSort(autoSort);
}, updateRemoteSort:function(remoteSort) {
  this.onRemoteSortSet(this.getSorters(false), remoteSort);
}, updateRemoteFilter:function(remoteFilter) {
  this.onRemoteFilterSet(this.getFilters(false), remoteFilter);
}, addFilter:function(filters, suppressEvent) {
  this.suppressNextFilter = !!suppressEvent;
  this.getFilters().add(filters);
  this.suppressNextFilter = false;
}, filterBy:function(fn, scope) {
  this.getFilters().add({filterFn:fn, scope:scope || this});
}, clearFilter:function(suppressEvent) {
  var me = this, filters = me.getFilters(false);
  if (!filters || filters.getCount() === 0) {
    return;
  }
  me.suppressNextFilter = !!suppressEvent;
  filters.removeAll();
  me.suppressNextFilter = false;
}, isFiltered:function() {
  return this.getFilters().getCount() > 0;
}, isSorted:function() {
  var sorters = this.getSorters(false);
  return !!(sorters && sorters.length > 0) || this.isGrouped();
}, addFieldTransform:function(sorter) {
  if (sorter.getTransform()) {
    return;
  }
  var fieldName = sorter.getProperty(), Model = this.getModel(), field, sortType;
  if (Model) {
    field = Model.getField(fieldName);
    sortType = field ? field.getSortType() : null;
  }
  if (sortType && sortType !== Ext.identityFn) {
    sorter.setTransform(sortType);
  }
}, beginUpdate:function() {
  if (!this.updating++ && this.hasListeners.beginupdate) {
    this.fireEvent('beginupdate');
  }
}, endUpdate:function() {
  if (this.updating && !--this.updating) {
    if (this.hasListeners.endupdate) {
      this.fireEvent('endupdate');
    }
    this.onEndUpdate();
  }
}, getState:function() {
  var me = this, sorters = [], filters = me.getFilters(), grouper = me.getGrouper(), filterState, hasState, result;
  me.getSorters().each(function(s) {
    sorters[sorters.length] = s.getState();
    hasState = true;
  });
  if (me.statefulFilters && me.saveStatefulFilters) {
    hasState = true;
    filterState = [];
    filters.each(function(f) {
      filterState[filterState.length] = f.getState();
    });
  }
  if (grouper) {
    hasState = true;
  }
  if (hasState) {
    result = {};
    if (sorters.length) {
      result.sorters = sorters;
    }
    if (filterState) {
      result.filters = filterState;
    }
    if (grouper) {
      result.grouper = grouper.getState();
    }
  }
  return result;
}, applyState:function(state) {
  var me = this, stateSorters = state.sorters, stateFilters = state.filters, stateGrouper = state.grouper;
  if (stateSorters) {
    me.getSorters().replaceAll(stateSorters);
  }
  if (stateFilters) {
    me.saveStatefulFilters = true;
    me.getFilters().replaceAll(stateFilters);
  }
  if (stateGrouper) {
    me.setGrouper(stateGrouper);
  }
}, hasPendingLoad:Ext.emptyFn, isLoaded:Ext.emptyFn, isLoading:Ext.emptyFn, destroy:function() {
  var me = this;
  if (me.hasListeners.beforedestroy) {
    me.fireEvent('beforedestroy', me);
  }
  me.destroying = true;
  if (me.getStoreId()) {
    Ext.data.StoreManager.unregister(me);
  }
  me.doDestroy();
  if (me.hasListeners.destroy) {
    me.fireEvent('destroy', me);
  }
  me.destroying = false;
  me.callParent();
}, doDestroy:Ext.emptyFn, sort:function(field, direction, mode) {
  var me = this;
  if (arguments.length === 0) {
    if (me.getRemoteSort()) {
      me.load();
    } else {
      me.forceLocalSort();
    }
  } else {
    me.getSorters().addSort(field, direction, mode);
  }
}, onBeforeCollectionSort:function(store, sorters) {
  if (sorters) {
    this.fireEvent('beforesort', this, sorters.getRange());
  }
}, onSorterEndUpdate:function() {
  var me = this, fireSort = true, sorters = me.getSorters(false), sorterCount;
  if (me.settingGroups || !sorters) {
    return;
  }
  sorters = sorters.getRange();
  sorterCount = sorters.length;
  if (me.getRemoteSort()) {
    if (sorters.length || me.getReloadOnClearSorters()) {
      fireSort = false;
      me.load({callback:function() {
        me.fireEvent('sort', me, sorters);
      }});
    }
  } else {
    if (sorterCount) {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
    }
  }
  if (fireSort) {
    me.fireEvent('sort', me, sorters);
  }
}, onFilterEndUpdate:function() {
  var me = this, suppressNext = me.suppressNextFilter, filters = me.getFilters(false);
  if (!filters) {
    return;
  }
  if (me.getRemoteFilter()) {
    me.currentPage = 1;
    if (!suppressNext) {
      me.load();
    }
  } else {
    if (!suppressNext) {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
    }
  }
  if (me.trackStateChanges) {
    me.saveStatefulFilters = true;
  }
  me.fireEvent('filterchange', me, me.getFilters().getRange());
}, updateGroupField:function(field) {
  if (field) {
    this.setGrouper({property:field, direction:this.getGroupDir()});
  } else {
    this.setGrouper(null);
  }
}, getGrouper:function() {
  return this.getData().getGrouper();
}, group:function(grouper, direction) {
  var me = this, sorters = me.getSorters(false), change = grouper || sorters && sorters.length, data = me.getData();
  if (grouper && typeof grouper === 'string') {
    grouper = {property:grouper, direction:direction || me.getGroupDir()};
  }
  me.settingGroups = true;
  if (grouper === data.getGrouper()) {
    data.updateGrouper(grouper);
  } else {
    data.setGrouper(grouper);
  }
  delete me.settingGroups;
  if (change) {
    if (me.getRemoteSort()) {
      if (!me.isInitializing) {
        me.load({scope:me, callback:me.fireGroupChange});
      }
    } else {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
      me.fireGroupChange();
    }
  } else {
    me.fireGroupChange();
  }
}, fireGroupChange:function() {
  if (!this.destroyed) {
    this.fireEvent('groupchange', this, this.getGrouper());
  }
}, clearGrouping:function() {
  this.group(null);
}, getGroupField:function() {
  var grouper = this.getGrouper(), group = '';
  if (grouper) {
    group = grouper.getProperty();
  }
  return group;
}, isGrouped:function() {
  return !!this.getGrouper();
}, applyGrouper:function(grouper) {
  this.group(grouper);
  return this.getData().getGrouper();
}, getGroups:function() {
  return this.getData().getGroups();
}, onEndUpdate:Ext.emptyFn, privates:{_metaProperties:{count:'getCount', first:'first', last:'last', loading:'hasPendingLoad', totalCount:'getTotalCount'}, interpret:function(name) {
  var me = this, accessor = me._metaProperties[name];
  return accessor && me[accessor]();
}, loadsSynchronously:Ext.privateFn, onRemoteFilterSet:function(filters, remoteFilter) {
  if (filters) {
    filters[remoteFilter ? 'on' : 'un']('endupdate', 'onFilterEndUpdate', this);
  }
}, onRemoteSortSet:function(sorters, remoteSort) {
  var me = this, data;
  if (sorters) {
    sorters[remoteSort ? 'on' : 'un']('endupdate', 'onSorterEndUpdate', me);
    data = me.getData();
    if (data) {
      data[remoteSort ? 'un' : 'on']('beforesort', 'onBeforeCollectionSort', me);
    }
  }
}}, deprecated:{5:{methods:{destroyStore:function() {
  this.destroy();
}}}}}, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable], [Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data, 'AbstractStore'], 0);
Ext.cmd.derive('Ext.data.Error', Ext.Base, {isError:true, $configPrefixed:false, config:{field:null, message:''}, constructor:function(config) {
  this.initConfig(config);
  this.msg = this.message;
}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'Error'], 0);
Ext.cmd.derive('Ext.data.ErrorCollection', Ext.util.MixedCollection, {alternateClassName:'Ext.data.Errors', init:function(record) {
  var me = this, fields = record.fields, data = record.data, before, field, item, i, len, msg, val, name;
  for (i = 0, len = fields.length; i < len; ++i) {
    field = fields[i];
    name = field.name;
    val = data[name];
    if (field.validate && !field.validate.$nullFn) {
      before = me.length;
      msg = field.validate(val, null, me, record);
      if (before === me.length && msg !== true) {
        me.add(name, msg);
      }
    }
  }
  return me;
}, add:function(key, value) {
  var me = this, defaultMessage = Ext.data.field.Field.defaultInvalidMessage, obj = key, current;
  if (Ext.isString(key)) {
    obj = new Ext.data.Error({field:key, message:value || defaultMessage});
  } else {
    if (!obj.isError) {
      obj = new Ext.data.Error({field:obj.field || obj.name, message:obj.error || obj.message || obj.msg || defaultMessage});
    }
    key = obj.field;
  }
  current = me.get(key);
  if (current) {
    if (Ext.isArray(current)) {
      current.push(obj);
      return current;
    }
    me.removeAtKey(key);
    obj = [current, obj];
    obj.field = key;
    obj = [obj];
  }
  return Ext.util.MixedCollection.prototype.add.call(this, obj);
}, getKey:function(item) {
  return item.field;
}, isValid:function() {
  return this.length === 0;
}, getByField:function(fieldName) {
  var values = this.get(fieldName);
  if (values && !Ext.isArray(values)) {
    values = [values];
  }
  return values || [];
}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'ErrorCollection', Ext.data, 'Errors'], 0);
Ext.cmd.derive('Ext.data.operation.Operation', Ext.Base, {alternateClassName:'Ext.data.Operation', isOperation:true, config:{synchronous:false, url:'', params:undefined, callback:undefined, scope:undefined, resultSet:null, response:null, request:null, records:null, id:undefined, proxy:null, batch:null, recordCreator:null, internalCallback:null, internalScope:null}, order:0, foreignKeyDirection:1, started:false, running:false, complete:false, success:undefined, exception:false, error:undefined, idPrefix:'ext-operation-', 
constructor:function(config) {
  var scope = config && config.scope;
  this.initConfig(config);
  if (config) {
    config.scope = scope;
  }
  if (scope) {
    this.setScope(scope);
    this.initialConfig.scope = scope;
  }
  this._internalId = Ext.id(this, this.idPrefix);
}, getAction:function() {
  return this.action;
}, execute:function() {
  var me = this, request;
  delete me.error;
  delete me.success;
  me.complete = me.exception = false;
  me.setStarted();
  me.request = request = me.doExecute();
  if (request) {
    request.setOperation(me);
  }
  return request;
}, doExecute:Ext.emptyFn, abort:function() {
  var me = this, request = me.request;
  if (me.running && request) {
    me.getProxy().abort(request);
    me.request = null;
  }
}, process:function(resultSet, request, response, autoComplete) {
  var me = this;
  autoComplete = autoComplete !== false;
  me.setResponse(response);
  me.setResultSet(resultSet);
  if (resultSet.getSuccess()) {
    me.doProcess(resultSet, request, response);
    me.setSuccessful(autoComplete);
  } else {
    if (autoComplete) {
      me.setException(resultSet.getMessage());
    }
  }
}, _commitSetOptions:{convert:true, commit:true}, doProcess:function(resultSet, request, response) {
  var me = this, commitSetOptions = me._commitSetOptions, clientRecords = me.getRecords(), clientLen = clientRecords.length, clientIdProperty = clientRecords[0].clientIdProperty, serverRecords = resultSet.getRecords(), serverLen = serverRecords ? serverRecords.length : 0, clientMap, serverRecord, clientRecord, i;
  if (serverLen && clientIdProperty) {
    clientMap = Ext.Array.toValueMap(clientRecords, 'id');
    for (i = 0; i < serverLen; ++i) {
      serverRecord = serverRecords[i];
      clientRecord = clientMap[serverRecord[clientIdProperty]];
      if (clientRecord) {
        delete clientMap[clientRecord.id];
        delete serverRecord[clientIdProperty];
        clientRecord.set(serverRecord, commitSetOptions);
      }
    }
    for (i in clientMap) {
      clientMap[i].commit();
    }
  } else {
    for (i = 0; i < clientLen; ++i) {
      clientRecord = clientRecords[i];
      if (serverLen === 0 || !(serverRecord = serverRecords[i])) {
        clientRecord.commit();
      } else {
        clientRecord.set(serverRecord, commitSetOptions);
      }
    }
  }
}, setStarted:function() {
  this.started = this.running = true;
}, setCompleted:function() {
  var me = this, proxy = me.getProxy();
  me.complete = true;
  me.running = false;
  me.triggerCallbacks();
  if (proxy && !proxy.destroyed) {
    proxy.completeOperation(me);
  }
}, setSuccessful:function(complete) {
  this.success = true;
  if (complete) {
    this.setCompleted();
  }
}, setException:function(error) {
  var me = this;
  me.exception = true;
  me.success = me.running = false;
  me.error = error;
  me.setCompleted();
}, triggerCallbacks:function() {
  var me = this, callback = me.getInternalCallback();
  if (callback) {
    callback.call(me.getInternalScope() || me, me);
    me.setInternalCallback(null);
    me.setInternalScope(null);
  }
  if (callback = me.getCallback()) {
    callback.call(me.getScope() || me, me.getRecords(), me, me.wasSuccessful());
    me.setCallback(null);
    me.setScope(null);
  }
}, hasException:function() {
  return this.exception;
}, getError:function() {
  return this.error;
}, getRecords:function() {
  var resultSet;
  return this._records || ((resultSet = this.getResultSet()) ? resultSet.getRecords() : null);
}, isStarted:function() {
  return this.started;
}, isRunning:function() {
  return this.running;
}, isComplete:function() {
  return this.complete;
}, wasSuccessful:function() {
  return this.isComplete() && this.success === true;
}, allowWrite:function() {
  return true;
}}, 1, 0, 0, 0, 0, 0, [Ext.data.operation, 'Operation', Ext.data, 'Operation'], 0);
Ext.cmd.derive('Ext.data.operation.Create', Ext.data.operation.Operation, {action:'create', isCreateOperation:true, order:10, config:{recordCreator:Ext.identityFn}, doExecute:function() {
  return this.getProxy().create(this);
}}, 0, 0, 0, 0, ['data.operation.create'], 0, [Ext.data.operation, 'Create'], 0);
Ext.cmd.derive('Ext.data.operation.Destroy', Ext.data.operation.Operation, {action:'destroy', isDestroyOperation:true, order:30, foreignKeyDirection:-1, doProcess:function() {
  var clientRecords = this.getRecords(), clientLen = clientRecords.length, i;
  for (i = 0; i < clientLen; ++i) {
    clientRecords[i].setErased();
  }
}, doExecute:function() {
  return this.getProxy().erase(this);
}, getRecordData:function(record, operation) {
  var data = {}, idField = record.idField, nameProperty = this.getNameProperty() || 'name';
  data[idField[nameProperty]] = record.id;
  return data;
}}, 0, 0, 0, 0, ['data.operation.destroy'], 0, [Ext.data.operation, 'Destroy'], 0);
Ext.cmd.derive('Ext.data.operation.Read', Ext.data.operation.Operation, {action:'read', isReadOperation:true, config:{filters:undefined, sorters:undefined, grouper:undefined, start:undefined, limit:undefined, page:undefined, addRecords:false}, doExecute:function() {
  return this.getProxy().read(this);
}, doProcess:Ext.emptyFn, allowWrite:function() {
  return false;
}}, 0, 0, 0, 0, ['data.operation.read'], 0, [Ext.data.operation, 'Read'], 0);
Ext.cmd.derive('Ext.data.operation.Update', Ext.data.operation.Operation, {action:'update', isUpdateOperation:true, order:20, config:{recordCreator:Ext.identityFn}, doExecute:function() {
  return this.getProxy().update(this);
}}, 0, 0, 0, 0, ['data.operation.update'], 0, [Ext.data.operation, 'Update'], 0);
Ext.cmd.derive('Ext.data.SortTypes', Ext.Base, function() {
  var me;
  return {singleton:true, constructor:function() {
    me = this;
  }, none:Ext.identityFn, stripCommasRe:/,/g, stripTagsRE:/<\/?[^>]+>/gi, asText:function(s) {
    return s != null ? String(s).replace(me.stripTagsRE, '') : '\x00';
  }, asUCText:function(s) {
    return s != null ? String(s).toUpperCase().replace(me.stripTagsRE, '') : '\x00';
  }, asUCString:function(s) {
    return s != null ? String(s).toUpperCase() : '\x00';
  }, asDate:function(s) {
    if (!s) {
      return 0;
    }
    if (Ext.isDate(s)) {
      return s.getTime();
    }
    return Date.parse(String(s));
  }, asFloat:function(s) {
    var val = parseFloat(String(s).replace(me.stripCommasRe, ''));
    return isNaN(val) ? 0 : val;
  }, asInt:function(s) {
    var val = parseInt(String(s).replace(me.stripCommasRe, ''), 10);
    return isNaN(val) ? 0 : val;
  }};
}, 1, 0, 0, 0, 0, 0, [Ext.data, 'SortTypes'], 0);
Ext.cmd.derive('Ext.data.validator.Validator', Ext.Base, {isValidator:true, factoryConfig:{cacheable:true}, type:'base', constructor:function(config) {
  if (typeof config === 'function') {
    this.fnOnly = true;
    this.validate = config;
  } else {
    this.initConfig(config);
  }
}, validate:function() {
  return true;
}, clone:function() {
  var me = this;
  if (me.fnOnly) {
    return new Ext.data.validator.Validator(me.validate);
  }
  return new me.self(me.getCurrentConfig());
}}, 1, 0, 0, 0, ['data.validator.base'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.validator, 'Validator'], function(Validator) {
  Ext.Factory.validator = Ext.Factory.dataValidator;
});
Ext.cmd.derive('Ext.data.field.Field', Ext.Base, {alternateClassName:'Ext.data.Field', aliasPrefix:'data.field.', type:'auto', factoryConfig:{defaultProperty:'name'}, isDataField:true, isField:true, allowBlank:true, allowNull:false, critical:false, defaultInvalidMessage:'This field is invalid', defaultValue:undefined, definedBy:null, depends:null, dependents:null, mapping:null, name:null, ordinal:undefined, persist:null, reference:null, summary:null, summaryField:'', unique:false, rank:null, stripRe:/[\$,%]/g, 
calculated:false, evil:false, identifier:false, onClassExtended:function(cls, data) {
  var sortType = data.sortType, proto = cls.prototype, superValidators = proto.validators, validators = data.validators;
  if (sortType && Ext.isString(sortType)) {
    proto.sortType = Ext.data.SortTypes[sortType];
  }
  if (validators) {
    if (!Ext.isArray(validators)) {
      validators = [validators];
    }
    delete data.validators;
    if (superValidators) {
      validators = superValidators.concat(validators);
    }
    proto.validators = validators;
  }
}, argumentNamesRe:/^function\s*\(\s*([^,\)\s]+)/, calculateRe:/[^\.a-z0-9_]([a-z_][a-z_0-9]*)\.([a-z_][a-z_0-9]*)/gi, constructor:function(config) {
  var me = this, calculateRe = me.calculateRe, calculate, calculated, defaultValue, sortType, depends, map, match, dataProp, str, fld, validators;
  if (config) {
    if (Ext.isString(config)) {
      me.name = config;
    } else {
      validators = config.validators;
      if (validators) {
        delete config.validators;
        me.instanceValidators = validators;
      }
      Ext.apply(me, config);
    }
  }
  if (!me.allowNull) {
    me.allowNull = !!me.reference;
  }
  calculate = me.calculate;
  depends = me.depends;
  if (calculate) {
    me.convert = me.doCalculate;
    if (!depends) {
      if (!(depends = calculate.$depends)) {
        map = {};
        str = Ext.Function.toCode(calculate);
        calculate.$depends = depends = [];
        match = me.argumentNamesRe.exec(str);
        dataProp = match ? match[1] : 'data';
        while (match = calculateRe.exec(str)) {
          if (dataProp === match[1] && !map[fld = match[2]]) {
            map[fld] = 1;
            depends.push(fld);
          }
        }
      }
      me.depends = depends;
    }
  }
  defaultValue = me.defaultValue;
  if (me.convert) {
    me.calculated = calculated = me.convert.length > 1;
    me.evil = calculated && !depends;
  }
  if (me.persist === null) {
    me.persist = !calculate;
  }
  sortType = me.sortType;
  if (!me.sortType) {
    me.sortType = Ext.data.SortTypes.none;
  } else {
    if (Ext.isString(sortType)) {
      me.sortType = Ext.data.SortTypes[sortType];
    }
  }
  if (depends && typeof depends === 'string') {
    me.depends = [depends];
  }
  me.cloneDefaultValue = defaultValue !== undefined && (Ext.isDate(defaultValue) || Ext.isArray(defaultValue) || Ext.isObject(defaultValue));
}, setModelValidators:function(modelValidators) {
  this._validators = null;
  this.modelValidators = modelValidators;
}, constructValidators:function(validators) {
  if (validators) {
    if (!(validators instanceof Array)) {
      validators = [validators];
    }
    var length = validators.length, all = this._validators, i, item, validator, presence;
    for (i = 0; i < length; ++i) {
      item = validators[i];
      if (item.fn) {
        item = item.fn;
      }
      validator = Ext.Factory.dataValidator(item);
      if (!validator.isPresence) {
        all.push(validator);
      } else {
        presence = validator;
      }
    }
    if (presence) {
      this.presence = [presence];
    }
  }
}, collate:function(value1, value2) {
  var me = this, lhs = value1, rhs = value2;
  if (me.sortType) {
    lhs = me.sortType(lhs);
    rhs = me.sortType(rhs);
  }
  return lhs === rhs ? 0 : lhs < rhs ? -1 : 1;
}, compare:function(value1, value2) {
  return value1 === value2 ? 0 : value1 < value2 ? -1 : 1;
}, isEqual:function(value1, value2) {
  return this.compare(value1, value2) === 0;
}, convert:null, serialize:null, validate:function(value, separator, errors, record) {
  var me = this, validators = me.getValidators(), result, presence;
  presence = this.presence;
  if (presence && (value == null || value === '')) {
    result = me.validateGroup(presence, value, separator, errors, record);
    if (result !== true) {
      return result;
    }
  }
  return me.validateGroup(validators, value, separator, errors, record);
}, validateGroup:function(validators, value, separator, errors, record) {
  var ret = '', validator, length, i, result;
  for (i = 0, length = validators.length; i < length; ++i) {
    validator = validators[i];
    result = validator.validate(value, record);
    if (result !== true) {
      result = result || this.defaultInvalidMessage;
      if (errors) {
        if (errors.isMixedCollection) {
          errors.add(this.name, result);
        } else {
          if (errors.isCollection) {
            errors.add(result);
          } else {
            errors.push(result);
          }
        }
        ret = ret || result;
      } else {
        if (separator) {
          if (ret) {
            ret += separator;
          }
          ret += result;
        } else {
          ret = result;
          break;
        }
      }
    }
  }
  return ret || true;
}, doCalculate:function(v, rec) {
  return rec ? this.calculate(rec.data) : v;
}, getName:function() {
  return this.name;
}, getAllowBlank:function() {
  return this.allowBlank;
}, getAllowNull:function() {
  return this.allowNull;
}, getConvert:function() {
  return this.convert;
}, getDefaultValue:function() {
  return this.defaultValue;
}, getDepends:function() {
  return this.depends;
}, getMapping:function() {
  return this.mapping;
}, hasMapping:function() {
  var map = this.mapping;
  return !!(map || map === 0);
}, getPersist:function() {
  return this.persist;
}, getSortType:function() {
  return this.sortType;
}, getSummary:function() {
  var me = this, doneSummary = me.doneSummary, summary = me.summary;
  if (!doneSummary) {
    me.doneSummary = true;
    if (summary) {
      me.summary = summary = Ext.Factory.dataSummary(summary);
    }
  }
  return summary || null;
}, getType:function() {
  return 'auto';
}, privates:{getValidators:function() {
  var me = this, validators = me._validators;
  if (!validators) {
    me._validators = validators = [];
    me.constructValidators(me.validators);
    me.constructValidators(me.modelValidators);
    me.constructValidators(me.instanceValidators);
  }
  return validators;
}}, deprecated:{'5.1':{methods:{getSortDir:function() {
  return this.sortDir;
}}}}}, 1, 0, 0, 0, ['data.field.auto'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.field, 'Field', Ext.data, 'Field'], 0);
Ext.cmd.derive('Ext.data.field.Boolean', Ext.data.field.Field, {isBooleanField:true, trueRe:/^\s*(?:true|yes|on|1)\s*$/i, convert:function(v) {
  if (typeof v === 'boolean') {
    return v;
  }
  if (this.allowNull && (v === undefined || v === null || v === '')) {
    return null;
  }
  return this.trueRe.test(String(v));
}, getType:function() {
  return 'bool';
}}, 0, 0, 0, 0, ['data.field.bool', 'data.field.boolean'], 0, [Ext.data.field, 'Boolean'], 0);
Ext.cmd.derive('Ext.data.field.Date', Ext.data.field.Field, {sortType:'asDate', isDateField:true, dateFormat:null, dateReadFormat:null, dateWriteFormat:null, compare:function(lhs, rhs) {
  var lhsIsDate = lhs instanceof Date, rhsIsDate = rhs instanceof Date, result;
  if (rhsIsDate && lhsIsDate) {
    result = lhs.getTime() - rhs.getTime();
    if (result === 0) {
      result = 0;
    } else {
      result = result < 0 ? -1 : 1;
    }
  } else {
    if (lhsIsDate === rhsIsDate) {
      result = 0;
    } else {
      result = lhsIsDate ? 1 : -1;
    }
  }
  return result;
}, convert:function(v) {
  if (!v) {
    return null;
  }
  if (v instanceof Date) {
    return v;
  }
  var dateFormat = this.dateReadFormat || this.dateFormat, parsed;
  if (dateFormat) {
    return Ext.Date.parse(v, dateFormat, this.useStrict);
  }
  parsed = Date.parse(v);
  return parsed ? new Date(parsed) : null;
}, serialize:function(value) {
  var result = null, format;
  if (Ext.isDate(value)) {
    format = this.getDateWriteFormat();
    result = format ? Ext.Date.format(value, format) : value;
  }
  return result;
}, getDateFormat:function() {
  return this.dateFormat;
}, getDateReadFormat:function() {
  return this.dateReadFormat;
}, getDateWriteFormat:function() {
  var me = this;
  if (me.hasOwnProperty('dateWriteFormat')) {
    return me.dateWriteFormat;
  }
  if (me.hasOwnProperty('dateFormat')) {
    return me.dateFormat;
  }
  return me.dateWriteFormat || me.dateFormat || 'timestamp';
}, getType:function() {
  return 'date';
}}, 0, 0, 0, 0, ['data.field.date'], 0, [Ext.data.field, 'Date'], 0);
Ext.cmd.derive('Ext.data.field.Integer', Ext.data.field.Field, {isNumeric:true, isIntegerField:true, numericType:'int', convert:function(v) {
  if (typeof v === 'number') {
    return this.getNumber(v);
  }
  var empty = v == null || v === '', allowNull = this.allowNull, out;
  if (empty) {
    out = allowNull ? null : 0;
  } else {
    out = this.parse(v);
    if (allowNull && isNaN(out)) {
      out = null;
    }
  }
  return out;
}, getNumber:function(v) {
  return parseInt(v, 10);
}, getType:function() {
  return this.numericType;
}, parse:function(v) {
  return parseInt(String(v).replace(this.stripRe, ''), 10);
}, sortType:function(s) {
  if (s == null) {
    s = Infinity;
  }
  return s;
}}, 0, 0, 0, 0, ['data.field.int', 'data.field.integer'], 0, [Ext.data.field, 'Integer'], 0);
Ext.cmd.derive('Ext.data.field.Number', Ext.data.field.Integer, {isIntegerField:false, isNumberField:true, numericType:'float', getNumber:Ext.identityFn, parse:function(v) {
  return parseFloat(String(v).replace(this.stripRe, ''));
}}, 0, 0, 0, 0, ['data.field.float', 'data.field.number'], 0, [Ext.data.field, 'Number'], 0);
Ext.cmd.derive('Ext.data.field.String', Ext.data.field.Field, {sortType:'asUCString', isStringField:true, convert:function(v) {
  var defaultValue = this.allowNull ? null : '';
  return v === undefined || v === null ? defaultValue : String(v);
}, getType:function() {
  return 'string';
}}, 0, 0, 0, 0, ['data.field.string'], 0, [Ext.data.field, 'String'], 0);
Ext.cmd.derive('Ext.data.identifier.Generator', Ext.Base, {'abstract':true, factoryConfig:{defaultType:'sequential'}, isGenerator:true, config:{id:null}, constructor:function(config) {
  var me = this, id;
  me.initConfig(config);
  id = me.getId();
  if (id) {
    Ext.data.identifier.Generator.all[id] = me;
  }
}, privates:{clone:function(config) {
  var cfg = this.getInitialConfig();
  cfg = config ? Ext.apply({}, config, cfg) : cfg;
  return new this.self(cfg);
}, statics:{all:{}}}}, 1, 0, 0, 0, ['data.identifier.default'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.identifier, 'Generator'], function() {
  var Generator = this, Factory = Ext.Factory, factory = Factory.dataIdentifier;
  Factory.dataIdentifier = function(config) {
    var id = Ext.isString(config) ? config : config && config.id, existing = id && Generator.all[id];
    return existing || factory(config);
  };
});
Ext.cmd.derive('Ext.data.identifier.Sequential', Ext.data.identifier.Generator, {config:{increment:1, prefix:null, seed:1}, generate:function() {
  var me = this, seed = me._seed, prefix = me._prefix;
  me._seed += me._increment;
  return prefix !== null ? prefix + seed : seed;
}}, 0, 0, 0, 0, ['data.identifier.sequential'], 0, [Ext.data.identifier, 'Sequential'], 0);
Ext.cmd.derive('Ext.data.Model', Ext.Base, {alternateClassName:'Ext.data.Record', isEntity:true, isModel:true, validIdRe:null, erasing:false, loadOperation:null, loadCount:0, observableType:'record', crudState:'R', crudStateWas:null, constructor:function(data, session) {
  var me = this, cls = me.self, identifier = cls.identifier, Model = Ext.data.Model, modelIdentifier = Model.identifier, idProperty = me.idField.name, array, id, initializeFn, internalId, len, i, fields;
  me.data = me.data = data || (data = {});
  me.internalId = internalId = modelIdentifier.generate();
  if ((array = data) instanceof Array) {
    me.data = data = {};
    fields = me.getFields();
    len = Math.min(fields.length, array.length);
    for (i = 0; i < len; ++i) {
      data[fields[i].name] = array[i];
    }
  }
  if (!(initializeFn = cls.initializeFn)) {
    cls.initializeFn = initializeFn = Model.makeInitializeFn(cls);
  }
  if (!initializeFn.$nullFn) {
    cls.initializeFn(me);
  }
  if (!me.isSummaryModel) {
    if (!(me.id = id = data[idProperty]) && id !== 0) {
      if (session) {
        identifier = session.getIdentifier(cls);
        id = identifier.generate();
      } else {
        if (modelIdentifier === identifier) {
          id = internalId;
        } else {
          id = identifier.generate();
        }
      }
      data[idProperty] = me.id = id;
      me.phantom = true;
      me.crudState = 'C';
    }
    if (session) {
      session.add(me);
    }
    if (me.phantom) {
      me.crudStateWas = 'C';
    }
  }
  if (me.init && Ext.isFunction(me.init)) {
    me.init();
  }
}, editing:false, dirty:false, session:null, dropped:false, erased:false, clientIdProperty:null, evented:false, phantom:false, idProperty:'id', manyToMany:null, identifier:null, previousValues:undefined, proxy:undefined, schema:'default', summary:null, versionProperty:null, generation:1, validationSeparator:null, convertOnSet:true, beginEdit:function() {
  var me = this, modified = me.modified, previousValues = me.previousValues;
  if (!me.editing) {
    me.editing = true;
    me.editMemento = {dirty:me.dirty, data:Ext.apply({}, me.data), generation:me.generation, modified:modified && Ext.apply({}, modified), previousValues:previousValues && Ext.apply({}, previousValues)};
  }
}, calculateSummary:function(records) {
  var fields = this.getFields(), len = fields.length, recLen = records.length, i, result, summary, prop, name, field;
  for (i = 0; i < len; ++i) {
    field = fields[i];
    summary = field.getSummary();
    if (summary) {
      result = result || {};
      name = field.name;
      prop = field.summaryField || name;
      result[name] = summary.calculate(records, prop, 'data', 0, recLen);
    }
  }
  if (result) {
    this.set(result, this._commitOptions);
  }
}, cancelEdit:function() {
  var me = this, editMemento = me.editMemento, validation = me.validation;
  if (editMemento) {
    me.editing = false;
    Ext.apply(me, editMemento);
    me.editMemento = null;
    if (validation && validation.syncGeneration !== me.generation) {
      validation.syncGeneration = 0;
    }
  }
}, endEdit:function(silent, modifiedFieldNames) {
  var me = this, editMemento = me.editMemento;
  if (editMemento) {
    me.editing = false;
    me.editMemento = null;
    me.previousValues = editMemento.previousValues;
    if (!silent) {
      if (!modifiedFieldNames) {
        modifiedFieldNames = me.getModifiedFieldNames(editMemento.data);
      }
      if (me.dirty || modifiedFieldNames && modifiedFieldNames.length) {
        me.callJoined('afterEdit', [modifiedFieldNames]);
      }
    }
  }
}, getField:function(name) {
  return this.self.getField(name);
}, getFields:function() {
  return this.self.getFields();
}, getFieldsMap:function() {
  return this.fieldsMap;
}, getIdProperty:function() {
  return this.idProperty;
}, getId:function() {
  return this.id;
}, getObservableId:function() {
  return this.internalId;
}, setId:function(id, options) {
  this.set(this.idProperty, id, options);
}, getPrevious:function(fieldName) {
  var previousValues = this.previousValues;
  return previousValues && previousValues[fieldName];
}, isModified:function(fieldName) {
  var modified = this.modified;
  return !!(modified && modified.hasOwnProperty(fieldName));
}, getModified:function(fieldName) {
  var out;
  if (this.isModified(fieldName)) {
    out = this.modified[fieldName];
  }
  return out;
}, get:function(fieldName) {
  return this.data[fieldName];
}, _singleProp:{}, _rejectOptions:{convert:false, silent:true}, set:function(fieldName, newValue, options) {
  var me = this, cls = me.self, data = me.data, modified = me.modified, prevVals = me.previousValues, session = me.session, single = Ext.isString(fieldName), opt = single ? options : newValue, convertOnSet = opt ? opt.convert !== false : me.convertOnSet, fieldsMap = me.fieldsMap, silent = opt && opt.silent, commit = opt && opt.commit, updateRefs = !(opt && opt.refs === false) && session, dirty = !(opt && opt.dirty === false && !commit), modifiedFieldNames = null, dirtyRank = 0, associations = me.associations, 
  currentValue, field, idChanged, key, name, oldId, comparator, dep, dependents, i, numFields, newId, rankedFields, reference, value, values, roleName;
  if (single) {
    values = me._singleProp;
    values[fieldName] = newValue;
  } else {
    values = fieldName;
  }
  if (!(rankedFields = cls.rankedFields)) {
    rankedFields = cls.rankFields();
  }
  numFields = rankedFields.length;
  do {
    for (name in values) {
      value = values[name];
      currentValue = data[name];
      comparator = me;
      field = fieldsMap[name];
      if (field) {
        if (convertOnSet && field.convert) {
          value = field.convert(value, me);
        }
        comparator = field;
        reference = field.reference;
      } else {
        reference = null;
      }
      if (comparator.isEqual(currentValue, value)) {
        continue;
      }
      data[name] = value;
      (modifiedFieldNames || (modifiedFieldNames = [])).push(name);
      (prevVals || (me.previousValues = prevVals = {}))[name] = currentValue;
      if (reference && reference.cls) {
        if (updateRefs) {
          session.updateReference(me, field, value, currentValue);
        }
        reference.onValueChange(me, session, value, currentValue);
      }
      i = (dependents = field && field.dependents) && dependents.length;
      while (i-- > 0) {
        (dep = dependents[i]).dirty = true;
        dirtyRank = dirtyRank ? Math.min(dirtyRank, dep.rank) : dep.rank;
      }
      if (!field || field.persist) {
        if (modified && modified.hasOwnProperty(name)) {
          if (!dirty || comparator.isEqual(modified[name], value)) {
            delete modified[name];
            me.dirty = -1;
          }
        } else {
          if (dirty) {
            if (!modified) {
              me.modified = modified = {};
            }
            me.dirty = true;
            modified[name] = currentValue;
          }
        }
      }
      if (name === me.idField.name) {
        idChanged = true;
        oldId = currentValue;
        newId = value;
      }
    }
    if (!dirtyRank) {
      break;
    }
    field = rankedFields[dirtyRank - 1];
    field.dirty = false;
    if (single) {
      delete values[fieldName];
    } else {
      values = me._singleProp;
      single = true;
    }
    fieldName = field.name;
    values[fieldName] = data[fieldName];
    convertOnSet = true;
    for (; dirtyRank < numFields; ++dirtyRank) {
      if (rankedFields[dirtyRank].dirty) {
        break;
      }
    }
    if (dirtyRank < numFields) {
      ++dirtyRank;
    } else {
      dirtyRank = 0;
    }
  } while (1);
  if (me.dirty < 0) {
    me.dirty = false;
    for (key in modified) {
      if (modified.hasOwnProperty(key)) {
        me.dirty = true;
        break;
      }
    }
  }
  if (single) {
    delete values[fieldName];
  }
  ++me.generation;
  if (idChanged) {
    me.id = newId;
    me.onIdChanged(newId, oldId);
    me.callJoined('onIdChanged', [oldId, newId]);
    if (associations) {
      for (roleName in associations) {
        associations[roleName].onIdChanged(me, oldId, newId);
      }
    }
  }
  if (commit) {
    me.commit(silent, modifiedFieldNames);
  } else {
    if (!silent && !me.editing && modifiedFieldNames) {
      me.callJoined('afterEdit', [modifiedFieldNames]);
    }
  }
  return modifiedFieldNames;
}, reject:function(silent) {
  var me = this, modified = me.modified;
  if (modified) {
    me.set(modified, me._rejectOptions);
  }
  me.dropped = false;
  me.clearState();
  if (!silent) {
    me.callJoined('afterReject');
  }
}, commit:function(silent, modifiedFieldNames) {
  var me = this, versionProperty = me.versionProperty, data = me.data, erased;
  me.clearState();
  if (versionProperty && !me.phantom && !isNaN(data[versionProperty])) {
    ++data[versionProperty];
  }
  me.phantom = false;
  if (me.dropped) {
    me.erased = erased = true;
  }
  if (!silent) {
    if (erased) {
      me.callJoined('afterErase');
    } else {
      me.callJoined('afterCommit', [modifiedFieldNames]);
    }
  }
}, clearState:function() {
  var me = this;
  me.dirty = me.editing = false;
  me.editMemento = me.modified = null;
}, drop:function(cascade) {
  var me = this, associations = me.associations, session = me.session, roleName;
  if (me.erased || me.dropped) {
    return;
  }
  me.dropped = true;
  if (associations && cascade !== false) {
    for (roleName in associations) {
      associations[roleName].onDrop(me, session);
    }
  }
  me.callJoined('afterDrop');
  if (me.phantom) {
    me.setErased();
  }
}, join:function(owner) {
  var me = this, joined = me.joined;
  if (!joined) {
    joined = me.joined = [owner];
  } else {
    if (!joined.length) {
      joined[0] = owner;
    } else {
      Ext.Array.include(joined, owner);
    }
  }
  if (owner.isStore && !me.store) {
    me.store = owner;
  }
}, unjoin:function(owner) {
  var me = this, joined = me.joined, len = joined && joined.length, store = me.store, i;
  if (owner === me.session) {
    me.session = null;
  } else {
    if (len === 1 && joined[0] === owner) {
      joined.length = 0;
    } else {
      if (len) {
        Ext.Array.remove(joined, owner);
      }
    }
    if (store === owner) {
      store = null;
      if (joined) {
        for (i = 0, len = joined.length; i < len; ++i) {
          owner = joined[i];
          if (owner.isStore) {
            store = owner;
            break;
          }
        }
      }
      me.store = store;
    }
  }
}, clone:function(session) {
  var me = this, modified = me.modified, ret = me.copy(me.id, session);
  if (modified) {
    ret.modified = Ext.apply({}, modified);
  }
  ret.dirty = me.dirty;
  ret.dropped = me.dropped;
  ret.phantom = me.phantom;
  return ret;
}, copy:function(newId, session) {
  var me = this, data = Ext.apply({}, me.data), idProperty = me.idProperty, T = me.self;
  if (newId || newId === 0) {
    data[idProperty] = newId;
  } else {
    if (newId === null) {
      delete data[idProperty];
    }
  }
  return new T(data, session);
}, getProxy:function() {
  return this.self.getProxy();
}, getValidation:function(refresh) {
  var me = this, ret = me.validation;
  if (!ret) {
    me.validation = ret = new Ext.data.Validation;
    ret.attach(me);
  }
  if (refresh === true || refresh !== false && ret.syncGeneration !== me.generation) {
    ret.refresh(refresh);
  }
  return ret;
}, validate:function() {
  return (new Ext.data.ErrorCollection).init(this);
}, isValid:function() {
  return this.getValidation().isValid();
}, toUrl:function() {
  var pieces = this.$className.split('.'), name = pieces[pieces.length - 1].toLowerCase();
  return name + '/' + this.getId();
}, erase:function(options) {
  var me = this;
  me.erasing = true;
  me.drop();
  me.erasing = false;
  return me.save(options);
}, setErased:function() {
  this.erased = true;
  this.callJoined('afterErase');
}, getChanges:function() {
  return this.getData(this._getChangesOptions);
}, getCriticalFields:function() {
  var cls = this.self, ret = cls.criticalFields;
  if (!ret) {
    cls.rankFields();
    ret = cls.criticalFields;
  }
  return ret;
}, getAssociatedData:function(result, options) {
  var me = this, associations = me.associations, deep, i, item, items, itemData, length, record, role, roleName, opts, clear, associated;
  result = result || {};
  me.$gathering = 1;
  if (options) {
    options = Ext.apply({}, options);
  }
  for (roleName in associations) {
    role = associations[roleName];
    item = role.getAssociatedItem(me);
    if (!item || item.$gathering) {
      continue;
    }
    if (item.isStore) {
      item.$gathering = 1;
      items = item.getData().items;
      length = items.length;
      itemData = [];
      for (i = 0; i < length; ++i) {
        record = items[i];
        deep = !record.$gathering;
        record.$gathering = 1;
        if (options) {
          associated = options.associated;
          if (associated === undefined) {
            options.associated = deep;
            clear = true;
          } else {
            if (!deep) {
              options.associated = false;
              clear = true;
            }
          }
          opts = options;
        } else {
          opts = deep ? me._getAssociatedOptions : me._getNotAssociatedOptions;
        }
        itemData.push(record.getData(opts));
        if (clear) {
          options.associated = associated;
          clear = false;
        }
        delete record.$gathering;
      }
      delete item.$gathering;
    } else {
      opts = options || me._getAssociatedOptions;
      if (options && options.associated === undefined) {
        opts.associated = true;
      }
      itemData = item.getData(opts);
    }
    result[roleName] = itemData;
  }
  delete me.$gathering;
  return result;
}, getData:function(options) {
  var me = this, ret = {}, opts = options === true ? me._getAssociatedOptions : options || ret, data = me.data, associated = opts.associated, changes = opts.changes, critical = changes && opts.critical, content = changes ? me.modified : data, fieldsMap = me.fieldsMap, persist = opts.persist, serialize = opts.serialize, criticalFields, field, n, name, value;
  if (content) {
    for (name in content) {
      value = data[name];
      field = fieldsMap[name];
      if (field) {
        if (persist && !field.persist) {
          continue;
        }
        if (serialize && field.serialize) {
          value = field.serialize(value, me);
        }
      }
      ret[name] = value;
    }
  }
  if (critical) {
    criticalFields = me.self.criticalFields || me.getCriticalFields();
    for (n = criticalFields.length; n-- > 0;) {
      name = (field = criticalFields[n]).name;
      if (!(name in ret)) {
        value = data[name];
        if (serialize && field.serialize) {
          value = field.serialize(value, me);
        }
        ret[name] = value;
      }
    }
  }
  if (associated) {
    if (typeof associated === 'object') {
      me.getNestedData(opts, ret);
    } else {
      me.getAssociatedData(ret, opts);
    }
  }
  return ret;
}, getNestedData:function(options, result) {
  var me = this, associations = me.associations, graph = options.associated, i, item, items, itemData, length, record, role, roleName, opts;
  result = result || {};
  for (roleName in graph) {
    role = associations[roleName];
    opts = graph[roleName];
    if (opts === true) {
      delete options.associated;
    } else {
      options.associated = opts;
    }
    item = role.getAssociatedItem(me);
    if (item.isStore) {
      items = item.getData().items;
      length = items.length;
      itemData = [];
      for (i = 0; i < length; ++i) {
        record = items[i];
        itemData.push(record.getData(options));
      }
    } else {
      itemData = item.getData(options);
    }
    result[roleName] = itemData;
  }
  options.associated = graph;
  return result;
}, getTransientFields:function() {
  var cls = this.self, ret = cls.transientFields;
  if (!ret) {
    cls.rankFields();
    ret = cls.transientFields;
  }
  return ret;
}, isLoading:function() {
  return !!this.loadOperation;
}, abort:function() {
  var operation = this.loadOperation;
  if (operation) {
    operation.abort();
  }
}, load:function(options) {
  options = Ext.apply({}, options);
  var me = this, scope = options.scope || me, proxy = me.getProxy(), callback = options.callback, operation = me.loadOperation, id = me.getId(), extras;
  if (operation) {
    extras = operation.extraCalls;
    if (!extras) {
      extras = operation.extraCalls = [];
    }
    extras.push(options);
    return operation;
  }
  options.id = id;
  options.recordCreator = function(data, type, readOptions) {
    var session = me.session;
    if (readOptions) {
      readOptions.recordCreator = session ? session.recordCreator : null;
    }
    me.set(data, me._commitOptions);
    return me;
  };
  options.internalCallback = function(operation) {
    var success = operation.wasSuccessful() && operation.getRecords().length > 0, op = me.loadOperation, extras = op.extraCalls, successFailArgs = [me, operation], callbackArgs = [me, operation, success], i, len;
    me.loadOperation = null;
    ++me.loadCount;
    if (success) {
      Ext.callback(options.success, scope, successFailArgs);
    } else {
      Ext.callback(options.failure, scope, successFailArgs);
    }
    Ext.callback(callback, scope, callbackArgs);
    if (extras) {
      for (i = 0, len = extras.length; i < len; ++i) {
        options = extras[i];
        if (success) {
          Ext.callback(options.success, scope, successFailArgs);
        } else {
          Ext.callback(options.failure, scope, successFailArgs);
        }
        Ext.callback(options.callback, scope, callbackArgs);
      }
    }
    me.callJoined('afterLoad');
  };
  delete options.callback;
  me.loadOperation = operation = proxy.createOperation('read', options);
  operation.execute();
  return operation;
}, mergeData:function(data) {
  if (!this.dirty) {
    this.set(data, this._commitOptions);
  }
}, save:function(options) {
  options = Ext.apply({}, options);
  var me = this, phantom = me.phantom, dropped = me.dropped, action = dropped ? 'destroy' : phantom ? 'create' : 'update', scope = options.scope || me, callback = options.callback, proxy = me.getProxy(), operation;
  options.records = [me];
  options.internalCallback = function(operation) {
    var args = [me, operation], success = operation.wasSuccessful();
    if (success) {
      Ext.callback(options.success, scope, args);
    } else {
      Ext.callback(options.failure, scope, args);
    }
    args.push(success);
    Ext.callback(callback, scope, args);
  };
  delete options.callback;
  operation = proxy.createOperation(action, options);
  if (dropped && phantom) {
    operation.setResultSet(Ext.data.reader.Reader.prototype.nullResultSet);
    me.setErased();
    operation.setSuccessful(true);
  } else {
    operation.execute();
  }
  return operation;
}, statics:{defaultProxy:'memory'}, inheritableStatics:{_associatedReadOptions:{recordsOnly:true, asRoot:true}, loadData:function(data, session) {
  var rec;
  if (data) {
    rec = this.getProxy().getReader().readRecords([data], session ? {recordCreator:session.recordCreator} : undefined, this._associatedReadOptions)[0];
  } else {
    rec = new this(data, session);
  }
  return rec;
}, getSummaryModel:function() {
  var me = this, proto = me.prototype, summaryModel = me.summaryModel;
  if (!summaryModel) {
    summaryModel = Ext.define(null, {extend:me, fields:proto.summaryFields || [], isSummaryModel:true});
    summaryModel.isSummaryModel = true;
    me.summaryModel = proto.summaryModel = summaryModel;
  }
  return summaryModel || null;
}, addFields:function(newFields) {
  this.replaceFields(newFields);
}, replaceFields:function(newFields, removeFields) {
  var me = this, proto = me.prototype, Field = Ext.data.field.Field, fields = me.fields, fieldsMap = me.fieldsMap, ordinals = me.fieldOrdinals, field, i, idField, len, name, ordinal, cleared;
  if (removeFields === true) {
    fields.length = 0;
    me.fieldsMap = fieldsMap = {};
    me.fieldOrdinals = ordinals = {};
    cleared = true;
  } else {
    if (removeFields) {
      for (i = removeFields.length; i-- > 0;) {
        name = removeFields[i];
        if (name in ordinals) {
          delete ordinals[name];
          delete fieldsMap[name];
        }
      }
      for (i = 0, len = fields.length; i < len; ++i) {
        name = (field = fields[i]).name;
        if (name in ordinals) {
          ordinals[name] = i;
        } else {
          fields.splice(i, 1);
          --i;
          --len;
        }
      }
    }
  }
  for (i = 0, len = newFields ? newFields.length : 0; i < len; i++) {
    name = (field = newFields[i]).name;
    if (!(name in ordinals)) {
      ordinals[name] = ordinal = fields.length;
      fields.push(field = Field.create(field));
      fieldsMap[name] = field;
      field.ordinal = ordinal;
      field.definedBy = field.owner = this;
    }
  }
  if (!cleared) {
    for (i = 0, len = fields.length; i < len; ++i) {
      fields[i].rank = null;
    }
  }
  me.idField = proto.idField = idField = fieldsMap[proto.idProperty];
  idField.allowNull = idField.critical = idField.identifier = true;
  idField.defaultValue = null;
  me.initializeFn = me.rankedFields = me.transientFields = me.criticalFields = null;
}, removeFields:function(removeFields) {
  this.replaceFields(null, removeFields);
}, getIdFromData:function(data) {
  var T = this, idField = T.idField, id = idField.calculated ? (new T(data)).id : data[idField.name];
  return id;
}, createWithId:function(id, data, session) {
  var d = data, T = this;
  if (id || id === 0) {
    d = {};
    if (data) {
      Ext.apply(d, data);
    }
    d[T.idField.name] = id;
  }
  return new T(d, session);
}, getFields:function() {
  return this.fields;
}, getFieldsMap:function() {
  return this.fieldsMap;
}, getField:function(name) {
  return this.fieldsMap[name] || null;
}, getProxy:function() {
  var me = this, proxy = me.proxy, defaultProxy = me.defaultProxy, defaults;
  if (!proxy) {
    proxy = me.proxyConfig;
    if (!proxy && defaultProxy) {
      proxy = defaultProxy;
    }
    if (!proxy || !proxy.isProxy) {
      if (typeof proxy === 'string') {
        proxy = {type:proxy};
      }
      defaults = Ext.merge(me.schema.constructProxy(me), proxy);
      if (proxy && proxy.type) {
        proxy = proxy.schema === false ? proxy : defaults;
      } else {
        proxy = defaults;
      }
    }
    proxy = me.setProxy(proxy);
  }
  return proxy;
}, setProxy:function(proxy) {
  var me = this, model;
  if (proxy) {
    if (!proxy.isProxy) {
      proxy = Ext.Factory.proxy(proxy);
    } else {
      model = proxy.getModel();
      if (model && model !== me) {
        proxy = proxy.clone();
      }
    }
    proxy.setModel(me);
  }
  return me.prototype.proxy = me.proxy = proxy;
}, load:function(id, options, session) {
  var data = {}, rec;
  if (session) {
    rec = session.peekRecord(this, id);
  }
  if (!rec) {
    data[this.prototype.idProperty] = id;
    rec = new this(data, session);
  }
  rec.load(options);
  return rec;
}}, deprecated:{5:{methods:{hasId:null, markDirty:null, setDirty:null, eachStore:function(callback, scope) {
  var me = this, stores = me.stores, len = stores.length, i;
  for (i = 0; i < len; ++i) {
    callback.call(scope, stores[i]);
  }
}, join:function(item) {
  var me = this, stores = me.stores, joined = me.joined;
  if (!joined) {
    joined = me.joined = [item];
  } else {
    joined.push(item);
  }
  if (item.isStore) {
    me.store = me.store || item;
    if (!stores) {
      stores = me.stores = [];
    }
    stores.push(item);
  }
}, unjoin:function(item) {
  var me = this, stores = me.stores, joined = me.joined;
  if (joined.length === 1) {
    joined.length = 0;
  } else {
    Ext.Array.remove(joined, item);
  }
  if (item.isStore) {
    Ext.Array.remove(stores, item);
    me.store = stores[0] || null;
  }
}}, properties:{persistenceProperty:null}, inheritableStatics:{methods:{setFields:null}}}}, privates:{_commitOptions:{commit:true}, _getChangesOptions:{changes:true}, _getAssociatedOptions:{associated:true}, _getNotAssociatedOptions:{associated:false}, _metaProperties:{dirty:'isDirty', phantom:'isPhantom', valid:'isValid'}, copyFrom:function(sourceRecord) {
  var me = this, fields = me.fields, fieldCount = fields.length, modifiedFieldNames = [], field, i = 0, myData, sourceData, idProperty = me.idProperty, name, value;
  if (sourceRecord) {
    myData = me.data;
    sourceData = sourceRecord.data;
    for (; i < fieldCount; i++) {
      field = fields[i];
      name = field.name;
      if (name !== idProperty) {
        value = sourceData[name];
        if (value !== undefined && !me.isEqual(myData[name], value)) {
          myData[name] = value;
          modifiedFieldNames.push(name);
        }
      }
    }
    if (me.phantom && !sourceRecord.phantom) {
      me.beginEdit();
      me.setId(sourceRecord.getId());
      me.endEdit(true);
      me.commit(true);
    }
  }
  return modifiedFieldNames;
}, callJoined:function(funcName, args) {
  var me = this, joined = me.joined, session = me.session, state = me.dropped ? 'D' : me.phantom ? 'C' : me.dirty ? 'U' : 'R', i, len, fn, item;
  me.crudState = state;
  if (joined || session) {
    if (args) {
      args.unshift(me);
    } else {
      args = [me];
    }
    fn = session && session[funcName];
    if (fn) {
      fn.apply(session, args);
    }
    if (joined) {
      for (i = 0, len = joined.length; i < len; ++i) {
        item = joined[i];
        if (item && (fn = item[funcName])) {
          fn.apply(item, args);
        }
      }
    }
  }
  me.crudStateWas = state;
}, hasPendingLoad:function() {
  return this.isLoading();
}, interpret:function(name) {
  var me = this, accessor = me._metaProperties[name];
  if (!accessor) {
    accessor = me.associations;
    accessor = accessor && accessor[name] && accessor[name].getterName;
  }
  if (accessor) {
    return me[accessor]();
  }
  return me.data[name];
}, isDirty:function() {
  return this.dirty;
}, isPhantom:function() {
  return this.phantom;
}, onAssociatedRecordSet:function(record, role) {
  this.callJoined('afterAssociatedRecordSet', [record, role]);
}, onIdChanged:Ext.privateFn, setSession:function(session) {
  this.session = session;
  if (session) {
    session.add(this);
  }
}, getModifiedFieldNames:function(old) {
  var me = this, data = me.data, modified = [], oldData = old || me.editMemento.data, key;
  for (key in data) {
    if (data.hasOwnProperty(key)) {
      if (!me.isEqual(data[key], oldData[key], key)) {
        modified.push(key);
      }
    }
  }
  return modified;
}, isEqual:function(lhs, rhs, field) {
  var f;
  if (field) {
    f = field.isField ? field : this.fieldsMap[field];
    if (f) {
      return f.isEqual(lhs, rhs);
    }
  }
  if (lhs instanceof Date && rhs instanceof Date) {
    return lhs.getTime() === rhs.getTime();
  }
  return lhs === rhs;
}, statics:{EDIT:'edit', REJECT:'reject', COMMIT:'commit', rankFields:function() {
  var cls = this, prototype = cls.prototype, fields = cls.fields, length = fields.length, rankedFields = [], criticalFields = [], transientFields = [], evilFields, field, i;
  cls.rankedFields = prototype.rankedFields = rankedFields;
  cls.criticalFields = prototype.criticalFields = criticalFields;
  cls.transientFields = prototype.transientFields = transientFields;
  for (i = 0; i < length; ++i) {
    field = fields[i];
    if (field.critical) {
      criticalFields.push(field);
    }
    if (!field.persist) {
      transientFields.push(field);
    }
    if (field.evil) {
      (evilFields || (evilFields = [])).push(field);
    } else {
      if (!field.depends) {
        rankedFields.push(field);
        field.rank = rankedFields.length;
      }
    }
  }
  for (i = 0; i < length; ++i) {
    if (!(field = fields[i]).rank && !field.evil) {
      cls.topoAdd(field);
    }
  }
  if (evilFields) {
    for (i = 0, length = evilFields.length; i < length; ++i) {
      rankedFields.push(field = evilFields[i]);
      field.rank = rankedFields.length;
    }
  }
  return rankedFields;
}, topoAdd:function(field) {
  var cls = this, dep = field.depends, dependsLength = dep ? dep.length : 0, rankedFields = cls.rankedFields, i, targetField;
  for (i = 0; i < dependsLength; ++i) {
    targetField = cls.fieldsMap[dep[i]];
    (targetField.dependents || (targetField.dependents = [])).push(field);
    if (!targetField.rank) {
      cls.topoAdd(targetField);
    }
  }
  rankedFields.push(field);
  field.rank = rankedFields.length;
}, initFields:function(data, cls, proto) {
  var Field = Ext.data.field.Field, fieldDefs = data.fields, fields = [], fieldOrdinals = {}, fieldsMap = {}, references = [], superFields = proto.fields, versionProperty = data.versionProperty || proto.versionProperty, idProperty = cls.idProperty, idField, field, i, length, name, ordinal, reference, superIdField, superIdFieldName, idDeclared;
  cls.fields = proto.fields = fields;
  cls.fieldOrdinals = proto.fieldOrdinals = fieldOrdinals;
  cls.fieldsMap = proto.fieldsMap = fieldsMap;
  cls.references = proto.references = references;
  if (superFields) {
    for (i = 0, length = superFields.length; i < length; ++i) {
      fields[i] = field = Ext.Object.chain(superFields[i]);
      field.dependents = null;
      field.owner = cls;
      fieldOrdinals[name = field.name] = i;
      fieldsMap[name] = field;
      field.rank = null;
      if (field.generated) {
        superIdField = field;
        superIdFieldName = field.name;
      }
    }
  }
  delete data.fields;
  if (fieldDefs) {
    for (i = 0, length = fieldDefs.length; i < length; ++i) {
      field = fieldDefs[i];
      reference = field.reference;
      if (reference && typeof reference !== 'string') {
        reference = Ext.merge({}, reference);
      }
      field.$reference = reference;
      field = Field.create(fieldDefs[i]);
      name = field.name;
      ordinal = fieldOrdinals[name];
      if (ordinal === undefined) {
        fieldOrdinals[name] = ordinal = fields.length;
      }
      fieldsMap[name] = field;
      fields[ordinal] = field;
      field.definedBy = field.owner = cls;
      field.ordinal = ordinal;
      if (name === idProperty) {
        idDeclared = field;
      }
    }
  }
  idField = fieldsMap[idProperty];
  if (!idField) {
    if (superIdField && superIdField.generated) {
      ordinal = superIdField.ordinal;
    } else {
      ordinal = fields.length;
    }
    delete fieldsMap[superIdFieldName];
    delete fieldOrdinals[superIdFieldName];
    idField = new Field(idProperty);
    fields[ordinal] = idField;
    fieldOrdinals[idProperty] = ordinal;
    fieldsMap[idProperty] = idField;
    idField.definedBy = cls;
    idField.ordinal = ordinal;
    idField.generated = true;
  } else {
    if (idDeclared && superIdField && superIdField.generated) {
      Ext.Array.remove(fields, superIdField);
      delete fieldsMap[superIdFieldName];
      delete fieldOrdinals[superIdFieldName];
      fieldsMap[idProperty] = idDeclared;
      for (i = 0, length = fields.length; i < length; ++i) {
        field = fields[i];
        fields.ordinal = i;
        fieldOrdinals[field.name] = i;
      }
    }
  }
  idField.allowNull = idField.critical = idField.identifier = true;
  idField.defaultValue = null;
  cls.idField = proto.idField = idField;
  if (versionProperty) {
    field = fieldsMap[versionProperty];
    if (!field) {
      ordinal = fields.length;
      field = new Field({name:versionProperty, type:'int'});
      fields[ordinal] = field;
      fieldOrdinals[versionProperty] = ordinal;
      fieldsMap[versionProperty] = field;
      field.definedBy = cls;
      field.ordinal = ordinal;
      field.generated = true;
    }
    field.defaultValue = 1;
    field.critical = true;
  }
}, initSummaries:function(data, cls, proto) {
  var summaryDefs = data.summary, superSummaries = proto.summaryFields, summaries, summaryMap, name, summary, len, i, index, field;
  if (superSummaries) {
    summaries = [];
    summaryMap = {};
    for (i = 0, len = superSummaries.length; i < len; ++i) {
      summary = superSummaries[i];
      summaries.push(summary);
      summaries[summary.name] = i;
    }
  }
  if (summaryDefs) {
    delete data.summary;
    summaries = summaries || [];
    summaryMap = summaryMap || {};
    for (name in summaryDefs) {
      summary = summaryDefs[name];
      if (typeof summary === 'function') {
        summary = {summary:summary};
      }
      index = summaryMap[name];
      summary = Ext.apply({name:name}, summary);
      field = summary.field;
      if (field) {
        delete summary.field;
        summary.summaryField = field;
      }
      if (index === undefined) {
        index = summaries.length;
        summaryMap[name] = summary;
      }
      summaries[index] = summary;
    }
  }
  if (summaries) {
    proto.summaryFields = summaries;
  }
}, initValidators:function(data, cls, proto) {
  var superValidators = proto.validators, validators, field, copy, validatorDefs, i, length, fieldValidator, name, validator, item;
  if (superValidators) {
    validators = {};
    for (field in superValidators) {
      validators[field] = Ext.Array.clone(superValidators[field]);
    }
  }
  validatorDefs = data.validators || data.validations;
  if (validatorDefs) {
    delete data.validators;
    validators = validators || {};
    if (Ext.isArray(validatorDefs)) {
      copy = {};
      for (i = 0, length = validatorDefs.length; i < length; ++i) {
        item = validatorDefs[i];
        name = item.field;
        if (!copy[name]) {
          copy[name] = [];
        }
        item = item.fn || item;
        copy[name].push(item);
      }
      validatorDefs = copy;
    }
    for (name in validatorDefs) {
      fieldValidator = validatorDefs[name];
      if (!Ext.isArray(fieldValidator)) {
        fieldValidator = [fieldValidator];
      }
      validator = validators[name];
      if (validator) {
        Ext.Array.push(validator, fieldValidator);
      } else {
        validators[name] = fieldValidator;
      }
    }
  }
  if (validators) {
    for (name in validators) {
      field = cls.getField(name);
      if (field) {
        field.setModelValidators(validators[name]);
      }
    }
  }
  cls.validators = proto.validators = validators;
}, initAssociations:function(schema, data, cls) {
  var associations = data.associations, belongsTo = data.belongsTo, hasMany = data.hasMany, hasOne = data.hasOne, matrices = data.manyToMany, i, length, assoc, o;
  delete data.associations;
  delete data.belongsTo;
  delete data.hasMany;
  delete data.hasOne;
  delete data.manyToMany;
  if (matrices) {
    schema.addMatrices(cls, matrices);
  }
  if (associations) {
    associations = Ext.isArray(associations) ? associations : [associations];
    for (i = 0, length = associations.length; i < length; ++i) {
      assoc = associations[i];
      o = Ext.apply({}, assoc);
      delete o.type;
      switch(assoc.type) {
        case 'belongsTo':
          schema.addBelongsTo(cls, o);
          break;
        case 'hasMany':
          schema.addHasMany(cls, o);
          break;
        case 'hasOne':
          schema.addHasOne(cls, o);
          break;
      }
    }
  }
  if (belongsTo) {
    belongsTo = Ext.isArray(belongsTo) ? belongsTo : [belongsTo];
    for (i = 0, length = belongsTo.length; i < length; ++i) {
      schema.addBelongsTo(cls, belongsTo[i]);
    }
  }
  if (hasMany) {
    hasMany = Ext.isArray(hasMany) ? hasMany : [hasMany];
    for (i = 0, length = hasMany.length; i < length; ++i) {
      schema.addHasMany(cls, hasMany[i]);
    }
  }
  if (hasOne) {
    hasOne = Ext.isArray(hasOne) ? hasOne : [hasOne];
    for (i = 0, length = hasOne.length; i < length; ++i) {
      schema.addHasOne(cls, hasOne[i]);
    }
  }
  schema.afterKeylessAssociations(cls);
}, initIdentifier:function(data, cls, proto) {
  var identifier = data.identifier || data.idgen, superIdent = proto.identifier || cls.schema._defaultIdentifier, generatorPrefix;
  if (identifier) {
    delete data.identifier;
    delete data.idgen;
    identifier = Ext.Factory.dataIdentifier(identifier);
  } else {
    if (superIdent) {
      if (superIdent.clone && !superIdent.getId()) {
        identifier = superIdent.clone();
      } else {
        if (superIdent.isGenerator) {
          identifier = superIdent;
        } else {
          identifier = Ext.Factory.dataIdentifier(superIdent);
        }
      }
    }
  }
  cls.identifier = proto.identifier = identifier;
  if (!identifier) {
    generatorPrefix = cls.entityName;
    if (!generatorPrefix) {
      generatorPrefix = Ext.id(null, 'extModel');
    }
    cls.identifier = Ext.Factory.dataIdentifier({type:'sequential', prefix:generatorPrefix + '-'});
  }
}, findValidator:function(validators, name, cfg) {
  var type = cfg.type || cfg, field = validators[name], len, i, item;
  if (field) {
    for (i = 0, len = field.length; i < len; ++i) {
      item = field[i];
      if (item.type === type) {
        return item;
      }
    }
  }
  return null;
}, makeInitializeFn:function(cls) {
  var code = ['var '], body = ['\nreturn function (e) {\n    var data \x3d e.data, v;\n'], work = 0, bc, ec, convert, expr, factory, field, fields, fs, hasDefValue, i, length;
  if (!(fields = cls.rankedFields)) {
    fields = cls.rankFields();
  }
  for (i = 0, length = fields.length; i < length; ++i) {
    field = fields[i];
    fs = 'f' + i;
    convert = field.convert;
    if (i) {
      code.push(',  \n    ');
    }
    code.push(fs, ' \x3d $fields[' + i + ']');
    if ((hasDefValue = field.defaultValue !== undefined) || convert) {
      expr = 'data["' + field.name + '"]';
      ++work;
      bc = ec = '';
      if (field.cloneDefaultValue) {
        bc = 'Ext.clone(';
        ec = ')';
      }
      body.push('\n');
      if (convert && hasDefValue) {
        body.push('    v \x3d ', expr, ';\n    if (v !\x3d\x3d undefined) {\n        v \x3d ', fs, '.convert(v, e);\n    }\n    if (v \x3d\x3d\x3d undefined) {\n        v \x3d ', bc, fs, '.defaultValue', ec, ';\n    }\n    ', expr, ' \x3d v;');
      } else {
        if (convert) {
          body.push('    v \x3d ', fs, '.convert(', expr, ',e);\n    if (v !\x3d\x3d undefined) {\n        ', expr, ' \x3d v;\n    }\n');
        } else {
          if (hasDefValue) {
            body.push('    if (', expr, ' \x3d\x3d\x3d undefined) {\n        ', expr, ' \x3d ', bc, fs, '.defaultValue', ec, ';\n    }\n');
          }
        }
      }
    }
  }
  if (!work) {
    return Ext.emptyFn;
  }
  code.push(';\n');
  code.push.apply(code, body);
  code.push('}');
  code = code.join('');
  factory = new Function('$fields', 'Ext', code);
  return factory(fields, Ext);
}}}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'Model', Ext.data, 'Record'], function() {
  var Model = this, proto = Model.prototype, Schema = Ext.data.schema.Schema, defaultSchema;
  Model.proxyConfig = proto.proxy;
  delete proto.proxy;
  Model.fields = [];
  Model.fieldsMap = proto.fieldsMap = {};
  Model.schema = proto.schema = Schema.get(proto.schema);
  proto.idField = new Ext.data.field.Field(proto.idProperty);
  Model.identifier = new Ext.data.identifier.Sequential;
  Model.onExtended(function(cls, data) {
    var proto = cls.prototype, schemaName = data.schema, superCls = proto.superclass.self, schema, entityName, proxy;
    cls.idProperty = data.idProperty || proto.idProperty;
    if (schemaName) {
      delete data.schema;
      schema = Schema.get(schemaName);
    } else {
      if (!(schema = proto.schema)) {
        schema = defaultSchema || (defaultSchema = Schema.get('default'));
      }
    }
    cls.rankFields = Model.rankFields;
    cls.topoAdd = Model.topoAdd;
    proto.schema = cls.schema = schema;
    if (!(entityName = data.entityName)) {
      proto.entityName = entityName = schema.getEntityName(cls);
    }
    cls.entityName = entityName;
    cls.fieldExtractors = {};
    Model.initIdentifier(data, cls, proto);
    Model.initFields(data, cls, proto);
    Model.initValidators(data, cls, proto);
    if (!data.isSummaryModel) {
      Model.initSummaries(data, cls, proto);
    }
    cls.fields.items = cls.fields;
    if (entityName) {
      schema.addEntity(cls);
      Model.initAssociations(schema, data, cls);
    }
    proxy = data.proxy;
    if (proxy) {
      delete data.proxy;
    } else {
      if (superCls !== Model) {
        proxy = superCls.proxyConfig || superCls.proxy;
      }
    }
    cls.proxyConfig = proxy;
  });
});
Ext.cmd.derive('Ext.data.ResultSet', Ext.Base, {isResultSet:true, $configPrefixed:false, config:{loaded:true, count:null, total:null, remoteTotal:null, success:false, records:null, message:null, metadata:null, groupData:null, summaryData:null}, constructor:function(config) {
  this.initConfig(config);
}, getCount:function() {
  var count = (arguments.callee.$previous || Ext.Base.prototype.getCount).call(this), records;
  if (!count) {
    records = this.getRecords();
    if (records) {
      count = records.length;
    }
  }
  return count;
}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'ResultSet'], 0);
Ext.cmd.derive('Ext.data.reader.Reader', Ext.Base, {alternateClassName:['Ext.data.Reader', 'Ext.data.DataReader'], factoryConfig:{defaultType:null}, config:{groupRootProperty:'', implicitIncludes:true, keepRawData:null, messageProperty:'', model:null, proxy:null, readRecordsOnFailure:true, rootProperty:'', successProperty:'success', summaryRootProperty:'', totalProperty:'total', transform:null, typeProperty:''}, isReader:true, constructor:function(config) {
  if (config && config.hasOwnProperty('root')) {
    config = Ext.apply({}, config);
    config.rootProperty = config.root;
    delete config.root;
  }
  var me = this;
  me.duringInit = 1;
  me.mixins.observable.constructor.call(me, config);
  --me.duringInit;
  me.buildExtractors();
}, forceBuildExtractors:function() {
  if (!this.duringInit) {
    this.buildExtractors(true);
  }
}, updateGroupRootProperty:function() {
  this.forceBuildExtractors();
}, updateMessageProperty:function() {
  this.forceBuildExtractors();
}, applyModel:function(model) {
  return Ext.data.schema.Schema.lookupEntity(model);
}, updateSuccessProperty:function() {
  this.forceBuildExtractors();
}, updateTotalProperty:function() {
  this.forceBuildExtractors();
}, applyTransform:function(transform) {
  if (transform) {
    if (Ext.isFunction(transform)) {
      transform = {fn:transform};
    } else {
      if (transform.charAt) {
        transform = {fn:this[transform]};
      }
    }
    return transform.fn.bind(transform.scope || this);
  }
  return transform;
}, read:function(response, readOptions) {
  var data, result, responseText;
  if (response) {
    responseText = response.responseText;
    if (responseText) {
      result = this.getResponseData(response);
      if (result && result.__$isError) {
        return new Ext.data.ResultSet({total:0, count:0, records:[], success:false, message:result.msg});
      } else {
        data = this.readRecords(result, readOptions);
      }
    } else {
      if (responseText !== '') {
        data = this.readRecords(response, readOptions);
      }
    }
  }
  return data || this.nullResultSet;
}, getNullResultSet:function() {
  return this.nullResultSet;
}, createReadError:function(msg) {
  return {__$isError:true, msg:msg};
}, readRecords:function(data, readOptions, internalReadOptions) {
  var me = this, recordsOnly = internalReadOptions && internalReadOptions.recordsOnly, asRoot = internalReadOptions && internalReadOptions.asRoot, groupData = null, summaryData = null, success, recordCount, records, root, remoteTotal, total, value, message, transform, meta, summaryOptions;
  meta = me.getMeta ? me.getMeta(data) : data.metaData;
  if (meta) {
    me.onMetaChange(meta);
  }
  transform = me.getTransform();
  if (transform) {
    data = transform(data);
  }
  me.buildExtractors();
  if (me.getKeepRawData()) {
    me.rawData = data;
  }
  if (me.hasListeners.rawdata) {
    me.fireEventArgs('rawdata', [data]);
  }
  data = me.getData(data);
  success = true;
  recordCount = 0;
  records = [];
  if (me.getSuccessProperty()) {
    value = me.getSuccess(data);
    if (value === false || value === 'false') {
      success = false;
    }
  }
  if (me.getMessageProperty()) {
    message = me.getMessage(data);
  }
  if (success || me.getReadRecordsOnFailure()) {
    root = asRoot || Ext.isArray(data) ? data : me.getRoot(data);
    if (root) {
      total = root.length;
    }
    if (me.getTotalProperty()) {
      value = parseInt(me.getTotal(data), 10);
      if (!isNaN(value)) {
        remoteTotal = total = value;
      }
    }
    if (root) {
      records = me.extractData(root, readOptions);
      recordCount = records.length;
    }
    if (me.getGroupRootProperty()) {
      root = me.getGroupRoot(data);
      if (root) {
        summaryOptions = {includes:false, model:me.getModel().getSummaryModel()};
        groupData = me.extractData(root, summaryOptions) || null;
      }
    }
    if (me.getSummaryRootProperty()) {
      root = me.getSummaryRoot(data);
      if (root) {
        summaryOptions = summaryOptions || {includes:false, model:me.getModel().getSummaryModel()};
        summaryData = me.extractData(root, summaryOptions) || null;
        if (summaryData) {
          summaryData = summaryData[0];
        }
      }
    }
  }
  return recordsOnly ? records : new Ext.data.ResultSet({total:total || recordCount, remoteTotal:remoteTotal, metadata:meta, count:recordCount, records:records, success:success, message:message, groupData:groupData, summaryData:summaryData});
}, extractData:function(root, readOptions) {
  var me = this, entityType = readOptions && readOptions.model ? Ext.data.schema.Schema.lookupEntity(readOptions.model) : me.getModel(), schema = entityType.schema, includes = readOptions && 'includes' in readOptions ? readOptions.includes : schema.hasAssociations(entityType) && me.getImplicitIncludes(), fieldExtractorInfo = me.getFieldExtractorInfo(entityType), length = root.length, records = new Array(length), typeProperty = me.getTypeProperty(), reader, node, nodeType, record, i;
  if (!length && Ext.isObject(root)) {
    root = [root];
    length = 1;
  }
  for (i = 0; i < length; i++) {
    record = root[i];
    if (!record.isModel) {
      node = record;
      if (typeProperty && (nodeType = me.getChildType(schema, node, typeProperty))) {
        reader = nodeType.getProxy().getReader();
        record = reader.extractRecord(node, readOptions, nodeType, schema.hasAssociations(nodeType) && reader.getImplicitIncludes(), reader.getFieldExtractorInfo(nodeType));
      } else {
        record = me.extractRecord(node, readOptions, entityType, includes, fieldExtractorInfo);
      }
      if (record.isModel && record.isNode) {
        record.raw = node;
      }
    }
    if (record.onLoad) {
      record.onLoad();
    }
    records[i] = record;
  }
  return records;
}, getChildType:function(schema, rawNode, typeProperty) {
  var namespace;
  switch(typeof typeProperty) {
    case 'string':
      return schema.getEntity(rawNode[typeProperty]);
    case 'object':
      namespace = typeProperty.namespace;
      return schema.getEntity((namespace ? namespace + '.' : '') + rawNode[typeProperty.name]);
    case 'function':
      return schema.getEntity(typeProperty(rawNode));
  }
}, extractRecordData:function(node, readOptions) {
  var entityType = readOptions && readOptions.model ? Ext.data.schema.Schema.lookupEntity(readOptions.model) : this.getModel(), fieldExtractorInfo = this.getFieldExtractorInfo(entityType);
  return this.extractRecord(node, readOptions, entityType, false, fieldExtractorInfo);
}, extractRecord:function(node, readOptions, entityType, includes, fieldExtractorInfo) {
  var me = this, creatorFn = readOptions && readOptions.recordCreator || me.defaultRecordCreator, modelData, record;
  modelData = me.extractModelData(node, fieldExtractorInfo);
  record = creatorFn.call(me, modelData, entityType || me.getModel(), readOptions);
  if (includes && record.isModel) {
    me.readAssociated(record, node, readOptions);
  }
  return record;
}, getFieldExtractorInfo:function(entityType) {
  var extractors = entityType.fieldExtractors, type, extractor;
  if (!extractors) {
    return;
  }
  type = this.$className;
  extractor = extractors[type];
  if (extractor === undefined) {
    extractors[type] = extractor = this.buildFieldExtractors(entityType);
  }
  return extractor;
}, buildFieldExtractors:function(entityType) {
  var fields = entityType.getFields(), len = fields.length, buffer = [], extractors = [], out = null, cnt = 0, field, name, i, extractor;
  for (i = 0; i < len; ++i) {
    field = fields[i];
    extractor = this.createFieldAccessor(field);
    if (extractor) {
      name = field.name;
      buffer.push('val \x3d extractors[' + cnt + "](raw, self); if (val !\x3d\x3d undefined) { data['" + name + "'] \x3d val; }");
      extractors.push(extractor);
      ++cnt;
    }
  }
  if (buffer.length) {
    out = {extractors:extractors, fn:new Function('raw', 'data', 'extractors', 'self', 'var val;' + buffer.join('\n'))};
  }
  return out;
}, defaultRecordCreator:function(data, Model) {
  return new Model(data);
}, defaultRecordCreatorFromServer:function(data, Model) {
  var record = new Model(data);
  record.phantom = false;
  return record;
}, getModelData:function(raw) {
  return {};
}, extractModelData:function(raw, fieldExtractorInfo) {
  var data = this.getModelData(raw), fn;
  if (fieldExtractorInfo) {
    fn = fieldExtractorInfo.fn;
    fn(raw, data, fieldExtractorInfo.extractors, this);
  }
  return data;
}, readAssociated:function(record, data, readOptions) {
  var roles = record.associations, key, role;
  for (key in roles) {
    if (roles.hasOwnProperty(key)) {
      role = roles[key];
      if (role.cls) {
        role.read(record, data, this, readOptions);
      }
    }
  }
}, getData:Ext.identityFn, getRoot:Ext.identityFn, getResponseData:function(response) {
}, onMetaChange:function(meta) {
  var me = this, fields = meta.fields, model, newModel, clientIdProperty, proxy;
  me.metaData = meta;
  if (meta.root) {
    me.setRootProperty(meta.root);
  }
  if (meta.totalProperty) {
    me.setTotalProperty(meta.totalProperty);
  }
  if (meta.successProperty) {
    me.setSuccessProperty(meta.successProperty);
  }
  if (meta.messageProperty) {
    me.setMessageProperty(meta.messageProperty);
  }
  clientIdProperty = meta.clientIdProperty;
  if (fields) {
    newModel = Ext.define(null, {extend:'Ext.data.Model', fields:fields, clientIdProperty:clientIdProperty});
    me.setModel(newModel);
    proxy = me.getProxy();
    if (proxy) {
      proxy.setModel(newModel);
    }
  } else {
    if (clientIdProperty) {
      model = me.getModel();
      if (model) {
        model.self.prototype.clientIdProperty = clientIdProperty;
      }
    }
  }
}, buildExtractors:function(force) {
  var me = this, totalProp, successProp, messageProp;
  if (force || !me.hasExtractors) {
    totalProp = me.getTotalProperty();
    successProp = me.getSuccessProperty();
    messageProp = me.getMessageProperty();
    if (totalProp) {
      me.getTotal = me.getAccessor(totalProp);
    }
    if (successProp) {
      me.getSuccess = me.getAccessor(successProp);
    }
    if (messageProp) {
      me.getMessage = me.getAccessor(messageProp);
    }
    me.hasExtractors = true;
    return true;
  }
}, getAccessor:function(prop) {
  var me = this, cache = me.extractorCache, ret, key;
  if (typeof prop === 'string') {
    key = me.getAccessorKey(prop);
    if (key) {
      ret = cache.get(key);
    }
    if (!ret) {
      ret = me.createAccessor(prop);
      if (key) {
        cache.add(key, ret);
      }
    }
  } else {
    ret = me.createAccessor(prop);
  }
  return ret;
}, getAccessorKey:function(prop) {
  var className = this.$className;
  return className ? className + prop : '';
}, createAccessor:Ext.emptyFn, createFieldAccessor:Ext.emptyFn, destroy:function() {
  var me = this;
  me.model = me.getTotal = me.getSuccess = me.getMessage = me.rawData = null;
  me.onMetaChange = null;
  me.transform = null;
  me.callParent();
}, privates:{copyFrom:function(reader) {
  var me = this;
  reader.buildExtractors();
  me.getTotal = reader.getTotal;
  me.getSuccess = reader.getSuccess;
  me.getMessage = reader.getMessage;
  ++me.duringInit;
  me.setConfig(reader.getConfig());
  --me.duringInit;
  me.hasExtractors = true;
}, getGroupRoot:Ext.privateFn, getSummaryRoot:Ext.privateFn}}, 1, 0, 0, 0, ['reader.base'], [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable], [Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.reader, 'Reader', Ext.data, 'Reader', Ext.data, 'DataReader'], function(Cls) {
  var proto = Cls.prototype;
  Ext.apply(proto, {nullResultSet:new Ext.data.ResultSet({total:0, count:0, records:[], success:true, message:''})});
  proto.extractorCache = new Ext.util.LruCache;
});
Ext.cmd.derive('Ext.data.writer.Writer', Ext.Base, {factoryConfig:{defaultType:null}, alternateClassName:['Ext.data.DataWriter', 'Ext.data.Writer'], config:{clientIdProperty:null, allDataOptions:{persist:true}, partialDataOptions:{changes:true, critical:true}, writeAllFields:false, dateFormat:null, nameProperty:'name', writeRecordId:true, transform:null}, isWriter:true, constructor:function(config) {
  this.initConfig(config);
}, applyTransform:function(transform) {
  if (transform) {
    if (Ext.isFunction(transform)) {
      transform = {fn:transform};
    }
    return transform.fn.bind(transform.scope || this);
  }
  return transform;
}, write:function(request) {
  var operation = request.getOperation(), records = operation.getRecords() || [], len = records.length, data = [], i;
  for (i = 0; i < len; i++) {
    data.push(this.getRecordData(records[i], operation));
  }
  return this.writeRecords(request, data);
}, writeRecords:Ext.emptyFn, getRecordData:function(record, operation) {
  var me = this, nameProperty = me.getNameProperty(), mapping = nameProperty !== 'name', idField = record.self.idField, key = idField[nameProperty] || idField.name, value = record.id, writeAll = me.getWriteAllFields(), ret, dateFormat, phantom, options, clientIdProperty, fieldsMap, data, field;
  if (idField.serialize) {
    value = idField.serialize(value);
  }
  if (!writeAll && operation && operation.isDestroyOperation) {
    ret = {};
    ret[key] = value;
  } else {
    dateFormat = me.getDateFormat();
    phantom = record.phantom;
    options = phantom || writeAll ? me.getAllDataOptions() : me.getPartialDataOptions();
    clientIdProperty = phantom && me.getClientIdProperty();
    fieldsMap = record.getFieldsMap();
    options.serialize = false;
    data = record.getData(options);
    ret = mapping ? {} : data;
    if (clientIdProperty) {
      ret[clientIdProperty] = value;
      delete data[key];
    } else {
      if (!me.getWriteRecordId()) {
        delete data[key];
      }
    }
    for (key in data) {
      value = data[key];
      if (!(field = fieldsMap[key])) {
        if (mapping) {
          ret[key] = value;
        }
      } else {
        if (field.isDateField && dateFormat && Ext.isDate(value)) {
          value = Ext.Date.format(value, dateFormat);
        } else {
          if (field.serialize) {
            value = field.serialize(value, record);
          }
        }
        if (mapping) {
          key = field[nameProperty] || key;
        }
        ret[key] = value;
      }
    }
  }
  return ret;
}}, 1, 0, 0, 0, ['writer.base'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.writer, 'Writer', Ext.data, 'DataWriter', Ext.data, 'Writer'], 0);
Ext.cmd.derive('Ext.data.proxy.Proxy', Ext.Base, {$configPrefixed:false, alternateClassName:['Ext.data.DataProxy', 'Ext.data.Proxy'], config:{batchOrder:'create,update,destroy', batchActions:true, model:undefined, reader:{type:'json'}, writer:{type:'json'}}, isProxy:true, isSynchronous:false, constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
  this.pendingOperations = {};
}, applyModel:function(model) {
  return Ext.data.schema.Schema.lookupEntity(model);
}, updateModel:function(model) {
  if (model) {
    var reader = this.getReader();
    if (reader && !reader.getModel()) {
      reader.setModel(model);
    }
  }
}, applyReader:function(reader) {
  if (this.isSynchronous) {
    reader = reader || {};
    reader.keepRawData = true;
  }
  return Ext.Factory.reader(reader);
}, updateReader:function(reader) {
  if (reader) {
    var me = this, model = me.getModel();
    if (!model) {
      model = reader.getModel();
      if (model) {
        me.setModel(model);
      }
    } else {
      reader.setModel(model);
    }
  }
}, applyWriter:function(writer) {
  var reader = this.getReader();
  writer = Ext.Factory.writer(writer);
  if (writer.getRecord && !writer.getRecord() && reader && reader.getRecord) {
    reader = reader.getRecord();
    if (reader) {
      writer.setRecord(reader);
    }
  }
  return writer;
}, abort:Ext.emptyFn, onMetaChange:function(meta) {
  this.fireEvent('metachange', this, meta);
}, create:Ext.emptyFn, read:Ext.emptyFn, update:Ext.emptyFn, erase:Ext.emptyFn, batch:function(options, listeners) {
  var me = this, useBatch = me.getBatchActions(), batch, records, actions, aLen, action, a, r, rLen, record;
  if (options.operations === undefined) {
    options = {operations:options, listeners:listeners};
  }
  if (options.batch) {
    if (Ext.isDefined(options.batch.runOperation)) {
      batch = Ext.applyIf(options.batch, {proxy:me, listeners:{}});
    }
  } else {
    options.batch = {proxy:me, listeners:options.listeners || {}};
  }
  if (!batch) {
    batch = new Ext.data.Batch(options.batch);
  }
  batch.on('complete', Ext.bind(me.onBatchComplete, me, [options], 0), null, {single:true, priority:1000});
  actions = me.getBatchOrder().split(',');
  aLen = actions.length;
  for (a = 0; a < aLen; a++) {
    action = actions[a];
    records = options.operations[action];
    if (records) {
      if (useBatch) {
        batch.add(me.createOperation(action, {records:records, params:options.params}));
      } else {
        rLen = records.length;
        for (r = 0; r < rLen; r++) {
          record = records[r];
          batch.add(me.createOperation(action, {records:[record], params:options.params}));
        }
      }
    }
  }
  batch.start();
  return batch;
}, onBatchComplete:function(batchOptions, batch) {
  var scope = batchOptions.scope || this;
  if (batch.hasException()) {
    if (Ext.isFunction(batchOptions.failure)) {
      Ext.callback(batchOptions.failure, scope, [batch, batchOptions]);
    }
  } else {
    if (Ext.isFunction(batchOptions.success)) {
      Ext.callback(batchOptions.success, scope, [batch, batchOptions]);
    }
  }
  if (Ext.isFunction(batchOptions.callback)) {
    Ext.callback(batchOptions.callback, scope, [batch, batchOptions]);
  }
}, createOperation:function(action, config) {
  var operation = Ext.createByAlias('data.operation.' + action, config);
  operation.setProxy(this);
  this.pendingOperations[operation._internalId] = operation;
  return operation;
}, completeOperation:function(operation) {
  delete this.pendingOperations[operation._internalId];
}, clone:function() {
  return new this.self(this.getInitialConfig());
}, destroy:function() {
  var ops = this.pendingOperations, opId, op;
  for (opId in ops) {
    op = ops[opId];
    if (op && op.isRunning()) {
      op.abort();
    }
  }
  this.pendingOperations = null;
  this.callParent();
}}, 1, 0, 0, 0, ['proxy.proxy'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable], [Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.data.proxy, 'Proxy', Ext.data, 'DataProxy', Ext.data, 'Proxy'], 0);
Ext.cmd.derive('Ext.data.proxy.Client', Ext.data.proxy.Proxy, {alternateClassName:'Ext.data.ClientProxy', isSynchronous:true, clear:function() {
}}, 0, 0, 0, 0, 0, 0, [Ext.data.proxy, 'Client', Ext.data, 'ClientProxy'], 0);
Ext.cmd.derive('Ext.data.proxy.Memory', Ext.data.proxy.Client, {alternateClassName:'Ext.data.MemoryProxy', isMemoryProxy:true, config:{enablePaging:null, data:{$value:null, merge:function(newValue, currentValue, target, mixinClass) {
  return newValue ? Ext.clone(newValue) : newValue;
}}, clearOnRead:null}, finishOperation:function(operation) {
  var recs = operation.getRecords(), len = recs.length, i;
  for (i = 0; i < len; i++) {
    recs[i].dropped = !!operation.isDestroyOperation;
    recs[i].commit();
  }
  operation.setSuccessful(true);
}, create:function(operation) {
  this.finishOperation(operation);
}, update:function(operation) {
  this.finishOperation(operation);
}, erase:function(operation) {
  this.finishOperation(operation);
}, read:function(operation) {
  var me = this, reader = me.getReader(), resultSet = reader.read(me.getData(), {recordCreator:reader.defaultRecordCreatorFromServer}), records = resultSet.getRecords(), sorters = operation.getSorters(), grouper = operation.getGrouper(), filters = operation.getFilters(), start = operation.getStart(), limit = operation.getLimit(), meta;
  if (operation.process(resultSet, null, null, false) !== false) {
    if (operation.success && me.getClearOnRead()) {
      this.setData(null);
    }
    if (filters && filters.length) {
      resultSet.setRecords(records = Ext.Array.filter(records, Ext.util.Filter.createFilterFn(filters)));
      resultSet.setTotal(records.length);
    }
    if (grouper) {
      sorters = sorters ? sorters.concat(grouper) : sorters;
    }
    if (sorters && sorters.length) {
      resultSet.setRecords(records = Ext.Array.sort(records, Ext.util.Sortable.createComparator(sorters)));
    }
    if (me.getEnablePaging() && start !== undefined && limit !== undefined) {
      if (start >= resultSet.getTotal()) {
        resultSet.setConfig({success:false, records:[], total:0});
      } else {
        resultSet.setRecords(Ext.Array.slice(records, start, start + limit));
      }
    }
    operation.setCompleted();
    if (meta = resultSet.getMetadata()) {
      me.onMetaChange(meta);
    }
  }
}, clear:Ext.emptyFn}, 0, 0, 0, 0, ['proxy.memory'], 0, [Ext.data.proxy, 'Memory', Ext.data, 'MemoryProxy'], 0);
Ext.cmd.derive('Ext.data.ProxyStore', Ext.data.AbstractStore, {config:{model:undefined, fields:null, proxy:undefined, autoLoad:undefined, autoSync:false, batchUpdateMode:'operation', sortOnLoad:true, trackRemoved:true, asynchronousLoad:undefined}, onClassExtended:function(cls, data, hooks) {
  var model = data.model, onBeforeClassCreated;
  if (typeof model === 'string') {
    onBeforeClassCreated = hooks.onBeforeCreated;
    hooks.onBeforeCreated = function() {
      var me = this, args = arguments;
      Ext.require(model, function() {
        onBeforeClassCreated.apply(me, args);
      });
    };
  }
}, implicitModel:'Ext.data.Model', autoSyncSuspended:0, removed:null, constructor:function(config) {
  var me = this;
  Ext.data.AbstractStore.prototype.constructor.apply(this, arguments);
  if (me.getAsynchronousLoad() === false) {
    me.flushLoad();
  }
}, doDestroy:function() {
  var me = this, proxy = me.getProxy();
  me.clearLoadTask();
  Ext.destroy(me.getData());
  me.data = null;
  me.setProxy(null);
  if (proxy.autoCreated) {
    proxy.destroy();
  }
  me.setModel(null);
  Ext.data.AbstractStore.prototype.doDestroy.call(this);
}, applyAsynchronousLoad:function(asynchronousLoad) {
  if (asynchronousLoad == null) {
    asynchronousLoad = !this.loadsSynchronously();
  }
  return asynchronousLoad;
}, updateAutoLoad:function(autoLoad) {
  this.getData();
  if (autoLoad) {
    this.load(Ext.isObject(autoLoad) ? autoLoad : undefined);
  }
}, getTotalCount:function() {
  return this.totalCount || 0;
}, applyFields:function(fields) {
  if (fields) {
    this.createImplicitModel(fields);
  }
}, applyModel:function(model) {
  if (model) {
    model = Ext.data.schema.Schema.lookupEntity(model);
  } else {
    if (!this.destroying) {
      this.getFields();
      model = this.getModel() || this.createImplicitModel();
    }
  }
  return model;
}, applyProxy:function(proxy) {
  var model = this.getModel();
  if (proxy !== null) {
    if (proxy) {
      if (proxy.isProxy) {
        proxy.setModel(model);
      } else {
        if (Ext.isString(proxy)) {
          proxy = {type:proxy, model:model};
        } else {
          if (!proxy.model) {
            proxy = Ext.apply({model:model}, proxy);
          }
        }
        proxy = Ext.createByAlias('proxy.' + proxy.type, proxy);
        proxy.autoCreated = true;
      }
    } else {
      if (model) {
        proxy = model.getProxy();
        this.useModelProxy = true;
      }
    }
    if (!proxy) {
      proxy = Ext.createByAlias('proxy.memory');
      proxy.autoCreated = true;
    }
  }
  return proxy;
}, applyState:function(state) {
  var me = this;
  Ext.data.AbstractStore.prototype.applyState.call(this, state);
  if (me.getAutoLoad() || me.isLoaded()) {
    me.load();
  }
}, updateProxy:function(proxy, oldProxy) {
  this.proxyListeners = Ext.destroy(this.proxyListeners);
}, updateTrackRemoved:function(track) {
  this.cleanRemoved();
  this.removed = track ? [] : null;
}, onMetaChange:function(proxy, meta) {
  this.fireEvent('metachange', this, meta);
}, create:function(data, options) {
  var me = this, Model = me.getModel(), instance = new Model(data), operation;
  options = Ext.apply({}, options);
  if (!options.records) {
    options.records = [instance];
  }
  options.internalScope = me;
  options.internalCallback = me.onProxyWrite;
  operation = me.createOperation('create', options);
  return operation.execute();
}, read:function() {
  return this.load.apply(this, arguments);
}, update:function(options) {
  var me = this, operation;
  options = Ext.apply({}, options);
  if (!options.records) {
    options.records = me.getUpdatedRecords();
  }
  options.internalScope = me;
  options.internalCallback = me.onProxyWrite;
  operation = me.createOperation('update', options);
  return operation.execute();
}, onProxyWrite:function(operation) {
  var me = this, success = operation.wasSuccessful(), records = operation.getRecords();
  switch(operation.getAction()) {
    case 'create':
      me.onCreateRecords(records, operation, success);
      break;
    case 'update':
      me.onUpdateRecords(records, operation, success);
      break;
    case 'destroy':
      me.onDestroyRecords(records, operation, success);
      break;
  }
  if (success) {
    me.fireEvent('write', me, operation);
    me.fireEvent('datachanged', me);
  }
}, onCreateRecords:Ext.emptyFn, onUpdateRecords:Ext.emptyFn, onDestroyRecords:function(records, operation, success) {
  if (success) {
    this.cleanRemoved();
  }
}, erase:function(options) {
  var me = this, operation;
  options = Ext.apply({}, options);
  if (!options.records) {
    options.records = me.getRemovedRecords();
  }
  options.internalScope = me;
  options.internalCallback = me.onProxyWrite;
  operation = me.createOperation('destroy', options);
  return operation.execute();
}, onBatchOperationComplete:function(batch, operation) {
  return this.onProxyWrite(operation);
}, onBatchComplete:function(batch, operation) {
  var me = this, operations = batch.operations, length = operations.length, i;
  if (me.batchUpdateMode !== 'operation') {
    me.suspendEvents();
    for (i = 0; i < length; i++) {
      me.onProxyWrite(operations[i]);
    }
    me.resumeEvents();
  }
  me.isSyncing = false;
  batch.destroy();
  me.fireEvent('datachanged', me);
}, onBatchException:function(batch, operation) {
}, filterNew:function(item) {
  return item.phantom && item.isValid();
}, getNewRecords:function() {
  return [];
}, getUpdatedRecords:function() {
  return [];
}, getModifiedRecords:function() {
  return [].concat(this.getNewRecords(), this.getUpdatedRecords());
}, filterUpdated:function(item) {
  return item.dirty && !item.phantom && item.isValid();
}, getRemovedRecords:function() {
  var removed = this.getRawRemovedRecords();
  return removed ? Ext.Array.clone(removed) : [];
}, sync:function(options) {
  var me = this, operations = {}, toCreate = me.getNewRecords(), toUpdate = me.getUpdatedRecords(), toDestroy = me.getRemovedRecords(), needsSync = false;
  me.needsSync = false;
  if (toCreate.length > 0) {
    operations.create = toCreate;
    needsSync = true;
  }
  if (toUpdate.length > 0) {
    operations.update = toUpdate;
    needsSync = true;
  }
  if (toDestroy.length > 0) {
    operations.destroy = toDestroy;
    needsSync = true;
  }
  if (needsSync && me.fireEvent('beforesync', operations) !== false) {
    me.isSyncing = true;
    options = options || {};
    me.proxy.batch(Ext.apply(options, {operations:operations, listeners:me.getBatchListeners()}));
  }
  return me;
}, getBatchListeners:function() {
  var me = this, listeners = {scope:me, exception:me.onBatchException, complete:me.onBatchComplete};
  if (me.batchUpdateMode === 'operation') {
    listeners.operationcomplete = me.onBatchOperationComplete;
  }
  return listeners;
}, save:function() {
  return this.sync.apply(this, arguments);
}, load:function(options) {
  var me = this;
  if (typeof options === 'function') {
    options = {callback:options};
  } else {
    options = options ? Ext.Object.chain(options) : {};
  }
  me.pendingLoadOptions = options;
  if (me.getAsynchronousLoad()) {
    if (!me.loadTimer) {
      me.loadTimer = Ext.asap(me.flushLoad, me);
    }
  } else {
    me.flushLoad();
  }
  return me;
}, flushLoad:function() {
  var me = this, options = me.pendingLoadOptions, operation;
  if (me.destroying || me.destroyed) {
    return;
  }
  me.clearLoadTask();
  if (!options) {
    return;
  }
  me.setLoadOptions(options);
  if (me.getRemoteSort() && options.sorters) {
    me.fireEvent('beforesort', me, options.sorters);
  }
  operation = Ext.apply({internalScope:me, internalCallback:me.onProxyLoad, scope:me}, options);
  me.lastOptions = operation;
  operation = me.createOperation('read', operation);
  if (me.fireEvent('beforeload', me, operation) !== false) {
    me.onBeforeLoad(operation);
    me.loading = true;
    if (me.hasListeners.beginload) {
      me.fireEvent('beginload', me, operation);
    }
    operation.execute();
  }
}, reload:function(options) {
  return this.load(Ext.apply({}, options, this.lastOptions));
}, onEndUpdate:function() {
  var me = this;
  if (me.needsSync && me.autoSync && !me.autoSyncSuspended) {
    me.sync();
  }
}, afterReject:function(record) {
  var me = this;
  if (me.contains(record)) {
    me.onUpdate(record, Ext.data.Model.REJECT, null);
    me.fireEvent('update', me, record, Ext.data.Model.REJECT, null);
    me.fireEvent('datachanged', me);
  }
}, afterCommit:function(record, modifiedFieldNames) {
  var me = this;
  if (!modifiedFieldNames) {
    modifiedFieldNames = null;
  }
  if (me.contains(record)) {
    me.onUpdate(record, Ext.data.Model.COMMIT, modifiedFieldNames);
    me.fireEvent('update', me, record, Ext.data.Model.COMMIT, modifiedFieldNames);
    me.fireEvent('datachanged', me);
  }
}, afterErase:function(record) {
  this.onErase(record);
}, onErase:Ext.emptyFn, onUpdate:Ext.emptyFn, hasPendingLoad:function() {
  return !!this.pendingLoadOptions || this.isLoading();
}, isLoading:function() {
  return !!this.loading;
}, isLoaded:function() {
  return this.loadCount > 0;
}, suspendAutoSync:function() {
  ++this.autoSyncSuspended;
}, resumeAutoSync:function(syncNow) {
  var me = this;
  if (me.autoSyncSuspended && !--me.autoSyncSuspended) {
    if (syncNow) {
      me.sync();
    }
  }
}, removeAll:Ext.emptyFn, clearData:Ext.emptyFn, privates:{getRawRemovedRecords:function() {
  return this.removed;
}, onExtraParamsChanged:function() {
}, clearLoadTask:function() {
  this.pendingLoadOptions = this.loadTimer = Ext.unasap(this.loadTimer);
}, cleanRemoved:function() {
  var removed = this.getRawRemovedRecords(), len, i;
  if (removed) {
    for (i = 0, len = removed.length; i < len; ++i) {
      removed[i].unjoin(this);
    }
    removed.length = 0;
  }
}, createOperation:function(type, options) {
  var me = this, proxy = me.getProxy(), listeners;
  if (!me.proxyListeners) {
    listeners = {scope:me, destroyable:true, beginprocessresponse:me.beginUpdate, endprocessresponse:me.endUpdate};
    if (!me.disableMetaChangeEvent) {
      listeners.metachange = me.onMetaChange;
    }
    me.proxyListeners = proxy.on(listeners);
  }
  return proxy.createOperation(type, options);
}, createImplicitModel:function(fields) {
  var me = this, modelCfg = {extend:me.implicitModel, statics:{defaultProxy:'memory'}}, proxy, model;
  if (fields) {
    modelCfg.fields = fields;
  }
  model = Ext.define(null, modelCfg);
  me.setModel(model);
  proxy = me.getProxy();
  if (proxy) {
    model.setProxy(proxy);
  } else {
    me.setProxy(model.getProxy());
  }
}, loadsSynchronously:function() {
  return this.getProxy().isSynchronous;
}, onBeforeLoad:Ext.privateFn, removeFromRemoved:function(record) {
  var removed = this.getRawRemovedRecords();
  if (removed) {
    Ext.Array.remove(removed, record);
    record.unjoin(this);
  }
}, setLoadOptions:function(options) {
  var me = this, filters, sorters;
  if (me.getRemoteFilter()) {
    filters = me.getFilters(false);
    if (filters && filters.getCount()) {
      options.filters = filters.getRange();
    }
  }
  if (me.getRemoteSort()) {
    sorters = me.getSorters(false);
    if (sorters && sorters.getCount()) {
      options.sorters = sorters.getRange();
    }
  }
}}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'ProxyStore'], 0);
Ext.cmd.derive('Ext.util.Group', Ext.util.Collection, {config:{groupKey:null}, $endUpdatePriority:2001, manageSorters:false}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Group'], 0);
Ext.cmd.derive('Ext.data.Group', Ext.util.Group, {store:null, getSummaryRecord:function() {
  var me = this, summaryRecord = me.summaryRecord, store = me.store, generation = store.getData().generation, M, T;
  if (!summaryRecord) {
    M = store.getModel();
    T = M.getSummaryModel();
    me.summaryRecord = summaryRecord = new T;
  }
  if (!summaryRecord.isRemote && summaryRecord.summaryGeneration !== generation) {
    summaryRecord.calculateSummary(me.items);
    summaryRecord.summaryGeneration = generation;
  }
  return summaryRecord;
}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'Group'], 0);
Ext.cmd.derive('Ext.data.LocalStore', Ext.Mixin, {mixinConfig:{id:'localstore'}, config:{extraKeys:null}, applyExtraKeys:function(extraKeys) {
  var indexName, data = this.getData();
  data.setExtraKeys(extraKeys);
  extraKeys = data.getExtraKeys();
  for (indexName in extraKeys) {
    this[indexName] = extraKeys[indexName];
  }
}, add:function(record) {
  return this.insert(this.getCount(), arguments.length === 1 ? record : arguments);
}, constructDataCollection:function() {
  var result = new Ext.util.Collection({rootProperty:'data', groupConfig:{xclass:'Ext.data.Group', store:this}});
  result.addObserver(this);
  return result;
}, createModel:function(record) {
  var session = this.getSession(), Model;
  if (!record.isModel) {
    Model = this.getModel();
    record = new Model(record, session);
  }
  return record;
}, createFiltersCollection:function() {
  return this.getData().getFilters();
}, createSortersCollection:function() {
  var sorters = this.getData().getSorters();
  sorters.setSorterConfigure(this.addFieldTransform, this);
  return sorters;
}, getSummaryRecord:function() {
  var me = this, summaryRecord = me.summaryRecord, data = me.getData(), generation = data.generation, T;
  if (!summaryRecord) {
    T = me.getModel().getSummaryModel();
    me.summaryRecord = summaryRecord = new T;
  }
  if (!summaryRecord.isRemote && summaryRecord.summaryGeneration !== generation) {
    summaryRecord.calculateSummary(data.items);
    summaryRecord.summaryGeneration = generation;
  }
  return summaryRecord;
}, onCollectionBeginUpdate:function() {
  this.beginUpdate();
}, onCollectionEndUpdate:function() {
  this.endUpdate();
}, onCollectionSort:function() {
  this.onSorterEndUpdate();
}, onCollectionFilter:function() {
  this.onFilterEndUpdate();
}, notifySorterChange:function() {
  this.getData().onSorterChange();
}, forceLocalSort:function() {
  var sorters = this.getSorters();
  sorters.beginUpdate();
  sorters.endUpdate();
}, contains:function(record) {
  return this.indexOf(record) > -1;
}, each:function(fn, scope, includeOptions) {
  var data = this.getData(), bypassFilters = includeOptions, len, record, i;
  if (typeof includeOptions === 'object') {
    bypassFilters = includeOptions.filtered;
  }
  if (bypassFilters && data.filtered) {
    data = data.getSource();
  }
  data = data.items.slice(0);
  len = data.length;
  for (i = 0; i < len; ++i) {
    record = data[i];
    if (fn.call(scope || record, record, i, len) === false) {
      break;
    }
  }
}, collect:function(property, includeOptions, filtered) {
  var me = this, allowNull = includeOptions, data = me.getData();
  if (typeof includeOptions === 'object') {
    filtered = includeOptions.filtered;
    allowNull = includeOptions.allowNull;
  }
  if (filtered && data.filtered) {
    data = data.getSource();
  }
  return data.collect(property, 'data', allowNull);
}, getById:function(id) {
  var data = this.getData();
  if (data.filtered) {
    data = data.getSource();
  }
  return data.get(id) || null;
}, getByInternalId:function(internalId) {
  var data = this.getData(), keyCfg;
  if (data.filtered) {
    if (!data.$hasExtraKeys) {
      keyCfg = this.makeInternalKeyCfg();
      data.setExtraKeys(keyCfg);
      data.$hasExtraKeys = true;
    }
    data = data.getSource();
  }
  if (!data.$hasExtraKeys) {
    data.setExtraKeys(keyCfg || this.makeInternalKeyCfg());
    data.$hasExtraKeys = true;
  }
  return data.byInternalId.get(internalId) || null;
}, getDataSource:function() {
  var data = this.getData();
  return data.getSource() || data;
}, indexOf:function(record) {
  return this.getData().indexOf(record);
}, indexOfId:function(id) {
  return this.indexOf(this.getById(id));
}, insert:function(index, records) {
  var me = this, len, i;
  if (records) {
    if (!Ext.isIterable(records)) {
      records = [records];
    } else {
      records = Ext.Array.clone(records);
    }
    len = records.length;
  }
  if (!len) {
    return [];
  }
  for (i = 0; i < len; ++i) {
    records[i] = me.createModel(records[i]);
  }
  me.getData().insert(index, records);
  return records;
}, queryBy:function(fn, scope) {
  var data = this.getData();
  return (data.getSource() || data).createFiltered(fn, scope);
}, query:function(property, value, anyMatch, caseSensitive, exactMatch) {
  var data = this.getData();
  return (data.getSource() || data).createFiltered(property, value, anyMatch, caseSensitive, exactMatch);
}, first:function(grouped) {
  return this.getData().first(grouped) || null;
}, last:function(grouped) {
  return this.getData().last(grouped) || null;
}, sum:function(field, grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.sumByGroup(field) : data.sum(field);
}, count:function(grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.countByGroup() : data.count();
}, min:function(field, grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.minByGroup(field) : data.min(field);
}, max:function(field, grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.maxByGroup(field) : data.max(field);
}, average:function(field, grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.averageByGroup(field) : data.average(field);
}, aggregate:function(fn, scope, grouped, field) {
  var me = this, groups, len, out, group, i;
  if (grouped && me.isGrouped()) {
    groups = me.getGroups().items;
    len = groups.length;
    out = {};
    for (i = 0; i < len; ++i) {
      group = groups[i];
      out[group.getGroupKey()] = me.getAggregate(fn, scope || me, group.items, field);
    }
    return out;
  } else {
    return me.getAggregate(fn, scope, me.getData().items, field);
  }
}, getAggregate:function(fn, scope, records, field) {
  var values = [], len = records.length, i;
  for (i = 0; i < len; ++i) {
    values[i] = records[i].get(field);
  }
  return fn.call(scope || this, records, values);
}, addObserver:function(observer) {
  var observers = this.observers;
  if (!observers) {
    this.observers = observers = new Ext.util.Collection;
  }
  observers.add(observer);
}, removeObserver:function(observer) {
  var observers = this.observers;
  if (observers) {
    observers.remove(observer);
  }
}, callObservers:function(action, args) {
  var observers = this.observers, len, items, i, methodName, item;
  if (observers) {
    items = observers.items;
    if (args) {
      args.unshift(this);
    } else {
      args = [this];
    }
    for (i = 0, len = items.length; i < len; ++i) {
      item = items[i];
      methodName = 'onSource' + action;
      if (item[methodName]) {
        item[methodName].apply(item, args);
      }
    }
  }
}, queryRecordsBy:function(fn, scope) {
  var data = this.getData(), matches = [], len, i, record;
  data = (data.getSource() || data).items;
  scope = scope || this;
  for (i = 0, len = data.length; i < len; ++i) {
    record = data[i];
    if (fn.call(scope, record) === true) {
      matches.push(record);
    }
  }
  return matches;
}, queryRecords:function(field, value) {
  var data = this.getData(), matches = [], len, i, record;
  data = (data.getSource() || data).items;
  for (i = 0, len = data.length; i < len; ++i) {
    record = data[i];
    if (record.get(field) === value) {
      matches.push(record);
    }
  }
  return matches;
}, privates:{isLast:function(record) {
  return record === this.last();
}, makeInternalKeyCfg:function() {
  return {byInternalId:{property:'internalId', rootProperty:''}};
}}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'LocalStore'], 0);
Ext.cmd.derive('Ext.data.proxy.Server', Ext.data.proxy.Proxy, {alternateClassName:'Ext.data.ServerProxy', isRemote:true, config:{url:'', pageParam:'page', startParam:'start', limitParam:'limit', groupParam:'group', groupDirectionParam:'groupDir', sortParam:'sort', filterParam:'filter', directionParam:'dir', idParam:'id', simpleSortMode:false, simpleGroupMode:false, noCache:true, cacheString:'_dc', timeout:30000, api:{create:undefined, read:undefined, update:undefined, destroy:undefined}, extraParams:{}}, 
primitiveRe:/string|number|boolean/, create:function() {
  return this.doRequest.apply(this, arguments);
}, read:function() {
  return this.doRequest.apply(this, arguments);
}, update:function() {
  return this.doRequest.apply(this, arguments);
}, erase:function() {
  return this.doRequest.apply(this, arguments);
}, setExtraParam:function(name, value) {
  var extraParams = this.getExtraParams();
  extraParams[name] = value;
  this.fireEvent('extraparamschanged', extraParams);
}, updateExtraParams:function(newExtraParams, oldExtraParams) {
  this.fireEvent('extraparamschanged', newExtraParams);
}, buildRequest:function(operation) {
  var me = this, initialParams = Ext.apply({}, operation.getParams()), params = Ext.applyIf(initialParams, me.getExtraParams() || {}), request, operationId, idParam;
  Ext.applyIf(params, me.getParams(operation));
  operationId = operation.getId();
  idParam = me.getIdParam();
  if (operationId !== undefined && params[idParam] === undefined) {
    params[idParam] = operationId;
  }
  request = new Ext.data.Request({params:params, action:operation.getAction(), records:operation.getRecords(), url:operation.getUrl(), operation:operation, proxy:me});
  request.setUrl(me.buildUrl(request));
  operation.setRequest(request);
  return request;
}, processResponse:function(success, operation, request, response) {
  var me = this, exception, reader, resultSet, meta;
  if (me.destroying || me.destroyed) {
    return;
  }
  me.fireEvent('beginprocessresponse', me, response, operation);
  if (success === true) {
    reader = me.getReader();
    if (response.status === 204) {
      resultSet = reader.getNullResultSet();
    } else {
      resultSet = reader.read(me.extractResponseData(response), {recordCreator:operation.getRecordCreator() || reader.defaultRecordCreatorFromServer});
    }
    operation.process(resultSet, request, response);
    exception = !operation.wasSuccessful();
  } else {
    me.setException(operation, response);
    exception = true;
  }
  if (me.destroyed) {
    return;
  }
  if (exception) {
    me.fireEvent('exception', me, response, operation);
  } else {
    meta = resultSet.getMetadata();
    if (meta) {
      me.onMetaChange(meta);
    }
  }
  if (me.destroyed) {
    return;
  }
  me.afterRequest(request, success);
  me.fireEvent('endprocessresponse', me, response, operation);
}, setException:function(operation, response) {
  operation.setException({status:response.status, statusText:response.statusText, response:response});
}, extractResponseData:Ext.identityFn, applyEncoding:function(value) {
  return Ext.encode(value);
}, encodeSorters:function(sorters, preventArray) {
  var out = [], length = sorters.length, i;
  for (i = 0; i < length; i++) {
    out[i] = sorters[i].serialize();
  }
  return this.applyEncoding(preventArray ? out[0] : out);
}, encodeFilters:function(filters) {
  var out = [], length = filters.length, needsEncoding, i, filter, encodedFilter;
  for (i = 0; i < length; i++) {
    filter = filters[i];
    filter.getFilterFn();
    if (filter.generatedFilterFn) {
      encodedFilter = filter.serialize();
      needsEncoding |= !this.primitiveRe.test(typeof encodedFilter);
      out.push(encodedFilter);
    }
  }
  return needsEncoding ? this.applyEncoding(out) : out;
}, getParams:function(operation) {
  if (!operation.isReadOperation) {
    return {};
  }
  var me = this, params = {}, grouper = operation.getGrouper(), sorters = operation.getSorters(), filters = operation.getFilters(), page = operation.getPage(), start = operation.getStart(), limit = operation.getLimit(), simpleSortMode = me.getSimpleSortMode(), simpleGroupMode = me.getSimpleGroupMode(), pageParam = me.getPageParam(), startParam = me.getStartParam(), limitParam = me.getLimitParam(), groupParam = me.getGroupParam(), groupDirectionParam = me.getGroupDirectionParam(), sortParam = me.getSortParam(), 
  filterParam = me.getFilterParam(), directionParam = me.getDirectionParam(), hasGroups, index;
  if (pageParam && page) {
    params[pageParam] = page;
  }
  if (startParam && (start || start === 0)) {
    params[startParam] = start;
  }
  if (limitParam && limit) {
    params[limitParam] = limit;
  }
  hasGroups = groupParam && grouper;
  if (hasGroups) {
    if (simpleGroupMode) {
      params[groupParam] = grouper.getProperty();
      if (groupDirectionParam === groupParam) {
        params[groupParam] += ' ' + grouper.getDirection();
      } else {
        params[groupDirectionParam] = grouper.getDirection();
      }
    } else {
      params[groupParam] = me.encodeSorters([grouper], true);
    }
  }
  if (sortParam && sorters && sorters.length > 0) {
    if (simpleSortMode) {
      for (index = sorters.length > 1 && hasGroups ? 1 : 0; index < sorters.length; index++) {
        if (directionParam === sortParam) {
          params[sortParam] = Ext.Array.push(params[sortParam] || [], sorters[index].getProperty() + ' ' + sorters[index].getDirection());
        } else {
          params[sortParam] = Ext.Array.push(params[sortParam] || [], sorters[index].getProperty());
          params[directionParam] = Ext.Array.push(params[directionParam] || [], sorters[index].getDirection());
        }
      }
    } else {
      params[sortParam] = me.encodeSorters(sorters);
    }
  }
  if (filterParam && filters && filters.length > 0) {
    params[filterParam] = me.encodeFilters(filters);
  }
  return params;
}, buildUrl:function(request) {
  var me = this, url = me.getUrl(request);
  if (me.getNoCache()) {
    url = Ext.urlAppend(url, Ext.String.format('{0}\x3d{1}', me.getCacheString(), Ext.Date.now()));
  }
  return url;
}, getUrl:function(request) {
  var url;
  if (request) {
    url = request.getUrl() || this.getApi()[request.getAction()];
  }
  return url ? url : (arguments.callee.$previous || Ext.data.proxy.Proxy.prototype.getUrl).call(this);
}, doRequest:function(operation, callback, scope) {
}, afterRequest:Ext.emptyFn, destroy:function() {
  var me = this;
  me.destroying = true;
  me.reader = me.writer = Ext.destroy(me.reader, me.writer);
  Ext.data.proxy.Proxy.prototype.destroy.call(this);
  me.destroying = false;
  me.destroyed = true;
}}, 0, 0, 0, 0, ['proxy.server'], 0, [Ext.data.proxy, 'Server', Ext.data, 'ServerProxy'], 0);
Ext.cmd.derive('Ext.data.proxy.Ajax', Ext.data.proxy.Server, {alternateClassName:['Ext.data.HttpProxy', 'Ext.data.AjaxProxy'], isAjaxProxy:true, defaultActionMethods:{create:'POST', read:'GET', update:'POST', destroy:'POST'}, config:{binary:false, headers:undefined, paramsAsJson:false, withCredentials:false, useDefaultXhrHeader:true, username:null, password:null, actionMethods:{create:'POST', read:'GET', update:'POST', destroy:'POST'}}, doRequest:function(operation) {
  var me = this, writer = me.getWriter(), request = me.buildRequest(operation), method = me.getMethod(request), jsonData, params;
  if (writer && operation.allowWrite()) {
    request = writer.write(request);
  }
  request.setConfig({binary:me.getBinary(), headers:me.getHeaders(), timeout:me.getTimeout(), scope:me, callback:me.createRequestCallback(request, operation), method:method, useDefaultXhrHeader:me.getUseDefaultXhrHeader(), disableCaching:false});
  if (method.toUpperCase() !== 'GET' && me.getParamsAsJson()) {
    params = request.getParams();
    if (params) {
      jsonData = request.getJsonData();
      if (jsonData) {
        jsonData = Ext.Object.merge({}, jsonData, params);
      } else {
        jsonData = params;
      }
      request.setJsonData(jsonData);
      request.setParams(undefined);
    }
  }
  if (me.getWithCredentials()) {
    request.setWithCredentials(true);
    request.setUsername(me.getUsername());
    request.setPassword(me.getPassword());
  }
  return me.sendRequest(request);
}, sendRequest:function(request) {
  request.setRawRequest(Ext.Ajax.request(request.getCurrentConfig()));
  this.lastRequest = request;
  return request;
}, abort:function(request) {
  request = request || this.lastRequest;
  if (request) {
    Ext.Ajax.abort(request.getRawRequest());
  }
}, getMethod:function(request) {
  var actions = this.getActionMethods(), action = request.getAction(), method;
  if (actions) {
    method = actions[action];
  }
  return method || this.defaultActionMethods[action];
}, createRequestCallback:function(request, operation) {
  return function(options, success, response) {
    var me = this;
    if (request === me.lastRequest) {
      me.lastRequest = null;
    }
    if (!me.destroying && !me.destroyed) {
      me.processResponse(success, operation, request, response);
    }
  };
}, destroy:function() {
  this.lastRequest = null;
  Ext.data.proxy.Server.prototype.destroy.call(this);
}}, 0, 0, 0, 0, ['proxy.ajax'], 0, [Ext.data.proxy, 'Ajax', Ext.data, 'HttpProxy', Ext.data, 'AjaxProxy'], 0);
Ext.cmd.derive('Ext.data.reader.Json', Ext.data.reader.Reader, {alternateClassName:'Ext.data.JsonReader', config:{record:null, metaProperty:'metaData', useSimpleAccessors:false, preserveRawData:false}, updateRootProperty:function() {
  this.forceBuildExtractors();
}, updateMetaProperty:function() {
  this.forceBuildExtractors();
}, getResponseData:function(response) {
  var error;
  try {
    return Ext.decode(response.responseText);
  } catch (ex) {
    error = this.createReadError(ex.message);
    Ext.Logger.warn('Unable to parse the JSON returned by the server');
    this.fireEvent('exception', this, response, error);
    return error;
  }
}, buildExtractors:function(force) {
  var me = this, emptyFn = Ext.emptyFn, prop;
  if (Ext.data.reader.Reader.prototype.buildExtractors.call(this, force)) {
    me.getRoot = me.setupExtractor(me.getRootProperty(), Ext.identityFn);
    me.getGroupRoot = me.setupExtractor(me.getGroupRootProperty(), emptyFn);
    me.getSummaryRoot = me.setupExtractor(me.getSummaryRootProperty(), emptyFn);
    me.getMeta = me.setupExtractor(me.getMetaProperty(), emptyFn);
  }
}, extractData:function(root, readOptions) {
  var recordName = this.getRecord(), data = [], length, i;
  if (recordName) {
    length = root.length;
    if (!length && Ext.isObject(root)) {
      length = 1;
      root = [root];
    }
    for (i = 0; i < length; i++) {
      data[i] = root[i][recordName];
    }
  } else {
    data = root;
  }
  return Ext.data.reader.Reader.prototype.extractData.call(this, data, readOptions);
}, getModelData:function(raw) {
  return this.getPreserveRawData() ? Ext.apply({}, raw) : raw;
}, createAccessor:function() {
  var re = /[\[\.]/;
  return function(expr) {
    var simple = this.getUseSimpleAccessors(), operatorIndex, result, current, parts, part, inExpr, isDot, isLeft, isRight, special, c, i, bracketed, len;
    if (!(expr || expr === 0)) {
      return;
    }
    if (typeof expr === 'function') {
      return expr;
    }
    if (!simple) {
      operatorIndex = String(expr).search(re);
    }
    if (simple === true || operatorIndex < 0) {
      result = function(raw) {
        return raw[expr];
      };
    } else {
      current = 'raw';
      parts = [];
      part = '';
      inExpr = 0;
      len = expr.length;
      for (i = 0; i <= len; ++i) {
        c = expr[i];
        isDot = c === '.';
        isLeft = c === '[';
        isRight = c === ']';
        special = isDot || isLeft || isRight || !c;
        if (!special || inExpr > 1 || inExpr && !isRight) {
          part += c;
        } else {
          if (special) {
            bracketed = false;
            if (isLeft) {
              ++inExpr;
            } else {
              if (isRight) {
                --inExpr;
                bracketed = true;
              }
            }
            if (part) {
              if (bracketed) {
                part = '[' + part + ']';
              } else {
                part = '.' + part;
              }
              current += part;
              parts.push('' + current);
              part = '';
            }
          }
        }
      }
      result = parts.join(' \x26\x26 ');
      result = Ext.functionFactory('raw', 'return ' + result);
    }
    return result;
  };
}(), createFieldAccessor:function(field) {
  var me = this, mapping = field.mapping, hasMap = mapping || mapping === 0, map = hasMap ? mapping : field.name;
  if (hasMap) {
    if (typeof map === 'function') {
      return function(raw, self) {
        return field.mapping(raw, self);
      };
    } else {
      return me.createAccessor(map);
    }
  }
}, getAccessorKey:function(prop) {
  var simple = this.getUseSimpleAccessors() ? 'simple' : '';
  return Ext.data.reader.Reader.prototype.getAccessorKey.call(this, simple + prop);
}, privates:{copyFrom:function(reader) {
  Ext.data.reader.Reader.prototype.copyFrom.call(this, reader);
  this.getRoot = reader.getRoot;
}, setupExtractor:function(prop, defaultFn) {
  return prop ? this.getAccessor(prop) : defaultFn;
}}}, 0, 0, 0, 0, ['reader.json'], 0, [Ext.data.reader, 'Json', Ext.data, 'JsonReader'], 0);
Ext.cmd.derive('Ext.data.writer.Json', Ext.data.writer.Writer, {alternateClassName:'Ext.data.JsonWriter', config:{rootProperty:undefined, encode:false, allowSingle:true, expandData:false}, getExpandedData:function(data) {
  var dataLength = data.length, i = 0, item, prop, nameParts, j, tempObj, toObject = function(name, value) {
    var o = {};
    o[name] = value;
    return o;
  };
  for (; i < dataLength; i++) {
    item = data[i];
    for (prop in item) {
      if (item.hasOwnProperty(prop)) {
        nameParts = prop.split('.');
        j = nameParts.length - 1;
        if (j > 0) {
          tempObj = item[prop];
          for (; j > 0; j--) {
            tempObj = toObject(nameParts[j], tempObj);
          }
          item[nameParts[0]] = item[nameParts[0]] || {};
          Ext.Object.merge(item[nameParts[0]], tempObj);
          delete item[prop];
        }
      }
    }
  }
  return data;
}, writeRecords:function(request, data) {
  var me = this, root = me.getRootProperty(), json, single, transform;
  if (me.getExpandData()) {
    data = me.getExpandedData(data);
  }
  if (me.getAllowSingle() && data.length === 1) {
    data = data[0];
    single = true;
  }
  transform = this.getTransform();
  if (transform) {
    data = transform(data, request);
  }
  if (me.getEncode()) {
    if (root) {
      request.setParam(root, Ext.encode(data));
    } else {
    }
  } else {
    if (single || data && data.length) {
      json = request.getJsonData() || {};
      if (root) {
        json[root] = data;
      } else {
        json = data;
      }
      request.setJsonData(json);
    }
  }
  return request;
}}, 0, 0, 0, 0, ['writer.json'], 0, [Ext.data.writer, 'Json', Ext.data, 'JsonWriter'], 0);
Ext.cmd.derive('Ext.util.SorterCollection', Ext.util.Collection, {isSorterCollection:true, $sortable:null, sortFn:null, config:{sorterOptionsFn:null, sorterOptionsScope:null}, constructor:function(config) {
  var me = this;
  me.sortFn = Ext.util.Sorter.createComparator(me);
  Ext.util.Collection.prototype.constructor.call(this, config);
  me.setDecoder(me.decodeSorter);
}, addSort:function(property, direction, mode) {
  var me = this, count, index, limit, options, primary, sorter, sorters;
  if (!property) {
    me.beginUpdate();
    me.endUpdate();
  } else {
    options = me.getOptions();
    if (property instanceof Array) {
      sorters = property;
      mode = direction;
      direction = null;
    } else {
      if (Ext.isString(property)) {
        if (!(sorter = me.get(property))) {
          sorters = [{property:property, direction:direction || options.getDefaultSortDirection()}];
        } else {
          sorters = [sorter];
        }
      } else {
        if (Ext.isFunction(property)) {
          sorters = [{sorterFn:property, direction:direction || options.getDefaultSortDirection()}];
        } else {
          sorters = [property];
          mode = direction;
          direction = null;
        }
      }
    }
    mode = me._sortModes[mode || 'replace'];
    primary = me.getAt(0);
    count = me.length;
    index = mode.append ? count : 0;
    me.beginUpdate();
    me.splice(index, mode.replace ? count : 0, sorters);
    if (mode.multi) {
      count = me.length;
      limit = options.getMultiSortLimit();
      if (count > limit) {
        me.removeAt(limit, count);
      }
    }
    if (sorter && direction) {
      sorter.setDirection(direction);
    } else {
      if (index === 0 && primary && primary === me.getAt(0)) {
        primary.toggle();
      }
    }
    me.endUpdate();
  }
}, clear:function() {
  this.beginUpdate();
  Ext.util.Collection.prototype.clear.call(this);
  this.endUpdate(this.items);
}, getSortFn:function() {
  return this.sortFn;
}, getByProperty:function(prop) {
  var items = this.items, len = items.length, i, item;
  for (i = 0; i < len; ++i) {
    item = items[i];
    if (item.getProperty() === prop) {
      return item;
    }
  }
  return null;
}, _sortModes:{append:{append:1}, multi:{multi:1}, prepend:{prepend:1}, replace:{replace:1}}, decodeSorter:function(sorter, xclass) {
  var me = this, options = me.getOptions(), root = options.getRootProperty(), sorterOptionsFn = me.getSorterOptionsFn(), currentSorter, sorterConfig, type;
  if (sorter.isSorter) {
    if (!sorter.getRoot()) {
      sorter.setRoot(root);
    }
  } else {
    sorterConfig = {direction:options.getDefaultSortDirection(), root:root};
    type = typeof sorter;
    if (type === 'string') {
      currentSorter = me.get(sorter);
      if (currentSorter) {
        return currentSorter;
      }
      sorterConfig.property = sorter;
    } else {
      if (type === 'function') {
        sorterConfig.sorterFn = sorter;
      } else {
        sorterConfig = Ext.apply(sorterConfig, sorter);
        if (sorterConfig.fn) {
          sorterConfig.sorterFn = sorterConfig.fn;
          delete sorterConfig.fn;
        }
      }
    }
    sorter = Ext.create(xclass || Ext.util.Sorter, sorterConfig);
  }
  if (sorterOptionsFn) {
    sorterOptionsFn.call(me.getSorterOptionsScope() || me, sorter);
  }
  return sorter;
}, setSorterConfigure:function(fn, scope) {
  this.setSorterOptionsFn(fn);
  this.setSorterOptionsScope(scope);
}, decodeRemoveItems:function(args, index) {
  var me = this, ret = index === undefined ? args : args[index];
  if (!ret || !ret.$cloned) {
    if (args.length > index + 1 || !Ext.isIterable(ret)) {
      ret = Ext.Array.slice(args, index);
    }
    var currentSorters = me.items, ln = ret.length, remove = [], i, item, n, sorter, type;
    for (i = 0; i < ln; i++) {
      sorter = ret[i];
      if (sorter && sorter.isSorter) {
        remove.push(sorter);
      } else {
        type = typeof sorter;
        if (type === 'string') {
          sorter = me.get(sorter);
          if (sorter) {
            remove.push(sorter);
          }
        } else {
          if (type === 'function') {
            for (n = currentSorters.length; n-- > 0;) {
              item = currentSorters[n];
              if (item.getSorterFn() === sorter) {
                remove.push(item);
              }
            }
          }
        }
      }
    }
    ret = remove;
    ret.$cloned = true;
  }
  return ret;
}, getOptions:function() {
  return this.$sortable || this;
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'SorterCollection'], 0);
Ext.cmd.derive('Ext.util.FilterCollection', Ext.util.Collection, {isFilterCollection:true, $filterable:null, filterFn:null, constructor:function(config) {
  var me = this;
  me.filterFn = Ext.util.Filter.createFilterFn(me);
  Ext.util.Collection.prototype.constructor.call(this, config);
  me.setDecoder(me.decodeFilter);
}, filterData:function(data) {
  return this.filtered ? Ext.Array.filter(data, this.filterFn) : data;
}, getFilterFn:function() {
  return this.filterFn;
}, isItemFiltered:function(item) {
  return !this.filterFn(item);
}, getFilterCount:function() {
  var filters = this.items, len = filters.length, i;
  for (i = len - 1; i >= 0; i--) {
    if (filters[i].getDisabled()) {
      len--;
    }
  }
  return len;
}, decodeFilter:function(filter) {
  var options = this.getOptions(), filterRoot = options.getRootProperty(), filterConfig;
  if (filter.isFilter) {
    if (!filter.getRoot()) {
      filter.setRoot(filterRoot);
    }
  } else {
    filterConfig = {root:filterRoot};
    if (Ext.isFunction(filter)) {
      filterConfig.filterFn = filter;
    } else {
      filterConfig = Ext.apply(filterConfig, filter);
      if (filterConfig.fn) {
        filterConfig.filterFn = filterConfig.fn;
        delete filterConfig.fn;
      }
      if (Ext.util.Filter.isInvalid(filterConfig)) {
        return false;
      }
    }
    filter = new Ext.util.Filter(filterConfig);
  }
  return filter;
}, decodeRemoveItems:function(args, index) {
  var me = this, ret = index === undefined ? args : args[index];
  if (!ret.$cloned) {
    if (args.length > index + 1 || !Ext.isIterable(ret)) {
      ret = Ext.Array.slice(args, index);
    }
    var currentFilters = me.items, ln = ret.length, remove = [], filter, i, isFunction, isProp, isString, item, match, n, type;
    for (i = 0; i < ln; i++) {
      filter = ret[i];
      if (filter && filter.isFilter) {
        remove.push(filter);
      } else {
        type = typeof filter;
        isFunction = type === 'function';
        isProp = filter.property !== undefined && filter.value !== undefined;
        isString = type === 'string';
        for (n = currentFilters.length; n-- > 0;) {
          item = currentFilters[n];
          match = false;
          if (isString) {
            match = item.getProperty() === filter;
          } else {
            if (isFunction) {
              match = item.getFilterFn() === filter;
            } else {
              if (isProp) {
                match = item.getProperty() === filter.property && item.getValue() === filter.value;
              }
            }
          }
          if (match) {
            remove.push(item);
          }
        }
      }
    }
    ret = remove;
    ret.$cloned = true;
  }
  return ret;
}, getOptions:function() {
  return this.$filterable || this;
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'FilterCollection'], 0);
Ext.cmd.derive('Ext.util.GroupCollection', Ext.util.Collection, {isGroupCollection:true, config:{grouper:null, groupConfig:null, itemRoot:null}, observerPriority:-100, emptyGroupRetainTime:300000, constructor:function(config) {
  this.emptyGroups = {};
  Ext.util.Collection.prototype.constructor.call(this, config);
  this.on('remove', 'onGroupRemove', this);
}, getItemGroup:function(item) {
  var key = this.getGrouper().getGroupString(item);
  return this.get(key);
}, onCollectionAdd:function(source, details) {
  if (!this.isConfiguring) {
    this.addItemsToGroups(source, details.items, details.at);
  }
}, onCollectionBeforeItemChange:function(source, details) {
  this.changeDetails = details;
}, onCollectionBeginUpdate:function() {
  this.beginUpdate();
}, onCollectionEndUpdate:function() {
  this.endUpdate();
}, onCollectionItemChange:function(source, details) {
  if (!details.indexChanged) {
    this.syncItemGrouping(source, details);
  }
  this.changeDetails = null;
}, onCollectionRefresh:function(source) {
  if (source.generation) {
    var me = this, itemGroupKeys = me.itemGroupKeys = {}, groupData = me.createEntries(source, source.items), entries = groupData.entries, groupKey, i, len, entry, j;
    for (i = 0, len = entries.length; i < len; ++i) {
      entry = entries[i];
      entry.group.splice(0, 1.0E99, entry.items);
      for (j = 0; j < entry.items.length; j++) {
        itemGroupKeys[source.getKey(entry.items[j])] = entry.group;
      }
    }
    entries = null;
    for (groupKey in me.map) {
      if (!(groupKey in groupData.groups)) {
        (entries || (entries = [])).push(me.map[groupKey]);
      }
    }
    if (entries) {
      me.remove(entries);
    }
    me.sortItems();
  }
}, onCollectionRemove:function(source, details) {
  var me = this, changeDetails = me.changeDetails, itemGroupKeys = me.itemGroupKeys || (me.itemGroupKeys = {}), entries, entry, group, i, n, j, removeGroups, item;
  if (source.getCount()) {
    if (changeDetails) {
      item = changeDetails.item || changeDetails.items[0];
      entries = me.createEntries(source, [item]).entries;
      entries[0].group = itemGroupKeys['oldKey' in details ? details.oldKey : source.getKey(item)];
    } else {
      entries = me.createEntries(source, details.items).entries;
    }
    for (i = 0, n = entries.length; i < n; ++i) {
      group = (entry = entries[i]).group;
      if (group) {
        group.remove(entry.items);
      }
      for (j = 0; j < entry.items.length; j++) {
        delete itemGroupKeys[source.getKey(entry.items[j])];
      }
      if (group && !group.length) {
        (removeGroups || (removeGroups = [])).push(group);
      }
    }
  } else {
    me.itemGroupKeys = {};
    removeGroups = me.items;
    for (i = 0, n = removeGroups.length; i < n; ++i) {
      removeGroups[i].clear();
    }
  }
  if (removeGroups) {
    me.remove(removeGroups);
  }
}, onCollectionSort:function(source) {
  var me = this, sorters = source.getSorters(false), items, length, i, group;
  if (sorters) {
    items = me.items;
    length = me.length;
    for (i = 0; i < length; ++i) {
      group = items[i];
      if (group.getSorters() !== sorters) {
        group.setSorters(sorters);
      }
    }
  }
}, onCollectionUpdateKey:function(source, details) {
  if (!details.indexChanged) {
    details.oldIndex = source.indexOf(details.item);
    this.syncItemGrouping(source, details);
  }
}, addItemsToGroups:function(source, items, at, oldIndex) {
  var me = this, itemGroupKeys = me.itemGroupKeys || (me.itemGroupKeys = {}), entries = me.createEntries(source, items).entries, index = -1, sourceStartIndex, entry, i, len, j, group, firstIndex, item;
  for (i = 0, len = entries.length; i < len; ++i) {
    entry = entries[i];
    group = entry.group;
    if (oldIndex || oldIndex === 0) {
      item = items[0];
      if (group.getCount() > 0 && source.getSorters().getCount() === 0) {
        firstIndex = source.indexOf(group.items[0]);
        if (oldIndex < firstIndex) {
          index = 0;
        } else {
          index = oldIndex - firstIndex;
        }
      }
      if (index === -1) {
        group.add(item);
      } else {
        group.insert(index, item);
      }
    } else {
      if (me.length > 1 && at) {
        sourceStartIndex = source.indexOf(entries[0].group.getAt(0));
        at = Math.max(at - sourceStartIndex, 0);
      }
      entry.group.insert(at != null ? at : group.items.length, entry.items);
      for (j = 0; j < entry.items.length; j++) {
        itemGroupKeys[source.getKey(entry.items[j])] = entry.group;
      }
    }
  }
  me.sortItems();
}, createEntries:function(source, items) {
  var me = this, groups = {}, entries = [], grouper = me.getGrouper(), entry, group, groupKey, i, item, len;
  for (i = 0, len = items.length; i < len; ++i) {
    groupKey = grouper.getGroupString(item = items[i]);
    if (!(entry = groups[groupKey])) {
      group = me.getGroup(source, groupKey);
      entries.push(groups[groupKey] = entry = {group:group, items:[]});
    }
    entry.items.push(item);
  }
  return {groups:groups, entries:entries};
}, syncItemGrouping:function(source, details) {
  var me = this, itemGroupKeys = me.itemGroupKeys || (me.itemGroupKeys = {}), item = details.item, oldKey, itemKey, oldGroup, group;
  itemKey = source.getKey(item);
  oldKey = 'oldKey' in details ? details.oldKey : itemKey;
  oldGroup = itemGroupKeys[oldKey];
  group = me.getGroup(source, me.getGrouper().getGroupString(item));
  details.group = group;
  details.oldGroup = oldGroup;
  if (!(details.groupChanged = group !== oldGroup)) {
    oldGroup.itemChanged(item, details.modified, details.oldKey, details);
  } else {
    if (oldGroup) {
      oldGroup.updateKey(item, oldKey, itemKey);
      oldGroup.remove(item);
      if (!oldGroup.length) {
        me.remove(oldGroup);
      }
    }
    me.addItemsToGroups(source, [item], null, details.oldIndex);
  }
  delete itemGroupKeys[oldKey];
  itemGroupKeys[itemKey] = group;
}, getGroup:function(source, key) {
  var me = this, group = me.get(key), autoSort = me.getAutoSort();
  if (group) {
    group.setSorters(source.getSorters());
  } else {
    group = me.emptyGroups[key] || Ext.create(Ext.apply({xclass:'Ext.util.Group', groupKey:key, rootProperty:me.getItemRoot(), sorters:source.getSorters()}, me.getGroupConfig()));
    group.ejectTime = null;
    me.setAutoSort(false);
    me.add(group);
    me.setAutoSort(autoSort);
  }
  return group;
}, getKey:function(item) {
  return item.getGroupKey();
}, createSortFn:function() {
  var me = this, grouper = me.getGrouper(), sorterFn = me.getSorters().getSortFn();
  if (!grouper) {
    return sorterFn;
  }
  return function(lhs, rhs) {
    return grouper.sort(lhs.items[0], rhs.items[0]) || sorterFn(lhs, rhs);
  };
}, updateGrouper:function(grouper) {
  var me = this;
  me.grouped = !!(grouper && me.$groupable.getAutoGroup());
  me.onSorterChange();
  me.onEndUpdateSorters(me.getSorters());
}, destroy:function() {
  var me = this;
  me.$groupable = null;
  me.destroyGroups(me.items);
  Ext.undefer(me.checkRemoveQueueTimer);
  Ext.util.Collection.prototype.destroy.call(this);
}, privates:{destroyGroups:function(groups) {
  var len = groups.length, i;
  for (i = 0; i < len; ++i) {
    groups[i].destroy();
  }
}, onGroupRemove:function(collection, info) {
  var me = this, groups = info.items, emptyGroups = me.emptyGroups, len, group, i;
  groups = Ext.Array.from(groups);
  for (i = 0, len = groups.length; i < len; i++) {
    group = groups[i];
    group.setSorters(null);
    emptyGroups[group.getGroupKey()] = group;
    group.ejectTime = Ext.now();
  }
  me.checkRemoveQueue();
}, checkRemoveQueue:function() {
  var me = this, emptyGroups = me.emptyGroups, groupKey, group, reschedule;
  for (groupKey in emptyGroups) {
    group = emptyGroups[groupKey];
    if (!group.getCount() && Ext.now() - group.ejectTime > me.emptyGroupRetainTime) {
      Ext.destroy(group);
      delete emptyGroups[groupKey];
    } else {
      reschedule = true;
    }
  }
  if (reschedule) {
    Ext.undefer(me.checkRemoveQueueTimer);
    me.checkRemoveQueueTimer = Ext.defer(me.checkRemoveQueue, me.emptyGroupRetainTime, me);
  }
}}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'GroupCollection'], 0);
Ext.cmd.derive('Ext.data.Store', Ext.data.ProxyStore, {config:{data:undefined, clearRemovedOnLoad:true, clearOnPageLoad:true, associatedEntity:null, role:null, session:null}, addRecordsOptions:{addRecords:true}, loadCount:0, complete:false, moveMapCount:0, constructor:function(config) {
  var me = this, data;
  if (config) {
    if (config.buffered) {
      return new Ext.data['BufferedStore'](config);
    }
  }
  Ext.data.ProxyStore.prototype.constructor.call(this, config);
  data = me.inlineData;
  if (data) {
    delete me.inlineData;
    me.loadInlineData(data);
  }
}, applyData:function(data, dataCollection) {
  var me = this;
  me.getFields();
  me.getModel();
  if (data && data.isCollection) {
    dataCollection = data;
  } else {
    if (!dataCollection) {
      dataCollection = me.constructDataCollection();
    }
    if (data) {
      if (me.isInitializing) {
        me.inlineData = data;
      } else {
        me.loadData(data);
      }
    }
  }
  return dataCollection;
}, loadInlineData:function(data) {
  var me = this, proxy = me.getProxy();
  if (proxy && proxy.isMemoryProxy) {
    proxy.setData(data);
    me.suspendEvents();
    me.read();
    me.resumeEvents();
  } else {
    me.removeAll(true);
    me.suspendEvents();
    me.loadData(data);
    me.resumeEvents();
  }
}, onCollectionAdd:function(collection, info) {
  this.loadCount = this.loadCount || 1;
  this.onCollectionAddItems(collection, info.items, info);
}, onCollectionFilterAdd:function(collection, items) {
  this.onCollectionAddItems(collection, items);
}, onCollectionAddItems:function(collection, records, info) {
  var me = this, len = records.length, lastChunk = info ? !info.next : false, removed = me.removed, ignoreAdd = me.ignoreCollectionAdd, session = me.getSession(), replaced = info && info.replaced, i, sync, record, replacedItems;
  if (me.activeRanges) {
    me.syncActiveRanges();
  }
  for (i = 0; i < len; ++i) {
    record = records[i];
    if (session) {
      session.adopt(record);
    }
    if (!ignoreAdd) {
      record.join(me);
      if (removed && removed.length) {
        Ext.Array.remove(removed, record);
      }
      sync = sync || record.phantom || record.dirty;
    }
  }
  if (ignoreAdd) {
    return;
  }
  if (replaced) {
    replacedItems = [];
    do {
      Ext.Array.push(replacedItems, replaced.items);
      replaced = replaced.next;
    } while (replaced);
    me.setMoving(replacedItems, true);
  }
  if (info) {
    if (info.replaced) {
      if (lastChunk) {
        me.fireEvent('datachanged', me);
        me.fireEvent('refresh', me);
      }
    } else {
      me.fireEvent('add', me, records, info.at);
      if (lastChunk) {
        me.fireEvent('datachanged', me);
      }
    }
  }
  if (replacedItems) {
    me.setMoving(replacedItems, false);
  }
  me.needsSync = me.needsSync || sync;
}, onCollectionBeforeItemChange:function(collection, info) {
  var record = info.item, modifiedFieldNames = info.modified || null, type = info.meta;
  this.fireEvent('beforeupdate', this, record, type, modifiedFieldNames, info);
}, onCollectionFilteredItemChange:function() {
  this.onCollectionItemChange.apply(this, arguments);
}, onCollectionItemChange:function(collection, info) {
  var me = this, record = info.item, modifiedFieldNames = info.modified || null, type = info.meta;
  if (me.fireChangeEvent(record)) {
    me.onUpdate(record, type, modifiedFieldNames, info);
    me.fireEvent('update', me, record, type, modifiedFieldNames, info);
    me.fireEvent('datachanged', me);
  }
}, afterChange:function(record, modifiedFieldNames, type) {
  this.getData().itemChanged(record, modifiedFieldNames || null, undefined, type);
}, afterCommit:function(record, modifiedFieldNames) {
  this.afterChange(record, modifiedFieldNames, Ext.data.Model.COMMIT);
}, afterEdit:function(record, modifiedFieldNames) {
  this.needsSync = this.needsSync || record.dirty;
  this.afterChange(record, modifiedFieldNames, Ext.data.Model.EDIT);
}, afterReject:function(record) {
  this.afterChange(record, null, Ext.data.Model.REJECT);
}, afterDrop:function(record) {
  this.getData().remove(record);
}, afterErase:function(record) {
  this.removeFromRemoved(record);
}, addSorted:function(record) {
  var me = this, remote = me.getRemoteSort(), data = me.getData(), index;
  if (remote) {
    data.setSorters(me.getSorters());
  }
  index = data.findInsertionIndex(record);
  if (remote) {
    data.setSorters(null);
  }
  return me.insert(index, record);
}, remove:function(records, isMove, silent) {
  var me = this, data = me.getDataSource(), len, i, toRemove, record;
  if (records) {
    if (records.isModel) {
      if (data.indexOf(records) > -1) {
        toRemove = [records];
        len = 1;
      } else {
        len = 0;
      }
    } else {
      toRemove = [];
      for (i = 0, len = records.length; i < len; ++i) {
        record = records[i];
        if (record && record.isEntity) {
          if (!data.contains(record)) {
            continue;
          }
        } else {
          if (!(record = data.getAt(record))) {
            continue;
          }
        }
        toRemove.push(record);
      }
      len = toRemove.length;
    }
  }
  if (!len) {
    return [];
  }
  me.removeIsMove = isMove === true;
  me.removeIsSilent = silent;
  data.remove(toRemove);
  me.removeIsSilent = false;
  return toRemove;
}, onCollectionRemove:function(collection, info) {
  var me = this, removed = me.removed, records = info.items, len = records.length, index = info.at, replacement = info.replacement, isMove = me.removeIsMove || replacement && Ext.Array.equals(records, replacement.items), silent = me.removeIsSilent, lastChunk = !info.next, data = me.getDataSource(), i, record;
  if (me.ignoreCollectionRemove) {
    return;
  }
  if (replacement) {
    me.setMoving(replacement.items, true);
  }
  for (i = len - 1; i >= 0; i--) {
    record = records[i];
    if (!data.contains(record)) {
      if (removed && !isMove && !record.phantom && !record.erasing) {
        record.removedFrom = index + i;
        removed.push(record);
        me.needsSync = true;
      } else {
        record.unjoin(me);
      }
    }
  }
  if (!silent) {
    if (!replacement || !replacement.items.length) {
      me.fireEvent('remove', me, records, index, isMove);
      if (lastChunk) {
        me.fireEvent('datachanged', me);
      }
    }
  }
  if (replacement) {
    me.setMoving(replacement.items, false);
  }
}, onFilterEndUpdate:function() {
  var me = this;
  if (me.destroying || me.destroyed) {
    return;
  }
  if (me.activeRanges) {
    me.syncActiveRanges();
  }
  Ext.data.ProxyStore.prototype.onFilterEndUpdate.apply(this, arguments);
  me.callObservers('Filter');
}, removeAt:function(index, count) {
  var data = this.getData();
  index = Math.max(index, 0);
  if (index < data.length) {
    if (arguments.length === 1) {
      count = 1;
    } else {
      if (!count) {
        return;
      }
    }
    data.removeAt(index, count);
  }
}, removeAll:function(silent) {
  var me = this, data = me.getData(), records = data.getRange();
  if (data.length) {
    me.removeIsSilent = true;
    me.callObservers('BeforeRemoveAll');
    data.removeAll();
    me.removeIsSilent = false;
    if (!silent) {
      me.fireEvent('clear', me, records);
      me.fireEvent('datachanged', me);
    }
    me.callObservers('AfterRemoveAll', [!!silent]);
  }
  return records;
}, setRecords:function(records) {
  var count = this.getCount();
  ++this.loadCount;
  if (count) {
    this.getData().splice(0, count, records);
  } else {
    this.add(records);
  }
}, splice:function(index, toRemove, toAdd) {
  return this.getData().splice(index, toRemove, toAdd);
}, onProxyLoad:function(operation) {
  var me = this, resultSet = operation.getResultSet(), records = operation.getRecords(), successful = operation.wasSuccessful();
  if (me.destroyed) {
    return;
  }
  if (resultSet) {
    me.totalCount = resultSet.getTotal();
  }
  if (successful) {
    records = me.processAssociation(records);
    me.loadRecords(records, operation.getAddRecords() ? {addRecords:true} : undefined);
    me.attachSummaryRecord(resultSet);
  } else {
    me.loading = false;
  }
  if (me.hasListeners.load) {
    me.fireEvent('load', me, records, successful, operation);
  }
  me.callObservers('AfterLoad', [records, successful, operation]);
}, onProxyWrite:function(operation) {
  if (operation.wasSuccessful()) {
    this.attachSummaryRecord(operation.getResultSet());
  }
  Ext.data.ProxyStore.prototype.onProxyWrite.call(this, operation);
}, filterDataSource:function(fn) {
  var source = this.getDataSource(), items = source.items, len = items.length, ret = [], i;
  for (i = 0; i < len; i++) {
    if (fn.call(source, items[i])) {
      ret.push(items[i]);
    }
  }
  return ret;
}, getNewRecords:function() {
  return this.filterDataSource(this.filterNew);
}, getRejectRecords:function() {
  return this.filterDataSource(this.filterRejects);
}, getUpdatedRecords:function() {
  return this.filterDataSource(this.filterUpdated);
}, loadData:function(data, append) {
  var me = this, length = data.length, newData = [], i;
  for (i = 0; i < length; i++) {
    newData.push(me.createModel(data[i]));
  }
  newData = me.processAssociation(newData);
  me.loadRecords(newData, append ? me.addRecordsOptions : undefined);
}, loadRawData:function(data, append) {
  var me = this, session = me.getSession(), result = me.getProxy().getReader().read(data, session ? {recordCreator:session.recordCreator} : undefined), records = result.getRecords(), success = result.getSuccess();
  if (success) {
    me.totalCount = result.getTotal();
    me.loadRecords(records, append ? me.addRecordsOptions : undefined);
  }
  return success;
}, loadRecords:function(records, options) {
  var me = this, length = records.length, data = me.getData(), addRecords, i, skipSort;
  if (options) {
    addRecords = options.addRecords;
  }
  if (!me.getRemoteSort() && !me.getSortOnLoad()) {
    skipSort = true;
    data.setAutoSort(false);
  }
  if (!addRecords) {
    me.clearData(true);
  }
  me.loading = false;
  me.ignoreCollectionAdd = true;
  me.callObservers('BeforePopulate');
  data.add(records);
  me.ignoreCollectionAdd = false;
  if (skipSort) {
    data.setAutoSort(true);
  }
  for (i = 0; i < length; i++) {
    records[i].join(me);
  }
  if (!me.isEmptyStore) {
    ++me.loadCount;
    me.complete = true;
  }
  if (me.hasListeners.datachanged) {
    me.fireEvent('datachanged', me);
  }
  if (me.hasListeners.refresh) {
    me.fireEvent('refresh', me);
  }
  me.callObservers('AfterPopulate');
}, loadPage:function(page, options) {
  var me = this, size = me.getPageSize();
  me.currentPage = page;
  options = Ext.apply({page:page, start:(page - 1) * size, limit:size, addRecords:!me.getClearOnPageLoad()}, options);
  me.read(options);
}, nextPage:function(options) {
  this.loadPage(this.currentPage + 1, options);
}, previousPage:function(options) {
  this.loadPage(this.currentPage - 1, options);
}, clearData:function(isLoad) {
  var me = this, removed = me.removed, data = me.getDataSource(), clearRemovedOnLoad = me.getClearRemovedOnLoad(), needsUnjoinCheck = removed && isLoad && !clearRemovedOnLoad, records, record, i, len;
  if (data) {
    records = data.items;
    for (i = 0, len = records.length; i < len; ++i) {
      record = records[i];
      if (needsUnjoinCheck && Ext.Array.contains(removed, record)) {
        continue;
      }
      record.unjoin(me);
    }
    me.ignoreCollectionRemove = true;
    me.callObservers('BeforeClear');
    data.removeAll();
    me.ignoreCollectionRemove = false;
    me.callObservers('AfterClear');
  }
  if (removed && (!isLoad || clearRemovedOnLoad)) {
    removed.length = 0;
  }
}, onIdChanged:function(rec, oldId, newId) {
  this.getData().updateKey(rec, oldId);
  this.fireEvent('idchanged', this, rec, oldId, newId);
}, commitChanges:function() {
  var me = this, recs = me.getModifiedRecords(), len = recs.length, i = 0;
  Ext.suspendLayouts();
  me.beginUpdate();
  for (; i < len; i++) {
    recs[i].commit();
  }
  me.cleanRemoved();
  me.endUpdate();
  Ext.resumeLayouts(true);
  me.fireEvent('commit', me);
}, filterNewOnly:function(item) {
  return item.phantom === true;
}, filterRejects:function(item) {
  return item.phantom || item.dirty;
}, rejectChanges:function() {
  var me = this, recs = me.getRejectRecords(), len = recs.length, i, rec, toRemove, sorted, data, currentAutoSort;
  Ext.suspendLayouts();
  me.beginUpdate();
  for (i = 0; i < len; i++) {
    rec = recs[i];
    if (rec.phantom) {
      toRemove = toRemove || [];
      toRemove.push(rec);
    } else {
      rec.reject();
    }
  }
  if (toRemove) {
    me.remove(toRemove);
    for (i = 0, len = toRemove.length; i < len; ++i) {
      toRemove[i].reject();
    }
  }
  recs = me.getRawRemovedRecords();
  if (recs) {
    len = recs.length;
    sorted = !me.getRemoteSort() && me.isSorted();
    if (sorted) {
      data = me.getData();
      currentAutoSort = data.getAutoSort();
      data.setAutoSort(false);
    }
    for (i = len - 1; i >= 0; i--) {
      rec = recs[i];
      rec.reject();
      if (!sorted) {
        me.insert(rec.removedFrom || 0, rec);
      }
    }
    if (sorted) {
      data.setAutoSort(currentAutoSort);
      me.add(recs);
    }
    recs.length = 0;
  }
  me.endUpdate();
  Ext.resumeLayouts(true);
  me.fireEvent('reject', me);
}, doDestroy:function() {
  var me = this, task = me.loadTask, data = me.getData(), source = data.getSource();
  me.clearData();
  me.setSession(null);
  me.observers = null;
  if (task) {
    task.cancel();
    me.loadTask = null;
  }
  if (source) {
    source.destroy();
  }
  Ext.data.ProxyStore.prototype.doDestroy.call(this);
}, privates:{commitOptions:{commit:true}, attachSummaryRecord:function(resultSet) {
  if (!resultSet) {
    return;
  }
  var me = this, summary = resultSet.getSummaryData(), grouper = me.getGrouper(), current = me.summaryRecord, commitOptions = me.commitOptions, groups, len, i, rec, group;
  if (summary) {
    if (current) {
      current.set(summary.data, commitOptions);
    } else {
      me.summaryRecord = summary;
      summary.isRemote = true;
    }
  }
  if (grouper) {
    summary = resultSet.getGroupData();
    if (summary) {
      groups = me.getGroups();
      for (i = 0, len = summary.length; i < len; ++i) {
        rec = summary[i];
        group = groups.getItemGroup(rec);
        if (group) {
          current = group.summaryRecord;
          if (current) {
            current.set(rec.data, commitOptions);
          } else {
            group.summaryRecord = rec;
            rec.isRemote = true;
          }
        }
      }
    }
  }
}, fetch:function(options) {
  options = Ext.apply({}, options);
  this.setLoadOptions(options);
  var operation = this.createOperation('read', options);
  operation.execute();
}, fireChangeEvent:function(record) {
  return this.getDataSource().contains(record);
}, onBeforeLoad:function(operation) {
  this.callObservers('BeforeLoad', [operation]);
}, onRemoteFilterSet:function(filters, remoteFilter) {
  if (filters) {
    this.getData().setFilters(remoteFilter ? null : filters);
  }
  Ext.data.ProxyStore.prototype.onRemoteFilterSet.call(this, filters, remoteFilter);
}, onRemoteSortSet:function(sorters, remoteSort) {
  var data = this.getData();
  if (sorters) {
    data.setSorters(remoteSort ? null : sorters);
  }
  data.setAutoGroup(!remoteSort);
  Ext.data.ProxyStore.prototype.onRemoteSortSet.call(this, sorters, remoteSort);
}, isMoving:function(records, getMap) {
  var map = this.moveMap, moving = 0, len, i;
  if (map) {
    if (records) {
      if (Ext.isArray(records)) {
        for (i = 0, len = records.length; i < len; ++i) {
          moving += map[records[i].id] ? 1 : 0;
        }
      } else {
        if (map[records.id]) {
          ++moving;
        }
      }
    } else {
      moving = getMap ? map : this.moveMapCount;
    }
  }
  return moving;
}, setLoadOptions:function(options) {
  var me = this, pageSize = me.getPageSize(), session, grouper;
  if (me.getRemoteSort() && !options.grouper) {
    grouper = me.getGrouper();
    if (grouper) {
      options.grouper = grouper;
    }
  }
  if (pageSize || 'start' in options || 'limit' in options || 'page' in options) {
    options.page = options.page != null ? options.page : me.currentPage;
    options.start = options.start !== undefined ? options.start : (options.page - 1) * pageSize;
    options.limit = options.limit != null ? options.limit : pageSize;
    me.currentPage = options.page;
  }
  options.addRecords = options.addRecords || false;
  if (!options.recordCreator) {
    session = me.getSession();
    if (session) {
      options.recordCreator = session.recordCreator;
    }
  }
  Ext.data.ProxyStore.prototype.setLoadOptions.call(this, options);
}, setMoving:function(records, isMoving) {
  var me = this, map = me.moveMap || (me.moveMap = {}), len = records.length, i, id;
  for (i = 0; i < len; ++i) {
    id = records[i].id;
    if (isMoving) {
      if (map[id]) {
        ++map[id];
      } else {
        map[id] = 1;
        ++me.moveMapCount;
      }
    } else {
      if (--map[id] === 0) {
        delete map[id];
        --me.moveMapCount;
      }
    }
  }
  if (me.moveMapCount === 0) {
    me.moveMap = null;
  }
}, processAssociation:function(records) {
  var me = this, associatedEntity = me.getAssociatedEntity();
  if (associatedEntity) {
    records = me.getRole().processLoad(me, associatedEntity, records, me.getSession());
  }
  return records;
}}}, 1, 0, 0, 0, ['store.store'], [[Ext.data.LocalStore.prototype.mixinId || Ext.data.LocalStore.$className, Ext.data.LocalStore]], [Ext.data, 'Store'], 0);
Ext.cmd.derive('Ext.data.reader.Array', Ext.data.reader.Json, {alternateClassName:'Ext.data.ArrayReader', config:{totalProperty:undefined, successProperty:undefined}, createFieldAccessor:function(field) {
  var oldMap = field.mapping, index = field.hasMapping() ? oldMap : field.ordinal, result;
  field.mapping = index;
  result = Ext.data.reader.Json.prototype.createFieldAccessor.apply(this, arguments);
  field.mapping = oldMap;
  return result;
}, getModelData:function(raw) {
  return {};
}}, 0, 0, 0, 0, ['reader.array'], 0, [Ext.data.reader, 'Array', Ext.data, 'ArrayReader'], 0);
Ext.cmd.derive('Ext.data.ArrayStore', Ext.data.Store, {alternateClassName:['Ext.data.SimpleStore'], config:{proxy:{type:'memory', reader:'array'}}, loadData:function(data, append) {
  if (this.expandData) {
    var r = [], i = 0, ln = data.length;
    for (; i < ln; i++) {
      r[r.length] = [data[i]];
    }
    data = r;
  }
  Ext.data.Store.prototype.loadData.call(this, data, append);
}}, 0, 0, 0, 0, ['store.array'], 0, [Ext.data, 'ArrayStore', Ext.data, 'SimpleStore'], 0);
Ext.cmd.derive('Ext.data.StoreManager', Ext.util.MixedCollection, {alternateClassName:['Ext.StoreMgr', 'Ext.data.StoreMgr', 'Ext.StoreManager'], singleton:true, register:function() {
  for (var i = 0, s; s = arguments[i]; i++) {
    this.add(s);
  }
}, unregister:function() {
  for (var i = 0, s; s = arguments[i]; i++) {
    this.remove(this.lookup(s));
  }
}, lookup:function(store, defaultType) {
  if (Ext.isArray(store)) {
    var first = store[0], data = store, arrays, fields, i, len;
    if (Ext.isObject(first)) {
      store = {data:data};
    } else {
      arrays = Ext.isArray(first);
      fields = ['field1'];
      if (arrays) {
        for (i = 2, len = first.length; i <= len; ++i) {
          fields.push('field' + i);
        }
      } else {
        data = [];
        for (i = 0, len = store.length; i < len; ++i) {
          data.push([store[i]]);
        }
      }
      return new Ext.data.ArrayStore({data:data, fields:fields, autoDestroy:true, autoCreated:true, expanded:!arrays});
    }
  }
  if (Ext.isString(store)) {
    return this.get(store);
  } else {
    return Ext.Factory.store(store, defaultType);
  }
}, getKey:function(o) {
  return o.storeId;
}, addEmptyStore:function() {
  var emptyStore = this.$emptyStore, destoryable = {destroy:Ext.emptyFn};
  if (!emptyStore) {
    emptyStore = this.$emptyStore = Ext.regStore('ext-empty-store', {proxy:'memory', useModelWarning:false});
    emptyStore.isEmptyStore = true;
    emptyStore.on = emptyStore.addListener = function() {
      return destoryable;
    };
    emptyStore.un = emptyStore.removeListener = Ext.emptyFn;
  }
  this.add(emptyStore);
}, clear:function() {
  this.callParent();
  this.addEmptyStore();
}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'StoreManager', Ext, 'StoreMgr', Ext.data, 'StoreMgr', Ext, 'StoreManager'], function() {
  Ext.regStore = function(id, config) {
    var store;
    if (Ext.isObject(id)) {
      config = id;
    } else {
      if (Ext.data.StoreManager.containsKey(id)) {
        return Ext.data.StoreManager.lookup(id);
      }
      config.storeId = id;
    }
    if (config instanceof Ext.data.Store) {
      store = config;
    } else {
      store = new Ext.data.Store(config);
    }
    Ext.data.StoreManager.register(store);
    return store;
  };
  Ext.getStore = function(name) {
    return Ext.data.StoreManager.lookup(name);
  };
  Ext.data.StoreManager.addEmptyStore();
});
Ext.cmd.derive('Ext.app.domain.Store', Ext.app.EventDomain, {singleton:true, type:'store', prefix:'store.', idMatchRe:/^\#/, constructor:function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.data.AbstractStore);
}, match:function(target, selector) {
  var result = false, alias = target.alias;
  if (selector === '*') {
    result = true;
  } else {
    if (this.idMatchRe.test(selector)) {
      result = target.getStoreId() === selector.substring(1);
    } else {
      if (alias) {
        result = Ext.Array.indexOf(alias, this.prefix + selector) > -1;
      }
    }
  }
  return result;
}}, 1, 0, 0, 0, 0, 0, [Ext.app.domain, 'Store'], 0);
Ext.cmd.derive('Ext.app.Controller', Ext.app.BaseController, {statics:{strings:{model:{getter:'getModel', upper:'Model'}, view:{getter:'getView', upper:'View'}, controller:{getter:'getController', upper:'Controller'}, store:{getter:'getStore', upper:'Store'}, profile:{getter:'getProfile', upper:'Profiles'}}, controllerRegex:/^(.*)\.controller\./, profileRegex:/^(.*)\.profile\./, createGetter:function(baseGetter, name) {
  return function() {
    return this[baseGetter](name);
  };
}, getGetterName:function(name, kindUpper) {
  var fn = 'get', parts = name.split('.'), numParts = parts.length, index;
  for (index = 0; index < numParts; index++) {
    fn += Ext.String.capitalize(parts[index]);
  }
  fn += kindUpper;
  return fn;
}, resolveNamespace:function(cls, data) {
  var Controller = Ext.app.Controller, namespaceRe = cls.prototype.isProfile ? Controller.profileRegex : Controller.controllerRegex, className, namespace, match;
  className = Ext.getClassName(cls);
  namespace = data.$namespace || data.namespace || Ext.app.getNamespace(className) || (match = namespaceRe.exec(className)) && match[1];
  return namespace;
}, processDependencies:function(cls, requires, namespace, kind, names, profileName) {
  if (!names || !names.length) {
    return;
  }
  var me = this, strings = me.strings[kind], o, absoluteName, shortName, name, j, subLn, getterName, getter;
  if (!Ext.isArray(names)) {
    names = [names];
  }
  for (j = 0, subLn = names.length; j < subLn; j++) {
    name = names[j];
    o = me.getFullName(name, kind, namespace, profileName);
    names[j] = absoluteName = o.absoluteName;
    shortName = o.shortName;
    requires.push(absoluteName);
    getterName = me.getGetterName(shortName, strings.upper);
    if (!cls[getterName]) {
      cls[getterName] = getter = me.createGetter(strings.getter, name);
    }
    if (getter && kind !== 'controller') {
      getter['Ext.app.getter'] = true;
    }
  }
}, getFullName:function(name, kind, namespace, profileName) {
  var shortName = name, sep, absoluteName;
  if ((sep = name.indexOf('@')) > 0) {
    shortName = name.substring(0, sep);
    absoluteName = name.substring(sep + 1) + '.' + shortName;
  } else {
    if (name.indexOf('.') > 0 && (Ext.ClassManager.isCreated(name) || this.hasRegisteredPrefix(name))) {
      absoluteName = name;
      shortName = name.replace(namespace + '.' + kind + '.', '');
    } else {
      if (namespace) {
        absoluteName = namespace + '.' + kind + '.' + (profileName ? profileName + '.' + name : name);
        shortName = name;
      } else {
        absoluteName = name;
      }
    }
  }
  return {absoluteName:absoluteName, shortName:shortName};
}, hasRegisteredPrefix:function(className) {
  var inventory = Ext.ClassManager, prefix = inventory.getPrefix(className);
  return prefix && prefix !== className;
}}, models:null, views:null, stores:null, controllers:null, config:{application:null, refs:null, active:true, moduleClassName:null}, onClassExtended:function(cls, data, hooks) {
  var onBeforeClassCreated = hooks.onBeforeCreated;
  hooks.onBeforeCreated = function(cls, data) {
    var Controller = Ext.app.Controller, requires = [], namespace, proto;
    proto = cls.prototype;
    namespace = Controller.resolveNamespace(cls, data);
    if (namespace) {
      proto.$namespace = namespace;
    }
    Controller.processDependencies(proto, requires, namespace, 'model', data.models);
    Controller.processDependencies(proto, requires, namespace, 'view', data.views);
    Controller.processDependencies(proto, requires, namespace, 'store', data.stores);
    Controller.processDependencies(proto, requires, namespace, 'controller', data.controllers);
    Ext.require(requires, Ext.Function.pass(onBeforeClassCreated, arguments, this));
  };
}, constructor:function(config) {
  this.initAutoGetters();
  Ext.app.BaseController.prototype.constructor.call(this, config);
}, normalizeRefs:function(refs) {
  var me = this, newRefs = [];
  if (refs) {
    if (Ext.isObject(refs)) {
      Ext.Object.each(refs, function(key, value) {
        if (Ext.isString(value)) {
          value = {selector:value};
        }
        value.ref = key;
        newRefs.push(value);
      });
    } else {
      if (Ext.isArray(refs)) {
        newRefs = Ext.Array.merge(newRefs, refs);
      }
    }
  }
  refs = me.refs;
  if (refs) {
    me.refs = null;
    refs = me.normalizeRefs(refs);
    if (refs) {
      newRefs = Ext.Array.merge(newRefs, refs);
    }
  }
  return newRefs;
}, getRefMap:function() {
  var me = this, refMap = me._refMap, refs, ref, ln, i;
  if (!refMap) {
    refs = me.getRefs();
    refMap = me._refMap = {};
    if (refs) {
      for (i = 0, ln = refs.length; i < ln; i++) {
        ref = refs[i];
        refMap[ref.ref] = ref.selector;
      }
    }
  }
  return refMap;
}, applyId:function(id) {
  return id || Ext.app.Controller.getFullName(this.$className, 'controller', this.$namespace).shortName;
}, applyRefs:function(refs) {
  return this.normalizeRefs(Ext.clone(refs));
}, updateRefs:function(refs) {
  if (refs) {
    this.ref(refs);
  }
}, initAutoGetters:function() {
  var proto = this.self.prototype, prop, fn;
  for (prop in proto) {
    fn = proto[prop];
    if (fn && fn['Ext.app.getter']) {
      fn.call(this);
    }
  }
}, doInit:function(app) {
  var me = this;
  if (!me._initialized) {
    me.init(app);
    me._initialized = true;
  }
}, finishInit:function(app) {
  var me = this, controllers = me.controllers, controller, i, l;
  if (me._initialized && controllers && controllers.length) {
    for (i = 0, l = controllers.length; i < l; i++) {
      controller = me.getController(controllers[i]);
      controller.finishInit(app);
    }
  }
}, init:Ext.emptyFn, onLaunch:Ext.emptyFn, activate:function() {
  this.setActive(true);
}, deactivate:function() {
  this.setActive(false);
}, isActive:function() {
  return this.getActive();
}, ref:function(refs) {
  var me = this, i = 0, length = refs.length, info, ref, fn;
  refs = Ext.Array.from(refs);
  me.references = me.references || [];
  for (; i < length; i++) {
    info = refs[i];
    ref = info.ref;
    fn = 'get' + Ext.String.capitalize(ref);
    if (!me[fn]) {
      me[fn] = Ext.Function.pass(me.getRef, [ref, info], me);
    }
    me.references.push(ref.toLowerCase());
  }
}, addRef:function(refs) {
  this.ref(refs);
}, getRef:function(ref, info, config) {
  var me = this, refCache = me.refCache || (me.refCache = {}), cached = refCache[ref];
  info = info || {};
  config = config || {};
  Ext.apply(info, config);
  if (info.forceCreate) {
    return Ext.ComponentManager.create(info, 'component');
  }
  if (!cached) {
    if (info.selector) {
      refCache[ref] = cached = Ext.ComponentQuery.query(info.selector)[0];
    }
    if (!cached && info.autoCreate) {
      refCache[ref] = cached = Ext.ComponentManager.create(info, 'component');
    }
    if (cached) {
      cached.on('destroy', function() {
        refCache[ref] = null;
      });
    }
  }
  return cached;
}, hasRef:function(ref) {
  var references = this.references;
  return references && Ext.Array.indexOf(references, ref.toLowerCase()) !== -1;
}, getController:function(id) {
  var app = this.getApplication();
  if (id === this.getId()) {
    return this;
  }
  return app && app.getController(id);
}, getStore:function(name) {
  var storeId, store;
  storeId = name.indexOf('@') === -1 ? name : name.split('@')[0];
  store = Ext.StoreManager.get(storeId);
  if (!store) {
    name = Ext.app.Controller.getFullName(name, 'store', this.$namespace);
    if (name) {
      store = Ext.create(name.absoluteName, {id:storeId});
    }
  }
  return store;
}, getModel:function(modelName) {
  var name = Ext.app.Controller.getFullName(modelName, 'model', this.$namespace), ret = Ext.ClassManager.get(name.absoluteName);
  if (!ret) {
    ret = Ext.data.schema.Schema.lookupEntity(modelName);
  }
  return ret;
}, getProfile:function(name) {
  name = Ext.app.Controller.getFullName(name, 'profile', this.$namespace);
  return name;
}, getView:function(view) {
  var name = Ext.app.Controller.getFullName(view, 'view', this.$namespace);
  return name && Ext.ClassManager.get(name.absoluteName);
}, destroy:function(destroyRefs, fromApp) {
  var me = this, app = me.application, refCache, ref;
  if (!fromApp && app) {
    app.unregister(me);
  }
  me.application = null;
  if (destroyRefs) {
    refCache = me.refCache;
    for (ref in refCache) {
      if (refCache.hasOwnProperty(ref)) {
        Ext.destroy(refCache[ref]);
      }
    }
  }
  Ext.app.BaseController.prototype.destroy.call(this);
}}, 1, 0, 0, 0, 0, 0, [Ext.app, 'Controller'], 0);
Ext.cmd.derive('Ext.app.Application', Ext.app.Controller, {isApplication:true, scope:undefined, namespaces:[], paths:null, config:{name:'', appProperty:'app', profiles:[], currentProfile:null, mainView:{$value:null, lazy:true}, defaultToken:null, glyphFontFamily:null, quickTips:true, router:null}, onClassExtended:function(cls, data, hooks) {
  var Controller = Ext.app.Controller, proto = cls.prototype, requires = [], onBeforeClassCreated, paths, namespace, ns;
  namespace = data.name || cls.superclass.name;
  if (namespace) {
    data.$namespace = namespace;
    Ext.app.addNamespaces(namespace);
  }
  if (data.namespaces) {
    Ext.app.addNamespaces(data.namespaces);
  }
  if (data['paths processed']) {
    delete data['paths processed'];
  } else {
    Ext.app.setupPaths(namespace, 'appFolder' in data ? data.appFolder : cls.superclass.appFolder, data.paths);
  }
  Controller.processDependencies(proto, requires, namespace, 'profile', data.profiles);
  proto.getDependencies(cls, data, requires);
  if (requires.length) {
    onBeforeClassCreated = hooks.onBeforeCreated;
    hooks.onBeforeCreated = function(cls, data) {
      var args = Ext.Array.clone(arguments);
      Ext.require(requires, function() {
        return onBeforeClassCreated.apply(this, args);
      });
    };
  }
}, getDependencies:Ext.emptyFn, constructor:function(config) {
  var me = this;
  Ext.route.Router.application = me;
  Ext.app.Controller.prototype.constructor.call(this, config);
  me.doInit(me);
  Ext.on('appupdate', me.onAppUpdate, me, {single:true});
  this.onProfilesReady();
}, applyId:function(id) {
  return id || this.$className;
}, updateRouter:function(cfg) {
  if (cfg) {
    Ext.route.Router.setConfig(cfg);
  }
}, onAppUpdate:Ext.emptyFn, onProfilesReady:function() {
  var me = this, profiles = me.getProfiles(), length = profiles.length, current, i, instance;
  for (i = 0; i < length; i++) {
    instance = Ext.create(profiles[i], {application:me});
    if (instance.isActive() && !current) {
      current = instance;
      me.setCurrentProfile(current);
    }
  }
  if (current) {
    current.init();
  }
  me.initControllers();
  me.onBeforeLaunch();
  me.finishInitControllers();
}, doInit:function(app) {
  this.initNamespace(app);
  Ext.app.Controller.prototype.doInit.call(this, app);
}, initNamespace:function(me) {
  var appProperty = me.getAppProperty(), ns = Ext.namespace(me.getName());
  if (ns) {
    ns.getApplication = function() {
      return me;
    };
    if (appProperty) {
      if (!ns[appProperty]) {
        ns[appProperty] = me;
      }
    }
  }
}, initControllers:function() {
  var me = this, controllers = Ext.Array.from(me.controllers), profile = me.getCurrentProfile(), i, ln;
  me.controllers = new Ext.util.MixedCollection;
  for (i = 0, ln = controllers.length; i < ln; i++) {
    me.getController(controllers[i]);
  }
  if (profile) {
    controllers = profile.getControllers();
    for (i = 0, ln = controllers.length; i < ln; i++) {
      me.getController(controllers[i]);
    }
  }
}, finishInitControllers:function() {
  var me = this, controllers, i, l;
  controllers = me.controllers.getRange();
  for (i = 0, l = controllers.length; i < l; i++) {
    controllers[i].finishInit(me);
  }
}, launch:Ext.emptyFn, onBeforeLaunch:function() {
  var me = this, History = Ext.util.History, defaultToken = me.getDefaultToken(), currentProfile = me.getCurrentProfile(), controllers, c, cLen, controller, token;
  me.initMainView();
  if (currentProfile) {
    currentProfile.launch();
  }
  me.launch.call(me.scope || me);
  me.launched = true;
  me.fireEvent('launch', me);
  controllers = me.controllers.items;
  cLen = controllers.length;
  for (c = 0; c < cLen; c++) {
    controller = controllers[c];
    controller.onLaunch(me);
  }
  if (!History.ready) {
    History.init();
  }
  token = History.getToken();
  if (token || token === defaultToken) {
    Ext.route.Router.onStateChange(token);
  } else {
    if (defaultToken) {
      History.replace(defaultToken);
    }
  }
  if (Ext.Microloader && Ext.Microloader.appUpdate && Ext.Microloader.appUpdate.updated) {
    Ext.Microloader.fireAppUpdate();
  }
  if (!me.cnsTimer) {
    me.cnsTimer = Ext.defer(Ext.ClassManager.clearNamespaceCache, 2000, Ext.ClassManager);
  }
}, getModuleClassName:function(name, kind) {
  return Ext.app.Controller.getFullName(name, kind, this.getName()).absoluteName;
}, initMainView:function() {
  var me = this, currentProfile = me.getCurrentProfile(), mainView;
  if (currentProfile) {
    mainView = currentProfile.getMainView();
  }
  if (mainView) {
    me.setMainView(mainView);
  } else {
    me.getMainView();
  }
}, applyMainView:function(value) {
  var view = this.getView(value);
  return view.create({$initParent:this.viewport});
}, createController:function(name) {
  return this.getController(name);
}, destroyController:function(controller) {
  if (typeof controller === 'string') {
    controller = this.getController(controller, true);
  }
  Ext.destroy(controller);
}, getController:function(name, preventCreate) {
  var me = this, controllers = me.controllers, className, controller, len, i, c, all;
  controller = controllers.get(name);
  if (!controller) {
    all = controllers.items;
    for (i = 0, len = all.length; i < len; ++i) {
      c = all[i];
      className = c.getModuleClassName();
      if (className && className === name) {
        controller = c;
        break;
      }
    }
  }
  if (!controller && !preventCreate) {
    className = me.getModuleClassName(name, 'controller');
    controller = Ext.create(className, {application:me, moduleClassName:className});
    controllers.add(controller);
    if (me._initialized) {
      controller.doInit(me);
    }
  }
  return controller;
}, unregister:function(controller) {
  this.controllers.remove(controller);
}, getApplication:function() {
  return this;
}, destroy:function(destroyRefs) {
  var me = this, controllers = me.controllers, ns = Ext.namespace(me.getName()), appProp = me.getAppProperty();
  Ext.undefer(me.cnsTimer);
  Ext.un('appupdate', me.onAppUpdate, me);
  Ext.destroy(me.viewport);
  if (controllers) {
    controllers.each(function(controller) {
      controller.destroy(destroyRefs, true);
    });
  }
  me.controllers = null;
  Ext.app.Controller.prototype.destroy.call(this, destroyRefs, true);
  if (ns && ns[appProp] === me) {
    delete ns[appProp];
  }
  if (Ext.route.Router.application === me) {
    Ext.route.Router.application = null;
  }
  if (Ext.app.Application.instance === me) {
    Ext.app.Application.instance = null;
  }
}, updateGlyphFontFamily:function(fontFamily) {
  Ext.setGlyphFontFamily(fontFamily);
}, applyProfiles:function(profiles) {
  var me = this;
  return Ext.Array.map(profiles, function(profile) {
    return me.getModuleClassName(profile, 'profile');
  });
}}, 1, 0, 0, 0, 0, 0, [Ext.app, 'Application'], function() {
  Ext.getApplication = function() {
    return Ext.app.Application.instance;
  };
});
Ext.application = function(config) {
  var createApp = function(App) {
    Ext.onReady(function() {
      var Viewport = Ext.viewport;
      Viewport = Viewport && Viewport['Viewport'];
      if (Viewport && Viewport.setup) {
        Viewport.setup(App.prototype.config.viewport);
      }
      Ext.app.Application.instance = new App;
    });
  };
  if (typeof config === 'string') {
    Ext.require(config, function() {
      createApp(Ext.ClassManager.get(config));
    });
  } else {
    config = Ext.apply({extend:'Ext.app.Application'}, config);
    Ext.app.setupPaths(config.name, config.appFolder, config.paths);
    config['paths processed'] = true;
    Ext.define(config.name + '.$application', config, function() {
      createApp(this);
    });
  }
};
Ext.define('Ext.overrides.app.Application', {override:'Ext.app.Application', autoCreateViewport:false, config:{enableQuickTips:null}, quickTips:true, updateEnableQuickTips:function(enableQuickTips) {
  this.setQuickTips(enableQuickTips);
}, applyMainView:function(mainView) {
  var view, proto, config, protoPlugins, configPlugins;
  if (typeof mainView === 'string') {
    view = this.getView(mainView);
    config = {};
  } else {
    config = mainView;
    view = Ext.ClassManager.getByConfig(mainView);
  }
  proto = view.prototype;
  if (!proto.isViewport) {
    protoPlugins = Ext.Array.from(proto.plugins);
    configPlugins = Ext.Array.from(config.plugins);
    config = Ext.apply({}, config);
    config.plugins = ['viewport'].concat(protoPlugins, configPlugins);
  }
  return view.create(config);
}, getDependencies:function(cls, data, requires) {
  var Controller = Ext.app.Controller, proto = cls.prototype, namespace = data.$namespace, viewportClass = data.autoCreateViewport;
  if (viewportClass) {
    if (viewportClass === true) {
      viewportClass = 'Viewport';
    } else {
      requires.push('Ext.plugin.Viewport');
    }
    Controller.processDependencies(proto, requires, namespace, 'view', viewportClass);
  }
}, onBeforeLaunch:function() {
  var me = this, autoCreateViewport = me.autoCreateViewport;
  if (me.getQuickTips()) {
    me.initQuickTips();
  }
  if (autoCreateViewport) {
    me.initViewport();
  }
  arguments.callee.$previous.apply(this, arguments);
}, getViewportName:function() {
  var name = null, autoCreate = this.autoCreateViewport;
  if (autoCreate) {
    name = autoCreate === true ? 'Viewport' : autoCreate;
  }
  return name;
}, initViewport:function() {
  this.setMainView(this.getViewportName());
}, initQuickTips:function() {
  Ext.tip.QuickTipManager.init();
}});
Ext.cmd.derive('Ext.app.domain.View', Ext.app.EventDomain, {isInstance:true, constructor:function(controller) {
  Ext.app.EventDomain.prototype.constructor.call(this, controller);
  this.controller = controller;
  this.monitoredClasses = [Ext.Widget];
}, match:function(target, selector, controller) {
  var out = false;
  if (selector === '#') {
    out = controller === target.getController();
  } else {
    out = target.is(selector);
  }
  return out;
}, destroy:function() {
  this.controller = null;
  Ext.app.EventDomain.prototype.destroy.call(this);
}}, 1, 0, 0, 0, 0, 0, [Ext.app.domain, 'View'], 0);
Ext.define('Ext.overrides.app.domain.View', {override:'Ext.app.domain.View', constructor:function(controller) {
  (arguments.callee.$previous || Ext.app.EventDomain.prototype.constructor).call(this, controller);
  this.monitoredClasses.push(Ext.Component);
}});
Ext.cmd.derive('Ext.app.ViewController', Ext.app.BaseController, {isViewController:true, factoryConfig:{type:'controller'}, config:{bindings:{$value:null, lazy:true}, closeViewAction:'destroy'}, view:null, constructor:function(config) {
  this.compDomain = new Ext.app.domain.View(this);
  Ext.app.BaseController.prototype.constructor.call(this, config);
}, beforeInit:Ext.emptyFn, init:Ext.emptyFn, initViewModel:Ext.emptyFn, destroy:function() {
  var me = this, domain = me.compDomain, bind, b, key;
  if (me.$hasBinds) {
    bind = me.getBindings();
    for (key in bind) {
      b = bind[key];
      if (b) {
        b.destroy();
      }
    }
  }
  if (domain) {
    domain.unlisten(me);
    domain.destroy();
  }
  me.compDomain = me.view = null;
  Ext.app.BaseController.prototype.destroy.call(this);
}, closeView:function() {
  var view = this.getView(), action;
  if (view) {
    action = this.getCloseViewAction();
    view[action]();
  }
}, control:function(selectors, listeners) {
  var obj = selectors;
  if (Ext.isString(selectors)) {
    obj = {};
    obj[selectors] = listeners;
  }
  this.compDomain.listen(obj, this);
}, listen:function(to, controller) {
  var component = to.component;
  if (component) {
    to = Ext.apply({}, to);
    delete to.component;
    this.control(component);
  }
  this.callParent([to, controller]);
}, applyId:function(id) {
  if (!id) {
    id = Ext.id(null, 'controller-');
  }
  return id;
}, getReferences:function() {
  var view = this.view;
  return view && view.getReferences();
}, getView:function() {
  return this.view;
}, lookup:function(key) {
  var view = this.view;
  return view && view.lookup(key);
}, lookupReference:function(key) {
  return this.lookup(key);
}, getSession:function() {
  var view = this.view;
  return view && view.lookupSession();
}, getViewModel:function() {
  var view = this.view;
  return view && view.lookupViewModel();
}, getStore:function(name) {
  var viewModel = this.getViewModel();
  return viewModel ? viewModel.getStore(name) : null;
}, fireViewEvent:function(eventName, args) {
  var view = this.view, result = false, a = arguments;
  if (view) {
    if (view !== args) {
      a = Ext.Array.slice(a);
      a.splice(1, 0, view);
    }
    result = view.fireEvent.apply(view, a);
  }
  return result;
}, applyBindings:function(bindings) {
  if (!bindings) {
    return null;
  }
  var me = this, viewModel = me.getViewModel(), getBindTemplateScope = me.getBindTemplateScope(), b, fn, descriptor;
  me.$hasBinds = true;
  for (fn in bindings) {
    descriptor = bindings[fn];
    b = null;
    if (descriptor) {
      b = viewModel.bind(descriptor, fn, me);
      b.getTemplateScope = getBindTemplateScope;
    }
    bindings[fn] = b;
  }
  return bindings;
}, privates:{view:null, attachReference:function(component) {
  var view = this.view;
  if (view) {
    view.attachReference(component);
  }
}, getBindTemplateScope:function() {
  return this.scope;
}, initBindings:function() {
  this.getBindings();
}, setView:function(view) {
  this.view = view;
  if (!this.beforeInit.$nullFn) {
    this.beforeInit(view);
  }
}}}, 1, 0, 0, 0, ['controller.controller'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.app, 'ViewController'], 0);
Ext.cmd.derive('Ext.util.Bag', Ext.Base, {isBag:true, constructor:function() {
  this.items = [];
  this.map = {};
}, generation:0, length:0, beginUpdate:Ext.emptyFn, endUpdate:Ext.emptyFn, add:function(item) {
  var me = this, items = me.items, map = me.map, n = 1, old, i, idx, id, it, ret, was;
  if (Ext.isArray(item)) {
    old = ret = [];
    n = item.length;
  }
  for (i = 0; i < n; i++) {
    id = me.getKey(it = old ? item[i] : item);
    idx = map[id];
    if (idx === undefined) {
      items.push(it);
      map[id] = me.length++;
      if (old) {
        old.push(it);
      } else {
        ret = it;
      }
    } else {
      was = items[idx];
      if (old) {
        old.push(was);
      } else {
        ret = was;
      }
      items[idx] = it;
    }
  }
  ++me.generation;
  return ret;
}, clear:function() {
  var me = this, needsClear = me.generation || me.length, ret = needsClear ? me.items : [];
  if (needsClear) {
    me.items = [];
    me.length = 0;
    me.map = {};
    ++me.generation;
  }
  return ret;
}, clone:function() {
  var me = this, ret = new me.self, len = me.length;
  if (len) {
    Ext.apply(ret.map, me.map);
    ret.items = me.items.slice();
    ret.length = me.length;
  }
  return ret;
}, contains:function(item) {
  var ret = false, map = this.map, key;
  if (item != null) {
    key = this.getKey(item);
    if (key in map) {
      ret = this.items[map[key]] === item;
    }
  }
  return ret;
}, containsKey:function(key) {
  return key in this.map;
}, destroy:function() {
  this.items = this.map = null;
  this.callParent();
}, each:function(fn, scope) {
  var items = this.items, len = items.length, i, ret;
  if (len) {
    scope = scope || this;
    items = items.slice(0);
    for (i = 0; i < len; i++) {
      ret = fn.call(scope, items[i], i, len);
      if (ret === false) {
        break;
      }
    }
  }
  return ret;
}, getAt:function(index) {
  var out = null;
  if (index < this.length) {
    out = this.items[index];
  }
  return out;
}, get:function(key) {
  return this.getByKey(key);
}, getByKey:function(key) {
  var map = this.map, ret = key in map ? this.items[map[key]] : null;
  return ret;
}, indexOfKey:function(key) {
  var map = this.map, ret = key in map ? map[key] : -1;
  return ret;
}, last:function() {
  return this.items[this.length - 1];
}, updateKey:function(item, oldKey) {
  var me = this, map = me.map, newKey;
  if (!item || !oldKey) {
    return;
  }
  if ((newKey = me.getKey(item)) !== oldKey) {
    if (me.getAt(map[oldKey]) === item && !(newKey in map)) {
      me.generation++;
      map[newKey] = map[oldKey];
      delete map[oldKey];
    }
  }
}, getCount:function() {
  return this.length;
}, getKey:function(item) {
  return item.id || item.getId();
}, getRange:function(begin, end) {
  var items = this.items, length = items.length, range;
  if (!length) {
    range = [];
  } else {
    range = Ext.Number.clipIndices(length, [begin, end]);
    range = items.slice(range[0], range[1]);
  }
  return range;
}, remove:function(item) {
  var me = this, map = me.map, items = me.items, ret = null, n = 1, changed, old, i, idx, id, last, was;
  if (Ext.isArray(item)) {
    n = item.length;
    old = ret = [];
  }
  if (me.length) {
    for (i = 0; i < n; i++) {
      idx = map[id = me.getKey(old ? item[i] : item)];
      if (idx !== undefined) {
        delete map[id];
        was = items[idx];
        if (old) {
          old.push(was);
        } else {
          ret = was;
        }
        last = items.pop();
        if (idx < --me.length) {
          items[idx] = last;
          map[me.getKey(last)] = idx;
        }
        changed = true;
      }
    }
    if (changed) {
      ++me.generation;
    }
  }
  return ret;
}, removeByKey:function(key) {
  var item = this.getByKey(key);
  if (item) {
    this.remove(item);
  }
  return item || null;
}, replace:function(item) {
  this.add(item);
  return item;
}, sort:function(fn) {
  var me = this, items = me.items, n = items.length, item;
  if (n) {
    Ext.Array.sort(items, fn);
    me.map = {};
    while (n-- > 0) {
      item = items[n];
      me.map[me.getKey(item)] = n;
    }
    ++me.generation;
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Bag'], 0);
Ext.cmd.derive('Ext.util.Scheduler', Ext.Base, {busyCounter:0, lastBusyCounter:0, destroyed:false, firing:null, notifyIndex:-1, nextId:0, orderedItems:null, passes:0, scheduledCount:0, validIdRe:null, config:{cycleLimit:5, preSort:null, tickDelay:5}, suspendOnNotify:true, constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
  this.items = new Ext.util.Bag;
}, destroy:function() {
  var me = this, timer = me.timer;
  if (timer) {
    window.clearTimeout(timer);
    me.timer = null;
  }
  me.items.destroy();
  me.items = me.orderedItems = null;
  me.callParent();
}, add:function(item) {
  var me = this, items = me.items;
  if (items === me.firing) {
    me.items = items = items.clone();
  }
  item.id = item.id || ++me.nextId;
  item.scheduler = me;
  items.add(item);
  if (!me.sortMap) {
    me.orderedItems = null;
  }
}, remove:function(item) {
  var me = this, items = me.items;
  if (me.destroyed) {
    return;
  }
  if (items === me.firing) {
    me.items = items = items.clone();
  }
  if (item.scheduled) {
    me.unscheduleItem(item);
    item.scheduled = false;
  }
  items.remove(item);
  me.orderedItems = null;
}, sort:function() {
  var me = this, items = me.items, sortMap = {}, preSort = me.getPreSort(), i, item;
  me.orderedItems = [];
  me.sortMap = sortMap;
  if (preSort) {
    items.sort(preSort);
  }
  items = items.items;
  for (i = 0; i < items.length; ++i) {
    item = items[i];
    if (!sortMap[item.id]) {
      me.sortItem(item);
    }
  }
  me.sortMap = null;
}, sortItem:function(item) {
  var me = this, sortMap = me.sortMap, orderedItems = me.orderedItems, itemId;
  if (!item.scheduler) {
    me.add(item);
  }
  itemId = item.id;
  if (!(itemId in sortMap)) {
    sortMap[itemId] = 0;
    if (!item.sort.$nullFn) {
      item.sort();
    }
    sortMap[itemId] = 1;
    item.order = me.orderedItems.length;
    orderedItems.push(item);
  }
  return me;
}, sortItems:function(items) {
  var me = this, sortItem = me.sortItem;
  if (items) {
    if (items instanceof Array) {
      Ext.each(items, sortItem, me);
    } else {
      Ext.Object.eachValue(items, sortItem, me);
    }
  }
  return me;
}, applyPreSort:function(preSort) {
  if (typeof preSort === 'function') {
    return preSort;
  }
  var parts = preSort.split(','), direction = [], length = parts.length, c, i, s;
  for (i = 0; i < length; ++i) {
    direction[i] = 1;
    s = parts[i];
    if ((c = s.charAt(0)) === '-') {
      direction[i] = -1;
    } else {
      if (c !== '+') {
        c = 0;
      }
    }
    if (c) {
      parts[i] = s.substring(1);
    }
  }
  return function(lhs, rhs) {
    var ret = 0, i, prop, v1, v2;
    for (i = 0; !ret && i < length; ++i) {
      prop = parts[i];
      v1 = lhs[prop];
      v2 = rhs[prop];
      ret = direction[i] * (v1 < v2 ? -1 : v2 < v1 ? 1 : 0);
    }
    return ret;
  };
}, notify:function() {
  var me = this, timer = me.timer, cyclesLeft = me.getCycleLimit(), globalEvents = Ext.GlobalEvents, suspend = me.suspendOnNotify, busyCounter, i, item, len, queue, firedEvent;
  if (timer) {
    window.clearTimeout(timer);
    me.timer = null;
  }
  if (!me.firing && me.scheduledCount) {
    if (suspend) {
      Ext.suspendLayouts();
    }
    while (me.scheduledCount) {
      if (cyclesLeft) {
        --cyclesLeft;
      } else {
        me.firing = null;
        break;
      }
      if (!firedEvent) {
        firedEvent = true;
        if (globalEvents.hasListeners.beforebindnotify) {
          globalEvents.fireEvent('beforebindnotify', me);
        }
      }
      ++me.passes;
      if (!(queue = me.orderedItems)) {
        me.sort();
        queue = me.orderedItems;
      }
      len = queue.length;
      if (len) {
        me.firing = me.items;
        for (i = 0; i < len; ++i) {
          item = queue[i];
          if (item.scheduled) {
            item.scheduled = false;
            --me.scheduledCount;
            me.notifyIndex = i;
            item.react();
            if (!me.scheduledCount) {
              break;
            }
          }
        }
      }
    }
    me.firing = null;
    me.notifyIndex = -1;
    if (suspend) {
      Ext.resumeLayouts(true);
    }
  }
  if ((busyCounter = me.busyCounter) !== me.lastBusyCounter) {
    if (!(me.lastBusyCounter = busyCounter)) {
      me.fireEvent('idle', me);
    }
  }
}, onTick:function() {
  this.timer = null;
  this.notify();
}, scheduleItem:function(item) {
  var me = this;
  ++me.scheduledCount;
  if (!me.timer && !me.firing) {
    me.scheduleTick();
  }
}, scheduleTick:function() {
  var me = this;
  if (!me.destroyed && !me.timer) {
    me.timer = Ext.defer(me.onTick, me.getTickDelay(), me);
  }
}, unscheduleItem:function(item) {
  if (this.scheduledCount) {
    --this.scheduledCount;
  }
}, adjustBusy:function(adjustment) {
  var me = this, busyCounter = me.busyCounter + adjustment;
  me.busyCounter = busyCounter;
  if (busyCounter) {
    if (!me.lastBusyCounter) {
      me.lastBusyCounter = busyCounter;
      me.fireEvent('busy', me);
    }
  } else {
    if (me.lastBusyCounter && !me.timer) {
      me.scheduleTick();
    }
  }
}, isBusy:function() {
  return !this.isIdle();
}, isIdle:function() {
  return !(this.busyCounter + this.lastBusyCounter);
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.util, 'Scheduler'], 0);
Ext.cmd.derive('Ext.data.Batch', Ext.Base, {config:{pauseOnException:false}, current:-1, total:0, running:false, complete:false, exception:false, constructor:function(config) {
  var me = this;
  me.mixins.observable.constructor.call(me, config);
  me.operations = [];
  me.exceptions = [];
}, add:function(operation) {
  var me = this, i, len;
  if (Ext.isArray(operation)) {
    for (i = 0, len = operation.length; i < len; ++i) {
      me.add(operation[i]);
    }
  } else {
    me.total++;
    operation.setBatch(me);
    me.operations.push(operation);
  }
  return me;
}, sort:function() {
  this.operations.sort(this.sortFn);
}, sortFn:function(operation1, operation2) {
  var ret = operation1.order - operation2.order;
  if (ret) {
    return ret;
  }
  var entityType1 = operation1.entityType, entityType2 = operation2.entityType, rank;
  if (!entityType1 || !entityType2) {
    return 0;
  }
  if (!(rank = entityType1.rank)) {
    entityType1.schema.rankEntities();
    rank = entityType1.rank;
  }
  return (rank - entityType2.rank) * operation1.foreignKeyDirection;
}, start:function(index) {
  var me = this;
  if (!me.operations.length || me.running) {
    return me;
  }
  me.exceptions.length = 0;
  me.exception = false;
  me.running = true;
  return me.runOperation(Ext.isDefined(index) ? index : me.current + 1);
}, retry:function() {
  return this.start(this.current);
}, runNextOperation:function() {
  var me = this;
  if (me.running) {
    me.runOperation(me.current + 1);
  }
  return me;
}, pause:function() {
  this.running = false;
  return this;
}, getOperations:function() {
  return this.operations;
}, getExceptions:function() {
  return this.exceptions;
}, getCurrent:function() {
  var out = null, current = this.current;
  if (!(current === -1 || this.complete)) {
    out = this.operations[current];
  }
  return out;
}, getTotal:function() {
  return this.total;
}, isRunning:function() {
  return this.running;
}, isComplete:function() {
  return this.complete;
}, hasException:function() {
  return this.exception;
}, runOperation:function(index) {
  var me = this, operations = me.operations, operation = operations[index];
  if (operation === undefined) {
    me.running = false;
    me.complete = true;
    me.fireEvent('complete', me, operations[operations.length - 1]);
  } else {
    me.current = index;
    operation.setInternalCallback(me.onOperationComplete);
    operation.setInternalScope(me);
    operation.execute();
  }
  return me;
}, onOperationComplete:function(operation) {
  var me = this, exception = operation.hasException();
  if (exception) {
    me.exception = true;
    me.exceptions.push(operation);
    me.fireEvent('exception', me, operation);
  }
  if (exception && me.getPauseOnException()) {
    me.pause();
  } else {
    me.fireEvent('operationcomplete', me, operation);
    me.runNextOperation();
  }
}}, 1, 0, 0, 0, 0, [['observable', Ext.mixin.Observable]], [Ext.data, 'Batch'], 0);
Ext.cmd.derive('Ext.data.matrix.Slice', Ext.Base, {constructor:function(side, id) {
  this.id = id;
  this.side = side;
  this.members = {};
}, attach:function(store) {
  var me = this;
  me.store = store;
  store.matrix = me;
  store.on('load', me.onStoreLoad, me, {single:true});
}, commit:function() {
  var members = this.members, id;
  for (id in members) {
    members[id][2] = 0;
  }
}, onStoreLoad:function(store) {
  this.update(store.getData().items, 0);
}, update:function(recordsOrIds, state) {
  var me = this, MatrixSlice = Ext.data.matrix.Slice, side = me.side, assocIndex = side.index, length = recordsOrIds.length, id = me.id, members = me.members, otherSide = side.inverse, otherSlices = otherSide.slices, assoc, call, i, item, otherId, otherSlice, record;
  for (i = 0; i < length; ++i) {
    call = record = null;
    item = recordsOrIds[i];
    otherId = item.isEntity ? (record = item).id : item;
    assoc = members[otherId];
    if (state < 0 && assoc && assoc[2] === 1) {
      delete members[otherId];
      otherSlice = otherSlices[otherId];
      if (otherSlice) {
        delete otherSlice.members[id];
      }
      call = 1;
    } else {
      if (!assoc) {
        assoc = [otherId, otherId, state];
        assoc[assocIndex] = id;
        members[otherId] = assoc;
        otherSlice = otherSlices[otherId];
        if (!otherSlice) {
          otherSlices[otherId] = otherSlice = new MatrixSlice(otherSide, otherId);
        }
        otherSlice.members[id] = assoc;
        call = 1;
      } else {
        if (state !== assoc[2] && state !== 0 && !(state === 1 && assoc[2] === 0)) {
          assoc[2] = state;
          otherSlice = otherSlices[otherId];
          call = 1;
        }
      }
    }
    if (call) {
      if (me.notify) {
        me.notify.call(me.scope, me, otherId, state);
      }
      if (otherSlice && otherSlice.notify) {
        otherSlice.notify.call(otherSlice.scope, otherSlice, id, state);
      }
    }
  }
}, updateId:function(newId) {
  var me = this, oldId = me.id, side = me.side, slices = side.slices, slice = slices[oldId], members = slice.members, index = side.index, otherSlices = side.inverse.slices, assoc, otherId, otherMembers;
  me.id = newId;
  slices[newId] = slice;
  delete slices[oldId];
  for (otherId in members) {
    assoc = members[otherId];
    assoc[index] = newId;
    otherMembers = otherSlices[otherId].members;
    otherMembers[newId] = otherMembers[oldId];
    delete otherMembers[oldId];
  }
}, destroy:function() {
  var me = this, store = me.store;
  if (store) {
    store.matrix = null;
    store.un('load', me.onStoreLoad, me);
  }
  me.notify = me.scope = me.store = me.side = me.members = null;
  me.callParent();
}}, 1, 0, 0, 0, 0, 0, [Ext.data.matrix, 'Slice'], 0);
Ext.cmd.derive('Ext.data.matrix.Side', Ext.Base, {constructor:function(matrix, index, role) {
  var me = this;
  me.matrix = matrix;
  me.index = index;
  me.role = role;
  me.slices = {};
}, commit:function() {
  var slices = this.slices, id;
  for (id in slices) {
    slices[id].commit();
  }
}, get:function(id1, id2) {
  var me = this, slices = me.slices, slice = slices[id1] || (slices[id1] = new Ext.data.matrix.Slice(me, id1));
  return id2 || id2 === 0 ? slice.members[id2] : slice;
}, update:function(id1, id2, state) {
  var slice = this.get(id1);
  return slice.update(id2, state);
}, updateId:function(oldId, newId) {
  var slice = this.get(oldId);
  if (slice) {
    slice.updateId(newId);
  }
}, destroy:function() {
  var me = this, slices = me.slices, id;
  for (id in slices) {
    slices[id].destroy();
  }
  me.inverse = me.matrix = me.role = me.slices = null;
  me.callParent();
}}, 1, 0, 0, 0, 0, 0, [Ext.data.matrix, 'Side'], 0);
Ext.cmd.derive('Ext.data.matrix.Matrix', Ext.Base, {constructor:function(session, matrix) {
  var me = this, association = matrix.isManyToMany ? matrix : session.getSchema().getAssociation(matrix), Side = Ext.data.matrix.Side, left = new Side(me, 0, association.left), right = new Side(me, 1, association.right);
  me.association = association;
  me.session = session;
  me.left = left;
  me.right = right;
  left.inverse = right;
  right.inverse = left;
}, commit:function() {
  this.left.commit();
  this.right.commit();
}, update:function(id1, id2, state) {
  return this.left.update(id1, id2, state);
}, updateId:function(record, oldId, newId) {
  var Type = record.self, left = this.left, right = this.right, matchSide;
  if (Type === left.role.cls) {
    matchSide = left;
  }
  if (Type === right.role.cls) {
    matchSide = right;
  }
  if (matchSide) {
    matchSide.updateId(oldId, newId);
  }
}, destroy:function() {
  var me = this;
  me.left.destroy();
  me.right.destroy();
  me.association = me.session = me.left = me.right = null;
  me.callParent();
}}, 1, 0, 0, 0, 0, 0, [Ext.data.matrix, 'Matrix'], 0);
Ext.cmd.derive('Ext.data.session.ChangesVisitor', Ext.Base, {constructor:function(session) {
  var me = this, crud;
  me.session = session;
  crud = session.getCrudProperties();
  me.result = null;
  me.writerOptions = {};
  me.createKey = crud.create;
  me.readKey = crud.read;
  me.updateKey = crud.update;
  me.dropKey = crud.drop;
}, onDirtyRecord:function(record) {
  var me = this, crud = me.crud, created = record.phantom, dropped = record.dropped, updated = !created && !dropped, type = record.$className, prop = created || dropped ? 'allDataOptions' : 'partialDataOptions', writerOptions = me.writerOptions, name = record.entityName, options, bucket, entry, result;
  if (created && dropped) {
    return false;
  }
  crud = created ? me.createKey : dropped ? me.dropKey : me.updateKey;
  writerOptions = writerOptions[type] || (writerOptions[type] = {});
  if (dropped) {
    if (!(options = writerOptions.drop)) {
      writerOptions.drop = options = {all:record.getProxy().getWriter().getWriteAllFields()};
    }
    if (!options.all) {
      entry = record.id;
    }
  }
  if (!entry) {
    if (!(options = writerOptions[prop])) {
      options = record.getProxy().getWriter().getConfig(prop);
      writerOptions[prop] = options = Ext.Object.chain(options);
      me.setupOptions(options);
    }
    entry = record.getData(options);
  }
  result = me.result || (me.result = {});
  bucket = result[name] || (result[name] = {});
  bucket = bucket[crud] || (bucket[crud] = []);
  bucket.push(entry);
}, setupOptions:function(options) {
  options.serialize = true;
}, onMatrixChange:function(association, id1, id2, state) {
  var me = this, name = association.left.type, assocName = association.right.role, operation = state < 0 ? me.dropKey : me.createKey, bucket, result;
  result = me.result || (me.result = {});
  bucket = result[name] || (result[name] = {});
  bucket = bucket[assocName] || (bucket[assocName] = {});
  bucket = bucket[operation] || (bucket[operation] = {});
  bucket = bucket[id1] || (bucket[id1] = []);
  bucket.push(id2);
}}, 1, 0, 0, 0, 0, 0, [Ext.data.session, 'ChangesVisitor'], 0);
Ext.cmd.derive('Ext.data.session.ChildChangesVisitor', Ext.data.session.ChangesVisitor, {constructor:function() {
  this.seen = {};
  Ext.data.session.ChangesVisitor.prototype.constructor.apply(this, arguments);
}, setupOptions:function(options) {
  Ext.data.session.ChangesVisitor.prototype.setupOptions.call(this, options);
  options.serialize = false;
}, onDirtyRecord:function(record) {
  if (Ext.data.session.ChangesVisitor.prototype.onDirtyRecord.apply(this, arguments) !== false) {
    if (!record.$source && (record.dropped || !record.phantom)) {
      this.readEntity(record);
    }
  }
}, readEntity:function(record) {
  var me = this, readKey = me.readKey, name = record.entityName, id = record.id, seen = me.seen, seenKey = name + id, result, bucket;
  if (seen[seenKey]) {
    return;
  }
  seen[seenKey] = true;
  result = me.result || (me.result = {});
  bucket = result[name] || (result[name] = {});
  bucket = bucket[readKey] || (bucket[readKey] = []);
  bucket.push(Ext.apply({}, record.modified, record.data));
}}, 1, 0, 0, 0, 0, 0, [Ext.data.session, 'ChildChangesVisitor'], 0);
Ext.cmd.derive('Ext.data.session.BatchVisitor', Ext.Base, {map:null, constructor:function(batch) {
  this.batch = batch;
}, getBatch:function(sort) {
  var map = this.map, batch = this.batch, bucket, entity, name, operation, operationType, proxy, batchActions, records, len, i;
  if (map) {
    if (!batch) {
      batch = new Ext.data.Batch;
    }
    for (name in map) {
      bucket = map[name];
      entity = bucket.entity;
      proxy = entity.getProxy();
      batchActions = proxy.getBatchActions();
      delete bucket.entity;
      for (operationType in bucket) {
        if (batchActions) {
          operation = proxy.createOperation(operationType, {records:bucket[operationType]});
          operation.entityType = entity;
          batch.add(operation);
        } else {
          records = bucket[operationType];
          for (i = 0, len = records.length; i < len; ++i) {
            operation = proxy.createOperation(operationType, {records:[records[i]]});
            operation.entityType = entity;
            batch.add(operation);
          }
        }
      }
    }
  }
  if (batch && sort !== false) {
    batch.sort();
  }
  return batch;
}, onDirtyRecord:function(record) {
  var me = this, operation = record.phantom ? 'create' : record.dropped ? 'destroy' : 'update', name = record.$className, map = me.map || (me.map = {}), bucket = map[name] || (map[name] = {entity:record.self});
  bucket = bucket[operation] || (bucket[operation] = []);
  bucket.push(record);
}}, 1, 0, 0, 0, 0, 0, [Ext.data.session, 'BatchVisitor'], 0);
Ext.cmd.derive('Ext.mixin.Dirty', Ext.Base, {mixinId:'dirty', config:{dirty:{$value:false, lazy:true}}, dirty:false, _dirtyRecordCount:0, ignoreDirty:false, recordStateIsDirtyState:true, isDirty:function() {
  return this.getDirty();
}, applyDirty:function(dirty) {
  return this.ignoreDirty ? false : dirty;
}, updateDirty:function(dirty) {
  var me = this;
  me.dirty = dirty;
  if (me.fireEvent && !me.isDirtyInitializing) {
    me.fireDirtyChange();
  }
}, clearRecordStates:function() {
  var me = this, counters = me._crudCounters;
  if (counters) {
    counters.C = counters.U = counters.D = 0;
  }
  me._dirtyRecordCount = 0;
  if (me.recordStateIsDirtyState) {
    me.setDirty(false);
  }
}, fireDirtyChange:function() {
  var me = this;
  if (!me.ignoreDirty && me.hasListeners.dirtychange) {
    me.fireEvent('dirtychange', me, me.dirty);
  }
}, trackRecordState:function(record, initial) {
  var me = this, counters = me._crudCounters || (me._crudCounters = {C:0, R:0, U:0, D:0}), dirtyRecordCountWas = me._dirtyRecordCount, state = record.crudState, stateWas = record.crudStateWas, changed, dirtyRecordCount;
  if (initial || state !== stateWas) {
    if (!initial && stateWas) {
      --counters[stateWas];
    }
    if (!(record.phantom && state === 'D')) {
      ++counters[state];
    }
    me._dirtyRecordCount = dirtyRecordCount = counters.C + counters.U + counters.D;
    changed = !dirtyRecordCount !== !dirtyRecordCountWas;
    if (changed && me.recordStateIsDirtyState) {
      me.setDirty(dirtyRecordCount > 0);
    }
  }
  return changed;
}, untrackRecordState:function(record) {
  var me = this, counters = me._crudCounters, dirtyRecordCountWas = me._dirtyRecordCount, state = record.crudState, changed, dirtyRecordCount;
  if (counters && state !== 'D' && !record.erased) {
    --counters[state];
    me._dirtyRecordCount = dirtyRecordCount = counters.C + counters.U + counters.D;
    changed = !dirtyRecordCount !== !dirtyRecordCountWas;
    if (changed && me.recordStateIsDirtyState) {
      me.setDirty(dirtyRecordCount > 0);
    }
  }
  return changed;
}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Dirty'], 0);
Ext.cmd.derive('Ext.data.Session', Ext.Base, {isSession:true, config:{schema:'default', parent:null, autoDestroy:true, crudProperties:{create:'C', read:'R', update:'U', drop:'D'}}, crudOperations:[{type:'R', entityMethod:'readEntities'}, {type:'C', entityMethod:'createEntities'}, {type:'U', entityMethod:'updateEntities'}, {type:'D', entityMethod:'dropEntities'}], crudKeys:{C:1, R:1, U:1, D:1}, statics:{nextId:1}, constructor:function(config) {
  var me = this;
  me.data = {};
  me.matrices = {};
  me.id = Ext.data.Session.nextId++;
  me.identifierCache = {};
  me.recordCreator = me.recordCreator.bind(me);
  me.mixins.observable.constructor.call(me, config);
}, destroy:function() {
  var me = this, matrices = me.matrices, data = me.data, entityName, entities, record, id;
  for (id in matrices) {
    matrices[id].destroy();
  }
  for (entityName in data) {
    entities = data[entityName];
    for (id in entities) {
      record = entities[id].record;
      if (record) {
        record.$source = null;
        record.unjoin(me);
      }
    }
  }
  me.identifierCache = me.recordCreator = me.matrices = me.data = null;
  me.setSchema(null);
  me.callParent();
}, adopt:function(record) {
  var me = this, associations = record.associations, roleName;
  if (record.session !== me) {
    me.add(record);
    if (associations) {
      for (roleName in associations) {
        associations[roleName].adoptAssociated(record, me);
      }
    }
  }
}, commit:function() {
  var me = this, data = me.data, matrices = me.matrices, dirtyWas = me.getDirty(), entityName, entities, id, record;
  me.suspendEvent('dirtychange');
  for (entityName in data) {
    entities = data[entityName];
    for (id in entities) {
      record = entities[id].record;
      if (record) {
        record.commit();
      }
    }
  }
  for (id in matrices) {
    matrices[id].commit();
  }
  me.clearRecordStates();
  me.resumeEvent('dirtychange');
  if (me.getDirty() !== dirtyWas) {
    me.fireDirtyChange();
  }
}, createRecord:function(type, data, preventAdd) {
  var Model = type.$isClass ? type : this.getSchema().getEntity(type), parent = this.getParent(), id;
  if (data && parent) {
    id = Model.getIdFromData(data);
    if (parent.peekRecord(Model, id)) {
      Ext.raise('A parent session already contains an entry for ' + Model.entityName + ': ' + id);
    }
  }
  return new Model(data, preventAdd ? null : this);
}, getChanges:function() {
  var visitor = new Ext.data.session.ChangesVisitor(this);
  this.visitData(visitor);
  return visitor.result;
}, getChangesForParent:function() {
  var visitor = new Ext.data.session.ChildChangesVisitor(this);
  this.visitData(visitor);
  return visitor.result;
}, getRecord:function(type, id, autoLoad) {
  var me = this, wasInstance = type.isModel, record, Model, parent, parentRec;
  if (wasInstance) {
    wasInstance = type;
    id = type.id;
    type = type.self;
  }
  record = me.peekRecord(type, id);
  if (!record) {
    Model = type.$isClass ? type : me.getSchema().getEntity(type);
    parent = me.getParent();
    if (parent) {
      parentRec = parent.peekRecord(Model, id);
    }
    if (parentRec) {
      if (parentRec.isLoading()) {
        wasInstance = false;
      } else {
        record = parentRec.copy(undefined, me);
        record.$source = parentRec;
      }
    }
    if (!record) {
      if (wasInstance) {
        record = wasInstance;
        me.adopt(record);
      } else {
        record = Model.createWithId(id, null, me);
        if (autoLoad !== false) {
          record.load(Ext.isObject(autoLoad) ? autoLoad : undefined);
        }
      }
    }
  }
  return record;
}, getSaveBatch:function(sort) {
  var visitor = new Ext.data.session.BatchVisitor;
  this.visitData(visitor);
  return visitor.getBatch(sort);
}, onInvalidAssociationEntity:function(entityType, id) {
  Ext.raise('Unable to read association entity: ' + this.getModelIdentifier(entityType, id));
}, onInvalidEntityCreate:function(entityType, id) {
  Ext.raise('Cannot create, record already not exists: ' + this.getModelIdentifier(entityType, id));
}, onInvalidEntityDrop:function(entityType, id) {
  Ext.raise('Cannot drop, record does not exist: ' + this.getModelIdentifier(entityType, id));
}, onInvalidEntityRead:function(entityType, id) {
  Ext.raise('Cannot read, record already not exists: ' + this.getModelIdentifier(entityType, id));
}, onInvalidEntityUpdate:function(entityType, id, dropped) {
  if (dropped) {
    Ext.raise('Cannot update, record dropped: ' + this.getModelIdentifier(entityType, id));
  } else {
    Ext.raise('Cannot update, record does not exist: ' + this.getModelIdentifier(entityType, id));
  }
}, peekRecord:function(type, id, deep) {
  var entityType = type.$isClass ? type : this.getSchema().getEntity(type), entityName = entityType.entityName, entry = this.data[entityName], ret, parent;
  entry = entry && entry[id];
  ret = entry && entry.record;
  if (!ret && deep) {
    parent = this.getParent();
    ret = parent && parent.peekRecord(type, id, deep);
  }
  return ret || null;
}, save:function() {
  var me = this, parent = me.getParent(), visitor;
  if (parent) {
    visitor = new Ext.data.session.ChildChangesVisitor(me);
    me.visitData(visitor);
    parent.update(visitor.result);
    me.commit();
  }
}, spawn:function() {
  return new this.self({schema:this.getSchema(), parent:this});
}, update:function(data) {
  var me = this, schema = me.getSchema(), crudOperations = me.crudOperations, len = crudOperations.length, crudKeys = me.crudKeys, dirtyWas = me.getDirty(), entityName, entityType, entityInfo, i, operation, item, associations, key, role, associationData;
  me.suspendEvent('dirtychange');
  me.getSchema().processKeyChecks(true);
  for (entityName in data) {
    entityType = schema.getEntity(entityName);
    entityInfo = data[entityName];
    for (i = 0; i < len; ++i) {
      operation = crudOperations[i];
      item = entityInfo[operation.type];
      if (item) {
        me[operation.entityMethod](entityType, item);
      }
    }
  }
  for (entityName in data) {
    entityType = schema.getEntity(entityName);
    associations = entityType.associations;
    entityInfo = data[entityName];
    for (key in entityInfo) {
      if (crudKeys[key]) {
        continue;
      }
      role = associations[key];
      associationData = entityInfo[role.role];
      role.processUpdate(me, associationData);
    }
  }
  me.resumeEvent('dirtychange');
  if (me.getDirty() !== dirtyWas) {
    me.fireDirtyChange();
  }
}, afterCommit:function(record) {
  this.trackRecordState(record);
}, afterDrop:function(record) {
  this.trackRecordState(record);
}, afterEdit:function(record) {
  this.trackRecordState(record);
}, afterErase:function(record) {
  this.evict(record);
}, afterReject:function(record) {
  this.trackRecordState(record);
}, privates:{add:function(record) {
  var me = this, id = record.id, entry = me.getEntry(record.self, id), associations, roleName;
  record.session = me;
  entry.record = record;
  me.trackRecordState(record, true);
  me.registerReferences(record);
  associations = record.associations;
  for (roleName in associations) {
    associations[roleName].checkMembership(me, record);
  }
}, applySchema:function(schema) {
  return Ext.data.schema.Schema.get(schema);
}, createEntities:function(entityType, items) {
  var me = this, len = items.length, i, data, rec, id;
  for (i = 0; i < len; ++i) {
    data = items[i];
    id = entityType.getIdFromData(data);
    rec = me.peekRecord(entityType, id);
    if (!rec) {
      rec = me.createRecord(entityType, data, true);
      rec.phantom = true;
      rec.crudState = 'C';
      me.add(rec);
      rec.crudStateWas = 'C';
    } else {
      me.onInvalidEntityCreate(entityType, id);
    }
  }
}, dropEntities:function(entityType, ids) {
  var len = ids.length, i, rec, id, extractId;
  if (len) {
    extractId = Ext.isObject(ids[0]);
  }
  for (i = 0; i < len; ++i) {
    id = ids[i];
    if (extractId) {
      id = entityType.getIdFromData(id);
    }
    rec = this.peekRecord(entityType, id);
    if (rec) {
      rec.drop();
    } else {
      this.onInvalidEntityDrop(entityType, id);
    }
  }
}, evict:function(record) {
  var me = this, entityName = record.entityName, entities = me.data[entityName], id = record.id;
  if (entities && entities[id]) {
    me.untrackRecordState(record);
    record.unjoin(me);
    delete entities[id];
  }
}, getEntityList:function(entityType, ids) {
  var len = ids.length, i, id, rec, invalid;
  for (i = 0; i < len; ++i) {
    id = ids[i];
    rec = this.peekRecord(entityType, id);
    if (rec) {
      ids[i] = rec;
    } else {
      invalid = true;
      ids[i] = null;
      this.onInvalidAssociationEntity(entityType, id);
    }
  }
  if (invalid) {
    ids = Ext.Array.clean(ids);
  }
  return ids;
}, getEntry:function(type, id) {
  if (type.isModel) {
    id = type.getId();
    type = type.self;
  }
  var entityType = type.$isClass ? type : this.getSchema().getEntity(type), entityName = entityType.entityName, data = this.data, entry;
  entry = data[entityName] || (data[entityName] = {});
  entry = entry[id] || (entry[id] = {});
  return entry;
}, getRefs:function(record, role, includeParent) {
  var entry = this.getEntry(record), refs = entry && entry.refs && entry.refs[role.role], parent = includeParent && this.getParent(), parentRefs, id, rec;
  if (parent) {
    parentRefs = parent.getRefs(record, role);
    if (parentRefs) {
      for (id in parentRefs) {
        rec = parentRefs[id];
        if (!refs || !refs[id]) {
          this.getRecord(rec.self, rec.id);
        }
      }
      refs = entry && entry.refs && entry.refs[role.role];
    }
  }
  return refs || null;
}, getIdentifier:function(entityType) {
  var parent = this.getParent(), cache, identifier, key, ret;
  if (parent) {
    ret = parent.getIdentifier(entityType);
  } else {
    cache = this.identifierCache;
    identifier = entityType.identifier;
    key = identifier.getId() || entityType.entityName;
    ret = cache[key];
    if (!ret) {
      if (identifier.clone) {
        ret = identifier.clone({id:null});
      } else {
        ret = identifier;
      }
      cache[key] = ret;
    }
  }
  return ret;
}, getMatrix:function(matrix, preventCreate) {
  var name = matrix.isManyToMany ? matrix.name : matrix, matrices = this.matrices, ret;
  ret = matrices[name];
  if (!ret && !preventCreate) {
    ret = matrices[name] = new Ext.data.matrix.Matrix(this, matrix);
  }
  return ret || null;
}, getMatrixSlice:function(role, id) {
  var matrix = this.getMatrix(role.association), side = matrix[role.side];
  return side.get(id);
}, getModelIdentifier:function(entityType, id) {
  return id + '@' + entityType.entityName;
}, onIdChanged:function(record, oldId, newId) {
  var me = this, matrices = me.matrices, entityName = record.entityName, id = record.id, bucket = me.data[entityName], entry = bucket[oldId], associations = record.associations, refs = entry.refs, setNoRefs = me._setNoRefs, association, fieldName, matrix, refId, role, roleName, roleRefs, key;
  delete bucket[oldId];
  bucket[newId] = entry;
  for (key in matrices) {
    matrices[key].updateId(record, oldId, newId);
  }
  if (refs) {
    for (roleName in refs) {
      roleRefs = refs[roleName];
      role = associations[roleName];
      association = role.association;
      if (!association.isManyToMany) {
        fieldName = association.field.name;
        for (refId in roleRefs) {
          roleRefs[refId].set(fieldName, id, setNoRefs);
        }
      }
    }
  }
  me.registerReferences(record, oldId);
}, processManyBlock:function(entityType, role, items, processor) {
  var me = this, id, record, records, store;
  if (items) {
    for (id in items) {
      record = me.peekRecord(entityType, id);
      if (record) {
        records = me.getEntityList(role.cls, items[id]);
        store = role.getAssociatedItem(record);
        me[processor](role, store, record, records);
      } else {
        me.onInvalidAssociationEntity(entityType, id);
      }
    }
  }
}, processManyCreate:function(role, store, record, records) {
  if (store) {
    store.add(records);
  } else {
    record[role.getterName](null, null, records);
  }
}, processManyDrop:function(role, store, record, records) {
  if (store) {
    store.remove(records);
  }
}, processManyRead:function(role, store, record, records) {
  if (store) {
    store.setRecords(records);
  } else {
    record[role.getterName](null, null, records);
  }
}, readEntities:function(entityType, items) {
  var me = this, len = items.length, i, data, rec, id;
  for (i = 0; i < len; ++i) {
    data = items[i];
    id = entityType.getIdFromData(data);
    rec = me.peekRecord(entityType, id);
    if (!rec) {
      rec = me.createRecord(entityType, data, true);
    } else {
      me.onInvalidEntityRead(entityType, id);
    }
    rec.phantom = false;
    me.add(rec);
  }
}, recordCreator:function(data, Model) {
  var me = this, id = Model.getIdFromData(data), record = me.peekRecord(Model, id, true);
  if (!record) {
    record = new Model(data, me);
  } else {
    record = me.getRecord(Model, id);
    record.mergeData(data);
  }
  return record;
}, registerReferences:function(record, oldId) {
  var entityName = record.entityName, id = record.id, recordData = record.data, remove = oldId || oldId === 0, entry, i, fk, len, reference, references, refs, roleName;
  len = (references = record.references).length;
  for (i = 0; i < len; ++i) {
    reference = references[i];
    fk = recordData[reference.name];
    if (fk || fk === 0) {
      reference = reference.reference;
      entityName = reference.type;
      roleName = reference.inverse.role;
      entry = this.getEntry(reference.cls, fk);
      refs = entry.refs || (entry.refs = {});
      refs = refs[roleName] || (refs[roleName] = {});
      refs[id] = record;
      if (remove) {
        delete refs[oldId];
      }
    }
  }
}, updateEntities:function(entityType, items) {
  var len = items.length, i, data, rec, id, modified;
  if (Ext.isArray(items)) {
    for (i = 0; i < len; ++i) {
      data = items[i];
      id = entityType.getIdFromData(data);
      rec = this.peekRecord(entityType, id);
      if (rec) {
        rec.set(data);
      } else {
        this.onInvalidEntityUpdate(entityType, id);
      }
    }
  } else {
    for (id in items) {
      data = items[id];
      rec = this.peekRecord(entityType, id);
      if (rec && !rec.dropped) {
        modified = rec.set(data);
      } else {
        this.onInvalidEntityUpdate(entityType, id, !!rec);
      }
    }
  }
}, updateReference:function(record, field, newValue, oldValue) {
  var reference = field.reference, entityName = reference.type, roleName = reference.inverse.role, id = record.id, entry, refs;
  if (oldValue || oldValue === 0) {
    refs = this.getEntry(entityName, oldValue).refs[roleName];
    delete refs[id];
  }
  if (newValue || newValue === 0) {
    entry = this.getEntry(entityName, newValue);
    refs = entry.refs || (entry.refs = {});
    refs = refs[roleName] || (refs[roleName] = {});
    refs[id] = record;
  }
}, visitData:function(visitor) {
  var me = this, data = me.data, matrices = me.matrices, all, assoc, id, id2, matrix, members, name, record, slice, slices, state;
  me.getSchema().processKeyChecks(true);
  for (name in data) {
    all = data[name];
    for (id in all) {
      record = all[id].record;
      if (record) {
        if (record.phantom || record.dirty || record.dropped) {
          if (visitor.onDirtyRecord) {
            visitor.onDirtyRecord(record);
          }
        } else {
          if (visitor.onCleanRecord) {
            visitor.onCleanRecord(record);
          }
        }
      }
    }
  }
  if (visitor.onMatrixChange) {
    for (name in matrices) {
      matrix = matrices[name].left;
      slices = matrix.slices;
      assoc = matrix.role.association;
      for (id in slices) {
        slice = slices[id];
        members = slice.members;
        for (id2 in members) {
          state = (record = members[id2])[2];
          if (state) {
            visitor.onMatrixChange(assoc, record[0], record[1], state);
          }
        }
      }
    }
  }
  return visitor;
}, _setNoRefs:{refs:false}}}, 1, 0, 0, 0, 0, [[Ext.mixin.Dirty.prototype.mixinId || Ext.mixin.Dirty.$className, Ext.mixin.Dirty], [Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.data, 'Session'], 0);
Ext.cmd.derive('Ext.util.Schedulable', Ext.Base, {'abstract':true, isSchedulable:true, scheduled:false, constructor:function() {
  this.getScheduler().add(this);
}, destroy:function() {
  var me = this, scheduler = me.getScheduler();
  if (scheduler && !scheduler.destroyed) {
    scheduler.remove(me);
  }
  me.scheduler = null;
  me.schedule = me.react = Ext.emptyFn;
  me.callParent();
}, getFullName:function() {
  return this.name || this.id;
}, privates:{getScheduler:function() {
  return this.scheduler;
}, schedule:function() {
  var me = this, scheduler;
  if (!me.scheduled) {
    scheduler = me.getScheduler();
    if (scheduler) {
      me.scheduled = true;
      if (me.onSchedule) {
        me.onSchedule();
      }
      scheduler.scheduleItem(me);
    }
  }
}, unschedule:function() {
  var me = this, scheduler;
  if (me.scheduled) {
    scheduler = me.getScheduler();
    if (scheduler && !scheduler.destroyed) {
      scheduler.unscheduleItem(me);
    }
    me.scheduled = false;
  }
}, sort:function() {
}}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Schedulable'], 0);
Ext.cmd.derive('Ext.app.bind.BaseBinding', Ext.util.Schedulable, {isBinding:true, calls:0, kind:20, defaultOptions:{}, lastValue:undefined, constructor:function(owner, callback, scope, options) {
  var me = this;
  me.options = options;
  me.owner = owner;
  me.scope = scope;
  me.callback = callback;
  me.lateBound = Ext.isString(callback);
  if (options && options.deep) {
    me.deep = true;
  }
  Ext.util.Schedulable.prototype.constructor.call(this);
}, destroy:function() {
  var me = this, owner = me.owner;
  if (owner) {
    owner.onBindDestroy(me);
  }
  Ext.util.Schedulable.prototype.destroy.call(this);
  me.scope = me.callback = me.owner = null;
}, isReadOnly:function() {
  return true;
}, privates:{getScheduler:function() {
  var owner = this.owner;
  return owner && owner.getScheduler();
}, getSession:function() {
  var owner = this.owner;
  return owner.isSession ? owner : owner.getSession();
}, notify:function(value) {
  var me = this, options = me.options || me.defaultOptions, previous = me.lastValue;
  if (!me.calls || me.deep || me.valueChanged(value, previous)) {
    ++me.calls;
    me.lastValue = value;
    if (me.lateBound) {
      me.scope[me.callback](value, previous, me);
    } else {
      me.callback.call(me.scope, value, previous, me);
    }
    if (options.single) {
      me.destroy();
    }
  }
}, valueChanged:function(value, previous) {
  var ret = true;
  if (previous !== value) {
    if (value && previous && value instanceof Date && previous instanceof Date) {
      ret = value.getTime() !== previous.getTime();
    }
  } else {
    ret = Ext.isArray(value);
  }
  return ret;
}}}, 1, 0, 0, 0, 0, 0, [Ext.app.bind, 'BaseBinding'], 0);
Ext.cmd.derive('Ext.app.bind.Binding', Ext.app.bind.BaseBinding, {constructor:function(stub, callback, scope, options) {
  var me = this;
  Ext.app.bind.BaseBinding.prototype.constructor.call(this, stub.owner, callback, scope, options);
  me.stub = stub;
  me.depth = stub.depth;
  if (stub.isAvailable() && !stub.scheduled) {
    me.schedule();
  }
}, destroy:function(fromParent) {
  var me = this, stub = me.stub;
  if (stub && !fromParent) {
    stub.unbind(me);
    me.stub = null;
  }
  Ext.app.bind.BaseBinding.prototype.destroy.call(this);
}, bindValidation:function(callback, scope) {
  var stub = this.stub;
  return stub && stub.bindValidation(callback, scope);
}, bindValidationField:function(callback, scope) {
  var stub = this.stub;
  return stub && stub.bindValidationField(callback, scope);
}, getFullName:function() {
  return this.fullName || (this.fullName = '@(' + this.stub.getFullName() + ')');
}, getValue:function() {
  var me = this, stub = me.stub;
  return stub && stub.getValue();
}, isAvailable:function() {
  var stub = this.stub;
  return stub && stub.isAvailable();
}, isLoading:function() {
  var stub = this.stub;
  return stub && stub.isLoading();
}, isReadOnly:function() {
  var stub = this.stub, options = this.options, ret = true;
  if (!(options && options.twoWay === false)) {
    if (stub) {
      ret = stub.isReadOnly();
    }
  }
  return ret;
}, refresh:function() {
}, setValue:function(value) {
  this.stub.set(value);
}, privates:{getDataObject:function() {
  var stub = this.stub;
  return stub && stub.getDataObject();
}, getRawValue:function() {
  var me = this, stub = me.stub;
  return stub && stub.getRawValue();
}, isDescendantOf:function(item) {
  var stub = this.stub;
  return stub ? item === stub || stub.isDescendantOf(item) : false;
}, react:function() {
  this.notify(this.getValue());
}, schedule:function() {
  if (!this.stub.scheduled) {
    Ext.app.bind.BaseBinding.prototype.schedule.call(this);
  }
}, sort:function() {
  var stub = this.stub;
  stub.scheduler.sortItem(stub);
}}}, 1, 0, 0, 0, 0, 0, [Ext.app.bind, 'Binding'], 0);
Ext.cmd.derive('Ext.app.bind.AbstractStub', Ext.util.Schedulable, {children:null, depth:0, generation:1, kind:10, parent:null, constructor:function(owner, name) {
  var me = this;
  me.owner = owner;
  me.name = name;
  Ext.util.Schedulable.prototype.constructor.call(this);
}, destroy:function() {
  var me = this, children = me.children, bindings = me.bindings, len, i, key;
  if (bindings) {
    for (i = 0, len = bindings.length; i < len; ++i) {
      bindings[i].destroy(true);
    }
  }
  for (key in children) {
    children[key].destroy();
  }
  if (me.scheduled) {
    me.unschedule();
  }
  Ext.util.Schedulable.prototype.destroy.call(this);
}, add:function(child) {
  var me = this;
  (me.children || (me.children = {}))[child.name] = child;
  child.depth = me.depth + 1;
  child.parent = me;
}, getChild:function(path) {
  var pathArray = Ext.isString(path) ? path.split('.') : path;
  if (pathArray && pathArray.length) {
    return this.descend(pathArray, 0);
  }
  return this;
}, getFullName:function() {
  var me = this, name = me.fullName, parent = me.parent, s;
  if (!name) {
    name = me.name || me.id;
    if (parent && (s = parent.getFullName())) {
      name = (s.charAt(s.length - 1) !== ':' ? s + '.' : s) + name;
    }
    me.fullName = name;
  }
  return name;
}, getSession:function() {
  var owner = this.owner;
  return owner.isSession ? owner : owner.getSession();
}, bind:function(callback, scope, options) {
  var me = this, binding = new Ext.app.bind.Binding(me, callback, scope, options), bindings = me.bindings || (me.bindings = []);
  binding.depth = me.depth;
  bindings.push(binding);
  return binding;
}, getValue:function() {
  return this.isAvailable() ? this.getRawValue() : null;
}, graft:function(replacement) {
  var me = this, bindings = me.bindings, name = me.name, i;
  me.parent = me.bindings = null;
  me.destroy();
  replacement.depth = me.depth;
  replacement.bindings = bindings;
  replacement.generation = me.generation + 1;
  replacement.name = name;
  replacement.id = me.id;
  replacement.path = me.path;
  if (bindings) {
    for (i = bindings.length; i-- > 0;) {
      bindings[i].stub = replacement;
    }
  }
  return replacement;
}, isDescendantOf:function(item) {
  for (var parent = this; parent = parent.parent;) {
    if (parent === item) {
      return true;
    }
  }
  return false;
}, isAvailable:function() {
  return true;
}, isLoading:function() {
  return false;
}, onSchedule:function() {
  for (var i, len, binding, bindings, p = this.parent; p; p = p.parent) {
    bindings = p.bindings;
    if (bindings) {
      for (i = 0, len = bindings.length; i < len; ++i) {
        binding = bindings[i];
        if (binding.deep && !binding.scheduled) {
          binding.schedule();
        }
      }
    }
  }
}, react:function() {
  var bindings = this.bindings, binding, i, len;
  if (bindings) {
    for (i = 0, len = bindings.length; i < len; ++i) {
      binding = bindings[i];
      if (!binding.scheduled) {
        binding.schedule();
      }
    }
  }
}, unbind:function(binding) {
  var bindings = this.bindings;
  if (bindings && bindings.length) {
    Ext.Array.remove(bindings, binding);
  }
}, privates:{collect:function() {
  var children = this.children, bindings = this.bindings, totalCount = 0, count = 0, child, key;
  if (children) {
    for (key in children) {
      child = children[key];
      count = child.collect();
      if (count === 0) {
        child.destroy();
        delete children[key];
      }
      totalCount += count;
    }
  }
  if (bindings) {
    totalCount += bindings.length;
  }
  return totalCount;
}, getScheduler:function() {
  var owner = this.owner;
  return owner && owner.getScheduler();
}, sort:function() {
  var parent = this.parent;
  if (parent) {
    this.scheduler.sortItem(parent);
  }
}}}, 1, 0, 0, 0, 0, 0, [Ext.app.bind, 'AbstractStub'], 0);
Ext.cmd.derive('Ext.app.bind.Stub', Ext.app.bind.AbstractStub, {isStub:true, dirty:true, formula:null, validationKey:'validation', constructor:function(owner, name, parent) {
  var me = this, path = name;
  Ext.app.bind.AbstractStub.prototype.constructor.call(this, owner, name);
  me.boundValue = null;
  if (parent) {
    parent.add(me);
    if (!parent.isRootStub) {
      path = parent.path + '.' + name;
    }
    me.checkHadValue();
  }
  me.path = path;
}, destroy:function() {
  var me = this, formula = me.formula, storeBinding = me.storeBinding;
  if (formula) {
    formula.destroy();
  }
  if (storeBinding) {
    storeBinding.destroy();
  }
  me.detachBound();
  Ext.app.bind.AbstractStub.prototype.destroy.call(this);
}, bindValidation:function(callback, scope) {
  var parent = this.parent;
  return parent && parent.descend([this.validationKey, this.name]).bind(callback, scope);
}, bindValidationField:function(callback, scope) {
  var parent = this.parent, name = this.name, lateBound = typeof callback === 'string', ret;
  if (parent) {
    ret = parent.bind(function(value) {
      var field = null;
      if (value && value.isModel) {
        field = value.getField(name);
      }
      if (lateBound) {
        scope[callback](field, value, this);
      } else {
        callback.call(scope, field, value, this);
      }
    });
  }
  return ret || null;
}, descend:function(path, index) {
  var me = this, children = me.children || (me.children = {}), pos = index || 0, name = path[pos++], ret;
  if (!(ret = children[name])) {
    ret = new Ext.app.bind.Stub(me.owner, name, me);
  }
  if (pos < path.length) {
    ret = ret.descend(path, pos);
  }
  return ret;
}, getChildValue:function(parentData) {
  var me = this, name = me.name, bindMappings = me.bindMappings, storeMappings = bindMappings.store, modelMappings = bindMappings.model, ret;
  if (!parentData && !Ext.isString(parentData)) {
    ret = me.hadValue ? null : undefined;
  } else {
    ret = me.inspectValue(parentData);
    if (!ret) {
      if (parentData.isEntity) {
        if (modelMappings[name]) {
          ret = parentData[modelMappings[name]]();
        } else {
          ret = parentData.data[name];
        }
      } else {
        if (parentData.isStore && storeMappings[name]) {
          ret = parentData[storeMappings[name]]();
        } else {
          ret = parentData[name];
          if (ret === undefined && me.hadValue) {
            ret = null;
          }
        }
      }
    }
  }
  return ret;
}, getDataObject:function() {
  var me = this, parentData = me.parent.getDataObject(), name = me.name, ret = parentData ? parentData[name] : null, storeMappings = me.bindMappings.store, associations;
  if (!ret) {
    if (parentData && parentData.isEntity) {
      associations = parentData.associations;
      if (associations && name in associations) {
        ret = parentData[associations[name].getterName]();
      }
    }
  } else {
    if (parentData.isStore && name in storeMappings) {
      ret = parentData[storeMappings[name]]();
    }
  }
  if (!ret || !(ret.$className || Ext.isObject(ret))) {
    parentData[name] = ret = {};
    me.hadValue = true;
    me.invalidate(true, true);
  }
  return ret;
}, getRawValue:function() {
  return this.getChildValue(this.getParentValue());
}, graft:function(replacement) {
  var me = this, parent = me.parent, children = me.children, name = me.name, i, ret;
  replacement.parent = parent;
  replacement.children = children;
  if (parent) {
    parent.children[name] = replacement;
  }
  if (children) {
    for (i in children) {
      children[i].parent = replacement;
    }
  }
  me.children = null;
  replacement.checkHadValue();
  ret = Ext.app.bind.AbstractStub.prototype.graft.call(this, replacement);
  ret.invalidate(true, true);
  return ret;
}, isAvailable:function() {
  return this.checkAvailability();
}, isLoading:function() {
  return !this.checkAvailability(true);
}, invalidate:function(deep, dirtyOnly) {
  var me = this, children = me.children, name;
  me.dirty = true;
  me.checkHadValue();
  if (!dirtyOnly && me.isAvailable()) {
    if (!me.scheduled) {
      me.schedule();
    }
  }
  if (deep && children) {
    for (name in children) {
      children[name].invalidate(deep, dirtyOnly);
    }
  }
}, isReadOnly:function() {
  var formula = this.formula;
  return !!(formula && !formula.set);
}, set:function(value, preventClimb) {
  var me = this, parent = me.parent, name = me.name, formula = me.formula, parentData, associations, association, formulaStub, setterName;
  if (formula && !formula.settingValue && formula.set) {
    formula.setValue(value);
    return;
  } else {
    if (me.isLinkStub) {
      formulaStub = me.getLinkFormulaStub();
      formula = formulaStub ? formulaStub.formula : null;
      if (formula) {
        formula.setValue(value);
        return;
      }
    }
  }
  parentData = parent.getDataObject();
  if (parentData.isEntity) {
    associations = parentData.associations;
    if (associations && name in associations) {
      association = associations[name];
      setterName = association.setterName;
      if (setterName) {
        parentData[setterName](value);
      }
      me.invalidate(true);
    } else {
      parentData.set(name, value);
    }
  } else {
    if (value && value.constructor === Object || !(value === parentData[name] && parentData.hasOwnProperty(name))) {
      if (preventClimb || !me.setByLink(value)) {
        if (value === undefined) {
          delete parentData[name];
        } else {
          parentData[name] = value;
        }
        me.inspectValue(parentData);
        me.invalidate(true);
      }
    }
  }
}, onStoreDataChanged:function() {
  this.invalidate(true);
}, afterLoad:function(record) {
  this.invalidate(true);
}, afterCommit:function(record) {
  this.afterEdit(record, null);
}, afterEdit:function(record, modifiedFieldNames) {
  var children = this.children, len = modifiedFieldNames && modifiedFieldNames.length, associations = record.associations, bindMappings = this.bindMappings.model, key, i, child, name, ref;
  if (children) {
    if (len) {
      for (i = 0; i < len; ++i) {
        name = modifiedFieldNames[i];
        child = children[name];
        if (!child) {
          ref = record.fieldsMap[name];
          ref = ref && ref.reference;
          child = ref && children[ref.role];
        }
        if (child) {
          child.invalidate(true);
        }
      }
    } else {
      for (key in children) {
        if (!(associations && key in associations)) {
          children[key].invalidate(true);
        }
      }
    }
    for (key in bindMappings) {
      child = children[key];
      if (child) {
        child.invalidate();
      }
    }
  }
  this.invalidate();
}, afterReject:function(record) {
  this.afterEdit(record, null);
}, afterAssociatedRecordSet:function(record, associated, role) {
  var children = this.children, key = role.role;
  if (children && key in children) {
    children[key].invalidate(true);
  }
}, setByLink:function(value) {
  var me = this, n = 0, ret = false, i, link, path, stub, root, name;
  for (stub = me; stub; stub = stub.parent) {
    if (stub.isLinkStub) {
      link = stub;
      if (n) {
        for (path = [], i = 0, stub = me; stub !== link; stub = stub.parent) {
          ++i;
          path[n - i] = stub.name;
        }
      }
      break;
    }
    ++n;
  }
  stub = null;
  if (link) {
    root = link.parent;
    name = link.name;
    if (!root.shouldClimb(name)) {
      stub = root.insertChild(name);
    } else {
      stub = link.getTargetStub();
    }
  }
  if (stub) {
    if (path) {
      stub = stub.descend(path);
    }
    stub.set(value);
    ret = true;
  }
  return ret;
}, setFormula:function(formula) {
  var me = this, oldFormula = me.formula;
  if (oldFormula) {
    oldFormula.destroy();
  }
  me.formula = new Ext.app.bind.Formula(me, formula);
}, react:function() {
  var me = this, bound = this.boundValue, children = me.children, generation;
  if (bound) {
    if (bound.isValidation) {
      bound.refresh();
      generation = bound.generation;
      if (me.lastValidationGeneration === generation) {
        return;
      }
      me.lastValidationGeneration = generation;
    } else {
      if (bound.isModel) {
        if (children && children[me.validationKey]) {
          bound.isValid();
        }
      }
    }
  }
  Ext.app.bind.AbstractStub.prototype.react.call(this);
}, privates:{bindMappings:{store:{count:'getCount', first:'first', last:'last', loading:'hasPendingLoad', totalCount:'getTotalCount'}, model:{dirty:'isDirty', phantom:'isPhantom', valid:'isValid'}}, checkAvailability:function(isLoading) {
  var me = this, parent = me.parent, bindMappings = me.bindMappings, name = me.name, available = !!(parent && parent.checkAvailability(isLoading)), associations, parentValue, value, availableSet, loading;
  if (available) {
    parentValue = me.getParentValue();
    value = me.inspectValue(parentValue);
    if (value) {
      if (isLoading) {
        available = !value.hasPendingLoad();
      } else {
        if (value.isStore) {
          available = true;
        } else {
          available = !value.isLoading() || value.loadCount > 0;
        }
      }
    } else {
      if (parentValue) {
        if (parentValue.isModel) {
          if (bindMappings.model[name]) {
            available = !parent.isLoading();
            availableSet = true;
          } else {
            associations = parentValue.associations;
            if (!(associations && name in associations)) {
              available = true;
              availableSet = true;
            }
          }
        } else {
          if (parentValue.isStore && bindMappings.store[name] && name !== 'loading') {
            available = !parent.isLoading();
            availableSet = true;
          }
        }
      }
      if (!availableSet) {
        available = me.hadValue || me.getRawValue() !== undefined;
      }
    }
  }
  return available;
}, checkHadValue:function() {
  if (!this.hadValue) {
    this.hadValue = this.getRawValue() !== undefined;
  }
}, collect:function() {
  var me = this, result = Ext.app.bind.AbstractStub.prototype.collect.call(this), storeBinding = me.storeBinding ? 1 : 0, formula = me.formula ? 1 : 0;
  return result + storeBinding + formula;
}, getLinkFormulaStub:function() {
  var stub = this;
  while (stub.isLinkStub) {
    stub = stub.binding.stub;
  }
  return stub.formula ? stub : null;
}, getParentValue:function() {
  var me = this;
  if (me.dirty) {
    me.parentValue = me.parent.getValue();
    me.dirty = false;
  }
  return me.parentValue;
}, setStore:function(storeBinding) {
  this.storeBinding = storeBinding;
}, inspectValue:function(parentData) {
  var me = this, name = me.name, current = me.boundValue, boundValue = null, associations, raw, changed, associatedEntity;
  if (parentData && parentData.isEntity) {
    associations = parentData.associations;
    if (associations && name in associations) {
      boundValue = parentData[associations[name].getterName]();
    } else {
      if (name === me.validationKey) {
        boundValue = parentData.getValidation();
        me.lastValidationGeneration = null;
      }
    }
  } else {
    if (parentData) {
      raw = parentData[name];
      if (raw && (raw.isModel || raw.isStore)) {
        boundValue = raw;
      }
    }
  }
  changed = current !== boundValue;
  if (changed) {
    if (current) {
      me.detachBound();
    }
    if (boundValue) {
      if (boundValue.isModel) {
        boundValue.join(me);
      } else {
        associatedEntity = boundValue.associatedEntity;
        if (associatedEntity && boundValue.autoLoad !== false && !boundValue.complete && !boundValue.hasPendingLoad()) {
          boundValue.load();
        }
        boundValue.on({scope:me, beginload:'onStoreDataChanged', load:'onStoreDataChanged', datachanged:'onStoreDataChanged', destroy:'onDestroyBound'});
      }
    }
    me.boundValue = boundValue;
  }
  return boundValue;
}, detachBound:function() {
  var me = this, current = me.boundValue;
  if (current && !current.destroyed) {
    if (current.isModel) {
      current.unjoin(me);
    } else {
      current.un({scope:me, beginload:'onStoreDataChanged', load:'onStoreDataChanged', datachanged:'onStoreDataChanged', destroy:'onDestroyBound'});
    }
  }
}, onDestroyBound:function() {
  if (!this.owner.destroying) {
    this.set(null);
  }
}, sort:function() {
  var me = this, formula = me.formula, scheduler = me.scheduler, storeBinding = me.storeBinding;
  Ext.app.bind.AbstractStub.prototype.sort.call(this);
  if (storeBinding) {
    scheduler.sortItem(storeBinding);
  }
  if (formula) {
    scheduler.sortItem(formula);
  }
}}}, 1, 0, 0, 0, 0, 0, [Ext.app.bind, 'Stub'], 0);
Ext.cmd.derive('Ext.app.bind.LinkStub', Ext.app.bind.Stub, {isLinkStub:true, binding:null, destroy:function() {
  var me = this, binding = me.binding, owner = me.owner;
  if (binding) {
    me.binding = null;
    binding.destroy();
    if (owner) {
      delete owner.linkData[me.name];
    }
  }
  me.target = null;
  Ext.app.bind.Stub.prototype.destroy.call(this);
}, getFullName:function() {
  var me = this;
  return me.fullName || (me.fullName = '(' + Ext.app.bind.Stub.prototype.getFullName.call(this) + ' -\x3e ' + me.binding.getFullName() + ')');
}, getDataObject:function() {
  var binding = this.binding, root = this.parent, name = this.name, rootData, ret;
  if (root.isRootStub && !root.shouldClimb(name)) {
    rootData = root.owner.getData();
    if (!rootData.hasOwnProperty(name)) {
      rootData[name] = ret = {};
    }
  } else {
    ret = binding && binding.getDataObject();
  }
  return ret;
}, getRawValue:function() {
  var binding = this.binding;
  return binding && binding.getRawValue();
}, getValue:function() {
  var binding = this.binding;
  return binding && binding.getValue();
}, getTargetStub:function() {
  var binding = this.binding;
  return binding && binding.stub;
}, isAvailable:function() {
  var binding = this.binding;
  return binding ? binding.isAvailable() : false;
}, isLoading:function() {
  var binding = this.binding;
  return binding ? binding.isLoading() : false;
}, link:function(bindDescriptor, target) {
  var me = this, binding = me.binding;
  if (binding) {
    binding.destroy();
  }
  target = me.target = target || me.owner;
  me.linkDescriptor = bindDescriptor;
  me.binding = target.bind(bindDescriptor, me.onChange, me);
  me.binding.deep = true;
}, onChange:function() {
  this.invalidate(true);
}, react:function() {
  var me = this, linkData = me.owner.linkData;
  linkData[me.name] = me.getValue();
  Ext.app.bind.Stub.prototype.react.call(this);
}, privates:{collect:function() {
  var me = this, result = Ext.app.bind.Stub.prototype.collect.call(this), binding = me.binding ? 1 : 0;
  return result + binding;
}, sort:function() {
  var binding = this.binding;
  if (binding) {
    this.scheduler.sortItem(binding);
  }
}}}, 0, 0, 0, 0, 0, 0, [Ext.app.bind, 'LinkStub'], 0);
Ext.cmd.derive('Ext.app.bind.RootStub', Ext.app.bind.AbstractStub, {isRootStub:true, depth:0, createRootChild:function(name, direct) {
  var me = this, owner = me.owner, ownerData = owner.getData(), children = me.children, previous = children && children[name], parentStub = previous ? null : me, parentVM, stub;
  if (direct || ownerData.hasOwnProperty(name) || !(parentVM = owner.getParent())) {
    stub = new Ext.app.bind.Stub(owner, name, parentStub);
  } else {
    stub = new Ext.app.bind.LinkStub(owner, name, parentStub);
    stub.link('{' + name + '}', parentVM);
  }
  if (previous) {
    previous.graft(stub);
  }
  return stub;
}, createStubChild:function(name) {
  return this.createRootChild(name, true);
}, descend:function(path, index) {
  var me = this, children = me.children, pos = index || 0, name = path[pos++], ret = children && children[name] || me.createRootChild(name);
  if (pos < path.length) {
    ret = ret.descend(path, pos);
  }
  return ret;
}, getFullName:function() {
  return this.fullName || (this.fullName = this.owner.id + ':');
}, getDataObject:function() {
  return this.owner.data;
}, getRawValue:function() {
  return this.owner.data;
}, getValue:function() {
  return this.owner.data;
}, isDescendantOf:function() {
  return false;
}, set:function(value, preventClimb) {
  var me = this, children = me.children || (me.children = {}), owner = me.owner, data = owner.data, parentVM = owner.getParent(), stub, v, key, setSelf, created;
  for (key in value) {
    v = value[key];
    if (v !== undefined) {
      stub = children[key];
      setSelf = preventClimb || !me.shouldClimb(key);
      if (!stub) {
        stub = me.createRootChild(key, setSelf);
        created = true;
      } else {
        if (setSelf && stub.isLinkStub && !stub.getLinkFormulaStub()) {
          stub = me.insertChild(key);
        }
      }
      if (!created || !data.hasOwnProperty(value)) {
        owner.invalidateChildLinks(key);
      }
      stub.set(v, setSelf);
    } else {
      if (data.hasOwnProperty(key)) {
        delete data[key];
        stub = children[key];
        if (stub) {
          if (!stub.isLinkStub && parentVM) {
            stub = me.createRootChild(key);
          }
          owner.invalidateChildLinks(key, true);
          stub.invalidate(true);
        }
      }
    }
  }
}, schedule:Ext.emptyFn, unschedule:Ext.emptyFn, privates:{checkAvailability:function() {
  return true;
}, insertChild:function(name) {
  return this.createRootChild(name, true);
}, invalidateChildLink:function(name, clear) {
  var children = this.children, stub = children && children[name];
  if (stub && stub.isLinkStub && !stub.getLinkFormulaStub()) {
    stub = this.createRootChild(name);
    if (clear) {
      stub.invalidate(true);
    }
    this.owner.invalidateChildLinks(name, clear);
  }
}, shouldClimb:function(name) {
  var parent = this.owner.getParent();
  while (parent) {
    if (parent.getData().hasOwnProperty(name)) {
      return true;
    }
    parent = parent.getParent();
  }
  return false;
}}}, 0, 0, 0, 0, 0, 0, [Ext.app.bind, 'RootStub'], 0);
Ext.cmd.derive('Ext.app.bind.Multi', Ext.app.bind.BaseBinding, {isMultiBinding:true, missing:1, deep:true, constructor:function(descriptor, owner, callback, scope, options) {
  var me = this, trackStatics = options && options.trackStatics;
  Ext.app.bind.BaseBinding.prototype.constructor.call(this, owner, callback, scope, options);
  me.bindings = [];
  me.literal = descriptor.$literal;
  if (descriptor.constructor === Object) {
    if (trackStatics) {
      me.staticKeys = [];
    }
    me.addObject(descriptor, me.lastValue = {}, me.staticKeys);
  } else {
    me.addArray(descriptor, me.lastValue = []);
  }
  if (!--me.missing && !me.scheduled) {
    me.schedule();
  }
}, destroy:function() {
  var me = this;
  me.bindings = Ext.destroy(me.bindings);
  Ext.app.bind.BaseBinding.prototype.destroy.call(this);
}, add:function(descriptor, data, property) {
  var me = this, owner = me.owner, bindings = me.bindings, method = me.literal ? descriptor.reference ? 'bindEntity' : 'bindExpression' : 'bind', binding, depth;
  ++me.missing;
  binding = owner[method](descriptor, function(value) {
    data[property] = value;
    if (binding.calls === 1) {
      --me.missing;
    }
    if (!me.missing && !me.scheduled) {
      me.schedule();
    }
  }, me, null);
  depth = binding.depth;
  if (!bindings.length || depth < me.depth) {
    me.depth = depth;
  }
  bindings.push(binding);
  return !this.isBindingStatic(binding);
}, addArray:function(multiBindDescr, array) {
  var me = this, n = multiBindDescr.length, hasDynamic = false, dynamic, b, i;
  for (i = 0; i < n; ++i) {
    b = multiBindDescr[i];
    if (b && (b.reference || Ext.isString(b))) {
      dynamic = me.add(b, array, i);
    } else {
      if (Ext.isArray(b)) {
        dynamic = me.addArray(b, array[i] = []);
      } else {
        if (b && b.constructor === Object) {
          dynamic = me.addObject(b, array[i] = {});
        } else {
          array[i] = b;
          dynamic = false;
        }
      }
    }
    hasDynamic = hasDynamic || dynamic;
  }
  return hasDynamic;
}, addObject:function(multiBindDescr, object, staticKeys) {
  var me = this, hasDynamic = false, dynamic, b, name;
  for (name in multiBindDescr) {
    b = multiBindDescr[name];
    if (b && (b.reference || Ext.isString(b))) {
      dynamic = me.add(b, object, name);
    } else {
      if (Ext.isArray(b)) {
        dynamic = me.addArray(b, object[name] = []);
      } else {
        if (b && b.constructor === Object) {
          dynamic = me.addObject(b, object[name] = {});
        } else {
          object[name] = b;
          dynamic = false;
        }
      }
    }
    if (staticKeys && !dynamic) {
      staticKeys.push(name);
    }
    hasDynamic = hasDynamic || dynamic;
  }
  return hasDynamic;
}, getFullName:function() {
  var me = this, fullName = me.fullName, bindings = me.bindings, length = bindings.length, i;
  if (!fullName) {
    fullName = '@[';
    for (i = 0; i < length; ++i) {
      if (i) {
        fullName += ',';
      }
      fullName += bindings[i].getFullName();
    }
    fullName += ']';
    me.fullName = fullName;
  }
  return fullName;
}, getRawValue:function() {
  return this.lastValue;
}, isDescendantOf:function() {
  return false;
}, isLoading:function() {
  for (var bindings = this.bindings, n = bindings.length; n-- > 0;) {
    if (bindings[n].isLoading()) {
      return true;
    }
  }
  return false;
}, isAvailable:function() {
  for (var bindings = this.bindings, n = bindings.length; n-- > 0;) {
    if (bindings[n].isAvailable()) {
      return true;
    }
  }
  return false;
}, isBindingStatic:function(binding) {
  return binding.isTemplateBinding && binding.isStatic;
}, isStatic:function() {
  var bindings = this.bindings, len = bindings.length, i, binding;
  for (i = 0; i < len; ++i) {
    binding = bindings[i];
    if (!this.isBindingStatic(binding)) {
      return false;
    }
  }
  return true;
}, pruneStaticKeys:function() {
  var value = Ext.apply({}, this.lastValue), keys = this.staticKeys, len = keys.length, i;
  for (i = 0; i < len; ++i) {
    delete value[keys[i]];
  }
  return value;
}, react:function() {
  this.notify(this.lastValue);
}, refresh:function() {
}, privates:{sort:function() {
  this.scheduler.sortItems(this.bindings);
}}}, 1, 0, 0, 0, 0, 0, [Ext.app.bind, 'Multi'], 0);
Ext.cmd.derive('Ext.app.bind.Formula', Ext.util.Schedulable, {statics:{getFormulaParser:function(name) {
  var cache = this.formulaCache, parser, s;
  if (!cache) {
    cache = this.formulaCache = new Ext.util.LruCache({maxSize:20});
  }
  parser = cache.get(name);
  if (!parser) {
    s = '[^\\.a-z0-9_]' + Ext.String.escapeRegex(name) + '\\(\\s*([\'"])(.*?)\\1\\s*\\)';
    parser = new RegExp(s, 'gi');
    cache.add(name, parser);
  }
  return parser;
}}, isFormula:true, calculation:null, explicit:false, set:null, single:false, fnKeywordArgumentNamesRe:/^function\s*[^\(]*\(\s*([^,\)\s]+)/, fnKeywordRe:/^\s*function/, replaceParenRe:/[\(\)]/g, constructor:function(stub, formula) {
  var me = this, owner = stub.owner, bindTo, expressions, getter, options;
  me.owner = owner;
  me.stub = stub;
  Ext.util.Schedulable.prototype.constructor.call(this);
  if (formula instanceof Function) {
    me.get = getter = formula;
  } else {
    me.get = getter = formula.get;
    me.set = formula.set;
    expressions = formula.bind;
    if (formula.single) {
      me.single = formula.single;
    }
    if (expressions) {
      bindTo = expressions.bindTo;
      if (bindTo) {
        options = Ext.apply({}, expressions);
        delete options.bindTo;
        expressions = bindTo;
      }
    }
  }
  if (expressions) {
    me.explicit = true;
  } else {
    expressions = getter.$expressions || me.parseFormula(getter);
  }
  me.binding = owner.bind(expressions, me.onChange, me, options);
}, destroy:function() {
  var me = this, binding = me.binding, stub = me.stub;
  if (binding) {
    binding.destroy();
    me.binding = null;
  }
  if (stub) {
    stub.formula = null;
  }
  Ext.util.Schedulable.prototype.destroy.call(this);
  me.getterFn = me.owner = null;
}, getFullName:function() {
  return this.fullName || (this.fullName = this.stub.getFullName() + '\x3d' + Ext.util.Schedulable.prototype.getFullName.call(this) + ')');
}, getRawValue:function() {
  return this.calculation;
}, onChange:function() {
  if (!this.scheduled) {
    this.schedule();
  }
}, parseFormula:function(formula) {
  var str = Ext.Function.toCode(formula), defaultProp = 'get', expressions = {$literal:true}, match, getterProp, formulaRe, expr;
  if (this.fnKeywordRe.test(str)) {
    match = this.fnKeywordArgumentNamesRe.exec(str);
    if (match) {
      getterProp = match[1];
    }
  } else {
    match = str.split('\x3d\x3e')[0];
    if (match) {
      match = Ext.String.trim(match.replace(this.replaceParenRe, '')).split(',');
      getterProp = match[0];
    }
  }
  getterProp = getterProp || defaultProp;
  formulaRe = Ext.app.bind.Formula.getFormulaParser(getterProp);
  while (match = formulaRe.exec(str)) {
    expr = match[2];
    expressions[expr] = expr;
  }
  expressions.$literal = true;
  formula.$expressions = expressions;
  return expressions;
}, react:function() {
  var me = this, owner = me.owner, data = me.binding.lastValue, getterFn = me.getterFn, arg;
  if (me.explicit) {
    arg = data;
  } else {
    arg = owner.getFormulaFn(data);
  }
  me.settingValue = true;
  me.stub.set(me.calculation = me.get.call(owner, arg));
  me.settingValue = false;
  if (me.single) {
    me.destroy();
  }
}, setValue:function(value) {
  this.set.call(this.stub.owner, value);
}, privates:{getScheduler:function() {
  var owner = this.owner;
  return owner && owner.getScheduler();
}, sort:function() {
  var me = this, binding = me.binding;
  if (!binding.destroyed) {
    me.scheduler.sortItem(binding);
  }
}}}, 1, 0, 0, 0, 0, 0, [Ext.app.bind, 'Formula'], 0);
Ext.cmd.derive('Ext.util.Fly', Ext.Base, {inheritableStatics:{flyPoolSize:2, fly:function() {
  var T = this, flyweights = T.flyweights || (T.flyweights = []), instance = flyweights.length ? flyweights.pop() : new T;
  instance.reset.apply(instance, arguments);
  return instance;
}}, release:function() {
  var me = this, T = me.self, flyweights = T.flyweights || (T.flyweights = []);
  me.reset();
  if (flyweights.length < T.flyPoolSize) {
    flyweights.push(me);
  }
}, reset:Ext.emptyFn}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Fly'], 0);
Ext.cmd.derive('Ext.parse.Tokenizer', Ext.util.Fly, function(Tokenizer) {
  var flyweights = Tokenizer.flyweights = [], BOOLEAN = {literal:true, 'boolean':true}, ERROR = {error:true}, IDENT = {ident:true}, LITERAL = {literal:true}, NULL = {literal:true, nil:true}, NUMBER = {literal:true, number:true}, STRING = {literal:true, string:true};
  return {isTokenizer:true, statics:{BOOLEAN:BOOLEAN, ERROR:ERROR, IDENT:IDENT, LITERAL:LITERAL, NULL:NULL, NUMBER:NUMBER, STRING:STRING}, config:{keywords:{'null':{type:'literal', is:NULL, value:null}, 'false':{type:'literal', is:BOOLEAN, value:false}, 'true':{type:'literal', is:BOOLEAN, value:true}}, operators:{'+':'plus', '-':'minus', '*':'multiply', '/':'divide', '!':'bang', ',':'comma', ':':'colon', '[':'arrayOpen', ']':'arrayClose', '{':'curlyOpen', '}':'curlyClose', '(':'parenOpen', ')':'parenClose'}}, 
  error:null, index:-1, constructor:function(config) {
    this.operators = {};
    this.initConfig(config);
  }, next:function() {
    var token = this.peek();
    this.head = undefined;
    return token;
  }, peek:function() {
    var me = this, error = me.error, token = me.head;
    if (error) {
      return error;
    }
    if (token === undefined) {
      me.head = token = me.advance();
    }
    return token;
  }, release:function() {
    this.reset();
    if (flyweights.length < Tokenizer.flyPoolSize) {
      flyweights.push(this);
    }
  }, reset:function(text, pos, end) {
    var me = this;
    me.error = null;
    me.head = undefined;
    me.index = -1;
    me.text = text || null;
    me.pos = pos || 0;
    me.end = text && end == null ? text.length : end;
    return me;
  }, privates:{digitRe:/[0-9]/, identFirstRe:/[a-z_$]/i, identRe:/[0-9a-z_$]/i, spaceRe:/[ \t]/, end:0, head:undefined, pos:0, text:null, applyOperators:function(ops) {
    var operators = this.operators, block, c, def, i, len, name, op;
    for (op in ops) {
      block = operators;
      name = ops[op];
      len = op.length;
      for (i = 0; i < len; ++i) {
        c = op.charAt(i);
        block = block[c] || (block[c] = {});
      }
      if (name) {
        block.token = def = {type:'operator', value:op, is:{operator:true}};
        def.is[name] = true;
      } else {
        block.token = null;
      }
    }
  }, advance:function() {
    var me = this, spaceRe = me.spaceRe, text = me.text, length = me.end, c;
    while (me.pos < length) {
      c = text.charAt(me.pos);
      if (spaceRe.test(c)) {
        ++me.pos;
        continue;
      }
      me.index = me.pos;
      return me.parse(c);
    }
    return null;
  }, parse:function(c) {
    var me = this, digitRe = me.digitRe, text = me.text, length = me.end, ret;
    if (c === '.' && me.pos + 1 < length) {
      if (digitRe.test(text.charAt(me.pos + 1))) {
        ret = me.parseNumber();
      }
    }
    if (!ret && me.operators[c]) {
      ret = me.parseOperator(c);
    }
    if (!ret) {
      if (c === '"' || c === "'") {
        ret = me.parseString();
      } else {
        if (digitRe.test(c)) {
          ret = me.parseNumber();
        } else {
          if (me.identFirstRe.test(c)) {
            ret = me.parseIdent();
          } else {
            ret = me.syntaxError('Unexpected character');
          }
        }
      }
    }
    return ret;
  }, parseIdent:function() {
    var me = this, identRe = me.identRe, keywords = me.getKeywords(), includeDots = !me.operators['.'], text = me.text, start = me.pos, end = start, length = me.end, prev = 0, c, value;
    while (end < length) {
      c = text.charAt(end);
      if (includeDots && c === '.') {
        if (prev === '.') {
          return me.syntaxError(end, 'Unexpected dot operator');
        }
        ++end;
      } else {
        if (identRe.test(c)) {
          ++end;
        } else {
          break;
        }
      }
      prev = c;
    }
    if (prev === '.') {
      return me.syntaxError(end - 1, 'Unexpected dot operator');
    }
    value = text.substring(start, me.pos = end);
    return keywords && keywords[value] || {type:'ident', is:IDENT, value:value};
  }, parseNumber:function() {
    var me = this, digitRe = me.digitRe, text = me.text, start = me.pos, length = me.end, c, decimal, exp, token;
    while (me.pos < length) {
      c = text.charAt(me.pos);
      if (c === '-' || c === '+') {
        if (me.pos !== start) {
          return me.syntaxError(start, 'Invalid number');
        }
        ++me.pos;
      } else {
        if (c === '.') {
          if (decimal) {
            break;
          }
          decimal = true;
          ++me.pos;
        } else {
          if (c === 'e' || c === 'E') {
            if (exp) {
              break;
            }
            decimal = exp = true;
            c = text.charAt(++me.pos);
            if (c === '-' || c === '+') {
              ++me.pos;
            }
          } else {
            if (digitRe.test(c)) {
              ++me.pos;
            } else {
              break;
            }
          }
        }
      }
    }
    token = {type:'literal', is:NUMBER, value:+text.substring(start, me.pos)};
    if (!isFinite(token.value)) {
      token = me.syntaxError(start, 'Invalid number');
    }
    return token;
  }, parseOperator:function(c) {
    var me = this, block = me.operators, text = me.text, length = me.end, end = me.pos, match, matchEnd, token;
    while (block[c]) {
      block = block[c];
      token = block.token;
      ++end;
      if (token) {
        match = token;
        matchEnd = end;
      }
      if (end < length) {
        c = text.charAt(end);
      } else {
        break;
      }
    }
    if (match) {
      me.pos = matchEnd;
    }
    return match;
  }, parseString:function() {
    var me = this, text = me.text, pos = me.pos, start = pos, length = me.end, str = '', c, closed, quote;
    quote = text.charAt(pos++);
    while (pos < length) {
      c = text.charAt(pos++);
      if (c === quote) {
        closed = true;
        break;
      }
      if (c === '\\' && pos < length) {
        c = text.charAt(pos++);
      }
      str += c;
    }
    me.pos = pos;
    if (!closed) {
      return me.syntaxError(start, 'Unterminated string');
    }
    return {type:'literal', is:STRING, value:str};
  }, syntaxError:function(at, message) {
    if (typeof at === 'string') {
      message = at;
      at = this.pos;
    }
    var suffix = at == null ? '' : ' (at index ' + at + ')', error = new Error(message + suffix);
    error.type = 'error';
    error.is = ERROR;
    if (suffix) {
      error.at = at;
    }
    return this.error = error;
  }}};
}, 1, 0, 0, 0, 0, 0, [Ext.parse, 'Tokenizer'], 0);
Ext.cmd.derive('Ext.parse.Symbol', Ext.Base, {priority:0, constructor:function(id, config) {
  var me = this, defaultProperty = me.defaultProperty;
  if (config && typeof config === 'object') {
    Ext.apply(me, config);
  } else {
    if (config !== undefined && defaultProperty) {
      me[defaultProperty] = config;
    }
  }
  me.id = id;
}, led:function() {
  this.parser.syntaxError(this.at, 'Missing operator');
}, nud:function() {
  this.parser.syntaxError(this.at, 'Undefined');
}, update:function(config) {
  if (config && typeof config === 'object') {
    var me = this, priority = config.priority, led = config.led, nud = config.nud;
    if (me.priority <= priority) {
      me.priority = priority;
    }
    if (led) {
      me.led = led;
    }
    if (nud) {
      me.nud = nud;
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.parse, 'Symbol'], 0);
Ext.cmd.derive('Ext.parse.symbol.Constant', Ext.parse.Symbol, {arity:'literal', isLiteral:true, defaultProperty:'value', constructor:function(id, config) {
  Ext.parse.Symbol.prototype.constructor.call(this, id, config);
  this._value = this.value;
}, nud:function() {
  var me = this;
  me.value = me._value;
  me.arity = 'literal';
  me.isLiteral = true;
  return me;
}}, 1, 0, 0, 0, 0, 0, [Ext.parse.symbol, 'Constant'], 0);
Ext.cmd.derive('Ext.parse.symbol.Infix', Ext.parse.Symbol, {arity:'binary', isBinary:true, defaultProperty:'priority', led:function(left) {
  var me = this;
  me.lhs = left;
  me.rhs = me.parser.parseExpression(me.priority);
  me.arity = 'binary';
  me.isBinary = true;
  return me;
}}, 0, 0, 0, 0, 0, 0, [Ext.parse.symbol, 'Infix'], 0);
Ext.cmd.derive('Ext.parse.symbol.InfixRight', Ext.parse.symbol.Infix, {led:function(left) {
  var me = this;
  me.lhs = left;
  me.rhs = me.parser.parseExpression(me.priority - 1);
  me.arity = 'binary';
  me.isBinary = true;
  return me;
}}, 0, 0, 0, 0, 0, 0, [Ext.parse.symbol, 'InfixRight'], 0);
Ext.cmd.derive('Ext.parse.symbol.Paren', Ext.parse.Symbol, {arity:'binary', isBinary:true, priority:80, led:function(left) {
  var me = this, args = [], parser = me.parser, id = left.id, type = left.arity;
  if (id !== '.' && id !== '[') {
    if ((type !== 'unary' || id !== 'function') && type !== 'ident' && id !== '(' && id !== '\x26\x26' && id !== '||' && id !== '?') {
      parser.syntaxError(left.at, 'Expected a variable name.');
    }
  }
  me.arity = 'invoke';
  me.isInvoke = true;
  me.operand = left;
  me.args = args;
  while (parser.token.id !== ')') {
    if (args.length) {
      parser.advance(',');
    }
    args.push(parser.parseExpression());
  }
  parser.advance(')');
  return me;
}, nud:function() {
  var parser = this.parser, ret = parser.parseExpression();
  parser.advance(')');
  return ret;
}}, 0, 0, 0, 0, 0, 0, [Ext.parse.symbol, 'Paren'], 0);
Ext.cmd.derive('Ext.parse.symbol.Prefix', Ext.parse.Symbol, {arity:'unary', isUnary:true, priority:70, nud:function() {
  var me = this;
  me.operand = me.parser.parseExpression(me.priority);
  me.arity = 'unary';
  me.isUnary = true;
  return me;
}}, 0, 0, 0, 0, 0, 0, [Ext.parse.symbol, 'Prefix'], 0);
Ext.cmd.derive('Ext.parse.Parser', Ext.util.Fly, function() {
  var ITSELF = function() {
    return this;
  };
  return {isParser:true, config:{constants:{'null':null, 'false':false, 'true':true}, infix:{'+':50, '-':50, '*':60, '/':60}, infixRight:{'\x26\x26':30, '||':30}, prefix:{'!':0, '-':0, '+':0}, symbols:{':':0, ',':0, ')':0, '[':0, ']':0, '{':0, '}':0, '(end)':0, '(ident)':{arity:'ident', isIdent:true, nud:ITSELF}, '(literal)':{arity:'literal', isLiteral:true, nud:ITSELF}, '(':{xclass:'Ext.parse.symbol.Paren'}}, tokenizer:{keywords:null}}, token:null, constructor:function(config) {
    this.symbols = {};
    this.initConfig(config);
  }, advance:function(expected) {
    var me = this, tokenizer = me.tokenizer, token = tokenizer.peek(), symbols = me.symbols, index = tokenizer.index, is, symbol, value;
    if (me.error) {
      throw me.error;
    }
    if (expected) {
      me.expect(expected);
    }
    if (!token) {
      return me.token = symbols['(end)'];
    }
    tokenizer.next();
    is = token.is;
    value = token.value;
    if (is.ident) {
      symbol = symbols[value] || symbols['(ident)'];
    } else {
      if (is.operator) {
        if (!(symbol = symbols[value])) {
          me.syntaxError(token.at, 'Unknown operator "' + value + '"');
        }
      } else {
        if (is.literal) {
          symbol = symbols['(literal)'];
        } else {
          me.syntaxError(token.at, 'Unexpected token');
        }
      }
    }
    me.token = symbol = Ext.Object.chain(symbol);
    symbol.at = index;
    symbol.value = value;
    if (!symbol.arity) {
      symbol.arity = token.type;
    }
    return symbol;
  }, expect:function(expected) {
    var token = this.token;
    if (expected !== token.id) {
      this.syntaxError(token.at, 'Expected "' + expected + '"');
    }
    return this;
  }, parseExpression:function(rightPriority) {
    var me = this, token = me.token, left;
    rightPriority = rightPriority || 0;
    me.advance();
    left = token.nud();
    while (rightPriority < (token = me.token).priority) {
      me.advance();
      left = token.led(left);
    }
    return left;
  }, reset:function(text, pos, end) {
    var me = this;
    me.error = me.token = null;
    me.tokenizer.reset(text, pos, end);
    me.advance();
    return me;
  }, syntaxError:function(at, message) {
    if (typeof at === 'string') {
      message = at;
      at = this.pos;
    }
    var suffix = at == null ? '' : ' (at index ' + at + ')', error = new Error(message + suffix);
    error.type = 'error';
    if (suffix) {
      error.at = at;
    }
    throw this.error = error;
  }, privates:{error:null, addSymbol:function(id, config, type, update) {
    var symbols = this.symbols, symbol = symbols[id], cfg, length, i;
    if (symbol) {
      if (typeof config === 'object') {
        cfg = config;
      } else {
        if (update && type) {
          update = Ext.Array.from(update);
          length = update.length;
          cfg = {};
          for (i = 0; i < length; i++) {
            cfg[update[i]] = type.prototype[update[i]];
          }
        } else {
          return symbol;
        }
      }
      symbol.update(cfg);
    } else {
      if (config && config.xclass) {
        type = Ext.ClassManager.get(config.xclass);
      } else {
        type = type || Ext.parse.Symbol;
      }
      symbols[id] = symbol = new type(id, config);
      symbol.parser = this;
    }
    return symbol;
  }, addSymbols:function(symbols, type, update) {
    for (var id in symbols) {
      this.addSymbol(id, symbols[id], type, update);
    }
  }, applyConstants:function(constants) {
    this.addSymbols(constants, Ext.parse.symbol.Constant, 'nud');
  }, applyInfix:function(operators) {
    this.addSymbols(operators, Ext.parse.symbol.Infix, 'led');
  }, applyInfixRight:function(operators) {
    this.addSymbols(operators, Ext.parse.symbol.InfixRight, 'led');
  }, applyPrefix:function(operators) {
    this.addSymbols(operators, Ext.parse.symbol.Prefix, 'nud');
  }, applySymbols:function(symbols) {
    this.addSymbols(symbols);
  }, applyTokenizer:function(config) {
    var ret = config;
    if (config && !config.isTokenizer) {
      ret = new Ext.parse.Tokenizer(config);
    }
    this.tokenizer = ret;
  }}};
}, 1, 0, 0, 0, 0, 0, [Ext.parse, 'Parser'], 0);
Ext.cmd.derive('Ext.app.bind.Parser', Ext.parse.Parser, {infix:{':':{priority:70, led:function(left) {
  var me = this;
  me.arity = 'formatter';
  me.operand = left;
  me.fmt = me.parser.parseFmt();
  return me;
}}, '?':{priority:20, led:function(left) {
  var me = this, parser = me.parser, symbol = parser.symbols[':'], temp;
  me.condition = left;
  temp = symbol.priority;
  symbol.priority = 0;
  me.tv = parser.parseExpression(0);
  me.parser.advance(':');
  symbol.priority = temp;
  me.fv = parser.parseExpression(0);
  me.arity = 'ternary';
  return me;
}}, '\x3d\x3d\x3d':40, '!\x3d\x3d':40, '\x3d\x3d':40, '!\x3d':40, '\x3c':40, '\x3c\x3d':40, '\x3e':40, '\x3e\x3d':40}, symbols:{'(':{nud:function() {
  var parser = this.parser, symbol = parser.symbols[':'], ret, temp;
  temp = symbol.priority;
  symbol.priority = 70;
  ret = parser.parseExpression();
  parser.advance(')');
  symbol.priority = temp;
  return ret;
}}}, prefix:{'@':0}, tokenizer:{operators:{'@':'at', '?':'qmark', '\x3d\x3d\x3d':'feq', '!\x3d\x3d':'fneq', '\x3d\x3d':'eq', '!\x3d':'neq', '\x3c':'lt', '\x3c\x3d':'lte', '\x3e':'gt', '\x3e\x3d':'gte', '\x26\x26':'and', '||':'or'}}, compileExpression:function(tokens, tokensMaps) {
  var me = this, debug, fn;
  me.tokens = tokens;
  me.tokensMap = tokensMaps;
  fn = me.parseSlot(me.parseExpression(), debug);
  me.tokens = me.tokensMap = null;
  return fn;
}, compileFormat:function() {
  var fn;
  fn = this.parseSlot({arity:'formatter', fmt:this.parseFmt(), operand:{arity:'ident', value:'dummy'}});
  this.expect('(end)');
  return fn;
}, privates:{useEval:Ext.isGecko, escapeRe:/("|'|\\)/g, parseFmt:function() {
  var me = this, fmt = [], priority = me.symbols[':'].priority, expr;
  do {
    if (fmt.length) {
      me.advance();
    }
    expr = me.parseExpression(priority);
    if (expr.isIdent || expr.isInvoke) {
      fmt.push(expr);
    } else {
      me.syntaxError(expr.at, 'Expected formatter name');
    }
  } while (me.token.id === ':');
  return fmt;
}, parseSlot:function(expr, debug) {
  var me = this, defs = [], body = [], tokens = me.tokens || [], fn, code, i, length, temp;
  me.definitions = defs;
  me.body = body;
  body.push('return ' + me.compile(expr) + ';');
  length = tokens.length;
  code = 'var fm \x3d Ext.util.Format,\nme,';
  temp = 'var a \x3d Ext.Array.from(values);\nme \x3d scope;\n';
  if (tokens.length) {
    for (i = 0; i < length; i++) {
      code += 'v' + i + (i == length - 1 ? ';' : ',');
      temp += 'v' + i + ' \x3d a[' + i + ']; ';
    }
  } else {
    code += 'v0;';
    temp += 'v0 \x3d a[0];';
  }
  defs = Ext.Array.insert(defs, 0, [code]);
  body = Ext.Array.insert(body, 0, [temp]);
  body = body.join('\n');
  defs.push((me.useEval ? '$\x3d' : 'return') + ' function (values, scope) {', body, '}');
  code = defs.join('\n');
  fn = me.useEval ? me.evalFn(code) : (new Function('Ext', code))(Ext);
  me.definitions = me.body = null;
  return fn;
}, compile:function(expr) {
  var me = this, v;
  switch(expr.arity) {
    case 'ident':
      return me.addToken(expr.value);
    case 'literal':
      v = expr.value;
      return typeof v === 'string' ? '"' + String(v).replace(me.escapeRe, '\\$1') + '"' : v;
    case 'unary':
      return me.compileUnary(expr);
    case 'binary':
      return me.compileBinary(expr);
    case 'ternary':
      return me.compileTernary(expr);
    case 'formatter':
      return me.compileFormatter(expr);
  }
  return this.syntaxError(expr.at, 'Compile error! Unknown symbol');
}, compileUnary:function(expr) {
  var v = expr.value, op = expr.operand;
  if (v === '!' || v === '-' || v === '+') {
    return v + '(' + this.compile(op) + ')';
  } else {
    if (v === '@') {
      if (!op.isIdent) {
        return this.syntaxError(expr.at, 'Compile error! Unexpected symbol');
      }
      return op.value;
    }
  }
  return '';
}, compileBinary:function(expr) {
  return '(' + this.compile(expr.lhs) + ' ' + expr.value + ' ' + this.compile(expr.rhs) + ')';
}, compileTernary:function(expr) {
  return '(' + this.compile(expr.condition) + ' ? ' + this.compile(expr.tv) + ' : ' + this.compile(expr.fv) + ')';
}, compileFormatter:function(expr) {
  var me = this, fmt = expr.fmt, length = fmt.length, body = ['var ret;'], i;
  if (fmt.length) {
    body.push('ret \x3d ' + me.compileFormatFn(fmt[0], me.compile(expr.operand)) + ';');
    for (i = 1; i < length; i++) {
      body.push('ret \x3d ' + me.compileFormatFn(fmt[i], 'ret') + ';');
    }
  }
  body.push('return ret;');
  return me.addFn(body.join('\n'));
}, compileFormatFn:function(expr, value) {
  var fmt, args = [], code = '', length, i;
  if (expr.isIdent) {
    fmt = expr.value;
  } else {
    if (expr.isInvoke) {
      fmt = expr.operand.value;
      args = expr.args;
    }
  }
  if (fmt.substring(0, 5) === 'this.') {
    fmt = 'me.' + fmt.substring(5);
  } else {
    if (!(fmt in Ext.util.Format)) {
      return this.syntaxError(expr.at, 'Compile error! Invalid format specified "' + fmt + '"');
    }
    fmt = 'fm.' + fmt;
  }
  code += value;
  length = args.length;
  for (i = 0; i < length; i++) {
    code += ', ' + this.compile(args[i]);
  }
  return fmt + '(' + code + ')';
}, addFn:function(body) {
  var defs = this.definitions, name = 'f' + defs.length;
  defs.push('function ' + name + '() {', body, '}');
  return name + '()';
}, evalFn:function($) {
  eval($);
  return $;
}, addToken:function(token) {
  var tokensMap = this.tokensMap, tokens = this.tokens, pos = 0;
  if (tokensMap && tokens) {
    if (token in tokensMap) {
      pos = tokensMap[token];
    } else {
      tokensMap[token] = pos = tokens.length;
      tokens.push(token);
    }
  }
  return 'v' + pos;
}}}, 0, 0, 0, 0, 0, 0, [Ext.app.bind, 'Parser'], 0);
Ext.cmd.derive('Ext.app.bind.Template', Ext.Base, {escapes:false, buffer:null, slots:null, tokens:null, constructor:function(text) {
  var me = this, initters = me._initters, name;
  me.text = text;
  for (name in initters) {
    me[name] = initters[name];
  }
}, _initters:{apply:function(values, scope) {
  return this.parse().apply(values, scope);
}, getTokens:function() {
  return this.parse().getTokens();
}}, apply:function(values, scope) {
  var me = this, slots = me.slots, buffer = me.buffer, length = slots.length, i, slot;
  for (i = 0; i < length; ++i) {
    slot = slots[i];
    if (slot) {
      buffer[i] = slot(values, scope);
    }
  }
  if (slot && me.single) {
    return buffer[0];
  }
  return buffer.join('');
}, getText:function() {
  return this.buffer.join('');
}, getTokens:function() {
  return this.tokens;
}, isStatic:function() {
  var tokens = this.getTokens(), slots = this.slots;
  return tokens.length === 0 && slots.length === 0;
}, privates:{literalChar:'~', escapeChar:'\\', parse:function() {
  var me = this, text = me.text, parser = Ext.app.bind.Parser.fly(), buffer = me.buffer = [], slots = me.slots = [], length = text.length, pos = 0, escapes = me.escapes, current = '', i = 0, esc = me.escapeChar, lit = me.literalChar, escaped, tokens, tokensMap, lastEscaped, c, prev, key;
  for (key in me._initters) {
    delete me[key];
  }
  me.tokens = tokens = [];
  me.tokensMap = tokensMap = {};
  while (i < length) {
    c = text[i];
    lastEscaped = escaped;
    escaped = escapes && c === esc;
    if (escaped) {
      c = text[i + 1];
      ++i;
    } else {
      if (c === lit && prev === lit && !lastEscaped) {
        current = current.slice(0, -1);
        current += text.substring(i + 1);
        break;
      } else {
        if (c === '{') {
          if (current) {
            buffer[pos++] = current;
            current = '';
          }
          parser.reset(text, i + 1);
          i = me.parseExpression(parser, pos);
          ++pos;
          continue;
        }
      }
    }
    current += c;
    ++i;
    prev = c;
  }
  if (current) {
    buffer[pos] = current;
  }
  parser.release();
  me.single = buffer.length === 0 && slots.length === 1;
  return me;
}, parseExpression:function(parser, pos) {
  var i;
  this.slots[pos] = parser.compileExpression(this.tokens, this.tokensMap);
  i = parser.token.at + 1;
  parser.expect('}');
  return i;
}}}, 1, 0, 0, 0, 0, 0, [Ext.app.bind, 'Template'], 0);
Ext.cmd.derive('Ext.app.bind.TemplateBinding', Ext.app.bind.BaseBinding, {isTemplateBinding:true, lastValue:undefined, value:undefined, constructor:function(template, owner, callback, scope, options) {
  var me = this, tpl = new Ext.app.bind.Template(template), tokens = tpl.getTokens();
  Ext.app.bind.BaseBinding.prototype.constructor.call(this, owner, callback, scope, options);
  me.tpl = tpl;
  me.tokens = tokens;
  tokens.$literal = true;
  if (!tpl.isStatic()) {
    me.multiBinding = new Ext.app.bind.Multi(tokens, owner, me.onBindData, me);
  } else {
    me.isStatic = true;
    me.onData(tpl.getText());
  }
}, destroy:function() {
  var me = this;
  Ext.destroy(me.multiBinding);
  me.tpl = me.multiBinding = null;
  Ext.app.bind.BaseBinding.prototype.destroy.call(this);
}, getFullName:function() {
  var multi = this.multiBinding;
  return this.fullName || (this.fullName = '$' + (multi ? multi.getFullName() : Ext.app.bind.BaseBinding.prototype.getFullName.call(this)));
}, getRawValue:function() {
  return this.value;
}, getTemplateScope:function() {
  return null;
}, isAvailable:function() {
  var multi = this.multiBinding;
  return multi ? multi.isAvailable() : false;
}, isDescendantOf:function() {
  return false;
}, isLoading:function() {
  var multi = this.multiBinding;
  return multi ? multi.isLoading() : false;
}, onBindData:function(data) {
  this.onData(this.tpl.apply(data, this.getTemplateScope()));
}, onData:function(value) {
  var me = this, lastValue = me.value;
  if (lastValue !== (me.value = value)) {
    me.lastValue = lastValue;
    me.schedule();
  }
}, react:function() {
  this.notify(this.value);
}, refresh:function() {
  var multi = this.multiBinding;
  if (multi) {
    multi.refresh();
  }
}, privates:{sort:function() {
  var multi = this.multiBinding;
  if (multi) {
    this.scheduler.sortItem(multi);
  }
}}}, 1, 0, 0, 0, 0, 0, [Ext.app.bind, 'TemplateBinding'], 0);
Ext.cmd.derive('Ext.data.ChainedStore', Ext.data.AbstractStore, {isChainedStore:true, config:{source:null, remoteFilter:false, remoteSort:false}, remove:function() {
  var source = this.getSource();
  return source.remove.apply(source, arguments);
}, removeAll:function() {
  var source = this.getSource();
  return source.removeAll();
}, getData:function() {
  var me = this, data = me.data;
  if (!data) {
    me.data = data = me.constructDataCollection();
  }
  return data;
}, getTotalCount:function() {
  return this.getCount();
}, getSession:function() {
  return this.getSourceValue('getSession', null);
}, applySource:function(source) {
  if (source) {
    source = Ext.data.StoreManager.lookup(source);
  }
  return source;
}, updateSource:function(source, oldSource) {
  var me = this, data;
  if (oldSource && !oldSource.destroyed) {
    oldSource.removeObserver(me);
  }
  if (source) {
    data = me.getData();
    data.setSource(source.getData());
    if (!me.isInitializing) {
      me.fireEvent('refresh', me);
      me.fireEvent('datachanged', me);
    }
    source.addObserver(me);
  }
}, getModel:function() {
  return this.getSourceValue('getModel', null);
}, getProxy:function() {
  return null;
}, onCollectionAdd:function(collection, info) {
  var me = this, records = info.items, lastChunk = !info.next;
  if (me.ignoreCollectionAdd) {
    return;
  }
  if (me.activeRanges) {
    me.syncActiveRanges();
  }
  me.fireEvent('add', me, records, info.at);
  if (lastChunk) {
    me.fireEvent('datachanged', me);
  }
}, onCollectionItemChange:function(collection, info) {
  var me = this, record = info.item, modifiedFieldNames = info.modified || null, type = info.meta;
  me.onUpdate(record, type, modifiedFieldNames, info);
  me.fireEvent('update', me, record, type, modifiedFieldNames, info);
  me.fireEvent('datachanged', me);
}, onCollectionUpdateKey:function(source, details) {
  this.fireEvent('idchanged', this, details.item, details.oldKey, details.newKey);
}, onUpdate:Ext.emptyFn, onCollectionRemove:function(collection, info) {
  var me = this, records = info.items, lastChunk = !info.next;
  if (me.ignoreCollectionRemove) {
    return;
  }
  me.fireEvent('remove', me, records, info.at, false);
  if (lastChunk) {
    me.fireEvent('datachanged', me);
  }
}, onSourceBeforeLoad:function(source, operation) {
  this.fireEvent('beforeload', this, operation);
  this.callObservers('BeforeLoad', [operation]);
}, onSourceAfterLoad:function(source, records, successful, operation) {
  this.fireEvent('load', this, records, successful, operation);
  this.callObservers('AfterLoad', [records, successful, operation]);
}, onFilterEndUpdate:function() {
  Ext.data.AbstractStore.prototype.onFilterEndUpdate.apply(this, arguments);
  this.callObservers('Filter');
}, onSourceBeforePopulate:function() {
  this.ignoreCollectionAdd = true;
  this.callObservers('BeforePopulate');
}, onSourceAfterPopulate:function() {
  var me = this;
  me.ignoreCollectionAdd = false;
  me.fireEvent('datachanged', me);
  me.fireEvent('refresh', me);
  this.callObservers('AfterPopulate');
}, onSourceBeforeClear:function() {
  this.ignoreCollectionRemove = true;
  this.callObservers('BeforeClear');
}, onSourceAfterClear:function() {
  this.ignoreCollectionRemove = false;
  this.callObservers('AfterClear');
}, onSourceBeforeRemoveAll:function() {
  this.ignoreCollectionRemove = true;
  this.callObservers('BeforeRemoveAll');
}, onSourceAfterRemoveAll:function(source, silent) {
  var me = this;
  me.ignoreCollectionRemove = false;
  if (!silent) {
    me.fireEvent('clear', me);
    me.fireEvent('datachanged', me);
  }
  this.callObservers('AfterRemoveAll', [silent]);
}, onSourceFilter:function() {
  var me = this;
  me.fireEvent('refresh', me);
  me.fireEvent('datachanged', me);
}, hasPendingLoad:function() {
  return this.getSourceValue('hasPendingLoad', false);
}, isLoaded:function() {
  return this.getSourceValue('isLoaded', false);
}, isLoading:function() {
  return this.getSourceValue('isLoading', false);
}, doDestroy:function() {
  var me = this;
  me.observers = null;
  me.setSource(null);
  me.getData().destroy(true);
  me.data = null;
  Ext.data.AbstractStore.prototype.doDestroy.call(this);
}, privates:{getSourceValue:function(method, defaultValue) {
  var source = this.getSource(), val = defaultValue;
  if (source && !source.destroyed) {
    val = source[method]();
  }
  return val;
}, isMoving:function() {
  var source = this.getSource();
  return source.isMoving ? source.isMoving.apply(source, arguments) : false;
}, loadsSynchronously:function() {
  return this.getSource().loadsSynchronously();
}}}, 0, 0, 0, 0, ['store.chained'], [[Ext.data.LocalStore.prototype.mixinId || Ext.data.LocalStore.$className, Ext.data.LocalStore]], [Ext.data, 'ChainedStore'], 0);
Ext.cmd.derive('Ext.app.ViewModel', Ext.Base, {isViewModel:true, factoryConfig:{name:'viewModel'}, collectTimeout:100, expressionRe:/^(?:\{(?:(\d+)|([a-z_][\w\.]*))\})$/i, statics:{escape:function(value) {
  var ret = value, key;
  if (typeof value === 'string') {
    ret = '~~' + value;
  } else {
    if (value && value.constructor === Object) {
      ret = {};
      for (key in value) {
        ret[key] = this.escape(value[key]);
      }
    }
  }
  return ret;
}}, $configStrict:false, config:{data:true, formulas:{$value:null, merge:function(newValue, currentValue, target, mixinClass) {
  return this.mergeNew(newValue, currentValue, target, mixinClass);
}}, links:null, parent:null, root:true, scheduler:null, schema:'default', session:null, stores:null, view:null}, constructor:function(config) {
  this.bindings = {};
  this.initConfig(config);
}, destroy:function() {
  var me = this, scheduler = me._scheduler, stores = me.storeInfo, parent = me.getParent(), task = me.collectTask, children = me.children, bindings = me.bindings, key, store, autoDestroy, storeBinding;
  me.destroying = true;
  if (task) {
    task.cancel();
    me.collectTask = null;
  }
  if (children) {
    for (key in children) {
      children[key].destroy();
    }
  }
  if (stores) {
    for (key in stores) {
      store = stores[key];
      storeBinding = store.$binding;
      autoDestroy = store.autoDestroy;
      if (autoDestroy || !store.$wasInstance && autoDestroy !== false) {
        store.destroy();
      }
      Ext.destroy(storeBinding);
    }
  }
  if (parent) {
    parent.unregisterChild(me);
  }
  me.getRoot().destroy();
  for (key in bindings) {
    bindings[key].destroy();
  }
  if (scheduler && scheduler.$owner === me) {
    scheduler.$owner = null;
    scheduler.destroy();
  }
  me.children = me.storeInfo = me._session = me._view = me._scheduler = me.bindings = me._root = me._parent = me.formulaFn = me.$formulaData = null;
  me.destroying = false;
  me.callParent();
}, bind:function(descriptor, callback, scope, options) {
  var me = this, track = true, binding;
  scope = scope || me;
  if (!options && descriptor.bindTo !== undefined && !Ext.isString(descriptor)) {
    options = descriptor;
    descriptor = options.bindTo;
  }
  if (!Ext.isString(descriptor)) {
    binding = new Ext.app.bind.Multi(descriptor, me, callback, scope, options);
  } else {
    if (me.expressionRe.test(descriptor)) {
      descriptor = descriptor.substring(1, descriptor.length - 1);
      binding = me.bindExpression(descriptor, callback, scope, options);
      track = false;
    } else {
      binding = new Ext.app.bind.TemplateBinding(descriptor, me, callback, scope, options);
    }
  }
  if (track) {
    me.bindings[binding.id] = binding;
  }
  return binding;
}, getSession:function() {
  var me = this, session = me._session, parent;
  if (!session && (parent = me.getParent())) {
    me.setSession(session = parent.getSession());
  }
  return session || null;
}, getStore:function(key) {
  var storeInfo = this.storeInfo, store;
  if (storeInfo) {
    store = storeInfo[key];
  }
  return store || null;
}, linkTo:function(key, reference) {
  var me = this, stub, create, id, modelType, linkStub, rec;
  if (reference.isModel) {
    reference = {type:reference.entityName, id:reference.id};
  }
  modelType = reference.type || reference.reference;
  create = reference.create;
  if (modelType) {
    id = reference.id;
    if (create) {
      id = undefined;
    }
    rec = me.getRecord(modelType, id);
    if (Ext.isObject(create)) {
      rec.set(create);
      rec.commit();
      rec.phantom = true;
    }
    stub = me.getRoot().createStubChild(key);
    stub.set(rec);
  } else {
    stub = me.getStub(key);
    if (!stub.isLinkStub) {
      linkStub = new Ext.app.bind.LinkStub(me, stub.name);
      stub.graft(linkStub);
      stub = linkStub;
    }
    stub.link(reference);
  }
}, notify:function() {
  var scheduler = this.getScheduler();
  if (!scheduler.firing) {
    scheduler.notify();
  }
}, get:function(path) {
  return this.getStub(path).getValue();
}, set:function(path, value) {
  var me = this, obj, stub;
  me.getData();
  if (value === undefined && path && path.constructor === Object) {
    stub = me.getRoot();
    value = path;
  } else {
    if (path && path.indexOf('.') < 0) {
      obj = {};
      obj[path] = value;
      value = obj;
      stub = me.getRoot();
    } else {
      stub = me.getStub(path);
    }
  }
  stub.set(value);
}, privates:{registerChild:function(child) {
  var children = this.children;
  if (!children) {
    this.children = children = {};
  }
  children[child.getId()] = child;
}, unregisterChild:function(child) {
  var children = this.children;
  if (!this.destroying && children) {
    delete children[child.getId()];
  }
}, getRecord:function(type, id) {
  var session = this.getSession(), Model = type, hasId = id !== undefined, record;
  if (session) {
    if (hasId) {
      record = session.getRecord(type, id);
    } else {
      record = session.createRecord(type);
    }
  } else {
    if (!Model.$isClass) {
      Model = this.getSchema().getEntity(Model);
    }
    if (hasId) {
      record = Model.createWithId(id);
      record.load();
    } else {
      record = new Model;
    }
  }
  return record;
}, bindExpression:function(descriptor, callback, scope, options) {
  var stub = this.getStub(descriptor);
  return stub.bind(callback, scope, options);
}, applyScheduler:function(scheduler) {
  if (scheduler && !scheduler.isInstance) {
    if (scheduler === true) {
      scheduler = {};
    }
    if (!('preSort' in scheduler)) {
      scheduler = Ext.apply({preSort:'kind,-depth'}, scheduler);
    }
    scheduler = new Ext.util.Scheduler(scheduler);
    scheduler.$owner = this;
  }
  return scheduler;
}, getScheduler:function() {
  var me = this, scheduler = me._scheduler, parent;
  if (!scheduler) {
    if (!(parent = me.getParent())) {
      scheduler = new Ext.util.Scheduler({preSort:'kind,-depth'});
      scheduler.$owner = me;
    } else {
      scheduler = parent.getScheduler();
    }
    me.setScheduler(scheduler);
  }
  return scheduler;
}, getStub:function(bindDescr) {
  var root = this.getRoot();
  return bindDescr ? root.getChild(bindDescr) : root;
}, collect:function() {
  var me = this, parent = me.getParent(), task = me.collectTask;
  if (parent) {
    parent.collect();
    return;
  }
  if (!task) {
    task = me.collectTask = new Ext.util.DelayedTask(me.doCollect, me);
  }
  if (me.collectTimeout === 0) {
    me.doCollect();
  } else {
    task.delay(me.collectTimeout);
  }
}, doCollect:function() {
  var children = this.children, key;
  if (children) {
    for (key in children) {
      children[key].doCollect();
    }
  }
  this.getRoot().collect();
}, invalidateChildLinks:function(name, clear) {
  var children = this.children, key;
  if (children) {
    for (key in children) {
      children[key].getRoot().invalidateChildLink(name, clear);
    }
  }
}, onBindDestroy:function(binding, fromChild) {
  var me = this, parent;
  if (me.destroying) {
    return;
  }
  if (!fromChild) {
    delete me.bindings[binding.id];
  }
  parent = me.getParent();
  if (parent) {
    parent.onBindDestroy(binding, true);
  } else {
    me.collect();
  }
}, applyData:function(newData, data) {
  var me = this, linkData, parent;
  me.getSession();
  if (!data) {
    parent = me.getParent();
    me.linkData = linkData = parent ? Ext.Object.chain(parent.getData()) : {};
    me.data = me._data = Ext.Object.chain(linkData);
  }
  if (newData && newData.constructor === Object) {
    me.getRoot().set(newData, true);
  }
}, applyParent:function(parent) {
  if (parent) {
    parent.registerChild(this);
  }
  return parent;
}, applyStores:function(stores) {
  var me = this, root = me.getRoot(), key, cfg, storeBind, stub, listeners;
  me.storeInfo = {};
  me.listenerScopeFn = function() {
    return me.getView().getInheritedConfig('defaultListenerScope');
  };
  for (key in stores) {
    cfg = stores[key];
    if (cfg.isStore) {
      cfg.$wasInstance = true;
      me.setupStore(cfg, key);
      continue;
    } else {
      if (Ext.isString(cfg)) {
        cfg = {source:cfg};
      } else {
        cfg = Ext.apply({}, cfg);
      }
    }
    listeners = cfg.listeners;
    delete cfg.listeners;
    storeBind = me.bind(cfg, me.onStoreBind, me, {trackStatics:true});
    if (storeBind.isStatic()) {
      storeBind.destroy();
      me.createStore(key, cfg, listeners);
    } else {
      storeBind.$storeKey = key;
      storeBind.$listeners = listeners;
      stub = root.createStubChild(key);
      stub.setStore(storeBind);
    }
  }
}, onStoreBind:function(cfg, oldValue, binding) {
  var info = this.storeInfo, key = binding.$storeKey, store = info[key], proxy;
  if (!store) {
    this.createStore(key, cfg, binding.$listeners, binding);
  } else {
    cfg = Ext.merge({}, binding.pruneStaticKeys());
    proxy = cfg.proxy;
    delete cfg.type;
    delete cfg.model;
    delete cfg.fields;
    delete cfg.proxy;
    delete cfg.listeners;
    if (proxy) {
      delete proxy.reader;
      delete proxy.writer;
      store.getProxy().setConfig(proxy);
    }
    store.setConfig(cfg);
  }
}, createStore:function(key, cfg, listeners, binding) {
  var session = this.getSession(), store;
  cfg = Ext.apply({}, cfg);
  if (cfg.session) {
    cfg.session = session;
  }
  if (cfg.source) {
    cfg.type = cfg.type || 'chained';
  }
  cfg.listeners = listeners;
  cfg.resolveListenerScope = this.listenerScopeFn;
  store = Ext.Factory.store(cfg);
  store.$binding = binding;
  this.setupStore(store, key);
}, setupStore:function(store, key) {
  store.resolveListenerScope = this.listenerScopeFn;
  this.storeInfo[key] = store;
  this.set(key, store);
}, applyFormulas:function(formulas) {
  var me = this, root = me.getRoot(), name, stub;
  me.getData();
  for (name in formulas) {
    root.createStubChild(name);
    stub = me.getStub(name);
    stub.setFormula(formulas[name]);
  }
  return formulas;
}, applyLinks:function(links) {
  for (var link in links) {
    this.linkTo(link, links[link]);
  }
}, applySchema:function(schema) {
  return Ext.data.schema.Schema.get(schema);
}, applyRoot:function() {
  var root = new Ext.app.bind.RootStub(this), parent = this.getParent();
  if (parent) {
    root.depth = parent.getRoot().depth - 1000;
  }
  return root;
}, getFormulaFn:function(data) {
  var me = this, fn = me.formulaFn;
  if (!fn) {
    fn = me.formulaFn = function(name) {
      return me.$formulaData[name];
    };
  }
  me.$formulaData = data;
  return fn;
}}}, 1, 0, 0, 0, ['viewmodel.default'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable], [Ext.mixin.Identifiable.prototype.mixinId || Ext.mixin.Identifiable.$className, Ext.mixin.Identifiable]], [Ext.app, 'ViewModel'], 0);
Ext.cmd.derive('Ext.app.domain.Controller', Ext.app.EventDomain, {singleton:true, type:'controller', prefix:'controller.', idMatchRe:/^\#/, constructor:function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.app.BaseController);
}, match:function(target, selector) {
  var result = false, alias = target.alias;
  if (selector === '*') {
    result = true;
  } else {
    if (selector === '#') {
      result = !!target.isApplication;
    } else {
      if (this.idMatchRe.test(selector)) {
        result = target.getId() === selector.substring(1);
      } else {
        if (alias) {
          result = Ext.Array.indexOf(alias, this.prefix + selector) > -1;
        }
      }
    }
  }
  return result;
}}, 1, 0, 0, 0, 0, 0, [Ext.app.domain, 'Controller'], 0);
Ext.cmd.derive('Ext.data.JsonStore', Ext.data.Store, {constructor:function(config) {
  config = Ext.apply({proxy:{type:'ajax', reader:'json', writer:'json'}}, config);
  Ext.data.Store.prototype.constructor.call(this, config);
}}, 1, 0, 0, 0, ['store.json'], 0, [Ext.data, 'JsonStore'], 0);
Ext.cmd.derive('Ext.data.NodeInterface', Ext.Base, {statics:{decorate:function(modelClass) {
  var model = Ext.data.schema.Schema.lookupEntity(modelClass), proto = model.prototype, idName, idField, idType;
  if (!model.prototype.isObservable) {
    model.mixin(Ext.mixin.Observable.prototype.mixinId, Ext.mixin.Observable);
  }
  if (proto.isNode) {
    return;
  }
  idName = proto.idProperty;
  idField = model.getField(idName);
  idType = idField.type;
  model.override(this.getPrototypeBody());
  model.addFields([{name:'parentId', type:idType, defaultValue:null, allowNull:idField.allowNull}, {name:'index', type:'int', defaultValue:-1, persist:false, convert:null}, {name:'depth', type:'int', defaultValue:0, persist:false, convert:null}, {name:'expanded', type:'bool', defaultValue:false, persist:false, convert:null}, {name:'expandable', type:'bool', defaultValue:true, persist:false, convert:null}, {name:'checked', type:'auto', defaultValue:null, persist:false, convert:null}, {name:'leaf', 
  type:'bool', defaultValue:false}, {name:'cls', type:'string', defaultValue:'', persist:false, convert:null}, {name:'iconCls', type:'string', defaultValue:'', persist:false, convert:null}, {name:'icon', type:'string', defaultValue:'', persist:false, convert:null}, {name:'glyph', type:'string', defaultValue:'', persist:false, convert:null}, {name:'root', type:'boolean', defaultValue:false, persist:false, convert:null}, {name:'isLast', type:'boolean', defaultValue:false, persist:false, convert:null}, 
  {name:'isFirst', type:'boolean', defaultValue:false, persist:false, convert:null}, {name:'allowDrop', type:'boolean', defaultValue:true, persist:false, convert:null}, {name:'allowDrag', type:'boolean', defaultValue:true, persist:false, convert:null}, {name:'loaded', type:'boolean', defaultValue:false, persist:false, convert:null}, {name:'loading', type:'boolean', defaultValue:false, persist:false, convert:null}, {name:'href', type:'string', defaultValue:'', persist:false, convert:null}, {name:'hrefTarget', 
  type:'string', defaultValue:'', persist:false, convert:null}, {name:'qtip', type:'string', defaultValue:'', persist:false, convert:null}, {name:'qtitle', type:'string', defaultValue:'', persist:false, convert:null}, {name:'qshowDelay', type:'int', defaultValue:0, persist:false, convert:null}, {name:'children', type:'auto', defaultValue:null, persist:false, convert:null}, {name:'visible', type:'boolean', defaultValue:true, persist:false}, {name:'text', type:'string', persist:false}]);
}, getPrototypeBody:function() {
  var bubbledEvents = {idchanged:true, append:true, remove:true, move:true, insert:true, beforeappend:true, beforeremove:true, beforemove:true, beforeinsert:true, expand:true, collapse:true, beforeexpand:true, beforecollapse:true, sort:true}, silently = {silent:true};
  return {isNode:true, firstChild:null, lastChild:null, parentNode:null, previousSibling:null, nextSibling:null, constructor:function() {
    var me = this;
    me.mixins.observable.constructor.call(me);
    me.callParent(arguments);
    me.childNodes = [];
    return me;
  }, createNode:function(node) {
    var me = this, childType = me.childType, store, storeReader, nodeProxy, nodeReader, reader, typeProperty, T = me.self;
    if (!node.isModel) {
      if (childType) {
        T = me.schema.getEntity(childType);
      } else {
        store = me.getTreeStore();
        storeReader = store && store.getProxy().getReader();
        nodeProxy = me.getProxy();
        nodeReader = nodeProxy ? nodeProxy.getReader() : null;
        reader = !storeReader || nodeReader && nodeReader.initialConfig.typeProperty ? nodeReader : storeReader;
        if (reader) {
          typeProperty = reader.getTypeProperty();
          if (typeProperty) {
            T = reader.getChildType(me.schema, node, typeProperty);
          }
        }
      }
      node = new T(node);
    }
    if (!node.childNodes) {
      node.firstChild = node.lastChild = node.parentNode = node.previousSibling = node.nextSibling = null;
      node.childNodes = [];
    }
    return node;
  }, isLeaf:function() {
    return this.get('leaf') === true;
  }, setFirstChild:function(node) {
    this.firstChild = node;
  }, setLastChild:function(node) {
    this.lastChild = node;
  }, updateInfo:function(commit, info) {
    var me = this, phantom = me.phantom, result;
    commit = {silent:true, commit:commit};
    if (info.depth != null && info.depth !== me.data.depth) {
      var childInfo = {depth:info.depth + 1}, children = me.childNodes, childCount = children.length, i;
      for (i = 0; i < childCount; i++) {
        children[i].updateInfo(commit, childInfo);
      }
    }
    result = me.set(info, commit);
    me.phantom = phantom;
    return result;
  }, isLast:function() {
    return this.get('isLast');
  }, isFirst:function() {
    return this.get('isFirst');
  }, hasChildNodes:function() {
    return !this.isLeaf() && this.childNodes.length > 0;
  }, isExpandable:function() {
    var me = this;
    if (me.get('expandable')) {
      return !(me.isLeaf() || me.isLoaded() && !me.phantom && !me.hasChildNodes());
    }
    return false;
  }, triggerUIUpdate:function() {
    this.callJoined('afterEdit', []);
  }, appendChild:function(node, suppressEvents, commit) {
    var me = this, i, ln, index, oldParent, previousSibling, childInfo = {isLast:true, parentId:me.getId(), depth:(me.data.depth || 0) + 1}, result, treeStore = me.getTreeStore(), halfCheckedValue = treeStore && treeStore.triStateCheckbox ? 1 : false, bulkUpdate = treeStore && treeStore.bulkUpdate, meChecked, nodeChecked, modifiedFields;
    Ext.suspendLayouts();
    if (Ext.isArray(node)) {
      ln = node.length;
      result = new Array(ln);
      me.callTreeStore('beginFill');
      for (i = 0; i < ln; i++) {
        result[i] = me.appendChild(node[i], suppressEvents, commit);
      }
      me.callTreeStore('endFill', [result]);
    } else {
      node = me.createNode(node);
      if (suppressEvents !== true && me.fireBubbledEvent('beforeappend', [me, node]) === false) {
        Ext.resumeLayouts(true);
        return false;
      }
      index = me.childNodes.length;
      oldParent = node.parentNode;
      if (oldParent) {
        if (suppressEvents !== true && node.fireBubbledEvent('beforemove', [node, oldParent, me, index]) === false) {
          Ext.resumeLayouts(true);
          return false;
        }
        if (oldParent.removeChild(node, false, suppressEvents, oldParent.getTreeStore() === treeStore) === false) {
          Ext.resumeLayouts(true);
          return false;
        }
      }
      treeStore && treeStore.beginUpdate();
      index = me.childNodes.length;
      if (index === 0) {
        me.setFirstChild(node);
      }
      me.childNodes[index] = node;
      node.parentNode = me;
      node.nextSibling = null;
      me.setLastChild(node);
      previousSibling = me.childNodes[index - 1];
      if (previousSibling) {
        node.previousSibling = previousSibling;
        previousSibling.nextSibling = node;
        previousSibling.updateInfo(commit, {isLast:false});
        if (!bulkUpdate) {
          previousSibling.triggerUIUpdate();
        }
      } else {
        node.previousSibling = null;
      }
      childInfo.isFirst = index === 0;
      childInfo.index = index;
      modifiedFields = node.updateInfo(commit, childInfo);
      if (me.isLeaf()) {
        me.set('leaf', false);
      }
      if (!me.isLoaded()) {
        if (bulkUpdate) {
          me.data.loaded = true;
        } else {
          me.set('loaded', true);
        }
      } else {
        if (me.childNodes.length === 1 && !bulkUpdate) {
          me.triggerUIUpdate();
        }
      }
      if (index && me.childNodes[index - 1].isExpanded() && !bulkUpdate) {
        me.childNodes[index - 1].cascade(me.triggerUIUpdate);
      }
      if (treeStore) {
        treeStore.registerNode(me, !bulkUpdate);
        if (bulkUpdate) {
          treeStore.registerNode(node);
        }
      }
      if (suppressEvents !== true) {
        me.fireBubbledEvent('append', [me, node, index]);
        if (oldParent) {
          node.fireBubbledEvent('move', [node, oldParent, me, index]);
        }
      }
      me.callTreeStore('onNodeAppend', [node, index]);
      if (modifiedFields) {
        node.callJoined('afterEdit', [modifiedFields]);
      }
      result = node;
      if (treeStore) {
        treeStore.endUpdate();
      }
    }
    Ext.resumeLayouts(true);
    return result;
  }, getOwnerTree:function() {
    var store = this.getTreeStore();
    return store && store.ownerTree;
  }, getTreeStore:function() {
    var root = this;
    while (root && !root.treeStore) {
      root = root.parentNode;
    }
    return root && root.treeStore;
  }, removeChild:function(node, erase, suppressEvents, isMove) {
    var me = this, index = me.indexOf(node), i, childCount, previousSibling, treeStore = me.getTreeStore(), bulkUpdate = treeStore && treeStore.bulkUpdate, removeContext, removeRange = [];
    if (index === -1 || suppressEvents !== true && me.fireBubbledEvent('beforeremove', [me, node, !!isMove]) === false) {
      return false;
    }
    Ext.suspendLayouts();
    treeStore && treeStore.beginUpdate();
    Ext.Array.erase(me.childNodes, index, 1);
    if (me.firstChild === node) {
      me.setFirstChild(node.nextSibling);
    }
    if (me.lastChild === node) {
      me.setLastChild(node.previousSibling);
    }
    previousSibling = node.previousSibling;
    if (previousSibling) {
      node.previousSibling.nextSibling = node.nextSibling;
    }
    if (node.nextSibling) {
      node.nextSibling.previousSibling = node.previousSibling;
      if (index === 0) {
        node.nextSibling.updateInfo(false, {isFirst:true});
      }
      for (i = index, childCount = me.childNodes.length; i < childCount; i++) {
        me.childNodes[i].updateInfo(false, {index:i});
      }
    } else {
      if (previousSibling) {
        previousSibling.updateInfo(false, {isLast:true});
        if (!bulkUpdate) {
          if (previousSibling.isExpanded()) {
            previousSibling.cascade(me.triggerUIUpdate);
          } else {
            previousSibling.triggerUIUpdate();
          }
        }
      }
    }
    if (!me.childNodes.length && !bulkUpdate) {
      me.triggerUIUpdate();
    }
    Ext.resumeLayouts(true);
    if (suppressEvents !== true) {
      removeContext = {parentNode:node.parentNode, previousSibling:node.previousSibling, nextSibling:node.nextSibling};
      me.callTreeStore('beforeNodeRemove', [[node], !!isMove, removeRange]);
      node.previousSibling = node.nextSibling = node.parentNode = null;
      me.fireBubbledEvent('remove', [me, node, !!isMove, removeContext]);
      me.callTreeStore('onNodeRemove', [[node], !!isMove, removeRange]);
    }
    if (erase) {
      node.erase(true);
    } else {
      node.clear();
    }
    if (!isMove) {
      node.set({parentId:null, lastParentId:me.getId()}, silently);
    }
    if (treeStore) {
      treeStore.endUpdate();
    }
    return node;
  }, copy:function(newId, session, deep) {
    var me = this, result, args = [newId], len = me.childNodes ? me.childNodes.length : 0, i;
    if (session && session.isSession) {
      args.push(session);
    } else {
      if (arguments.length < 3) {
        deep = session;
      }
    }
    result = me.callParent(args);
    if (deep) {
      for (i = 0; i < len; i++) {
        result.appendChild(me.childNodes[i].copy(undefined, true));
      }
    }
    return result;
  }, clear:function(erase, resetChildren) {
    var me = this, data;
    me.parentNode = me.previousSibling = me.nextSibling = null;
    if (erase) {
      me.firstChild = me.lastChild = me.childNodes = null;
    }
    if (resetChildren) {
      me.firstChild = me.lastChild = null;
      me.childNodes.length = 0;
      if (me.data) {
        me.data.children = null;
      }
    }
  }, drop:function() {
    var me = this, childNodes = me.childNodes, parentNode = me.parentNode, len, i, node, treeStore = me.getTreeStore();
    me.callParent();
    if (parentNode) {
      parentNode.removeChild(me);
    } else {
      if (me.get('root')) {
        treeStore.setRoot(null);
      }
    }
    treeStore && treeStore.beginUpdate();
    for (i = 0, len = childNodes ? childNodes.length : 0; i < len; i++) {
      node = childNodes[i];
      node.clear();
      node.drop();
    }
    treeStore && treeStore.endUpdate();
  }, erase:function(options) {
    var me = this, childNodes = me.childNodes, len = childNodes && childNodes.length, i, node;
    me.remove();
    me.clear(true);
    me.callParent([options]);
    for (i = 0; i < len; i++) {
      node = childNodes[i];
      node.parentNode = null;
      node.erase(options);
    }
  }, insertBefore:function(node, refNode, suppressEvents) {
    var me = this, index = me.indexOf(refNode), oldParent = node.parentNode, refIndex = index, childCount, previousSibling, i, treeStore = me.getTreeStore(), bulkUpdate = treeStore && treeStore.bulkUpdate, modifiedFields, sibling, siblingModifiedFields;
    if (!refNode) {
      return me.appendChild(node);
    }
    if (node === refNode) {
      return false;
    }
    node = me.createNode(node);
    if (suppressEvents !== true && me.fireBubbledEvent('beforeinsert', [me, node, refNode]) === false) {
      return false;
    }
    if (oldParent === me && me.indexOf(node) < index) {
      refIndex--;
    }
    if (oldParent) {
      if (suppressEvents !== true && node.fireBubbledEvent('beforemove', [node, oldParent, me, index, refNode]) === false) {
        return false;
      }
      if (oldParent.removeChild(node, false, suppressEvents, oldParent.getTreeStore() === treeStore) === false) {
        return false;
      }
    }
    treeStore && treeStore.beginUpdate();
    if (refIndex === 0) {
      me.setFirstChild(node);
    }
    Ext.Array.splice(me.childNodes, refIndex, 0, node);
    node.parentNode = me;
    node.nextSibling = refNode;
    refNode.previousSibling = node;
    previousSibling = me.childNodes[refIndex - 1];
    if (previousSibling) {
      node.previousSibling = previousSibling;
      previousSibling.nextSibling = node;
    } else {
      node.previousSibling = null;
    }
    modifiedFields = node.updateInfo(false, {parentId:me.getId(), index:refIndex, isFirst:refIndex === 0, isLast:false, depth:(me.data.depth || 0) + 1});
    for (i = refIndex + 1, childCount = me.childNodes.length; i < childCount; i++) {
      sibling = me.childNodes[i];
      siblingModifiedFields = sibling.updateInfo(false, {index:i});
      if (siblingModifiedFields) {
        sibling.callJoined('afterEdit', [siblingModifiedFields]);
      }
    }
    if (!me.isLoaded()) {
      if (bulkUpdate) {
        me.data.loaded = true;
      } else {
        me.set('loaded', true);
      }
    } else {
      if (me.childNodes.length === 1 && !bulkUpdate) {
        me.triggerUIUpdate();
      }
    }
    if (treeStore) {
      treeStore.registerNode(me, !bulkUpdate);
    }
    if (suppressEvents !== true) {
      me.fireBubbledEvent('insert', [me, node, refNode]);
      if (oldParent) {
        node.fireBubbledEvent('move', [node, oldParent, me, refIndex, refNode]);
      }
    }
    me.callTreeStore('onNodeInsert', [node, refIndex]);
    if (modifiedFields) {
      node.callJoined('afterEdit', [modifiedFields]);
    }
    if (treeStore) {
      treeStore.endUpdate();
    }
    return node;
  }, insertChild:function(index, node) {
    var sibling = this.childNodes[index];
    if (sibling) {
      return this.insertBefore(node, sibling);
    } else {
      return this.appendChild(node);
    }
  }, isLastVisible:function() {
    var me = this, result = me.data.isLast, next = me.nextSibling;
    if (!result && me.getTreeStore().isFiltered()) {
      while (next) {
        if (next.data.visible) {
          return false;
        }
        next = next.nextSibling;
      }
      return true;
    }
    return result;
  }, remove:function(erase, suppressEvents) {
    var me = this, parentNode = me.parentNode;
    if (parentNode) {
      parentNode.removeChild(me, erase, suppressEvents);
    } else {
      if (erase) {
        me.erase(true);
      }
    }
    return me;
  }, removeAll:function(erase, suppressEvents, fromParent) {
    var me = this, childNodes = me.childNodes, len = childNodes.length, node, treeStore, i, removeRange = [];
    if (!len) {
      return me;
    }
    if (!fromParent) {
      treeStore = me.getTreeStore();
      if (treeStore) {
        treeStore.beginUpdate();
        treeStore.suspendEvent('remove');
        me.callTreeStore('beforeNodeRemove', [childNodes, false, removeRange]);
      }
    }
    for (i = 0; i < len; ++i) {
      node = childNodes[i];
      node.previousSibling = node.nextSibling = node.parentNode = null;
      me.fireBubbledEvent('remove', [me, node, false]);
      if (erase) {
        node.erase(true);
      } else {
        node.removeAll(false, suppressEvents, true);
      }
    }
    if (!fromParent && treeStore) {
      treeStore.resumeEvent('remove');
      me.callTreeStore('onNodeRemove', [childNodes, false, removeRange]);
      treeStore.endUpdate();
    }
    me.firstChild = me.lastChild = null;
    childNodes.length = 0;
    if (!fromParent) {
      me.triggerUIUpdate();
    }
    return me;
  }, getChildAt:function(index) {
    return this.childNodes[index];
  }, replaceChild:function(newChild, oldChild, suppressEvents) {
    var s = oldChild ? oldChild.nextSibling : null;
    this.removeChild(oldChild, false, suppressEvents);
    this.insertBefore(newChild, s, suppressEvents);
    return oldChild;
  }, indexOf:function(child) {
    return Ext.Array.indexOf(this.childNodes, child);
  }, indexOfId:function(id) {
    var childNodes = this.childNodes, len = childNodes.length, i = 0;
    for (; i < len; ++i) {
      if (childNodes[i].getId() === id) {
        return i;
      }
    }
    return -1;
  }, getPath:function(field, separator) {
    field = field || this.idProperty;
    separator = separator || '/';
    var path = [this.get(field)], parent = this.parentNode;
    while (parent) {
      path.unshift(parent.get(field));
      parent = parent.parentNode;
    }
    return separator + path.join(separator);
  }, getDepth:function() {
    return this.get('depth');
  }, bubble:function(fn, scope, args) {
    var p = this;
    while (p) {
      if (fn.apply(scope || p, args || [p]) === false) {
        break;
      }
      p = p.parentNode;
    }
  }, cascade:function(spec, scope, args, after) {
    var me = this, before = spec;
    if (arguments.length === 1 && !Ext.isFunction(spec)) {
      after = spec.after;
      scope = spec.scope;
      args = spec.args;
      before = spec.before;
    }
    if (!before || before.apply(scope || me, args || [me]) !== false) {
      var childNodes = me.childNodes, length = childNodes.length, i;
      for (i = 0; i < length; i++) {
        childNodes[i].cascade.call(childNodes[i], before, scope, args, after);
      }
      if (after) {
        after.apply(scope || me, args || [me]);
      }
    }
  }, cascadeBy:function() {
    return this.cascade.apply(this, arguments);
  }, eachChild:function(fn, scope, args) {
    var childNodes = this.childNodes, length = childNodes.length, i;
    for (i = 0; i < length; i++) {
      if (fn.apply(scope || this, args || [childNodes[i]]) === false) {
        break;
      }
    }
  }, findChild:function(attribute, value, deep) {
    return this.findChildBy(function() {
      return this.get(attribute) == value;
    }, null, deep);
  }, findChildBy:function(fn, scope, deep) {
    var cs = this.childNodes, len = cs.length, i = 0, n, res;
    for (; i < len; i++) {
      n = cs[i];
      if (fn.call(scope || n, n) === true) {
        return n;
      } else {
        if (deep) {
          res = n.findChildBy(fn, scope, deep);
          if (res !== null) {
            return res;
          }
        }
      }
    }
    return null;
  }, contains:function(node) {
    return node.isAncestor(this);
  }, isAncestor:function(node) {
    var p = this.parentNode;
    while (p) {
      if (p === node) {
        return true;
      }
      p = p.parentNode;
    }
    return false;
  }, sort:function(sortFn, recursive, suppressEvent) {
    var me = this, childNodes = me.childNodes, ln = childNodes.length, i, n, info = {isFirst:true};
    if (ln > 0) {
      if (!sortFn) {
        sortFn = me.getTreeStore().getSortFn();
      }
      Ext.Array.sort(childNodes, sortFn);
      me.setFirstChild(childNodes[0]);
      me.setLastChild(childNodes[ln - 1]);
      for (i = 0; i < ln; i++) {
        n = childNodes[i];
        n.previousSibling = childNodes[i - 1];
        n.nextSibling = childNodes[i + 1];
        info.isLast = i === ln - 1;
        info.index = i;
        n.updateInfo(false, info);
        info.isFirst = false;
        if (recursive && !n.isLeaf()) {
          n.sort(sortFn, true, true);
        }
      }
      if (suppressEvent !== true) {
        me.fireBubbledEvent('sort', [me, childNodes]);
        me.callTreeStore('onNodeSort', [childNodes]);
      }
    }
  }, isExpanded:function() {
    return this.get('expanded');
  }, isLoaded:function() {
    return this.get('loaded');
  }, isBranchLoaded:function() {
    var isBranchLoaded = !this.isLeaf() && this.isLoaded();
    if (isBranchLoaded) {
      this.cascade(function(node) {
        if (!node.isLeaf()) {
          isBranchLoaded = isBranchLoaded || node.isBranchLoaded();
        }
        return isBranchLoaded;
      });
    }
    return isBranchLoaded;
  }, isLoading:function() {
    return this.get('loading');
  }, isRoot:function() {
    return !this.parentNode;
  }, isVisible:function() {
    var parent = this.parentNode;
    while (parent) {
      if (!parent.isExpanded()) {
        return false;
      }
      parent = parent.parentNode;
    }
    return true;
  }, expand:function(recursive, callback, scope) {
    var me = this, treeStore, resumeAddEvent;
    if (!me.isLeaf()) {
      if (me.isLoading()) {
        me.on('expand', function() {
          me.expand(recursive, callback, scope);
        }, me, {single:true});
      } else {
        if (!me.isExpanded()) {
          if (me.fireBubbledEvent('beforeexpand', [me]) !== false) {
            if (recursive) {
              if (me.parentNode && me.parentNode.isSynchronousRecursiveExpand) {
                me.isSynchronousRecursiveExpand = true;
              } else {
                treeStore = me.getTreeStore();
                if (treeStore.getProxy().isSynchronous || me.isBranchLoaded()) {
                  me.isSynchronousRecursiveExpand = true;
                  treeStore.suspendEvent('add', 'datachanged');
                  resumeAddEvent = true;
                }
              }
            }
            me.callTreeStore('onBeforeNodeExpand', [me.onChildNodesAvailable, me, [recursive, callback, scope]]);
            if (resumeAddEvent) {
              treeStore.resumeEvent('add', 'datachanged');
              treeStore.fireEvent('datachanged', treeStore);
              treeStore.fireEvent('refresh', treeStore);
            }
            me.isSynchronousRecursiveExpand = false;
          }
        } else {
          if (recursive) {
            me.expandChildren(true, callback, scope);
          } else {
            Ext.callback(callback, scope || me, [me.childNodes]);
          }
        }
      }
    } else {
      Ext.callback(callback, scope || me);
    }
  }, onChildNodesAvailable:function(records, recursive, callback, scope) {
    var me = this, treeStore = me.getTreeStore(), bulkUpdate = treeStore && treeStore.bulkUpdate, ancestor, i, collapsedAncestors;
    Ext.suspendLayouts();
    for (ancestor = me.parentNode; ancestor; ancestor = ancestor.parentNode) {
      if (!ancestor.isExpanded()) {
        (collapsedAncestors || (collapsedAncestors = [])).unshift(ancestor);
      }
    }
    if (bulkUpdate || !treeStore.isVisible(me)) {
      me.data.expanded = true;
    } else {
      me.set('expanded', true);
    }
    if (collapsedAncestors) {
      for (i = 1; i < collapsedAncestors.length; i++) {
        ancestor = collapsedAncestors[i];
        if (bulkUpdate || !treeStore.isVisible(ancestor)) {
          ancestor.data.expanded = true;
        } else {
          ancestor.set('expanded', true);
        }
      }
      collapsedAncestors[0].expand();
      for (i = 1; i < collapsedAncestors.length; i++) {
        ancestor = collapsedAncestors[i];
        ancestor.fireBubbledEvent('expand', [ancestor, ancestor.childNodes]);
      }
    } else {
      me.callTreeStore('onNodeExpand', [records, false]);
    }
    me.fireBubbledEvent('expand', [me, records]);
    if (recursive) {
      me.expandChildren(true, callback, scope);
    } else {
      Ext.callback(callback, scope || me, [me.childNodes]);
    }
    Ext.resumeLayouts(true);
  }, expandChildren:function(recursive, callback, scope, singleExpand) {
    var me = this, origCallback, i, allNodes, expandNodes, ln, node, treeStore;
    if (Ext.isBoolean(callback)) {
      origCallback = callback;
      callback = scope;
      scope = singleExpand;
      singleExpand = origCallback;
    }
    if (singleExpand === undefined) {
      treeStore = me.getTreeStore();
      singleExpand = treeStore && treeStore.singleExpand;
    }
    allNodes = me.childNodes;
    expandNodes = [];
    ln = singleExpand ? Math.min(allNodes.length, 1) : allNodes.length;
    for (i = 0; i < ln; ++i) {
      node = allNodes[i];
      if (!node.isLeaf()) {
        expandNodes[expandNodes.length] = node;
      }
    }
    ln = expandNodes.length;
    for (i = 0; i < ln; ++i) {
      expandNodes[i].expand(recursive);
    }
    if (callback) {
      Ext.callback(callback, scope || me, [me.childNodes]);
    }
  }, collapse:function(recursive, callback, scope) {
    var me = this, expanded = me.isExpanded(), treeStore = me.getTreeStore(), bulkUpdate = treeStore && treeStore.bulkUpdate, len = me.childNodes.length, i, collapseChildren;
    if (!me.isLeaf() && (!expanded && recursive || me.fireBubbledEvent('beforecollapse', [me]) !== false)) {
      Ext.suspendLayouts();
      if (me.isExpanded()) {
        if (recursive) {
          collapseChildren = function() {
            for (i = 0; i < len; i++) {
              me.childNodes[i].setCollapsed(true);
            }
          };
          if (callback) {
            callback = Ext.Function.createSequence(collapseChildren, Ext.Function.bind(callback, scope, [me.childNodes]));
          } else {
            callback = collapseChildren;
          }
        } else {
          if (callback) {
            callback = Ext.Function.bind(callback, scope, [me.childNodes]);
          }
        }
        if (bulkUpdate || !treeStore.contains(me)) {
          me.data.expanded = false;
        } else {
          me.set('expanded', false);
        }
        me.callTreeStore('onNodeCollapse', [me.childNodes, callback, scope]);
        me.fireBubbledEvent('collapse', [me, me.childNodes]);
        callback = null;
      } else {
        if (recursive) {
          for (i = 0; i < len; i++) {
            me.childNodes[i].setCollapsed(true);
          }
        }
      }
      Ext.resumeLayouts(true);
    }
    Ext.callback(callback, scope || me, [me.childNodes]);
  }, setCollapsed:function(recursive) {
    var me = this, len = me.childNodes.length, i;
    if (!me.isLeaf() && me.fireBubbledEvent('beforecollapse', [me]) !== false) {
      me.data.expanded = false;
      me.fireBubbledEvent('collapse', [me, me.childNodes]);
      if (recursive) {
        for (i = 0; i < len; i++) {
          me.childNodes[i].setCollapsed(true);
        }
      }
    }
  }, collapseChildren:function(recursive, callback, scope) {
    var me = this, i, allNodes = me.childNodes, ln = allNodes.length, collapseNodes = [], node;
    for (i = 0; i < ln; ++i) {
      node = allNodes[i];
      if (!node.isLeaf() && node.isLoaded() && node.isExpanded()) {
        collapseNodes.push(node);
      }
    }
    ln = collapseNodes.length;
    if (ln) {
      for (i = 0; i < ln; ++i) {
        node = collapseNodes[i];
        if (i === ln - 1) {
          node.collapse(recursive, callback, scope);
        } else {
          node.collapse(recursive);
        }
      }
    } else {
      Ext.callback(callback, scope);
    }
  }, fireEvent:function(eventName) {
    return this.fireBubbledEvent(eventName, Ext.Array.slice(arguments, 1));
  }, fireBubbledEvent:function(eventName, args) {
    var result, eventSource, topNode;
    if (bubbledEvents[eventName]) {
      for (eventSource = this; result !== false && eventSource; eventSource = (topNode = eventSource).parentNode) {
        result = eventSource.fireEventArgs.call(eventSource, eventName, args);
      }
      if (result !== false) {
        eventSource = topNode.getTreeStore();
        if (eventSource && eventSource.hasListeners && eventSource.hasListeners[eventName = 'node' + eventName]) {
          result = eventSource.fireEventArgs(eventName, args);
        }
      }
      return result;
    } else {
      return this.fireEventArgs.apply(this, arguments);
    }
  }, serialize:function(writerParam) {
    var writer = writerParam || new Ext.data.writer.Json({writeAllFields:true}), result = writer.getRecordData(this), childNodes = this.childNodes, len = childNodes.length, children, i;
    if (len > 0) {
      result.children = children = [];
      for (i = 0; i < len; i++) {
        children.push(childNodes[i].serialize(writer));
      }
    }
    return result;
  }, callTreeStore:function(funcName, args) {
    var me = this, target = me.getTreeStore(), fn = target && target[funcName];
    if (target && fn) {
      args = args || [];
      if (args[0] !== me) {
        args.unshift(me);
      }
      fn.apply(target, args);
    }
  }, addCls:function(cls) {
    this.replaceCls(null, cls);
  }, removeCls:function(cls) {
    this.replaceCls(cls);
  }, replaceCls:function(oldCls, newCls) {
    var pieces = this._parseCls(this.data.cls), parts = this._parseCls(oldCls);
    if (parts.length) {
      pieces = Ext.Array.difference(pieces, parts);
    }
    parts = this._parseCls(newCls);
    if (parts.length) {
      pieces = Ext.Array.unique(pieces.concat(parts));
    }
    this.set('cls', pieces.join(' '));
  }, toggleCls:function(cls, state) {
    if (state === undefined) {
      var pieces = this._parseCls(this.data.cls), parts = this._parseCls(cls), len = parts.length, i, p;
      for (i = 0; i < len; ++i) {
        p = parts[i];
        if (Ext.Array.contains(pieces, p)) {
          Ext.Array.remove(pieces, p);
        } else {
          pieces.push(p);
        }
      }
      this.set('cls', pieces.join(' '));
    } else {
      if (state) {
        this.addCls(cls);
      } else {
        this.removeCls(cls);
      }
    }
  }, privates:{_noCls:[], spacesRe:/\s+/, join:function(store) {
    if (store.isTreeStore) {
      if (this.isRoot()) {
        this.treeStore = this.store = store;
      }
    } else {
      this.callParent([store]);
    }
  }, callJoined:function(funcName, args) {
    this.callParent([funcName, args]);
    this.callTreeStore(funcName, args);
  }, _parseCls:function(cls) {
    if (!cls) {
      return this._noCls;
    }
    if (typeof cls === 'string') {
      return cls.split(this.spacesRe);
    }
    return cls;
  }}};
}}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'NodeInterface'], 0);
Ext.cmd.derive('Ext.mixin.Queryable', Ext.Base, {mixinId:'queryable', isQueryable:true, query:function(selector) {
  selector = selector || '*';
  return Ext.ComponentQuery.query(selector, this.getQueryRoot());
}, queryBy:function(fn, scope) {
  var out = [], items = this.getQueryRoot().getRefItems(true), i = 0, len = items.length, item;
  for (; i < len; ++i) {
    item = items[i];
    if (fn.call(scope || item, item) !== false) {
      out.push(item);
    }
  }
  return out;
}, queryById:function(id) {
  return this.down(Ext.makeIdSelector(id));
}, child:function(selector) {
  var children = this.getQueryRoot().getRefItems();
  if (selector && selector.isComponent) {
    return this.matchById(children, selector.getItemId());
  }
  if (selector) {
    children = Ext.ComponentQuery.query(selector, children);
  }
  if (children.length) {
    return children[0];
  }
  return null;
}, down:function(selector) {
  if (selector && selector.isComponent) {
    return this.matchById(this.getRefItems(true), selector.getItemId());
  }
  selector = selector || '';
  return this.query(selector)[0] || null;
}, visitPreOrder:function(selector, fn, scope, extraArgs) {
  Ext.ComponentQuery._visit(true, selector, this.getQueryRoot(), fn, scope, extraArgs);
}, visitPostOrder:function(selector, fn, scope, extraArgs) {
  Ext.ComponentQuery._visit(false, selector, this.getQueryRoot(), fn, scope, extraArgs);
}, getRefItems:function() {
  return [];
}, getQueryRoot:function() {
  return this;
}, privates:{matchById:function(items, id) {
  var len = items.length, i, item;
  for (i = 0; i < len; ++i) {
    item = items[i];
    if (item.getItemId() === id) {
      return item;
    }
  }
  return null;
}}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Queryable'], 0);
Ext.cmd.derive('Ext.data.TreeModel', Ext.data.Model, {getRefItems:function() {
  return this.childNodes;
}, getRefOwner:function() {
  return this.parentNode;
}, statics:{defaultProxy:'memory'}}, 0, 0, 0, 0, 0, [[Ext.mixin.Queryable.prototype.mixinId || Ext.mixin.Queryable.$className, Ext.mixin.Queryable]], [Ext.data, 'TreeModel'], function() {
  Ext.data.NodeInterface.decorate(this);
});
Ext.cmd.derive('Ext.data.Request', Ext.Base, {isDataRequest:true, config:{action:undefined, params:undefined, method:'GET', url:null, operation:null, proxy:null, disableCaching:false, headers:{}, callbackKey:null, rawRequest:null, jsonData:undefined, xmlData:undefined, withCredentials:false, username:null, password:null, binary:false, callback:null, scope:null, timeout:30000, records:null, directFn:null, args:null, useDefaultXhrHeader:null}, constructor:function(config) {
  this.initConfig(config);
}, getParam:function(key) {
  var params = this.getParams(), val;
  if (params) {
    return params[key];
  }
  return val;
}, setParam:function(key, value) {
  var params = this.getParams() || {};
  params[key] = value;
  this.setParams(params);
}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'Request'], 0);
Ext.cmd.derive('Ext.data.TreeStore', Ext.data.Store, {isTreeStore:true, config:{root:null, rootVisible:false, defaultRootProperty:'children', parentIdProperty:null, clearOnLoad:true, clearRemovedOnLoad:true, nodeParam:'node', defaultRootId:'root', defaultRootText:'Root', folderSort:false, pageSize:null}, filterer:'topdown', lazyFill:false, fillCount:0, bulkUpdate:0, nodesToUnregister:0, _silentOptions:{silent:true}, implicitModel:'Ext.data.TreeModel', groupField:null, groupDir:null, grouper:null, 
constructor:function(config) {
  var me = this;
  me.byIdMap = {};
  Ext.data.Store.prototype.constructor.call(this, config);
}, applyFields:function(fields, oldFields) {
  var me = this;
  if (fields) {
    if (me.defaultRootProperty !== me.self.prototype.config.defaultRootProperty) {
      fields = fields.concat({name:me.defaultRootProperty, type:'auto', defaultValue:null, persist:false});
    }
  }
  Ext.data.Store.prototype.applyFields.call(this, fields, oldFields);
}, applyGroupField:function(field) {
  return null;
}, applyGroupDir:function(dir) {
  return null;
}, applyGrouper:function(grouper) {
  return null;
}, group:Ext.emptyFn, onSorterEndUpdate:function() {
  var me = this, sorterCollection = me.getSorters(), sorters = sorterCollection.getRange(), rootNode = me.getRoot(), folderSort = me.getFolderSort();
  me.fireEvent('beforesort', me, sorters);
  if (rootNode && (folderSort || sorters.length)) {
    if (me.getRemoteSort()) {
      if (sorters.length) {
        me.load({callback:function() {
          me.fireEvent('sort', me, sorters);
        }});
      }
    } else {
      rootNode.sort(this.getSortFn(), true);
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
      me.fireEvent('sort', me, sorters);
    }
  } else {
    me.fireEvent('sort', me, sorters);
  }
}, updateFolderSort:function(folderSort) {
  this.needsFolderSort = folderSort;
  this.onSorterEndUpdate();
}, getSortFn:function() {
  return this._sortFn || (this._sortFn = this.createSortFn());
}, createSortFn:function() {
  var me = this, sortersSortFn = this.sorters.getSortFn();
  return function(node1, node2) {
    var node1FolderOrder, node2FolderOrder, result = 0;
    if (me.needsFolderSort) {
      node1FolderOrder = node1.data.leaf ? 1 : 0;
      node2FolderOrder = node2.data.leaf ? 1 : 0;
      result = node1FolderOrder - node2FolderOrder;
    }
    if (me.needsIndexSort && result === 0) {
      result = node1.data.index - node2.data.index;
    }
    return result || sortersSortFn(node1, node2);
  };
}, getTotalCount:function() {
  return this.getCount();
}, afterEdit:function(node, modifiedFieldNames) {
  var me = this, parentNode = node.parentNode, rootVisible = me.getRootVisible(), isHiddenRoot = !parentNode && !rootVisible, prevVisibleNodeIndex, isVisible = node.get('visible'), toAdd, removeStart;
  if (!isHiddenRoot && isVisible !== me.contains(node)) {
    if (isVisible) {
      if (!parentNode || me.isVisible(node)) {
        toAdd = [node];
        if (node.isExpanded()) {
          me.handleNodeExpand(node, node.childNodes, toAdd);
        }
        prevVisibleNodeIndex = node.previousSibling ? me.indexOfPreviousVisibleNode(node.previousSibling) : parentNode ? me.indexOf(parentNode) : -1;
        me.insert(prevVisibleNodeIndex + 1, toAdd);
      }
    } else {
      removeStart = me.indexOf(node);
      me.removeAt(removeStart, me.indexOfNextVisibleNode(node) - removeStart);
    }
  } else {
    if (me.getRoot() && me.needsLocalFilter()) {
      me.onFilterEndUpdate(me.getFilters());
    }
  }
  Ext.data.Store.prototype.afterEdit.call(this, node, modifiedFieldNames);
}, afterReject:function(record) {
  var me = this;
  if (me.contains(record)) {
    me.onUpdate(record, Ext.data.Model.REJECT, null);
    me.fireEvent('update', me, record, Ext.data.Model.REJECT, null);
  }
}, afterCommit:function(record, modifiedFieldNames) {
  var me = this;
  if (!modifiedFieldNames) {
    modifiedFieldNames = null;
  }
  if (me.contains(record)) {
    me.onUpdate(record, Ext.data.Model.COMMIT, modifiedFieldNames);
    me.fireEvent('update', me, record, Ext.data.Model.COMMIT, modifiedFieldNames);
  }
}, updateRootVisible:function(rootVisible) {
  var rootNode = this.getRoot(), data;
  if (rootNode) {
    data = this.getData();
    if (rootVisible) {
      data.insert(0, rootNode);
    } else {
      data.remove(rootNode);
    }
  }
}, updateTrackRemoved:function(trackRemoved) {
  Ext.data.Store.prototype.updateTrackRemoved.apply(this, arguments);
  this.removedNodes = this.removed;
  this.removed = null;
}, onDestroyRecords:function(records, operation, success) {
  if (success) {
    this.removedNodes.length = 0;
  }
}, updateProxy:function(proxy) {
  var reader;
  if (proxy) {
    if (proxy.setIdParam) {
      proxy.setIdParam(this.getNodeParam());
    }
    reader = proxy.getReader();
    if (Ext.isEmpty(reader.getRootProperty())) {
      reader.setRootProperty(this.getDefaultRootProperty());
    }
  }
}, setProxy:function(proxy) {
  this.changingProxy = true;
  (arguments.callee.$previous || Ext.data.Store.prototype.setProxy).call(this, proxy);
  this.changingProxy = false;
}, updateModel:function(model) {
  if (model) {
    var isNode = model.prototype.isNode;
    Ext.data.NodeInterface.decorate(model);
    if (!isNode && !this.changingProxy) {
      this.getProxy().getReader().buildExtractors(true);
    }
  }
}, onCollectionFilter:Ext.emptyFn, onFilterEndUpdate:function(filters) {
  var me = this, length = filters.length, root = me.getRoot(), childNodes, childNode, filteredNodes, i;
  if (!me.getRemoteFilter()) {
    if (length) {
      me.doFilter(root);
    } else {
      root.cascade({after:function(node) {
        node.set('visible', true, me._silentOptions);
      }});
    }
    if (length) {
      filteredNodes = [];
      childNodes = root.childNodes;
      for (i = 0, length = childNodes.length; i < length; i++) {
        childNode = childNodes[i];
        if (childNode.get('visible')) {
          filteredNodes.push(childNode);
        }
      }
    } else {
      filteredNodes = root.childNodes;
    }
    me.onNodeFilter(root, filteredNodes);
    root.fireEvent('filterchange', root, filteredNodes);
    me.suppressNextFilter = true;
    Ext.data.Store.prototype.onFilterEndUpdate.call(this, filters);
    me.suppressNextFilter = false;
  } else {
    Ext.data.Store.prototype.onFilterEndUpdate.call(this, filters);
  }
}, onNodeFilter:function(root, childNodes) {
  var me = this, data = me.getData(), toAdd = [];
  if (me.getRootVisible() && root.get('visible')) {
    toAdd.push(root);
  }
  me.handleNodeExpand(root, childNodes, toAdd);
  me.suspendEvents();
  data.splice(0, data.getCount(), toAdd);
  me.resumeEvents();
  if (!me.suppressNextFilter) {
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
  }
}, onBeforeNodeExpand:function(node, callback, scope, args) {
  var me = this, storeReader, nodeProxy, nodeReader, reader, children, callbackArgs;
  if (node.isLoaded()) {
    callbackArgs = [node.childNodes];
    if (args) {
      callbackArgs.push.apply(callbackArgs, args);
    }
    Ext.callback(callback, scope || node, callbackArgs);
  } else {
    if (node.isLoading()) {
      me.on('load', function() {
        callbackArgs = [node.childNodes];
        if (args) {
          callbackArgs.push.apply(callbackArgs, args);
        }
        Ext.callback(callback, scope || node, callbackArgs);
      }, me, {single:true, priority:1001});
    } else {
      storeReader = me.getProxy().getReader();
      nodeProxy = node.getProxy();
      nodeReader = nodeProxy ? nodeProxy.getReader() : null;
      reader = nodeReader && nodeReader.initialConfig.rootProperty ? nodeReader : storeReader;
      children = reader.getRoot(node.raw || node.data);
      if (children || node.phantom && !node.isRoot()) {
        if (children) {
          me.fillNode(node, reader.extractData(children, {model:node.childType, recordCreator:me.recordCreator}));
        }
        callbackArgs = [node.childNodes];
        if (args) {
          callbackArgs.push.apply(callbackArgs, args);
        }
        Ext.callback(callback, scope || node, callbackArgs);
      } else {
        me.read({node:node, onChildNodesAvailable:function() {
          delete me.lastOptions.onChildNodesAvailable;
          callbackArgs = [node.childNodes];
          if (args) {
            callbackArgs.push.apply(callbackArgs, args);
          }
          Ext.callback(callback, scope || node, callbackArgs);
        }});
        me.flushLoad();
      }
    }
  }
}, onNodeExpand:function(parent, records) {
  var me = this, insertIndex = me.indexOf(parent) + 1, toAdd = [];
  me.handleNodeExpand(parent, records, toAdd);
  if (!me.refreshCounter && parent.isRoot() && !parent.get('visible')) {
    me.loadRecords(toAdd);
  } else {
    ++me.loadCount;
    me.insert(insertIndex, toAdd);
  }
}, handleNodeExpand:function(parent, records, toAdd) {
  var me = this, ln = records ? records.length : 0, i, record;
  if (parent !== this.getRoot() && !me.isVisible(parent)) {
    return;
  }
  if (ln) {
    for (i = 0; i < ln; i++) {
      record = records[i];
      if (record.get('visible')) {
        toAdd.push(record);
        if (record.isExpanded()) {
          if (record.isLoaded()) {
            me.handleNodeExpand(record, record.childNodes, toAdd);
          } else {
            record.set('expanded', false, {silent:true});
            record.expand();
          }
        }
      }
    }
  }
}, onNodeCollapse:function(parent, records, callback, scope) {
  var me = this, collapseIndex = me.indexOf(parent) + 1, lastNodeIndexPlus;
  if (me.needsLocalFilter()) {
    records = Ext.Array.filter(records, me.filterVisible);
  }
  if (records.length && me.isVisible(parent)) {
    lastNodeIndexPlus = me.indexOfNextVisibleNode(parent);
    me.removeAt(collapseIndex, lastNodeIndexPlus - collapseIndex);
  }
  Ext.callback(callback, scope);
}, indexOfNextVisibleNode:function(node) {
  var result;
  while (node.parentNode) {
    for (result = node.nextSibling; result && !result.get('visible'); result = result.nextSibling) {
    }
    if (result) {
      return this.indexOf(result);
    }
    node = node.parentNode;
  }
  return this.getCount();
}, indexOfPreviousVisibleNode:function(node) {
  var result;
  for (result = node; result && !result.get('visible'); result = result.previousSibling) {
  }
  if (result) {
    if (result.isExpanded() && result.lastChild) {
      return this.indexOfPreviousVisibleNode(result.lastChild);
    }
  } else {
    result = node.parentNode;
  }
  return this.indexOf(result);
}, filterNew:function(item) {
  return !item.get('root') && Ext.data.Store.prototype.filterNew.call(this, item);
}, filterRejects:function(item) {
  return !item.get('root') && Ext.data.Store.prototype.filterRejects.call(this, item);
}, getNewRecords:function() {
  return Ext.Array.filter(Ext.Object.getValues(this.byIdMap), this.filterNew, this);
}, getRejectRecords:function() {
  return Ext.Array.filter(Ext.Object.getValues(this.byIdMap), this.filterRejects, this);
}, getUpdatedRecords:function() {
  return Ext.Array.filter(Ext.Object.getValues(this.byIdMap), this.filterUpdated);
}, beforeNodeRemove:function(parentNode, childNodes, isMove, removeRange) {
  if (!Ext.isArray(childNodes)) {
    childNodes = [childNodes];
  }
  var me = this, len = childNodes.length, removed = me.removedNodes, i, startNode;
  for (i = 0; !startNode && i < len; i++) {
    if (childNodes[i].get('visible')) {
      startNode = childNodes[i];
    }
  }
  if (startNode) {
    removeRange[0] = me.indexOf(childNodes[0]);
    removeRange[1] = me.indexOfNextVisibleNode(childNodes[childNodes.length - 1]) - removeRange[0];
  } else {
    removeRange[0] = -1;
    removeRange[1] = 0;
  }
  for (i = 0; i < len; i++) {
    childNodes[i].cascade(function(node) {
      me.unregisterNode(node, true);
      if (removed && !isMove) {
        if (!node.phantom && !node.erasing && !me.loading) {
          node.removedFrom = me.indexOf(node);
          removed.push(node);
          me.needsSync = true;
        }
      }
    });
  }
}, afterDrop:Ext.emptyFn, onNodeRemove:function(parentNode, childNodes, isMove, removeRange) {
  var me = this;
  me.suspendAutoSync();
  if (removeRange[0] !== -1) {
    me.removeIsMove = isMove;
    me.removeAt.apply(me, removeRange);
    me.removeIsMove = false;
  }
  me.resumeAutoSync();
}, onNodeAppend:function(parent, node, index) {
  this.onNodeInsert(parent, node, index);
}, onNodeInsert:function(parent, node, index) {
  var me = this, data = node.raw || node.data, removed = me.removedNodes, storeReader, nodeProxy, nodeReader, reader, dataRoot, storeInsertionPoint;
  if (parent && me.needsLocalFilter()) {
    me.doFilter(parent);
  }
  me.beginUpdate();
  if (me.isVisible(node)) {
    if (index === 0 || !node.previousSibling) {
      storeInsertionPoint = me.indexOf(parent);
    } else {
      storeInsertionPoint = me.indexOfPreviousVisibleNode(node.previousSibling);
    }
    me.insert(storeInsertionPoint + 1, node);
    if (!node.isLeaf() && node.isExpanded()) {
      if (node.isLoaded()) {
        me.onNodeExpand(node, node.childNodes);
      } else {
        if (!me.fillCount) {
          node.set('expanded', false);
          node.expand();
        }
      }
    }
  }
  Ext.Array.remove(removed, node);
  me.needsSync = me.needsSync || node.phantom || node.dirty;
  if (!node.isLeaf() && !node.isLoaded() && !me.lazyFill) {
    storeReader = me.getProxy().getReader();
    nodeProxy = node.getProxy();
    nodeReader = nodeProxy ? nodeProxy.getReader() : null;
    reader = nodeReader && nodeReader.initialConfig.rootProperty ? nodeReader : storeReader;
    dataRoot = reader.getRoot(data);
    if (dataRoot) {
      me.fillNode(node, reader.extractData(dataRoot, {model:node.childType, recordCreator:me.recordCreator}));
    }
  }
  me.endUpdate();
}, registerNode:function(node, includeChildren) {
  var me = this, was = me.byIdMap[node.id], children, length, i;
  me.byIdMap[node.id] = node;
  if (node.onRegisterTreeNode && node !== was) {
    node.onRegisterTreeNode(me);
  }
  if (node.onUnregisterTreeNode) {
    me.nodesToUnregister++;
  }
  if (includeChildren === true) {
    children = node.childNodes;
    length = children.length;
    for (i = 0; i < length; i++) {
      me.registerNode(children[i], true);
    }
  }
}, unregisterNode:function(node, includeChildren) {
  var me = this, was = me.byIdMap[node.id], children, length, i;
  delete me.byIdMap[node.id];
  if (includeChildren === true) {
    children = node.childNodes;
    length = children.length;
    for (i = 0; i < length; i++) {
      me.unregisterNode(children[i], true);
    }
  }
  if (node.onUnregisterTreeNode && node === was) {
    node.onUnregisterTreeNode(me);
    me.nodesToUnregister--;
  }
}, onNodeSort:function(node, childNodes) {
  var me = this;
  me.suspendAutoSync();
  if (me.indexOf(node) !== -1 && node.isExpanded() || node === me.getRoot() && !me.getRootVisible()) {
    Ext.suspendLayouts();
    me.onNodeCollapse(node, childNodes);
    me.onNodeExpand(node, childNodes);
    Ext.resumeLayouts(true);
  }
  me.resumeAutoSync(me.autoSync);
}, applyRoot:function(newRoot) {
  var me = this, Model = me.getModel(), idProperty = Model.prototype.idProperty, defaultRootId = me.getDefaultRootId();
  if (newRoot && !newRoot.isNode) {
    newRoot = Ext.apply({text:me.getDefaultRootText(), root:true, isFirst:true, isLast:true, depth:0, index:0, parentId:null, allowDrag:false}, newRoot);
    if (defaultRootId && newRoot[idProperty] === undefined) {
      newRoot[idProperty] = defaultRootId;
    }
    newRoot = new Model(newRoot);
  }
  return newRoot;
}, updateRoot:function(newRoot, oldRoot) {
  var me = this, oldOwner, initial = !oldRoot, toRemove, removeRange = [];
  me.getTrackRemoved();
  me.suspendEvent('add', 'remove');
  if (initial) {
    me.suspendEvent('refresh', 'datachanged');
  }
  if (oldRoot && oldRoot.isModel) {
    if (me.getRootVisible()) {
      toRemove = [oldRoot];
    } else {
      toRemove = oldRoot.childNodes;
    }
    me.beforeNodeRemove(null, toRemove, false, removeRange);
    oldRoot.set('root', false);
    me.onNodeRemove(null, toRemove, false, removeRange);
    oldRoot.fireEvent('remove', null, oldRoot, false);
    oldRoot.fireEvent('rootchange', null);
    oldRoot.clearListeners();
    oldRoot.store = oldRoot.treeStore = null;
    me.unregisterNode(oldRoot);
  }
  me.getData().clear();
  if (newRoot) {
    if (newRoot.fireEventArgs('beforeappend', [null, newRoot]) === false) {
      newRoot = null;
    } else {
      oldOwner = newRoot.parentNode;
      if (oldOwner) {
        if (!oldOwner.removeChild(newRoot, false, false, oldOwner.getTreeStore() === me)) {
          return;
        }
      } else {
        if ((oldOwner = newRoot.getTreeStore()) && oldOwner !== me && newRoot === oldOwner.getRoot()) {
          oldOwner.setRoot(null);
        }
      }
      newRoot.store = newRoot.treeStore = me;
      newRoot.set('root', true);
      newRoot.updateInfo(true, {isFirst:true, isLast:true, depth:0, index:0, parentId:null});
      me.registerNode(newRoot, true);
      newRoot.fireEvent('append', null, newRoot, false);
      newRoot.fireEvent('rootchange', newRoot);
      me.onNodeAppend(null, newRoot, 0);
      newRoot.phantom = true;
    }
  }
  if (!initial) {
    me.fireEvent('rootchange', newRoot, oldRoot);
  }
  if (newRoot && (me.getAutoLoad() || newRoot.isExpanded())) {
    if (newRoot.isLoaded()) {
      me.onNodeExpand(newRoot, newRoot.childNodes);
      if (!initial) {
        me.fireEvent('datachanged', me);
        me.fireEvent('refresh', me);
      }
    } else {
      newRoot.data.expanded = false;
      newRoot.expand(false);
      if (newRoot.isLoaded && !me.getProxy().isSynchronous && !initial) {
        me.fireEvent('datachanged', me);
        me.fireEvent('refresh', me);
      }
    }
  } else {
    if (!initial) {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
    }
  }
  me.resumeEvent('add', 'remove');
  if (initial) {
    me.resumeEvent('refresh', 'datachanged');
  }
}, doDestroy:function() {
  var me = this, root = me.getRoot();
  if (root && me.nodesToUnregister) {
    root.cascade(function(node) {
      if (node.onUnregisterTreeNode) {
        node.onUnregisterTreeNode(me);
      }
    });
  }
  Ext.data.Store.prototype.doDestroy.call(this);
}, each:function(fn, scope, includeOptions) {
  var i = 0, filtered = includeOptions, includeCollapsed;
  if (includeOptions && typeof includeOptions === 'object') {
    includeCollapsed = includeOptions.collapsed;
    filtered = includeOptions.filtered;
  }
  if (includeCollapsed) {
    this.getRoot().cascade(function(node) {
      if (filtered === true || node.get('visible')) {
        return fn.call(scope || node, node, i++);
      }
    });
  } else {
    return Ext.data.Store.prototype.each.call(this, fn, scope, filtered);
  }
}, collect:function(dataIndex, options, filtered) {
  var includeCollapsed, map = {}, result = [], allowNull = options, strValue, value;
  if (options && typeof options === 'object') {
    includeCollapsed = options.collapsed;
    filtered = options.filtered;
    allowNull = options.allowNull;
  }
  if (includeCollapsed || filtered) {
    this.getRoot().cascade(function(node) {
      if (filtered === true || node.get('visible')) {
        value = node.get(dataIndex);
        strValue = String(value);
        if ((allowNull || !Ext.isEmpty(value)) && !map[strValue]) {
          map[strValue] = 1;
          result.push(value);
        }
      }
      if (!includeCollapsed && !node.isExpanded()) {
        return false;
      }
    });
  } else {
    result = Ext.data.Store.prototype.collect.call(this, dataIndex, allowNull, filtered);
  }
  return result;
}, getNodeById:function(id) {
  return this.byIdMap[id] || null;
}, findNode:function(fieldName, value, startsWith, endsWith, ignoreCase) {
  if (Ext.isEmpty(value, false)) {
    return null;
  }
  if (fieldName === this.model.idProperty && arguments.length < 3) {
    return this.byIdMap[value];
  }
  var regex = Ext.String.createRegex(value, startsWith, endsWith, ignoreCase), result = null;
  Ext.Object.eachValue(this.byIdMap, function(node) {
    if (node && regex.test(node.get(fieldName))) {
      result = node;
      return false;
    }
  });
  return result;
}, load:function(options) {
  var node = options && options.node;
  if (!node && !(node = this.getRoot())) {
    node = this.setRoot({expanded:true, autoRoot:true});
    return;
  }
  if (node.isLoading()) {
    return;
  }
  return Ext.data.Store.prototype.load.call(this, options);
}, reload:function(options) {
  var o = Ext.apply({}, options, this.lastOptions);
  o.node = this.getRoot();
  return this.load(o);
}, flushLoad:function() {
  var me = this, options = me.pendingLoadOptions, node, callback, scope, clearOnLoad = me.getClearOnLoad(), isRootLoad, operation, doClear;
  me.clearLoadTask();
  if (!options) {
    return;
  }
  node = options.node || me.getRoot();
  isRootLoad = node && node.isRoot();
  callback = options.callback;
  scope = options.scope;
  options.params = options.params || {};
  if (node.data.expanded && !isRootLoad) {
    node.data.loaded = false;
    if (clearOnLoad) {
      node.data.expanded = false;
    }
    options.callback = function(loadedNodes, operation, success) {
      if (!clearOnLoad) {
        node.collapse();
      }
      node.expand();
      Ext.callback(callback, scope, [loadedNodes, operation, success]);
    };
  }
  options.id = node.getId();
  me.setLoadOptions(options);
  if (me.getRemoteSort() && options.sorters) {
    me.fireEvent('beforesort', me, options.sorters);
  }
  options = Ext.apply({node:options.node || node, internalScope:me, internalCallback:me.onProxyLoad}, options);
  me.lastOptions = Ext.apply({}, options);
  options.isRootLoad = isRootLoad;
  operation = me.createOperation('read', options);
  if (me.fireEvent('beforeload', me, operation) !== false) {
    me.loading = true;
    if (isRootLoad) {
      if (me.getClearRemovedOnLoad()) {
        me.removedNodes.length = 0;
      }
      if (clearOnLoad) {
        me.unregisterNode(node, true);
        node.clear(false, true);
        me.registerNode(node);
        doClear = true;
      }
    } else {
      if (me.loading) {
        node.data.loaded = false;
      }
      if (me.getTrackRemoved() && me.getClearRemovedOnLoad()) {
        me.clearRemoved(node);
      }
      if (clearOnLoad) {
        node.removeAll(false);
      }
    }
    if (me.loading && node) {
      node.set('loading', true, {silent:!(me.contains(node) || node === me.getRoot())});
    }
    if (doClear) {
      me.clearData(true);
      if (me.getRootVisible()) {
        me.suspendEvents();
        me.add(node);
        me.resumeEvents();
      }
    }
    operation.execute();
  }
  return me;
}, onProxyLoad:function(operation) {
  var me = this, options = operation.initialConfig, successful = operation.wasSuccessful(), records = operation.getRecords(), node = options.node, isRootLoad = options.isRootLoad, scope = operation.getScope() || me, args = [records, operation, successful];
  if (me.destroyed) {
    return;
  }
  me.loading = false;
  node.set('loading', false);
  if (successful) {
    ++me.loadCount;
    if (!me.getClearOnLoad()) {
      records = me.cleanRecords(node, records);
    }
    if (me.getParentIdProperty()) {
      records = me.treeify(node, records);
    }
    if (isRootLoad) {
      me.suspendEvent('add', 'update');
    }
    records = me.fillNode(node, records);
  }
  Ext.callback(options.onChildNodesAvailable, scope, args);
  if (isRootLoad) {
    me.resumeEvent('add', 'update');
    me.callObservers('BeforePopulate');
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
    me.callObservers('AfterPopulate');
  }
  me.fireEvent('load', me, records, successful, operation, node);
}, clearRemoved:function(node) {
  var me = this, removed = me.removedNodes, id = node.getId(), removedLength = removed.length, i = removedLength, recordsToClear = {}, newRemoved = [], removedHash = {}, removedNode, targetNode, targetId;
  if (node === me.getRoot()) {
    me.removedNodes.length = 0;
    return;
  }
  for (; i--;) {
    removedNode = removed[i];
    removedHash[removedNode.getId()] = removedNode;
  }
  for (i = removedLength; i--;) {
    removedNode = removed[i];
    targetNode = removedNode;
    while (targetNode && targetNode.getId() !== id) {
      targetId = targetNode.get('parentId') || targetNode.get('lastParentId');
      targetNode = targetNode.parentNode || me.getNodeById(targetId) || removedHash[targetId];
    }
    if (targetNode) {
      recordsToClear[removedNode.getId()] = removedNode;
    }
  }
  for (i = 0; i < removedLength; i++) {
    removedNode = removed[i];
    if (!recordsToClear[removedNode.getId()]) {
      newRemoved.push(removedNode);
    }
  }
  me.removedNodes = newRemoved;
}, fillNode:function(node, newNodes) {
  var me = this, newNodeCount = newNodes ? newNodes.length : 0;
  if (++me.bulkUpdate === 1) {
    me.suspendEvent('datachanged');
  }
  if (newNodeCount) {
    me.setupNodes(newNodes);
    node.appendChild(newNodes, undefined, true);
  } else {
    if (me.bulkUpdate === 1) {
      node.set('loaded', true);
    } else {
      node.data.loaded = true;
    }
  }
  if (!--me.bulkUpdate) {
    me.resumeEvent('datachanged');
  }
  return newNodes;
}, setupNodes:function(newNodes) {
  var me = this, sorters = me.getSorters(), needsIndexSort = false, newNodeCount = newNodes.length, performLocalSort = me.sortOnLoad && newNodeCount > 1 && !me.getRemoteSort() && me.getFolderSort() || sorters.length, performLocalFilter = me.needsLocalFilter(), node1, node2, i;
  if (performLocalFilter) {
    me.doFilter(newNodes[0]);
  }
  for (i = 1; i < newNodeCount; i++) {
    node1 = newNodes[i];
    node2 = newNodes[i - 1];
    if (performLocalFilter) {
      me.doFilter(node1);
    }
    needsIndexSort = node1.data.index !== node2.data.index;
  }
  if (performLocalSort) {
    me.needsIndexSort = true;
    Ext.Array.sort(newNodes, me.getSortFn());
    me.needsIndexSort = false;
  } else {
    if (needsIndexSort) {
      Ext.Array.sort(newNodes, me.sortByIndex);
    }
  }
}, beginFill:function() {
  var me = this;
  if (!me.fillCount++) {
    me.beginUpdate();
    me.suspendEvent('add', 'update');
    me.suspendAutoSync();
    me.fillArray = [];
  }
}, endFill:function(parent, nodes) {
  var me = this, fillArray = me.fillArray, i, len, index;
  fillArray.push(nodes);
  if (!--me.fillCount) {
    me.resumeAutoSync();
    me.resumeEvent('add', 'update');
    for (i = 0, len = fillArray.length; i < len; i++) {
      index = me.indexOf(fillArray[i][0]);
      if (index !== -1) {
        me.fireEvent('add', me, fillArray[i], index);
      }
    }
    me.fillArray = null;
    me.endUpdate();
  }
}, sortByIndex:function(node1, node2) {
  return node1.data.index - node2.data.index;
}, onIdChanged:function(node, oldId, newId) {
  var childNodes = node.childNodes, len = childNodes && childNodes.length, i;
  Ext.data.Store.prototype.onIdChanged.apply(this, arguments);
  delete this.byIdMap[oldId];
  this.byIdMap[newId] = node;
  for (i = 0; i < len; i++) {
    childNodes[i].set('parentId', newId);
  }
}, treeify:function(parentNode, records) {
  var me = this, loadParentNodeId = parentNode.getId(), parentIdProperty = me.getParentIdProperty(), len = records.length, result = [], nodeMap = {}, i, node, parentId, parent, id, children;
  for (i = 0; i < len; i++) {
    node = records[i];
    node.data.depth = 1;
    nodeMap[node.id] = node;
  }
  for (i = 0; i < len; i++) {
    node = records[i];
    parentId = node.data[parentIdProperty];
    if (!(parentId || parentId === 0) || parentId === loadParentNodeId) {
      result.push(node);
    } else {
      parent = nodeMap[parentId];
      parent.$children = parent.$children || [];
      parent.$children.push(node);
      node.data.depth = parent.data.depth + 1;
    }
  }
  for (id in nodeMap) {
    node = nodeMap[id];
    children = node.$children;
    if (children) {
      delete node.$children;
      me.setupNodes(children);
      node.appendChild(children);
    }
    me.registerNode(node);
  }
  me.setupNodes(result);
  return result;
}, cleanRecords:function(node, records) {
  var nodeHash = {}, childNodes = node.childNodes, i = 0, len = childNodes.length, out = [], rec;
  for (; i < len; ++i) {
    nodeHash[childNodes[i].getId()] = true;
  }
  for (i = 0, len = records.length; i < len; ++i) {
    rec = records[i];
    if (!nodeHash[rec.getId()]) {
      out.push(rec);
    }
  }
  return out;
}, removeAll:function() {
  this.suspendEvents();
  this.setRoot(null);
  this.resumeEvents();
  Ext.data.Store.prototype.removeAll.call(this);
}, doSort:function(sorterFn) {
  var me = this;
  if (me.getRemoteSort()) {
    me.load();
  } else {
    me.tree.sort(sorterFn, true);
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
  }
  me.fireEvent('sort', me, me.sorters.getRange());
}, filterVisible:function(node) {
  return node.get('visible');
}, isVisible:function(node) {
  var parentNode = node.parentNode, visible = node.data.visible, root = this.getRoot();
  while (visible && parentNode) {
    visible = parentNode.data.expanded && parentNode.data.visible;
    parentNode = parentNode.parentNode;
  }
  return visible && !(node === root && !this.getRootVisible());
}, commitChanges:function() {
  var removed = this.removedNodes;
  if (removed) {
    removed.length = 0;
  }
  Ext.data.Store.prototype.commitChanges.call(this);
}, getRootNode:function() {
  return this.getRoot();
}, setRootNode:function(root) {
  this.setRoot(root);
  return this.getRoot();
}, privates:{fireChangeEvent:function(record) {
  return !!this.byIdMap[record.id];
}, getRawRemovedRecords:function() {
  return this.removedNodes;
}, createOperation:function(type, options) {
  var me = this, node = options.node, proxy;
  if (me.useModelProxy && node && node !== me.getRootNode()) {
    proxy = node.getProxy();
  }
  if (proxy && proxy !== me.getProxy()) {
    return proxy.createOperation(type, options);
  } else {
    return Ext.data.Store.prototype.createOperation.call(this, type, options);
  }
}, recordCreator:function(data, Model) {
  return new Model(data);
}, doFilter:function(node) {
  this.filterNodes(node, this.getFilters().getFilterFn(), true);
}, filterNodes:function(node, filterFn, parentVisible) {
  var me = this, bottomUpFiltering = me.filterer === 'bottomup', match = filterFn(node) && parentVisible || node.isRoot() && !me.getRootVisible(), childNodes = node.childNodes, len = childNodes && childNodes.length, i, matchingChildren;
  if (len) {
    for (i = 0; i < len; ++i) {
      matchingChildren = me.filterNodes(childNodes[i], filterFn, match || bottomUpFiltering) || matchingChildren;
    }
    if (bottomUpFiltering) {
      match = matchingChildren || match;
    }
  }
  node.set('visible', match, me._silentOptions);
  return match;
}, needsLocalFilter:function() {
  return !this.getRemoteFilter() && this.getFilters().length;
}, onRemoteFilterSet:function(filters, remoteFilter) {
  var data = this.getData();
  data.setFilters(null);
  if (filters) {
    filters.on('endupdate', this.onFilterEndUpdate, this);
  }
}, onRemoteSortSet:function(sorters, remoteSort) {
  var data = this.getData();
  data.setSorters(null);
  if (sorters) {
    sorters.on('endupdate', this.onSorterEndUpdate, this);
  }
}}, deprecated:{5:{properties:{tree:null}}}}, 1, 0, 0, 0, ['store.tree'], 0, [Ext.data, 'TreeStore'], 0);
Ext.cmd.derive('Ext.data.Types', Ext.Base, {singleton:true}, 0, 0, 0, 0, 0, 0, [Ext.data, 'Types'], function(Types) {
  var SortTypes = Ext.data.SortTypes;
  Ext.apply(Types, {stripRe:/[\$,%]/g, AUTO:{sortType:SortTypes.none, type:'auto'}, STRING:{convert:function(v) {
    var defaultValue = this.getAllowNull() ? null : '';
    return v === undefined || v === null ? defaultValue : String(v);
  }, sortType:SortTypes.asUCString, type:'string'}, INT:{convert:function(v) {
    if (typeof v === 'number') {
      return parseInt(v, 10);
    }
    return v !== undefined && v !== null && v !== '' ? parseInt(String(v).replace(Types.stripRe, ''), 10) : this.getAllowNull() ? null : 0;
  }, sortType:SortTypes.none, type:'int'}, FLOAT:{convert:function(v) {
    if (typeof v === 'number') {
      return v;
    }
    return v !== undefined && v !== null && v !== '' ? parseFloat(String(v).replace(Types.stripRe, ''), 10) : this.getAllowNull() ? null : 0;
  }, sortType:SortTypes.none, type:'float'}, BOOL:{convert:function(v) {
    if (typeof v === 'boolean') {
      return v;
    }
    if (this.getAllowNull() && (v === undefined || v === null || v === '')) {
      return null;
    }
    return v === 'true' || v == 1;
  }, sortType:SortTypes.none, type:'bool'}, DATE:{convert:function(v) {
    var df = this.getDateReadFormat() || this.getDateFormat(), parsed;
    if (!v) {
      return null;
    }
    if (v instanceof Date) {
      return v;
    }
    if (df) {
      return Ext.Date.parse(v, df);
    }
    parsed = Date.parse(v);
    return parsed ? new Date(parsed) : null;
  }, sortType:SortTypes.asDate, type:'date'}});
  Types.BOOLEAN = Types.BOOL;
  Types.INTEGER = Types.INT;
  Types.NUMBER = Types.FLOAT;
});
Ext.cmd.derive('Ext.data.Validation', Ext.data.Model, {isValidation:true, syncGeneration:0, attach:function(record) {
  this.record = record;
  this.isBase = record.self === Ext.data.Model;
  delete this.data.id;
}, getValidation:function() {
  return null;
}, isValid:function() {
  var me = this;
  if (me.syncGeneration !== me.record.generation) {
    me.refresh();
  }
  return !me.dirty;
}, refresh:function(force) {
  if (this.isBase) {
    return;
  }
  var me = this, data = me.data, record = me.record, fields = record.fields, generation = record.generation, recordData = record.data, sep = record.validationSeparator, values = null, defaultMessage, currentValue, error, field, item, i, j, jLen, len, msg, val, name;
  if (force || me.syncGeneration !== generation) {
    me.syncGeneration = generation;
    for (i = 0, len = fields.length; i < len; ++i) {
      field = fields[i];
      name = field.name;
      val = recordData[name];
      defaultMessage = field.defaultInvalidMessage;
      error = 0;
      if (!(name in data)) {
        data[name] = currentValue = true;
      } else {
        currentValue = data[name];
      }
      if (field.validate !== Ext.emptyFn) {
        msg = field.validate(val, sep, null, record);
        if (msg !== true) {
          error = msg || defaultMessage;
        }
      }
      if (!error) {
        error = true;
      }
      if (error !== currentValue) {
        (values || (values = {}))[name] = error;
      }
    }
    if (values) {
      me.set(values);
    }
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'Validation'], 0);
Ext.cmd.derive('Ext.dom.Helper', Ext.Base, function() {
  var afterbegin = 'afterbegin', afterend = 'afterend', beforebegin = 'beforebegin', beforeend = 'beforeend', bbValues = ['BeforeBegin', 'previousSibling'], aeValues = ['AfterEnd', 'nextSibling'], bb_ae_PositionHash = {beforebegin:bbValues, afterend:aeValues}, fullPositionHash = {beforebegin:bbValues, afterend:aeValues, afterbegin:['AfterBegin', 'firstChild'], beforeend:['BeforeEnd', 'lastChild']};
  return {singleton:true, alternateClassName:['Ext.DomHelper', 'Ext.core.DomHelper'], emptyTags:/^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i, confRe:/^(?:tag|children|cn|html|tpl|tplData)$/i, endRe:/end/i, attributeTransform:{cls:'class', htmlFor:'for'}, closeTags:{}, detachedDiv:document.createElement('div'), decamelizeName:function() {
    var camelCaseRe = /([a-z])([A-Z])/g, cache = {};
    function decamel(match, p1, p2) {
      return p1 + '-' + p2.toLowerCase();
    }
    return function(s) {
      return cache[s] || (cache[s] = s.replace(camelCaseRe, decamel));
    };
  }(), generateMarkup:function(spec, buffer) {
    var me = this, specType = typeof spec, attr, val, tag, i, closeTags;
    if (specType === 'string' || specType === 'number') {
      buffer.push(spec);
    } else {
      if (Ext.isArray(spec)) {
        for (i = 0; i < spec.length; i++) {
          if (spec[i]) {
            me.generateMarkup(spec[i], buffer);
          }
        }
      } else {
        tag = spec.tag || 'div';
        buffer.push('\x3c', tag);
        for (attr in spec) {
          if (spec.hasOwnProperty(attr)) {
            val = spec[attr];
            if (val !== undefined && !me.confRe.test(attr)) {
              if (val && val.join) {
                val = val.join(' ');
              }
              if (typeof val === 'object') {
                buffer.push(' ', attr, '\x3d"');
                me.generateStyles(val, buffer, true).push('"');
              } else {
                buffer.push(' ', me.attributeTransform[attr] || attr, '\x3d"', val, '"');
              }
            }
          }
        }
        if (me.emptyTags.test(tag)) {
          buffer.push('/\x3e');
        } else {
          buffer.push('\x3e');
          if (val = spec.tpl) {
            val.applyOut(spec.tplData, buffer);
          }
          if (val = spec.html) {
            buffer.push(val);
          }
          if (val = spec.cn || spec.children) {
            me.generateMarkup(val, buffer);
          }
          closeTags = me.closeTags;
          buffer.push(closeTags[tag] || (closeTags[tag] = '\x3c/' + tag + '\x3e'));
        }
      }
    }
    return buffer;
  }, generateStyles:function(styles, buffer, encode) {
    var a = buffer || [], name, val;
    for (name in styles) {
      if (styles.hasOwnProperty(name)) {
        val = styles[name];
        name = this.decamelizeName(name);
        if (encode && Ext.String.hasHtmlCharacters(val)) {
          val = Ext.String.htmlEncode(val);
        }
        a.push(name, ':', val, ';');
      }
    }
    return buffer || a.join('');
  }, markup:function(spec) {
    if (typeof spec === 'string') {
      return spec;
    }
    var buf = this.generateMarkup(spec, []);
    return buf.join('');
  }, applyStyles:function(el, styles) {
    Ext.fly(el).applyStyles(styles);
  }, createContextualFragment:function(html) {
    var div = this.detachedDiv, fragment = document.createDocumentFragment(), length, childNodes;
    div.innerHTML = html;
    childNodes = div.childNodes;
    length = childNodes.length;
    while (length--) {
      fragment.appendChild(childNodes[0]);
    }
    return fragment;
  }, createDom:function(o, parentNode) {
    var me = this, markup = me.markup(o), div = me.detachedDiv, child;
    div.innerHTML = markup;
    child = div.firstChild;
    return Ext.supports.ChildContentClearedWhenSettingInnerHTML ? child.cloneNode(true) : child;
  }, insertHtml:function(where, el, html) {
    var me = this, hashVal, range, rangeEl, setStart, frag;
    where = where.toLowerCase();
    if (el.insertAdjacentHTML) {
      if (me.ieInsertHtml) {
        frag = me.ieInsertHtml(where, el, html);
        if (frag) {
          return frag;
        }
      }
      hashVal = fullPositionHash[where];
      if (hashVal) {
        el.insertAdjacentHTML(hashVal[0], html);
        return el[hashVal[1]];
      }
    } else {
      if (el.nodeType === 3) {
        where = where === afterbegin ? beforebegin : where;
        where = where === beforeend ? afterend : where;
      }
      range = Ext.supports.CreateContextualFragment ? el.ownerDocument.createRange() : undefined;
      setStart = 'setStart' + (this.endRe.test(where) ? 'After' : 'Before');
      if (bb_ae_PositionHash[where]) {
        if (range) {
          range[setStart](el);
          frag = range.createContextualFragment(html);
        } else {
          frag = this.createContextualFragment(html);
        }
        el.parentNode.insertBefore(frag, where === beforebegin ? el : el.nextSibling);
        return el[(where === beforebegin ? 'previous' : 'next') + 'Sibling'];
      } else {
        rangeEl = (where === afterbegin ? 'first' : 'last') + 'Child';
        if (el.firstChild) {
          if (range) {
            try {
              range[setStart](el[rangeEl]);
              frag = range.createContextualFragment(html);
            } catch (e$30) {
              frag = this.createContextualFragment(html);
            }
          } else {
            frag = this.createContextualFragment(html);
          }
          if (where === afterbegin) {
            el.insertBefore(frag, el.firstChild);
          } else {
            el.appendChild(frag);
          }
        } else {
          el.innerHTML = html;
        }
        return el[rangeEl];
      }
    }
  }, insertBefore:function(el, o, returnElement) {
    return this.doInsert(el, o, returnElement, beforebegin);
  }, insertAfter:function(el, o, returnElement) {
    return this.doInsert(el, o, returnElement, afterend);
  }, insertFirst:function(el, o, returnElement) {
    return this.doInsert(el, o, returnElement, afterbegin);
  }, append:function(el, o, returnElement) {
    return this.doInsert(el, o, returnElement, beforeend);
  }, overwrite:function(el, html, returnElement) {
    var me = this, newNode;
    el = Ext.getDom(el);
    html = me.markup(html);
    if (me.ieOverwrite) {
      newNode = me.ieOverwrite(el, html);
    }
    if (!newNode) {
      el.innerHTML = html;
      newNode = el.firstChild;
    }
    return returnElement ? Ext.get(newNode) : newNode;
  }, doInsert:function(el, o, returnElement, where) {
    var me = this, newNode;
    el = el.dom || Ext.getDom(el);
    if ('innerHTML' in el) {
      newNode = me.insertHtml(where, el, me.markup(o));
    } else {
      newNode = me.createDom(o, null);
      if (el.nodeType === 3) {
        where = where === afterbegin ? beforebegin : where;
        where = where === beforeend ? afterend : where;
      }
      if (bb_ae_PositionHash[where]) {
        el.parentNode.insertBefore(newNode, where === beforebegin ? el : el.nextSibling);
      } else {
        if (el.firstChild && where === afterbegin) {
          el.insertBefore(newNode, el.firstChild);
        } else {
          el.appendChild(newNode);
        }
      }
    }
    return returnElement ? Ext.get(newNode) : newNode;
  }, createTemplate:function(o) {
    var html = this.markup(o);
    return new Ext.Template(html);
  }, createHtml:function(spec) {
    return this.markup(spec);
  }};
}, 0, 0, 0, 0, 0, 0, [Ext.dom, 'Helper', Ext, 'DomHelper', Ext.core, 'DomHelper'], 0);
Ext.define('Ext.overrides.dom.Helper', function() {
  var tableRe = /^(?:table|thead|tbody|tr|td)$/i, tableElRe = /td|tr|tbody|thead/i, ts = '\x3ctable\x3e', te = '\x3c/table\x3e', tbs = ts + '\x3ctbody\x3e', tbe = '\x3c/tbody\x3e' + te, trs = tbs + '\x3ctr\x3e', tre = '\x3c/tr\x3e' + tbe;
  return {override:'Ext.dom.Helper', ieInsertHtml:function(where, el, html) {
    var frag = null;
    if (Ext.isIE9m && tableRe.test(el.tagName)) {
      frag = this.insertIntoTable(el.tagName.toLowerCase(), where, el, html);
    }
    return frag;
  }, ieOverwrite:function(el, html) {
    if (Ext.isIE9m && tableRe.test(el.tagName)) {
      while (el.firstChild) {
        el.removeChild(el.firstChild);
      }
      if (html) {
        return this.insertHtml('afterbegin', el, html);
      }
    }
  }, ieTable:function(depth, openingTags, htmlContent, closingTags) {
    var i = -1, el = this.detachedDiv, ns, nx;
    el.innerHTML = [openingTags, htmlContent, closingTags].join('');
    while (++i < depth) {
      el = el.firstChild;
    }
    ns = el.nextSibling;
    if (ns) {
      ns = el;
      el = document.createDocumentFragment();
      while (ns) {
        nx = ns.nextSibling;
        el.appendChild(ns);
        ns = nx;
      }
    }
    return el;
  }, insertIntoTable:function(tag, where, destinationEl, html) {
    var node, before, bb = where === 'beforebegin', ab = where === 'afterbegin', be = where === 'beforeend', ae = where === 'afterend';
    if (tag === 'td' && (ab || be) || !tableElRe.test(tag) && (bb || ae)) {
      return null;
    }
    before = bb ? destinationEl : ae ? destinationEl.nextSibling : ab ? destinationEl.firstChild : null;
    if (bb || ae) {
      destinationEl = destinationEl.parentNode;
    }
    if (tag === 'td' || tag === 'tr' && (be || ab)) {
      node = this.ieTable(4, trs, html, tre);
    } else {
      if ((tag === 'tbody' || tag === 'thead') && (be || ab) || tag === 'tr' && (bb || ae)) {
        node = this.ieTable(3, tbs, html, tbe);
      } else {
        node = this.ieTable(2, ts, html, te);
      }
    }
    destinationEl.insertBefore(node, before);
    return node;
  }};
}());
Ext.cmd.derive('Ext.dom.Query', Ext.Base, function() {
  var DQ, doc = document, cache, simpleCache, valueCache, useClassList = !!doc.documentElement.classList, useElementPointer = !!doc.documentElement.firstElementChild, useChildrenCollection = function() {
    var d = doc.createElement('div');
    d.innerHTML = '\x3c!-- --\x3etext\x3c!-- --\x3e';
    return d.children && d.children.length === 0;
  }(), nonSpace = /\S/, trimRe = /^\s+|\s+$/g, tplRe = /\{(\d+)\}/g, modeRe = /^(\s?[\/>+~]\s?|\s|$)/, tagTokenRe = /^(#)?([\w\-\*\|\\]+)/, nthRe = /(\d*)n\+?(\d*)/, nthRe2 = /\D/, startIdRe = /^\s*#/, isIE = window.ActiveXObject ? true : false, key = 30803, longHex = /\\([0-9a-fA-F]{6})/g, shortHex = /\\([0-9a-fA-F]{1,6})\s{0,1}/g, nonHex = /\\([^0-9a-fA-F]{1})/g, escapes = /\\/g, num, hasEscapes, supportsColonNsSeparator = function() {
    var xmlDoc, xmlString = '\x3cr\x3e\x3ca:b xmlns:a\x3d"n"\x3e\x3c/a:b\x3e\x3c/r\x3e';
    if (window.DOMParser) {
      xmlDoc = (new DOMParser).parseFromString(xmlString, 'application/xml');
    } else {
      xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
      xmlDoc.loadXML(xmlString);
    }
    return !!xmlDoc.getElementsByTagName('a:b').length;
  }(), longHexToChar = function($0, $1) {
    return String.fromCharCode(parseInt($1, 16));
  }, shortToLongHex = function($0, $1) {
    while ($1.length < 6) {
      $1 = '0' + $1;
    }
    return '\\' + $1;
  }, charToLongHex = function($0, $1) {
    num = $1.charCodeAt(0).toString(16);
    if (num.length === 1) {
      num = '0' + num;
    }
    return '\\0000' + num;
  }, unescapeCssSelector = function(selector) {
    return hasEscapes ? selector.replace(longHex, longHexToChar) : selector;
  }, setupEscapes = function(path) {
    hasEscapes = path.indexOf('\\') > -1;
    if (hasEscapes) {
      path = path.replace(shortHex, shortToLongHex).replace(nonHex, charToLongHex).replace(escapes, '\\\\');
    }
    return path;
  };
  eval('var batch \x3d 30803, child, next, prev, byClassName;');
  child = useChildrenCollection ? function child(parent, index) {
    return parent.children[index];
  } : function child(parent, index) {
    var i = 0, n = parent.firstChild;
    while (n) {
      if (n.nodeType == 1) {
        if (++i == index) {
          return n;
        }
      }
      n = n.nextSibling;
    }
    return null;
  };
  next = useElementPointer ? function(n) {
    return n.nextElementSibling;
  } : function(n) {
    while ((n = n.nextSibling) && n.nodeType != 1) {
    }
    return n;
  };
  prev = useElementPointer ? function(n) {
    return n.previousElementSibling;
  } : function(n) {
    while ((n = n.previousSibling) && n.nodeType != 1) {
    }
    return n;
  };
  function children(parent) {
    var n = parent.firstChild, nodeIndex = -1, nextNode;
    while (n) {
      nextNode = n.nextSibling;
      if (n.nodeType == 3 && !nonSpace.test(n.nodeValue)) {
        parent.removeChild(n);
      } else {
        n.nodeIndex = ++nodeIndex;
      }
      n = nextNode;
    }
    return this;
  }
  byClassName = useClassList ? function(nodeSet, cls) {
    cls = unescapeCssSelector(cls);
    if (!cls) {
      return nodeSet;
    }
    var result = [], ri = -1, i, ci, classList;
    for (i = 0; ci = nodeSet[i]; i++) {
      classList = ci.classList;
      if (classList) {
        if (classList.contains(cls)) {
          result[++ri] = ci;
        }
      } else {
        if ((' ' + ci.className + ' ').indexOf(cls) !== -1) {
          result[++ri] = ci;
        }
      }
    }
    return result;
  } : function(nodeSet, cls) {
    cls = unescapeCssSelector(cls);
    if (!cls) {
      return nodeSet;
    }
    var result = [], ri = -1, i, ci;
    for (i = 0; ci = nodeSet[i]; i++) {
      if ((' ' + ci.className + ' ').indexOf(cls) !== -1) {
        result[++ri] = ci;
      }
    }
    return result;
  };
  function attrValue(n, attr) {
    if (!n.tagName && typeof n.length != 'undefined') {
      n = n[0];
    }
    if (!n) {
      return null;
    }
    if (attr == 'for') {
      return n.htmlFor;
    }
    if (attr == 'class' || attr == 'className') {
      return n.className;
    }
    return n.getAttribute(attr) || n[attr];
  }
  function getNodes(ns, mode, tagName) {
    var result = [], ri = -1, cs, i, ni, j, ci, cn, utag, n, cj;
    if (!ns) {
      return result;
    }
    tagName = tagName.replace('|', ':') || '*';
    if (typeof ns.getElementsByTagName != 'undefined') {
      ns = [ns];
    }
    if (!mode) {
      tagName = unescapeCssSelector(tagName);
      if (!supportsColonNsSeparator && DQ.isXml(ns[0]) && tagName.indexOf(':') !== -1) {
        for (i = 0; ni = ns[i]; i++) {
          cs = ni.getElementsByTagName(tagName.split(':').pop());
          for (j = 0; ci = cs[j]; j++) {
            if (ci.tagName === tagName) {
              result[++ri] = ci;
            }
          }
        }
      } else {
        for (i = 0; ni = ns[i]; i++) {
          cs = ni.getElementsByTagName(tagName);
          for (j = 0; ci = cs[j]; j++) {
            result[++ri] = ci;
          }
        }
      }
    } else {
      if (mode == '/' || mode == '\x3e') {
        utag = tagName.toUpperCase();
        for (i = 0; ni = ns[i]; i++) {
          cn = ni.childNodes;
          for (j = 0; cj = cn[j]; j++) {
            if (cj.nodeName == utag || cj.nodeName == tagName || tagName == '*') {
              result[++ri] = cj;
            }
          }
        }
      } else {
        if (mode == '+') {
          utag = tagName.toUpperCase();
          for (i = 0; n = ns[i]; i++) {
            while ((n = n.nextSibling) && n.nodeType != 1) {
            }
            if (n && (n.nodeName == utag || n.nodeName == tagName || tagName == '*')) {
              result[++ri] = n;
            }
          }
        } else {
          if (mode == '~') {
            utag = tagName.toUpperCase();
            for (i = 0; n = ns[i]; i++) {
              while (n = n.nextSibling) {
                if (n.nodeName == utag || n.nodeName == tagName || tagName == '*') {
                  result[++ri] = n;
                }
              }
            }
          }
        }
      }
    }
    return result;
  }
  function concat(a, b) {
    a.push.apply(a, b);
    return a;
  }
  function byTag(cs, tagName) {
    if (cs.tagName || cs === doc) {
      cs = [cs];
    }
    if (!tagName) {
      return cs;
    }
    var result = [], ri = -1, i, ci;
    tagName = tagName.toLowerCase();
    for (i = 0; ci = cs[i]; i++) {
      if (ci.nodeType == 1 && ci.tagName.toLowerCase() == tagName) {
        result[++ri] = ci;
      }
    }
    return result;
  }
  function byId(cs, id) {
    id = unescapeCssSelector(id);
    if (cs.tagName || cs === doc) {
      cs = [cs];
    }
    if (!id) {
      return cs;
    }
    var result = [], ri = -1, i, ci;
    for (i = 0; ci = cs[i]; i++) {
      if (ci && ci.id == id) {
        result[++ri] = ci;
        return result;
      }
    }
    return result;
  }
  function byAttribute(cs, attr, value, op, custom) {
    var result = [], ri = -1, useGetStyle = custom == '{', fn = DQ.operators[op], a, xml, hasXml, i, ci;
    value = unescapeCssSelector(value);
    for (i = 0; ci = cs[i]; i++) {
      if (ci.nodeType === 1) {
        if (!hasXml) {
          xml = DQ.isXml(ci);
          hasXml = true;
        }
        if (!xml) {
          if (useGetStyle) {
            a = DQ.getStyle(ci, attr);
          } else {
            if (attr == 'class' || attr == 'className') {
              a = ci.className;
            } else {
              if (attr == 'for') {
                a = ci.htmlFor;
              } else {
                if (attr == 'href') {
                  a = ci.getAttribute('href', 2);
                } else {
                  a = ci.getAttribute(attr);
                }
              }
            }
          }
        } else {
          a = ci.getAttribute(attr);
        }
        if (fn && fn(a, value) || !fn && a) {
          result[++ri] = ci;
        }
      }
    }
    return result;
  }
  function byPseudo(cs, name, value) {
    value = unescapeCssSelector(value);
    return DQ.pseudos[name](cs, value);
  }
  function nodupIEXml(cs) {
    var d = ++key, r, i, len, c;
    cs[0].setAttribute('_nodup', d);
    r = [cs[0]];
    for (i = 1, len = cs.length; i < len; i++) {
      c = cs[i];
      if (!c.getAttribute('_nodup') != d) {
        c.setAttribute('_nodup', d);
        r[r.length] = c;
      }
    }
    for (i = 0, len = cs.length; i < len; i++) {
      cs[i].removeAttribute('_nodup');
    }
    return r;
  }
  function nodup(cs) {
    if (!cs) {
      return [];
    }
    var len = cs.length, c, i, r = cs, cj, ri = -1, d, j;
    if (!len || typeof cs.nodeType != 'undefined' || len == 1) {
      return cs;
    }
    if (isIE && typeof cs[0].selectSingleNode != 'undefined') {
      return nodupIEXml(cs);
    }
    d = ++key;
    cs[0]._nodup = d;
    for (i = 1; c = cs[i]; i++) {
      if (c._nodup != d) {
        c._nodup = d;
      } else {
        r = [];
        for (j = 0; j < i; j++) {
          r[++ri] = cs[j];
        }
        for (j = i + 1; cj = cs[j]; j++) {
          if (cj._nodup != d) {
            cj._nodup = d;
            r[++ri] = cj;
          }
        }
        return r;
      }
    }
    return r;
  }
  function quickDiffIEXml(c1, c2) {
    var d = ++key, r = [], i, len;
    for (i = 0, len = c1.length; i < len; i++) {
      c1[i].setAttribute('_qdiff', d);
    }
    for (i = 0, len = c2.length; i < len; i++) {
      if (c2[i].getAttribute('_qdiff') != d) {
        r[r.length] = c2[i];
      }
    }
    for (i = 0, len = c1.length; i < len; i++) {
      c1[i].removeAttribute('_qdiff');
    }
    return r;
  }
  function quickDiff(c1, c2) {
    var len1 = c1.length, d = ++key, r = [], i, len;
    if (!len1) {
      return c2;
    }
    if (isIE && typeof c1[0].selectSingleNode != 'undefined') {
      return quickDiffIEXml(c1, c2);
    }
    for (i = 0; i < len1; i++) {
      c1[i]._qdiff = d;
    }
    for (i = 0, len = c2.length; i < len; i++) {
      if (c2[i]._qdiff != d) {
        r[r.length] = c2[i];
      }
    }
    return r;
  }
  function quickId(ns, mode, root, id) {
    if (ns == root) {
      id = unescapeCssSelector(id);
      var d = root.ownerDocument || root;
      return d.getElementById(id);
    }
    ns = getNodes(ns, mode, '*');
    return byId(ns, id);
  }
  return {singleton:true, alternateClassName:['Ext.core.DomQuery', 'Ext.DomQuery'], _init:function() {
    DQ = this;
    DQ.operators = Ext.Object.chain(Ext.util.Operators);
    DQ._cache = cache = new Ext.util.LruCache({maxSize:200});
    DQ._valueCache = valueCache = new Ext.util.LruCache({maxSize:200});
    DQ._simpleCache = simpleCache = new Ext.util.LruCache({maxSize:200});
  }, clearCache:function() {
    cache.clear();
    valueCache.clear();
    simpleCache.clear();
  }, getStyle:function(el, name) {
    return Ext.fly(el, '_DomQuery').getStyle(name);
  }, compile:function(path, type) {
    type = type || 'select';
    var fn = ['var f \x3d function(root) {\n var mode; ++batch; var n \x3d root || document;\n'], lastPath, matchers = DQ.matchers, matchersLn = matchers.length, modeMatch, lmode = path.match(modeRe), tokenMatch, matched, j, t, m;
    path = setupEscapes(path);
    if (lmode && lmode[1]) {
      fn[fn.length] = 'mode\x3d"' + lmode[1].replace(trimRe, '') + '";';
      path = path.replace(lmode[1], '');
    }
    while (path.substr(0, 1) == '/') {
      path = path.substr(1);
    }
    while (path && lastPath != path) {
      lastPath = path;
      tokenMatch = path.match(tagTokenRe);
      if (type == 'select') {
        if (tokenMatch) {
          if (tokenMatch[1] == '#') {
            fn[fn.length] = 'n \x3d quickId(n, mode, root, "' + tokenMatch[2] + '");';
          } else {
            fn[fn.length] = 'n \x3d getNodes(n, mode, "' + tokenMatch[2] + '");';
          }
          path = path.replace(tokenMatch[0], '');
        } else {
          if (path.substr(0, 1) != '@') {
            fn[fn.length] = 'n \x3d getNodes(n, mode, "*");';
          }
        }
      } else {
        if (tokenMatch) {
          if (tokenMatch[1] == '#') {
            fn[fn.length] = 'n \x3d byId(n, "' + tokenMatch[2] + '");';
          } else {
            fn[fn.length] = 'n \x3d byTag(n, "' + tokenMatch[2] + '");';
          }
          path = path.replace(tokenMatch[0], '');
        }
      }
      while (!(modeMatch = path.match(modeRe))) {
        matched = false;
        for (j = 0; j < matchersLn; j++) {
          t = matchers[j];
          m = path.match(t.re);
          if (m) {
            fn[fn.length] = t.select.replace(tplRe, function(x, i) {
              return m[i];
            });
            path = path.replace(m[0], '');
            matched = true;
            break;
          }
        }
        if (!matched) {
          Ext.raise({sourceClass:'Ext.DomQuery', sourceMethod:'compile', msg:'Error parsing selector. Parsing failed at "' + path + '"'});
        }
      }
      if (modeMatch[1]) {
        fn[fn.length] = 'mode\x3d"' + modeMatch[1].replace(trimRe, '') + '";';
        path = path.replace(modeMatch[1], '');
      }
    }
    fn[fn.length] = 'return nodup(n);\n}';
    eval(fn.join(''));
    return f;
  }, jsSelect:function(path, root, type) {
    root = root || doc;
    if (typeof root == 'string') {
      root = doc.getElementById(root);
    }
    var paths = Ext.splitAndUnescape(path, ','), results = [], query, i, len, subPath, result;
    for (i = 0, len = paths.length; i < len; i++) {
      subPath = paths[i].replace(trimRe, '');
      query = cache.get(subPath);
      if (!query) {
        query = DQ.compile(subPath, type);
        if (!query) {
          Ext.raise({sourceClass:'Ext.DomQuery', sourceMethod:'jsSelect', msg:subPath + ' is not a valid selector'});
        }
        cache.add(subPath, query);
      } else {
        setupEscapes(subPath);
      }
      result = query(root);
      if (result && result !== doc) {
        results = results.concat(result);
      }
    }
    if (paths.length > 1) {
      return nodup(results);
    }
    return results;
  }, isXml:function(el) {
    var docEl = (el ? el.ownerDocument || el : 0).documentElement;
    return docEl ? docEl.nodeName !== 'HTML' : false;
  }, select:doc.querySelectorAll ? function(path, root, type, single) {
    root = root || doc;
    if (!DQ.isXml(root)) {
      try {
        if (root.parentNode && root.nodeType !== 9 && path.indexOf(',') === -1 && !startIdRe.test(path)) {
          path = Ext.makeIdSelector(Ext.id(root)) + ' ' + path;
          root = root.parentNode;
        }
        return single ? [root.querySelector(path)] : Ext.Array.toArray(root.querySelectorAll(path));
      } catch (e$31) {
      }
    }
    return DQ.jsSelect.call(this, path, root, type);
  } : function(path, root, type) {
    return DQ.jsSelect.call(this, path, root, type);
  }, selectNode:function(path, root) {
    return Ext.DomQuery.select(path, root, null, true)[0];
  }, selectValue:function(path, root, defaultValue) {
    path = path.replace(trimRe, '');
    var query = valueCache.get(path), n, v;
    if (!query) {
      query = DQ.compile(path, 'select');
      valueCache.add(path, query);
    } else {
      setupEscapes(path);
    }
    n = query(root);
    return DQ.getNodeValue(n[0] || n, defaultValue);
  }, getNodeValue:function(node, defaultValue) {
    if (typeof node.normalize == 'function') {
      node.normalize();
    }
    var firstChild = node && node.firstChild, v = firstChild ? firstChild.nodeValue : null;
    if (defaultValue !== undefined && (v == null || v === '')) {
      v = defaultValue;
    }
    return v;
  }, selectNumber:function(path, root, defaultValue) {
    var v = DQ.selectValue(path, root, defaultValue || 0);
    return parseFloat(v);
  }, is:function(el, ss) {
    if (typeof el == 'string') {
      el = doc.getElementById(el);
    }
    var isArray = Ext.isArray(el), result = DQ.filter(isArray ? el : [el], ss);
    return isArray ? result.length == el.length : result.length > 0;
  }, filter:function(els, ss, nonMatches) {
    ss = ss.replace(trimRe, '');
    var query = simpleCache.get(ss), result;
    if (!query) {
      query = DQ.compile(ss, 'simple');
      simpleCache.add(ss, query);
    } else {
      setupEscapes(ss);
    }
    result = query(els);
    return nonMatches ? quickDiff(result, els) : result;
  }, matchers:[{re:/^\.([\w\-\\]+)/, select:useClassList ? 'n \x3d byClassName(n, "{1}");' : 'n \x3d byClassName(n, " {1} ");'}, {re:/^\:([\w\-]+)(?:\(((?:[^\s>\/]*|.*?))\))?/, select:'n \x3d byPseudo(n, "{1}", "{2}");'}, {re:/^(?:([\[\{])(?:@)?([\w\-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]\}])/, select:'n \x3d byAttribute(n, "{2}", "{4}", "{3}", "{1}");'}, {re:/^#([\w\-\\]+)/, select:'n \x3d byId(n, "{1}");'}, {re:/^@([\w\-\.]+)/, select:'return {firstChild:{nodeValue:attrValue(n, "{1}")}};'}], pseudos:{'first-child':function(c) {
    var r = [], ri = -1, n, i, ci;
    for (i = 0; ci = n = c[i]; i++) {
      while ((n = n.previousSibling) && n.nodeType != 1) {
      }
      if (!n) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'last-child':function(c) {
    var r = [], ri = -1, n, i, ci;
    for (i = 0; ci = n = c[i]; i++) {
      while ((n = n.nextSibling) && n.nodeType != 1) {
      }
      if (!n) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'nth-child':function(c, a) {
    var r = [], ri = -1, m = nthRe.exec(a == 'even' && '2n' || a == 'odd' && '2n+1' || !nthRe2.test(a) && 'n+' + a || a), f = (m[1] || 1) - 0, l = m[2] - 0, i, n, j, cn, pn;
    for (i = 0; n = c[i]; i++) {
      pn = n.parentNode;
      if (batch != pn._batch) {
        j = 0;
        for (cn = pn.firstChild; cn; cn = cn.nextSibling) {
          if (cn.nodeType == 1) {
            cn.nodeIndex = ++j;
          }
        }
        pn._batch = batch;
      }
      if (f == 1) {
        if (l === 0 || n.nodeIndex == l) {
          r[++ri] = n;
        }
      } else {
        if ((n.nodeIndex + l) % f === 0) {
          r[++ri] = n;
        }
      }
    }
    return r;
  }, 'only-child':function(c) {
    var r = [], ri = -1, i, ci;
    for (i = 0; ci = c[i]; i++) {
      if (!prev(ci) && !next(ci)) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'empty':function(c) {
    var r = [], ri = -1, i, ci, cns, j, cn, empty;
    for (i = 0; ci = c[i]; i++) {
      cns = ci.childNodes;
      j = 0;
      empty = true;
      while (cn = cns[j]) {
        ++j;
        if (cn.nodeType == 1 || cn.nodeType == 3) {
          empty = false;
          break;
        }
      }
      if (empty) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'contains':function(c, v) {
    var r = [], ri = -1, i, ci;
    for (i = 0; ci = c[i]; i++) {
      if ((ci.textContent || ci.innerText || ci.text || '').indexOf(v) != -1) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'nodeValue':function(c, v) {
    var r = [], ri = -1, i, ci;
    for (i = 0; ci = c[i]; i++) {
      if (ci.firstChild && ci.firstChild.nodeValue == v) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'checked':function(c) {
    var r = [], ri = -1, i, ci;
    for (i = 0; ci = c[i]; i++) {
      if (ci.checked === true) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'not':function(c, ss) {
    return DQ.filter(c, ss, true);
  }, 'any':function(c, selectors) {
    var ss = selectors.split('|'), r = [], ri = -1, s, i, ci, j;
    for (i = 0; ci = c[i]; i++) {
      for (j = 0; s = ss[j]; j++) {
        if (DQ.is(ci, s)) {
          r[++ri] = ci;
          break;
        }
      }
    }
    return r;
  }, 'odd':function(c) {
    return this['nth-child'](c, 'odd');
  }, 'even':function(c) {
    return this['nth-child'](c, 'even');
  }, 'nth':function(c, a) {
    return c[a - 1] || [];
  }, 'first':function(c) {
    return c[0] || [];
  }, 'last':function(c) {
    return c[c.length - 1] || [];
  }, 'has':function(c, ss) {
    var s = DQ.select, r = [], ri = -1, i, ci;
    for (i = 0; ci = c[i]; i++) {
      if (s(ss, ci).length > 0) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'next':function(c, ss) {
    var is = DQ.is, r = [], ri = -1, i, ci, n;
    for (i = 0; ci = c[i]; i++) {
      n = next(ci);
      if (n && is(n, ss)) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'prev':function(c, ss) {
    var is = DQ.is, r = [], ri = -1, i, ci, n;
    for (i = 0; ci = c[i]; i++) {
      n = prev(ci);
      if (n && is(n, ss)) {
        r[++ri] = ci;
      }
    }
    return r;
  }, focusable:function(candidates) {
    var len = candidates.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = candidates[i];
      if (Ext.fly(c, '_DomQuery').isFocusable()) {
        results.push(c);
      }
    }
    return results;
  }, visible:function(candidates, deep) {
    var len = candidates.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = candidates[i];
      if (Ext.fly(c, '_DomQuery').isVisible(deep)) {
        results.push(c);
      }
    }
    return results;
  }, isScrolled:function(c) {
    var r = [], ri = -1, i, ci, s;
    for (i = 0; ci = c[i]; i++) {
      s = Ext.fly(ci, '_DomQuery').getScroll();
      if (s.top > 0 || s.left > 0) {
        r[++ri] = ci;
      }
    }
    return r;
  }}};
}, 0, 0, 0, 0, 0, 0, [Ext.dom, 'Query', Ext.core, 'DomQuery', Ext, 'DomQuery'], function() {
  this._init();
});
Ext.cmd.derive('Ext.dom.GarbageCollector', Ext.Base, {singleton:true, interval:30000, constructor:function() {
  var me = this;
  me.lastTime = Ext.now();
  me.onTick = me.onTick.bind(me);
  me.resume();
}, collect:function() {
  var me = this, cache = Ext.cache, eid, dom, el, t, isGarbage, tagName;
  for (eid in cache) {
    if (!cache.hasOwnProperty(eid)) {
      continue;
    }
    el = cache[eid];
    if (el.skipGarbageCollection) {
      continue;
    }
    dom = el.dom;
    try {
      isGarbage = Ext.isGarbage(dom);
    } catch (e$32) {
      delete cache[eid];
      continue;
    }
    if (isGarbage) {
      isGarbage = false;
      if (el && el.dom) {
        el.collect();
      }
    }
  }
  if (Ext.isIE9m) {
    t = {};
    for (eid in cache) {
      if (cache.hasOwnProperty(eid)) {
        t[eid] = cache[eid];
      }
    }
    Ext.cache = Ext.dom.Element.cache = t;
  }
  me.lastTime = Ext.now();
}, onTick:function() {
  this.timerId = null;
  if (Ext.enableGarbageCollector) {
    this.collect();
  }
  this.resume();
}, pause:function() {
  var timerId = this.timerId;
  if (timerId) {
    this.timerId = null;
    Ext.undefer(timerId);
  }
}, resume:function() {
  var me = this, lastTime = me.lastTime;
  if (Ext.enableGarbageCollector && Ext.now() - lastTime > me.interval) {
    me.collect();
  }
  if (!me.timerId) {
    me.timerId = Ext.defer(me.onTick, me.interval);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.dom, 'GarbageCollector'], 0);
Ext.cmd.derive('Ext.dom.TouchAction', Ext.Base, {singleton:true, lastTouchStartTime:0, minMoveDistance:8, spaceRe:/\s+/, preventSingle:null, preventMulti:null, disabledOverflowDom:null, panXCls:'x-touch-action-pan-x', panYCls:'x-touch-action-pan-y', cssValues:['none', 'pan-x', 'pan-y', 'pan-x pan-y', 'pinch-zoom', 'pan-x pinch-zoom', 'pan-y pinch-zoom', 'pan-x pan-y pinch-zoom', 'double-tap-zoom', 'pan-x double-tap-zoom', 'pan-y double-tap-zoom', 'pan-x pan-y double-tap-zoom', 'pinch-zoom double-tap-zoom', 
'pan-x pinch-zoom double-tap-zoom', 'pan-y pinch-zoom double-tap-zoom', ''], objectValues:[{panX:false, panY:false, pinchZoom:false, doubleTapZoom:false}, {panX:true, panY:false, pinchZoom:false, doubleTapZoom:false}, {panX:false, panY:true, pinchZoom:false, doubleTapZoom:false}, {panX:true, panY:true, pinchZoom:false, doubleTapZoom:false}, {panX:false, panY:false, pinchZoom:true, doubleTapZoom:false}, {panX:true, panY:false, pinchZoom:true, doubleTapZoom:false}, {panX:false, panY:true, pinchZoom:true, 
doubleTapZoom:false}, {panX:true, panY:true, pinchZoom:true, doubleTapZoom:false}, {panX:false, panY:false, pinchZoom:false, doubleTapZoom:true}, {panX:true, panY:false, pinchZoom:false, doubleTapZoom:true}, {panX:false, panY:true, pinchZoom:false, doubleTapZoom:true}, {panX:true, panY:true, pinchZoom:false, doubleTapZoom:true}, {panX:false, panY:false, pinchZoom:true, doubleTapZoom:true}, {panX:true, panY:false, pinchZoom:true, doubleTapZoom:true}, {panX:false, panY:true, pinchZoom:true, doubleTapZoom:true}, 
{panX:true, panY:true, pinchZoom:true, doubleTapZoom:true}], attributeName:'data-extTouchAction', constructor:function() {
  var me = this, supports = Ext.supports;
  if (supports.TouchAction) {
    me.cssProp = 'touch-action';
  } else {
    if (supports.MSPointerEvents) {
      me.cssProp = '-ms-touch-action';
    }
  }
  if (supports.TouchEvents) {
    Ext.getWin().on({touchstart:'onTouchStart', touchmove:'onTouchMove', touchend:'onTouchEnd', scope:me, delegated:false, translate:false, capture:true, priority:5000});
    Ext.on({scroll:'onScroll', scope:me, destroyable:true});
  }
}, containsTargets:function(dom, e) {
  var contains = true, event = e.browserEvent, touches = e.type === 'touchend' ? event.changedTouches : event.touches, i, ln;
  for (i = 0, ln = touches.length; i < ln; i++) {
    if (!dom.contains(touches[i].target)) {
      contains = false;
      break;
    }
  }
  return contains;
}, disableOverflow:function(dom, vertical) {
  var me = this, overflowName = vertical ? 'overflow-y' : 'overflow-x', overflowStyle, cls;
  if (!me.disabledOverflowDom && !Ext.isiOS && !Ext.getScrollbarSize().width) {
    me.disabledOverflowDom = dom;
    cls = vertical ? me.panXCls : me.panYCls;
    while (dom) {
      overflowStyle = Ext.fly(dom).getStyle(overflowName);
      if (overflowStyle === 'auto' || overflowStyle === 'scroll') {
        Ext.fly(dom).addCls(cls);
      }
      dom = dom.parentNode;
    }
  }
}, get:function(dom) {
  var flags = dom.getAttribute(this.attributeName), ret = null;
  if (flags != null) {
    ret = this.objectValues[flags];
  }
  return ret;
}, getFlags:function(touchAction) {
  var flags;
  if (typeof touchAction === 'number') {
    flags = touchAction;
  } else {
    flags = 0;
    if (touchAction.panX !== false) {
      flags |= 1;
    }
    if (touchAction.panY !== false) {
      flags |= 2;
    }
    if (touchAction.pinchZoom !== false) {
      flags |= 4;
    }
    if (touchAction.doubleTapZoom !== false) {
      flags |= 8;
    }
  }
  return flags;
}, isScrollable:function(el, vertical, forward) {
  var overflowStyle = Ext.fly(el).getStyle(vertical ? 'overflow-y' : 'overflow-x'), isScrollable = overflowStyle === 'auto' || overflowStyle === 'scroll';
  if (isScrollable) {
    if (vertical) {
      isScrollable = forward ? el.scrollTop + el.clientHeight < el.scrollHeight : el.scrollTop > 0;
    } else {
      isScrollable = forward ? el.scrollLeft + el.clientWidth < el.scrollWidth : el.scrollLeft > 0;
    }
  }
  return isScrollable;
}, lookupFlags:function(dom) {
  return parseInt(dom.getAttribute && dom.getAttribute(this.attributeName) || 15, 10);
}, onScroll:function() {
  this.scrollOccurred = true;
  this.isDoubleTap = false;
}, onTouchEnd:function(e) {
  var me = this, dom = e.target, touchCount, flags, doubleTapZoom;
  touchCount = e.browserEvent.touches.length;
  if (touchCount === 0) {
    if (me.isDoubleTap) {
      while (dom) {
        flags = me.lookupFlags(dom);
        if (flags != null) {
          doubleTapZoom = flags & 8;
          if (!doubleTapZoom) {
            e.preventDefault();
          }
        }
        dom = dom.parentNode;
      }
    }
    me.isDoubleTap = false;
    me.preventSingle = null;
    me.preventMulti = null;
    me.resetOverflow();
  }
}, onTouchMove:function(e) {
  var me = this, prevent = null, dom = e.target, flags, touchCount, panX, panY, point, startPoint, isVertical, scale, distance, deltaX, deltaY, preventSingle, preventMulti;
  preventSingle = me.preventSingle;
  preventMulti = me.preventMulti;
  touchCount = e.browserEvent.touches.length;
  if (touchCount === 1 && preventSingle === false || preventMulti === false) {
    return;
  }
  if (touchCount > 1 && preventMulti === true || touchCount === 1 && preventSingle === true) {
    prevent = true;
  } else {
    if (touchCount === 1) {
      point = e.getPoint();
      startPoint = me.startPoint;
      scale = Ext.Element.getViewportScale();
      distance = point.getDistanceTo(me.startPoint) * scale;
      deltaX = point.x - startPoint.x;
      deltaY = point.y - startPoint.y;
      isVertical = Math.abs(deltaY) >= Math.abs(deltaX);
    }
    while (dom && dom.nodeType === 1) {
      flags = me.lookupFlags(dom);
      if (flags & 0) {
        prevent = true;
      } else {
        if (touchCount === 1) {
          panX = !!(flags & 1);
          panY = !!(flags & 2);
          if (panX && panY) {
            prevent = false;
          } else {
            if (!panX && !panY) {
              prevent = true;
            } else {
              if (distance >= me.minMoveDistance) {
                prevent = !!(panX && isVertical || panY && !isVertical);
              }
            }
          }
          if (!prevent && me.isScrollable(dom, isVertical, (isVertical ? deltaY : deltaX) < 0)) {
            break;
          }
        } else {
          if (me.containsTargets(dom, e)) {
            prevent = !(flags & 4);
          } else {
            prevent = false;
          }
        }
      }
      if (prevent) {
        break;
      }
      dom = dom.parentNode;
    }
  }
  if (touchCount === 1) {
    me.preventSingle = prevent;
  } else {
    if (touchCount > 1) {
      me.preventMulti = prevent;
    }
  }
  if (prevent) {
    e.preventDefault();
  }
}, onTouchStart:function(e) {
  var me = this, time, flags, dom, panX, panY;
  if (e.browserEvent.touches.length === 1) {
    time = e.time;
    if (!me.scrollOccurred && time - me.lastTouchStartTime <= 500) {
      me.isDoubleTap = true;
    }
    me.lastTouchStartTime = time;
    me.scrollOccurred = false;
    me.startPoint = e.getPoint();
    dom = e.target;
    while (dom) {
      flags = me.lookupFlags(dom);
      if (flags != null) {
        panX = !!(flags & 1);
        panY = !!(flags & 2);
        if (panX !== panY) {
          me.disableOverflow(dom, panX);
          break;
        }
      }
      dom = dom.parentNode;
    }
  } else {
    me.isDoubleTap = false;
  }
}, resetOverflow:function() {
  var me = this, dom = me.disabledOverflowDom;
  while (dom) {
    Ext.fly(dom).removeCls([me.panXCls, me.panYCls]);
    dom = dom.parentNode;
  }
  me.disabledOverflowDom = null;
}, set:function(dom, value) {
  var me = this, cssProp = me.cssProp, flags = me.getFlags(value), supportedFlags = flags & Ext.supports.TouchAction, attributeName = me.attributeName;
  if (cssProp) {
    Ext.fly(dom).setStyle(cssProp, me.cssValues[supportedFlags]);
  }
  if (flags === 15) {
    dom.removeAttribute(attributeName);
  } else {
    dom.setAttribute(attributeName, flags);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.dom, 'TouchAction'], 0);
Ext.cmd.derive('Ext.event.gesture.Recognizer', Ext.Base, {priority:0, handledEvents:[], isStarted:false, config:{onRecognized:Ext.emptyFn, callbackScope:null}, constructor:function(config) {
  this.initConfig(config);
  Ext.event.publisher.Gesture.instance.registerRecognizer(this);
}, onStart:Ext.emptyFn, onEnd:Ext.emptyFn, onTouchStart:Ext.emptyFn, onTouchMove:Ext.emptyFn, onTouchEnd:function() {
  return this.reset();
}, onTouchCancel:function(e) {
  return this.cancel(e);
}, fire:function(eventName, e, info, isCancel) {
  this.getOnRecognized().call(this.getCallbackScope(), this, eventName, e, info, isCancel);
}, cancel:function(e) {
  if (this.isStarted) {
    this.onCancel(e);
  }
  return this.reset();
}, onCancel:Ext.emptyFn, reset:function() {
  this.isStarted = false;
  return false;
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Identifiable.prototype.mixinId || Ext.mixin.Identifiable.$className, Ext.mixin.Identifiable]], [Ext.event.gesture, 'Recognizer'], 0);
Ext.cmd.derive('Ext.event.gesture.SingleTouch', Ext.event.gesture.Recognizer, {isSingleTouch:true, onTouchStart:function(e) {
  if (e.touches.length > 1) {
    return this.cancel(e);
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, 'SingleTouch'], 0);
Ext.cmd.derive('Ext.event.gesture.DoubleTap', Ext.event.gesture.SingleTouch, {priority:300, config:{moveDistance:8, tapDistance:24, maxDuration:300}, handledEvents:['singletap', 'doubletap'], singleTapTimer:null, startTime:0, lastTapTime:0, onTouchStart:function(e) {
  var me = this, ret = Ext.event.gesture.SingleTouch.prototype.onTouchStart.call(this, e), lastStartPoint;
  if (ret !== false) {
    me.isStarted = true;
    lastStartPoint = me.lastStartPoint = e.changedTouches[0].point;
    me.startPoint = me.startPoint || lastStartPoint;
    me.startTime = e.time;
    Ext.undefer(me.singleTapTimer);
  }
  return ret;
}, onTouchMove:function(e) {
  var me = this, point = e.changedTouches[0].point, scale = Ext.Element.getViewportScale(), distance = Math.round(Math.abs(point.getDistanceTo(me.lastStartPoint) * scale));
  if (distance >= me.getMoveDistance()) {
    return me.cancel(e);
  }
}, onTouchEnd:function(e) {
  var me = this, maxDuration = me.getMaxDuration(), time = e.time, target = e.target, lastTapTime = me.lastTapTime, lastTarget = me.lastTarget, point = e.changedTouches[0].point, duration, scale, distance;
  me.lastTapTime = time;
  me.lastTarget = target;
  if (lastTapTime) {
    duration = time - lastTapTime;
    if (duration <= maxDuration) {
      scale = Ext.Element.getViewportScale();
      distance = Math.round(Math.abs(point.getDistanceTo(me.startPoint) * scale));
      if (distance <= me.getTapDistance()) {
        if (target !== lastTarget) {
          return me.cancel(e);
        }
        me.lastTarget = null;
        me.lastTapTime = 0;
        me.fire('doubletap', e, {touch:e.changedTouches[0], duration:duration});
        return Ext.event.gesture.SingleTouch.prototype.onTouchEnd.call(this, e);
      }
    }
  }
  if (time - me.startTime > maxDuration) {
    me.fire('singletap', e);
    me.reset();
  } else {
    me.setSingleTapTimer(e);
  }
}, setSingleTapTimer:function(e) {
  var me = this;
  me.singleTapTimer = Ext.defer(function() {
    me.fire('singletap', e);
    me.reset();
  }, me.getMaxDuration());
}, reset:function() {
  var me = this;
  Ext.undefer(me.singleTapTimer);
  me.startTime = me.lastTapTime = 0;
  me.lastStartPoint = me.startPoint = me.singleTapTimer = null;
  return Ext.event.gesture.SingleTouch.prototype.reset.call(this);
}}, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, 'DoubleTap'], function(DoubleTap) {
  var gestures = Ext.manifest.gestures;
  DoubleTap.instance = new DoubleTap(gestures && gestures.doubleTap);
});
Ext.cmd.derive('Ext.event.gesture.Drag', Ext.event.gesture.SingleTouch, {priority:100, startPoint:null, previousPoint:null, lastPoint:null, handledEvents:['dragstart', 'drag', 'dragend', 'dragcancel'], config:{minDistance:8}, constructor:function() {
  Ext.event.gesture.SingleTouch.prototype.constructor.apply(this, arguments);
  this.initInfo();
}, initInfo:function() {
  this.info = {touch:null, previous:{x:0, y:0}, x:0, y:0, delta:{x:0, y:0}, absDelta:{x:0, y:0}, flick:{velocity:{x:0, y:0}}, direction:{x:0, y:0}, time:0, previousTime:{x:0, y:0}, longpress:false};
}, onTouchStart:function(e) {
  var me = this, ret = Ext.event.gesture.SingleTouch.prototype.onTouchStart.call(this, e);
  if (ret !== false) {
    me.startTime = e.time;
    me.startPoint = e.changedTouches[0].point;
  }
  return ret;
}, tryDragStart:function(e) {
  var me = this, point = e.changedTouches[0].point, minDistance = me.getMinDistance(), scale = Ext.Element.getViewportScale(), distance = Math.round(Math.abs(point.getDistanceTo(me.startPoint) * scale));
  if (distance >= minDistance) {
    me.doDragStart(e);
  }
}, doDragStart:function(e, isLongPress) {
  var me = this, touch = e.changedTouches[0], point = touch.point, info = me.info, time;
  if (isLongPress) {
    time = Ext.now();
    me.startTime = time;
    me.startPoint = point;
    info.longpress = true;
  } else {
    time = e.time;
  }
  me.isStarted = true;
  me.previousPoint = me.lastPoint = point;
  me.resetInfo('x', e, touch);
  me.resetInfo('y', e, touch);
  info.time = time;
  me.fire('dragstart', e, info);
}, onTouchMove:function(e) {
  var me = this, touch, point;
  if (!me.startPoint) {
    return;
  }
  if (!me.isStarted) {
    me.tryDragStart(e);
  }
  if (!me.isStarted) {
    return;
  }
  touch = e.changedTouches[0];
  point = touch.point;
  if (me.lastPoint) {
    me.previousPoint = me.lastPoint;
  }
  me.lastPoint = point;
  me.lastMoveEvent = e;
  me.updateInfo('x', e, touch);
  me.updateInfo('y', e, touch);
  me.info.time = e.time;
  me.fire('drag', e, me.info);
}, onAxisDragEnd:function(axis, info) {
  var duration = info.time - info.previousTime[axis];
  if (duration > 0) {
    info.flick.velocity[axis] = (info[axis] - info.previous[axis]) / duration;
  }
}, resetInfo:function(axis, e, touch) {
  var me = this, value = me.lastPoint[axis], startValue = me.startPoint[axis], delta = value - startValue, capAxis = axis.toUpperCase(), info = me.info;
  info.touch = touch;
  info.delta[axis] = delta;
  info.absDelta[axis] = Math.abs(delta);
  info.previousTime[axis] = me.startTime;
  info.previous[axis] = startValue;
  info[axis] = value;
  info.direction[axis] = 0;
  info['start' + capAxis] = me.startPoint[axis];
  info['previous' + capAxis] = info.previous[axis];
  info['page' + capAxis] = info[axis];
  info['delta' + capAxis] = info.delta[axis];
  info['absDelta' + capAxis] = info.absDelta[axis];
  info['previousDelta' + capAxis] = 0;
  info.startTime = me.startTime;
}, updateInfo:function(axis, e, touch) {
  var me = this, value = me.lastPoint[axis], previousValue = me.previousPoint[axis], startValue = me.startPoint[axis], delta = value - startValue, info = me.info, direction = info.direction, capAxis = axis.toUpperCase(), previousFlick = info.previous[axis];
  info.touch = touch;
  info.delta[axis] = delta;
  info.absDelta[axis] = Math.abs(delta);
  if (value !== previousFlick && value !== info[axis]) {
    info.previous[axis] = info[axis];
    info.previousTime[axis] = info.time;
  }
  info[axis] = value;
  if (value > previousValue) {
    direction[axis] = 1;
  } else {
    if (value < previousValue) {
      direction[axis] = -1;
    }
  }
  info['start' + capAxis] = startValue;
  info['previous' + capAxis] = info.previous[axis];
  info['page' + capAxis] = info[axis];
  info['delta' + capAxis] = info.delta[axis];
  info['absDelta' + capAxis] = info.absDelta[axis];
  info['previousDelta' + capAxis] = info.previous[axis] - startValue;
  info.startTime = me.startTime;
}, onTouchEnd:function(e) {
  var me = this, touch, point, info;
  if (me.isStarted) {
    touch = e.changedTouches[0];
    point = touch.point;
    info = me.info;
    me.lastPoint = point;
    me.updateInfo('x', e, touch);
    me.updateInfo('y', e, touch);
    info.time = e.time;
    me.onAxisDragEnd('x', info);
    me.onAxisDragEnd('y', info);
    me.fire('dragend', e, info);
  }
  return Ext.event.gesture.SingleTouch.prototype.onTouchEnd.call(this, e);
}, onCancel:function(e) {
  var me = this, touch = e.changedTouches[0], info = me.info;
  if (!e.touches.length) {
    me.lastPoint = touch.point;
  }
  me.updateInfo('x', e, touch);
  me.updateInfo('y', e, touch);
  info.time = e.time;
  me.fire('dragcancel', e, info, true);
}, reset:function() {
  var me = this;
  me.lastPoint = me.startPoint = me.previousPoint = me.lastPoint = me.lastMoveEvent = null;
  me.initInfo();
  return Ext.event.gesture.SingleTouch.prototype.reset.call(this);
}}, 1, 0, 0, 0, 0, 0, [Ext.event.gesture, 'Drag'], function(Drag) {
  var gestures = Ext.manifest.gestures;
  Drag.instance = new Drag(gestures && gestures.drag);
});
Ext.cmd.derive('Ext.event.gesture.Swipe', Ext.event.gesture.SingleTouch, {priority:600, handledEvents:['swipestart', 'swipe', 'swipecancel'], config:{minDistance:80, maxOffset:35, maxDuration:1000}, onTouchStart:function(e) {
  var me = this, ret = Ext.event.gesture.SingleTouch.prototype.onTouchStart.call(this, e), touch;
  if (ret !== false) {
    touch = e.changedTouches[0];
    me.startTime = e.time;
    me.isHorizontal = true;
    me.isVertical = true;
    me.startX = touch.pageX;
    me.startY = touch.pageY;
  }
  return ret;
}, onTouchMove:function(e) {
  var me = this, touch = e.changedTouches[0], x = touch.pageX, y = touch.pageY, deltaX = x - me.startX, deltaY = y - me.startY, absDeltaX = Math.abs(x - me.startX), absDeltaY = Math.abs(y - me.startY), duration = e.time - me.startTime, minDistance, direction, distance;
  if (absDeltaX === 0 && absDeltaY === 0 || duration > me.getMaxDuration()) {
    return me.cancel(e);
  }
  if (me.isHorizontal && absDeltaY > me.getMaxOffset()) {
    me.isHorizontal = false;
  }
  if (me.isVertical && absDeltaX > me.getMaxOffset()) {
    me.isVertical = false;
  }
  if (!me.isVertical || !me.isHorizontal) {
    minDistance = me.getMinDistance();
    if (me.isHorizontal && absDeltaX < minDistance) {
      direction = deltaX < 0 ? 'left' : 'right';
      distance = absDeltaX;
    } else {
      if (me.isVertical && absDeltaY < minDistance) {
        direction = deltaY < 0 ? 'up' : 'down';
        distance = absDeltaY;
      }
    }
  }
  if (!me.isHorizontal && !me.isVertical) {
    return me.cancel(e);
  }
  if (direction && !me.isStarted) {
    me.isStarted = true;
    me.fire('swipestart', e, {touch:touch, direction:direction, distance:distance, duration:duration});
  }
}, onTouchEnd:function(e) {
  var me = this, touch, x, y, deltaX, deltaY, absDeltaX, absDeltaY, minDistance, duration, direction, distance;
  if (me.onTouchMove(e) !== false) {
    touch = e.changedTouches[0];
    x = touch.pageX;
    y = touch.pageY;
    deltaX = x - me.startX;
    deltaY = y - me.startY;
    absDeltaX = Math.abs(deltaX);
    absDeltaY = Math.abs(deltaY);
    minDistance = me.getMinDistance();
    duration = e.time - me.startTime;
    if (me.isVertical && absDeltaY < minDistance) {
      me.isVertical = false;
    }
    if (me.isHorizontal && absDeltaX < minDistance) {
      me.isHorizontal = false;
    }
    if (me.isHorizontal) {
      direction = deltaX < 0 ? 'left' : 'right';
      distance = absDeltaX;
    } else {
      if (me.isVertical) {
        direction = deltaY < 0 ? 'up' : 'down';
        distance = absDeltaY;
      }
    }
    me.fire('swipe', e, {touch:touch, direction:direction, distance:distance, duration:duration});
  }
  return Ext.event.gesture.SingleTouch.prototype.onTouchEnd.call(this, e);
}, onCancel:function(e) {
  this.fire('swipecancel', e, null, true);
}, reset:function() {
  var me = this;
  me.startTime = me.isHorizontal = me.isVertical = me.startX = me.startY = null;
  return Ext.event.gesture.SingleTouch.prototype.reset.call(this);
}}, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, 'Swipe'], function(Swipe) {
  var gestures = Ext.manifest.gestures;
  Swipe.instance = new Swipe(gestures && gestures.swipe);
});
Ext.cmd.derive('Ext.event.gesture.EdgeSwipe', Ext.event.gesture.Swipe, {priority:500, handledEvents:['edgeswipe', 'edgeswipestart', 'edgeswipeend', 'edgeswipecancel'], config:{minDistance:60}, onTouchStart:function(e) {
  var me = this, ret = Ext.event.gesture.Swipe.prototype.onTouchStart.call(this, e), touch;
  if (ret !== false) {
    touch = e.changedTouches[0];
    me.direction = null;
    me.isHorizontal = true;
    me.isVertical = true;
    me.startX = touch.pageX;
    me.startY = touch.pageY;
  }
  return ret;
}, onTouchMove:function(e) {
  var me = this, touch = e.changedTouches[0], x = touch.pageX, y = touch.pageY, deltaX = x - me.startX, deltaY = y - me.startY, absDeltaY = Math.abs(y - me.startY), absDeltaX = Math.abs(x - me.startX), minDistance = me.getMinDistance(), maxOffset = me.getMaxOffset(), duration = e.time - me.startTime, elementWidth = Ext.Viewport && Ext.Element.getViewportWidth(), elementHeight = Ext.Viewport && Ext.Element.getViewportHeight(), direction, distance;
  if (me.isVertical && absDeltaX > maxOffset) {
    me.isVertical = false;
  }
  if (me.isHorizontal && absDeltaY > maxOffset) {
    me.isHorizontal = false;
  }
  if (me.isVertical && me.isHorizontal) {
    if (absDeltaY > absDeltaX) {
      me.isHorizontal = false;
    } else {
      me.isVertical = false;
    }
  }
  if (me.isHorizontal) {
    direction = deltaX < 0 ? 'left' : 'right';
    distance = deltaX;
  } else {
    if (me.isVertical) {
      direction = deltaY < 0 ? 'up' : 'down';
      distance = deltaY;
    }
  }
  direction = me.direction || (me.direction = direction);
  if (direction === 'up') {
    distance = deltaY * -1;
  } else {
    if (direction === 'left') {
      distance = deltaX * -1;
    }
  }
  me.distance = distance;
  if (!distance) {
    return me.cancel(e);
  }
  if (!me.isStarted) {
    if (direction === 'right' && me.startX > minDistance || direction === 'down' && me.startY > minDistance || direction === 'left' && elementWidth - me.startX > minDistance || direction === 'up' && elementHeight - me.startY > minDistance) {
      return me.cancel(e);
    }
    me.isStarted = true;
    me.startTime = e.time;
    me.fire('edgeswipestart', e, {touch:touch, direction:direction, distance:distance, duration:duration});
  } else {
    me.fire('edgeswipe', e, {touch:touch, direction:direction, distance:distance, duration:duration});
  }
}, onTouchEnd:function(e) {
  var me = this, duration;
  if (me.onTouchMove(e) !== false) {
    duration = e.time - me.startTime;
    me.fire('edgeswipeend', e, {touch:e.changedTouches[0], direction:me.direction, distance:me.distance, duration:duration});
  }
  return this.reset();
}, onCancel:function(e) {
  this.fire('edgeswipecancel', e, {touch:e.changedTouches[0]}, true);
}, reset:function() {
  var me = this;
  me.direction = me.isHorizontal = me.isVertical = me.startX = me.startY = me.startTime = me.distance = null;
  return Ext.event.gesture.Swipe.prototype.reset.call(this);
}}, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, 'EdgeSwipe'], function(EdgeSwipe) {
  var gestures = Ext.manifest.gestures;
  EdgeSwipe.instance = new EdgeSwipe(gestures && gestures.edgeSwipe);
});
Ext.cmd.derive('Ext.event.gesture.LongPress', Ext.event.gesture.SingleTouch, {priority:400, config:{moveDistance:8, minDuration:1000}, handledEvents:['longpress', 'taphold'], onTouchStart:function(e) {
  var me = this, ret = Ext.event.gesture.SingleTouch.prototype.onTouchStart.call(this, e);
  if (ret !== false) {
    me.startPoint = e.changedTouches[0].point;
    me.setLongPressTimer(e);
  }
  return ret;
}, setLongPressTimer:function(e) {
  var me = this;
  Ext.undefer(me.timer);
  me.timer = Ext.defer(me.fireLongPress, me.getMinDuration(), me, [e]);
}, onTouchMove:function(e) {
  var me = this, point = e.changedTouches[0].point, scale = Ext.Element.getViewportScale(), distance = Math.round(Math.abs(point.getDistanceTo(me.startPoint) * scale));
  if (distance >= me.getMoveDistance()) {
    return me.cancel(e);
  }
}, reset:function() {
  var me = this;
  me.timer = me.startPoint = Ext.undefer(me.timer);
  return Ext.event.gesture.SingleTouch.prototype.reset.call(this);
}, fireLongPress:function(e) {
  var me = this, info = {touch:e.changedTouches[0], duration:me.getMinDuration(), startDrag:me.startDrag};
  this.fire('taphold', e, info);
  this.fire('longpress', e, info);
  this.reset();
}, startDrag:function() {
  var dragRecognizer = Ext.event.gesture.Drag.instance, touchStartEvent = this.parentEvent;
  dragRecognizer.doDragStart(touchStartEvent, true);
  Ext.event.publisher.Gesture.instance.claimRecognizer(dragRecognizer, touchStartEvent);
}}, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, 'LongPress'], function(LongPress) {
  var gestures = Ext.manifest.gestures;
  LongPress.instance = new LongPress(gestures && gestures.longPress);
});
Ext.cmd.derive('Ext.event.gesture.MultiTouch', Ext.event.gesture.Recognizer, {requiredTouchesCount:2, isTracking:false, isMultiTouch:true, onTouchStart:function(e) {
  var me = this, requiredTouchesCount = me.requiredTouchesCount, touches = e.touches, touchesCount = touches.length;
  if (touchesCount === requiredTouchesCount) {
    me.isTracking = true;
  } else {
    if (touchesCount > requiredTouchesCount) {
      return me.cancel(e);
    }
  }
}, reset:function() {
  this.isTracking = false;
  return Ext.event.gesture.Recognizer.prototype.reset.call(this);
}}, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, 'MultiTouch'], 0);
Ext.cmd.derive('Ext.event.gesture.Pinch', Ext.event.gesture.MultiTouch, {priority:700, handledEvents:['pinchstart', 'pinch', 'pinchend', 'pinchcancel'], startDistance:0, lastTouches:null, onTouchMove:function(e) {
  var me = this, touches, firstPoint, secondPoint, distance;
  if (me.isTracking) {
    touches = e.touches;
    firstPoint = touches[0].point;
    secondPoint = touches[1].point;
    distance = firstPoint.getDistanceTo(secondPoint);
    if (distance === 0) {
      return;
    }
    if (!me.isStarted) {
      me.isStarted = true;
      me.startDistance = distance;
      me.fire('pinchstart', e, {touches:touches, distance:distance, scale:1});
    } else {
      me.fire('pinch', e, {touches:touches, distance:distance, scale:distance / me.startDistance});
    }
  }
}, onTouchEnd:function(e) {
  if (this.isStarted) {
    this.fire('pinchend', e);
  }
  return Ext.event.gesture.MultiTouch.prototype.onTouchEnd.call(this, e);
}, onCancel:function(e) {
  this.fire('pinchcancel', e, null, true);
}, reset:function() {
  this.lastTouches = null;
  this.startDistance = 0;
  return Ext.event.gesture.MultiTouch.prototype.reset.call(this);
}}, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, 'Pinch'], function(Pinch) {
  var gestures = Ext.manifest.gestures;
  Pinch.instance = new Pinch(gestures && gestures.pinch);
});
Ext.cmd.derive('Ext.event.gesture.Rotate', Ext.event.gesture.MultiTouch, {priority:800, handledEvents:['rotatestart', 'rotate', 'rotateend', 'rotatecancel'], startAngle:0, lastTouches:null, lastAngle:null, onTouchMove:function(e) {
  var me = this, touches, lastAngle, firstPoint, secondPoint, angle, nextAngle, previousAngle, diff;
  if (me.isTracking) {
    touches = e.touches;
    lastAngle = me.lastAngle;
    firstPoint = touches[0].point;
    secondPoint = touches[1].point;
    angle = firstPoint.getAngleTo(secondPoint);
    if (lastAngle !== null) {
      diff = Math.abs(lastAngle - angle);
      nextAngle = angle + 360;
      previousAngle = angle - 360;
      if (Math.abs(nextAngle - lastAngle) < diff) {
        angle = nextAngle;
      } else {
        if (Math.abs(previousAngle - lastAngle) < diff) {
          angle = previousAngle;
        }
      }
    }
    me.lastAngle = angle;
    if (!me.isStarted) {
      me.isStarted = true;
      me.startAngle = angle;
      me.fire('rotatestart', e, {touches:touches, angle:angle, rotation:0});
    } else {
      me.fire('rotate', e, {touches:touches, angle:angle, rotation:angle - me.startAngle});
    }
    me.lastTouches = Ext.Array.clone(touches);
  }
}, onTouchEnd:function(e) {
  if (this.isStarted) {
    this.fire('rotateend', e);
  }
  return Ext.event.gesture.MultiTouch.prototype.onTouchEnd.call(this, e);
}, onCancel:function(e) {
  this.fire('rotatecancel', e, null, true);
}, reset:function() {
  var me = this;
  me.lastTouches = me.lastAngle = me.startAngle = null;
  return Ext.event.gesture.MultiTouch.prototype.reset.call(this);
}}, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, 'Rotate'], function(Rotate) {
  var gestures = Ext.manifest.gestures;
  Rotate.instance = new Rotate(gestures && gestures.rotate);
});
Ext.cmd.derive('Ext.event.gesture.Tap', Ext.event.gesture.SingleTouch, {priority:200, handledEvents:['tap', 'tapcancel'], config:{moveDistance:8}, onTouchStart:function(e) {
  var me = this, ret = Ext.event.gesture.SingleTouch.prototype.onTouchStart.call(this, e);
  if (ret !== false) {
    me.isStarted = true;
    me.startPoint = e.changedTouches[0].point;
  }
  return ret;
}, onTouchMove:function(e) {
  var me = this, point = e.changedTouches[0].point, scale = Ext.Element.getViewportScale(), distance = Math.round(Math.abs(point.getDistanceTo(me.startPoint) * scale));
  if (distance >= me.getMoveDistance()) {
    return me.cancel(e);
  }
}, onTouchEnd:function(e) {
  this.fire('tap', e, {touch:e.changedTouches[0]});
  return Ext.event.gesture.SingleTouch.prototype.onTouchEnd.call(this, e);
}, onCancel:function(e) {
  this.fire('tapcancel', e, {touch:e.changedTouches[0]}, true);
}, reset:function() {
  this.startPoint = null;
  return Ext.event.gesture.SingleTouch.prototype.reset.call(this);
}}, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, 'Tap'], function(Tap) {
  var gestures = Ext.manifest.gestures;
  Tap.instance = new Tap(gestures && gestures.tap);
});
Ext.cmd.derive('Ext.event.publisher.Focus', Ext.event.publisher.Dom, {type:'focus', handledEvents:['focusenter', 'focusleave', 'focusmove'], handledDomEvents:['focusin', 'focusout'], publishDelegatedDomEvent:function(e) {
  var me = this, relatedTarget = e.relatedTarget;
  if (e.type === 'focusout') {
    if (relatedTarget == null) {
      me.processFocusIn(e, e.target, document.body);
    }
  } else {
    if (relatedTarget == null || !relatedTarget.tagName) {
      relatedTarget = document.body;
    }
    me.processFocusIn(e, relatedTarget, e.target);
  }
}, processFocusIn:function(e, fromElement, toElement) {
  var me = this, commonAncestor, node, targets = [], focusFly = me.focusFly, backwards, event, focusEnterEvent;
  if (fromElement && focusFly.attach(fromElement).isFocusSuspended() || toElement && focusFly.attach(toElement).isFocusSuspended()) {
    return;
  }
  if (toElement.compareDocumentPosition) {
    backwards = !!(toElement.compareDocumentPosition(fromElement) & 4);
  }
  for (node = fromElement, commonAncestor = Ext.dom.Element.getCommonAncestor(toElement, fromElement, true); node && node !== commonAncestor; node = node.parentNode) {
    targets.push(node);
  }
  if (targets.length) {
    event = me.createSyntheticEvent('focusleave', e, fromElement, toElement, fromElement, toElement, backwards);
    me.publish(event, targets);
    if (event.stopped) {
      return;
    }
  }
  targets.length = 0;
  for (node = toElement; node && node !== commonAncestor; node = node.parentNode) {
    targets.push(node);
  }
  focusEnterEvent = me.createSyntheticEvent('focusenter', e, toElement, fromElement, fromElement, toElement, backwards);
  if (targets.length) {
    me.publish(focusEnterEvent, targets);
    if (focusEnterEvent.stopped) {
      return;
    }
  }
  targets = me.getPropagatingTargets(commonAncestor);
  if (targets.length) {
    event = me.createSyntheticEvent('focusmove', e, toElement, fromElement, fromElement, toElement, backwards);
    me.publish(event, targets);
    if (event.stopped) {
      return;
    }
  }
  if (Ext.GlobalEvents.hasListeners.focus) {
    Ext.GlobalEvents.fireEvent('focus', {event:focusEnterEvent, toElement:toElement, fromElement:fromElement, backwards:backwards});
  }
}, createSyntheticEvent:function(eventName, browserEvent, target, relatedTarget, fromElement, toElement, backwards) {
  var event = new Ext.event.Event(browserEvent);
  event.type = eventName;
  event.relatedTarget = relatedTarget;
  event.target = target;
  event.fromElement = fromElement;
  event.toElement = toElement;
  event.backwards = backwards;
  return event;
}}, 0, 0, 0, 0, 0, 0, [Ext.event.publisher, 'Focus'], function(Focus) {
  var focusTimeout;
  Focus.prototype.focusFly = new Ext.dom.Fly;
  Focus.instance = new Focus;
  if (!Ext.supports.FocusinFocusoutEvents) {
    this.override({handledDomEvents:['focus', 'blur'], publishDelegatedDomEvent:function(e) {
      var me = this, targetIsElement;
      me.callSuper([e]);
      targetIsElement = e.target !== window && e.target !== document;
      if (e.type === 'blur') {
        if (!targetIsElement) {
          if (e.explicitOriginalTarget === Focus.previousActiveElement) {
            if (e.target === window) {
              Ext.undefer(focusTimeout);
              focusTimeout = 0;
              me.processFocusIn(e, Focus.previousActiveElement, document.body);
              Focus.previousActiveElement = null;
            }
          }
        } else {
          focusTimeout = Ext.defer(function() {
            focusTimeout = 0;
            me.processFocusIn(e, e.target, document.body);
            Focus.previousActiveElement = null;
          }, 1);
          if (targetIsElement && Ext.cache[e.target.id]) {
            Ext.cache[e.target.id].focusinTimeout = focusTimeout;
          }
        }
        Focus.previousActiveElement = targetIsElement ? e.target : null;
      } else {
        Ext.undefer(focusTimeout);
        focusTimeout = 0;
        me.processFocusIn(e, Focus.previousActiveElement || document.body, targetIsElement ? e.target : document.body);
      }
    }});
    Ext.define(null, {override:'Ext.dom.Element', destroy:function() {
      if (this.focusinTimeout) {
        Ext.undefer(this.focusinTimeout);
        this.focusinTimeout = null;
      }
      this.callParent();
    }});
  }
});
Ext.cmd.derive('Ext.fx.State', Ext.Base, {isAnimatable:{'background-color':true, 'background-image':true, 'background-position':true, 'border-bottom-color':true, 'border-bottom-width':true, 'border-color':true, 'border-left-color':true, 'border-left-width':true, 'border-right-color':true, 'border-right-width':true, 'border-spacing':true, 'border-top-color':true, 'border-top-width':true, 'border-width':true, 'bottom':true, 'color':true, 'crop':true, 'font-size':true, 'font-weight':true, 'height':true, 
'left':true, 'letter-spacing':true, 'line-height':true, 'margin-bottom':true, 'margin-left':true, 'margin-right':true, 'margin-top':true, 'max-height':true, 'max-width':true, 'min-height':true, 'min-width':true, 'opacity':true, 'outline-color':true, 'outline-offset':true, 'outline-width':true, 'padding-bottom':true, 'padding-left':true, 'padding-right':true, 'padding-top':true, 'right':true, 'text-indent':true, 'text-shadow':true, 'top':true, 'vertical-align':true, 'visibility':true, 'width':true, 
'word-spacing':true, 'z-index':true, 'zoom':true, 'transform':true}, constructor:function(data) {
  this.data = {};
  this.set(data);
}, setConfig:function(data) {
  this.set(data);
  return this;
}, setRaw:function(data) {
  this.data = data;
  return this;
}, clear:function() {
  return this.setRaw({});
}, setTransform:function(name, value) {
  var data = this.data, isArray = Ext.isArray(value), transform = data.transform, ln, key;
  if (!transform) {
    transform = data.transform = {translateX:0, translateY:0, translateZ:0, scaleX:1, scaleY:1, scaleZ:1, rotate:0, rotateX:0, rotateY:0, rotateZ:0, skewX:0, skewY:0};
  }
  if (typeof name == 'string') {
    switch(name) {
      case 'translate':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.translateX = value[0];
          if (ln == 1) {
            break;
          }
          transform.translateY = value[1];
          if (ln == 2) {
            break;
          }
          transform.translateZ = value[2];
        } else {
          transform.translateX = value;
        }
        break;
      case 'rotate':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.rotateX = value[0];
          if (ln == 1) {
            break;
          }
          transform.rotateY = value[1];
          if (ln == 2) {
            break;
          }
          transform.rotateZ = value[2];
        } else {
          transform.rotate = value;
        }
        break;
      case 'scale':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.scaleX = value[0];
          if (ln == 1) {
            break;
          }
          transform.scaleY = value[1];
          if (ln == 2) {
            break;
          }
          transform.scaleZ = value[2];
        } else {
          transform.scaleX = value;
          transform.scaleY = value;
        }
        break;
      case 'skew':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.skewX = value[0];
          if (ln == 1) {
            break;
          }
          transform.skewY = value[1];
        } else {
          transform.skewX = value;
        }
        break;
      default:
        transform[name] = value;
    }
  } else {
    for (key in name) {
      if (name.hasOwnProperty(key)) {
        value = name[key];
        this.setTransform(key, value);
      }
    }
  }
}, set:function(name, value) {
  var data = this.data, key;
  if (typeof name != 'string') {
    for (key in name) {
      value = name[key];
      if (key === 'transform') {
        this.setTransform(value);
      } else {
        data[key] = value;
      }
    }
  } else {
    if (name === 'transform') {
      this.setTransform(value);
    } else {
      data[name] = value;
    }
  }
  return this;
}, unset:function(name) {
  var data = this.data;
  if (data.hasOwnProperty(name)) {
    delete data[name];
  }
  return this;
}, getData:function() {
  return this.data;
}}, 1, 0, 0, 0, 0, 0, [Ext.fx, 'State'], 0);
Ext.cmd.derive('Ext.fx.animation.Abstract', Ext.Evented, {factoryConfig:{type:'animation'}, isAnimation:true, config:{name:'', element:null, before:null, from:{}, to:{}, after:null, states:{}, duration:300, easing:'linear', iteration:1, direction:'normal', delay:0, onBeforeStart:null, callback:null, onEnd:null, onBeforeEnd:null, scope:null, reverse:null, preserveEndState:false, replacePrevious:true}, STATE_FROM:'0%', STATE_TO:'100%', DIRECTION_UP:'up', DIRECTION_TOP:'top', DIRECTION_DOWN:'down', 
DIRECTION_BOTTOM:'bottom', DIRECTION_LEFT:'left', DIRECTION_RIGHT:'right', stateNameRegex:/^(?:[\d\.]+)%$/, constructor:function() {
  this.states = {};
  Ext.Evented.prototype.constructor.apply(this, arguments);
  return this;
}, applyElement:function(element) {
  return Ext.get(element);
}, applyBefore:function(before, current) {
  if (before) {
    return Ext.factory(before, Ext.fx.State, current);
  }
}, applyAfter:function(after, current) {
  if (after) {
    return Ext.factory(after, Ext.fx.State, current);
  }
}, setFrom:function(from) {
  return this.setState(this.STATE_FROM, from);
}, setTo:function(to) {
  return this.setState(this.STATE_TO, to);
}, getFrom:function() {
  return this.getState(this.STATE_FROM);
}, getTo:function() {
  return this.getState(this.STATE_TO);
}, setStates:function(states) {
  var validNameRegex = this.stateNameRegex, name;
  for (name in states) {
    if (validNameRegex.test(name)) {
      this.setState(name, states[name]);
    }
  }
  return this;
}, getStates:function() {
  return this.states;
}, updateCallback:function(callback) {
  if (callback) {
    this.setOnEnd(callback);
  }
}, end:function() {
  this.stop();
}, stop:function() {
  this.fireEvent('stop', this);
}, destroy:function() {
  this.destroying = true;
  this.stop();
  Ext.Evented.prototype.destroy.call(this);
  this.destroying = false;
  this.destroyed = true;
}, setState:function(name, state) {
  var states = this.getStates(), stateInstance;
  stateInstance = Ext.factory(state, Ext.fx.State, states[name]);
  if (stateInstance) {
    states[name] = stateInstance;
  }
  return this;
}, getState:function(name) {
  return this.getStates()[name];
}, getData:function() {
  var me = this, states = me.getStates(), statesData = {}, before = me.getBefore(), after = me.getAfter(), from = states[me.STATE_FROM], to = states[me.STATE_TO], fromData = from.getData(), toData = to.getData(), data, name, state;
  for (name in states) {
    if (states.hasOwnProperty(name)) {
      state = states[name];
      data = state.getData();
      statesData[name] = data;
    }
  }
  return {before:before ? before.getData() : {}, after:after ? after.getData() : {}, states:statesData, from:fromData, to:toData, duration:me.getDuration(), iteration:me.getIteration(), direction:me.getDirection(), easing:me.getEasing(), delay:me.getDelay(), onEnd:me.getOnEnd(), onBeforeEnd:me.getOnBeforeEnd(), onBeforeStart:me.getOnBeforeStart(), scope:me.getScope(), preserveEndState:me.getPreserveEndState(), replacePrevious:me.getReplacePrevious()};
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.fx.animation, 'Abstract'], 0);
Ext.cmd.derive('Ext.fx.animation.Slide', Ext.fx.animation.Abstract, {alternateClassName:'Ext.fx.animation.SlideIn', config:{direction:'left', out:false, offset:0, easing:'auto', containerBox:'auto', elementBox:'auto', isElementBoxFit:true, useCssTransform:true}, reverseDirectionMap:{up:'down', top:'down', down:'up', bottom:'up', left:'right', right:'left'}, applyEasing:function(easing) {
  if (easing === 'auto') {
    return 'ease-' + (this.getOut() ? 'in' : 'out');
  }
  return easing;
}, getContainerBox:function() {
  var box = this._containerBox;
  if (box === 'auto') {
    box = this.getElement().getParent().getBox();
  }
  return box;
}, getElementBox:function() {
  var box = this._elementBox;
  if (this.getIsElementBoxFit()) {
    return this.getContainerBox();
  }
  if (box === 'auto') {
    box = this.getElement().getBox();
  }
  return box;
}, getData:function() {
  var elementBox = this.getElementBox(), containerBox = this.getContainerBox(), box = elementBox ? elementBox : containerBox, from = this.getFrom(), to = this.getTo(), out = this.getOut(), offset = this.getOffset(), direction = this.getDirection(), useCssTransform = this.getUseCssTransform(), reverse = this.getReverse(), translateX = 0, translateY = 0, offsetPct, fromX, fromY, toX, toY;
  if (typeof offset === 'string') {
    offsetPct = true;
    offset = parseFloat(offset);
  }
  if (reverse) {
    direction = this.reverseDirectionMap[direction];
  }
  switch(direction) {
    case this.DIRECTION_UP:
    case this.DIRECTION_TOP:
      if (offsetPct) {
        offset = box.height * offset / 100;
      }
      if (out) {
        translateY = containerBox.top - box.top - box.height - offset;
      } else {
        translateY = containerBox.bottom - box.bottom + box.height + offset;
      }
      break;
    case this.DIRECTION_DOWN:
    case this.DIRECTION_BOTTOM:
      if (offsetPct) {
        offset = box.height * offset / 100;
      }
      if (out) {
        translateY = containerBox.bottom - box.bottom + box.height + offset;
      } else {
        translateY = containerBox.top - box.height - box.top - offset;
      }
      break;
    case this.DIRECTION_RIGHT:
      if (offsetPct) {
        offset = box.width * offset / 100;
      }
      if (out) {
        translateX = containerBox.right - box.right + box.width + offset;
      } else {
        translateX = containerBox.left - box.left - box.width - offset;
      }
      break;
    case this.DIRECTION_LEFT:
      if (offsetPct) {
        offset = box.width * offset / 100;
      }
      if (out) {
        translateX = containerBox.left - box.left - box.width - offset;
      } else {
        translateX = containerBox.right - box.right + box.width + offset;
      }
      break;
  }
  fromX = out ? 0 : translateX;
  fromY = out ? 0 : translateY;
  if (useCssTransform) {
    from.setTransform({translateX:fromX, translateY:fromY});
  } else {
    from.set('left', fromX);
    from.set('top', fromY);
  }
  toX = out ? translateX : 0;
  toY = out ? translateY : 0;
  if (useCssTransform) {
    to.setTransform({translateX:toX, translateY:toY});
  } else {
    to.set('left', toX);
    to.set('top', toY);
  }
  return Ext.fx.animation.Abstract.prototype.getData.apply(this, arguments);
}}, 0, 0, 0, 0, ['animation.slide', 'animation.slideIn'], 0, [Ext.fx.animation, 'Slide', Ext.fx.animation, 'SlideIn'], 0);
Ext.cmd.derive('Ext.fx.animation.SlideOut', Ext.fx.animation.Slide, {config:{out:true}}, 0, 0, 0, 0, ['animation.slideOut'], 0, [Ext.fx.animation, 'SlideOut'], 0);
Ext.cmd.derive('Ext.fx.animation.Fade', Ext.fx.animation.Abstract, {alternateClassName:'Ext.fx.animation.FadeIn', config:{out:false, before:{display:null, opacity:0}, after:{opacity:null}, reverse:null}, updateOut:function(newOut) {
  var to = this.getTo(), from = this.getFrom();
  if (newOut) {
    from.set('opacity', 1);
    to.set('opacity', 0);
  } else {
    from.set('opacity', 0);
    to.set('opacity', 1);
  }
}}, 0, 0, 0, 0, ['animation.fade', 'animation.fadeIn'], 0, [Ext.fx.animation, 'Fade', Ext.fx.animation, 'FadeIn'], 0);
Ext.cmd.derive('Ext.fx.animation.FadeOut', Ext.fx.animation.Fade, {config:{out:true, before:{}}}, 0, 0, 0, 0, ['animation.fadeOut'], 0, [Ext.fx.animation, 'FadeOut'], 0);
Ext.cmd.derive('Ext.fx.animation.Flip', Ext.fx.animation.Abstract, {config:{easing:'ease-in', direction:'right', half:false, out:null}, getData:function() {
  var me = this, from = me.getFrom(), to = me.getTo(), direction = me.getDirection(), out = me.getOut(), half = me.getHalf(), rotate = half ? 90 : 180, fromScale = 1, toScale = 1, fromRotateX = 0, fromRotateY = 0, toRotateX = 0, toRotateY = 0;
  if (out) {
    toScale = 0.8;
  } else {
    fromScale = 0.8;
  }
  switch(direction) {
    case this.DIRECTION_UP:
    case this.DIRECTION_TOP:
      if (out) {
        toRotateX = rotate;
      } else {
        fromRotateX = -rotate;
      }
      break;
    case this.DIRECTION_DOWN:
    case this.DIRECTION_BOTTOM:
      if (out) {
        toRotateX = -rotate;
      } else {
        fromRotateX = rotate;
      }
      break;
    case this.DIRECTION_RIGHT:
      if (out) {
        toRotateY = rotate;
      } else {
        fromRotateY = -rotate;
      }
      break;
    case this.DIRECTION_LEFT:
      if (out) {
        toRotateY = -rotate;
      } else {
        fromRotateY = rotate;
      }
      break;
  }
  from.setTransform({rotateX:fromRotateX, rotateY:fromRotateY, scale:fromScale});
  to.setTransform({rotateX:toRotateX, rotateY:toRotateY, scale:toScale});
  return Ext.fx.animation.Abstract.prototype.getData.call(this);
}}, 0, 0, 0, 0, ['animation.flip'], 0, [Ext.fx.animation, 'Flip'], 0);
Ext.cmd.derive('Ext.fx.animation.Pop', Ext.fx.animation.Abstract, {alternateClassName:'Ext.fx.animation.PopIn', config:{out:false, before:{display:null, opacity:0}, after:{opacity:null}}, getData:function() {
  var to = this.getTo(), from = this.getFrom(), out = this.getOut();
  if (out) {
    from.set('opacity', 1);
    from.setTransform({scale:1});
    to.set('opacity', 0);
    to.setTransform({scale:0});
  } else {
    from.set('opacity', 0);
    from.setTransform({scale:0});
    to.set('opacity', 1);
    to.setTransform({scale:1});
  }
  return Ext.fx.animation.Abstract.prototype.getData.apply(this, arguments);
}}, 0, 0, 0, 0, ['animation.pop', 'animation.popIn'], 0, [Ext.fx.animation, 'Pop', Ext.fx.animation, 'PopIn'], 0);
Ext.cmd.derive('Ext.fx.animation.PopOut', Ext.fx.animation.Pop, {config:{out:true, before:{}}}, 0, 0, 0, 0, ['animation.popOut'], 0, [Ext.fx.animation, 'PopOut'], 0);
Ext.cmd.derive('Ext.fx.Animation', Ext.Base, {constructor:function(config) {
  var defaultClass = Ext.fx.animation.Abstract, type;
  if (typeof config == 'string') {
    type = config;
    config = {};
  } else {
    if (config && config.type) {
      type = config.type;
    }
  }
  if (type) {
    defaultClass = Ext.ClassManager.getByAlias('animation.' + type);
  }
  return Ext.factory(config, defaultClass);
}}, 1, 0, 0, 0, 0, 0, [Ext.fx, 'Animation'], 0);
Ext.cmd.derive('Ext.fx.runner.Css', Ext.Evented, {prefixedProperties:{'transform':true, 'transform-origin':true, 'perspective':true, 'transform-style':true, 'transition':true, 'transition-property':true, 'transition-duration':true, 'transition-timing-function':true, 'transition-delay':true, 'animation':true, 'animation-name':true, 'animation-duration':true, 'animation-iteration-count':true, 'animation-direction':true, 'animation-timing-function':true, 'animation-delay':true}, lengthProperties:{'top':true, 
'right':true, 'bottom':true, 'left':true, 'width':true, 'height':true, 'max-height':true, 'max-width':true, 'min-height':true, 'min-width':true, 'margin-bottom':true, 'margin-left':true, 'margin-right':true, 'margin-top':true, 'padding-bottom':true, 'padding-left':true, 'padding-right':true, 'padding-top':true, 'border-bottom-width':true, 'border-left-width':true, 'border-right-width':true, 'border-spacing':true, 'border-top-width':true, 'border-width':true, 'outline-width':true, 'letter-spacing':true, 
'line-height':true, 'text-indent':true, 'word-spacing':true, 'font-size':true, 'translate':true, 'translateX':true, 'translateY':true, 'translateZ':true, 'translate3d':true, 'x':true, 'y':true}, durationProperties:{'transition-duration':true, 'transition-delay':true, 'animation-duration':true, 'animation-delay':true}, angleProperties:{rotate:true, rotateX:true, rotateY:true, rotateZ:true, skew:true, skewX:true, skewY:true}, DEFAULT_UNIT_LENGTH:'px', DEFAULT_UNIT_ANGLE:'deg', DEFAULT_UNIT_DURATION:'ms', 
customProperties:{x:true, y:true}, formattedNameCache:{'x':'left', 'y':'top'}, transformMethods3d:['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY', 'scaleX', 'scaleY', 'scaleZ'], transformMethodsNo3d:['translateX', 'translateY', 'rotate', 'skewX', 'skewY', 'scaleX', 'scaleY'], constructor:function() {
  var me = this;
  me.transformMethods = Ext.feature.has.Css3dTransforms ? me.transformMethods3d : me.transformMethodsNo3d;
  me.vendorPrefix = Ext.browser.getStyleDashPrefix();
  me.ruleStylesCache = {};
  Ext.Evented.prototype.constructor.call(this);
}, getStyleSheet:function() {
  var styleSheet = this.styleSheet, styleElement, styleSheets;
  if (!styleSheet) {
    styleElement = document.createElement('style');
    styleElement.type = 'text/css';
    (document.head || document.getElementsByTagName('head')[0]).appendChild(styleElement);
    styleSheets = document.styleSheets;
    this.styleSheet = styleSheet = styleSheets[styleSheets.length - 1];
  }
  return styleSheet;
}, applyRules:function(selectors) {
  var styleSheet = this.getStyleSheet(), ruleStylesCache = this.ruleStylesCache, rules = styleSheet.cssRules, selector, properties, ruleStyle, ruleStyleCache, rulesLength, name, value;
  for (selector in selectors) {
    properties = selectors[selector];
    ruleStyle = ruleStylesCache[selector];
    if (ruleStyle === undefined) {
      rulesLength = rules.length;
      styleSheet.insertRule(selector + '{}', rulesLength);
      ruleStyle = ruleStylesCache[selector] = rules.item(rulesLength).style;
    }
    ruleStyleCache = ruleStyle.$cache;
    if (!ruleStyleCache) {
      ruleStyleCache = ruleStyle.$cache = {};
    }
    for (name in properties) {
      value = this.formatValue(properties[name], name);
      name = this.formatName(name);
      if (ruleStyleCache[name] !== value) {
        ruleStyleCache[name] = value;
        if (value === null) {
          ruleStyle.removeProperty(name);
        } else {
          ruleStyle.setProperty(name, value);
        }
      }
    }
  }
  return this;
}, applyStyles:function(styles) {
  var id, element, elementStyle, properties, name, value;
  for (id in styles) {
    if (styles.hasOwnProperty(id)) {
      this.activeElement = element = document.getElementById(id);
      if (!element) {
        continue;
      }
      elementStyle = element.style;
      properties = styles[id];
      for (name in properties) {
        if (properties.hasOwnProperty(name)) {
          value = this.formatValue(properties[name], name);
          name = this.formatName(name);
          if (value === null) {
            elementStyle.removeProperty(name);
          } else {
            elementStyle.setProperty(name, value);
          }
        }
      }
    }
  }
  this.activeElement = null;
  return this;
}, formatName:function(name) {
  var cache = this.formattedNameCache, formattedName = cache[name];
  if (!formattedName) {
    if ((Ext.os.is.Tizen || !Ext.feature.has.CssTransformNoPrefix) && this.prefixedProperties[name]) {
      formattedName = this.vendorPrefix + name;
    } else {
      formattedName = name;
    }
    cache[name] = formattedName;
  }
  return formattedName;
}, formatValue:function(value, name) {
  var type = typeof value, defaultLengthUnit = this.DEFAULT_UNIT_LENGTH, isCustom = this.customProperties[name], transformMethods, method, i, ln, transformValues, values;
  if (value === null) {
    return '';
  }
  if (type === 'string') {
    if (this.lengthProperties[name]) {
      if (!Ext.dom.Element.hasUnit(value)) {
        value = value + defaultLengthUnit;
        if (isCustom) {
          value = this.getCustomValue(value, name);
        }
      }
    }
    return value;
  } else {
    if (type === 'number') {
      if (value === 0) {
        return '0';
      }
      if (this.lengthProperties[name]) {
        value = value + defaultLengthUnit;
        if (isCustom) {
          value = this.getCustomValue(value, name);
        }
        return value;
      }
      if (this.angleProperties[name]) {
        return value + this.DEFAULT_UNIT_ANGLE;
      }
      if (this.durationProperties[name]) {
        return value + this.DEFAULT_UNIT_DURATION;
      }
    } else {
      if (name === 'transform') {
        transformMethods = this.transformMethods;
        transformValues = [];
        for (i = 0, ln = transformMethods.length; i < ln; i++) {
          method = transformMethods[i];
          transformValues.push(method + '(' + this.formatValue(value[method], method) + ')');
        }
        return transformValues.join(' ');
      } else {
        if (Ext.isArray(value)) {
          values = [];
          for (i = 0, ln = value.length; i < ln; i++) {
            values.push(this.formatValue(value[i], name));
          }
          return values.length > 0 ? values.join(', ') : 'none';
        }
      }
    }
  }
  return value;
}, getCustomValue:function(value, name) {
  var el = Ext.fly(this.activeElement);
  if (name === 'x') {
    value = el.translateXY(parseInt(value, 10)).x;
  } else {
    if (name === 'y') {
      value = el.translateXY(null, parseInt(value, 10)).y;
    }
  }
  return value + this.DEFAULT_UNIT_LENGTH;
}}, 1, 0, 0, 0, 0, 0, [Ext.fx.runner, 'Css'], 0);
Ext.cmd.derive('Ext.fx.runner.CssTransition', Ext.fx.runner.Css, {alternateClassName:'Ext.Animator', singleton:true, listenersAttached:false, constructor:function() {
  this.runningAnimationsData = {};
  this.transitionQueue = {toData:{}, transitionData:{}};
  return this.callParent(arguments);
}, attachListeners:function() {
  this.listenersAttached = true;
  Ext.getWin().on('transitionend', 'onTransitionEnd', this);
}, onTransitionEnd:function(e) {
  var target = e.target, id = target.id;
  if (id && this.runningAnimationsData.hasOwnProperty(id)) {
    this.refreshRunningAnimationsData(Ext.get(target), [e.browserEvent.propertyName]);
  }
}, getElementId:function(element) {
  return element.getId ? element.getId() : element.id;
}, onAnimationEnd:function(element, data, animation, isInterrupted, isReplaced) {
  var id = this.getElementId(element), runningData = this.runningAnimationsData[id], endRules = {}, endData = {}, runningNameMap, toPropertyNames, i, ln, name;
  animation.un('stop', 'onAnimationStop', this);
  if (runningData) {
    runningNameMap = runningData.nameMap;
  }
  endRules[id] = endData;
  if (data.onBeforeEnd) {
    data.onBeforeEnd.call(data.scope || this, element, isInterrupted);
  }
  animation.fireEvent('animationbeforeend', animation, element, isInterrupted);
  this.fireEvent('animationbeforeend', this, animation, element, isInterrupted);
  if (isReplaced || !isInterrupted && !data.preserveEndState) {
    toPropertyNames = data.toPropertyNames;
    for (i = 0, ln = toPropertyNames.length; i < ln; i++) {
      name = toPropertyNames[i];
      if (runningNameMap && !runningNameMap.hasOwnProperty(name)) {
        endData[name] = null;
      }
    }
  }
  if (data.after) {
    Ext.merge(endData, data.after);
  }
  this.applyStyles(endRules);
  if (data.onEnd) {
    data.onEnd.call(data.scope || this, element, isInterrupted);
  }
  animation.fireEvent('animationend', animation, element, isInterrupted);
  this.fireEvent('animationend', this, animation, element, isInterrupted);
  Ext.AnimationQueue.stop(Ext.emptyFn, animation);
}, onAllAnimationsEnd:function(element) {
  var id = this.getElementId(element), transitionQueue = this.transitionQueue, endRules = {};
  delete this.runningAnimationsData[id];
  endRules[id] = {'transition-property':null, 'transition-duration':null, 'transition-timing-function':null, 'transition-delay':null};
  delete transitionQueue.toData[id];
  delete transitionQueue.transitionData[id];
  this.applyStyles(endRules);
  this.fireEvent('animationallend', this, element);
}, hasRunningAnimations:function(element) {
  var id = this.getElementId(element), runningAnimationsData = this.runningAnimationsData;
  return runningAnimationsData.hasOwnProperty(id) && runningAnimationsData[id].sessions.length > 0;
}, refreshRunningAnimationsData:function(element, propertyNames, interrupt, replace) {
  var id = this.getElementId(element), runningAnimationsData = this.runningAnimationsData, runningData = runningAnimationsData[id];
  if (!runningData) {
    return;
  }
  var nameMap = runningData.nameMap, nameList = runningData.nameList, sessions = runningData.sessions, ln, j, subLn, name, i, session, map, list, hasCompletedSession = false;
  interrupt = Boolean(interrupt);
  replace = Boolean(replace);
  if (!sessions) {
    return this;
  }
  ln = sessions.length;
  if (ln === 0) {
    return this;
  }
  if (replace) {
    runningData.nameMap = {};
    nameList.length = 0;
    for (i = 0; i < ln; i++) {
      session = sessions[i];
      this.onAnimationEnd(element, session.data, session.animation, interrupt, replace);
    }
    sessions.length = 0;
  } else {
    for (i = 0; i < ln; i++) {
      session = sessions[i];
      map = session.map;
      list = session.list;
      for (j = 0, subLn = propertyNames.length; j < subLn; j++) {
        name = propertyNames[j];
        if (map[name]) {
          delete map[name];
          Ext.Array.remove(list, name);
          session.length--;
          if (--nameMap[name] == 0) {
            delete nameMap[name];
            Ext.Array.remove(nameList, name);
          }
        }
      }
      if (session.length == 0) {
        sessions.splice(i, 1);
        i--;
        ln--;
        hasCompletedSession = true;
        this.onAnimationEnd(element, session.data, session.animation, interrupt);
      }
    }
  }
  if (!replace && !interrupt && sessions.length == 0 && hasCompletedSession) {
    this.onAllAnimationsEnd(element);
  }
}, getRunningData:function(id) {
  var runningAnimationsData = this.runningAnimationsData;
  if (!runningAnimationsData.hasOwnProperty(id)) {
    runningAnimationsData[id] = {nameMap:{}, nameList:[], sessions:[]};
  }
  return runningAnimationsData[id];
}, getTestElement:function() {
  var me = this, testElement = me.testElement, iframe = me.iframe, iframeDocument, iframeStyle;
  if (testElement) {
    if (testElement.ownerDocument.defaultView !== iframe.contentWindow) {
      iframeDocument = iframe.contentDocument;
      iframeDocument.body.appendChild(testElement);
      me.testElementComputedStyle = iframeDocument.defaultView.getComputedStyle(testElement);
    }
  } else {
    iframe = me.iframe = document.createElement('iframe');
    iframe.setAttribute('tabIndex', -1);
    iframeStyle = iframe.style;
    iframeStyle.setProperty('visibility', 'hidden', 'important');
    iframeStyle.setProperty('width', '0px', 'important');
    iframeStyle.setProperty('height', '0px', 'important');
    iframeStyle.setProperty('position', 'absolute', 'important');
    iframeStyle.setProperty('border', '0px', 'important');
    iframeStyle.setProperty('zIndex', '-1000', 'important');
    document.body.appendChild(iframe);
    iframeDocument = iframe.contentDocument;
    iframeDocument.open();
    iframeDocument.writeln('\x3c/body\x3e');
    iframeDocument.close();
    me.testElement = testElement = iframeDocument.createElement('div');
    testElement.style.setProperty('position', 'absolute', 'important');
    iframeDocument.body.appendChild(testElement);
    me.testElementComputedStyle = iframeDocument.defaultView.getComputedStyle(testElement);
  }
  return testElement;
}, getCssStyleValue:function(name, value) {
  var testElement = this.getTestElement(), computedStyle = this.testElementComputedStyle, style = testElement.style;
  style.setProperty(name, value);
  if (Ext.browser.is.Firefox) {
    testElement.offsetHeight;
  }
  value = computedStyle.getPropertyValue(name);
  style.removeProperty(name);
  return value;
}, run:function(animations) {
  var me = this, ret = [], isLengthPropertyMap = me.lengthProperties, fromData = {}, toData = me.transitionQueue.toData, data = {}, transitionData = me.transitionQueue.transitionData, element, elementId, from, to, before, fromPropertyNames, toPropertyNames, doApplyTo, message, runningData, elementData, i, j, ln, animation, propertiesLength, sessionNameMap, computedStyle, formattedName, name, toFormattedValue, computedValue, fromFormattedValue, isLengthProperty, runningNameMap, runningNameList, runningSessions, 
  runningSession, messageTimerFn, onBeforeStart;
  if (!me.listenersAttached) {
    me.attachListeners();
  }
  animations = Ext.Array.from(animations);
  for (i = 0, ln = animations.length; i < ln; i++) {
    animation = animations[i];
    animation = Ext.factory(animation, Ext.fx.Animation);
    ret.push(animation);
    me.activeElement = element = animation.getElement();
    Ext.AnimationQueue.start(Ext.emptyFn, animation);
    computedStyle = window.getComputedStyle(element.dom);
    elementId = me.getElementId(element);
    data[elementId] = data = Ext.merge({}, animation.getData());
    onBeforeStart = animation.getOnBeforeStart();
    if (onBeforeStart) {
      onBeforeStart.call(animation.scope || me, element);
    }
    animation.fireEvent('animationstart', animation, data);
    me.fireEvent('animationstart', me, animation, data);
    before = data.before;
    from = data.from;
    to = data.to;
    data.fromPropertyNames = fromPropertyNames = [];
    data.toPropertyNames = toPropertyNames = [];
    for (name in to) {
      if (to.hasOwnProperty(name)) {
        to[name] = toFormattedValue = me.formatValue(to[name], name);
        formattedName = me.formatName(name);
        isLengthProperty = isLengthPropertyMap.hasOwnProperty(name);
        if (!isLengthProperty) {
          toFormattedValue = me.getCssStyleValue(formattedName, toFormattedValue);
        }
        if (from.hasOwnProperty(name)) {
          from[name] = fromFormattedValue = me.formatValue(from[name], name);
          if (!isLengthProperty) {
            fromFormattedValue = me.getCssStyleValue(formattedName, fromFormattedValue);
          }
          if (toFormattedValue !== fromFormattedValue) {
            fromPropertyNames.push(formattedName);
            toPropertyNames.push(formattedName);
          }
        } else {
          computedValue = computedStyle.getPropertyValue(formattedName);
          if (toFormattedValue !== computedValue) {
            toPropertyNames.push(formattedName);
          }
        }
      }
    }
    propertiesLength = toPropertyNames.length;
    if (propertiesLength === 0) {
      me.onAnimationEnd(element, data, animation);
      continue;
    }
    runningData = me.getRunningData(elementId);
    runningSessions = runningData.sessions;
    if (runningSessions.length > 0) {
      me.refreshRunningAnimationsData(element, Ext.Array.merge(fromPropertyNames, toPropertyNames), true, data.replacePrevious);
    }
    runningNameMap = runningData.nameMap;
    runningNameList = runningData.nameList;
    sessionNameMap = {};
    for (j = 0; j < propertiesLength; j++) {
      name = toPropertyNames[j];
      sessionNameMap[name] = true;
      if (!runningNameMap.hasOwnProperty(name)) {
        runningNameMap[name] = 1;
        runningNameList.push(name);
      } else {
        runningNameMap[name]++;
      }
    }
    runningSession = {element:element, map:sessionNameMap, list:toPropertyNames.slice(), length:propertiesLength, data:data, animation:animation};
    runningSessions.push(runningSession);
    animation.on('stop', 'onAnimationStop', me);
    elementData = Ext.apply({}, before);
    Ext.apply(elementData, from);
    if (runningNameList.length > 0) {
      fromPropertyNames = Ext.Array.difference(runningNameList, fromPropertyNames);
      toPropertyNames = Ext.Array.merge(fromPropertyNames, toPropertyNames);
      elementData['transition-property'] = fromPropertyNames;
    }
    fromData[elementId] = elementData;
    toData[elementId] = Ext.apply({}, to);
    transitionData[elementId] = {'transition-property':toPropertyNames, 'transition-duration':data.duration, 'transition-timing-function':data.easing, 'transition-delay':data.delay};
    animation.startTime = Date.now();
  }
  me.activeElement = null;
  message = me.$className;
  me.applyStyles(fromData);
  doApplyTo = function(e) {
    if (e.data === message && e.source === window) {
      window.removeEventListener('message', doApplyTo, false);
      me.applyStyles(me.transitionQueue.toData);
    }
  };
  if (!me.messageTimerId) {
    messageTimerFn = function() {
      var messageFollowupFn;
      me.messageTimerId = null;
      if (Ext.isIE) {
        me.applyStyles(me.transitionQueue.transitionData);
        if (!me.messageFollowupId) {
          messageFollowupFn = function() {
            me.messageFollowupId = null;
            window.addEventListener('message', doApplyTo, false);
            window.postMessage(message, '*');
          };
          me.messageFollowupId = Ext.raf(messageFollowupFn);
        }
      } else {
        Ext.merge(me.transitionQueue.toData, me.transitionQueue.transitionData);
        window.addEventListener('message', doApplyTo, false);
        window.postMessage(message, '*');
      }
    };
    me.messageTimerId = Ext.raf(messageTimerFn);
  }
  return ret;
}, onAnimationStop:function(animation) {
  var me = this, runningAnimationsData = me.runningAnimationsData, activeAnimations = 0, stoppedAnimations = 0, id, runningData, sessions, i, ln, session;
  for (id in runningAnimationsData) {
    if (runningAnimationsData.hasOwnProperty(id)) {
      runningData = runningAnimationsData[id];
      sessions = runningData.sessions;
      activeAnimations++;
      for (i = 0, ln = sessions.length; i < ln; i++) {
        session = sessions[i];
        if (session.animation === animation) {
          me.refreshRunningAnimationsData(session.element, session.list.slice(), false);
          if (animation.destroying) {
            stoppedAnimations++;
          }
        }
      }
    }
  }
  if (activeAnimations === stoppedAnimations) {
    if (me.messageFollowupId) {
      Ext.unraf(me.messageFollowupId);
      me.messageFollowupId = null;
    }
    if (me.messageTimerId) {
      Ext.unraf(me.messageTimerId);
      me.messageTimerId = null;
    }
    Ext.apply(me.transitionQueue, {toData:{}, transitionData:{}});
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.fx.runner, 'CssTransition', Ext, 'Animator'], 0);
Ext.cmd.derive('Ext.mixin.Container', Ext.Mixin, {mixinConfig:{id:'container'}, isContainer:true, nameHolder:false, referenceHolder:false, getNamedItems:function() {
  var CM = Ext.ComponentManager;
  if (CM.referencesDirty) {
    CM.fixReferences();
  }
  return this.nameRefs || null;
}, getReferences:function() {
  var CM = Ext.ComponentManager;
  if (CM.referencesDirty) {
    CM.fixReferences();
  }
  return this.refs || null;
}, lookup:function(ref) {
  var refs = this.getReferences();
  return refs && refs[ref] || null;
}, lookupName:function(name) {
  var items = this.getNamedItems();
  return items && items[name] || null;
}, lookupReference:function(ref) {
  return this.lookup(ref);
}, privates:{attachNameRef:function(component) {
  var me = this, key = component.name || component._name, entry, nameRefs;
  if (key && !me.destroying && !me.destroyed) {
    nameRefs = me.nameRefs || (me.nameRefs = {});
    entry = nameRefs[key];
    if (!entry) {
      entry = component.shareableName ? [component] : component;
    } else {
      if (!entry.isInstance) {
        entry.push(component);
      }
    }
    nameRefs[key] = entry;
  }
}, attachReference:function(component) {
  var me = this, key, refs;
  if (!me.destroying && !me.destroyed) {
    refs = me.refs || (me.refs = {});
    key = component.referenceKey;
    refs[key] = component;
  }
}, containerOnAdded:function(component, instanced) {
  if (instanced) {
    Ext.ComponentManager.markReferencesDirty();
  }
}, containerOnRemoved:function(destroying) {
  if (!destroying) {
    Ext.ComponentManager.markReferencesDirty();
  }
}, initContainerInheritedState:function(inheritedState, inheritedStateInner) {
  var me = this, controller = me.getController(), session = me.getSession(), viewModel = me.getConfig('viewModel', true), reference = me.reference, referenceHolder = me.referenceHolder;
  if (me.nameHolder) {
    inheritedState.nameHolder = me;
  }
  if (controller) {
    inheritedState.referenceHolder = controller;
    referenceHolder = true;
  } else {
    if (referenceHolder) {
      inheritedState.referenceHolder = me;
    }
  }
  if (referenceHolder) {
    inheritedState.referencePath = '';
  } else {
    if (reference && me.isParentReference) {
      inheritedState.referencePath = me.referenceKey + '.';
    }
  }
  if (session) {
    inheritedState.session = session;
  }
  if (viewModel) {
    inheritedState.viewModelPath = '';
  } else {
    if (reference && me.isParentReference) {
      inheritedState.viewModelPath = me.viewModelKey + '.';
    }
  }
}, setupReference:function(reference) {
  var len;
  if (reference && reference.charAt(len = reference.length - 1) === '\x3e') {
    this.isParentReference = true;
    reference = reference.substring(0, len);
  }
  return reference;
}}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Container'], 0);
Ext.cmd.derive('Ext.util.KeyMap', Ext.Base, {alternateClassName:'Ext.KeyMap', eventName:'keydown', constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  me.bindings = [];
  if (!me.target.isComponent) {
    me.target = Ext.get(me.target);
  }
  if (me.binding) {
    me.addBinding(me.binding);
  } else {
    if (config.key) {
      me.addBinding(config);
    }
  }
  me.enable();
}, addBinding:function(binding) {
  var me = this, keyCode = binding.key, i, len;
  if (me.processing) {
    me.bindings = me.bindings.slice(0);
  }
  if (Ext.isArray(binding)) {
    for (i = 0, len = binding.length; i < len; i++) {
      me.addBinding(binding[i]);
    }
    return;
  }
  me.bindings.push(Ext.apply({keyCode:me.processKeys(keyCode)}, binding));
}, removeBinding:function(binding) {
  var me = this, bindings = me.bindings, len = bindings.length, i, item, keys;
  if (me.processing) {
    me.bindings = bindings.slice(0);
  }
  keys = me.processKeys(binding.key);
  for (i = 0; i < len; i++) {
    item = bindings[i];
    if ((item.fn || item.handler) === (binding.fn || binding.handler) && item.scope === binding.scope) {
      if (binding.alt === item.alt && binding.ctrl === item.ctrl && binding.shift === item.shift) {
        if (Ext.Array.equals(item.keyCode, keys)) {
          Ext.Array.erase(me.bindings, i, 1);
          return;
        }
      }
    }
  }
}, processKeys:function(keyCode) {
  var processed = false, key, keys, keyString, len, i;
  if (keyCode.test) {
    return keyCode;
  }
  if (Ext.isString(keyCode)) {
    keys = [];
    keyString = keyCode.toUpperCase();
    for (i = 0, len = keyString.length; i < len; i++) {
      keys.push(keyString.charCodeAt(i));
    }
    keyCode = keys;
    processed = true;
  }
  if (!Ext.isArray(keyCode)) {
    keyCode = [keyCode];
  }
  if (!processed) {
    for (i = 0, len = keyCode.length; i < len; i++) {
      key = keyCode[i];
      if (Ext.isString(key)) {
        keyCode[i] = key.toUpperCase().charCodeAt(0);
      }
    }
  }
  return keyCode;
}, handleTargetEvent:function(event) {
  var me = this, bindings, i, len, result;
  if (me.enabled) {
    bindings = me.bindings;
    event = me.processEvent.apply(me.processEventScope || me, arguments);
    if (event) {
      me.lastKeyEvent = event;
      if (me.ignoreInputFields && Ext.fly(event.target).isInputField()) {
        return;
      }
      if (!event.getKey) {
        return event;
      }
      me.processing = true;
      for (i = 0, len = bindings.length; i < len; i++) {
        result = me.processBinding(bindings[i], event);
        if (result === false) {
          me.processing = false;
          return result;
        }
      }
      me.processing = false;
    }
  }
}, processEvent:Ext.identityFn, processBinding:function(binding, event) {
  if (this.checkModifiers(binding, event)) {
    var key = event.getKey(), handler = binding.fn || binding.handler, scope = binding.scope || this, keyCode = binding.keyCode, defaultEventAction = binding.defaultEventAction, i, len, result;
    if (keyCode.test) {
      if (keyCode.test(String.fromCharCode(event.getCharCode()))) {
        result = handler.call(scope, key, event);
        if (result !== true && defaultEventAction) {
          event[defaultEventAction]();
        }
        if (result === false) {
          return result;
        }
      }
    } else {
      if (keyCode.length) {
        for (i = 0, len = keyCode.length; i < len; i++) {
          if (key === keyCode[i]) {
            result = handler.call(scope, key, event);
            if (result !== true && defaultEventAction) {
              event[defaultEventAction]();
            }
            if (result === false) {
              return result;
            }
            break;
          }
        }
      }
    }
  }
}, checkModifiers:function(binding, event) {
  var keys = ['shift', 'ctrl', 'alt'], i, len, val, key;
  for (i = 0, len = keys.length; i < len; i++) {
    key = keys[i];
    val = binding[key];
    if (!(val === undefined || val === event[key + 'Key'])) {
      return false;
    }
  }
  return true;
}, on:function(key, fn, scope) {
  var keyCode, shift, ctrl, alt;
  if (Ext.isObject(key) && !Ext.isArray(key)) {
    keyCode = key.key;
    shift = key.shift;
    ctrl = key.ctrl;
    alt = key.alt;
  } else {
    keyCode = key;
  }
  this.addBinding({key:keyCode, shift:shift, ctrl:ctrl, alt:alt, fn:fn, scope:scope});
}, un:function(key, fn, scope) {
  var keyCode, shift, ctrl, alt;
  if (Ext.isObject(key) && !Ext.isArray(key)) {
    keyCode = key.key;
    shift = key.shift;
    ctrl = key.ctrl;
    alt = key.alt;
  } else {
    keyCode = key;
  }
  this.removeBinding({key:keyCode, shift:shift, ctrl:ctrl, alt:alt, fn:fn, scope:scope});
}, isEnabled:function() {
  return !!this.enabled;
}, enable:function() {
  var me = this;
  if (!me.enabled) {
    me.target.on(me.eventName, me.handleTargetEvent, me, {capture:me.capture, priority:me.priority});
    me.enabled = true;
  }
}, disable:function() {
  var me = this;
  if (me.enabled) {
    if (!me.target.destroyed) {
      me.target.removeListener(me.eventName, me.handleTargetEvent, me);
    }
    me.enabled = false;
  }
}, setDisabled:function(disabled) {
  if (disabled) {
    this.disable();
  } else {
    this.enable();
  }
}, destroy:function(removeTarget) {
  var me = this, target = me.target;
  me.bindings = [];
  me.disable();
  me.target = null;
  if (removeTarget) {
    target.destroy();
    Ext.raise('Using removeTarget argument in KeyMap destructor is not supported.');
  }
  me.callParent();
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'KeyMap', Ext, 'KeyMap'], 0);
Ext.cmd.derive('Ext.util.KeyNav', Ext.Base, {alternateClassName:'Ext.KeyNav', disabled:false, defaultEventAction:false, forceKeyDown:false, eventName:'keypress', statics:{keyOptions:{left:37, right:39, up:38, down:40, space:32, pageUp:33, pageDown:34, del:46, backspace:8, home:36, end:35, enter:13, esc:27, tab:9}}, constructor:function(config) {
  var me = this, keymapCfg, map;
  config = config || {};
  keymapCfg = {target:config.target, ignoreInputFields:config.ignoreInputFields, eventName:me.getKeyEvent('forceKeyDown' in config ? config.forceKeyDown : me.forceKeyDown, config.eventName), capture:config.capture};
  if (me.map) {
    me.map.destroy();
  }
  me.initConfig(config);
  if (config.processEvent) {
    keymapCfg.processEvent = config.processEvent;
    keymapCfg.processEventScope = config.processEventScope || me;
  }
  if (config.priority) {
    keymapCfg.priority = config.priority;
  }
  if (config.keyMap) {
    map = me.map = config.keyMap;
  } else {
    map = me.map = new Ext.util.KeyMap(keymapCfg);
    me.destroyKeyMap = true;
  }
  me.addBindings(config);
  map.disable();
  if (!config.disabled) {
    map.enable();
  }
}, addBindings:function(bindings) {
  var me = this, map = me.map, keyCodes = Ext.util.KeyNav.keyOptions, Event = Ext.event.Event, defaultScope = bindings.scope || me, binding, keyName, keyCode;
  for (keyName in bindings) {
    binding = bindings[keyName];
    keyCode = keyName.length === 1 ? keyName.charCodeAt(0) : keyCodes[keyName] || Event[keyName.toUpperCase()];
    if (keyCode != null) {
      keyName = keyCode;
    }
    if (binding && (keyName.length === 1 || !isNaN(keyName = parseInt(keyName, 10)))) {
      if (typeof binding === 'function') {
        binding = {handler:binding, defaultEventAction:bindings.defaultEventAction !== undefined ? bindings.defaultEventAction : me.defaultEventAction};
      }
      map.addBinding({key:keyName, ctrl:binding.ctrl, shift:binding.shift, alt:binding.alt, handler:Ext.Function.bind(me.handleEvent, binding.scope || defaultScope, [binding.handler || binding.fn, me], true), defaultEventAction:binding.defaultEventAction !== undefined ? binding.defaultEventAction : me.defaultEventAction});
    }
  }
}, handleEvent:function(keyCode, event, handler, keyNav) {
  keyNav.lastKeyEvent = event;
  return handler.call(this, event);
}, destroy:function(removeEl) {
  var me = this;
  if (removeEl) {
    Ext.raise('removeEl argument in KeyNav destructor is not supported anymore.');
  }
  if (me.destroyKeyMap) {
    me.map.destroy(removeEl);
  }
  me.map = null;
  me.callParent();
}, enable:function() {
  if (this.map) {
    this.map.enable();
    this.disabled = false;
  }
}, disable:function() {
  if (this.map) {
    this.map.disable();
  }
  this.disabled = true;
}, setDisabled:function(disabled) {
  this.map.setDisabled(disabled);
  this.disabled = disabled;
}, isEnabled:function() {
  return !this.disabled;
}, getKeyEvent:function(forceKeyDown, configuredEventName) {
  if (forceKeyDown || Ext.supports.SpecialKeyDownRepeat && !configuredEventName) {
    return 'keydown';
  } else {
    return configuredEventName || this.eventName;
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'KeyNav', Ext, 'KeyNav'], 0);
Ext.cmd.derive('Ext.mixin.FocusableContainer', Ext.Mixin, {mixinConfig:{id:'focusablecontainer'}, isFocusableContainer:true, focusableContainer:false, resetFocusPosition:false, activeChildTabIndex:0, inactiveChildTabIndex:-1, allowFocusingDisabledChildren:false, focusableContainerEl:'el', privates:{initFocusableContainer:function(clearChildren) {
  var items, i, len;
  if (this.focusableContainer) {
    clearChildren = clearChildren != null ? clearChildren : true;
    this.doInitFocusableContainer(clearChildren);
  } else {
    items = this.getFocusables();
    for (i = 0, len = items.length; i < len; i++) {
      items[i].ownerFocusableContainer = null;
    }
  }
}, doInitFocusableContainer:function(clearChildren) {
  var me = this, el = me.focusableContainerEl, child;
  if (!el.isElement) {
    el = me.focusableContainerEl = me[el];
  }
  if (me.initFocusableContainerKeyNav) {
    me.initFocusableContainerKeyNav(el);
  }
  if (clearChildren) {
    me.clearFocusables();
    if (!me.isDisabled()) {
      child = me.findNextFocusableChild({step:1}) || me.findNextFocusableChild({beforeRender:true});
      if (child) {
        me.activateFocusable(child);
      }
    }
  }
  child = me.findNextFocusableChild({firstTabbable:true});
  me.activateFocusableContainer(!!child && !me.isDisabled());
}, initFocusableContainerKeyNav:function(el) {
  var me = this;
  if (!me.focusableKeyNav) {
    el = el || me.focusableContainerEl;
    me.focusableKeyNav = new Ext.util.KeyNav({target:el, disabled:true, eventName:'keydown', processEvent:me.processFocusableContainerKeyEvent, processEventScope:me, scope:me, tab:me.onFocusableContainerTabKey, enter:{handler:me.onFocusableContainerEnterKey, ctrl:false, shift:false, alt:false}, space:{handler:me.onFocusableContainerSpaceKey, ctrl:false, shift:false, alt:false}, up:{handler:me.onFocusableContainerUpKey, ctrl:false, shift:false, alt:false}, down:{handler:me.onFocusableContainerDownKey, 
    ctrl:false, shift:false, alt:false}, left:{handler:me.onFocusableContainerLeftKey, ctrl:false, shift:false, alt:false}, right:{handler:me.onFocusableContainerRightKey, ctrl:false, shift:false, alt:false}});
  }
}, destroyFocusableContainer:function() {
  this.focusableKeyNav = Ext.destroy(this.focusableKeyNav);
}, activateFocusableContainer:function(enable) {
  var keyNav = this.focusableKeyNav;
  if (keyNav) {
    keyNav.setDisabled(!enable);
  }
}, isFocusableContainerActive:function() {
  var keyNav = this.focusableKeyNav;
  return keyNav ? !keyNav.disabled : false;
}, getFocusables:function() {
  return this.items.items;
}, initDefaultFocusable:function() {
  var me = this, haveFocusable = false, items, item, i, len;
  items = me.getFocusables();
  len = items.length;
  if (!len) {
    return;
  }
  for (i = 0; i < len; i++) {
    item = items[i];
    if (!item.isDisabled() && item.isFocusable()) {
      haveFocusable = true;
      break;
    }
  }
  if (!haveFocusable) {
    return;
  }
  item = me.findNextFocusableChild({items:items, step:true});
  if (item) {
    me.activateFocusable(item);
  }
  return item;
}, clearFocusables:function(skipFocused) {
  var me = this, items = me.getFocusables(), len = items.length, item, i;
  for (i = 0; i < len; i++) {
    item = items[i];
    if (!item.destroyed && item.focusable && item.isTabbable()) {
      me.deactivateFocusable(item);
    }
  }
}, processFocusableContainerKeyEvent:function(e) {
  if (!Ext.fly(e.target).isInputField()) {
    return e;
  }
}, activateFocusable:function(child) {
  child.setTabIndex(this.activeChildTabIndex);
}, deactivateFocusable:function(child) {
  child.setTabIndex(this.inactiveChildTabIndex);
}, onFocusableContainerTabKey:function() {
  return true;
}, onFocusableContainerEnterKey:function() {
  return true;
}, onFocusableContainerSpaceKey:function() {
  return true;
}, onFocusableContainerUpKey:function(e) {
  e.preventDefault();
  return this.moveChildFocus(e, false);
}, onFocusableContainerDownKey:function(e) {
  e.preventDefault();
  return this.moveChildFocus(e, true);
}, onFocusableContainerLeftKey:function(e) {
  e.preventDefault();
  return this.moveChildFocus(e, false);
}, onFocusableContainerRightKey:function(e) {
  e.preventDefault();
  return this.moveChildFocus(e, true);
}, getFocusableFromEvent:function(e) {
  var child = Ext.Component.from(e);
  return child;
}, moveChildFocus:function(e, forward) {
  var child = this.getFocusableFromEvent(e);
  return this.focusChild(child, forward, e);
}, focusChild:function(child, forward) {
  var nextChild = this.findNextFocusableChild({child:child, step:forward});
  if (nextChild) {
    nextChild.focus();
  }
  return nextChild;
}, findNextFocusableChild:function(options) {
  var beforeRender = options.beforeRender, firstTabbable = options.firstTabbable, items, item, child, step, idx, i, len, allowDisabled;
  items = options.items || this.getFocusables();
  step = options.step != null ? options.step : 1;
  child = options.child;
  allowDisabled = !!this.allowFocusingDisabledChildren;
  idx = Ext.Array.indexOf(items, child);
  step = step === true ? 1 : step === false ? -1 : step;
  len = items.length;
  i = step > 0 ? idx < len ? idx + step : 0 : idx > 0 ? idx + step : len - 1;
  for (;; i += step) {
    if (idx < 0 && (i >= len || i < 0)) {
      return null;
    } else {
      if (i >= len) {
        i = -1;
        continue;
      } else {
        if (i < 0) {
          i = len;
          continue;
        } else {
          if (i === idx) {
            return null;
          }
        }
      }
    }
    item = items[i];
    if (!item || !item.focusable || item.isDisabled() && !allowDisabled) {
      continue;
    }
    if (firstTabbable) {
      if (item.isTabbable && item.isTabbable()) {
        return item;
      }
    } else {
      if (beforeRender || item.isFocusable && item.isFocusable()) {
        return item;
      }
    }
  }
  return null;
}, onFocusEnter:function(e) {
  var me = this, target = e.toComponent, child;
  if (target === me) {
    child = me.initDefaultFocusable();
    if (child) {
      child.focus();
    }
  }
  me.activateFocusableContainer(true);
}, onFocusLeave:function(e) {
  var me = this;
  if (me.resetFocusPosition) {
    me.clearFocusables();
    me.initDefaultFocusable();
  }
}, beforeFocusableChildBlur:Ext.privateFn, afterFocusableChildBlur:Ext.privateFn, beforeFocusableChildFocus:function(child) {
  var me = this;
  if (!me.focusableContainer || me.destroying || me.destroyed) {
    return;
  }
  me.clearFocusables();
  me.activateFocusable(child);
}, afterFocusableChildFocus:function(child) {
  var me = this;
  if (!me.focusableContainer || me.destroying || me.destroyed) {
    return;
  }
  me.lastFocusedChild = child;
}, onFocusableChildAdd:function(child) {
  var me = this;
  if (child.focusable) {
    child.ownerFocusableContainer = me;
  }
}, onFocusableChildRemove:function(child) {
  var me = this, next;
  child.ownerFocusableContainer = null;
  if (child === me.lastFocusedChild) {
    me.lastFocusedChild = null;
    next = me.initDefaultFocusable();
    if (child.hasFocus) {
      next = next || child.findFocusTarget();
      if (next) {
        next.focus();
      }
    }
  }
  child = next || me.findNextFocusableChild({step:1, beforeRender:true});
  if (!child) {
    me.activateFocusableContainer(false);
  }
}, beforeFocusableChildEnable:Ext.privateFn, onFocusableChildEnable:function(child) {
  var me = this, active;
  if (!me.focusableContainer || me.destroying || me.destroyed) {
    return;
  }
  if (me.containsFocus) {
    active = Ext.ComponentManager.getActiveComponent();
    me.clearFocusables();
    me.activateFocusable(active);
  } else {
    if (me.resetFocusPosition || me.lastFocusedChild == null) {
      me.clearFocusables();
      if (child.hasFocus) {
        me.activateFocusable(child);
        active = child;
      }
    } else {
      me.deactivateFocusable(child);
      if (child === me.lastFocusedChild) {
        me.clearFocusables();
        me.activateFocusable(child);
      }
      active = me.findNextFocusableChild({firstTabbable:true});
    }
  }
  if (!active) {
    me.initDefaultFocusable();
  }
  me.activateFocusableContainer(true);
}, beforeFocusableChildDisable:function(child) {
  var me = this, next;
  if (!me.focusableContainer || me.destroying || me.destroyed) {
    return;
  }
  if (child.hasFocus) {
    next = me.findNextFocusableChild({child:child}) || child.findFocusTarget();
    if (next) {
      next.focus();
    }
  }
}, onFocusableChildDisable:function(child) {
  var me = this, next;
  if (!me.focusableContainer || me.destroying || me.destroyed) {
    return;
  }
  next = me.findNextFocusableChild({firstTabbable:true});
  if (!next) {
    next = me.initDefaultFocusable();
  }
  if (!next) {
    me.activateFocusableContainer(false);
  }
}, beforeFocusableChildHide:function(child) {
  return this.beforeFocusableChildDisable(child);
}, onFocusableChildHide:function(child) {
  return this.onFocusableChildDisable(child);
}, beforeFocusableChildShow:function(child) {
  return this.beforeFocusableChildEnable(child);
}, onFocusableChildShow:function(child) {
  return this.onFocusableChildEnable(child);
}, onFocusableChildMasked:Ext.privateFn, onFocusableChildDestroy:Ext.privateFn, onFocusableChildUpdate:Ext.privateFn}, deprecated:{7:{configs:{enableFocusableContainer:'focusableContainer'}}}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'FocusableContainer'], 0);
Ext.cmd.derive('Ext.perf.Accumulator', Ext.Base, function() {
  var currentFrame = null, khrome = Ext.global['chrome'], formatTpl, getTimestamp = function() {
    getTimestamp = Ext.now;
    var interval, toolbox;
    if (Ext.isChrome && khrome && khrome.Interval) {
      interval = new khrome.Interval;
      interval.start();
      getTimestamp = function() {
        return interval.microseconds() / 1000;
      };
    } else {
      if (window.ActiveXObject) {
        try {
          toolbox = new ActiveXObject('SenchaToolbox.Toolbox');
          Ext.senchaToolbox = toolbox;
          getTimestamp = function() {
            return toolbox.milliseconds;
          };
        } catch (e$33) {
        }
      }
    }
    Ext.perf.getTimestamp = Ext.perf.Accumulator.getTimestamp = getTimestamp;
    return getTimestamp();
  };
  function adjustSet(set, time) {
    set.sum += time;
    set.min = Math.min(set.min, time);
    set.max = Math.max(set.max, time);
  }
  function leaveFrame(time) {
    var totalTime = time ? time : getTimestamp() - this.time, me = this, accum = me.accum;
    ++accum.count;
    if (!--accum.depth) {
      adjustSet(accum.total, totalTime);
    }
    adjustSet(accum.pure, totalTime - me.childTime);
    currentFrame = me.parent;
    if (currentFrame) {
      ++currentFrame.accum.childCount;
      currentFrame.childTime += totalTime;
    }
  }
  function makeSet() {
    return {min:Number.MAX_VALUE, max:0, sum:0};
  }
  function makeTap(me, fn) {
    return function() {
      var frame = me.enter(), ret = fn.apply(this, arguments);
      frame.leave();
      return ret;
    };
  }
  function setToJSON(count, childCount, calibration, set) {
    var data = {avg:0, min:set.min, max:set.max, sum:0};
    if (count) {
      calibration = calibration || 0;
      data.sum = set.sum - childCount * calibration;
      data.avg = data.sum / count;
    }
    return data;
  }
  return {constructor:function(name) {
    var me = this;
    me.count = me.childCount = me.depth = me.maxDepth = 0;
    me.pure = makeSet();
    me.total = makeSet();
    me.name = name;
  }, statics:{getTimestamp:getTimestamp}, format:function(calibration) {
    if (!formatTpl) {
      formatTpl = new Ext.XTemplate(['{name} - {count} call(s)', '\x3ctpl if\x3d"count"\x3e', '\x3ctpl if\x3d"childCount"\x3e', ' ({childCount} children)', '\x3c/tpl\x3e', '\x3ctpl if\x3d"depth - 1"\x3e', ' ({depth} deep)', '\x3c/tpl\x3e', '\x3ctpl for\x3d"times"\x3e', ', {type}: {[this.time(values.sum)]} msec (', 'avg\x3d{[this.time(values.sum / parent.count)]}', ')', '\x3c/tpl\x3e', '\x3c/tpl\x3e'].join(''), {time:function(t) {
        return Math.round(t * 100) / 100;
      }});
    }
    var data = this.getData(calibration);
    data.name = this.name;
    data.pure.type = 'Pure';
    data.total.type = 'Total';
    data.times = [data.pure, data.total];
    return formatTpl.apply(data);
  }, getData:function(calibration) {
    var me = this;
    return {count:me.count, childCount:me.childCount, depth:me.maxDepth, pure:setToJSON(me.count, me.childCount, calibration, me.pure), total:setToJSON(me.count, me.childCount, calibration, me.total)};
  }, enter:function() {
    var me = this, frame = {accum:me, leave:leaveFrame, childTime:0, parent:currentFrame};
    ++me.depth;
    if (me.maxDepth < me.depth) {
      me.maxDepth = me.depth;
    }
    currentFrame = frame;
    frame.time = getTimestamp();
    return frame;
  }, monitor:function(fn, scope, args) {
    var frame = this.enter();
    if (args) {
      fn.apply(scope, args);
    } else {
      fn.call(scope);
    }
    frame.leave();
  }, report:function() {
    Ext.log(this.format());
  }, tap:function(className, methodName) {
    var me = this, methods = typeof methodName === 'string' ? [methodName] : methodName, klass, statik, i, parts, length, name, src, tapFunc;
    tapFunc = function() {
      if (typeof className === 'string') {
        klass = Ext.global;
        parts = className.split('.');
        for (i = 0, length = parts.length; i < length; ++i) {
          klass = klass[parts[i]];
        }
      } else {
        klass = className;
      }
      for (i = 0, length = methods.length; i < length; ++i) {
        name = methods[i];
        statik = name.charAt(0) === '!';
        if (statik) {
          name = name.substring(1);
        } else {
          statik = !(name in klass.prototype);
        }
        src = statik ? klass : klass.prototype;
        src[name] = makeTap(me, src[name]);
      }
    };
    Ext.ClassManager.onCreated(tapFunc, me, className);
    return me;
  }};
}, 1, 0, 0, 0, 0, 0, [Ext.perf, 'Accumulator'], function() {
  Ext.perf.getTimestamp = this.getTimestamp;
});
Ext.cmd.derive('Ext.perf.Monitor', Ext.Base, {singleton:true, alternateClassName:'Ext.Perf', constructor:function() {
  this.accumulators = [];
  this.accumulatorsByName = {};
}, calibrate:function() {
  var accum = new Ext.perf.Accumulator('$'), total = accum.total, getTimestamp = Ext.perf.Accumulator.getTimestamp, count = 0, frame, endTime, startTime;
  startTime = getTimestamp();
  do {
    frame = accum.enter();
    frame.leave();
    ++count;
  } while (total.sum < 100);
  endTime = getTimestamp();
  return (endTime - startTime) / count;
}, get:function(name) {
  var me = this, accum = me.accumulatorsByName[name];
  if (!accum) {
    me.accumulatorsByName[name] = accum = new Ext.perf.Accumulator(name);
    me.accumulators.push(accum);
  }
  return accum;
}, enter:function(name) {
  return this.get(name).enter();
}, monitor:function(name, fn, scope) {
  this.get(name).monitor(fn, scope);
}, report:function() {
  var me = this, accumulators = me.accumulators, calibration = me.calibrate();
  accumulators.sort(function(a, b) {
    return a.name < b.name ? -1 : b.name < a.name ? 1 : 0;
  });
  me.updateGC();
  Ext.log('Calibration: ' + Math.round(calibration * 100) / 100 + ' msec/sample');
  Ext.each(accumulators, function(accum) {
    Ext.log(accum.format(calibration));
  });
}, getData:function(all) {
  var ret = {}, accumulators = this.accumulators;
  Ext.each(accumulators, function(accum) {
    if (all || accum.count) {
      ret[accum.name] = accum.getData();
    }
  });
  return ret;
}, reset:function() {
  Ext.each(this.accumulators, function(accum) {
    var me = accum;
    me.count = me.childCount = me.depth = me.maxDepth = 0;
    me.pure = {min:Number.MAX_VALUE, max:0, sum:0};
    me.total = {min:Number.MAX_VALUE, max:0, sum:0};
  });
}, updateGC:function() {
  var accumGC = this.accumulatorsByName.GC, toolbox = Ext.senchaToolbox, bucket;
  if (accumGC) {
    accumGC.count = toolbox.garbageCollectionCounter || 0;
    if (accumGC.count) {
      bucket = accumGC.pure;
      accumGC.total.sum = bucket.sum = toolbox.garbageCollectionMilliseconds;
      bucket.min = bucket.max = bucket.sum / accumGC.count;
      bucket = accumGC.total;
      bucket.min = bucket.max = bucket.sum / accumGC.count;
    }
  }
}, watchGC:function() {
  Ext.perf.getTimestamp();
  var toolbox = Ext.senchaToolbox;
  if (toolbox) {
    this.get('GC');
    toolbox.watchGarbageCollector(false);
  }
}, setup:function(config) {
  if (!config) {
    config = {render:{'Ext.Component':'render'}, layout:{'Ext.layout.Context':'run'}};
  }
  this.currentConfig = config;
  var key, prop, accum, className, methods;
  for (key in config) {
    if (config.hasOwnProperty(key)) {
      prop = config[key];
      accum = Ext.Perf.get(key);
      for (className in prop) {
        if (prop.hasOwnProperty(className)) {
          methods = prop[className];
          accum.tap(className, methods);
        }
      }
    }
  }
  this.watchGC();
}, setupLog:function(config) {
  var className, cls, methods, method, override;
  for (className in config) {
    if (config.hasOwnProperty(className)) {
      cls = Ext.ClassManager.get(className);
      if (cls) {
        methods = config[className];
        override = {};
        for (method in methods) {
          override[method] = function(methodName, idProp) {
            return function() {
              var before, diff, id, idHolder, ret;
              before = +Date.now();
              ret = this.callParent(arguments);
              diff = +Date.now() - before;
              if (window.console && diff > 0) {
                idHolder = idProp === 'this' ? this : typeof idProp === 'string' ? this[idProp] : typeof idProp === 'number' ? arguments[idProp] : null;
                if (idHolder) {
                  id = idHolder.id;
                }
                if (id != null) {
                  console.log(methodName + ' for ' + id + ': ' + diff + 'ms');
                } else {
                  console.log(methodName + ' for unknown: ' + diff + 'ms');
                }
                if (console.trace) {
                  console.trace();
                }
              }
              return ret;
            };
          }(method, methods[method]);
        }
        Ext.override(cls, override);
      }
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.perf, 'Monitor', Ext, 'Perf'], 0);
Ext.cmd.derive('Ext.plugin.MouseEnter', Ext.plugin.Abstract, {element:'el', init:function(component) {
  var me = this, listeners = {mouseover:'onMouseEvent', scope:me, destroyable:true}, element = me.element;
  if (me.leaveHandler || me.delay) {
    listeners.mouseout = 'onMouseEvent';
  }
  if (typeof element === 'string') {
    element = component[me.element];
  }
  if (element) {
    me.mouseListener = Ext.get(element).on(listeners);
  } else {
    component.on({render:function() {
      me.mouseListener = component[me.element].on(listeners);
    }, single:true});
  }
}, onMouseEvent:function(e) {
  var me = this, delegate = e.getTarget(me.delegate);
  if (delegate && delegate !== e.getRelatedTarget(me.delegate)) {
    if (me.delay) {
      Ext.undefer(me.mouseEventTimer);
      me.mouseEventTimer = Ext.defer(me.handleMouseEvent, me.delay, me, [e, delegate]);
    } else {
      me.handleMouseEvent(e, delegate);
    }
  }
}, handleMouseEvent:function(e, delegate) {
  var me = this;
  if (e.type === 'mouseover') {
    Ext.callback(me.handler, null, [e, delegate], 0, me.cmp, me.scope);
  } else {
    if (me.leaveHandler) {
      Ext.callback(me.leaveHandler, null, [e, delegate], 0, me.cmp, me.scope);
    }
  }
}, destroy:function() {
  Ext.destroy(this.mouseListener);
  Ext.plugin.Abstract.prototype.destroy.call(this);
}}, 0, 0, 0, 0, ['plugin.mouseenter'], 0, [Ext.plugin, 'MouseEnter'], 0);
Ext.cmd.derive('Ext.util.ClickRepeater', Ext.Base, {alternateClassName:'Ext.util.TapRepeater', config:{el:null, target:null, disabled:null}, interval:20, delay:250, preventDefault:true, stopDefault:false, timer:0, handler:null, scope:null, constructor:function(config) {
  var me = this;
  if (arguments.length === 2) {
    me.setEl(config);
    config = arguments[1];
  }
  me.mixins.observable.constructor.call(this, config);
}, destroy:function() {
  this.setEl(null);
  this.callParent();
}, privates:{fireClick:function(e) {
  var me = this;
  me.fireEvent('click', me, e);
  Ext.callback(me.handler, me.scope, [me, e], 0, me.getTarget());
}, updateDisabled:function(disabled) {
  var me = this;
  if (disabled) {
    me.savedEl = me.getEl();
    me.setEl(null);
  } else {
    if (me.savedEl) {
      me.setEl(me.savedEl);
    }
  }
}, updateTarget:function(target) {
  this.setEl(target.el);
}, updateEl:function(newEl, oldEl) {
  var me = this, elListeners;
  if (oldEl) {
    oldEl.selectable();
    Ext.undefer(me.timer);
    if (me.pressedCls) {
      oldEl.removeCls(me.pressedCls);
    }
    Ext.getDoc().un('mouseup', me.handleMouseUp, me);
    me.elListeners = Ext.destroy(me.elListeners);
  }
  if (newEl) {
    newEl.unselectable();
    elListeners = {mousedown:me.handleMouseDown, scope:me, destroyable:true};
    if (me.preventDefault || me.stopDefault) {
      elListeners.click = me.eventOptions;
    }
    me.elListeners = newEl.on(elListeners);
  }
}, eventOptions:function(e) {
  if (this.preventDefault) {
    e.preventDefault();
  }
  if (this.stopDefault) {
    e.stopEvent();
  }
}, handleMouseDown:function(e) {
  var me = this, el = me.getEl();
  Ext.undefer(me.timer);
  if (me.pressedCls) {
    el.addCls(me.pressedCls);
  }
  me.mousedownTime = Ext.now();
  if (e.pointerType === 'mouse') {
    el.on('mouseout', me.handleMouseOut, me);
  }
  Ext.getDoc().on('mouseup', me.handleMouseUp, me);
  me.fireEvent('mousedown', me, e);
  me.fireClick(e);
  if (me.accelerate) {
    me.delay = 400;
  }
  me.timer = Ext.defer(me.click, me.delay || me.interval, me, [e]);
  if (me.mousedownPreventDefault) {
    e.preventDefault();
  }
  if (me.mousedownStopEvent) {
    e.stopEvent();
  }
}, click:function(e) {
  var me = this;
  me.fireClick(e);
  me.timer = Ext.defer(me.click, me.accelerate ? me.easeOutExpo(Ext.now() - me.mousedownTime, 400, -390, 12000) : me.interval, me, [e]);
}, easeOutExpo:function(t, b, c, d) {
  return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
}, handleMouseOut:function() {
  var me = this, el = me.getEl();
  Ext.undefer(me.timer);
  if (me.pressedCls) {
    el.removeCls(me.pressedCls);
  }
  el.on('mouseover', me.handleMouseReturn, me);
}, handleMouseReturn:function(e) {
  var me = this, el = me.getEl();
  el.un('mouseover', me.handleMouseReturn, me);
  if (me.pressedCls) {
    el.addCls(me.pressedCls);
  }
  me.click(e);
}, handleMouseUp:function(e) {
  var me = this, el = me.getEl();
  Ext.undefer(me.timer);
  el.un('mouseover', me.handleMouseReturn, me);
  el.un('mouseout', me.handleMouseOut, me);
  Ext.getDoc().un('mouseup', me.handleMouseUp, me);
  if (me.pressedCls) {
    el.removeCls(me.pressedCls);
  }
  me.fireEvent('mouseup', me, e);
}}}, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.util, 'ClickRepeater', Ext.util, 'TapRepeater'], 0);
Ext.cmd.derive('Ext.util.ItemCollection', Ext.util.MixedCollection, {alternateClassName:'Ext.ItemCollection', getKey:function(item) {
  return item.getItemId && item.getItemId();
}, has:function(item) {
  return this.map.hasOwnProperty(item.getId());
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'ItemCollection', Ext, 'ItemCollection'], 0);
Ext.cmd.derive('Ext.util.TaskManager', Ext.util.TaskRunner, {alternateClassName:['Ext.TaskManager'], singleton:true}, 0, 0, 0, 0, 0, 0, [Ext.util, 'TaskManager', Ext, 'TaskManager'], 0);
Ext.cmd.derive('Ext.util.TextMetrics', Ext.Base, {statics:{shared:null, measure:function(el, text, fixedWidth) {
  var me = this, shared = me.shared || (me.shared = new me(el, fixedWidth));
  shared.bind(el);
  shared.setFixedWidth(fixedWidth || 'auto');
  return shared.getSize(text);
}, destroy:function() {
  this.shared = Ext.destroy(this.shared);
}}, constructor:function(bindTo, fixedWidth) {
  var me = this, measure = me.measure = Ext.getBody().createChild({role:'presentation', cls:'x-textmetrics', style:{position:'absolute', left:'-1000px', top:'-1000px', visibility:'hidden'}});
  if (bindTo) {
    me.bind(bindTo);
  }
  if (fixedWidth) {
    measure.setWidth(fixedWidth);
  }
}, getSize:function(text) {
  var measure = this.measure, size;
  measure.setHtml(text);
  size = measure.getSize();
  measure.setHtml('');
  return size;
}, bind:function(el) {
  this.measure.setStyle((this.el || (this.self.prototype.el = new Ext.dom.Fly)).attach(el).getStyle(['font-size', 'font-size-adjust', 'font-style', 'font-weight', 'font-family', 'font-kerning', 'font-stretch', 'line-height', 'text-transform', 'text-decoration', 'letter-spacing', 'word-break']));
}, setFixedWidth:function(width) {
  this.measure.setWidth(width);
}, getWidth:function(text) {
  this.measure.dom.style.width = 'auto';
  return this.getSize(text).width;
}, getHeight:function(text) {
  return this.getSize(text).height;
}, destroy:function() {
  var me = this;
  me.el = me.measure = Ext.destroy(me.measure);
  me.callParent();
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'TextMetrics'], function() {
  Ext.Element.override({getTextWidth:function(text, min, max) {
    return Ext.Number.constrain(Ext.util.TextMetrics.measure(this.dom, Ext.valueFrom(text, this.dom.innerHTML, true)).width, min || 0, max || 1000000);
  }});
});
Ext.define(null, {override:'Ext.form.field.Checkbox', compatibility:Ext.isIE8, changeEventName:'propertychange', onChangeEvent:function(e) {
  if (this.duringSetRawValue || e.browserEvent.propertyName !== 'checked') {
    return;
  }
  this.callParent([e]);
}, updateCheckedCls:function(checked) {
  var me = this, displayEl = me.displayEl;
  me.callParent([checked]);
  if (displayEl && checked !== me.lastValue) {
    displayEl.repaint();
  }
}});
Ext.define(null, {override:'Ext.form.field.Radio', compatibility:Ext.isIE8, getSubTplData:function(fieldData) {
  var data = this.callParent([fieldData]);
  delete data.checked;
  return data;
}, afterRender:function() {
  this.callParent();
  if (this.checked) {
    this.inputEl.dom.checked = true;
  }
}, onChange:function(newValue, oldValue) {
  this.callSuper([newValue, oldValue]);
}});
Ext.define(null, {override:'Ext.scroll.Scroller', compatibility:Ext.isIE8, privates:{doScrollTo:function(x, y, animate) {
  var me = this, element = me.getScrollElement(), maxPosition, dom, to, xInf, yInf, ret, deferred, callback;
  if (element && !element.destroyed) {
    dom = element.dom;
    xInf = x === Infinity;
    yInf = y === Infinity;
    if (xInf || yInf) {
      maxPosition = me.getMaxPosition();
      if (xInf) {
        x = maxPosition.x;
      }
      if (yInf) {
        y = maxPosition.y;
      }
    }
    if (x !== null) {
      x = me.convertX(x);
    }
    if (animate) {
      to = {};
      if (y != null) {
        to.scrollTop = y;
      }
      if (x != null) {
        to.scrollLeft = x;
      }
      animate = Ext.mergeIf({to:{scrollTop:y, scrollLeft:x}}, animate);
      deferred = new Ext.Deferred;
      callback = animate.callback;
      animate.callback = function() {
        if (callback) {
          callback.call(animate.scope || Ext.global, arguments);
        }
        if (me.destroyed) {
          deferred.reject();
        } else {
          deferred.resolve();
        }
      };
      element.animate(animate);
      ret = deferred.promise;
    } else {
      if (x != null && x !== 0 && y != null) {
        me.deferDomScroll = true;
      }
      if (y != null) {
        dom.scrollTop = y;
      }
      if (x != null) {
        dom.scrollLeft = x;
      }
      if (me.deferDomScroll) {
        me.deferDomScroll = false;
        +dom.scrollLeft;
        dom.scrollLeft = x;
        +dom.scrollTop;
        dom.scrollTop = y;
      }
      ret = Ext.Deferred.getCachedResolved();
    }
    me.positionDirty = true;
  } else {
    ret = Ext.Deferred.getCachedRejected();
  }
  return ret;
}, onDomScroll:function() {
  var me = this;
  if (me.deferDomScroll) {
    return;
  }
  me.callParent();
}}});
Ext.cmd.derive('Ext.Action', Ext.Base, {constructor:function(config) {
  this.initialConfig = config;
  this.itemId = config.itemId = config.itemId || config.id || Ext.id();
  this.items = [];
}, isAction:true, setText:function(text) {
  this.initialConfig.text = text;
  this.callEach('setText', [text]);
}, getText:function() {
  return this.initialConfig.text;
}, setIconCls:function(cls) {
  this.initialConfig.iconCls = cls;
  this.callEach('setIconCls', [cls]);
}, setGlyph:function(glyph) {
  this.initialConfig.glyph = glyph;
  this.callEach('setGlyph', [glyph]);
}, getIconCls:function() {
  return this.initialConfig.iconCls;
}, setDisabled:function(disabled) {
  this.initialConfig.disabled = disabled;
  this.callEach('setDisabled', [disabled]);
}, enable:function() {
  this.setDisabled(false);
}, disable:function() {
  this.setDisabled(true);
}, isDisabled:function() {
  return this.initialConfig.disabled;
}, setHidden:function(hidden) {
  this.initialConfig.hidden = hidden;
  this.callEach('setVisible', [!hidden]);
}, show:function() {
  this.setHidden(false);
}, hide:function() {
  this.setHidden(true);
}, isHidden:function() {
  return this.initialConfig.hidden;
}, setHandler:function(handler, scope) {
  this.initialConfig.handler = handler;
  this.initialConfig.scope = scope;
  this.callEach('setHandler', [handler, scope]);
}, each:function(fn, scope) {
  Ext.each(this.items, fn, scope);
}, callEach:function(fnName, args) {
  var items = this.items, i = 0, len = items.length, item;
  Ext.suspendLayouts();
  for (; i < len; i++) {
    item = items[i];
    item[fnName].apply(item, args);
  }
  Ext.resumeLayouts(true);
}, addComponent:function(comp) {
  this.items.push(comp);
  comp.on('destroy', this.removeComponent, this);
}, removeComponent:function(comp) {
  Ext.Array.remove(this.items, comp);
}, execute:function() {
  this.initialConfig.handler.apply(this.initialConfig.scope || Ext.global, arguments);
}}, 1, 0, 0, 0, 0, 0, [Ext, 'Action'], 0);
Ext.cmd.derive('Ext.ElementLoader', Ext.Base, {statics:{Renderer:{Html:function(loader, response, active) {
  loader.getTarget().setHtml(response.responseText, active.scripts === true, active.callback, active.rendererScope);
  return true;
}}}, url:null, params:null, baseParams:null, autoLoad:false, target:null, loadMask:false, ajaxOptions:null, scripts:false, isLoader:true, constructor:function(config) {
  var me = this, autoLoad;
  me.mixins.observable.constructor.call(me, config);
  me.setTarget(me.target);
  if (me.autoLoad) {
    autoLoad = me.autoLoad;
    if (autoLoad === true) {
      autoLoad = null;
    }
    me.load(autoLoad);
  }
}, setTarget:function(target) {
  var me = this;
  target = Ext.get(target);
  if (me.target && me.target !== target) {
    me.abort();
  }
  me.target = target;
}, getTarget:function() {
  return this.target || null;
}, abort:function() {
  var active = this.active;
  if (active !== undefined) {
    Ext.Ajax.abort(active.request);
    if (active.mask) {
      this.removeMask();
    }
    delete this.active;
  }
}, removeMask:function() {
  this.target.unmask();
}, addMask:function(mask) {
  this.target.mask(mask === true ? null : mask);
}, load:function(options) {
  if (this.destroying || this.destroyed) {
    return;
  }
  options = Ext.apply({}, options);
  var me = this, mask = Ext.isDefined(options.loadMask) ? options.loadMask : me.loadMask, params = Ext.apply({}, options.params), ajaxOptions = Ext.apply({}, options.ajaxOptions), callback = options.callback || me.callback, scope = options.scope || me.scope || me;
  Ext.applyIf(ajaxOptions, me.ajaxOptions);
  Ext.applyIf(options, ajaxOptions);
  Ext.applyIf(params, me.params);
  Ext.apply(params, me.baseParams);
  Ext.applyIf(options, {url:me.url});
  Ext.apply(options, {scope:me, params:params, callback:me.onComplete});
  if (me.fireEvent('beforeload', me, options) === false) {
    return;
  }
  if (mask) {
    me.addMask(mask);
  }
  me.active = {options:options, mask:mask, scope:scope, callback:callback, success:options.success || me.success, failure:options.failure || me.failure, renderer:options.renderer || me.renderer, scripts:Ext.isDefined(options.scripts) ? options.scripts : me.scripts};
  me.active.request = Ext.Ajax.request(options);
  me.setOptions(me.active, options);
}, setOptions:function(active, options) {
  active.rendererScope = options.rendererScope || this.rendererScope || this;
}, onComplete:function(options, success, response) {
  var me = this, active = me.active, rendererScope, scope;
  if (active) {
    scope = active.scope;
    rendererScope = active.rendererScope;
    if (success) {
      success = me.getRenderer(active.renderer).call(rendererScope, me, response, active) !== false;
    }
    if (success) {
      Ext.callback(active.success, scope, [me, response, options]);
      me.fireEvent('load', me, response, options);
    } else {
      Ext.callback(active.failure, scope, [me, response, options]);
      me.fireEvent('exception', me, response, options);
    }
    Ext.callback(active.callback, scope, [me, success, response, options]);
    if (active.mask) {
      me.removeMask();
    }
  }
  delete me.active;
}, getRenderer:function(renderer) {
  if (Ext.isFunction(renderer)) {
    return renderer;
  }
  return this.statics().Renderer.Html;
}, startAutoRefresh:function(interval, options) {
  var me = this;
  me.stopAutoRefresh();
  me.autoRefresh = Ext.interval(function() {
    me.load(options);
  }, interval);
}, stopAutoRefresh:function() {
  Ext.uninterval(this.autoRefresh);
  this.autoRefresh = null;
}, isAutoRefreshing:function() {
  return !!this.autoRefresh;
}, destroy:function() {
  var me = this;
  me.stopAutoRefresh();
  me.abort();
  me.callParent();
}}, 1, 0, 0, 0, 0, [[Ext.util.Observable.prototype.mixinId || Ext.util.Observable.$className, Ext.util.Observable]], [Ext, 'ElementLoader'], 0);
Ext.cmd.derive('Ext.ComponentLoader', Ext.ElementLoader, {statics:{Renderer:{Data:function(loader, response, active) {
  var success = true;
  try {
    loader.getTarget().update(Ext.decode(response.responseText));
  } catch (e$34) {
    success = false;
  }
  return success;
}, Component:function(loader, response, active) {
  var success = true, target = loader.getTarget(), items = [];
  try {
    items = Ext.decode(response.responseText);
  } catch (e$35) {
    success = false;
  }
  if (success) {
    target.suspendLayouts();
    if (active.removeAll) {
      target.removeAll();
    }
    target.add(items);
    target.resumeLayouts(true);
  }
  return success;
}}}, target:null, loadOnRender:false, loadMask:false, renderer:'html', setTarget:function(target) {
  var me = this;
  if (Ext.isString(target)) {
    target = Ext.getCmp(target);
  }
  if (me.target && me.target !== target) {
    me.abort();
  }
  me.target = target;
  if (target && me.loadOnRender) {
    if (target.rendered) {
      me.doLoadOnRender();
    } else {
      me.mon(target, 'render', me.doLoadOnRender, me);
    }
  }
}, doLoadOnRender:function() {
  var loadOnRender = this.loadOnRender;
  this.load(Ext.isObject(loadOnRender) ? loadOnRender : null);
}, removeMask:function() {
  this.target.setLoading(false);
}, addMask:function(mask) {
  this.target.setLoading(mask);
}, setOptions:function(active, options) {
  active.removeAll = Ext.isDefined(options.removeAll) ? options.removeAll : this.removeAll;
  active.rendererScope = options.rendererScope || this.rendererScope || this.target;
}, getRenderer:function(renderer) {
  if (Ext.isFunction(renderer)) {
    return renderer;
  }
  var renderers = this.statics().Renderer;
  switch(renderer) {
    case 'component':
      return renderers.Component;
    case 'data':
      return renderers.Data;
    default:
      return Ext.ElementLoader.Renderer.Html;
  }
}}, 0, 0, 0, 0, 0, 0, [Ext, 'ComponentLoader'], 0);
Ext.cmd.derive('Ext.layout.SizeModel', Ext.Base, {constructor:function(config) {
  var me = this, SizeModel = me.self, sizeModelsArray = SizeModel.sizeModelsArray, name;
  Ext.apply(me, config);
  me[name = me.name] = true;
  me.fixed = !(me.auto = me.natural || me.shrinkWrap);
  sizeModelsArray[me.ordinal = sizeModelsArray.length] = SizeModel[name] = SizeModel.sizeModels[name] = me;
}, statics:{sizeModelsArray:[], sizeModels:{}}, calculated:false, configured:false, constrainedMax:false, constrainedMin:false, natural:false, shrinkWrap:false, calculatedFromConfigured:false, calculatedFromNatural:false, calculatedFromShrinkWrap:false, names:null}, 1, 0, 0, 0, 0, 0, [Ext.layout, 'SizeModel'], function() {
  var SizeModel = this, sizeModelsArray = SizeModel.sizeModelsArray, i, j, n, pairs, sizeModel;
  new SizeModel({name:'calculated'});
  new SizeModel({name:'configured', names:{width:'width', height:'height'}});
  new SizeModel({name:'natural'});
  new SizeModel({name:'shrinkWrap'});
  new SizeModel({name:'calculatedFromConfigured', configured:true, calculatedFrom:true, names:{width:'width', height:'height'}});
  new SizeModel({name:'calculatedFromNatural', natural:true, calculatedFrom:true});
  new SizeModel({name:'calculatedFromShrinkWrap', shrinkWrap:true, calculatedFrom:true});
  new SizeModel({name:'constrainedMax', configured:true, constrained:true, names:{width:'maxWidth', height:'maxHeight'}});
  new SizeModel({name:'constrainedMin', configured:true, constrained:true, names:{width:'minWidth', height:'minHeight'}});
  new SizeModel({name:'constrainedDock', configured:true, constrained:true, constrainedByMin:true, names:{width:'dockConstrainedWidth', height:'dockConstrainedHeight'}});
  for (i = 0, n = sizeModelsArray.length; i < n; ++i) {
    sizeModel = sizeModelsArray[i];
    sizeModel.pairsByHeightOrdinal = pairs = [];
    for (j = 0; j < n; ++j) {
      pairs.push({width:sizeModel, height:sizeModelsArray[j], ordinal:j});
    }
  }
});
Ext.cmd.derive('Ext.layout.Layout', Ext.Base, {factoryConfig:{type:'layout', defaultType:'autocontainer', instanceProp:'isLayout'}, isLayout:true, initialized:false, running:false, needsItemSize:true, setsItemSize:true, autoSizePolicy:{readsWidth:1, readsHeight:1, setsWidth:0, setsHeight:0}, $configPrefixed:false, $configStrict:false, constructor:function(config) {
  var me = this;
  me.id = Ext.id(null, me.type + '-');
  me.initConfig(config);
  delete me.type;
  me.layoutCount = 0;
}, beginLayout:Ext.emptyFn, beginLayoutCycle:function(ownerContext) {
  var me = this, context = me.context, changed;
  if (me.lastWidthModel !== ownerContext.widthModel) {
    if (me.lastWidthModel) {
      changed = true;
    }
    me.lastWidthModel = ownerContext.widthModel;
  }
  if (me.lastHeightModel !== ownerContext.heightModel) {
    if (me.lastWidthModel) {
      changed = true;
    }
    me.lastHeightModel = ownerContext.heightModel;
  }
  if (changed) {
    (context = ownerContext.context).clearTriggers(me, false);
    context.clearTriggers(me, true);
    me.triggerCount = 0;
  }
}, finishedLayout:function(ownerContext) {
  this.lastWidthModel = ownerContext.widthModel;
  this.lastHeightModel = ownerContext.heightModel;
  this.ownerContext = null;
}, redoLayout:Ext.emptyFn, undoLayout:Ext.emptyFn, getAnimatePolicy:function() {
  return this.animatePolicy;
}, getItemSizePolicy:function(item) {
  return this.autoSizePolicy;
}, isItemBoxParent:function(itemContext) {
  return false;
}, isItemLayoutRoot:function(item) {
  var sizeModel = item.getSizeModel(), width = sizeModel.width, height = sizeModel.height;
  if (!item.componentLayout.lastComponentSize && (width.calculated || height.calculated)) {
    return false;
  }
  return !width.shrinkWrap && !height.shrinkWrap;
}, isItemShrinkWrap:function(item) {
  return item.shrinkWrap;
}, isRunning:function() {
  return !!this.ownerContext;
}, getItemsRenderTree:function(items, renderCfgs) {
  var length = items.length, i, item, itemConfig, result;
  if (length) {
    result = [];
    for (i = 0; i < length; ++i) {
      item = items[i];
      if (!item.rendered) {
        if (renderCfgs && renderCfgs[item.id] !== undefined) {
          itemConfig = renderCfgs[item.id];
        } else {
          this.configureItem(item);
          itemConfig = item.getRenderTree();
          if (renderCfgs) {
            renderCfgs[item.id] = itemConfig;
          }
        }
        if (itemConfig) {
          result.push(itemConfig);
        }
      }
    }
  }
  return result;
}, finishRender:Ext.emptyFn, finishRenderItems:function(target, items) {
  var length = items.length, i, item;
  for (i = 0; i < length; i++) {
    item = items[i];
    if (item.rendering) {
      item.finishRender(i);
    }
  }
}, renderChildren:function() {
  var me = this, items = me.getLayoutItems(), target = me.getRenderTarget();
  me.renderItems(items, target);
}, renderItems:function(items, target) {
  var me = this, ln = items.length, i = 0, pos = 0, item;
  if (ln) {
    Ext.suspendLayouts();
    for (; i < ln; i++, pos++) {
      item = items[i];
      if (item && !item.rendered) {
        me.renderItem(item, target, pos);
      } else {
        if (item.ignoreDomPosition) {
          --pos;
        } else {
          if (!me.isValidParent(item, target, pos)) {
            me.moveItem(item, target, pos);
          } else {
            me.configureItem(item);
          }
        }
      }
    }
    Ext.resumeLayouts(true);
  }
}, isValidParent:function(item, target, position) {
  var targetDom = target && target.dom || target, itemDom = this.getItemLayoutEl(item);
  if (itemDom && targetDom) {
    if (typeof position === 'number') {
      position = this.getPositionOffset(position);
      return itemDom === targetDom.childNodes[position];
    }
    return itemDom.parentNode === targetDom;
  }
  return false;
}, getItemLayoutEl:function(item) {
  var dom = item.el ? item.el.dom : Ext.getDom(item), parentNode = dom.parentNode, className;
  if (parentNode) {
    className = parentNode.className;
    if (className && className.indexOf('x-resizable-wrap') !== -1) {
      dom = dom.parentNode;
    }
  }
  return dom;
}, getPositionOffset:function(position) {
  return position;
}, configureItem:function(item) {
  item.ownerLayout = this;
}, renderItem:function(item, target, position) {
  var me = this;
  if (!item.rendered) {
    me.configureItem(item);
    item.render(target, position);
  }
}, moveItem:function(item, target, position) {
  var activeEl = Ext.fly(document.activeElement);
  target = target.dom || target;
  if (typeof position === 'number') {
    position = target.childNodes[position];
  }
  if (item.el.contains(activeEl)) {
    activeEl.suspendFocusEvents();
  } else {
    activeEl = null;
  }
  target.insertBefore(item.el.dom, position || null);
  item.container = Ext.get(target);
  this.configureItem(item);
  if (activeEl) {
    activeEl.focus();
    activeEl.resumeFocusEvents();
  }
}, onContentChange:function() {
  this.owner.updateLayout();
  return true;
}, initLayout:function() {
  this.initialized = true;
}, setOwner:function(owner) {
  this.owner = owner;
}, getLayoutItems:function() {
  return [];
}, onAdd:function(item) {
  item.ownerLayout = this;
}, onRemove:Ext.emptyFn, onDestroy:Ext.emptyFn, afterRemove:function(item) {
  var me = this, el = item.el, owner = me.owner, removeClasses;
  if (item.rendered) {
    removeClasses = [].concat(me.itemCls || []);
    if (owner.itemCls) {
      removeClasses = Ext.Array.push(removeClasses, owner.itemCls);
    }
    if (removeClasses.length) {
      el.removeCls(removeClasses);
    }
  }
  delete item.ownerLayout;
}, afterCollapse:function(owner, animated) {
  if (animated) {
    this.onContentChange(owner);
  }
}, afterExpand:function(owner, animated) {
  if (animated) {
    this.onContentChange(owner);
  }
}, destroy:function() {
  var me = this, target;
  if (me.targetCls) {
    target = me.getTarget();
    if (target) {
      target.removeCls(me.targetCls);
    }
  }
  if (!me.onDestroy.$emptyFn) {
    me.onDestroy();
  }
  me.callParent();
}, sortWeightedItems:function(items, reverseProp) {
  for (var i = 0, length = items.length; i < length; ++i) {
    items[i].$i = i;
  }
  Ext.Array.sort(items, function(item1, item2) {
    var ret = item2.weight - item1.weight;
    if (!ret) {
      ret = item1.$i - item2.$i;
      if (item1[reverseProp]) {
        ret = -ret;
      }
    }
    return ret;
  });
  for (i = 0; i < length; ++i) {
    delete items[i].$i;
  }
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.layout, 'Layout'], function() {
  var Layout = this;
  Layout.prototype.sizeModels = Layout.sizeModels = Ext.layout.SizeModel.sizeModels;
});
Ext.cmd.derive('Ext.layout.container.Container', Ext.layout.Layout, {alternateClassName:'Ext.layout.ContainerLayout', type:'container', beginCollapse:Ext.emptyFn, beginExpand:Ext.emptyFn, animatePolicy:null, activeItemCount:0, renderTpl:['{%this.renderBody(out,values)%}'], usesContainerHeight:true, usesContainerWidth:true, usesHeight:true, usesWidth:true, constructor:function() {
  Ext.layout.Layout.prototype.constructor.apply(this, arguments);
  this.mixins.elementCt.constructor.call(this);
}, destroy:function() {
  this.mixins.elementCt.destroy.call(this);
  Ext.layout.Layout.prototype.destroy.call(this);
}, beginLayout:function(ownerContext) {
  Ext.layout.Layout.prototype.beginLayout.apply(this, arguments);
  ownerContext.targetContext = ownerContext.paddingContext = ownerContext.getEl('getTarget', this);
  this.cacheChildItems(ownerContext);
}, beginLayoutCycle:function(ownerContext, firstCycle) {
  var me = this;
  Ext.layout.Layout.prototype.beginLayoutCycle.apply(this, arguments);
  if (firstCycle) {
    if (me.usesContainerHeight) {
      ++ownerContext.consumersContainerHeight;
    }
    if (me.usesContainerWidth) {
      ++ownerContext.consumersContainerWidth;
    }
  }
}, cacheChildItems:function(ownerContext) {
  var me = this, context, childItems, items, length, i;
  if (me.needsItemSize || me.setsItemSize) {
    context = ownerContext.context;
    childItems = ownerContext.childItems = [];
    items = ownerContext.visibleItems = me.getVisibleItems();
    length = items.length;
    for (i = 0; i < length; ++i) {
      childItems.push(context.getCmp(items[i]));
    }
  }
}, cacheElements:function() {
  var owner = this.owner;
  this.attachChildEls(owner.el, owner);
}, calculate:function(ownerContext) {
  var props = ownerContext.props, el = ownerContext.el;
  if (ownerContext.widthModel.shrinkWrap && isNaN(props.width)) {
    ownerContext.setContentWidth(el.getWidth());
  }
  if (ownerContext.heightModel.shrinkWrap && isNaN(props.height)) {
    ownerContext.setContentHeight(el.getHeight());
  }
}, configureItem:function(item) {
  var me = this, itemCls = me.itemCls, ownerItemCls = me.owner.itemCls, needsCopy, addClasses;
  item.ownerLayout = me;
  if (itemCls) {
    if (typeof itemCls === 'string') {
      addClasses = [itemCls];
    } else {
      addClasses = itemCls;
      needsCopy = !!addClasses;
    }
  }
  if (ownerItemCls) {
    if (needsCopy) {
      addClasses = Ext.Array.clone(addClasses);
    }
    addClasses = Ext.Array.push(addClasses || [], ownerItemCls);
  }
  if (addClasses) {
    item.addCls(addClasses);
  }
}, doRenderBody:function(out, renderData) {
  this.renderItems(out, renderData);
  this.renderContent(out, renderData);
}, doRenderContainer:function(out, renderData) {
  var me = renderData.$comp.layout, tpl = me.getRenderTpl(), data = me.getRenderData();
  tpl.applyOut(data, out);
}, doRenderItems:function(out, renderData) {
  var me = renderData.$layout, tree = me.getRenderTree();
  if (tree) {
    Ext.DomHelper.generateMarkup(tree, out);
  }
}, doRenderTabGuard:function(out, renderData, position) {
  var cmp = renderData.$comp, tabGuardTpl;
  if (cmp.tabGuard && !renderData.$skipTabGuards) {
    tabGuardTpl = cmp.lookupTpl('tabGuardTpl');
    if (tabGuardTpl) {
      renderData.tabGuard = position;
      renderData.tabGuardEl = cmp.tabGuardElements[position];
      cmp.addChildEl(renderData.tabGuardEl);
      tabGuardTpl.applyOut(renderData, out);
      delete renderData.tabGuard;
      delete renderData.tabGuardEl;
    }
  }
}, finishRender:function() {
  var me = this, owner = me.owner, target, items;
  Ext.layout.Layout.prototype.finishRender.call(this);
  me.cacheElements();
  target = me.getRenderTarget();
  items = me.getLayoutItems();
  me.finishRenderItems(target, items);
}, notifyOwner:function() {
  this.owner.afterLayout(this);
}, getContainerSize:function(ownerContext, inDom) {
  var targetContext = ownerContext.targetContext, frameInfo = targetContext.getFrameInfo(), padding = ownerContext.paddingContext.getPaddingInfo(), got = 0, needed = 0, gotWidth, gotHeight, width, height;
  if (!ownerContext.widthModel.shrinkWrap) {
    ++needed;
    width = inDom ? targetContext.getDomProp('width') : targetContext.getProp('width');
    gotWidth = typeof width === 'number';
    if (gotWidth) {
      ++got;
      width -= frameInfo.width + padding.width;
      if (width < 0) {
        width = 0;
      }
    }
  }
  if (!ownerContext.heightModel.shrinkWrap) {
    ++needed;
    height = inDom ? targetContext.getDomProp('height') : targetContext.getProp('height');
    gotHeight = typeof height === 'number';
    if (gotHeight) {
      ++got;
      height -= frameInfo.height + padding.height;
      if (height < 0) {
        height = 0;
      }
    }
  }
  return {width:width, height:height, needed:needed, got:got, gotAll:got === needed, gotWidth:gotWidth, gotHeight:gotHeight};
}, getPositionOffset:function(position) {
  if (!this.createsInnerCt) {
    var offset = this.owner.itemNodeOffset;
    if (offset) {
      position += offset;
    }
  }
  return position;
}, getLayoutItems:function() {
  var owner = this.owner, items = owner && owner.items;
  return items && items.items || [];
}, getRenderData:function() {
  var comp = this.owner;
  return {$comp:comp, $layout:this, ownerId:comp.id};
}, getRenderedItems:function() {
  var me = this, target = me.getRenderTarget(), items = me.getLayoutItems(), ln = items.length, renderedItems = [], i, pos, item;
  for (i = 0, pos = 0; i < ln; i++, pos++) {
    item = items[i];
    if (item.rendered) {
      if (item.ignoreDomPosition) {
        --pos;
      } else {
        if (!this.isValidParent(item, target, pos)) {
          continue;
        }
      }
      renderedItems.push(item);
    }
  }
  return renderedItems;
}, getRenderTarget:function() {
  return this.owner.getTargetEl();
}, getElementTarget:function() {
  return this.getRenderTarget();
}, getRenderTpl:function() {
  var me = this, renderTpl = Ext.XTemplate.getTpl(this, 'renderTpl');
  if (!renderTpl.renderContent) {
    me.owner.setupRenderTpl(renderTpl);
  }
  return renderTpl;
}, getRenderTree:function() {
  var result, items = this.owner.items, itemsGen, renderCfgs = {};
  do {
    itemsGen = items.generation;
    result = this.getItemsRenderTree(this.getLayoutItems(), renderCfgs);
  } while (items.generation !== itemsGen);
  return result;
}, renderChildren:function() {
  var me = this, ownerItems = me.owner.items, target = me.getRenderTarget(), itemsGen, items;
  do {
    itemsGen = ownerItems.generation;
    items = me.getLayoutItems();
    me.renderItems(items, target);
  } while (ownerItems.generation !== itemsGen);
}, getScrollbarsNeeded:function(width, height, contentWidth, contentHeight) {
  var scrollbarSize = Ext.getScrollbarSize(), hasWidth = typeof width === 'number', hasHeight = typeof height === 'number', needHorz = 0, needVert = 0;
  if (!scrollbarSize.width) {
    return 0;
  }
  if (hasHeight && height < contentHeight) {
    needVert = 2;
    width -= scrollbarSize.width;
  }
  if (hasWidth && width < contentWidth) {
    needHorz = 1;
    if (!needVert && hasHeight) {
      height -= scrollbarSize.height;
      if (height < contentHeight) {
        needVert = 2;
      }
    }
  }
  return needVert + needHorz;
}, getTarget:function() {
  return this.owner.getTargetEl();
}, getVisibleItems:function() {
  var target = this.getRenderTarget(), items = this.getLayoutItems(), ln = items.length, visibleItems = [], i, pos, item;
  for (i = 0, pos = 0; i < ln; i++, pos++) {
    item = items[i];
    if (item.rendered && item.hidden !== true && !item.floated) {
      if (item.ignoreDomPosition) {
        --pos;
      } else {
        if (!this.isValidParent(item, target, pos)) {
          continue;
        }
      }
      visibleItems.push(item);
    }
  }
  return visibleItems;
}, getMoveAfterIndex:function(after) {
  return this.owner.items.indexOf(after) + 1;
}, moveItemBefore:function(item, before) {
  var owner = this.owner, items = owner.items, index = items.indexOf(item), toIndex;
  if (item === before) {
    return item;
  }
  if (before) {
    toIndex = items.indexOf(before);
    if (index > -1 && index < toIndex) {
      --toIndex;
    }
  } else {
    toIndex = items.length;
  }
  return owner.insert(toIndex, item);
}, setupRenderTpl:function(renderTpl) {
  renderTpl.renderBody = this.doRenderBody;
  renderTpl.renderContainer = this.doRenderContainer;
  renderTpl.renderItems = this.doRenderItems;
  renderTpl.renderTabGuard = this.doRenderTabGuard;
}, getContentTarget:function() {
  return this.owner.getDefaultContentTarget();
}, onAdd:function(item) {
  if (!item.liquidLayout) {
    ++this.activeItemCount;
  }
  Ext.layout.Layout.prototype.onAdd.call(this, item);
}, onRemove:function(item, isDestroying) {
  if (!item.liquidLayout) {
    --this.activeItemCount;
  }
  Ext.layout.Layout.prototype.onRemove.call(this, item, isDestroying);
}}, 1, 0, 0, 0, ['layout.container'], [[Ext.util.ElementContainer.prototype.mixinId || Ext.util.ElementContainer.$className, Ext.util.ElementContainer]], [Ext.layout.container, 'Container', Ext.layout, 'ContainerLayout'], 0);
Ext.cmd.derive('Ext.layout.container.Auto', Ext.layout.container.Container, {type:'autocontainer', childEls:['outerCt', 'innerCt'], reserveScrollbar:false, managePadding:true, manageOverflow:false, needsItemSize:false, setsItemSize:false, lastOverflowAdjust:{width:0, height:0}, outerCtCls:'x-autocontainer-outerCt', innerCtCls:'x-autocontainer-innerCt', renderTpl:['\x3cdiv id\x3d"{ownerId}-outerCt" data-ref\x3d"outerCt" class\x3d"{outerCtCls}" role\x3d"presentation"\x3e', '\x3cdiv id\x3d"{ownerId}-innerCt" data-ref\x3d"innerCt" style\x3d"{%this.renderPadding(out, values)%}" ', 
'\x3ctpl if\x3d"!$comp.html"\x3erole\x3d"presentation"\x3c/tpl\x3e', 'class\x3d"{innerCtCls}"\x3e', '{%this.renderBody(out,values)%}', '\x3c/div\x3e', '\x3c/div\x3e'], beginLayout:function(ownerContext) {
  Ext.layout.container.Container.prototype.beginLayout.apply(this, arguments);
  this.initContextItems(ownerContext);
}, beforeLayoutCycle:function(ownerContext) {
  var comp = this.owner, inheritedState = comp.inheritedState, inheritedStateInner = comp.inheritedStateInner;
  if (!inheritedState || inheritedState.invalid) {
    inheritedState = comp.getInherited();
    inheritedStateInner = comp.inheritedStateInner;
  }
  if (ownerContext.widthModel.shrinkWrap) {
    inheritedStateInner.inShrinkWrapTable = true;
  } else {
    delete inheritedStateInner.inShrinkWrapTable;
  }
}, beginLayoutCycle:function(ownerContext) {
  var me = this, outerCt = me.outerCt, lastOuterCtWidth = me.lastOuterCtWidth || '', lastOuterCtHeight = me.lastOuterCtHeight || '', lastOuterCtTableLayout = me.lastOuterCtTableLayout || '', state = ownerContext.state, overflowXStyle, outerCtWidth, outerCtHeight, outerCtTableLayout, inheritedStateInner;
  Ext.layout.container.Container.prototype.beginLayoutCycle.apply(this, arguments);
  outerCtWidth = outerCtHeight = outerCtTableLayout = '';
  if (!ownerContext.widthModel.shrinkWrap) {
    outerCtWidth = '100%';
    inheritedStateInner = me.owner.inheritedStateInner;
    overflowXStyle = me.getOverflowXStyle(ownerContext);
    outerCtTableLayout = inheritedStateInner.inShrinkWrapTable || overflowXStyle === 'auto' || overflowXStyle === 'scroll' ? '' : 'fixed';
  }
  if (!ownerContext.heightModel.shrinkWrap && !Ext.supports.PercentageHeightOverflowBug) {
    outerCtHeight = '100%';
  }
  if (outerCtWidth !== lastOuterCtWidth || me.hasOuterCtPxWidth) {
    outerCt.setStyle('width', outerCtWidth);
    me.lastOuterCtWidth = outerCtWidth;
    me.hasOuterCtPxWidth = false;
  }
  if (outerCtTableLayout !== lastOuterCtTableLayout) {
    outerCt.setStyle('table-layout', outerCtTableLayout);
    me.lastOuterCtTableLayout = outerCtTableLayout;
  }
  if (outerCtHeight !== lastOuterCtHeight || me.hasOuterCtPxHeight) {
    outerCt.setStyle('height', outerCtHeight);
    me.lastOuterCtHeight = outerCtHeight;
    me.hasOuterCtPxHeight = false;
  }
  if (me.hasInnerCtPxHeight) {
    me.innerCt.setStyle('height', '');
    me.hasInnerCtPxHeight = false;
  }
  state.overflowAdjust = state.overflowAdjust || me.lastOverflowAdjust;
}, calculate:function(ownerContext) {
  var me = this, state = ownerContext.state, containerSize = me.getContainerSize(ownerContext, true), calculatedItems = state.calculatedItems || (state.calculatedItems = me.calculateItems ? me.calculateItems(ownerContext, containerSize) : true);
  me.setCtSizeIfNeeded(ownerContext, containerSize);
  if (calculatedItems && ownerContext.hasDomProp('containerChildrenSizeDone')) {
    me.calculateContentSize(ownerContext);
    if (containerSize.gotAll) {
      if (me.manageOverflow && !ownerContext.state.secondPass && !me.reserveScrollbar) {
        me.calculateOverflow(ownerContext, containerSize);
      }
      return;
    }
  }
  me.done = false;
}, calculateContentSize:function(ownerContext) {
  var me = this, containerDimensions = (ownerContext.widthModel.shrinkWrap ? 1 : 0) | (ownerContext.heightModel.shrinkWrap ? 2 : 0), calcWidth = containerDimensions & 1 || undefined, calcHeight = containerDimensions & 2 || undefined, needed = 0, props = ownerContext.props;
  if (calcWidth) {
    if (isNaN(props.contentWidth)) {
      ++needed;
    } else {
      calcWidth = undefined;
    }
  }
  if (calcHeight) {
    if (isNaN(props.contentHeight)) {
      ++needed;
    } else {
      calcHeight = undefined;
    }
  }
  if (needed) {
    if (calcWidth && !ownerContext.setContentWidth(me.measureContentWidth(ownerContext))) {
      me.done = false;
    }
    if (calcHeight && !ownerContext.setContentHeight(me.measureContentHeight(ownerContext))) {
      me.done = false;
    }
  }
}, calculateOverflow:function(ownerContext) {
  var me = this, width, height, scrollbarSize, scrollbars, xauto, yauto, targetEl;
  xauto = me.getOverflowXStyle(ownerContext) === 'auto';
  yauto = me.getOverflowYStyle(ownerContext) === 'auto';
  if (xauto || yauto) {
    scrollbarSize = Ext.getScrollbarSize();
    targetEl = ownerContext.overflowContext.el.dom;
    scrollbars = 0;
    if (targetEl.scrollWidth > targetEl.clientWidth) {
      scrollbars |= 1;
    }
    if (targetEl.scrollHeight > targetEl.clientHeight) {
      scrollbars |= 2;
    }
    width = yauto && scrollbars & 2 ? scrollbarSize.width : 0;
    height = xauto && scrollbars & 1 ? scrollbarSize.height : 0;
    if (width !== me.lastOverflowAdjust.width || height !== me.lastOverflowAdjust.height) {
      me.done = false;
      ownerContext.invalidate({state:{overflowAdjust:{width:width, height:height}, overflowState:scrollbars, secondPass:true}});
    }
  }
}, completeLayout:function(ownerContext) {
  this.lastOverflowAdjust = ownerContext.state.overflowAdjust;
}, doRenderBody:function(out, renderData) {
  var me = renderData.$layout, XTemplate = Ext.XTemplate, beforeBodyTpl = me.beforeBodyTpl, afterBodyTpl = me.afterBodyTpl;
  if (beforeBodyTpl) {
    XTemplate.getTpl(me, 'beforeBodyTpl').applyOut(renderData, out);
  }
  this.renderItems(out, renderData);
  this.renderContent(out, renderData);
  if (afterBodyTpl) {
    XTemplate.getTpl(me, 'afterBodyTpl').applyOut(renderData, out);
  }
}, doRenderPadding:function(out, renderData) {
  var me = renderData.$layout, owner = renderData.$layout.owner, padding = owner[owner.contentPaddingProperty];
  if (me.managePadding && padding) {
    out.push('padding:', owner.unitizeBox(padding));
  }
}, finishedLayout:function(ownerContext) {
  var innerCt = this.innerCt;
  Ext.layout.container.Container.prototype.finishedLayout.apply(this, arguments);
  if (Ext.isIE8) {
    innerCt.repaint();
  }
  if (Ext.isOpera) {
    innerCt.setStyle('position', 'relative');
    innerCt.dom.scrollWidth;
    innerCt.setStyle('position', '');
  }
}, getContainerSize:function(ownerContext, inDom) {
  var size = Ext.layout.container.Container.prototype.getContainerSize.apply(this, arguments), overflowAdjust = ownerContext.state.overflowAdjust;
  if (overflowAdjust) {
    size.width -= overflowAdjust.width;
    size.height -= overflowAdjust.height;
  }
  return size;
}, getRenderData:function() {
  var me = this, data = Ext.layout.container.Container.prototype.getRenderData.call(this);
  data.innerCtCls = me.innerCtCls;
  data.outerCtCls = me.outerCtCls;
  return data;
}, getRenderTarget:function() {
  return this.innerCt;
}, getElementTarget:function() {
  return this.innerCt;
}, getOverflowXStyle:function(ownerContext) {
  return ownerContext.overflowXStyle || (ownerContext.overflowXStyle = this.owner.scrollFlags.overflowX || ownerContext.overflowContext.getStyle('overflow-x'));
}, getOverflowYStyle:function(ownerContext) {
  return ownerContext.overflowYStyle || (ownerContext.overflowYStyle = this.owner.scrollFlags.overflowY || ownerContext.overflowContext.getStyle('overflow-y'));
}, initContextItems:function(ownerContext) {
  var me = this, target = ownerContext.target, overflowEl = me.owner.getOverflowEl();
  ownerContext.outerCtContext = ownerContext.getEl('outerCt', me);
  ownerContext.innerCtContext = ownerContext.getEl('innerCt', me);
  ownerContext.overflowContext = overflowEl === ownerContext.el ? ownerContext : ownerContext.getEl(overflowEl);
  if (target[target.contentPaddingProperty] !== undefined) {
    ownerContext.paddingContext = ownerContext.innerCtContext;
  }
}, initLayout:function() {
  var me = this, scrollbarWidth = Ext.getScrollbarSize().width, owner = me.owner;
  Ext.layout.container.Container.prototype.initLayout.call(this);
  if (scrollbarWidth && me.manageOverflow && !me.hasOwnProperty('lastOverflowAdjust')) {
    if (owner.scrollable || me.reserveScrollbar) {
      me.lastOverflowAdjust = {width:scrollbarWidth, height:0};
    }
  }
}, measureContentHeight:function(ownerContext) {
  var contentHeight = this.outerCt.getHeight(), target = ownerContext.target;
  if (this.managePadding && target[target.contentPaddingProperty] === undefined) {
    contentHeight += ownerContext.targetContext.getPaddingInfo().height;
  }
  return contentHeight;
}, measureContentWidth:function(ownerContext) {
  var dom, style, old, contentWidth, target;
  if (this.chromeCellMeasureBug) {
    dom = this.innerCt.dom;
    style = dom.style;
    old = style.display;
    if (old === 'table-cell') {
      style.display = '';
      dom.offsetWidth;
      style.display = old;
    }
  }
  if (Ext.isSafari) {
    dom = this.outerCt.dom;
    style = dom.style;
    style.display = 'table-cell';
    dom.offsetWidth;
    dom.style.display = '';
  }
  contentWidth = this.outerCt.getWidth();
  target = ownerContext.target;
  if (this.managePadding && target[target.contentPaddingProperty] === undefined) {
    contentWidth += ownerContext.targetContext.getPaddingInfo().width;
  }
  return contentWidth;
}, setCtSizeIfNeeded:function(ownerContext, containerSize) {
  var me = this, height = containerSize.height, padding = ownerContext.paddingContext.getPaddingInfo(), targetEl = me.getTarget(), overflowXStyle = me.getOverflowXStyle(ownerContext), canOverflowX = overflowXStyle === 'auto' || overflowXStyle === 'scroll', scrollbarSize = Ext.getScrollbarSize(), needsOuterHeight, needsInnerHeight;
  if (height && !ownerContext.heightModel.shrinkWrap) {
    if (Ext.supports.PercentageHeightOverflowBug) {
      needsOuterHeight = true;
    }
    if (Ext.isIE8) {
      needsInnerHeight = true;
    }
    if ((needsOuterHeight || needsInnerHeight) && canOverflowX && targetEl.dom.scrollWidth > targetEl.dom.clientWidth) {
      height = Math.max(height - scrollbarSize.height, 0);
    }
    if (needsOuterHeight) {
      ownerContext.outerCtContext.setProp('height', height + padding.height);
      me.hasOuterCtPxHeight = true;
    }
    if (needsInnerHeight) {
      ownerContext.innerCtContext.setProp('height', height);
      me.hasInnerCtPxHeight = true;
    }
  }
}, setupRenderTpl:function(renderTpl) {
  Ext.layout.container.Container.prototype.setupRenderTpl.apply(this, arguments);
  renderTpl.renderPadding = this.doRenderPadding;
}, getContentTarget:function() {
  return this.innerCt;
}}, 0, 0, 0, 0, ['layout.auto', 'layout.autocontainer'], 0, [Ext.layout.container, 'Auto'], function(Cls) {
  var v = Ext.chromeVersion;
  Cls.prototype.chromeCellMeasureBug = Ext.isChrome && v >= 26 && v <= 34;
});
Ext.cmd.derive('Ext.ZIndexManager', Ext.Base, {alternateClassName:'Ext.WindowGroup', statics:{zBase:9000, activeCounter:0}, reflowSuspended:0, constructor:function(container) {
  var me = this;
  me.id = Ext.id(null, 'zindex-mgr-');
  me.zIndexStack = new Ext.util.Collection({sorters:{sorterFn:function(comp1, comp2) {
    var ret = (comp1.alwaysOnTop || 0) - (comp2.alwaysOnTop || 0);
    if (!ret) {
      ret = comp1.getActiveCounter() - comp2.getActiveCounter();
    }
    return ret;
  }}, filters:{filterFn:function(comp) {
    return comp.isVisible();
  }}});
  me.zIndexStack.addObserver(me);
  me.front = null;
  me.sortCount = 0;
  me.globalListeners = Ext.GlobalEvents.on({beforehide:me.onComponentShowHide, show:me.onComponentShowHide, scope:me, destroyable:true});
  if (container) {
    if (container.isContainer) {
      me.resizeListeners = container.on({resize:me.onContainerResize, scope:me, destroyable:true});
      me.zseed = Ext.Number.from(me.rendered ? container.getEl().getStyle('zIndex') : undefined, me.getNextZSeed());
      me.targetEl = container.getTargetEl();
      me.container = container;
    } else {
      me.resizeListeners = Ext.on({resize:me.onContainerResize, scope:me, destroyable:true});
      me.zseed = me.getNextZSeed();
      me.targetEl = Ext.get(container);
    }
  } else {
    me.zseed = me.getNextZSeed();
    Ext.onInternalReady(function() {
      me.resizeListeners = Ext.on({resize:me.scheduleContainerResize, scope:me, destroyable:true, priority:-10000});
      me.targetEl = Ext.getBody();
    });
  }
}, getId:function() {
  return this.id;
}, getNextZSeed:function() {
  return Ext.ZIndexManager.zBase += 10000;
}, setBase:function(baseZIndex) {
  this.zseed = baseZIndex;
  return this.onCollectionSort();
}, onCollectionSort:function() {
  var me = this, oldFront = me.front, zIndex = me.zseed, a = me.zIndexStack.getRange(), len = a.length, i, comp, topModal, topFocusable, topMost, doFocus = !oldFront || oldFront.isVisible();
  me.sortCount++;
  for (i = 0; i < len; i++) {
    comp = a[i];
    if (comp.destroying || comp.destroyed) {
      continue;
    }
    zIndex = comp.setZIndex(zIndex);
    if (!comp.hidden) {
      topMost = comp;
      if (comp.modal) {
        topModal = comp;
        topFocusable = null;
      }
      if (doFocus && (comp.isFocusable(true) && (comp.modal || comp.focusOnToFront))) {
        topFocusable = comp;
      }
    }
  }
  if (topFocusable && topFocusable !== oldFront && !topFocusable.preventFocusOnActivate) {
    topFocusable.onFocusTopmost();
  }
  if (topModal) {
    if (topModal === me.topModal) {
      me.syncModalMask(topModal);
    } else {
      me.showModalMask(topModal);
    }
  } else {
    me.hideModalMask();
  }
  if (topMost !== me.topMost) {
    if (me.topMost) {
      me.topMost.onZIndexChange(false);
    }
    if (topMost) {
      topMost.onZIndexChange(true);
    }
  }
  me.front = topFocusable;
  me.topModal = topModal;
  me.topMost = topMost;
  return zIndex;
}, onComponentUpdate:function(comp) {
  if (!this.reflowSuspended && this.zIndexStack.contains(comp)) {
    this.zIndexStack.sort();
  }
}, suspendReflow:function() {
  this.reflowSuspended++;
}, resumeReflow:function(flush) {
  if (this.reflowSuspended && !--this.reflowSuspended) {
    if (flush) {
      this.zIndexStack.sort();
    }
  }
}, onAfterComponentRender:function(comp) {
  if (!this.reflowSuspended && comp.isVisible() && comp.toFrontOnShow) {
    this.zIndexStack.itemChanged(comp, 'hidden');
    this.zIndexStack.sort();
  }
}, onComponentShowHide:function(comp) {
  var me = this, zIndexStack = me.zIndexStack, sortCount = me.sortCount;
  if (comp.isFloating() && !me.hidingAll && (zIndexStack.getSource() || zIndexStack).contains(comp)) {
    if (me.tempHidden) {
      Ext.Array.remove(me.tempHidden, comp);
    }
    zIndexStack.beginUpdate();
    if (comp.isVisible()) {
      if (comp.toFrontOnShow) {
        zIndexStack.itemChanged(comp, 'hidden');
        comp.setActiveCounter(++Ext.ZIndexManager.activeCounter);
      }
    } else {
      zIndexStack.itemChanged(comp, 'hidden');
    }
    zIndexStack.endUpdate();
    if (me.sortCount === sortCount && !me.reflowSuspended) {
      me.onCollectionSort();
    }
  }
}, register:function(comp) {
  var me = this;
  if (comp.zIndexManager) {
    comp.zIndexManager.unregister(comp);
  }
  comp.zIndexManager = me;
  if (!comp.rendered) {
    comp.on('afterrender', me.onAfterComponentRender, me, {single:true});
  }
  me.zIndexStack.add(comp);
}, unregister:function(comp) {
  var me = this;
  delete comp.zIndexManager;
  comp.un('afterrender', me.onAfterComponentRender, me);
  me.zIndexStack.remove(comp);
  me.onCollectionSort();
}, get:function(id) {
  return id.isComponent ? id : this.zIndexStack.get(id);
}, bringToFront:function(comp, preventFocus) {
  var me = this, zIndexStack = me.zIndexStack, oldFront = zIndexStack.last(), newFront, preventFocusSetting;
  comp = me.get(comp);
  if (!comp) {
    return false;
  }
  preventFocusSetting = comp.preventFocusOnActivate;
  comp.preventFocusOnActivate = preventFocus;
  comp.setActiveCounter(++Ext.ZIndexManager.activeCounter);
  comp.preventFocusOnActivate = preventFocusSetting;
  newFront = zIndexStack.last();
  return newFront === comp && newFront !== oldFront;
}, sendToBack:function(comp) {
  comp = this.get(comp);
  if (comp) {
    comp.setActiveCounter(0);
  }
  return comp || null;
}, hideAll:function() {
  var me = this, all = me.zIndexStack.getRange(), len = all.length, i;
  me.hidingAll = true;
  for (i = 0; i < len; i++) {
    all[i].hide();
  }
  me.hidingAll = false;
  me.hideModalMask();
  me.front = null;
}, hide:function() {
  var me = this, activeElement = Ext.Element.getActiveElement(), all = me.zIndexStack.getRange(), len = all.length, i, comp;
  me.focusRestoreElement = null;
  (me.tempHidden || (me.tempHidden = [])).length = 0;
  for (i = 0; i < len; i++) {
    comp = all[i];
    if (comp.isVisible()) {
      if (comp.el.contains(activeElement)) {
        me.focusRestoreElement = activeElement;
      }
      comp.el.hide();
      comp.pendingShow = comp.hidden = true;
      me.tempHidden.push(comp);
    }
  }
}, show:function() {
  var me = this, i, tempHidden = me.tempHidden, len = tempHidden ? tempHidden.length : 0, comp;
  for (i = 0; i < len; i++) {
    comp = tempHidden[i];
    comp.hidden = false;
    if (comp.pendingShow) {
      comp.el.show();
      comp.pendingShow = false;
      comp.setPosition(comp.x, comp.y);
      comp.onFloatShow();
    } else {
      comp.hide();
    }
  }
  me.tempHidden = null;
  if (me.focusRestoreElement) {
    me.focusRestoreElement.focus();
  }
}, getActive:function() {
  return this.zIndexStack.last();
}, getBy:function(fn, scope) {
  return this.zIndexStack.filterBy(fn, scope).getRange();
}, each:function(fn, scope) {
  this.zIndexStack.each(fn, scope);
}, eachBottomUp:function(fn, scope) {
  var stack = this.zIndexStack.getRange(), i, len = stack.length, comp;
  for (i = 0; i < len; i++) {
    comp = stack[i];
    if (comp.isComponent && fn.call(scope || comp, comp) === false) {
      return;
    }
  }
}, eachTopDown:function(fn, scope) {
  var stack = this.zIndexStack.getRange(), i, comp;
  for (i = stack.length; i-- > 0;) {
    comp = stack[i];
    if (comp.isComponent && fn.call(scope || comp, comp) === false) {
      return;
    }
  }
}, destroy:function() {
  var me = this, stack = me.zIndexStack.getRange(), len = stack.length, i;
  for (i = 0; i < len; i++) {
    Ext.destroy(stack[i]);
  }
  Ext.destroy(me.mask, me.maskShim, me.zIndexStack, me.globalListeners, me.resizeListeners);
  me.callParent();
}, privates:{getMaskBox:function() {
  var maskTarget = this.mask.maskTarget;
  if (maskTarget.dom === document.body) {
    return {height:Math.max(document.body.scrollHeight, Ext.dom.Element.getDocumentHeight()), width:Math.max(document.body.scrollWidth, Ext.dom.Element.getDocumentWidth()), x:0, y:0};
  } else {
    return maskTarget.getBox();
  }
}, scheduleContainerResize:function() {
  if (!this.containerResizeTimer) {
    this.containerResizeTimer = Ext.raf(this.onContainerResize, this);
  }
}, onContainerResize:function() {
  var me = this, mask = me.mask, maskShim = me.maskShim, viewSize;
  me.containerResizeTimer = null;
  if (mask && mask.isVisible()) {
    mask.hide();
    if (maskShim) {
      maskShim.hide();
    }
    viewSize = me.getMaskBox();
    if (maskShim) {
      maskShim.setSize(viewSize);
      maskShim.show();
    }
    mask.setSize(viewSize);
    mask.show();
  }
}, onMaskMousedown:function(e) {
  if (this.topModal) {
    this.topModal.focus();
    e.preventDefault();
  }
}, onMaskClick:function() {
  var front = this.topModal, methodName;
  if (front) {
    if (!front.hasListeners.maskclick || front.fireEvent('maskclick', front) !== false) {
      methodName = front.maskClickAction || 'focus';
      front[methodName]();
    }
  }
}, showModalMask:function(comp) {
  var me = this, compEl = comp.el, maskTarget = comp.floatParent ? comp.floatParent.getEl() : comp.container, mask = me.mask;
  if (!mask) {
    me.mask = mask = Ext.getBody().createChild({role:'presentation', cls:'x-mask x-border-box', style:'height:0;width:0'});
    mask.setVisibilityMode(Ext.Element.DISPLAY);
    mask.on({mousedown:me.onMaskMousedown, click:me.onMaskClick, scope:me});
  } else {
    me.hideModalMask();
  }
  mask.maskTarget = maskTarget;
  maskTarget.saveTabbableState({excludeRoot:compEl});
  me.syncModalMask(comp);
}, syncModalMask:function(comp) {
  var me = this, zIndex = comp.el.getZIndex() - 4, mask = me.mask, shim = me.maskShim, viewSize = me.getMaskBox();
  if (shim) {
    shim.setZIndex(zIndex);
    shim.show();
    shim.setBox(viewSize);
  }
  mask.setZIndex(zIndex);
  mask.show();
  mask.setBox(viewSize);
}, hideModalMask:function() {
  var mask = this.mask, maskShim = this.maskShim;
  if (mask && mask.isVisible()) {
    mask.maskTarget.restoreTabbableState();
    mask.maskTarget = undefined;
    mask.hide();
    if (maskShim) {
      maskShim.hide();
    }
  }
}}}, 1, 0, 0, 0, 0, 0, [Ext, 'ZIndexManager', Ext, 'WindowGroup'], function() {
  Ext.WindowManager = Ext.WindowMgr = new this;
});
Ext.cmd.derive('Ext.container.Container', Ext.Component, {alternateClassName:['Ext.Container', 'Ext.AbstractContainer'], renderTpl:'\x3ctpl if\x3d"hasTabGuard"\x3e{% this.renderTabGuard(out, values, \'before\'); %}\x3c/tpl\x3e{% this.renderContainer(out,values) %}\x3ctpl if\x3d"hasTabGuard"\x3e{% this.renderTabGuard(out, values, \'after\'); %}\x3c/tpl\x3e', config:{actions:null}, autoDestroy:true, defaultType:'panel', detachOnRemove:true, items:undefined, layout:'auto', suspendLayout:false, tabGuardTpl:'\x3cspan id\x3d"{id}-{tabGuardEl}" data-ref\x3d"{tabGuardEl}" aria-hidden\x3d"true" class\x3d"x-tab-guard x-tab-guard-{tabGuardPosition}" style\x3d"width:0px;height:0px;"\x3e\x3c/span\x3e', 
tabGuardElements:{before:'tabGuardBeforeEl', after:'tabGuardAfterEl'}, _applyDefaultsOptions:{defaults:true, strict:false}, ariaRole:'presentation', baseCls:'x-container', layoutCounter:0, add:function() {
  var me = this, args = Ext.Array.slice(arguments), index = typeof args[0] === 'number' ? args.shift() : -1, layout = me.getLayout(), needsLayout = false, addingArray, items, i, length, item, pos, ret, instanced;
  if (args.length === 1 && Ext.isArray(args[0])) {
    items = args[0];
    addingArray = true;
  } else {
    items = args;
  }
  if (me.rendered) {
    Ext.suspendLayouts();
  }
  ret = items = me.prepareItems(items, true);
  length = items.length;
  if (!addingArray && length === 1) {
    ret = items[0];
  }
  for (i = 0; i < length; i++) {
    item = items[i];
    pos = index < 0 ? me.items.length : index + i;
    instanced = !!item.instancedCmp;
    delete item.instancedCmp;
    if (item.floating) {
      (me.floatingItems || (me.floatingItems = new Ext.util.ItemCollection)).add(item);
      item.onAdded(me, pos, instanced);
      delete item.$initParent;
      if (me.hasListeners.add) {
        me.fireEvent('add', me, item, pos);
      }
    } else {
      if ((!me.hasListeners.beforeadd || me.fireEvent('beforeadd', me, item, pos) !== false) && me.onBeforeAdd(item) !== false) {
        me.items.insert(pos, item);
        item.onAdded(me, pos, instanced);
        delete item.$initParent;
        if (me.focusableContainer) {
          me.onFocusableChildAdd(item);
        }
        me.onAdd(item, pos);
        layout.onAdd(item, pos);
        needsLayout = true;
        if (me.hasListeners.add) {
          me.fireEvent('add', me, item, pos);
        }
      }
    }
    item.isLayoutMoving = false;
  }
  if (needsLayout) {
    me.updateLayout();
  }
  if (me.rendered) {
    if (length && me.focusableContainer) {
      me.$initFocusableContainerAfterLayout = true;
    }
    Ext.resumeLayouts(true);
  }
  return ret;
}, onAdded:function(container, pos, instanced) {
  Ext.Component.prototype.onAdded.call(this, container, pos, instanced);
  this.containerOnAdded(container, instanced);
}, onRemoved:function(destroying) {
  this.containerOnRemoved(destroying);
  Ext.Component.prototype.onRemoved.apply(this, arguments);
}, afterComponentLayout:function() {
  var floaters = this.floatingItems, floaterCount, i, floater;
  Ext.Component.prototype.afterComponentLayout.apply(this, arguments);
  if (floaters) {
    floaters = floaters.items;
    floaterCount = floaters.length;
    for (i = 0; i < floaterCount; i++) {
      floater = floaters[i];
      if (!floater.rendered && floater.autoShow) {
        floater.show();
      }
    }
  }
}, afterLayout:function(layout) {
  var me = this;
  ++me.layoutCounter;
  if (me.hasListeners.afterlayout) {
    me.fireEvent('afterlayout', me, layout);
  }
  if (me.focusableContainer && me.$initFocusableContainerAfterLayout) {
    me.initFocusableContainer();
  }
  delete me.$initFocusableContainerAfterLayout;
}, doDestroy:function() {
  var me = this, items = me.items, floatingItems = me.floatingItems, c;
  if (me.focusableContainer) {
    me.destroyFocusableContainer();
  }
  if (items) {
    while (c = items.first()) {
      me.doRemove(c, true);
    }
    items.destroy();
    me.items = null;
  }
  if (floatingItems) {
    while (c = floatingItems.first()) {
      me.doRemove(c, true);
    }
    floatingItems.destroy();
    me.floatingItems = null;
  }
  Ext.destroy(me.layout);
  Ext.Component.prototype.doDestroy.call(this);
}, beforeRender:function() {
  var me = this, layout = me.getLayout(), targetCls;
  me.preventChildDisable = true;
  Ext.Component.prototype.beforeRender.call(this);
  me.preventChildDisable = false;
  if (!layout.initialized) {
    layout.initLayout();
  }
  targetCls = layout.targetCls;
  if (targetCls) {
    me.applyTargetCls(targetCls);
  }
}, cascade:function(fn, scope, origArgs) {
  var me = this, cs = me.items ? me.items.items : [], len = cs.length, i = 0, c, args = origArgs ? origArgs.concat(me) : [me], componentIndex = args.length - 1;
  if (fn.apply(scope || me, args) !== false) {
    for (; i < len; i++) {
      c = cs[i];
      if (c.cascade) {
        c.cascade(fn, scope, origArgs);
      } else {
        args[componentIndex] = c;
        fn.apply(scope || c, args);
      }
    }
  }
  return this;
}, contains:function(comp, deep) {
  var result = false;
  if (deep) {
    this.cascade(function(c) {
      if (c.contains && c.contains(comp)) {
        result = true;
        return false;
      }
    });
    return result;
  } else {
    return this.items.contains(comp) || this.floatingItems && this.floatingItems.contains(comp);
  }
}, disable:function(silent, fromParent) {
  var me = this, wasDisabled = me.disabled, itemsToDisable, len, i;
  Ext.Component.prototype.disable.call(this, silent, fromParent);
  if (!fromParent && !me.preventChildDisable && !wasDisabled) {
    itemsToDisable = me.getChildItemsToDisable();
    len = itemsToDisable.length;
    for (i = 0; i < len; i++) {
      itemsToDisable[i].disable(silent, true);
    }
  }
  if (me.focusableContainer) {
    me.activateFocusableContainer(false);
  }
  return me;
}, enable:function(silent, fromParent) {
  var me = this, wasDisabled = me.disabled, itemsToDisable, len, i;
  Ext.Component.prototype.enable.call(this, silent, fromParent);
  if (wasDisabled) {
    itemsToDisable = me.getChildItemsToDisable();
    len = itemsToDisable.length;
    for (i = 0; i < len; i++) {
      itemsToDisable[i].enable(silent, true);
    }
  }
  if (me.focusableContainer) {
    me.activateFocusableContainer(true);
  }
  return me;
}, getChildByElement:function(el, deep) {
  var item, itemEl, i = 0, it = this.getRefItems(), ln = it.length;
  el = Ext.getDom(el);
  for (; i < ln; i++) {
    item = it[i];
    itemEl = item.getEl();
    if (itemEl && (itemEl.dom === el || itemEl.contains(el))) {
      return deep && item.getChildByElement ? item.getChildByElement(el, deep) : item;
    }
  }
  return null;
}, getComponent:function(comp) {
  if (Ext.isObject(comp)) {
    comp = comp.getItemId();
  }
  var c = this.items.get(comp), floaters = this.floatingItems;
  if (!c && floaters && typeof comp !== 'number') {
    c = floaters.get(comp);
  }
  return c;
}, getFocusEl:function() {
  var delegate = this.getDefaultFocus();
  if (delegate) {
    return delegate;
  } else {
    if (this.focusable) {
      return this.getTargetEl();
    }
  }
  return undefined;
}, getLayout:function() {
  var me = this, layout = me.layout;
  if (!layout || !layout.isLayout) {
    me.setLayout(layout);
  }
  return me.layout;
}, getRefItems:function(deep) {
  var me = this, items = me.items.items, len = items.length, i = 0, item, result = [];
  for (; i < len; i++) {
    item = items[i];
    result[result.length] = item;
    if (deep && item.getRefItems) {
      result.push.apply(result, item.getRefItems(true));
    }
  }
  if (me.floatingItems) {
    items = me.floatingItems.items;
    len = items.length;
    for (i = 0; i < len; i++) {
      item = items[i];
      result[result.length] = item;
      if (deep && item.getRefItems) {
        result.push.apply(result, item.getRefItems(true));
      }
    }
  }
  return result;
}, getDefaultFocus:function() {
  var defaultFocus = this.defaultFocus, result;
  if (defaultFocus && !this.isConfiguring) {
    result = this.down(defaultFocus);
  }
  return result;
}, setDefaultFocus:function(value) {
  this.defaultFocus = value;
}, initComponent:function() {
  var me = this;
  Ext.Component.prototype.initComponent.call(this);
  me.getLayout();
  me.constructing = true;
  me.initItems();
  if (me.disabled) {
    me.disabled = false;
    me.disable(true);
  }
  me.reference = me.setupReference(me.reference);
  delete me.constructing;
}, initItems:function() {
  var me = this, items = me.items;
  if (!items || !items.isMixedCollection) {
    me.items = new Ext.util.ItemCollection;
    if (items) {
      if (!Ext.isArray(items)) {
        items = [items];
      }
      me.$initingItems = true;
      me.add(items);
      delete me.$initingItems;
    }
  }
}, initInheritedState:function(inheritedState, inheritedStateInner) {
  var me = this, layout = me.layout;
  Ext.Component.prototype.initInheritedState.call(this, inheritedState, inheritedStateInner);
  if (me.collapsed) {
    inheritedState.collapsed = true;
  }
  me.initContainerInheritedState(inheritedState, inheritedStateInner);
  if (layout && layout.initInheritedState) {
    layout.initInheritedState(inheritedState, inheritedStateInner);
  }
}, insert:function(index, component) {
  var compIdx;
  if (component && component.isComponent) {
    compIdx = this.items.indexOf(component);
    if (compIdx !== -1) {
      return this.move(compIdx, index);
    }
  }
  return this.add(index, component);
}, lookupComponent:function(comp) {
  var me = this, defaultType = me.defaultType, wasAction;
  if (!comp.isComponent) {
    if (typeof comp === 'string') {
      if (!(wasAction = comp[0] === '@')) {
        return Ext.ComponentManager.get(comp);
      }
      comp = me.getAction(comp.substr(1));
      defaultType = me.defaultActionType || defaultType;
    }
    comp = Ext.ComponentManager.create(comp, defaultType);
    if (wasAction) {
      comp.instancedCmp = true;
    }
  }
  return comp;
}, move:function(fromIdx, toIdx) {
  var me = this, items = me.items, item;
  if (fromIdx.isComponent) {
    fromIdx = items.indexOf(fromIdx);
  }
  item = items.getAt(fromIdx);
  if (fromIdx !== toIdx) {
    item = items.removeAt(fromIdx);
    if (item === false) {
      return false;
    }
    toIdx = Math.min(toIdx, items.getCount());
    items.insert(toIdx, item);
    me.onMove(item, fromIdx, toIdx);
    if (me.hasListeners.childmove) {
      me.fireEvent('childmove', me, item, fromIdx, toIdx);
    }
    me.updateLayout();
  }
  return item;
}, moveBefore:function(item, before) {
  var activeEl, refocusEl;
  if (item !== before) {
    activeEl = Ext.Element.getActiveElement(true);
    if (item.el && item.el.contains(activeEl)) {
      refocusEl = activeEl;
      refocusEl.suspendFocusEvents();
      item.isLayoutMoving = true;
    }
    item = this.layout.moveItemBefore(item, before);
    if (refocusEl) {
      item.isLayoutMoving = false;
      refocusEl.focus();
      refocusEl.resumeFocusEvents();
    }
  }
  return item;
}, moveAfter:function(item, after) {
  var layout = this.layout, index;
  if (item !== after) {
    index = after ? layout.getMoveAfterIndex(after) : 0;
    item = this.moveBefore(item, this.items.getAt(index));
  }
  return item;
}, nextChild:function(child, selector) {
  var me = this, items = me.items, childIndex = items.indexOf(child), i = 0, len = items.length, result;
  if (childIndex !== -1) {
    if (selector) {
      for (; i < len; i++) {
        result = items.getAt(childIndex + i);
        if (!result || Ext.ComponentQuery.is(result, selector)) {
          break;
        }
      }
    } else {
      result = items.getAt(childIndex + 1);
    }
  }
  return result || null;
}, onAdd:Ext.emptyFn, onBeforeAdd:function(item) {
  var owner = item.ownerCt;
  if (item.isDetached) {
    item.reattachToBody();
  }
  if (owner && owner !== this) {
    item.isLayoutMoving = true;
    owner.remove(item, {destroy:false, detach:false});
  }
}, onMove:Ext.emptyFn, onRemove:Ext.emptyFn, onPosition:function() {
  Ext.Component.prototype.onPosition.apply(this, arguments);
  this.repositionFloatingItems();
}, onResize:function() {
  Ext.Component.prototype.onResize.apply(this, arguments);
  this.repositionFloatingItems();
}, prevChild:function(child, selector) {
  var me = this, items = me.items, childIndex = items.indexOf(child), i = 0, len = items.length, result;
  if (childIndex !== -1) {
    if (selector) {
      for (; i < len; i++) {
        result = items.getAt(childIndex - i);
        if (!result || Ext.ComponentQuery.is(result, selector)) {
          break;
        }
      }
    } else {
      result = items.getAt(childIndex - 1);
    }
  }
  return result || null;
}, remove:function(component, autoDestroy) {
  var me = this, c;
  if (me.destroyed || me.destroying) {
    return;
  }
  c = me.getComponent(component);
  if (c && (!me.hasListeners.beforeremove || me.fireEvent('beforeremove', me, c) !== false)) {
    me.doRemove(c, autoDestroy);
    if (me.hasListeners.remove) {
      me.fireEvent('remove', me, c);
    }
    if (!me.destroying && !me.destroyAfterRemoving && !c.floating) {
      me.updateLayout();
    }
    if (me.destroyAfterRemoving) {
      me.destroy();
    }
  }
  return c;
}, removeAll:function(autoDestroy) {
  var me = this, removeItems, floaters = me.floatingItems, items = [], i = 0, len, item;
  if (floaters) {
    removeItems = me.items.items.concat(floaters.items);
  } else {
    removeItems = me.items.items.slice();
  }
  len = removeItems.length;
  Ext.suspendLayouts();
  me.removingAll = true;
  for (; i < len; i++) {
    item = removeItems[i];
    me.remove(item, autoDestroy);
    if (item.ownerCt !== me) {
      items.push(item);
    }
  }
  me.removingAll = false;
  Ext.resumeLayouts(!!len);
  return items;
}, setLayout:function(configuration) {
  var me = this, oldLayout = me.layout, type;
  if (configuration) {
    if (typeof configuration === 'string') {
      configuration = {type:configuration};
    }
    type = configuration.type;
    if (oldLayout) {
      if (oldLayout.isLayout) {
        if (!type || type === oldLayout.type) {
          oldLayout.setConfig(configuration);
          configuration = oldLayout;
        } else {
          oldLayout.setOwner(null);
        }
      } else {
        if (typeof oldLayout === 'string') {
          oldLayout = {type:oldLayout};
        }
        configuration = Ext.merge({}, oldLayout, configuration);
      }
    }
    if (!(configuration && configuration.isLayout)) {
      configuration.owner = this;
      configuration = Ext.Factory.layout(configuration);
    }
    configuration.setOwner(this);
  }
  me.layout = configuration;
  if (me.rendered) {
    me.updateLayout();
  }
}, setActiveItem:function(item) {
  return this.getLayout().setActiveItem(item);
}, updateActions:function(actions) {
  var me = this, actionName, action;
  for (actionName in actions) {
    if (!actions[actionName].isAction) {
      actions[actionName] = new Ext.Action(actions[actionName]);
    }
  }
}, getAction:function(name) {
  var owner = this;
  for (owner = this; owner; owner = owner.getRefOwner()) {
    if (owner.actions && owner.actions[name]) {
      return owner.actions[name];
    }
  }
}, onShowComplete:function(cb, scope) {
  var me = this;
  Ext.Component.prototype.onShowComplete.call(this, cb, scope);
  if (me.focusableContainer && me.activateFocusableContainer) {
    me.activateFocusableContainer();
  }
}, onFocusEnter:function(e) {
  var me = this;
  Ext.Component.prototype.onFocusEnter.call(this, e);
  if (me.focusableContainer && !me.destroying && !me.destroyed) {
    me.mixins.focusablecontainer.onFocusEnter.call(me, e);
  }
}, onFocusLeave:function(e) {
  var me = this;
  Ext.Component.prototype.onFocusLeave.call(this, e);
  if (me.focusableContainer && !me.destroying && !me.destroyed) {
    me.mixins.focusablecontainer.onFocusLeave.call(me, e);
  }
}, privates:{applyDefaults:function(config) {
  var me = this, defaults = me.defaults;
  if (defaults) {
    if (Ext.isFunction(defaults)) {
      defaults = defaults.call(me, config);
    }
    if (Ext.isString(config)) {
      config = Ext.ComponentManager.get(config);
    }
    if (config.isComponent) {
      config.setConfig(defaults, null, me._applyDefaultsOptions);
    } else {
      config = me.self.getConfigurator().merge(me, Ext.Object.fork(defaults), config);
    }
  }
  return config;
}, applyTargetCls:function(targetCls) {
  this.layoutTargetCls = targetCls;
}, doRemove:function(component, flags) {
  var me = this, layout = me.layout, hasLayout = layout && me.rendered, floating = component.floating, doDetach = me.detachOnRemove, doDestroy = me.autoDestroy, isDestroying;
  if (typeof flags === 'boolean') {
    doDestroy = flags;
  } else {
    if (typeof flags === 'object') {
      if (flags.destroy != null) {
        doDestroy = flags.destroy;
      }
      if (flags.detach != null) {
        doDetach = flags.detach;
      }
    }
  }
  isDestroying = component.destroying || doDestroy;
  if (floating) {
    me.floatingItems.remove(component);
  } else {
    me.items.remove(component);
  }
  if (hasLayout && !floating) {
    if (layout.running) {
      Ext.Component.cancelLayout(component, isDestroying);
    }
    layout.onRemove(component, isDestroying);
  }
  if (!component.destroyed) {
    component.onRemoved(isDestroying);
  }
  if (me.focusableContainer && !me.destroying && !me.destroyed) {
    me.onFocusableChildRemove(component, isDestroying);
  }
  me.onRemove(component, isDestroying);
  if (doDestroy) {
    component.destroy();
  } else {
    if (!me.destroyed) {
      if (hasLayout && !floating) {
        layout.afterRemove(component);
      }
      if (doDetach && component.rendered) {
        component.detachFromBody();
      }
    }
  }
}, finishRenderChildren:function() {
  Ext.Component.prototype.finishRenderChildren.call(this);
  var layout = this.getLayout();
  if (layout) {
    layout.finishRender();
  }
}, getChildItemsToDisable:function() {
  return this.query('[isLabelable],[isFocusableContainer],button');
}, getContentTarget:function() {
  return this.getLayout().getContentTarget();
}, getDefaultContentTarget:function() {
  return this.el;
}, prepareItems:function(items, applyDefaults) {
  if (Ext.isArray(items)) {
    items = items.slice();
  } else {
    items = [items];
  }
  var me = this, i = 0, len = items.length, item;
  for (; i < len; i++) {
    item = items[i];
    if (item == null) {
      Ext.Array.erase(items, i, 1);
      --i;
      --len;
    } else {
      if (applyDefaults) {
        item = this.applyDefaults(item);
      }
      item.$initParent = me;
      if (item.isComponent) {
        item.instancedCmp = true;
      }
      items[i] = me.lookupComponent(item);
      delete item.$initParent;
    }
  }
  return items;
}, repositionFloatingItems:function() {
  var floaters = this.floatingItems, floaterCount, i, floater;
  if (floaters) {
    floaters = floaters.items;
    floaterCount = floaters.length;
    for (i = 0; i < floaterCount; i++) {
      floater = floaters[i];
      if (floater.el && !floater.hidden) {
        floater.setPosition(floater.x, floater.y);
      }
    }
  }
}, initTabGuards:function(activate) {
  var me = this, beforeGuard = me.tabGuardBeforeEl, afterGuard = me.tabGuardAfterEl, minTabIndex = me.tabGuardBeforeIndex || 0, maxTabIndex = me.tabGuardAfterIndex || 0, i, tabIndex, nodes;
  if (!me.rendered || !me.tabGuard) {
    return;
  }
  nodes = me.el.findTabbableElements({skipSelf:true});
  if (nodes[0] === beforeGuard.dom) {
    nodes.shift();
  }
  if (nodes[nodes.length - 1] === afterGuard.dom) {
    nodes.pop();
  }
  if (nodes && nodes.length) {
    if (minTabIndex == null || maxTabIndex == null) {
      for (i = 0; i < nodes.length; i++) {
        tabIndex = +nodes[i].getAttribute('tabIndex');
        if (tabIndex > 0) {
          minTabIndex = Math.min(minTabIndex, tabIndex);
          maxTabIndex = Math.max(maxTabIndex, tabIndex);
        }
      }
    }
    beforeGuard.dom.setAttribute('tabIndex', minTabIndex);
    afterGuard.dom.setAttribute('tabIndex', maxTabIndex);
  } else {
    beforeGuard.dom.removeAttribute('tabIndex');
    afterGuard.dom.removeAttribute('tabIndex');
  }
  if (me.onTabGuardFocusEnter) {
    if (!beforeGuard.hasListeners.focusenter) {
      beforeGuard.on('focusenter', me.onTabGuardFocusEnter, me);
    }
    if (!afterGuard.hasListeners.focusenter) {
      afterGuard.on('focusenter', me.onTabGuardFocusEnter, me);
    }
  }
}, _noMargin:{'margin-top':'', 'margin-right':'', 'margin-bottom':'', 'margin-left':''}, resetItemMargins:function() {
  var items = this.items.items, i = items.length, noMargin = this._noMargin, item;
  while (i--) {
    item = items[i];
    item.margin$ = null;
    item.el.setStyle(noMargin);
  }
}, setupRenderTpl:function(renderTpl) {
  Ext.Component.prototype.setupRenderTpl.apply(this, arguments);
  this.getLayout().setupRenderTpl(renderTpl);
}}}, 0, ['container'], ['component', 'box', 'container'], {'component':true, 'box':true, 'container':true}, ['widget.container'], [[Ext.mixin.Queryable.prototype.mixinId || Ext.mixin.Queryable.$className, Ext.mixin.Queryable], [Ext.mixin.Container.prototype.mixinId || Ext.mixin.Container.$className, Ext.mixin.Container], [Ext.mixin.FocusableContainer.prototype.mixinId || Ext.mixin.FocusableContainer.$className, Ext.mixin.FocusableContainer]], [Ext.container, 'Container', Ext, 'Container', Ext, 'AbstractContainer'], 
0);
Ext.cmd.derive('Ext.layout.container.Editor', Ext.layout.container.Container, {autoSizeDefault:{width:'field', height:'field'}, sizePolicies:{$:{$:{readsWidth:1, readsHeight:1, setsWidth:0, setsHeight:0}, boundEl:{readsWidth:1, readsHeight:0, setsWidth:0, setsHeight:1}}, boundEl:{$:{readsWidth:0, readsHeight:1, setsWidth:1, setsHeight:0}, boundEl:{readsWidth:0, readsHeight:0, setsWidth:1, setsHeight:1}}}, getItemSizePolicy:function(item) {
  var me = this, autoSize = me.owner.autoSize, key = autoSize && autoSize.width, policy = me.sizePolicies;
  policy = policy[key] || policy.$;
  key = autoSize && autoSize.height;
  policy = policy[key] || policy.$;
  return policy;
}, calculate:function(ownerContext) {
  var me = this, owner = me.owner, autoSize = owner.autoSize, fieldWidth, fieldHeight;
  if (autoSize === true) {
    autoSize = me.autoSizeDefault;
  }
  if (autoSize) {
    fieldWidth = me.getDimension(owner, autoSize.width, 'getWidth', owner.width);
    fieldHeight = me.getDimension(owner, autoSize.height, 'getHeight', owner.height);
  }
  ownerContext.childItems[0].setSize(fieldWidth, fieldHeight);
  ownerContext.setWidth(fieldWidth);
  ownerContext.setHeight(fieldHeight);
  ownerContext.setContentSize(fieldWidth || owner.field.getWidth(), fieldHeight || owner.field.getHeight());
}, getDimension:function(owner, type, getMethod, ownerSize) {
  switch(type) {
    case 'boundEl':
      return owner.boundEl[getMethod]();
    case 'field':
      return undefined;
    default:
      return ownerSize;
  }
}}, 0, 0, 0, 0, ['layout.editor'], 0, [Ext.layout.container, 'Editor'], 0);
Ext.cmd.derive('Ext.Editor', Ext.container.Container, {layout:'editor', allowBlur:true, revertInvalid:true, value:'', alignment:'c-c?', offsets:[0, 0], shadow:'frame', constrain:false, swallowKeys:true, completeOnEnter:true, cancelOnEsc:true, updateEl:false, focusOnToFront:false, baseCls:'x-editor', editing:false, preventDefaultAlign:true, useBoundValue:true, specialKeyDelay:1, initComponent:function() {
  var me = this, field = me.field = Ext.ComponentManager.create(me.field || {}, 'textfield');
  field.msgTarget = field.msgTarget || 'qtip';
  me.mon(field, {scope:me, specialkey:me.onSpecialKey});
  if (field.grow) {
    me.mon(field, 'autosize', me.onFieldAutosize, me, {delay:1});
  }
  me.floating = {constrain:me.constrain};
  me.items = field;
  Ext.container.Container.prototype.initComponent.call(this);
}, onAdded:function(container) {
  this.ownerCmp = container;
}, onFieldAutosize:function() {
  this.updateLayout();
}, afterRender:function(ct, position) {
  var me = this, field = me.field, inputEl = field.inputEl;
  Ext.container.Container.prototype.afterRender.apply(this, arguments);
  if (inputEl) {
    inputEl.dom.name = '';
    if (me.swallowKeys) {
      inputEl.swallowEvent(['keypress', 'keydown']);
    }
  }
}, onSpecialKey:function(field, event) {
  var me = this, key = event.getKey(), complete = me.completeOnEnter && key === event.ENTER, cancel = me.cancelOnEsc && key === event.ESC, task = me.specialKeyTask;
  if (complete || cancel) {
    event.stopEvent();
    if (!task) {
      me.specialKeyTask = task = new Ext.util.DelayedTask;
    }
    task.delay(me.specialKeyDelay, complete ? me.completeEdit : me.cancelEdit, me);
  }
  me.fireEvent('specialkey', me, field, event);
}, startEdit:function(el, value, doFocus) {
  var me = this, field = me.field, dom, ownerCt, renderTo;
  me.completeEdit(true);
  me.boundEl = Ext.get(el);
  dom = me.boundEl.dom;
  if (me.useBoundValue && !Ext.isDefined(value)) {
    value = Ext.String.trim(dom.textContent || dom.innerText || dom.innerHTML);
  }
  if (me.fireEvent('beforestartedit', me, me.boundEl, value) !== false) {
    if (me.context) {
      value = me.context.value;
    }
    Ext.suspendLayouts();
    if (!me.rendered) {
      ownerCt = me.ownerCt;
      renderTo = me.renderTo || ownerCt && ownerCt.getEl() || Ext.getBody();
      Ext.fly(renderTo).position();
      me.renderTo = renderTo;
    }
    me.startValue = value;
    me.show();
    me.realign(true);
    field.suspendEvents();
    field.setValue(value);
    field.resetOriginalValue();
    field.resumeEvents();
    if (doFocus !== false) {
      field.focus(field.selectOnFocus ? true : [Ext.Number.MAX_SAFE_INTEGER]);
    }
    if (field.autoSize) {
      field.autoSize();
    }
    Ext.resumeLayouts(true);
    me.toggleBoundEl(false);
    me.editing = true;
  }
}, realign:function(autoSize) {
  var me = this;
  if (autoSize === true) {
    me.updateLayout();
  }
  me.alignTo(me.boundEl, me.alignment, me.offsets);
}, completeEdit:function(remainVisible) {
  var me = this, field = me.field, startValue = me.startValue, cancel = me.context && me.context.cancel, value;
  if (!me.editing) {
    return;
  }
  if (field.assertValue) {
    field.assertValue();
  }
  value = me.getValue();
  if (!field.isValid()) {
    if (me.revertInvalid !== false) {
      me.cancelEdit(remainVisible);
    }
    return;
  }
  if (me.ignoreNoChange && !field.didValueChange(value, startValue)) {
    me.onEditComplete(remainVisible);
    return;
  }
  if (me.fireEvent('beforecomplete', me, value, startValue) !== false) {
    value = me.getValue();
    if (me.updateEl && me.boundEl) {
      me.boundEl.setHtml(value);
    }
    me.onEditComplete(remainVisible, cancel);
    me.fireEvent('complete', me, value, startValue);
  }
}, onShow:function() {
  var me = this;
  Ext.container.Container.prototype.onShow.apply(this, arguments);
  me.fireEvent('startedit', me, me.boundEl, me.startValue);
}, cancelEdit:function(remainVisible) {
  var me = this, startValue = me.startValue, field = me.field, value;
  if (me.editing) {
    if (field) {
      value = me.editedValue = me.getValue();
      field.suspendEvents();
      me.setValue(startValue);
      field.resumeEvents();
    }
    me.onEditComplete(remainVisible, true);
    me.fireEvent('canceledit', me, value, startValue);
    delete me.editedValue;
  }
}, onEditComplete:function(remainVisible, canceling) {
  this.editing = false;
  if (remainVisible !== true) {
    this.hide();
    this.toggleBoundEl(true);
  }
}, onFocusLeave:function(e) {
  var me = this;
  if (me.allowBlur === true && me.editing) {
    me.completeEdit();
  }
  Ext.container.Container.prototype.onFocusLeave.call(this, e);
}, onHide:function() {
  var me = this, field = me.field;
  if (me.editing) {
    me.completeEdit();
  } else {
    if (field.collapse) {
      field.collapse();
    }
  }
  Ext.container.Container.prototype.onHide.apply(this, arguments);
}, getValue:function() {
  return this.field.getValue();
}, setValue:function(value) {
  this.field.setValue(value);
}, toggleBoundEl:function(visible) {
  if (this.hideEl !== false) {
    this.boundEl.setVisible(visible);
  }
}, doDestroy:function() {
  var me = this, task = me.specialKeyTask;
  if (task) {
    task.cancel();
  }
  Ext.destroy(me.field);
  Ext.container.Container.prototype.doDestroy.call(this);
}}, 0, ['editor'], ['component', 'box', 'container', 'editor'], {'component':true, 'box':true, 'container':true, 'editor':true}, ['widget.editor'], 0, [Ext, 'Editor'], 0);
Ext.cmd.derive('Ext.util.StoreHolder', Ext.Base, {mixinId:'storeholder', autoDestroyBoundStore:false, bindStore:function(store, initial, propertyName) {
  propertyName = propertyName || 'store';
  var me = this, oldStore = initial ? null : me[propertyName];
  if (store !== oldStore) {
    if (oldStore) {
      if (!me.onUnbindStore.$emptyFn) {
        me.onUnbindStore(oldStore, initial, propertyName);
      }
      if (!oldStore.destroyed) {
        if (me.autoDestroyBoundStore && propertyName === 'store' && oldStore.autoDestroy) {
          oldStore.destroy();
        } else {
          me.unbindStoreListeners(oldStore);
        }
      }
    }
    if (store) {
      me[propertyName] = store = Ext.data.StoreManager.lookup(store);
      me.bindStoreListeners(store);
      if (!me.onBindStore.$emptyFn) {
        me.onBindStore(store, oldStore, initial);
      }
    } else {
      me[propertyName] = null;
    }
    if (me.fireEvent) {
      me.fireEvent('storechange', me, store, oldStore);
    }
  }
  return me;
}, getStore:function() {
  return this.store;
}, setStore:function(store) {
  this.bindStore(store);
}, unbindStoreListeners:function(store) {
  var listeners = this.storeListeners;
  if (listeners) {
    store.un(listeners);
  }
}, bindStoreListeners:function(store) {
  var listeners = this.getStoreListeners(store);
  if (listeners) {
    listeners = Ext.apply({}, listeners);
    if (!listeners.scope) {
      listeners.scope = this;
    }
    this.storeListeners = listeners;
    store.on(listeners);
  }
}, getStoreListeners:Ext.emptyFn, onUnbindStore:Ext.emptyFn, onBindStore:Ext.emptyFn}, 0, 0, 0, 0, 0, 0, [Ext.util, 'StoreHolder'], 0);
Ext.cmd.derive('Ext.LoadMask', Ext.Component, {isLoadMask:true, msg:'Loading...', msgCls:'x-mask-loading', msgWrapCls:'x-mask-msg', useMsg:true, useTargetEl:false, cls:'x-mask', componentCls:'x-border-box', ariaRole:'progressbar', focusable:true, tabIndex:0, childEls:['msgWrapEl', 'msgEl', 'msgTextEl'], renderTpl:['\x3cdiv id\x3d"{id}-msgWrapEl" data-ref\x3d"msgWrapEl" class\x3d"{[values.$comp.msgWrapCls]}" role\x3d"presentation"\x3e', '\x3cdiv id\x3d"{id}-msgEl" data-ref\x3d"msgEl" class\x3d"{[values.$comp.msgCls]} ', 
'x-', 'mask-msg-inner {childElCls}" role\x3d"presentation"\x3e', '\x3cdiv id\x3d"{id}-msgTextEl" data-ref\x3d"msgTextEl" class\x3d"', 'x-', 'mask-msg-text', '{childElCls}" role\x3d"presentation"\x3e{msg}\x3c/div\x3e', '\x3c/div\x3e', '\x3c/div\x3e'], maskOnDisable:false, skipLayout:true, constructor:function(config) {
  var me = this, comp;
  if (arguments.length === 2) {
    comp = me.target = config;
    config = arguments[1];
  } else {
    comp = config.target;
  }
  Ext.Component.prototype.constructor.call(this, config);
  if (comp.isComponent) {
    me.ownerCt = comp;
    me.hidden = true;
    me.renderTo = me.getMaskTarget();
    me.external = me.renderTo === Ext.getBody();
    me.bindComponent(comp);
  } else {
    comp = Ext.get(comp);
    me.isElement = true;
    me.renderTo = me.target;
  }
  me.render(me.renderTo);
  if (me.store) {
    me.bindStore(me.store, true);
  }
}, initRenderData:function() {
  var result = Ext.Component.prototype.initRenderData.apply(this, arguments);
  result.msg = this.msg || '';
  return result;
}, onRender:function() {
  Ext.Component.prototype.onRender.apply(this, arguments);
  this.maskEl = this.el;
}, bindComponent:function(comp) {
  var me = this, listeners = {scope:this, resize:me.sizeMask};
  if (me.external) {
    listeners.added = me.onComponentAdded;
    listeners.removed = me.onComponentRemoved;
    if (comp.floating) {
      listeners.move = me.sizeMask;
      me.activeOwner = comp;
    } else {
      if (comp.ownerCt) {
        me.onComponentAdded(comp.ownerCt);
      }
    }
  }
  me.mon(comp, listeners);
  if (me.external) {
    me.mon(Ext.GlobalEvents, {show:me.onContainerShow, hide:me.onContainerHide, expand:me.onContainerExpand, collapse:me.onContainerCollapse, scope:me});
  }
}, onComponentAdded:function(owner) {
  var me = this;
  delete me.activeOwner;
  me.floatParent = owner;
  if (!owner.floating) {
    owner = owner.up('[floating]');
  }
  if (owner) {
    me.activeOwner = owner;
    me.mon(owner, 'move', me.sizeMask, me);
    me.mon(owner, 'tofront', me.onOwnerToFront, me);
  } else {
    me.preventBringToFront = true;
  }
  owner = me.floatParent.ownerCt;
  if (me.rendered && me.isVisible() && owner) {
    me.floatOwner = owner;
    me.mon(owner, 'afterlayout', me.sizeMask, me, {single:true});
  }
}, onComponentRemoved:function(owner) {
  var me = this, activeOwner = me.activeOwner, floatOwner = me.floatOwner;
  if (activeOwner) {
    me.mun(activeOwner, 'move', me.sizeMask, me);
    me.mun(activeOwner, 'tofront', me.onOwnerToFront, me);
  }
  if (floatOwner) {
    me.mun(floatOwner, 'afterlayout', me.sizeMask, me);
  }
  delete me.activeOwner;
  delete me.floatOwner;
}, afterRender:function() {
  var me = this;
  Ext.Component.prototype.afterRender.apply(this, arguments);
  if (Ext.isIE) {
    me.el.on('mousedown', me.onMouseDown, me);
  }
  this.el.skipGarbageCollection = true;
}, onMouseDown:function(e) {
  var el = this.el;
  if (e.within(el)) {
    e.preventDefault();
    el.focus();
  }
}, onOwnerToFront:function(owner, zIndex) {
  this.el.setStyle('zIndex', zIndex + 1);
}, onContainerShow:function(container) {
  if (!this.isHierarchicallyHidden()) {
    this.onComponentShow();
  }
}, onContainerHide:function(container) {
  if (this.isHierarchicallyHidden()) {
    this.onComponentHide();
  }
}, onContainerExpand:function(container) {
  if (!this.isHierarchicallyHidden()) {
    this.onComponentShow();
  }
}, onContainerCollapse:function(container) {
  if (this.isHierarchicallyHidden()) {
    this.onComponentHide();
  }
}, onComponentHide:function() {
  var me = this;
  if (me.rendered && me.isVisible()) {
    me.hide();
    me.showNext = true;
  }
}, onComponentShow:function() {
  if (this.showNext) {
    this.show();
  }
  delete this.showNext;
}, sizeMask:function() {
  var me = this, target = me.activeOwner || me.target, boxTarget = me.external ? me.getOwner().el : me.getMaskTarget(), zIndex;
  if (me.rendered && me.isVisible()) {
    if (me.external) {
      if (!me.isElement && target.floating) {
        zIndex = target.el.getZIndex();
        if (!isNaN(zIndex)) {
          me.onOwnerToFront(target, zIndex);
        }
      }
      me.el.setSize(boxTarget.getSize()).alignTo(boxTarget, 'tl-tl');
    }
    me.msgWrapEl.center(me.el);
  }
}, bindStore:function(store, initial) {
  var me = this;
  Ext.destroy(me.proxyListeners);
  me.mixins.storeholder.bindStore.apply(me, arguments);
  store = me.store;
  if (store) {
    while (store.getSource) {
      store = store.getSource();
    }
    if (!store.loadsSynchronously()) {
      me.proxyListeners = store.getProxy().on({exception:me.onLoad, scope:me, destroyable:true});
    }
    if (store.isLoading()) {
      me.onBeforeLoad();
    }
  }
}, getStoreListeners:function(store) {
  var onLoad = this.onLoad, beforeLoad = this.onBeforeLoad, result = {cachemiss:beforeLoad, cachefilled:{fn:onLoad, buffer:100}};
  if (!store.loadsSynchronously()) {
    result.beforeload = beforeLoad;
    result.load = onLoad;
  }
  return result;
}, onDisable:function() {
  Ext.Component.prototype.onDisable.apply(this, arguments);
  if (this.loading) {
    this.onLoad();
  }
}, getOwner:function() {
  return this.ownerCt || this.ownerCmp || this.floatParent;
}, getMaskTarget:function() {
  var owner = this.getOwner();
  if (this.isElement) {
    return this.target;
  }
  return this.useTargetEl ? owner.getTargetEl() : owner.getMaskTarget() || Ext.getBody();
}, onBeforeLoad:function() {
  var me = this, owner = me.getOwner(), origin;
  if (!me.disabled) {
    me.loading = true;
    if (owner.componentLayoutCounter) {
      me.maybeShow();
    } else {
      origin = owner.afterComponentLayout;
      owner.afterComponentLayout = function() {
        owner.afterComponentLayout = origin;
        origin.apply(owner, arguments);
        me.maybeShow();
      };
    }
  }
}, maybeShow:function() {
  var me = this, owner = me.getOwner(), ownerVisible;
  ownerVisible = owner.isVisible(true) && (!me.isComponent || owner.el.isVisible(true));
  if (!ownerVisible) {
    me.showNext = true;
  } else {
    if (me.loading && owner.rendered) {
      me.show();
    }
  }
}, hide:function() {
  var me = this, ownerCt = me.ownerCt;
  me.target.removeCls('x-masked');
  if (me.isElement) {
    ownerCt.unmask();
    me.fireEvent('hide', this);
    return;
  }
  if (ownerCt) {
    ownerCt.updateMaskState(false, me);
  }
  delete me.showNext;
  return Ext.Component.prototype.hide.apply(this, arguments);
}, show:function() {
  var me = this;
  me.target.addCls('x-masked');
  if (me.isElement) {
    me.ownerCt.mask(this.useMsg ? this.msg : '', this.msgCls);
    me.fireEvent('show', this);
    return;
  }
  return Ext.Component.prototype.show.apply(this, arguments);
}, afterShow:function() {
  var me = this, ownerCt = me.ownerCt;
  me.loading = true;
  Ext.Component.prototype.afterShow.apply(this, arguments);
  ownerCt.updateMaskState(true, me);
  me.el.restoreTabbableState();
  me.syncMaskState();
}, syncMaskState:function() {
  var me = this, ownerCt = me.ownerCt, el = me.el;
  if (me.isVisible()) {
    if (me.hasOwnProperty('msgWrapCls')) {
      el.dom.className = me.msgWrapCls;
    }
    if (me.useMsg) {
      me.msgTextEl.setHtml(me.msg);
      me.ariaEl.dom.setAttribute('aria-valuetext', me.msg);
    } else {
      me.msgWrapEl.hide();
    }
    if (me.shim || Ext.useShims) {
      el.enableShim(null, true);
    } else {
      el.disableShim();
    }
    if (ownerCt.el.contains(Ext.Element.getActiveElement())) {
      me.focus();
    }
    me.sizeMask();
  }
}, onLoad:function() {
  this.loading = false;
  this.hide();
}, doDestroy:function() {
  var me = this;
  me.ownerCt = null;
  me.bindStore(null);
  if (me.isElement) {
    me.ownerCt.unmask();
  }
  Ext.Component.prototype.doDestroy.call(this);
}}, 1, ['loadmask'], ['component', 'box', 'loadmask'], {'component':true, 'box':true, 'loadmask':true}, ['widget.loadmask'], [[Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder]], [Ext, 'LoadMask'], 0);
Ext.cmd.derive('Ext.layout.component.Component', Ext.layout.Layout, {type:'component', isComponentLayout:true, nullBox:{}, usesContentHeight:true, usesContentWidth:true, usesHeight:true, usesWidth:true, widthCache:{}, heightCache:{}, beginLayoutCycle:function(ownerContext, firstCycle) {
  var me = this, owner = me.owner, ownerCtContext = ownerContext.ownerCtContext, heightModel = ownerContext.heightModel, widthModel = ownerContext.widthModel, body = owner.el.dom === document.body, lastBox = owner.lastBox || me.nullBox, lastSize = owner.el.lastBox || me.nullBox, dirty = !body, isTopLevel = ownerContext.isTopLevel, ownerLayout, v, width, height, scroller;
  Ext.layout.Layout.prototype.beginLayoutCycle.call(this, ownerContext, firstCycle);
  if (firstCycle) {
    scroller = owner.getScrollable && owner.getScrollable();
    if (scroller) {
      scroller.flushOnDomScrollEnd();
    }
    if (me.usesContentWidth) {
      ++ownerContext.consumersContentWidth;
    }
    if (me.usesContentHeight) {
      ++ownerContext.consumersContentHeight;
    }
    if (me.usesWidth) {
      ++ownerContext.consumersWidth;
    }
    if (me.usesHeight) {
      ++ownerContext.consumersHeight;
    }
    if (ownerCtContext && !ownerCtContext.hasRawContent) {
      ownerLayout = owner.ownerLayout;
      if (ownerLayout) {
        if (ownerLayout.usesWidth) {
          ++ownerContext.consumersWidth;
        }
        if (ownerLayout.usesHeight) {
          ++ownerContext.consumersHeight;
        }
      }
    }
  }
  if (widthModel.configured) {
    width = owner[widthModel.names.width];
    if (isTopLevel && widthModel.calculatedFrom) {
      width = lastBox.width;
    }
    if (!body) {
      dirty = me.setWidthInDom || (firstCycle ? width !== lastSize.width : widthModel.constrained);
    }
    ownerContext.setWidth(width, dirty);
  } else {
    if (isTopLevel) {
      if (widthModel.calculated) {
        v = lastBox.width;
        ownerContext.setWidth(v, v !== lastSize.width);
      } else {
        if (widthModel.calculatedFromNatural) {
          owner.el.dom.style.width = owner.width;
        }
      }
      v = lastBox.x;
      ownerContext.setProp('x', v, v !== lastSize.x);
    }
  }
  if (heightModel.configured) {
    height = owner[heightModel.names.height];
    if (isTopLevel && heightModel.calculatedFrom) {
      height = lastBox.height;
    }
    if (!body) {
      dirty = firstCycle ? height !== lastSize.height : heightModel.constrained;
    }
    ownerContext.setHeight(height, dirty);
  } else {
    if (isTopLevel) {
      if (heightModel.calculated) {
        v = lastBox.height;
        ownerContext.setHeight(v, v !== lastSize.height);
      } else {
        if (heightModel.calculatedFromNatural) {
          owner.el.dom.style.height = owner.height;
        }
      }
      v = lastBox.y;
      ownerContext.setProp('y', v, v !== lastSize.y);
    }
  }
}, finishedLayout:function(ownerContext) {
  var me = this, elementChildren = ownerContext.children, owner = me.owner, len, i, elContext, lastBox, props;
  if (elementChildren) {
    len = elementChildren.length;
    for (i = 0; i < len; i++) {
      elContext = elementChildren[i];
      elContext.el.lastBox = elContext.props;
    }
  }
  ownerContext.previousSize = me.lastComponentSize;
  me.lastComponentSize = owner.el.lastBox = props = ownerContext.props;
  lastBox = owner.lastBox || (owner.lastBox = {});
  lastBox.x = props.x;
  lastBox.y = props.y;
  lastBox.width = props.width;
  lastBox.height = props.height;
  lastBox.invalid = false;
  Ext.layout.Layout.prototype.finishedLayout.call(this, ownerContext);
}, notifyOwner:function(ownerContext) {
  var me = this, currentSize = me.lastComponentSize, prevSize = ownerContext.previousSize;
  me.owner.afterComponentLayout(currentSize.width, currentSize.height, prevSize ? prevSize.width : undefined, prevSize ? prevSize.height : undefined);
}, getTarget:function() {
  return this.owner.el;
}, getRenderTarget:function() {
  return this.owner.el;
}, cacheTargetInfo:function(ownerContext) {
  var me = this, targetInfo = me.targetInfo, target;
  if (!targetInfo) {
    target = ownerContext.getEl('getTarget', me);
    me.targetInfo = targetInfo = {padding:target.getPaddingInfo(), border:target.getBorderInfo()};
  }
  return targetInfo;
}, measureAutoDimensions:function(ownerContext, dimensions) {
  var me = this, owner = me.owner, containerLayout = owner.layout, heightModel = ownerContext.heightModel, widthModel = ownerContext.widthModel, boxParent = ownerContext.boxParent, isBoxParent = ownerContext.isBoxParent, target = ownerContext.target, props = ownerContext.props, isContainer, ret = {gotWidth:false, gotHeight:false, isContainer:isContainer = !ownerContext.hasRawContent}, hv = dimensions || 3, zeroWidth, zeroHeight, needed = 0, got = 0, ready, size, temp, key, cache;
  if (widthModel.shrinkWrap && ownerContext.consumersContentWidth) {
    ++needed;
    zeroWidth = !(hv & 1);
    if (isContainer) {
      if (zeroWidth) {
        ret.contentWidth = 0;
        ret.gotWidth = true;
        ++got;
      } else {
        if ((ret.contentWidth = ownerContext.getProp('contentWidth')) !== undefined) {
          ret.gotWidth = true;
          ++got;
        }
      }
    } else {
      size = props.contentWidth;
      if (typeof size === 'number') {
        ret.contentWidth = size;
        ret.gotWidth = true;
        ++got;
      } else {
        if (zeroWidth) {
          ready = true;
        } else {
          if (!ownerContext.hasDomProp('containerChildrenSizeDone')) {
            ready = false;
          } else {
            if (isBoxParent || !boxParent || boxParent.widthModel.shrinkWrap) {
              ready = true;
            } else {
              ready = boxParent.hasDomProp('width');
            }
          }
        }
        if (ready) {
          if (zeroWidth) {
            temp = 0;
          } else {
            if (containerLayout && containerLayout.measureContentWidth) {
              temp = containerLayout.measureContentWidth(ownerContext);
            } else {
              if (target.cacheWidth) {
                key = target.xtype + '-' + target.ui;
                cache = me.widthCache;
                temp = cache[key] || (cache[key] = me.measureContentWidth(ownerContext));
              } else {
                temp = me.measureContentWidth(ownerContext);
              }
            }
          }
          if (!isNaN(ret.contentWidth = temp)) {
            ownerContext.setContentWidth(temp, true);
            ret.gotWidth = true;
            ++got;
          }
        }
      }
    }
  } else {
    if (widthModel.natural && ownerContext.consumersWidth) {
      ++needed;
      size = props.width;
      if (typeof size === 'number') {
        ret.width = size;
        ret.gotWidth = true;
        ++got;
      } else {
        if (isBoxParent || !boxParent) {
          ready = true;
        } else {
          ready = boxParent.hasDomProp('width');
        }
        if (ready) {
          if (!isNaN(ret.width = me.measureOwnerWidth(ownerContext))) {
            ownerContext.setWidth(ret.width, false);
            ret.gotWidth = true;
            ++got;
          }
        }
      }
    }
  }
  if (heightModel.shrinkWrap && ownerContext.consumersContentHeight) {
    ++needed;
    zeroHeight = !(hv & 2);
    if (isContainer) {
      if (zeroHeight) {
        ret.contentHeight = 0;
        ret.gotHeight = true;
        ++got;
      } else {
        if ((ret.contentHeight = ownerContext.getProp('contentHeight')) !== undefined) {
          ret.gotHeight = true;
          ++got;
        }
      }
    } else {
      size = props.contentHeight;
      if (typeof size === 'number') {
        ret.contentHeight = size;
        ret.gotHeight = true;
        ++got;
      } else {
        if (zeroHeight) {
          ready = true;
        } else {
          if (!ownerContext.hasDomProp('containerChildrenSizeDone')) {
            ready = false;
          } else {
            if (owner.noWrap) {
              ready = true;
            } else {
              if (!widthModel.shrinkWrap) {
                ready = (ownerContext.bodyContext || ownerContext).hasDomProp('width');
              } else {
                if (isBoxParent || !boxParent || boxParent.widthModel.shrinkWrap) {
                  ready = true;
                } else {
                  ready = boxParent.hasDomProp('width');
                }
              }
            }
          }
        }
        if (ready) {
          if (zeroHeight) {
            temp = 0;
          } else {
            if (containerLayout && containerLayout.measureContentHeight) {
              temp = containerLayout.measureContentHeight(ownerContext);
            } else {
              if (target.cacheHeight) {
                key = target.xtype + '-' + target.ui;
                cache = me.heightCache;
                temp = cache[key] || (cache[key] = me.measureContentHeight(ownerContext));
              } else {
                temp = me.measureContentHeight(ownerContext);
              }
            }
          }
          if (!isNaN(ret.contentHeight = temp)) {
            ownerContext.setContentHeight(temp, true);
            ret.gotHeight = true;
            ++got;
          }
        }
      }
    }
  } else {
    if (heightModel.natural && ownerContext.consumersHeight) {
      ++needed;
      size = props.height;
      if (typeof size === 'number') {
        ret.height = size;
        ret.gotHeight = true;
        ++got;
      } else {
        if (isBoxParent || !boxParent) {
          ready = true;
        } else {
          ready = boxParent.hasDomProp('width');
        }
        if (ready) {
          if (!isNaN(ret.height = me.measureOwnerHeight(ownerContext))) {
            ownerContext.setHeight(ret.height, false);
            ret.gotHeight = true;
            ++got;
          }
        }
      }
    }
  }
  if (boxParent) {
    ownerContext.onBoxMeasured();
  }
  ret.gotAll = got === needed;
  return ret;
}, measureContentWidth:function(ownerContext) {
  return ownerContext.el.getWidth() - ownerContext.getFrameInfo().width;
}, measureContentHeight:function(ownerContext) {
  return ownerContext.el.getHeight() - ownerContext.getFrameInfo().height;
}, measureOwnerHeight:function(ownerContext) {
  return ownerContext.el.getHeight();
}, measureOwnerWidth:function(ownerContext) {
  return ownerContext.el.getWidth();
}}, 0, 0, 0, 0, 0, 0, [Ext.layout.component, 'Component'], 0);
Ext.cmd.derive('Ext.layout.component.Auto', Ext.layout.component.Component, {type:'autocomponent', setHeightInDom:false, setWidthInDom:false, waitForOuterHeightInDom:false, waitForOuterWidthInDom:false, beginLayoutCycle:function(ownerContext, firstCycle) {
  var me = this, lastWidthModel = me.lastWidthModel, lastHeightModel = me.lastHeightModel, el = me.owner.el;
  Ext.layout.component.Component.prototype.beginLayoutCycle.apply(this, arguments);
  if (lastWidthModel && lastWidthModel.fixed && ownerContext.widthModel.shrinkWrap) {
    el.setWidth(null);
  }
  if (lastHeightModel && lastHeightModel.fixed && ownerContext.heightModel.shrinkWrap) {
    el.setHeight(null);
  }
}, calculate:function(ownerContext) {
  var me = this, measurement = me.measureAutoDimensions(ownerContext), heightModel = ownerContext.heightModel, widthModel = ownerContext.widthModel, width, height;
  if (measurement.gotWidth) {
    if (widthModel.shrinkWrap) {
      me.publishOwnerWidth(ownerContext, measurement.contentWidth);
    } else {
      if (me.publishInnerWidth) {
        me.publishInnerWidth(ownerContext, measurement.width);
      }
    }
  } else {
    if (!widthModel.auto && me.publishInnerWidth) {
      width = me.waitForOuterWidthInDom ? ownerContext.getDomProp('width') : ownerContext.getProp('width');
      if (width === undefined) {
        me.done = false;
      } else {
        me.publishInnerWidth(ownerContext, width);
      }
    }
  }
  if (measurement.gotHeight) {
    if (heightModel.shrinkWrap) {
      me.publishOwnerHeight(ownerContext, measurement.contentHeight);
    } else {
      if (me.publishInnerHeight) {
        me.publishInnerHeight(ownerContext, measurement.height);
      }
    }
  } else {
    if (!heightModel.auto && me.publishInnerHeight) {
      height = me.waitForOuterHeightInDom ? ownerContext.getDomProp('height') : ownerContext.getProp('height');
      if (height === undefined) {
        me.done = false;
      } else {
        me.publishInnerHeight(ownerContext, height);
      }
    }
  }
  if (!measurement.gotAll) {
    me.done = false;
  }
}, calculateOwnerHeightFromContentHeight:function(ownerContext, contentHeight) {
  return contentHeight + ownerContext.getFrameInfo().height;
}, calculateOwnerWidthFromContentWidth:function(ownerContext, contentWidth) {
  return contentWidth + ownerContext.getFrameInfo().width;
}, publishOwnerHeight:function(ownerContext, contentHeight) {
  var me = this, owner = me.owner, height = me.calculateOwnerHeightFromContentHeight(ownerContext, contentHeight), constrainedHeight, dirty, heightModel;
  if (isNaN(height)) {
    me.done = false;
  } else {
    constrainedHeight = Ext.Number.constrain(height, owner.minHeight, owner.maxHeight);
    if (constrainedHeight === height) {
      dirty = me.setHeightInDom;
    } else {
      heightModel = me.sizeModels[constrainedHeight < height ? 'constrainedMax' : 'constrainedMin'];
      height = constrainedHeight;
      if (ownerContext.heightModel.calculatedFromShrinkWrap) {
        ownerContext.heightModel = heightModel;
      } else {
        ownerContext.invalidate({heightModel:heightModel});
      }
    }
    ownerContext.setHeight(height, dirty);
  }
}, publishOwnerWidth:function(ownerContext, contentWidth) {
  var me = this, owner = me.owner, width = me.calculateOwnerWidthFromContentWidth(ownerContext, contentWidth), constrainedWidth, dirty, widthModel;
  if (isNaN(width)) {
    me.done = false;
  } else {
    constrainedWidth = Ext.Number.constrain(width, owner.minWidth, owner.maxWidth);
    if (constrainedWidth === width) {
      dirty = me.setWidthInDom;
    } else {
      widthModel = me.sizeModels[constrainedWidth < width ? 'constrainedMax' : 'constrainedMin'];
      width = constrainedWidth;
      if (ownerContext.widthModel.calculatedFromShrinkWrap) {
        ownerContext.widthModel = widthModel;
      } else {
        ownerContext.invalidate({widthModel:widthModel});
      }
    }
    ownerContext.setWidth(width, dirty);
  }
}}, 0, 0, 0, 0, ['layout.autocomponent'], 0, [Ext.layout.component, 'Auto'], 0);
Ext.cmd.derive('Ext.layout.component.ProgressBar', Ext.layout.component.Auto, {type:'progressbar', beginLayout:function(ownerContext) {
  var me = this, i, textEls;
  Ext.layout.component.Auto.prototype.beginLayout.apply(this, arguments);
  if (!ownerContext.textEls) {
    textEls = me.owner.textEl;
    if (textEls.isComposite) {
      ownerContext.textEls = [];
      textEls = textEls.elements;
      for (i = textEls.length; i--;) {
        ownerContext.textEls[i] = ownerContext.getEl(Ext.get(textEls[i]));
      }
    } else {
      ownerContext.textEls = [ownerContext.getEl('textEl')];
    }
  }
}, calculate:function(ownerContext) {
  var me = this, i, textEls, width;
  Ext.layout.component.Auto.prototype.calculate.apply(this, arguments);
  if (Ext.isNumber(width = ownerContext.getProp('width'))) {
    width -= ownerContext.getBorderInfo().width;
    textEls = ownerContext.textEls;
    for (i = textEls.length; i--;) {
      textEls[i].setWidth(width);
    }
  } else {
    me.done = false;
  }
}}, 0, 0, 0, 0, ['layout.progressbar'], 0, [Ext.layout.component, 'ProgressBar'], 0);
Ext.cmd.derive('Ext.ProgressBar', Ext.Component, {baseCls:'x-progress', animate:false, text:'', waitTimer:null, childEls:['bar'], defaultBindProperty:'value', renderTpl:['\x3ctpl if\x3d"internalText"\x3e', '\x3cdiv class\x3d"{baseCls}-text {baseCls}-text-back" role\x3d"presentation"\x3e{text}\x3c/div\x3e', '\x3c/tpl\x3e', '\x3cdiv id\x3d"{id}-bar" data-ref\x3d"bar" class\x3d"{baseCls}-bar {baseCls}-bar-{ui}" role\x3d"presentation" style\x3d"width:{percentage}%"\x3e', '\x3ctpl if\x3d"internalText"\x3e', 
'\x3cdiv class\x3d"{baseCls}-text" role\x3d"presentation"\x3e', '\x3cdiv role\x3d"presentation"\x3e{text}\x3c/div\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e', '\x3c/div\x3e'], componentLayout:'progressbar', ariaRole:'progressbar', focusable:true, tabIndex:0, autoEl:{'aria-valuemin':'0', 'aria-valuenow':'0', 'aria-valuemax':'100'}, initRenderData:function() {
  var me = this, value = me.value || 0, data;
  data = Ext.Component.prototype.initRenderData.call(this);
  return Ext.apply(data, {internalText:!me.hasOwnProperty('textEl'), text:me.text || Math.round(value * 100) + '%', percentage:value * 100});
}, onRender:function() {
  var me = this;
  Ext.Component.prototype.onRender.apply(this, arguments);
  if (me.textEl) {
    me.textEl = Ext.get(me.textEl);
    me.updateText(me.text);
  } else {
    me.textEl = me.el.select('.' + me.baseCls + '-text');
  }
}, afterRender:function() {
  var me = this;
  Ext.Component.prototype.afterRender.apply(this, arguments);
  if (me.text) {
    me.ariaEl.dom.setAttribute('aria-valuetext', me.text);
  }
}, updateValue:function(value) {
  this.updateProgress(value);
}, updateProgress:function(value, text, animate) {
  value = value || 0;
  var me = this, oldValue = me.value, textTpl = me.getTextTpl();
  me.value = value || (value = 0);
  if (text != null) {
    me.autoText = false;
    me.updateText(text);
  } else {
    if (textTpl) {
      me.autoText = false;
      me.updateText(textTpl.apply({value:value, percent:value * 100}));
    } else {
      if (!me.text && me.autoText !== false) {
        me.autoText = true;
        me.updateText(Math.round(value * 100) + '%');
      } else {
        if (me.text && me.ariaEl.dom) {
          me.ariaEl.dom.removeAttribute('aria-valuetext');
        }
      }
    }
  }
  if (me.rendered && !me.destroyed) {
    if (animate === true || animate !== false && me.animate) {
      me.bar.stopAnimation();
      me.bar.animate(Ext.apply({from:{width:oldValue * 100 + '%'}, to:{width:value * 100 + '%'}}, me.animate));
    } else {
      me.bar.setStyle('width', value * 100 + '%');
    }
    me.ariaEl.dom.setAttribute('aria-valuenow', Math.round(value * 100));
  }
  me.fireEvent('update', me, value, text);
  return me;
}, updateText:function(text) {
  var me = this;
  if (!me.autoText) {
    me.text = text;
  }
  if (me.rendered) {
    me.textEl.setHtml(text);
    if (!me.autoText) {
      me.ariaEl.dom.setAttribute('aria-valuetext', text);
    } else {
      me.ariaEl.dom.removeAttribute('aria-valuetext');
    }
  }
  return me;
}, applyText:function(text) {
  this.updateText(text);
}, getText:function() {
  return this.text;
}, wait:function(config) {
  var me = this, scope;
  if (!me.waitTimer) {
    scope = me;
    config = config || {};
    if (config.text != null) {
      me.autoText = false;
    }
    me.updateText(config.text);
    me.waitTimer = Ext.TaskManager.start({run:function(i) {
      var inc = config.increment || 10;
      i -= 1;
      me.updateProgress(((i + inc) % inc + 1) * (100 / inc) * 0.01, null, config.animate);
    }, interval:config.interval || 1000, duration:config.duration, onStop:function() {
      if (config.fn) {
        config.fn.apply(config.scope || me);
      }
      me.reset();
    }, scope:scope});
  }
  return me;
}, isWaiting:function() {
  return this.waitTimer !== null;
}, reset:function(hide) {
  var me = this;
  me.updateProgress(0);
  me.clearTimer();
  if (hide === true) {
    me.hide();
  }
  if (me.rendered) {
    me.ariaEl.dom.removeAttribute('aria-valuetext');
  }
  return me;
}, clearTimer:function() {
  var me = this;
  if (me.waitTimer) {
    me.waitTimer.onStop = null;
    Ext.TaskManager.stop(me.waitTimer);
    me.waitTimer = null;
  }
}, doDestroy:function() {
  var me = this, bar = me.bar, nodes, el, i, len;
  me.clearTimer();
  if (me.rendered) {
    if (me.textEl.isComposite) {
      nodes = me.textEl.slice();
      for (i = 0, len = nodes.length; i < len; i++) {
        el = Ext.get(nodes[i]);
        el.destroy();
      }
    }
    Ext.destroyMembers(me, 'textEl', 'progressBar');
    if (bar && me.animate) {
      bar.stopAnimation();
    }
  }
  Ext.Component.prototype.doDestroy.call(this);
}}, 0, ['progressbar'], ['component', 'box', 'progressbar'], {'component':true, 'box':true, 'progressbar':true}, ['widget.progressbar'], [[Ext.ProgressBase.prototype.mixinId || Ext.ProgressBase.$className, Ext.ProgressBase]], [Ext, 'ProgressBar'], 0);
Ext.cmd.derive('Ext.dom.ButtonElement', Ext.dom.Element, {setSize:function(width, height, animate) {
  var me = this, component = me.component;
  Ext.dom.Element.prototype.setSize.call(this, width, height, animate);
  component.btnWrap.setStyle('table-layout', !width || width === 'auto' ? '' : 'fixed');
  component.btnEl.setStyle('height', !height || height === 'auto' ? '' : 'auto');
  return me;
}, setStyle:function(prop, value) {
  var me = this, component = me.component, width, height;
  Ext.dom.Element.prototype.setStyle.call(this, prop, value);
  if (prop) {
    if (prop === 'width' || typeof prop !== 'string' && 'width' in prop) {
      width = value || prop.width;
      component.btnWrap.setStyle('table-layout', !width || width === 'auto' ? '' : 'fixed');
    }
    if (prop === 'height' || typeof prop !== 'string' && 'height' in prop) {
      height = value || prop.height;
      component.btnEl.setStyle('height', !height || height === 'auto' ? '' : 'auto');
    }
  }
  return me;
}, setHeight:function(height, animate) {
  Ext.dom.Element.prototype.setHeight.call(this, height, animate);
  this.component.btnEl.setStyle('height', !height || height === 'auto' ? '' : 'auto');
  return this;
}, setWidth:function(width, animate) {
  Ext.dom.Element.prototype.setWidth.call(this, width, animate);
  this.component.btnWrap.setStyle('table-layout', !width || width === 'auto' ? '' : 'fixed');
  return this;
}}, 0, 0, 0, 0, 0, 0, [Ext.dom, 'ButtonElement'], 0);
Ext.cmd.derive('Ext.button.Manager', Ext.Base, {singleton:true, alternateClassName:'Ext.ButtonToggleManager', groups:{}, pressedButton:null, init:function() {
  var me = this;
  if (!me.initialized) {
    Ext.getDoc().on({mouseup:me.onDocumentMouseUp, scope:me});
    me.initialized = true;
  }
}, onButtonMousedown:function(button, e) {
  var pressed = this.pressedButton;
  if (pressed && !pressed.destroying && !pressed.destroyed) {
    pressed.onMouseUp(e);
  }
  this.pressedButton = button;
}, onDocumentMouseUp:function(e) {
  var pressed = this.pressedButton;
  if (pressed && !pressed.destroying && !pressed.destroyed) {
    pressed.onMouseUp(e);
    this.pressedButton = null;
  }
}, toggleGroup:function(btn, state) {
  if (state) {
    var g = this.groups[btn.toggleGroup], length = g.length, i;
    for (i = 0; i < length; i++) {
      if (g[i] !== btn) {
        g[i].toggle(false);
      }
    }
  }
}, register:function(btn) {
  var me = this, groups = this.groups, group = groups[btn.toggleGroup];
  me.init();
  if (!btn.toggleGroup) {
    return;
  }
  if (!group) {
    group = groups[btn.toggleGroup] = [];
  }
  group.push(btn);
  btn.on('toggle', me.toggleGroup, me);
}, unregister:function(btn) {
  if (!btn.toggleGroup) {
    return;
  }
  var me = this, group = me.groups[btn.toggleGroup];
  if (group) {
    Ext.Array.remove(group, btn);
    btn.un('toggle', me.toggleGroup, me);
  }
}, getPressed:function(groupName) {
  var group = this.groups[groupName], i = 0, len;
  if (group) {
    for (len = group.length; i < len; i++) {
      if (group[i].pressed === true) {
        return group[i];
      }
    }
  }
  return null;
}}, 0, 0, 0, 0, 0, 0, [Ext.button, 'Manager', Ext, 'ButtonToggleManager'], 0);
Ext.cmd.derive('Ext.menu.Manager', Ext.Base, {singleton:true, alternateClassName:'Ext.menu.MenuMgr', groups:{}, visible:[], constructor:function() {
  var me = this;
  me.onShow = function() {
    me.registerGlobalListeners();
    return me.onShow.apply(me, arguments);
  };
}, onGlobalScroll:function(scroller) {
  var allMenus = this.visible, len = allMenus.length, i, menu, scrollerEl = scroller.getElement();
  if (len && scroller !== Ext.scroll.Scroller.viewport) {
    allMenus = allMenus.slice();
    for (i = 0; i < len; ++i) {
      menu = allMenus[i];
      if (!menu.alignOnScroll && menu.hideOnScroll !== false && !menu.owns(scrollerEl)) {
        menu.hide();
      }
    }
  }
}, checkActiveMenus:function(e) {
  var allMenus = this.visible, len = allMenus.length, i, menu, mousedownCmp = Ext.Component.from(e);
  if (len) {
    allMenus = allMenus.slice();
    for (i = 0; i < len; ++i) {
      menu = allMenus[i];
      if (!(menu.owns(e) || mousedownCmp && mousedownCmp.isMenuItem && mousedownCmp.getMenu() === menu)) {
        menu.hide();
      }
    }
  }
}, onShow:function(menu) {
  if (menu.floating) {
    Ext.Array.include(this.visible, menu);
  }
}, onHide:function(menu) {
  if (menu.floating) {
    Ext.Array.remove(this.visible, menu);
  }
}, hideAll:function() {
  var allMenus = this.visible, len = allMenus.length, result = false, i;
  if (len) {
    allMenus = allMenus.slice();
    for (i = 0; i < len; i++) {
      allMenus[i].hide();
      result = true;
    }
  }
  return result;
}, get:function(menu, config) {
  var result;
  if (typeof menu === 'string') {
    result = Ext.getCmp(menu);
    if (result instanceof Ext.menu.Menu) {
      menu = result;
    }
  } else {
    if (Ext.isArray(menu)) {
      config = Ext.apply({items:menu}, config);
      menu = new Ext.menu.Menu(config);
    } else {
      if (!menu.isComponent) {
        config = Ext.apply({}, menu, config);
        menu = Ext.ComponentManager.create(config, 'menu');
      }
    }
  }
  return menu;
}, registerCheckable:function(menuItem) {
  var groups = this.groups, groupId = menuItem.group;
  if (groupId) {
    if (!groups[groupId]) {
      groups[groupId] = [];
    }
    groups[groupId].push(menuItem);
  }
}, unregisterCheckable:function(menuItem) {
  var groups = this.groups, groupId = menuItem.group;
  if (groupId) {
    Ext.Array.remove(groups[groupId], menuItem);
  }
}, onCheckChange:function(menuItem, state) {
  var groups = this.groups, groupId = menuItem.group, i = 0, group, ln, curr;
  if (groupId && state) {
    group = groups[groupId];
    ln = group.length;
    for (; i < ln; i++) {
      curr = group[i];
      if (curr !== menuItem) {
        curr.setChecked(false);
      }
    }
  }
}, registerGlobalListeners:function() {
  var me = this;
  delete me.onShow;
  Ext.on({mousedown:me.checkActiveMenus, scroll:me.onGlobalScroll, scope:me});
}}, 1, 0, 0, 0, 0, 0, [Ext.menu, 'Manager', Ext.menu, 'MenuMgr'], 0);
Ext.cmd.derive('Ext.button.Button', Ext.Component, {alternateClassName:'Ext.Button', config:{iconAlign:'left', text:null, textAlign:'center', arrowVisible:true, glyph:null}, isButton:true, _syncFrameHeight:true, liquidLayout:true, hidden:false, disabled:false, pressed:false, tabIndex:0, enableToggle:false, menuAlign:'tl-bl?', showEmptyMenu:false, clickEvent:'click', preventDefault:true, handleMouseEvents:true, tooltipType:'qtip', baseCls:'x-btn', hrefTarget:'_blank', destroyMenu:true, focusable:true, 
ariaRole:'button', keyMap:{scope:'this', SPACE:'onEnterKey', ENTER:'onEnterKey', DOWN:'onDownKey'}, defaultBindProperty:'text', childEls:['btnEl', 'btnWrap', 'btnInnerEl', 'btnIconEl', 'arrowEl'], publishes:{pressed:1}, _btnWrapCls:'x-btn-wrap', _btnCls:'x-btn-button', _baseIconCls:'x-btn-icon-el', _glyphCls:'x-btn-glyph', _innerCls:'x-btn-inner', _textCls:'x-btn-text', _noTextCls:'x-btn-no-text', _hasIconCls:'x-btn-icon', _pressedCls:'x-btn-pressed', overCls:'x-btn-over', _disabledCls:'x-btn-disabled', 
_menuActiveCls:'x-btn-menu-active', _arrowElCls:'x-btn-arrow-el', _focusCls:'x-btn-focus', _arrowFocusCls:'x-arrow-focus', renderTpl:'\x3cspan id\x3d"{id}-btnWrap" data-ref\x3d"btnWrap" role\x3d"presentation" unselectable\x3d"on" style\x3d"{btnWrapStyle}" class\x3d"{btnWrapCls} {btnWrapCls}-{ui} {splitCls}{childElCls}"\x3e\x3cspan id\x3d"{id}-btnEl" data-ref\x3d"btnEl" role\x3d"presentation" unselectable\x3d"on" style\x3d"{btnElStyle}" class\x3d"{btnCls} {btnCls}-{ui} {textCls} {noTextCls} {hasIconCls} {iconAlignCls} {textAlignCls} {btnElAutoHeightCls}{childElCls}"\x3e\x3ctpl if\x3d"iconBeforeText"\x3e{[values.$comp.renderIcon(values)]}\x3c/tpl\x3e\x3cspan id\x3d"{id}-btnInnerEl" data-ref\x3d"btnInnerEl" unselectable\x3d"on" class\x3d"{innerCls} {innerCls}-{ui}{childElCls}"\x3e{text}\x3c/span\x3e\x3ctpl if\x3d"!iconBeforeText"\x3e{[values.$comp.renderIcon(values)]}\x3c/tpl\x3e\x3c/span\x3e\x3c/span\x3e{[values.$comp.getAfterMarkup ? values.$comp.getAfterMarkup(values) : ""]}\x3ctpl if\x3d"closable"\x3e\x3cspan id\x3d"{id}-closeEl" data-ref\x3d"closeEl" class\x3d"{baseCls}-close-btn"\x3e\x3ctpl if\x3d"closeText"\x3e {closeText}\x3c/tpl\x3e\x3c/span\x3e\x3c/tpl\x3e\x3ctpl if\x3d"split"\x3e\x3cspan id\x3d"{id}-arrowEl" class\x3d"{arrowElCls}" data-ref\x3d"arrowEl" role\x3d"button" hidefocus\x3d"on" unselectable\x3d"on"\x3ctpl if\x3d"tabIndex !\x3d null"\x3e tabindex\x3d"{tabIndex}"\x3c/tpl\x3e\x3ctpl foreach\x3d"arrowElAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e style\x3d"{arrowElStyle}"\x3e{arrowElText}\x3c/span\x3e\x3c/tpl\x3e', 
iconTpl:'\x3cspan id\x3d"{id}-btnIconEl" data-ref\x3d"btnIconEl" role\x3d"presentation" unselectable\x3d"on" class\x3d"{baseIconCls} {baseIconCls}-{ui} {iconCls} {glyphCls}{childElCls}" style\x3d"\x3ctpl if\x3d"iconUrl"\x3ebackground-image:url({iconUrl});\x3c/tpl\x3e\x3ctpl if\x3d"glyph"\x3e\x3ctpl if\x3d"glyphFontFamily"\x3efont-family:{glyphFontFamily};\x3c/tpl\x3e"\x3e{glyph}\x3ctpl else\x3e"\x3e\x3c/tpl\x3e\x3c/span\x3e', scale:'small', allowedScales:['small', 'medium', 'large'], arrowAlign:'right', 
arrowCls:'arrow', maskOnDisable:false, shrinkWrap:3, frame:true, autoEl:{tag:'a', hidefocus:'on', unselectable:'on'}, hasFrameTable:function() {
  return this.href && this.frameTable;
}, frameTableListener:function() {
  if (!this.disabled) {
    this.doNavigate();
  }
}, doNavigate:function() {
  if (this.hrefTarget === '_blank') {
    window.open(this.getHref(), this.hrefTarget);
  } else {
    location.href = this.getHref();
  }
}, _triggerRegion:{}, initComponent:function() {
  var me = this;
  me.addCls('x-unselectable');
  Ext.Component.prototype.initComponent.call(this);
  if (me.menu) {
    me.split = true;
    me.setMenu(me.menu, false, true);
  }
  if (me.url) {
    me.href = me.url;
  }
  me.configuredWithPreventDefault = me.hasOwnProperty('preventDefault');
  if (me.href && !me.configuredWithPreventDefault) {
    me.preventDefault = false;
  }
  if (Ext.isString(me.toggleGroup) && me.toggleGroup !== '') {
    me.enableToggle = true;
  }
  if (me.html && !me.text) {
    me.text = me.html;
    delete me.html;
  }
}, getElConfig:function() {
  var me = this, config = Ext.Component.prototype.getElConfig.call(this), href = me.getHref(), hrefTarget = me.hrefTarget;
  if (config.tag === 'a') {
    if (!me.disabled) {
      config.tabIndex = me.tabIndex;
    }
    if (href) {
      if (!me.disabled) {
        config.href = href;
        if (hrefTarget) {
          config.target = hrefTarget;
        }
      }
    }
  }
  if (!me.ariaStaticRoles[me.ariaRole]) {
    if (me.menu && !me.isSplitButton) {
      config['aria-haspopup'] = true;
    }
    if (me.enableToggle) {
      config['aria-pressed'] = !!me.pressed;
    }
  }
  return config;
}, beforeRender:function() {
  Ext.Component.prototype.beforeRender.call(this);
  if (this.pressed) {
    this.addCls(this._pressedCls);
  }
}, initRenderData:function() {
  return Ext.apply(Ext.Component.prototype.initRenderData.call(this), this.getTemplateArgs());
}, getMenu:function() {
  return this.menu || null;
}, setMenu:function(menu, destroyMenu, initial) {
  var me = this, oldMenu = me.menu, ariaDom = me.isSplitButton ? me.arrowEl && me.arrowEl.dom : me.ariaEl.dom, instanced, ariaAttr;
  if (oldMenu && !initial) {
    if (destroyMenu !== false && me.destroyMenu) {
      oldMenu.destroy();
    }
    oldMenu.ownerCmp = null;
  }
  if (menu) {
    instanced = menu.isMenu;
    menu = Ext.menu.Manager.get(menu, {ownerCmp:me});
    menu.setOwnerCmp(me, instanced);
    menu.menuClickBuffer = 250;
    me.mon(menu, {scope:me, show:me.onMenuShow, hide:me.onMenuHide});
    if (!oldMenu && me.getArrowVisible()) {
      me.split = true;
      if (me.rendered) {
        me._addSplitCls();
        me.updateLayout();
      }
    }
    me.menu = menu;
    if (ariaDom) {
      ariaDom.setAttribute('aria-haspopup', true);
      ariaDom.setAttribute('aria-owns', menu.id);
    } else {
      ariaAttr = me.isSplitButton ? me.ariaArrowElAttributes || (me.ariaArrowElAttributes = {}) : me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
      ariaAttr['aria-haspopup'] = true;
      ariaAttr['aria-owns'] = menu.id;
    }
  } else {
    if (me.rendered) {
      ariaDom.removeAttribute('aria-haspopup');
      ariaDom.removeAttribute('aria-owns');
      me._removeSplitCls();
      me.updateLayout();
    } else {
      ariaAttr = me.isSplitButton ? me.ariaArrowElAttributes : me.ariaRenderAttributes;
      if (ariaAttr) {
        delete ariaAttr['aria-haspopup'];
        delete ariaAttr['aria-owns'];
      }
    }
    me.split = false;
    me.menu = null;
  }
}, onRender:function() {
  var me = this, addOnclick, btn, btnListeners;
  Ext.Component.prototype.onRender.apply(this, arguments);
  btn = me.el;
  if (me.tooltip) {
    me.setTooltip(me.tooltip, true);
  }
  if (me.handleMouseEvents) {
    btnListeners = {scope:me, mouseover:me.onMouseOver, mouseout:me.onMouseOut, mousedown:me.onMouseDown};
    if (me.split) {
      btnListeners.mousemove = me.onMouseMove;
    }
  } else {
    btnListeners = {scope:me};
  }
  if (Ext.supports.Touch) {
    btnListeners.touchstart = me.onTouchStart;
  }
  if (me.repeat) {
    me.mon(new Ext.util.ClickRepeater(btn, Ext.isObject(me.repeat) ? me.repeat : {}), 'click', me.onRepeatClick, me);
  } else {
    if (btnListeners[me.clickEvent]) {
      addOnclick = true;
    } else {
      btnListeners[me.clickEvent] = me.onClick;
    }
  }
  me.mon(btn, btnListeners);
  if (me.hasFrameTable()) {
    me.mon(me.frameTable, 'click', me.frameTableListener, me);
  }
  if (addOnclick) {
    me.mon(btn, me.clickEvent, me.onClick, me);
  }
  Ext.button.Manager.register(me);
}, onFocusLeave:function(e) {
  Ext.Component.prototype.onFocusLeave.call(this, e);
  if (this.menu) {
    this.menu.hide();
  }
}, getTemplateArgs:function() {
  var me = this, btnCls = me._btnCls, baseIconCls = me._baseIconCls, iconAlign = me.getIconAlign(), glyph = me.glyph, glyphFontFamily, text = me.text, hasIcon = me._hasIcon(), hasIconCls = me._hasIconCls;
  if (glyph) {
    glyphFontFamily = glyph.fontFamily;
    glyph = glyph.character;
  }
  return {split:me.isSplitButton, innerCls:me._innerCls, splitCls:me.getArrowVisible() ? me.getSplitCls() : '', iconUrl:me.icon, iconCls:me.iconCls, glyph:glyph, glyphCls:glyph ? me._glyphCls : '', glyphFontFamily:glyphFontFamily, text:text || '\x26#160;', closeText:me.closeText, textCls:text ? me._textCls : '', noTextCls:text ? '' : me._noTextCls, hasIconCls:hasIcon ? hasIconCls : '', btnWrapCls:me._btnWrapCls, btnWrapStyle:me.width ? 'table-layout:fixed;' : '', btnElStyle:me.height ? 'height:auto;' : 
  '', btnCls:btnCls, baseIconCls:baseIconCls, iconBeforeText:iconAlign === 'left' || iconAlign === 'top', iconAlignCls:hasIcon ? hasIconCls + '-' + iconAlign : '', textAlignCls:btnCls + '-' + me.getTextAlign(), arrowElCls:me._arrowElCls, arrowElStyle:me.arrowVisible ? '' : 'display:none', tabIndex:me.tabIndex};
}, renderIcon:function(values) {
  return this.lookupTpl('iconTpl').apply(values);
}, setHref:function(href) {
  var me = this, hrefTarget = me.hrefTarget, dom;
  me.href = href;
  if (!me.configuredWithPreventDefault) {
    me.preventDefault = !href;
  }
  if (me.rendered) {
    dom = me.el.dom;
    if (!href || me.disabled) {
      dom.removeAttribute('href');
      dom.removeAttribute('hrefTarget');
    } else {
      dom.href = me.getHref();
      if (hrefTarget) {
        dom.target = hrefTarget;
      }
    }
  }
}, getHref:function() {
  var me = this, href = me.href;
  return href ? Ext.urlAppend(href, Ext.Object.toQueryString(Ext.apply({}, me.params, me.baseParams))) : false;
}, setParams:function(params) {
  var me = this, dom;
  me.params = params;
  if (me.rendered) {
    dom = me.el.dom;
    if (me.disabled) {
      dom.removeAttribute('href');
    } else {
      dom.href = me.getHref() || '';
    }
  }
}, getSplitCls:function() {
  var me = this;
  return me.split ? me.baseCls + '-' + me.arrowCls + ' ' + (me.baseCls + '-' + me.arrowCls + '-' + me.arrowAlign) : '';
}, setIcon:function(icon) {
  icon = icon || '';
  var me = this, btnIconEl = me.btnIconEl, oldIcon = me.icon || '';
  if (me.glyph) {
    me.setGlyph(null);
  }
  me.icon = icon;
  if (icon !== oldIcon) {
    if (btnIconEl) {
      btnIconEl.removeCls(me.iconCls);
      btnIconEl.setStyle('background-image', icon ? 'url(' + icon + ')' : '');
      me._syncHasIconCls();
      if (me.didIconStateChange(oldIcon, icon)) {
        me.updateLayout();
      }
    }
    me.fireEvent('iconchange', me, oldIcon, icon);
  }
  return me;
}, setIconCls:function(cls) {
  cls = cls || '';
  var me = this, btnIconEl = me.btnIconEl, oldCls = me.iconCls || '';
  if (me.glyph) {
    me.setGlyph(null);
  }
  me.iconCls = cls;
  if (oldCls !== cls) {
    if (btnIconEl) {
      btnIconEl.setStyle('background-image', '');
      btnIconEl.removeCls(oldCls);
      btnIconEl.addCls(cls);
      me._syncHasIconCls();
      if (me.didIconStateChange(oldCls, cls)) {
        me.updateLayout();
      }
    }
    me.fireEvent('iconchange', me, oldCls, cls);
  }
  return me;
}, applyGlyph:function(glyph, oldGlyph) {
  if (glyph) {
    if (!glyph.isGlyph) {
      glyph = new Ext.Glyph(glyph);
    }
    if (glyph.isEqual(oldGlyph)) {
      glyph = undefined;
    }
  }
  return glyph;
}, updateGlyph:function(glyph, oldGlyph) {
  var me = this, btnIconEl = me.btnIconEl, glyphCls = me._glyphCls;
  if (btnIconEl) {
    me.icon = null;
    btnIconEl.setStyle('background-image', '');
    if (glyph) {
      btnIconEl.dom.innerHTML = glyph.character;
      btnIconEl.addCls(glyphCls);
      btnIconEl.setStyle(glyph.getStyle());
    } else {
      btnIconEl.dom.innerHTML = '';
      btnIconEl.removeCls(glyphCls);
    }
    me._syncHasIconCls();
    if (me.didIconStateChange(oldGlyph, glyph)) {
      me.updateLayout();
    }
  }
  me.fireEvent('glyphchange', me, glyph && glyph.glyphConfig, oldGlyph && oldGlyph.glyphConfig);
  return me;
}, setTooltip:function(tooltip, initial) {
  var me = this;
  if (me.rendered) {
    if (!initial || !tooltip) {
      me.clearTip();
    }
    if (tooltip) {
      if (Ext.quickTipsActive && Ext.isObject(tooltip)) {
        Ext.tip.QuickTipManager.register(Ext.apply({target:me.el.id}, tooltip));
        me.tooltip = tooltip;
      } else {
        me.el.dom.setAttribute(me.getTipAttr(), tooltip);
      }
    }
  } else {
    me.tooltip = tooltip;
  }
  return me;
}, updateIconAlign:function(align, oldAlign) {
  var me = this, btnEl, btnIconEl, hasIconCls;
  if (me.rendered) {
    btnEl = me.btnEl;
    btnIconEl = me.btnIconEl;
    hasIconCls = me._hasIconCls;
    if (oldAlign) {
      btnEl.removeCls(hasIconCls + '-' + oldAlign);
    }
    btnEl.addCls(hasIconCls + '-' + align);
    if (align === 'top' || align === 'left') {
      btnEl.insertFirst(btnIconEl);
    } else {
      btnEl.appendChild(btnIconEl);
    }
    me.updateLayout();
  }
}, updateTextAlign:function(align, oldAlign) {
  var me = this, btnEl = me.btnEl, btnCls = me._btnCls;
  if (me.rendered) {
    btnEl.removeCls(btnCls + '-' + oldAlign);
    btnEl.addCls(btnCls + '-' + align);
  }
}, getTipAttr:function() {
  return this.tooltipType === 'qtip' ? 'data-qtip' : 'title';
}, getRefItems:function(deep) {
  var menu = this.menu, items = [];
  if (menu) {
    if (deep) {
      items = menu.getRefItems(deep);
    }
    items.unshift(menu);
  }
  return items;
}, clearTip:function() {
  var me = this, el = me.el;
  if (Ext.quickTipsActive && Ext.isObject(me.tooltip)) {
    Ext.tip.QuickTipManager.unregister(el);
  } else {
    el.dom.removeAttribute(me.getTipAttr());
  }
}, doDestroy:function() {
  var me = this, menu = me.menu;
  if (me.deferFocusTimer) {
    Ext.undefer(me.deferFocusTimer);
    me.deferFocusTimer = null;
  }
  if (me.rendered) {
    me.clearTip();
  }
  Ext.destroy(me.repeater);
  if (menu && me.destroyMenu) {
    me.menu = Ext.destroy(menu);
  }
  Ext.button.Manager.unregister(me);
  Ext.Component.prototype.doDestroy.call(this);
}, setHandler:function(handler, scope) {
  this.handler = handler;
  if (arguments.length > 1) {
    this.scope = scope;
  }
  return this;
}, updateText:function(text, oldText) {
  text = text == null ? '' : String(text);
  oldText = oldText || '';
  var me = this, btnInnerEl = me.btnInnerEl, btnEl = me.btnEl;
  if (me.rendered) {
    btnInnerEl.setHtml(text || '\x26#160;');
    btnEl[text ? 'addCls' : 'removeCls'](me._textCls);
    btnEl[text ? 'removeCls' : 'addCls'](me._noTextCls);
    me.updateLayout();
  }
  me.fireEvent('textchange', me, oldText, text);
}, didIconStateChange:function(old, current) {
  var currentEmpty = Ext.isEmpty(current);
  return Ext.isEmpty(old) ? !currentEmpty : currentEmpty;
}, click:function(e) {
  return this.onClick(e);
}, setPressed:function(pressed) {
  return this.toggle(pressed !== false);
}, toggle:function(state, suppressEvent) {
  var me = this, ariaDom = me.ariaEl.dom;
  if (!me.enableToggle) {
    return me;
  }
  state = state === undefined ? !me.pressed : !!state;
  if (me.fireEvent('beforetoggle', me, state) !== false) {
    if (state !== me.pressed) {
      me[state ? 'addCls' : 'removeCls'](me._pressedCls);
      me.pressed = state;
      if (ariaDom) {
        ariaDom.setAttribute('aria-pressed', state);
      }
      if (!suppressEvent) {
        me.fireEvent('toggle', me, state);
        Ext.callback(me.toggleHandler, me.scope, [me, state], 0, me);
        if (me.publishState) {
          me.publishState('pressed', state);
        }
      }
    }
  }
  return me;
}, maybeShowMenu:function(e) {
  if (this.menu) {
    this.showMenu(e);
  }
}, showMenu:function(clickEvent) {
  var me = this, menu = me.menu, isPointerEvent = !clickEvent || clickEvent.pointerType;
  if (menu && me.rendered) {
    if (me.tooltip && Ext.quickTipsActive && me.getTipAttr() !== 'title') {
      Ext.tip.QuickTipManager.getQuickTip().cancelShow(me.el);
    }
    if (menu.isVisible()) {
      if (isPointerEvent) {
        menu.hide();
      } else {
        menu.focus();
      }
    } else {
      if (!clickEvent || me.showEmptyMenu || menu.items.getCount() > 0) {
        menu.autoFocus = !isPointerEvent;
        menu.showBy(me.el, me.menuAlign);
      }
    }
  }
  return me;
}, hideMenu:function() {
  if (this.hasVisibleMenu()) {
    this.menu.hide();
  }
  return this;
}, hasVisibleMenu:function() {
  var menu = this.menu;
  return menu && menu.rendered && menu.isVisible();
}, onRepeatClick:function(repeat, e) {
  this.onClick(e);
}, onTouchStart:function(e) {
  if (this.disabled) {
    this.doPreventDefault(e);
  }
}, onEnterKey:function(e) {
  if (!this.href) {
    this.onClick(e);
    e.stopEvent();
    return false;
  }
}, onClick:function(e) {
  var me = this;
  if (e) {
    me.doPreventDefault(e);
  }
  if (e && e.type !== 'keydown' && e.button) {
    return;
  }
  if (!me.disabled) {
    me.doToggle();
    me.maybeShowMenu(e);
    me.fireHandler(e);
  }
}, doToggle:function() {
  var me = this;
  if (me.allowDepress !== false || !me.pressed) {
    me.toggle();
  }
}, doPreventDefault:function(e) {
  if (e && (this.preventDefault || this.disabled && this.getHref())) {
    e.preventDefault();
  }
}, fireHandler:function(e) {
  var me = this;
  if (me.fireEvent('click', me, e) !== false && !me.destroyed) {
    Ext.callback(me.handler, me.scope, [me, e], 0, me);
  }
}, onMouseOver:function(e) {
  var me = this;
  if (!me.disabled && !e.within(me.el, true, true)) {
    me.onMouseEnter(e);
  }
}, onMouseOut:function(e) {
  var me = this;
  if (!e.within(me.el, true, true)) {
    if (me.overMenuTrigger) {
      me.onMenuTriggerOut(e);
    }
    me.onMouseLeave(e);
  }
}, onMouseMove:function(e) {
  var me = this, over = me.overMenuTrigger;
  if (me.split) {
    if (me.isWithinTrigger(e)) {
      if (!over) {
        me.onMenuTriggerOver(e);
      }
    } else {
      if (over) {
        me.onMenuTriggerOut(e);
      }
    }
  }
}, isWithinTrigger:function(e) {
  var me = this, el = me.el, overPosition, triggerRegion;
  overPosition = me.arrowAlign === 'right' ? e.getX() - me.getX() : e.getY() - el.getY();
  triggerRegion = me.getTriggerRegion();
  return overPosition > triggerRegion.begin && overPosition < triggerRegion.end;
}, getTriggerRegion:function() {
  var me = this, region = me._triggerRegion, isRight = me.arrowAlign === 'right', getEnd = isRight ? 'getRight' : 'getBottom', btnSize = isRight ? me.getWidth() : me.getHeight();
  region.begin = btnSize - (me.el[getEnd]() - me.btnEl[getEnd]());
  region.end = btnSize;
  return region;
}, onMouseEnter:function(e) {
  this.fireEvent('mouseover', this, e);
}, onMouseLeave:function(e) {
  this.fireEvent('mouseout', this, e);
}, onMenuTriggerOver:function(e) {
  var me = this, arrowTip = me.arrowTooltip;
  me.overMenuTrigger = true;
  if (me.split && arrowTip) {
    me.btnWrap.dom.setAttribute(me.getTipAttr(), arrowTip);
  }
  me.fireEvent('menutriggerover', me, me.menu, e);
}, onMenuTriggerOut:function(e) {
  var me = this;
  delete me.overMenuTrigger;
  if (me.split && me.arrowTooltip) {
    me.btnWrap.dom.setAttribute(me.getTipAttr(), '');
  }
  me.fireEvent('menutriggerout', me, me.menu, e);
}, onEnable:function() {
  var me = this, href = me.href, hrefTarget = me.hrefTarget, dom = me.el.dom;
  Ext.Component.prototype.onEnable.call(this);
  me.removeCls(me._disabledCls);
  me.el.setTabIndex(me.tabIndex);
  if (href) {
    dom.href = href;
  }
  if (hrefTarget) {
    dom.target = hrefTarget;
  }
}, onDisable:function() {
  var me = this, dom = me.el.dom;
  Ext.Component.prototype.onDisable.call(this);
  me.addCls(me._disabledCls);
  me.removeCls(me.overCls);
  me.el.setTabIndex(null);
  if (me.href) {
    dom.removeAttribute('href');
  }
  if (me.hrefTarget) {
    dom.removeAttribute('target');
  }
}, setScale:function(scale) {
  var me = this, ui = me.ui.replace('-' + me.scale, '');
  if (!Ext.Array.contains(me.allowedScales, scale)) {
    throw '#setScale: scale must be an allowed scale (' + me.allowedScales.join(', ') + ')';
  }
  me.scale = scale;
  me.setUI(ui);
}, setUI:function(ui) {
  var me = this;
  if (me.scale && !ui.match(me.scale)) {
    ui = ui + '-' + me.scale;
  }
  Ext.Component.prototype.setUI.call(this, ui);
}, onMouseDown:function(e) {
  var me = this, activeEl;
  if (Ext.isIE || e.pointerType === 'touch') {
    if (me.deferFocusTimer) {
      Ext.undefer(me.deferFocusTimer);
    }
    activeEl = Ext.Element.getActiveElement();
    me.deferFocusTimer = Ext.defer(function() {
      var focusEl;
      me.deferFocusTimer = null;
      if (me.destroying || me.destroyed || Ext.Element.getActiveElement() !== activeEl || !me.canFocus()) {
        return;
      }
      focusEl = me.getFocusEl();
      if (focusEl && !e.defaultPrevented) {
        focusEl.focus();
      }
    }, 1);
  }
  if (!me.disabled && e.button === 0) {
    Ext.button.Manager.onButtonMousedown(me, e);
    me.addCls(me._pressedCls);
  }
}, onMouseUp:function(e) {
  var me = this;
  if (!me.destroyed && e.button === 0) {
    if (!me.pressed) {
      me.removeCls(me._pressedCls);
    }
  }
}, onMenuShow:function() {
  var me = this;
  me.addCls(me._menuActiveCls);
  me.fireEvent('menushow', me, me.menu);
}, onMenuHide:function(e) {
  var me = this;
  me.removeCls(me._menuActiveCls);
  me.fireEvent('menuhide', me, me.menu);
}, onDownKey:function(e) {
  var me = this;
  if (me.menu && !me.disabled) {
    me.showMenu(e);
    e.stopEvent();
    return false;
  }
}, updateArrowVisible:function(visible) {
  var me = this;
  if (me.rendered) {
    if (visible) {
      if (me.menu || me.isSplitButton) {
        me.split = true;
        me._addSplitCls();
      }
    } else {
      me._removeSplitCls();
      me.split = false;
    }
  }
  return visible;
}, privates:{elClsMap:{'btnWrap':'_btnWrapCls', 'btnEl':'_btnCls', 'btnIconEl':'_baseIconCls', 'btnInnerEl':'_innerCls'}, addUIToElement:function() {
  Ext.Component.prototype.addUIToElement.call(this);
  this.updateChildElsUICls(true);
}, addOverCls:function() {
  if (!this.disabled) {
    this.addCls(this.overCls);
  }
}, _addSplitCls:function() {
  var me = this;
  me.btnWrap.addCls(me.getSplitCls());
}, getTdCls:function() {
  return 'x-button-' + this.ui + '-' + this.scale + '-cell';
}, getValue:function() {
  return this.value;
}, removeUIFromElement:function() {
  Ext.Component.prototype.removeUIFromElement.call(this);
  this.updateChildElsUICls(false);
}, removeOverCls:function() {
  this.removeCls(this.overCls);
}, _removeSplitCls:function() {
  var me = this;
  me.btnWrap.removeCls(me.getSplitCls());
}, _syncHasIconCls:function() {
  var me = this, btnEl = me.btnEl, hasIconCls = me._hasIconCls;
  if (btnEl) {
    btnEl[me._hasIcon() ? 'addCls' : 'removeCls']([hasIconCls, hasIconCls + '-' + me.iconAlign]);
  }
}, _hasIcon:function() {
  return !!(this.icon || this.iconCls || this.glyph);
}, updateChildElsUICls:function(add) {
  var me = this, ui = me.ui, state = add ? 'addCls' : 'removeCls', elClsMap = me.elClsMap, key, el, mapCls, cls;
  for (key in elClsMap) {
    el = me[key];
    mapCls = elClsMap[key];
    cls = me[mapCls];
    if (el && cls) {
      el[state](cls + '-' + ui);
    }
  }
}, wrapPrimaryEl:function(dom) {
  this.el = new Ext.dom.ButtonElement(dom);
  Ext.Component.prototype.wrapPrimaryEl.call(this, dom);
}}}, 0, ['button'], ['component', 'box', 'button'], {'component':true, 'box':true, 'button':true}, ['widget.button'], [[Ext.mixin.Queryable.prototype.mixinId || Ext.mixin.Queryable.$className, Ext.mixin.Queryable]], [Ext.button, 'Button', Ext, 'Button'], 0);
Ext.cmd.derive('Ext.button.Split', Ext.button.Button, {alternateClassName:'Ext.SplitButton', isSplitButton:true, arrowCls:'split', split:true, getTemplateArgs:function() {
  var me = this, ariaAttr, data;
  data = Ext.button.Button.prototype.getTemplateArgs.call(this);
  if (me.disabled) {
    data.tabIndex = null;
  }
  ariaAttr = me.ariaArrowElAttributes || {};
  ariaAttr['aria-hidden'] = !!me.hidden;
  ariaAttr['aria-disabled'] = !!me.disabled;
  if (me.arrowTooltip) {
    ariaAttr['aria-label'] = me.arrowTooltip;
  } else {
    ariaAttr['aria-labelledby'] = me.id;
  }
  data.arrowElAttributes = ariaAttr;
  return data;
}, onRender:function() {
  var me = this, el;
  Ext.button.Button.prototype.onRender.call(this);
  el = me.getFocusEl();
  if (el) {
    el.on({scope:me, focus:me.onMainElFocus, blur:me.onMainElBlur});
  }
  el = me.arrowEl;
  if (el) {
    el.dom.setAttribute('data-componentid', me.id);
    el.setVisibilityMode(Ext.dom.Element.DISPLAY);
    el.on({scope:me, focus:me.onArrowElFocus, blur:me.onArrowElBlur});
  }
}, setArrowHandler:function(handler, scope) {
  this.arrowHandler = handler;
  this.scope = scope;
}, onClick:function(e) {
  var me = this, arrowKeydown = e.type === 'keydown' && e.target === me.arrowEl.dom;
  me.doPreventDefault(e);
  if (!me.disabled) {
    if (arrowKeydown || me.isWithinTrigger(e)) {
      e.preventDefault();
      me.maybeShowMenu(e);
      me.fireEvent('arrowclick', me, e);
      if (me.arrowHandler) {
        me.arrowHandler.call(me.scope || me, me, e);
      }
    } else {
      me.doToggle();
      me.fireHandler(e);
    }
  }
}, enable:function(silent) {
  var me = this, arrowEl = me.arrowEl;
  Ext.button.Button.prototype.enable.call(this, silent);
  if (arrowEl) {
    arrowEl.dom.setAttribute('tabIndex', me.tabIndex);
    arrowEl.dom.setAttribute('aria-disabled', 'false');
  }
}, disable:function(silent) {
  var me = this, arrowEl = me.arrowEl;
  Ext.button.Button.prototype.disable.call(this, silent);
  if (arrowEl) {
    arrowEl.dom.removeAttribute('tabIndex');
    arrowEl.dom.setAttribute('aria-disabled', 'true');
  }
}, afterHide:function(cb, scope) {
  Ext.button.Button.prototype.afterHide.call(this, cb, scope);
  this.arrowEl.dom.setAttribute('aria-hidden', 'true');
}, afterShow:function(animateTarget, cb, scope) {
  Ext.button.Button.prototype.afterShow.call(this, animateTarget, cb, scope);
  this.arrowEl.dom.setAttribute('aria-hidden', 'false');
}, privates:{isFocusing:function(e) {
  var me = this, from = e.fromElement, to = e.toElement, focusEl = me.focusEl && me.focusEl.dom, arrowEl = me.arrowEl && me.arrowEl.dom;
  if (me.focusable) {
    if (to === focusEl) {
      return from === arrowEl ? false : true;
    } else {
      if (to === arrowEl) {
        return from === focusEl ? false : true;
      }
    }
    return true;
  }
  return false;
}, isBlurring:function(e) {
  var me = this, from = e.fromElement, to = e.toElement, focusEl = me.focusEl && me.focusEl.dom, arrowEl = me.arrowEl && me.arrowEl.dom;
  if (me.focusable) {
    if (from === focusEl) {
      return to === arrowEl ? false : true;
    } else {
      if (from === arrowEl) {
        return to === focusEl ? false : true;
      }
    }
    return true;
  }
  return false;
}, getFocusClsEl:Ext.privateFn, onMainElFocus:function(e) {
  this.el.addCls(this._focusCls);
}, onMainElBlur:function(e) {
  this.el.removeCls(this._focusCls);
}, onArrowElFocus:function(e) {
  this.el.addCls(this._arrowFocusCls);
}, onArrowElBlur:function() {
  this.el.removeCls(this._arrowFocusCls);
}, setTabIndex:function(newTabIndex) {
  Ext.button.Button.prototype.setTabIndex.call(this, newTabIndex);
  if (this.arrowEl) {
    this.arrowEl.set({tabIndex:newTabIndex});
  }
}, _addSplitCls:function() {
  var arrowEl = this.arrowEl;
  Ext.button.Button.prototype._addSplitCls.call(this);
  arrowEl.dom.setAttribute('tabIndex', this.tabIndex);
  arrowEl.setVisible(true);
}, _removeSplitCls:function() {
  var arrowEl = this.arrowEl;
  Ext.button.Button.prototype._removeSplitCls.call(this);
  arrowEl.dom.removeAttribute('tabIndex');
  arrowEl.setVisible(false);
}}}, 0, ['splitbutton'], ['component', 'box', 'button', 'splitbutton'], {'component':true, 'box':true, 'button':true, 'splitbutton':true}, ['widget.splitbutton'], 0, [Ext.button, 'Split', Ext, 'SplitButton'], 0);
Ext.cmd.derive('Ext.panel.Bar', Ext.container.Container, {vertical:false, _verticalSides:{left:1, right:1}, initComponent:function() {
  var me = this, vertical = me.vertical;
  me.dock = me.dock || (vertical ? 'left' : 'top');
  me.layout = Ext.apply(vertical ? {type:'vbox', align:'middle', alignRoundingMethod:'ceil'} : {type:'hbox', align:'middle', alignRoundingMethod:'floor'}, me.layout);
  Ext.container.Container.prototype.initComponent.call(this);
}, onAdded:function(container, pos, instanced) {
  this.initOrientation();
  Ext.container.Container.prototype.onAdded.call(this, container, pos, instanced);
}, onRemoved:function(destroying) {
  this.removeClsWithUI(this.uiCls);
  Ext.container.Container.prototype.onRemoved.call(this, destroying);
}, beforeRender:function() {
  var me = this;
  if (me.forceOrientation || !me.ownerCt) {
    me.initOrientation();
  }
  Ext.container.Container.prototype.beforeRender.call(this);
}, setDock:function(dock) {
  var me = this, layout, vertical;
  if (dock !== me.dock) {
    Ext.suspendLayouts();
    me.clearOrientation();
    Ext.container.Container.prototype.setDock.call(this, dock);
    me.initOrientation();
    vertical = me.vertical;
    layout = me.layout;
    layout.setVertical(vertical);
    layout.setAlignRoundingMethod(vertical ? 'ceil' : 'floor');
    Ext.resumeLayouts(true);
  }
}, privates:{clearOrientation:function() {
  this.removeClsWithUI([this.vertical ? 'vertical' : 'horizontal', this.getDockName()]);
}, getDockName:function() {
  return this.dock;
}, initOrientation:function() {
  var me = this, dock = me.dock, vertical = me.vertical = dock ? dock in me._verticalSides : me.vertical;
  me.addClsWithUI([vertical ? 'vertical' : 'horizontal', me.getDockName()]);
}}}, 0, 0, ['component', 'box', 'container'], {'component':true, 'box':true, 'container':true}, 0, 0, [Ext.panel, 'Bar'], 0);
Ext.cmd.derive('Ext.panel.Title', Ext.Component, {isTitle:true, noWrap:true, textAlign:'left', iconAlign:'left', rotation:0, text:'\x26#160;', beforeRenderConfig:{textAlign:null, text:null, glyph:null, icon:null, iconAlign:null, iconCls:null, rotation:null}, autoEl:{role:'presentation', unselectable:'on'}, textElRole:'presentation', tabIndex:0, childEls:['textEl', 'iconEl', 'iconWrapEl'], renderTpl:'\x3ctpl if\x3d"iconMarkup \x26\x26 iconBeforeTitle"\x3e{iconMarkup}\x3c/tpl\x3e\x3cdiv id\x3d"{id}-textEl" data-ref\x3d"textEl" class\x3d"{textCls} {textCls}-{ui} {itemCls}{childElCls}" unselectable\x3d"on"\x3ctpl if\x3d"textElRole"\x3e role\x3d"{textElRole}"\x3c/tpl\x3e\x3e{text}\x3c/div\x3e\x3ctpl if\x3d"iconMarkup \x26\x26 !iconBeforeTitle"\x3e{iconMarkup}\x3c/tpl\x3e', 
iconTpl:'\x3cdiv id\x3d"{id}-iconWrapEl" data-ref\x3d"iconWrapEl" role\x3d"presentation" class\x3d"{iconWrapCls} {iconWrapCls}-{ui} {iconAlignCls} {itemCls}{childElCls}"\x3ctpl if\x3d"iconWrapStyle"\x3e style\x3d"{iconWrapStyle}"\x3c/tpl\x3e\x3e\x3cdiv id\x3d"{id}-iconEl" data-ref\x3d"iconEl" role\x3d"presentation" unselectable\x3d"on" class\x3d"{baseIconCls} {baseIconCls}-{ui} {iconCls} {glyphCls}" style\x3d"\x3ctpl if\x3d"iconUrl"\x3ebackground-image:url({iconUrl});\x3c/tpl\x3e\x3ctpl if\x3d"glyph \x26\x26 glyphFontFamily"\x3efont-family:{glyphFontFamily};\x3c/tpl\x3e"\x3e\x3ctpl if\x3d"glyph"\x3e{glyph}\x3c/tpl\x3e\x3c/div\x3e\x3c/div\x3e', 
_textAlignClasses:{left:'x-title-align-left', center:'x-title-align-center', right:'x-title-align-right'}, _iconAlignClasses:{top:'x-title-icon-top', right:'x-title-icon-right', bottom:'x-title-icon-bottom', left:'x-title-icon-left'}, _rotationClasses:{0:'x-title-rotate-none', 1:'x-title-rotate-right', 2:'x-title-rotate-left'}, _rotationAngles:{1:90, 2:270}, baseCls:'x-title', _titleSuffix:'-title', _glyphCls:'x-title-glyph', _iconWrapCls:'x-title-icon-wrap', _baseIconCls:'x-title-icon', _itemCls:'x-title-item', 
_textCls:'x-title-text', afterComponentLayout:function() {
  var me = this, rotation = me.getRotation(), lastBox, lastX, el;
  if (rotation && !Ext.isIE8) {
    el = me.el;
    lastBox = me.lastBox;
    lastX = lastBox.x;
    el.setStyle(me._getVerticalAdjustDirection(), lastX + (rotation === 1 ? lastBox.width : -lastBox.height) + 'px');
  }
  Ext.Component.prototype.afterComponentLayout.call(this);
}, onRender:function() {
  var me = this, rotation = me.getRotation(), el = me.el;
  Ext.Component.prototype.onRender.call(this);
  if (rotation) {
    el.setVertical(me._rotationAngles[rotation]);
  }
  if (Ext.supports.FixedTableWidthBug) {
    el._needsTableWidthFix = true;
  }
}, applyText:function(text) {
  if (!text) {
    text = '\x26#160;';
  }
  return text;
}, beforeRender:function() {
  var me = this;
  Ext.Component.prototype.beforeRender.call(this);
  me.addCls(me._rotationClasses[me.getRotation()]);
  me.addCls(me._textAlignClasses[me.getTextAlign()]);
}, getIconMarkup:function() {
  return this.lookupTpl('iconTpl').apply(this.getIconRenderData());
}, getIconRenderData:function() {
  var me = this, icon = me.getIcon(), iconCls = me.getIconCls(), glyph = me.getGlyph(), glyphFontFamily, iconAlign = me.getIconAlign();
  if (glyph) {
    glyphFontFamily = glyph.fontFamily;
    glyph = glyph.character;
  }
  return {id:me.id, ui:me.ui, itemCls:me._itemCls, iconUrl:icon, iconCls:iconCls, iconWrapCls:me._iconWrapCls, baseIconCls:me._baseIconCls, iconAlignCls:me._iconAlignClasses[iconAlign], glyph:glyph, glyphCls:glyph ? me._glyphCls : '', glyphFontFamily:glyphFontFamily};
}, initRenderData:function() {
  var me = this, iconAlign, renderData;
  renderData = Ext.apply({text:me.getText(), textElRole:me.textElRole, id:me.id, ui:me.ui, itemCls:me._itemCls, textCls:me._textCls, iconMarkup:null, iconBeforeTitle:null}, Ext.Component.prototype.initRenderData.call(this));
  if (me._hasIcon()) {
    iconAlign = me.getIconAlign();
    renderData.iconMarkup = me.getIconMarkup();
    renderData.iconBeforeTitle = iconAlign === 'top' || iconAlign === 'left';
  }
  return renderData;
}, onAdded:function(container, pos, instanced) {
  var me = this, suffix = me._titleSuffix, baseCls = container.baseCls;
  me.addCls([baseCls + suffix, baseCls + suffix + '-' + container.ui]);
  Ext.Component.prototype.onAdded.call(this, container, pos, instanced);
}, applyGlyph:function(glyph, oldGlyph) {
  if (glyph) {
    if (!glyph.isGlyph) {
      glyph = new Ext.Glyph(glyph);
    }
    if (glyph.isEqual(oldGlyph)) {
      glyph = undefined;
    }
  }
  return glyph;
}, updateGlyph:function(glyph, oldGlyph) {
  var me = this, glyphCls = me._glyphCls, iconEl;
  if (me.rendered) {
    me._syncIconVisibility();
    iconEl = me.iconEl;
    if (glyph) {
      iconEl.dom.innerHTML = glyph.character;
      iconEl.addCls(glyphCls);
      iconEl.setStyle('font-family', glyph.fontFamily);
    } else {
      if (oldGlyph !== glyph) {
        iconEl.dom.innerHTML = '';
        iconEl.removeCls(glyphCls);
      }
    }
    if (me._didIconStateChange(oldGlyph, glyph)) {
      me.updateLayout();
    }
  }
}, updateIcon:function(icon, oldIcon) {
  icon = icon || '';
  var me = this, iconEl;
  if (me.rendered && icon !== oldIcon) {
    me._syncIconVisibility();
    iconEl = me.iconEl;
    iconEl.setStyle('background-image', icon ? 'url(' + icon + ')' : '');
    if (me._didIconStateChange(oldIcon, icon)) {
      me.updateLayout();
    }
  }
}, updateIconAlign:function(align, oldAlign) {
  var me = this, iconWrapEl = me.iconWrapEl, el, iconAlignClasses;
  if (me.iconWrapEl) {
    el = me.el;
    iconAlignClasses = me._iconAlignClasses;
    if (oldAlign) {
      iconWrapEl.removeCls(iconAlignClasses[oldAlign]);
    }
    iconWrapEl.addCls(iconAlignClasses[align]);
    if (align === 'top' || align === 'left') {
      el.insertFirst(iconWrapEl);
    } else {
      el.appendChild(iconWrapEl);
    }
    me.updateLayout();
  }
}, updateIconCls:function(cls, oldCls) {
  cls = cls || '';
  var me = this, iconEl;
  if (me.rendered && oldCls !== cls) {
    me._syncIconVisibility();
    iconEl = me.iconEl;
    if (oldCls) {
      iconEl.removeCls(oldCls);
    }
    iconEl.addCls(cls);
    if (me._didIconStateChange(oldCls, cls)) {
      me.updateLayout();
    }
  }
}, updateRotation:function(rotation, oldRotation) {
  var me = this, el, rotationClasses;
  if (me.rendered) {
    el = me.el;
    rotationClasses = me._rotationClasses;
    me.removeCls(rotationClasses[oldRotation]);
    me.addCls(rotationClasses[rotation]);
    el.setHorizontal();
    if (rotation) {
      el.setVertical(me._rotationAngles[rotation]);
    }
    el.setStyle({right:'', left:'', top:'', height:'', width:''});
    me.lastBox = null;
    me.updateLayout();
  }
}, updateText:function(text) {
  if (this.rendered) {
    this.textEl.setHtml(text);
    this.updateLayout();
  }
}, updateTextAlign:function(align, oldAlign) {
  var me = this, textAlignClasses = me._textAlignClasses;
  if (me.rendered) {
    if (oldAlign) {
      me.removeCls(textAlignClasses[oldAlign]);
    }
    me.addCls(textAlignClasses[align]);
    me.updateLayout();
  }
}, privates:{_getVerticalAdjustDirection:function() {
  return 'left';
}, _didIconStateChange:function(old, current) {
  var currentEmpty = Ext.isEmpty(current);
  return Ext.isEmpty(old) ? !currentEmpty : currentEmpty;
}, _hasIcon:function() {
  return !!(this.getIcon() || this.getIconCls() || this.getGlyph());
}, _syncIconVisibility:function() {
  var me = this, el = me.el, hasIcon = me._hasIcon(), iconWrapEl = me.iconWrapEl, isBefore, iconAlign;
  if (hasIcon && !iconWrapEl) {
    iconAlign = me.iconAlign;
    isBefore = iconAlign === 'left' || iconAlign === 'top';
    el.dom.insertAdjacentHTML(isBefore ? 'afterbegin' : 'beforeend', me.getIconMarkup());
    iconWrapEl = me.iconWrapEl = el[isBefore ? 'first' : 'last']();
    me.iconEl = iconWrapEl.first();
  }
  if (iconWrapEl) {
    iconWrapEl.setDisplayed(hasIcon);
  }
}}}, 0, ['title'], ['component', 'box', 'title'], {'component':true, 'box':true, 'title':true}, ['widget.title'], 0, [Ext.panel, 'Title'], 0);
Ext.cmd.derive('Ext.panel.Tool', Ext.Component, {config:{glyph:null}, isTool:true, baseCls:'x-tool', disabledCls:'x-tool-disabled', toolPressedCls:'x-tool-pressed', toolOverCls:'x-tool-over', childEls:['toolEl'], renderTpl:['\x3cdiv id\x3d"{id}-toolEl" data-ref\x3d"toolEl" class\x3d"{className} {childElCls}" role\x3d"presentation"\x3ctpl if\x3d"glyph"\x3e\x3ctpl if\x3d"glyphFontFamily"\x3e style\x3d"font-family:{glyphFontFamily};"\x3e\x3c/tpl\x3e{glyph}\x3ctpl else\x3e\x3e\x3c/tpl\x3e\x3c/div\x3e'], 
toolOwner:null, tooltipType:'qtip', stopEvent:true, ariaRole:'button', focusable:true, tabIndex:0, keyMap:{scope:'this', SPACE:'onClick', ENTER:'onClick'}, cacheHeight:true, cacheWidth:true, initComponent:function() {
  var me = this;
  me.tooltip = me.tooltip || me.qtip;
  Ext.Component.prototype.initComponent.call(this);
}, initRenderData:function() {
  var me = this, data = Ext.Component.prototype.initRenderData.call(this), glyph = me.getGlyph(), glyphFontFamily;
  if (glyph) {
    glyphFontFamily = glyph.fontFamily;
    glyph = glyph.character;
  }
  Ext.applyIf(data, {className:me.calculateClassName(), glyph:glyph, glyphFontFamily:glyphFontFamily});
  return data;
}, calculateClassName:function() {
  var me = this, result = me.baseCls + '-tool-el ';
  if (me.type) {
    result += me.baseCls + '-img ' + me.baseCls + '-' + me.type;
  } else {
    if (me.iconCls) {
      result += me.iconCls;
    }
  }
  return result;
}, afterRender:function() {
  var me = this, tip;
  Ext.Component.prototype.afterRender.call(this);
  if (me.setTypeAfterRender) {
    me.setTypeAfterRender = false;
    me.setType(me.type);
  }
  me.el.on({click:me.onClick, mousedown:me.onMouseDown, mouseover:me.onMouseOver, mouseout:me.onMouseOut, scope:me});
  tip = me.tooltip;
  if (tip) {
    me.setTooltip(tip);
  }
}, tipAttrs:{qtip:'data-qtip'}, setTooltip:function(tooltip, type) {
  var me = this, oldTip = me.tooltip, oldType = me.tooltipType, id = me.id, el = me.el, attr;
  if (oldTip && Ext.quickTipsActive && Ext.isObject(oldTip)) {
    Ext.tip.QuickTipManager.unregister(id);
  }
  me.tooltip = tooltip;
  if (type) {
    me.tooltipType = type;
  }
  if (tooltip) {
    if (Ext.quickTipsActive && Ext.isObject(tooltip)) {
      Ext.tip.QuickTipManager.register(Ext.apply({target:id}, tooltip));
    } else {
      if (el) {
        if (type && oldType && type !== oldType) {
          attr = me.tipAttrs[oldType] || 'title';
          el.dom.removeAttribute(attr);
        }
        attr = me.tipAttrs[type || oldType] || 'title';
        el.dom.setAttribute(attr, tooltip);
      }
    }
    if (attr !== 'title' && me.ariaRole && me.ariaRole !== 'presentation') {
      if (el) {
        el.dom.setAttribute('aria-label', tooltip);
      } else {
        me.ariaRenderAttributes = me.ariaRenderAttributes || {};
        me.ariaRenderAttributes['aria-label'] = tooltip;
      }
    }
  }
}, setType:function(type) {
  var me = this, toolEl = me.toolEl, updating = me.updating, rendering = me.rendering, oldClassName, clear;
  if (!updating) {
    oldClassName = me.calculateClassName();
    if (!rendering) {
      me.updating = clear = true;
    }
    me.setIconCls(null);
    me.setGlyph(null);
  }
  me.type = type;
  if (clear) {
    me.updateToolCls(oldClassName);
    me.updating = false;
  } else {
    if (rendering) {
      me.setTypeAfterRender = true;
    }
  }
  return me;
}, setIconCls:function(iconCls) {
  var me = this, toolEl = me.toolEl, updating = me.updating, oldClassName, clear;
  if (!updating) {
    oldClassName = me.calculateClassName();
    me.updating = clear = true;
    me.setType(null);
    me.setGlyph(null);
  }
  me.iconCls = iconCls;
  if (clear) {
    me.updateToolCls(oldClassName);
    me.updating = false;
  }
  return me;
}, doDestroy:function() {
  var me = this;
  me.setTooltip(null);
  delete me.toolOwner;
  Ext.Component.prototype.doDestroy.call(this);
}, applyGlyph:function(glyph, oldGlyph) {
  if (glyph) {
    if (!glyph.isGlyph) {
      glyph = new Ext.Glyph(glyph);
    }
    if (glyph.isEqual(oldGlyph)) {
      glyph = undefined;
    }
  }
  return glyph;
}, updateGlyph:function(glyph, oldGlyph) {
  var me = this, toolEl = me.toolEl, updating = me.updating, oldClassName, clear;
  if (!updating) {
    oldClassName = me.calculateClassName();
    me.updating = clear = true;
    me.setType(null);
    me.setIconCls(null);
  }
  if (toolEl) {
    if (glyph) {
      toolEl.dom.innerHTML = glyph.character;
      toolEl.setStyle(glyph.getStyle());
    } else {
      toolEl.dom.innerHTML = '';
    }
  }
  if (clear) {
    me.updateToolCls(oldClassName);
    me.updating = false;
  }
}, privates:{onClick:function(e, target) {
  var me = this;
  if (me.disabled) {
    return false;
  }
  if (e.type !== 'keydown') {
    me.el.removeCls(me.toolPressedCls + ' ' + me.toolOverCls);
  }
  if (me.stopEvent !== false) {
    e.stopEvent();
  }
  if (me.handler) {
    Ext.callback(me.handler, me.scope, [e, target, me.ownerCt, me], 0, me);
  } else {
    if (me.callback) {
      Ext.callback(me.callback, me.scope, [me.toolOwner || me.ownerCt, me, e], 0, me);
    }
  }
  if (me.destroyed) {
    return;
  }
  me.fireEvent('click', me, e, me.toolOwner || me.ownerCt);
  return true;
}, onMouseDown:function(e) {
  e.preventDefault();
  if (this.disabled) {
    return false;
  }
  this.el.addCls(this.toolPressedCls);
}, onMouseOver:function() {
  if (this.disabled) {
    return false;
  }
  this.el.addCls(this.toolOverCls);
}, onMouseOut:function() {
  this.el.removeCls(this.toolOverCls);
}, updateToolCls:function(oldCls) {
  var me = this, toolEl = this.toolEl;
  if (toolEl) {
    toolEl.removeCls(oldCls);
    toolEl.addCls(this.calculateClassName());
  }
}}}, 0, ['tool'], ['component', 'box', 'tool'], {'component':true, 'box':true, 'tool':true}, ['widget.tool'], 0, [Ext.panel, 'Tool'], 0);
Ext.cmd.derive('Ext.panel.Header', Ext.panel.Bar, {isHeader:true, defaultType:'tool', indicateDrag:false, weight:-1, shrinkWrap:3, focusableContainer:true, iconAlign:'left', titleAlign:'left', titlePosition:0, titleRotation:'default', autoEl:{role:'presentation'}, beforeRenderConfig:{glyph:null, icon:null, iconCls:null, iconAlign:null, title:{$value:{xtype:'title', flex:1}, merge:function(newValue, oldValue) {
  if (typeof newValue !== 'object') {
    newValue = {text:newValue};
  }
  return Ext.merge(oldValue ? Ext.Object.chain(oldValue) : {}, newValue);
}}, titleAlign:null, titlePosition:null, titleRotation:null}, headerCls:'x-header', initComponent:function() {
  var me = this, items = me.items, itemPosition = me.itemPosition, cls = [me.headerCls];
  me.tools = me.tools || [];
  me.items = items = items ? items.slice() : [];
  if (itemPosition !== undefined) {
    me._userItems = items.slice();
    me.items = items = [];
  }
  me.indicateDragCls = me.headerCls + '-draggable';
  if (me.indicateDrag) {
    cls.push(me.indicateDragCls);
  }
  me.addCls(cls);
  me.syncNoBorderCls();
  Ext.Array.push(items, me.tools);
  me.tools.length = 0;
  Ext.panel.Bar.prototype.initComponent.call(this);
  me.on({dblclick:me.onDblClick, click:me.onClick, element:'el', scope:me});
}, addTool:function(tool) {
  var me = this;
  me.add(Ext.ComponentManager.create(tool, 'tool'));
  me.checkFocusableTools();
}, afterLayout:function() {
  var me = this, frameBR, frameTR, frameTL, xPos;
  if (me.vertical) {
    frameTR = me.frameTR;
    if (frameTR) {
      frameBR = me.frameBR;
      frameTL = me.frameTL;
      xPos = me.getWidth() - frameTR.getPadding('r') - (frameTL ? frameTL.getPadding('l') : me.el.getBorderWidth('l')) + 'px';
      frameBR.setStyle('background-position-x', xPos);
      frameTR.setStyle('background-position-x', xPos);
    }
  }
  Ext.panel.Bar.prototype.afterLayout.call(this);
}, applyTitle:function(title, oldTitle) {
  var me = this, isString, configHasRotation;
  title = title || '';
  isString = Ext.isString(title);
  if (!Ext.isObject(title)) {
    title = {text:title.toString()};
  }
  if (oldTitle) {
    Ext.suspendLayouts();
    oldTitle.setConfig(title);
    Ext.resumeLayouts(true);
    title = oldTitle;
  } else {
    if (isString) {
      title.xtype = 'title';
    }
    title.ui = me.ui;
    configHasRotation = 'rotation' in title;
    title.id = me.id + '-title';
    if (me.isAccordionHeader) {
      title.ariaRole = 'tab';
      title.textElRole = null;
      title.focusable = true;
    }
    title = Ext.create(title);
    if (!configHasRotation && me.vertical && me.titleRotation === 'default') {
      title.rotation = 1;
    }
  }
  return title;
}, applyTitlePosition:function(position) {
  var max = this.items.getCount();
  if (this._titleInItems) {
    --max;
  }
  return Math.max(Math.min(position, max), 0);
}, beforeLayout:function() {
  Ext.panel.Bar.prototype.beforeLayout.call(this);
  this.syncBeforeAfterTitleClasses();
}, beforeRender:function() {
  var me = this, itemPosition = me.itemPosition;
  me.protoEl.unselectable();
  Ext.panel.Bar.prototype.beforeRender.call(this);
  if (itemPosition !== undefined) {
    me.insert(itemPosition, me._userItems);
  }
  me.checkFocusableTools();
}, checkFocusableTools:function() {
  var me = this, tools = me.tools, haveFocusableTool, i, len;
  if (me.isAccordionHeader) {
    me.focusableContainer = false;
    return;
  }
  for (i = 0, len = tools.length; i < len; i++) {
    if (tools[i].focusable) {
      haveFocusableTool = true;
      break;
    }
  }
  if (haveFocusableTool) {
    if (!me.initialConfig.hasOwnProperty('focusableContainer') || me.focusableContainer) {
      me.ariaRole = 'toolbar';
      me.focusableContainer = true;
      if (me.rendered) {
        me.ariaEl.dom.setAttribute('role', 'toolbar');
        me.initFocusableContainer(true);
      }
    }
  } else {
    me.ariaRole = 'presentation';
    me.focusableContainer = false;
    if (me.rendered) {
      me.ariaEl.dom.setAttribute('role', 'presentation');
      me.initFocusableContainer(true);
    }
  }
}, getTools:function() {
  return this.tools.slice();
}, onAdd:function(component, index) {
  var tools = this.tools;
  Ext.panel.Bar.prototype.onAdd.call(this, component, index);
  if (component.isTool) {
    tools.push(component);
    tools[component.type] = component;
  }
}, onAdded:function(container, pos, instanced) {
  this.syncNoBorderCls();
  Ext.panel.Bar.prototype.onAdded.call(this, container, pos, instanced);
}, onRemoved:function(container, pos, instanced) {
  this.syncNoBorderCls();
  Ext.panel.Bar.prototype.onRemoved.call(this, container, pos, instanced);
}, setDock:function(dock) {
  var me = this, title = me.getTitle(), rotation = me.getTitleRotation(), titleRotation = title.getRotation();
  Ext.suspendLayouts();
  Ext.panel.Bar.prototype.setDock.call(this, dock);
  if (rotation === 'default') {
    rotation = me.vertical ? 1 : 0;
    if (rotation !== titleRotation) {
      title.setRotation(rotation);
    }
    if (me.rendered) {
      me.resetItemMargins();
    }
  }
  Ext.resumeLayouts(true);
}, updateGlyph:function(glyph) {
  this.getTitle().setGlyph(glyph);
}, updateIcon:function(icon) {
  this.getTitle().setIcon(icon);
}, updateIconAlign:function(align, oldAlign) {
  this.getTitle().setIconAlign(align);
}, updateIconCls:function(cls) {
  this.getTitle().setIconCls(cls);
}, updateTitle:function(title, oldTitle) {
  if (!oldTitle) {
    this.insert(this.getTitlePosition(), title);
    this._titleInItems = true;
  }
  this.titleCmp = title;
}, updateTitleAlign:function(align, oldAlign) {
  this.getTitle().setTextAlign(align);
}, updateTitlePosition:function(position) {
  this.insert(position, this.getTitle());
}, updateTitleRotation:function(rotation) {
  if (rotation === 'default') {
    rotation = this.vertical ? 1 : 0;
  }
  this.getTitle().setRotation(rotation);
}, privates:{fireClickEvent:function(type, e) {
  var toolCls = '.' + Ext.panel.Tool.prototype.baseCls;
  if (!e.getTarget(toolCls)) {
    this.fireEvent(type, this, e);
  }
}, getFramingInfoCls:function() {
  var me = this, cls = Ext.panel.Bar.prototype.getFramingInfoCls.call(this), owner = me.ownerCt;
  if (!me.expanding && owner && (owner.collapsed || me.isCollapsedExpander)) {
    cls += '-' + owner.collapsedCls;
  }
  return cls + '-' + me.dock;
}, onClick:function(e) {
  this.fireClickEvent('click', e);
}, onDblClick:function(e) {
  this.fireClickEvent('dblclick', e);
}, syncBeforeAfterTitleClasses:function(force) {
  var me = this, items = me.items, childItems = items.items, titlePosition = me.getTitlePosition(), itemCount = childItems.length, itemGeneration = items.generation, syncGen = me.syncBeforeAfterGen, afterCls, beforeCls, i, item;
  if (!force && syncGen === itemGeneration) {
    return;
  }
  me.syncBeforeAfterGen = itemGeneration;
  for (i = 0; i < itemCount; ++i) {
    item = childItems[i];
    afterCls = item.afterTitleCls || (item.afterTitleCls = item.baseCls + '-after-title');
    beforeCls = item.beforeTitleCls || (item.beforeTitleCls = item.baseCls + '-before-title');
    if (!me.title || i < titlePosition) {
      if (syncGen) {
        item.removeCls(afterCls);
      }
      item.addCls(beforeCls);
    } else {
      if (i > titlePosition) {
        if (syncGen) {
          item.removeCls(beforeCls);
        }
        item.addCls(afterCls);
      }
    }
  }
}, syncNoBorderCls:function() {
  var me = this, ownerCt = this.ownerCt, noBorderCls = me.headerCls + '-noborder';
  if (ownerCt ? ownerCt.border === false && !ownerCt.frame : me.border === false) {
    me.addCls(noBorderCls);
  } else {
    me.removeCls(noBorderCls);
  }
}}}, 0, ['header'], ['component', 'box', 'container', 'header'], {'component':true, 'box':true, 'container':true, 'header':true}, ['widget.header'], 0, [Ext.panel, 'Header'], 0);
Ext.cmd.derive('Ext.layout.container.boxOverflow.None', Ext.Base, {alternateClassName:'Ext.layout.boxOverflow.None', factoryConfig:{defaultType:'none'}, isBoxOverflowHandler:true, $configPrefixed:false, $configStrict:false, constructor:function(config) {
  this.initConfig(config);
}, handleOverflow:Ext.emptyFn, clearOverflow:Ext.emptyFn, beginLayout:Ext.emptyFn, beginLayoutCycle:Ext.emptyFn, calculate:function(ownerContext) {
  var me = this, plan = ownerContext.state.boxPlan, overflow;
  if (plan && plan.tooNarrow) {
    overflow = me.handleOverflow(ownerContext);
    if (overflow) {
      if (overflow.reservedSpace) {
        me.layout.publishInnerCtSize(ownerContext, overflow.reservedSpace);
      }
    }
  } else {
    me.clearOverflow();
  }
}, completeLayout:Ext.emptyFn, finishedLayout:function(ownerContext) {
  var me = this, owner = me.layout.owner, hiddens, hiddenCount;
  if (owner.hasListeners.overflowchange) {
    hiddens = owner.query('\x3e[hidden]');
    hiddenCount = hiddens.length;
    if (hiddenCount !== me.lastHiddenCount) {
      owner.fireEvent('overflowchange', me.lastHiddenCount, hiddenCount, hiddens);
      me.lastHiddenCount = hiddenCount;
    }
  }
}, onRemove:Ext.emptyFn, getItem:function(item) {
  return this.layout.owner.getComponent(item);
}, getOwnerType:function(owner) {
  var type;
  if (owner.isToolbar) {
    type = 'toolbar';
  } else {
    if (owner.isTabBar) {
      type = 'tab-bar';
    } else {
      if (owner.isMenu) {
        type = 'menu';
      } else {
        if (owner.isBreadcrumb) {
          type = 'breadcrumb';
        } else {
          type = owner.getXType();
        }
      }
    }
  }
  return type;
}, getPrefixConfig:Ext.emptyFn, getSuffixConfig:Ext.emptyFn, getOverflowCls:function() {
  return '';
}, setVertical:function() {
  var me = this, layout = me.layout, innerCt = layout.innerCt;
  innerCt.removeCls(me.getOverflowCls(layout.oppositeDirection));
  innerCt.addCls(me.getOverflowCls(layout.direction));
}}, 1, 0, 0, 0, ['box.overflow.None', 'box.overflow.none'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.layout.container.boxOverflow, 'None', Ext.layout.boxOverflow, 'None'], 0);
Ext.cmd.derive('Ext.layout.container.boxOverflow.Scroller', Ext.layout.container.boxOverflow.None, {alternateClassName:'Ext.layout.boxOverflow.Scroller', animateScroll:false, scrollIncrement:20, wheelIncrement:10, scrollRepeatInterval:60, scrollDuration:400, scrollerCls:'x-box-scroller', beforeSuffix:'-before-scroller', afterSuffix:'-after-scroller', constructor:function(config) {
  var me = this;
  me.mixins.observable.constructor.call(me, config);
  me.layout.owner.on({afterrender:me.onOwnerRender, scope:me, single:true});
  me.layout.owner.getOverflowEl = me.ownerGetOverflowImpl;
  me.scrollPosition = 0;
  me.scrollSize = 0;
}, onOwnerRender:function(owner) {
  var me = this, scrollable = {isBoxOverflowScroller:true, x:false, y:false, listeners:{scrollend:this.onScrollEnd, scope:this}};
  if (!Ext.getScrollbarSize().width && !Ext.platformTags.desktop) {
    scrollable[owner.layout.horizontal ? 'x' : 'y'] = true;
  } else {
    me.wheelListener = me.layout.innerCt.on('mousewheel', me.onMouseWheel, me, {destroyable:true});
  }
  owner.setScrollable(scrollable);
}, getPrefixConfig:function() {
  return {role:'presentation', id:this.layout.owner.id + this.beforeSuffix, cls:this.createScrollerCls('beforeX'), style:'display:none'};
}, getSuffixConfig:function() {
  return {role:'presentation', id:this.layout.owner.id + this.afterSuffix, cls:this.createScrollerCls('afterX'), style:'display:none'};
}, createScrollerCls:function(xName) {
  var me = this, layout = me.layout, owner = layout.owner, type = me.getOwnerType(owner), scrollerCls = me.scrollerCls, cls = scrollerCls + ' ' + scrollerCls + '-' + layout.names[xName] + ' ' + scrollerCls + '-' + type + ' ' + scrollerCls + '-' + type + '-' + owner.ui;
  if (owner.plain) {
    cls += ' ' + scrollerCls + '-plain';
  }
  return cls;
}, getOverflowCls:function(direction) {
  return this.scrollerCls + '-body-' + direction;
}, beginLayout:function(ownerContext) {
  ownerContext.innerCtScrollPos = this.getScrollPosition();
  Ext.layout.container.boxOverflow.None.prototype.beginLayout.apply(this, arguments);
}, finishedLayout:function(ownerContext) {
  var me = this, plan = ownerContext.state.boxPlan, layout = me.layout, names = layout.names, scrollPos = Math.min(me.getMaxScrollPosition(), ownerContext.innerCtScrollPos), lastProps;
  if (plan && plan.tooNarrow) {
    lastProps = ownerContext.childItems[ownerContext.childItems.length - 1].props;
    me.scrollSize = lastProps[names.x] + lastProps[names.width];
    me.updateScrollButtons();
    layout.innerCt[names.setScrollLeft](scrollPos);
  }
  Ext.layout.container.boxOverflow.None.prototype.finishedLayout.call(this, ownerContext);
}, handleOverflow:function(ownerContext) {
  var me = this, names = me.layout.names, getWidth = names.getWidth, parallelMargins = names.parallelMargins, scrollerWidth, targetPaddingWidth, beforeScroller, afterScroller;
  me.showScrollers();
  beforeScroller = me.getBeforeScroller();
  afterScroller = me.getAfterScroller();
  scrollerWidth = beforeScroller[getWidth]() + afterScroller[getWidth]() + beforeScroller.getMargin(parallelMargins) + afterScroller.getMargin(parallelMargins);
  targetPaddingWidth = ownerContext.targetContext.getPaddingInfo()[names.width];
  return {reservedSpace:Math.max(scrollerWidth - targetPaddingWidth, 0)};
}, getBeforeScroller:function() {
  var me = this;
  return me._beforeScroller || (me._beforeScroller = me.createScroller(me.beforeSuffix, 'beforeRepeater', 'scrollLeft'));
}, getAfterScroller:function() {
  var me = this;
  return me._afterScroller || (me._afterScroller = me.createScroller(me.afterSuffix, 'afterRepeater', 'scrollRight'));
}, createScroller:function(suffix, repeaterName, scrollHandler) {
  var me = this, owner = me.layout.owner, scrollerCls = me.scrollerCls, scrollerEl;
  scrollerEl = owner.el.getById(owner.id + suffix);
  scrollerEl.addClsOnOver(scrollerCls + '-hover');
  scrollerEl.addClsOnClick(scrollerCls + '-pressed');
  scrollerEl.setVisibilityMode(Ext.Element.DISPLAY);
  me[repeaterName] = new Ext.util.ClickRepeater(scrollerEl, {interval:me.scrollRepeatInterval, handler:scrollHandler, scope:me});
  return scrollerEl;
}, onMouseWheel:function(e) {
  var cmp = Ext.Component.from(e.target), cmpScroller = cmp.getScrollable && cmp.getScrollable();
  if (!cmpScroller || cmpScroller === this.layout.owner.getScrollable()) {
    e.stopEvent();
    this.scrollBy(this.getWheelDelta(e) * this.wheelIncrement * -1, false);
  }
}, getWheelDelta:function(e) {
  return e.getWheelDelta();
}, clearOverflow:function() {
  this.hideScrollers();
}, showScrollers:function() {
  var me = this;
  me.getBeforeScroller().show();
  me.getAfterScroller().show();
  me.layout.owner.addClsWithUI(me.layout.direction === 'vertical' ? 'vertical-scroller' : 'scroller');
}, hideScrollers:function() {
  var me = this, beforeScroller = me.getBeforeScroller(), afterScroller = me.getAfterScroller();
  if (beforeScroller) {
    beforeScroller.hide();
    afterScroller.hide();
    me.layout.owner.removeClsWithUI(me.layout.direction === 'vertical' ? 'vertical-scroller' : 'scroller');
  }
}, destroy:function() {
  Ext.destroyMembers(this, 'beforeRepeater', 'afterRepeater', '_beforeScroller', '_afterScroller', 'wheelListener');
  this.callParent();
}, scrollBy:function(delta, animate) {
  var layout = this.layout, scroller = layout.owner.getScrollable(), args = [0, 0, animate ? this.getScrollAnim() : false];
  args[layout.horizontal ? 0 : 1] = delta;
  scroller.scrollBy.apply(scroller, args);
}, getScrollAnim:function() {
  return {duration:this.scrollDuration, callback:this.updateScrollButtons, scope:this};
}, updateScrollButtons:function() {
  var me = this, beforeScroller = me.getBeforeScroller(), afterScroller = me.getAfterScroller(), scrollPos = me.getScrollPosition(), disabledCls;
  if (!beforeScroller || !afterScroller) {
    return;
  }
  disabledCls = me.scrollerCls + '-disabled';
  beforeScroller[scrollPos ? 'removeCls' : 'addCls'](disabledCls);
  afterScroller[scrollPos >= me.getMaxScrollPosition() ? 'addCls' : 'removeCls'](disabledCls);
}, scrollLeft:function() {
  this.scrollBy(-this.scrollIncrement, false);
}, scrollRight:function() {
  this.scrollBy(this.scrollIncrement, false);
}, getScrollPosition:function() {
  var layout = this.layout;
  return layout.owner.getScrollable().getPosition()[layout.horizontal ? 'x' : 'y'];
}, getMaxScrollPosition:function() {
  var layout = this.layout;
  return layout.owner.getScrollable().getMaxPosition()[layout.horizontal ? 'x' : 'y'];
}, setVertical:function() {
  var me = this, beforeScroller = me.getBeforeScroller(), afterScroller = me.getAfterScroller(), names = me.layout.names, scrollerCls = me.scrollerCls;
  beforeScroller.removeCls(scrollerCls + '-' + names.beforeY);
  afterScroller.removeCls(scrollerCls + '-' + names.afterY);
  beforeScroller.addCls(scrollerCls + '-' + names.beforeX);
  afterScroller.addCls(scrollerCls + '-' + names.afterX);
  Ext.layout.container.boxOverflow.None.prototype.setVertical.call(this);
}, scrollTo:function(position, animate) {
  var layout = this.layout, scroller = layout.owner.getScrollable(), args = [0, 0, animate ? this.getScrollAnim() : false];
  args[layout.horizontal ? 0 : 1] = position;
  scroller.scrollTo.apply(scroller, args);
}, onScrollEnd:function(scroller, x, y) {
  this.updateScrollButtons();
  this.fireEvent('scroll', this, this.layout.horizontal ? x : y, false);
}, scrollToItem:function(item, animate) {
  item = this.getItem(item);
  if (item !== undefined) {
    this.layout.owner.getScrollable().ensureVisible(item.el, {animation:animate});
  }
}, privates:{ownerGetOverflowImpl:function() {
  return this.layout.innerCt;
}}}, 1, 0, 0, 0, ['box.overflow.Scroller', 'box.overflow.scroller'], [['observable', Ext.mixin.Observable]], [Ext.layout.container.boxOverflow, 'Scroller', Ext.layout.boxOverflow, 'Scroller'], 0);
Ext.cmd.derive('Ext.dd.DragDropManager', Ext.Base, {singleton:true, alternateClassName:['Ext.dd.DragDropMgr', 'Ext.dd.DDM'], ids:{}, handleIds:{}, dragCurrent:null, dragOvers:{}, deltaX:0, deltaY:0, preventDefault:true, stopPropagation:false, initialized:false, locked:false, init:function() {
  this.initialized = true;
}, POINT:0, INTERSECT:1, mode:0, notifyOccluded:false, dragCls:'x-dd-drag-current', currentPoint:new Ext.util.Point, _execOnAll:function(sMethod, args) {
  var ids = this.ids, i, j, oDD, item;
  for (i in ids) {
    if (ids.hasOwnProperty(i)) {
      item = ids[i];
      for (j in item) {
        if (item.hasOwnProperty(j)) {
          oDD = item[j];
          if (!this.isTypeOfDD(oDD)) {
            continue;
          }
          oDD[sMethod].apply(oDD, args);
        }
      }
    }
  }
}, addListeners:function() {
  var me = this;
  me.init();
  Ext.getWin().on({unload:me._onUnload, resize:me._onResize, scope:me});
}, _onResize:function(e) {
  this._execOnAll('resetConstraints', []);
}, lock:function() {
  this.locked = true;
}, unlock:function() {
  this.locked = false;
}, isLocked:function() {
  return this.locked;
}, locationCache:{}, useCache:true, clickPixelThresh:8, dragThreshMet:false, clickTimeout:null, startX:0, startY:0, regDragDrop:function(oDD, sGroup) {
  if (!this.initialized) {
    this.init();
  }
  if (!this.ids[sGroup]) {
    this.ids[sGroup] = {};
  }
  this.ids[sGroup][oDD.id] = oDD;
}, removeDDFromGroup:function(oDD, sGroup) {
  if (!this.ids[sGroup]) {
    this.ids[sGroup] = {};
  }
  var obj = this.ids[sGroup];
  if (obj && obj[oDD.id]) {
    delete obj[oDD.id];
  }
}, _remove:function(oDD, clearGroup) {
  var me = this, ids = me.ids, groups = oDD.groups, g;
  if (me.clearingAll) {
    return;
  }
  if (me.dragCurrent === oDD) {
    me.dragCurrent = null;
  }
  for (g in groups) {
    if (groups.hasOwnProperty(g)) {
      if (clearGroup) {
        delete ids[g];
      } else {
        if (ids[g]) {
          delete ids[g][oDD.id];
        }
      }
    }
  }
  delete me.handleIds[oDD.id];
  delete me.locationCache[oDD.id];
}, regHandle:function(sDDId, sHandleId) {
  if (!this.handleIds[sDDId]) {
    this.handleIds[sDDId] = {};
  }
  this.handleIds[sDDId][sHandleId] = sHandleId;
}, isDragDrop:function(id) {
  return this.getDDById(id) ? true : false;
}, getRelated:function(p_oDD, bTargetsOnly) {
  var oDDs = [], i, j, dd;
  for (i in p_oDD.groups) {
    for (j in this.ids[i]) {
      dd = this.ids[i][j];
      if (!this.isTypeOfDD(dd)) {
        continue;
      }
      if (!bTargetsOnly || dd.isTarget) {
        oDDs[oDDs.length] = dd;
      }
    }
  }
  return oDDs;
}, isLegalTarget:function(oDD, oTargetDD) {
  var targets = this.getRelated(oDD, true), i, len;
  for (i = 0, len = targets.length; i < len; ++i) {
    if (targets[i].id === oTargetDD.id) {
      return true;
    }
  }
  return false;
}, isTypeOfDD:function(oDD) {
  return oDD && oDD.__ygDragDrop;
}, isHandle:function(sDDId, sHandleId) {
  return this.handleIds[sDDId] && this.handleIds[sDDId][sHandleId];
}, getDDById:function(id, force) {
  var i, dd;
  for (i in this.ids) {
    dd = this.ids[i][id];
    if (dd instanceof Ext.dd.DDTarget || force) {
      return dd;
    }
  }
  return null;
}, handleMouseDown:function(e, oDD) {
  var me = this, xy = e.getXY(), el = oDD.getEl(), pointerup = {translate:false, fn:me.handleMouseUp, capture:false, priority:-1000}, pointermove = {translate:false, fn:me.handleMouseMove, capture:false}, listeners = {capture:true, destroyable:true, scope:me}, DomEventType = e.browserEvent.type;
  listeners.touchstart = me.handleMouseUp;
  if (DomEventType === 'pointerdown') {
    listeners.pointerup = pointerup;
    listeners.pointermove = pointermove;
  } else {
    if (DomEventType === 'MSPointerDown') {
      listeners.MSPointerUp = pointerup;
      listeners.MSPointerMove = pointermove;
    } else {
      if (DomEventType === 'mousedown') {
        listeners.mouseup = pointerup;
        listeners.mousemove = pointermove;
      } else {
        listeners.touchend = pointerup;
        listeners.touchmove = pointermove;
      }
    }
  }
  me.pointerMoveListeners = Ext.getDoc().on(listeners);
  me.isMouseDown = true;
  me.currentPoint.setPosition(xy);
  if (me.dragCurrent) {
    me.handleMouseUp(e);
  }
  me.mousedownEvent = e;
  me.currentTarget = e.getTarget();
  me.dragCurrent = oDD;
  Ext.fly(el).setCapture();
  me.startX = xy[0];
  me.startY = xy[1];
  me.offsetX = me.offsetY = 0;
  me.deltaX = me.startX - el.offsetLeft;
  me.deltaY = me.startY - el.offsetTop;
  me.dragThreshMet = false;
}, startDrag:function(x, y) {
  var me = this, current = me.dragCurrent, dragEl;
  Ext.undefer(me.clickTimeout);
  if (Ext.quickTipsActive) {
    Ext.tip.QuickTipManager.ddDisable();
  }
  if (current) {
    current.b4StartDrag(x, y);
    current.startDrag(x, y);
    dragEl = Ext.fly(current.getDragEl());
    if (dragEl) {
      dragEl.addCls(me.dragCls);
      if (dragEl.shim && dragEl.shim.el) {
        dragEl.shim.el.addCls(me.dragCls);
      }
    }
  }
  me.dragThreshMet = true;
}, handleMouseUp:function(e) {
  var me = this;
  me.pointerMoveListeners.destroy();
  me.isMouseDown = false;
  if (!me.dragCurrent) {
    return;
  }
  if (Ext.isIE && document.releaseCapture) {
    document.releaseCapture();
  }
  Ext.undefer(me.clickTimeout);
  if (me.dragThreshMet) {
    me.fireEvents(e, true);
  }
  me.stopDrag(e);
  if (me.dragThreshMet) {
    me.stopEvent(e);
  }
  me.mousedownEvent = me.currentTarget = null;
}, stopEvent:function(e) {
  if (this.stopPropagation) {
    e.stopPropagation();
  }
  if (this.preventDefault && e.pointerType === 'touch') {
    e.preventDefault();
  }
}, stopDrag:function(e) {
  var me = this, current = me.dragCurrent, dragEl;
  if (Ext.quickTipsActive) {
    Ext.tip.QuickTipManager.ddEnable();
  }
  if (current) {
    if (me.dragThreshMet) {
      dragEl = Ext.fly(current.getDragEl());
      if (dragEl) {
        dragEl.removeCls(me.dragCls);
        if (dragEl.shim && dragEl.shim.el) {
          dragEl.shim.el.removeCls(me.dragCls);
        }
      }
      current.b4EndDrag(e);
      current.endDrag(e);
    }
    me.dragCurrent.onMouseUp(e);
  }
  me.dragCurrent = null;
  me.dragOvers = {};
}, handleMouseMove:function(e) {
  var me = this, current = me.dragCurrent, point = e.getXY(), currentX = point[0], currentY = point[1], diffX, diffY;
  me.offsetX = currentX - me.startX;
  me.offsetY = currentY - me.startY;
  me.currentPoint.setPosition(point);
  if (!current) {
    return true;
  }
  if (!me.dragThreshMet) {
    diffX = Math.abs(me.offsetX);
    diffY = Math.abs(me.offsetY);
    if (diffX > me.clickPixelThresh || diffY > me.clickPixelThresh) {
      e.claimGesture();
      me.startDrag(me.startX, me.startY);
    }
  }
  if (me.dragThreshMet) {
    current.b4Drag(e);
    current.onDrag(e);
    if (!current.moveOnly) {
      me.fireEvents(e, false);
    }
  }
  me.stopEvent(e);
  return true;
}, fireEvents:function(e, isDrop) {
  var me = this, isTouch = Ext.supports.Touch, dragCurrent = me.dragCurrent, mousePoint = me.currentPoint, allTargets = [], oldOvers = [], outEvts = [], overEvts = [], dropEvts = [], enterEvts = [], dragEl, overTarget, overTargetEl, needsSort, i, len, sGroup, overDragEl;
  if (!dragCurrent || dragCurrent.isLocked()) {
    return;
  }
  overDragEl = !(dragCurrent.deltaX < 0 || dragCurrent.deltaY < 0);
  if (isTouch || !me.notifyOccluded && (!Ext.supports.CSSPointerEvents || Ext.isIE10m || Ext.isOpera) && overDragEl) {
    dragEl = dragCurrent.getDragEl();
    if (overDragEl) {
      dragEl.style.visibility = 'hidden';
    }
    e = e.chain({target:me.elementFromPoint(e.clientX, e.clientY) || document.documentElement});
    if (overDragEl) {
      dragEl.style.visibility = 'visible';
    }
  }
  for (i in me.dragOvers) {
    overTarget = me.dragOvers[i];
    delete me.dragOvers[i];
    if (!me.isTypeOfDD(overTarget) || overTarget.destroyed) {
      continue;
    }
    if (isDrop) {
      outEvts.push(overTarget);
    } else {
      if (me.notifyOccluded) {
        if (!this.isOverTarget(mousePoint, overTarget, me.mode)) {
          outEvts.push(overTarget);
        }
      } else {
        if (!e.within(overTarget.getEl())) {
          outEvts.push(overTarget);
        }
      }
    }
    oldOvers[i] = true;
  }
  for (sGroup in dragCurrent.groups) {
    if ('string' !== typeof sGroup) {
      continue;
    }
    for (i in me.ids[sGroup]) {
      overTarget = me.ids[sGroup][i];
      if (me.isTypeOfDD(overTarget) && (overTargetEl = overTarget.getEl()) && overTarget.isTarget && !overTarget.isLocked() && Ext.fly(overTargetEl).isVisible(true) && (overTarget !== dragCurrent || dragCurrent.ignoreSelf === false)) {
        if (me.notifyOccluded) {
          if ((overTarget.zIndex = me.getZIndex(overTargetEl)) !== -1) {
            needsSort = true;
          }
          allTargets.push(overTarget);
        } else {
          if (e.within(overTargetEl)) {
            allTargets.push(overTarget);
            break;
          }
        }
      }
    }
  }
  if (needsSort) {
    Ext.Array.sort(allTargets, me.byZIndex);
  }
  for (i = 0, len = allTargets.length; i < len; i++) {
    overTarget = allTargets[i];
    if (me.isOverTarget(mousePoint, overTarget, me.mode)) {
      if (isDrop) {
        dropEvts.push(overTarget);
      } else {
        if (!oldOvers[overTarget.id]) {
          enterEvts.push(overTarget);
        } else {
          overEvts.push(overTarget);
        }
        me.dragOvers[overTarget.id] = overTarget;
      }
      if (!me.notifyOccluded) {
        break;
      }
    }
  }
  if (me.mode) {
    if (enterEvts.length) {
      dragCurrent.onDragEnter(e, enterEvts);
    }
    if (overEvts.length) {
      dragCurrent.b4DragOver(e, overEvts);
      dragCurrent.onDragOver(e, overEvts);
    }
    if (dropEvts.length) {
      dragCurrent.b4DragDrop(e, dropEvts);
      dragCurrent.onDragDrop(e, dropEvts);
    }
    if (outEvts.length) {
      dragCurrent.b4DragOut(e, outEvts);
      dragCurrent.onDragOut(e, outEvts);
    }
  } else {
    for (i = 0, len = enterEvts.length; i < len; ++i) {
      dragCurrent.onDragEnter(e, enterEvts[i].id);
    }
    for (i = 0, len = overEvts.length; i < len; ++i) {
      dragCurrent.b4DragOver(e, overEvts[i].id);
      dragCurrent.onDragOver(e, overEvts[i].id);
    }
    for (i = 0, len = dropEvts.length; i < len; ++i) {
      dragCurrent.b4DragDrop(e, dropEvts[i].id);
      dragCurrent.onDragDrop(e, dropEvts[i].id);
    }
    for (i = 0, len = outEvts.length; i < len; ++i) {
      dragCurrent.b4DragOut(e, outEvts[i].id);
      dragCurrent.onDragOut(e, outEvts[i].id);
    }
  }
  if (isDrop && !dropEvts.length) {
    dragCurrent.onInvalidDrop(e);
  }
}, elementFromPoint:function(x, y) {
  if (Ext.rootInheritedState.rtl) {
    x = Ext.Element.getViewportWidth() - x;
  }
  return Ext.Element.fromPoint(x, y, true);
}, getZIndex:function(element) {
  var body = document.body, z, zIndex = -1;
  element = Ext.getDom(element);
  while (element !== body) {
    if (!isNaN(z = Number(Ext.fly(element).getStyle('zIndex')))) {
      zIndex = z;
    }
    element = element.parentNode;
  }
  return zIndex;
}, byZIndex:function(d1, d2) {
  return d1.zIndex < d2.zIndex;
}, getBestMatch:function(dds) {
  var winner = null, len = dds.length, i, dd;
  if (len === 1) {
    winner = dds[0];
  } else {
    for (i = 0; i < len; ++i) {
      dd = dds[i];
      if (dd.cursorIsOver) {
        winner = dd;
        break;
      } else {
        if (!winner || winner.overlap.getArea() < dd.overlap.getArea()) {
          winner = dd;
        }
      }
    }
  }
  return winner;
}, refreshCache:function(groups) {
  var sGroup, i, oDD, loc;
  for (sGroup in groups) {
    if ('string' !== typeof sGroup) {
      continue;
    }
    for (i in this.ids[sGroup]) {
      oDD = this.ids[sGroup][i];
      if (this.isTypeOfDD(oDD)) {
        loc = this.getLocation(oDD);
        if (loc) {
          this.locationCache[oDD.id] = loc;
        } else {
          delete this.locationCache[oDD.id];
        }
      }
    }
  }
}, verifyEl:function(el) {
  return Ext.getBody().contains(el);
}, getLocation:function(oDD) {
  if (!this.isTypeOfDD(oDD)) {
    return null;
  }
  if (oDD.getRegion) {
    return oDD.getRegion();
  }
  var el = oDD.getEl(), pos, x1, x2, y1, y2, t, r, b, l;
  try {
    pos = Ext.fly(el).getXY();
  } catch (e$36) {
  }
  if (!pos) {
    return null;
  }
  x1 = pos[0];
  x2 = x1 + el.offsetWidth;
  y1 = pos[1];
  y2 = y1 + el.offsetHeight;
  t = y1 - oDD.padding[0];
  r = x2 + oDD.padding[1];
  b = y2 + oDD.padding[2];
  l = x1 - oDD.padding[3];
  return new Ext.util.Region(t, r, b, l);
}, isOverTarget:function(pt, oTarget, intersect) {
  var loc = this.locationCache[oTarget.id], dc, pos, el, curRegion, overlap;
  if (!loc || !this.useCache) {
    loc = this.getLocation(oTarget);
    this.locationCache[oTarget.id] = loc;
  }
  if (!loc) {
    return false;
  }
  oTarget.cursorIsOver = loc.contains(pt);
  dc = this.dragCurrent;
  if (!dc || !dc.getTargetCoord || !intersect && !dc.constrainX && !dc.constrainY) {
    return oTarget.cursorIsOver;
  }
  oTarget.overlap = null;
  pos = dc.getTargetCoord(pt.x, pt.y);
  el = dc.getDragEl();
  curRegion = new Ext.util.Region(pos.y, pos.x + el.offsetWidth, pos.y + el.offsetHeight, pos.x);
  overlap = curRegion.intersect(loc);
  if (overlap) {
    oTarget.overlap = overlap;
    return intersect ? true : oTarget.cursorIsOver;
  } else {
    return false;
  }
}, _onUnload:function(e, me) {
  Ext.dd.DragDropManager.unregAll();
}, unregAll:function() {
  var me = this, cache = me.elementCache, i;
  if (me.dragCurrent) {
    me.stopDrag();
    me.dragCurrent = null;
  }
  me.clearingAll = true;
  me._execOnAll('unreg', []);
  delete me.clearingAll;
  for (i in cache) {
    delete cache[i];
  }
  me.elementCache = {};
  me.ids = {};
  me.handleIds = {};
}, elementCache:{}, getElWrapper:function(id) {
  var oWrapper = this.elementCache[id];
  if (!oWrapper || !oWrapper.el) {
    oWrapper = this.elementCache[id] = new this.ElementWrapper(Ext.getDom(id));
  }
  return oWrapper;
}, getElement:function(id) {
  return Ext.getDom(id);
}, getCss:function(id) {
  var el = Ext.getDom(id);
  return el ? el.style : null;
}, ElementWrapper:function(el) {
  this.el = el || null;
  this.id = this.el && el.id;
  this.css = this.el && el.style;
}, getPosX:function(el) {
  return Ext.fly(el).getX();
}, getPosY:function(el) {
  return Ext.fly(el).getY();
}, swapNode:function(n1, n2) {
  if (n1.swapNode) {
    n1.swapNode(n2);
  } else {
    var p = n2.parentNode, s = n2.nextSibling;
    if (s === n1) {
      p.insertBefore(n1, n2);
    } else {
      if (n2 === n1.nextSibling) {
        p.insertBefore(n2, n1);
      } else {
        n1.parentNode.replaceChild(n2, n1);
        p.insertBefore(n1, s);
      }
    }
  }
}, getScroll:function() {
  var doc = window.document, docEl = doc.documentElement, body = doc.body, top = 0, left = 0;
  if (docEl && (docEl.scrollTop || docEl.scrollLeft)) {
    top = docEl.scrollTop;
    left = docEl.scrollLeft;
  } else {
    if (body) {
      top = body.scrollTop;
      left = body.scrollLeft;
    }
  }
  return {top:top, left:left};
}, getStyle:function(el, styleProp) {
  return Ext.fly(el).getStyle(styleProp);
}, getScrollTop:function() {
  return this.getScroll().top;
}, getScrollLeft:function() {
  return this.getScroll().left;
}, moveToEl:function(moveEl, targetEl) {
  var aCoord = Ext.fly(targetEl).getXY();
  Ext.fly(moveEl).setXY(aCoord);
}, numericSort:function(a, b) {
  return a - b;
}, handleWasClicked:function(node, id) {
  if (this.isHandle(id, node.id)) {
    return true;
  } else {
    var p = node.parentNode;
    while (p) {
      if (this.isHandle(id, p.id)) {
        return true;
      } else {
        p = p.parentNode;
      }
    }
  }
  return false;
}}, 0, 0, 0, 0, 0, 0, [Ext.dd, 'DragDropManager', Ext.dd, 'DragDropMgr', Ext.dd, 'DDM'], function(DragDropManager) {
  Ext.onInternalReady(function() {
    DragDropManager.addListeners();
  });
});
Ext.cmd.derive('Ext.resizer.Splitter', Ext.Component, {childEls:['collapseEl'], renderTpl:['\x3ctpl if\x3d"collapsible\x3d\x3d\x3dtrue"\x3e', '\x3cdiv id\x3d"{id}-collapseEl" data-ref\x3d"collapseEl" role\x3d"presentation" class\x3d"', 'x-', 'collapse-el ', 'x-', 'layout-split-{collapseDir}{childElCls}"\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e'], isSplitter:true, baseCls:'x-splitter', collapsedClsInternal:'x-splitter-collapsed', canResize:true, collapsible:null, collapseOnDblClick:true, defaultSplitMin:40, 
defaultSplitMax:1000, collapseTarget:'next', horizontal:false, vertical:false, touchAction:undefined, size:5, tracker:null, ariaRole:'separator', focusable:true, tabIndex:0, applyTouchAction:function(touchAction, oldTouchAction) {
  if (touchAction === undefined) {
    touchAction = this.vertical ? {panX:false} : {panY:false};
  }
  return Ext.Component.prototype.applyTouchAction.call(this, touchAction, oldTouchAction);
}, getTrackerConfig:function() {
  return Ext.apply({xclass:'Ext.resizer.SplitterTracker', el:this.el, splitter:this}, this.tracker);
}, beforeRender:function() {
  var me = this, target = me.getCollapseTarget(), collapsible = me.collapsible, ariaAttr;
  Ext.Component.prototype.beforeRender.call(this);
  if (target.collapsed) {
    me.addCls(me.collapsedClsInternal);
  }
  if (!me.canResize) {
    me.addCls(me.baseCls + '-noresize');
  }
  Ext.applyIf(me.renderData, {collapseDir:me.getCollapseDirection(), collapsible:collapsible !== null ? collapsible : target.collapsible});
  me.ariaRenderAttributes = me.ariaRenderAttributes || {};
  me.ariaRenderAttributes['aria-orientation'] = me.orientation;
  me.protoEl.unselectable();
}, onRender:function() {
  var me = this, target, collapseEl;
  Ext.Component.prototype.onRender.apply(this, arguments);
  if (me.performCollapse !== false) {
    if (me.renderData.collapsible) {
      me.mon(me.collapseEl, 'click', me.toggleTargetCmp, me);
    }
    if (me.collapseOnDblClick) {
      me.mon(me.el, 'dblclick', me.toggleTargetCmp, me);
    }
  }
  target = me.getCollapseTarget();
  if (target && target.isPanel) {
    target.on({collapse:me.onTargetCollapse, expand:me.onTargetExpand, beforeexpand:me.onBeforeTargetExpand, beforecollapse:me.onBeforeTargetCollapse, scope:me});
  }
  if (me.canResize) {
    me.tracker = Ext.create(me.getTrackerConfig());
    me.relayEvents(me.tracker, ['beforedragstart', 'dragstart', 'dragend']);
  }
  collapseEl = me.collapseEl;
  if (collapseEl) {
    collapseEl.lastCollapseDirCls = me.collapseDirProps[me.collapseDirection].cls;
  }
}, getCollapseDirection:function() {
  var me = this, dir = me.collapseDirection, collapseTarget, idx, items, type;
  if (!dir) {
    collapseTarget = me.collapseTarget;
    if (collapseTarget.isComponent) {
      dir = collapseTarget.collapseDirection;
    }
    if (!dir) {
      type = me.ownerCt.layout.type;
      if (collapseTarget.isComponent) {
        items = me.ownerCt.items;
        idx = Number(items.indexOf(collapseTarget) === items.indexOf(me) - 1) << 1 | Number(type === 'hbox');
      } else {
        idx = Number(me.collapseTarget === 'prev') << 1 | Number(type === 'hbox');
      }
      dir = ['bottom', 'right', 'top', 'left'][idx];
    }
    me.collapseDirection = dir;
  }
  me.setOrientation(dir === 'top' || dir === 'bottom' ? 'horizontal' : 'vertical');
  return dir;
}, getCollapseTarget:function() {
  var me = this;
  return me.collapseTarget.isComponent ? me.collapseTarget : me.collapseTarget === 'prev' ? me.previousSibling() : me.nextSibling();
}, setCollapseEl:function(display) {
  var el = this.collapseEl;
  if (el) {
    el.setDisplayed(display);
  }
}, onBeforeTargetExpand:function(target) {
  this.setCollapseEl('none');
}, onBeforeTargetCollapse:function() {
  this.setCollapseEl('none');
}, onTargetCollapse:function(target) {
  var me = this;
  if (target === me.getCollapseTarget() && target[me.orientation === 'vertical' ? 'collapsedHorizontal' : 'collapsedVertical']()) {
    me.el.addCls(me.collapsedClsInternal + ' ' + (me.collapsedCls || ''));
  }
  me.setCollapseEl('');
}, onTargetExpand:function(target) {
  var me = this;
  me.el.removeCls(me.collapsedClsInternal + ' ' + (me.collapsedCls || ''));
  me.setCollapseEl('');
}, collapseDirProps:{top:{cls:'x-layout-split-top'}, right:{cls:'x-layout-split-right'}, bottom:{cls:'x-layout-split-bottom'}, left:{cls:'x-layout-split-left'}}, orientationProps:{horizontal:{opposite:'vertical', fixedAxis:'height', stretchedAxis:'width'}, vertical:{opposite:'horizontal', fixedAxis:'width', stretchedAxis:'height'}}, applyCollapseDirection:function() {
  var me = this, collapseEl = me.collapseEl, collapseDirProps = me.collapseDirProps[me.collapseDirection], cls;
  if (collapseEl) {
    cls = collapseEl.lastCollapseDirCls;
    if (cls) {
      collapseEl.removeCls(cls);
    }
    collapseEl.addCls(collapseEl.lastCollapseDirCls = collapseDirProps.cls);
  }
}, applyOrientation:function() {
  var me = this, orientation = me.orientation, orientationProps = me.orientationProps[orientation], defaultSize = me.size, fixedSizeProp = orientationProps.fixedAxis, stretchSizeProp = orientationProps.stretchedAxis, cls = me.baseCls + '-';
  me[orientation] = true;
  me[orientationProps.opposite] = false;
  if (!me.hasOwnProperty(fixedSizeProp) || me[fixedSizeProp] === '100%') {
    me[fixedSizeProp] = defaultSize;
  }
  if (!me.hasOwnProperty(stretchSizeProp) || me[stretchSizeProp] === defaultSize) {
    me[stretchSizeProp] = '100%';
  }
  me.removeCls(cls + orientationProps.opposite);
  me.addCls(cls + orientation);
}, setOrientation:function(orientation) {
  var me = this;
  if (me.orientation !== orientation) {
    me.orientation = orientation;
    me.applyOrientation();
  }
}, updateOrientation:function() {
  delete this.collapseDirection;
  this.getCollapseDirection();
  this.applyCollapseDirection();
}, toggleTargetCmp:function(e, t) {
  var cmp = this.getCollapseTarget(), placeholder = cmp.placeholder, toggle;
  if (Ext.isFunction(cmp.expand) && Ext.isFunction(cmp.collapse)) {
    if (placeholder && !placeholder.hidden) {
      toggle = true;
    } else {
      toggle = !cmp.hidden;
    }
    if (toggle) {
      if (cmp.collapsed || cmp.floatedFromCollapse) {
        cmp.expand();
      } else {
        if (cmp.collapseDirection) {
          cmp.collapse();
        } else {
          cmp.collapse(this.renderData.collapseDir);
        }
      }
    }
  }
}, setSize:function() {
  var me = this;
  Ext.Component.prototype.setSize.apply(this, arguments);
  if (Ext.isIE && me.el) {
    me.el.repaint();
  }
}, doDestroy:function() {
  Ext.destroy(this.tracker);
  Ext.Component.prototype.doDestroy.call(this);
}}, 0, ['splitter'], ['component', 'box', 'splitter'], {'component':true, 'box':true, 'splitter':true}, ['widget.splitter'], 0, [Ext.resizer, 'Splitter'], 0);
Ext.define('Ext.theme.neptune.resizer.Splitter', {override:'Ext.resizer.Splitter', size:8});
Ext.define('Ext.theme.triton.resizer.Splitter', {override:'Ext.resizer.Splitter', size:10});
Ext.cmd.derive('Ext.layout.container.Box', Ext.layout.container.Container, {alternateClassName:'Ext.layout.BoxLayout', type:'box', config:{align:'begin', constrainAlign:false, enableSplitters:true, overflowHandler:{$value:null, merge:function(newValue, oldValue) {
  if (typeof newValue === 'string') {
    newValue = {type:newValue};
  }
  return Ext.merge(oldValue ? Ext.Object.chain(oldValue) : {}, newValue);
}}, padding:0, pack:'start', stretchMaxPartner:undefined, vertical:false, alignRoundingMethod:'round'}, itemCls:'x-box-item', targetCls:'x-box-layout-ct', targetElCls:'x-box-target', innerCls:'x-box-inner', manageMargins:true, createsInnerCt:true, childEls:['innerCt', 'targetEl'], renderTpl:['{%var oc,l\x3dvalues.$comp.layout,oh\x3dl.overflowHandler;if (oh \x26\x26 oh.getPrefixConfig!\x3d\x3dExt.emptyFn) {if(oc\x3doh.getPrefixConfig())dh.generateMarkup(oc, out)}%}\x3cdiv id\x3d"{ownerId}-innerCt" data-ref\x3d"innerCt" role\x3d"presentation" class\x3d"{[l.innerCls]}{[oh ? (" " + oh.getOverflowCls(l.direction)) : ""]}"\x3e\x3cdiv id\x3d"{ownerId}-targetEl" data-ref\x3d"targetEl" class\x3d"{targetElCls}" role\x3d"presentation"\x3e{%this.renderBody(out, values)%}\x3c/div\x3e\x3c/div\x3e{%if (oh \x26\x26 oh.getSuffixConfig!\x3d\x3dExt.emptyFn) {if(oc\x3doh.getSuffixConfig())dh.generateMarkup(oc, out)}%}', 
{disableFormats:true, definitions:'var dh\x3dExt.DomHelper;'}], constructor:function(config) {
  var me = this, type;
  Ext.layout.container.Container.prototype.constructor.call(this, config);
  me.setVertical(me.vertical);
  me.flexSortFn = me.flexSort.bind(me);
  type = typeof me.padding;
  if (type === 'string' || type === 'number') {
    me.padding = Ext.util.Format.parseBox(me.padding);
    me.padding.height = me.padding.top + me.padding.bottom;
    me.padding.width = me.padding.left + me.padding.right;
  }
}, _beginRe:/^(?:begin|left|top)$/, _centerRe:/^(?:center|middle)$/, _endRe:/^(?:end|right|bottom)$/, _percentageRe:/^\s*(\d+(?:\.\d*)?)\s*[%]\s*$/, getItemSizePolicy:function(item, ownerSizeModel) {
  var me = this, policy = me.sizePolicy, align = me.align, flex = item.flex, key = align, names = me.names, heightName = names.height, widthName = names.width, width = item[widthName], height = item[heightName], percentageRe = me._percentageRe, percentageWidth = percentageRe.test(width), isStretch = align === 'stretch', isStretchMax = align === 'stretchmax', constrain = me.constrainAlign;
  if (!ownerSizeModel && (isStretch || flex || percentageWidth || constrain && !isStretchMax)) {
    ownerSizeModel = me.owner.getSizeModel();
  }
  if (isStretch) {
    if (!percentageRe.test(height) && ownerSizeModel[heightName].shrinkWrap) {
      key = 'stretchmax';
    }
  } else {
    if (!isStretchMax) {
      if (percentageRe.test(height)) {
        key = 'stretch';
      } else {
        if (constrain && !ownerSizeModel[heightName].shrinkWrap) {
          key = 'stretchmax';
        } else {
          key = '';
        }
      }
    }
  }
  if (flex || percentageWidth) {
    if (!ownerSizeModel[widthName].shrinkWrap) {
      policy = policy.flex;
    }
  }
  return policy[key];
}, flexSort:function(a, b) {
  var maxWidthName = this.names.maxWidth, minWidthName = this.names.minWidth, infiniteValue = Infinity, aTarget = a.target, bTarget = b.target, aFlex = aTarget.flex, bFlex = bTarget.flex, result = 0, aMin, bMin, aMax, bMax, hasMin, hasMax;
  aMax = aTarget[maxWidthName] || infiniteValue;
  bMax = bTarget[maxWidthName] || infiniteValue;
  aMin = aTarget[minWidthName] || 0;
  bMin = bTarget[minWidthName] || 0;
  hasMin = isFinite(aMin) || isFinite(bMin);
  hasMax = isFinite(aMax) || isFinite(bMax);
  if (hasMin || hasMax) {
    if (hasMax) {
      result = aMax - bMax;
    }
    if (result === 0 && hasMin) {
      result = bMin - aMin;
    }
    if (result === 0) {
      if (hasMax) {
        result = bFlex - aFlex;
      } else {
        result = aFlex - bFlex;
      }
    }
  }
  return result;
}, isItemBoxParent:function(itemContext) {
  return true;
}, isItemShrinkWrap:function(item) {
  return true;
}, roundFlex:function(width) {
  return Math.floor(width);
}, beginCollapse:function(child) {
  var me = this;
  if (me.direction === 'vertical' && child.collapsedVertical()) {
    child.collapseMemento.capture(['flex']);
    delete child.flex;
  } else {
    if (me.direction === 'horizontal' && child.collapsedHorizontal()) {
      child.collapseMemento.capture(['flex']);
      delete child.flex;
    }
  }
}, beginExpand:function(child) {
  child.collapseMemento.restore(['flex']);
}, beginLayout:function(ownerContext) {
  var me = this, owner = me.owner, smp = owner.stretchMaxPartner, style = me.innerCt.dom.style, names = me.names, overflowHandler = me.overflowHandler;
  ownerContext.boxNames = names;
  if (overflowHandler) {
    overflowHandler.beginLayout(ownerContext);
  }
  if (typeof smp === 'string') {
    smp = Ext.getCmp(smp) || owner.query(smp)[0];
  }
  ownerContext.stretchMaxPartner = smp && ownerContext.context.getCmp(smp);
  Ext.layout.container.Container.prototype.beginLayout.call(this, ownerContext);
  ownerContext.innerCtContext = ownerContext.getEl('innerCt', me);
  ownerContext.targetElContext = ownerContext.getEl('targetEl', me);
  ownerContext.ownerScrollable = owner.getScrollable();
  style.width = style.height = '';
}, beginLayoutCycle:function(ownerContext, firstCycle) {
  var me = this, state = ownerContext.state, scrollable = ownerContext.ownerScrollable, align = me.align, names = ownerContext.boxNames, pack = me.pack, centerRe = me._centerRe, overflowHandler = me.overflowHandler, canScroll = ownerContext.state.canScroll, widthModel, heightModel;
  if (overflowHandler) {
    overflowHandler.beginLayoutCycle(ownerContext, firstCycle);
  }
  Ext.layout.container.Container.prototype.beginLayoutCycle.call(this, ownerContext, firstCycle);
  ownerContext.parallelSizeModel = widthModel = ownerContext[names.widthModel];
  ownerContext.perpendicularSizeModel = heightModel = ownerContext[names.heightModel];
  ownerContext.boxOptions = {align:align = {stretch:align === 'stretch', stretchmax:align === 'stretchmax', center:centerRe.test(align), bottom:me._endRe.test(align)}, pack:pack = {center:centerRe.test(pack), end:pack === 'end'}};
  if (scrollable && !scrollable.isBoxOverflowScroller) {
    if (!canScroll) {
      state.canScroll = {parallel:!widthModel.shrinkWrap && scrollable[names.getX](), perpendicular:!heightModel.shrinkWrap && scrollable[names.getY]()};
    }
    if (!state.actualScroll) {
      state.actualScroll = {parallel:false, perpendicular:false};
    }
  }
  if (align.stretch && heightModel.shrinkWrap) {
    align.stretchmax = true;
    align.stretch = false;
  }
  align.nostretch = !(align.stretch || align.stretchmax);
  if (widthModel.shrinkWrap) {
    pack.center = pack.end = false;
  }
  me.cacheFlexes(ownerContext);
  me.targetEl.setWidth(20000);
}, cacheFlexes:function(ownerContext) {
  var me = this, names = ownerContext.boxNames, widthModelName = names.widthModel, heightModelName = names.heightModel, nostretch = ownerContext.boxOptions.align.nostretch, totalFlex = 0, childItems = ownerContext.childItems, i = childItems.length, flexedItems = [], minWidth = 0, smallestHeight = 0, smallestWidth = 0, minWidthName = names.minWidth, minHeightName = names.minHeight, percentageRe = me._percentageRe, percentageWidths = 0, percentageHeights = 0, child, childContext, flex, match, heightModel, 
  widthModel, width, height;
  while (i--) {
    childContext = childItems[i];
    child = childContext.target;
    widthModel = childContext[widthModelName];
    if (widthModel.calculated) {
      childContext.flex = flex = child.flex;
      if (flex) {
        totalFlex += flex;
        flexedItems.push(childContext);
        minWidth += child[minWidthName] || 0;
      } else {
        if (match = percentageRe.exec(child[names.width])) {
          childContext.percentageParallel = parseFloat(match[1]) / 100;
          ++percentageWidths;
        }
      }
    }
    if (widthModel.configured) {
      width = child[names.width];
    } else {
      width = child[minWidthName] || 0;
    }
    smallestWidth += width;
    heightModel = childContext[heightModelName];
    if (nostretch && heightModel.calculated) {
      match = percentageRe.exec(child[names.height]);
      childContext.percentagePerpendicular = parseFloat(match[1]) / 100;
      ++percentageHeights;
    }
    if (heightModel.configured) {
      height = child[names.height];
    } else {
      height = child[minHeightName] || 0;
    }
    if (height > smallestHeight) {
      smallestHeight = height;
    }
  }
  ownerContext.flexedItems = flexedItems;
  ownerContext.flexedMinWidth = minWidth;
  ownerContext.smallestWidth = smallestWidth;
  ownerContext.smallestHeight = smallestHeight;
  ownerContext.totalFlex = totalFlex;
  ownerContext.percentageWidths = percentageWidths;
  ownerContext.percentageHeights = percentageHeights;
  Ext.Array.sort(flexedItems, me.flexSortFn);
}, calculate:function(ownerContext) {
  var me = this, names = ownerContext.boxNames, state = ownerContext.state, actualScroll = state.actualScroll, needsScroll = state.needsScroll, canScroll = state.canScroll, plan = state.boxPlan || (state.boxPlan = {}), overflowHandler = me.overflowHandler;
  plan.targetSize = me.getContainerSize(ownerContext);
  if (canScroll && !needsScroll) {
    state.needsScroll = needsScroll = {parallel:canScroll.parallel && plan.targetSize[names.width] < ownerContext.smallestWidth, perpendicular:canScroll.perpendicular && plan.targetSize[names.height] < ownerContext.smallestHeight};
  }
  if (!state.parallelDone) {
    state.parallelDone = me.calculateParallel(ownerContext, names, plan);
  }
  if (!state.perpendicularDone) {
    state.perpendicularDone = me.calculatePerpendicular(ownerContext, names, plan);
  }
  if (state.parallelDone && state.perpendicularDone) {
    if (canScroll && !state.scrollPass) {
      if (needsScroll.parallel !== actualScroll.parallel || needsScroll.perpendicular !== actualScroll.perpendicular) {
        ownerContext.invalidate({state:{scrollPass:true, canScroll:canScroll, needsScroll:actualScroll}});
        me.done = false;
        return;
      }
    }
    me.publishInnerCtSize(ownerContext);
    if (me.done && ownerContext.boxOptions.align.stretchmax && !state.stretchMaxDone) {
      me.calculateStretchMax(ownerContext, names, plan);
      state.stretchMaxDone = true;
    }
    if (overflowHandler) {
      overflowHandler.calculate(ownerContext);
    }
  } else {
    me.done = false;
  }
}, calculateParallel:function(ownerContext, names, plan) {
  var me = this, widthShrinkWrap = ownerContext.parallelSizeModel.shrinkWrap, widthName = names.width, childItems = ownerContext.childItems, beforeXName = names.beforeX, afterXName = names.afterX, setWidthName = names.setWidth, childItemsLength = childItems.length, flexedItems = ownerContext.flexedItems, flexedItemsLength = flexedItems.length, pack = ownerContext.boxOptions.pack, padding = me.padding, targetSize = plan.targetSize, containerWidth = targetSize[widthName], state = ownerContext.state, 
  needsScroll = state.needsScroll, canScroll = state.canScroll, totalMargin = 0, left = padding[beforeXName], nonFlexWidth = left + padding[afterXName], scrollbarSize = Ext.getScrollbarSize(), scrollbarWidth = scrollbarSize[names.width], scrollbarHeight = scrollbarSize[names.height], i, childMargins, remainingWidth, remainingFlex, childContext, flex, flexedWidth, contentWidth, childWidth, percentageSpace, availableSpace;
  if (!widthShrinkWrap && !targetSize[names.gotWidth]) {
    return false;
  }
  for (i = 0; i < childItemsLength; ++i) {
    childContext = childItems[i];
    childMargins = childContext.marginInfo || childContext.getMarginInfo();
    totalMargin += childMargins[widthName];
    if (!childContext[names.widthModel].calculated) {
      childWidth = childContext.getProp(widthName);
      nonFlexWidth += childWidth;
      if (isNaN(nonFlexWidth)) {
        return false;
      }
    }
  }
  nonFlexWidth += totalMargin;
  if (ownerContext.percentageWidths) {
    percentageSpace = containerWidth - totalMargin;
    if (isNaN(percentageSpace)) {
      return false;
    }
    for (i = 0; i < childItemsLength; ++i) {
      childContext = childItems[i];
      if (childContext.percentageParallel) {
        childWidth = Math.ceil(percentageSpace * childContext.percentageParallel);
        childWidth = childContext[setWidthName](childWidth);
        nonFlexWidth += childWidth;
      }
    }
  }
  if (widthShrinkWrap) {
    availableSpace = 0;
    plan.tooNarrow = false;
  } else {
    availableSpace = containerWidth - nonFlexWidth;
    if (needsScroll && needsScroll.perpendicular) {
      availableSpace -= scrollbarHeight;
    }
    plan.tooNarrow = availableSpace < ownerContext.flexedMinWidth;
    if (plan.tooNarrow && canScroll && canScroll.parallel) {
      state.actualScroll.parallel = true;
    }
  }
  contentWidth = nonFlexWidth;
  remainingWidth = availableSpace;
  remainingFlex = ownerContext.totalFlex;
  for (i = 0; i < flexedItemsLength; i++) {
    childContext = flexedItems[i];
    flex = childContext.flex;
    flexedWidth = me.roundFlex(flex / remainingFlex * remainingWidth);
    flexedWidth = childContext[setWidthName](flexedWidth);
    contentWidth += flexedWidth;
    remainingWidth = Math.max(0, remainingWidth - flexedWidth);
    remainingFlex -= flex;
  }
  if (pack.center) {
    left += remainingWidth / 2;
    if (left < 0) {
      left = 0;
    }
  } else {
    if (pack.end) {
      left += remainingWidth;
    }
  }
  for (i = 0; i < childItemsLength; ++i) {
    childContext = childItems[i];
    childMargins = childContext.marginInfo;
    left += childMargins[beforeXName];
    childContext.setProp(names.x, left);
    left += childMargins[afterXName] + childContext.props[widthName];
  }
  contentWidth += ownerContext.targetContext.getPaddingInfo()[widthName];
  ownerContext.state.contentWidth = contentWidth;
  if (needsScroll && needsScroll.perpendicular) {
    if (widthShrinkWrap) {
      contentWidth += scrollbarWidth;
    }
    ownerContext[names.hasOverflowY] = true;
    ownerContext.target.componentLayout[names.setWidthInDom] = true;
    ownerContext[names.invalidateScrollY] = Ext.isIE8;
  }
  ownerContext[names.setContentWidth](contentWidth);
  return true;
}, calculatePerpendicular:function(ownerContext, names, plan) {
  var me = this, state = ownerContext.state, needsScroll = state.needsScroll, canScroll = state.canScroll, heightShrinkWrap = ownerContext.perpendicularSizeModel.shrinkWrap, targetSize = plan.targetSize, childItems = ownerContext.childItems, childItemsLength = childItems.length, mmax = Math.max, heightName = names.height, setHeightName = names.setHeight, beforeYName = names.beforeY, topPositionName = names.y, padding = me.padding, top = padding[beforeYName], availHeight = targetSize[heightName] - 
  top - padding[names.afterY], align = ownerContext.boxOptions.align, isStretch = align.stretch, isStretchMax = align.stretchmax, isCenter = align.center, isBottom = align.bottom, constrain = me.constrainAlign, maxHeight = 0, hasPercentageSizes = 0, onBeforeInvalidateChild = me.onBeforeConstrainInvalidateChild, onAfterInvalidateChild = me.onAfterConstrainInvalidateChild, scrollbarHeight = Ext.getScrollbarSize().height, childTop, i, childHeight, childMargins, diff, height, childContext, stretchMaxPartner, 
  stretchMaxChildren, shrinkWrapParallelOverflow, percentagePerpendicular;
  if (!heightShrinkWrap && !targetSize[names.gotHeight]) {
    return false;
  }
  if (isStretch || (isCenter || isBottom) && !heightShrinkWrap) {
    if (isNaN(availHeight)) {
      return false;
    }
  }
  if (needsScroll && needsScroll.parallel) {
    if (heightShrinkWrap) {
      shrinkWrapParallelOverflow = true;
    } else {
      availHeight -= scrollbarHeight;
      plan.targetSize[heightName] -= scrollbarHeight;
    }
  }
  if (isStretch) {
    height = availHeight;
    maxHeight = mmax(height, ownerContext.smallestHeight);
  } else {
    for (i = 0; i < childItemsLength; i++) {
      childContext = childItems[i];
      childMargins = (childContext.marginInfo || childContext.getMarginInfo())[heightName];
      if (!(percentagePerpendicular = childContext.percentagePerpendicular)) {
        childHeight = childContext.getProp(heightName);
      } else {
        ++hasPercentageSizes;
        if (heightShrinkWrap) {
          continue;
        } else {
          childHeight = percentagePerpendicular * availHeight - childMargins;
          childHeight = childContext[setHeightName](childHeight);
        }
      }
      if (!heightShrinkWrap && constrain && childContext[names.heightModel].shrinkWrap && childHeight > availHeight) {
        childContext.invalidate({before:onBeforeInvalidateChild, after:onAfterInvalidateChild, layout:me, childHeight:availHeight, names:names});
        ownerContext.state.parallelDone = false;
      }
      if (isNaN(maxHeight = mmax(maxHeight, childHeight + childMargins, childContext.target[names.minHeight] || 0))) {
        return false;
      }
    }
  }
  if (shrinkWrapParallelOverflow) {
    maxHeight += scrollbarHeight;
    ownerContext[names.hasOverflowX] = true;
    ownerContext.target.componentLayout[names.setHeightInDom] = true;
    ownerContext[names.invalidateScrollX] = Ext.isIE8;
  }
  stretchMaxPartner = ownerContext.stretchMaxPartner;
  if (stretchMaxPartner) {
    ownerContext.setProp('maxChildHeight', maxHeight);
    stretchMaxChildren = stretchMaxPartner.childItems;
    if (stretchMaxChildren && stretchMaxChildren.length) {
      maxHeight = mmax(maxHeight, stretchMaxPartner.getProp('maxChildHeight'));
      if (isNaN(maxHeight)) {
        return false;
      }
    }
  }
  ownerContext[names.setContentHeight](maxHeight + me.padding[heightName] + ownerContext.targetContext.getPaddingInfo()[heightName]);
  if (shrinkWrapParallelOverflow) {
    maxHeight -= scrollbarHeight;
  }
  if (maxHeight > targetSize[heightName] && canScroll && canScroll.perpendicular) {
    state.actualScroll.perpendicular = true;
  }
  plan.maxSize = maxHeight;
  if (isStretchMax) {
    height = maxHeight;
  } else {
    if (isCenter || isBottom || hasPercentageSizes) {
      if (constrain) {
        height = heightShrinkWrap ? maxHeight : availHeight;
      } else {
        height = heightShrinkWrap ? maxHeight : mmax(availHeight, maxHeight);
      }
      height -= ownerContext.innerCtContext.getBorderInfo()[heightName];
    }
  }
  for (i = 0; i < childItemsLength; i++) {
    childContext = childItems[i];
    childMargins = childContext.marginInfo || childContext.getMarginInfo();
    childTop = top + childMargins[beforeYName];
    if (isStretch) {
      childContext[setHeightName](height - childMargins[heightName]);
    } else {
      percentagePerpendicular = childContext.percentagePerpendicular;
      if (heightShrinkWrap && percentagePerpendicular) {
        childMargins = childContext.marginInfo || childContext.getMarginInfo();
        childHeight = percentagePerpendicular * height - childMargins[heightName];
        childHeight = childContext[setHeightName](childHeight);
      }
      if (isCenter) {
        diff = height - childContext.props[heightName];
        if (diff > 0) {
          childTop = top + Math[me.alignRoundingMethod](diff / 2);
        }
      } else {
        if (isBottom) {
          childTop = mmax(0, height - childTop - childContext.props[heightName]);
        }
      }
    }
    childContext.setProp(topPositionName, childTop);
  }
  return true;
}, onBeforeConstrainInvalidateChild:function(childContext, options) {
  var heightModelName = options.names.heightModel;
  if (!childContext[heightModelName].constrainedMin) {
    childContext[heightModelName] = Ext.layout.SizeModel.calculated;
  }
}, onAfterConstrainInvalidateChild:function(childContext, options) {
  var names = options.names;
  childContext.setProp(names.beforeY, 0);
  if (childContext[names.heightModel].calculated) {
    childContext[names.setHeight](options.childHeight);
  }
}, calculateStretchMax:function(ownerContext, names, plan) {
  var me = this, heightName = names.height, widthName = names.width, childItems = ownerContext.childItems, length = childItems.length, height = plan.maxSize, onBeforeStretchMaxInvalidateChild = me.onBeforeStretchMaxInvalidateChild, onAfterStretchMaxInvalidateChild = me.onAfterStretchMaxInvalidateChild, childContext, props, i, childHeight;
  for (i = 0; i < length; ++i) {
    childContext = childItems[i];
    props = childContext.props;
    childHeight = height - childContext.getMarginInfo()[heightName];
    if (childHeight !== props[heightName] || childContext[names.heightModel].constrained) {
      childContext.invalidate({before:onBeforeStretchMaxInvalidateChild, after:onAfterStretchMaxInvalidateChild, layout:me, childWidth:props[widthName], childHeight:childHeight, childX:props.x, childY:props.y, names:names});
    }
  }
}, onBeforeStretchMaxInvalidateChild:function(childContext, options) {
  var heightModelName = options.names.heightModel;
  if (!childContext[heightModelName].constrainedMax) {
    childContext[heightModelName] = Ext.layout.SizeModel.calculated;
  }
}, onAfterStretchMaxInvalidateChild:function(childContext, options) {
  var names = options.names, childHeight = options.childHeight, childWidth = options.childWidth;
  childContext.setProp('x', options.childX);
  childContext.setProp('y', options.childY);
  if (childContext[names.heightModel].calculated) {
    childContext[names.setHeight](childHeight);
  }
  if (childContext[names.widthModel].calculated) {
    childContext[names.setWidth](childWidth);
  }
}, completeLayout:function(ownerContext) {
  var me = this, invalidateScrollX = ownerContext.invalidateScrollX, invalidateScrollY = ownerContext.invalidateScrollY, overflowHandler = me.overflowHandler, dom, el, overflowX, overflowY, styles;
  if (overflowHandler) {
    overflowHandler.completeLayout(ownerContext);
  }
  if (invalidateScrollX || invalidateScrollY) {
    el = me.getTarget();
    dom = el.dom;
    styles = dom.style;
    if (invalidateScrollX) {
      overflowX = el.getStyle('overflowX');
      if (overflowX === 'auto') {
        overflowX = styles.overflowX;
        styles.overflowX = 'scroll';
      } else {
        invalidateScrollX = false;
      }
    }
    if (invalidateScrollY) {
      overflowY = el.getStyle('overflowY');
      if (overflowY === 'auto') {
        overflowY = styles.overflowY;
        styles.overflowY = 'scroll';
      } else {
        invalidateScrollY = false;
      }
    }
    if (invalidateScrollX || invalidateScrollY) {
      dom.scrollWidth;
      if (invalidateScrollX) {
        styles.overflowX = overflowX;
      }
      if (invalidateScrollY) {
        styles.overflowY = overflowY;
      }
    }
  }
}, finishedLayout:function(ownerContext) {
  var overflowHandler = this.overflowHandler;
  if (overflowHandler) {
    overflowHandler.finishedLayout(ownerContext);
  }
  Ext.layout.container.Container.prototype.finishedLayout.call(this, ownerContext);
}, getLayoutItems:function() {
  var items = Ext.layout.container.Container.prototype.getLayoutItems.call(this), n = items.length, lastVisibleItem, hide, i, item, splitAfter, splitBefore, splitter;
  for (i = 0; i < n; ++i) {
    if ((item = items[i]).isSplitter) {
      continue;
    }
    splitter = item.splitter;
    if (item.hidden) {
      if (splitter) {
        if (!splitter.hidden) {
          splitter.hidden = true;
          if (splitter.el) {
            splitter.el.hide();
          }
        }
      }
      continue;
    }
    if (splitter) {
      splitBefore = splitter.collapseTarget === 'next';
    } else {
      splitBefore = false;
    }
    hide = null;
    if (lastVisibleItem && splitAfter) {
      if (splitAfter.hidden) {
        splitAfter.hidden = false;
        if (splitAfter.el) {
          splitAfter.el.show();
        }
      }
      if (splitBefore) {
        hide = true;
      }
    } else {
      if (splitBefore) {
        hide = !lastVisibleItem;
      }
    }
    if (hide !== null && splitter.hidden !== hide) {
      splitter.hidden = hide;
      if (splitter.el) {
        splitter.el.setVisible(!hide);
      }
    }
    splitAfter = !splitBefore && splitter;
    lastVisibleItem = item;
  }
  if (lastVisibleItem && splitAfter && !splitAfter.hidden) {
    splitAfter.hidden = true;
    if (splitAfter.el) {
      splitAfter.el.hide();
    }
  }
  return items;
}, insertSplitter:function(item, index, hidden, splitterCfg) {
  var splitter = {xtype:'splitter', id:item.id + '-splitter', hidden:hidden, splitterFor:item, synthetic:true}, at = index + (splitterCfg.collapseTarget === 'prev' ? 1 : 0);
  splitter[this.names.height] = '100%';
  if (splitterCfg) {
    Ext.apply(splitter, splitterCfg);
  }
  item.splitter = this.owner.add(at, splitter);
}, publishInnerCtSize:function(ownerContext, widthOffset) {
  widthOffset = widthOffset || 0;
  var me = this, state = ownerContext.state, names = ownerContext.boxNames, heightName = names.height, widthName = names.width, align = ownerContext.boxOptions.align, padding = me.padding, plan = state.boxPlan, targetSize = plan.targetSize, height = plan.maxSize, needsScroll = state.needsScroll, innerCtContext = ownerContext.innerCtContext, innerCtWidth, innerCtHeight;
  if (ownerContext.parallelSizeModel.shrinkWrap || plan.tooNarrow && state.canScroll) {
    innerCtWidth = state.contentWidth - ownerContext.targetContext.getPaddingInfo()[widthName];
  } else {
    innerCtWidth = targetSize[widthName];
    if (needsScroll && needsScroll.perpendicular) {
      innerCtWidth -= Ext.getScrollbarSize()[widthName];
    }
  }
  innerCtWidth -= widthOffset;
  me.owner.tooNarrow = plan.tooNarrow;
  if (align.stretch) {
    innerCtHeight = height;
  } else {
    innerCtHeight = plan.maxSize + padding[names.beforeY] + padding[names.afterY] + innerCtContext.getBorderInfo()[heightName];
    if (!ownerContext.perpendicularSizeModel.shrinkWrap && (align.center || align.bottom)) {
      innerCtHeight = Math.max(targetSize[heightName], innerCtHeight);
    }
  }
  innerCtContext[names.setWidth](innerCtWidth);
  innerCtContext[names.setHeight](innerCtHeight);
  ownerContext.targetElContext.setWidth(ownerContext.innerCtContext.props.width - (me.vertical ? 0 : widthOffset || 0));
  if (isNaN(innerCtWidth + innerCtHeight)) {
    me.done = false;
  }
}, onAdd:function(item, index) {
  var me = this, split = me.enableSplitters && !item.isButton && item.split;
  Ext.layout.container.Container.prototype.onAdd.call(this, item, index);
  if (split) {
    if (split === true) {
      split = {collapseTarget:'next'};
    } else {
      if (Ext.isString(split)) {
        split = {collapseTarget:split === 'before' ? 'next' : 'prev'};
      } else {
        split = Ext.apply({collapseTarget:split.side === 'before' ? 'next' : 'prev'}, split);
      }
    }
    me.insertSplitter(item, index, !!item.hidden, split);
  }
}, onRemove:function(comp, isDestroying) {
  var me = this, names = me.names, owner = me.owner, splitter = comp.splitter, overflowHandler = me.overflowHandler, el;
  Ext.layout.container.Container.prototype.onRemove.call(this, comp, isDestroying);
  if (splitter && owner.contains(splitter)) {
    owner.doRemove(splitter, true);
    comp.splitter = null;
  }
  if (overflowHandler) {
    overflowHandler.onRemove(comp);
  }
  if (comp.layoutMarginCap === me.id) {
    delete comp.layoutMarginCap;
  }
  if (!owner.destroying && !isDestroying && comp.rendered) {
    el = comp.getEl();
    if (el) {
      el.setStyle(names.beforeY, '');
      el.setStyle(names.beforeX, '');
      el.setStyle('margin', '');
    }
  }
}, applyOverflowHandler:function(overflowHandler, oldOverflowHandler) {
  var type;
  if (typeof overflowHandler === 'string') {
    overflowHandler = {type:overflowHandler};
  }
  type = overflowHandler.type;
  if (oldOverflowHandler && oldOverflowHandler.type === overflowHandler.type) {
    delete overflowHandler.type;
    oldOverflowHandler.setConfig(overflowHandler);
    return oldOverflowHandler;
  }
  overflowHandler.layout = this;
  return Ext.Factory.boxOverflow(overflowHandler);
}, getRenderTarget:function() {
  return this.targetEl;
}, getElementTarget:function() {
  return this.innerCt;
}, destroy:function() {
  var me = this;
  Ext.destroy(me.innerCt, me.overflowHandler);
  me.flexSortFn = me.innerCt = null;
  Ext.layout.container.Container.prototype.destroy.call(this);
}, getRenderData:function() {
  var data = Ext.layout.container.Container.prototype.getRenderData.call(this);
  data.targetElCls = this.targetElCls;
  return data;
}, updateVertical:function(vertical) {
  var me = this, overflowHandler = me.overflowHandler, owner = me.owner, props = me._props;
  Ext.apply(me, vertical ? props.vbox : props.hbox);
  if (overflowHandler && owner && owner.rendered) {
    overflowHandler.setVertical(vertical);
  }
}, _props:{'hbox':{direction:'horizontal', oppositeDirection:'vertical', horizontal:true, vertical:false, names:{beforeX:'left', beforeScrollX:'left', leftCap:'Left', afterX:'right', width:'width', contentWidth:'contentWidth', minWidth:'minWidth', maxWidth:'maxWidth', widthCap:'Width', widthModel:'widthModel', widthIndex:0, x:'x', getX:'getX', setX:'setX', scrollLeft:'scrollLeft', overflowX:'overflowX', hasOverflowX:'hasOverflowX', invalidateScrollX:'invalidateScrollX', parallelMargins:'lr', center:'middle', 
beforeY:'top', afterY:'bottom', height:'height', contentHeight:'contentHeight', minHeight:'minHeight', maxHeight:'maxHeight', heightCap:'Height', heightModel:'heightModel', heightIndex:1, y:'y', getY:'getY', setY:'setY', overflowY:'overflowY', hasOverflowY:'hasOverflowY', invalidateScrollY:'invalidateScrollY', perpendicularMargins:'tb', getWidth:'getWidth', getHeight:'getHeight', setWidth:'setWidth', setHeight:'setHeight', gotWidth:'gotWidth', gotHeight:'gotHeight', setContentWidth:'setContentWidth', 
setContentHeight:'setContentHeight', setWidthInDom:'setWidthInDom', setHeightInDom:'setHeightInDom', getScrollLeft:'getScrollLeft', setScrollLeft:'setScrollLeft', scrollTo:'scrollTo'}, sizePolicy:{flex:{'':{readsWidth:0, readsHeight:1, setsWidth:1, setsHeight:0}, stretch:{readsWidth:0, readsHeight:0, setsWidth:1, setsHeight:1}, stretchmax:{readsWidth:0, readsHeight:1, setsWidth:1, setsHeight:1}}, '':{readsWidth:1, readsHeight:1, setsWidth:0, setsHeight:0}, stretch:{readsWidth:1, readsHeight:0, setsWidth:0, 
setsHeight:1}, stretchmax:{readsWidth:1, readsHeight:1, setsWidth:0, setsHeight:1}}}, 'vbox':{direction:'vertical', oppositeDirection:'horizontal', horizontal:false, vertical:true, names:{beforeX:'top', beforeScrollX:'top', leftCap:'Top', afterX:'bottom', width:'height', contentWidth:'contentHeight', minWidth:'minHeight', maxWidth:'maxHeight', widthCap:'Height', widthModel:'heightModel', widthIndex:1, x:'y', getX:'getY', setX:'setY', scrollLeft:'scrollTop', overflowX:'overflowY', hasOverflowX:'hasOverflowY', 
invalidateScrollX:'invalidateScrollY', parallelMargins:'tb', center:'center', beforeY:'left', afterY:'right', height:'width', contentHeight:'contentWidth', minHeight:'minWidth', maxHeight:'maxWidth', heightCap:'Width', heightModel:'widthModel', heightIndex:0, y:'x', getY:'getX', setY:'setX', overflowY:'overflowX', hasOverflowY:'hasOverflowX', invalidateScrollY:'invalidateScrollX', perpendicularMargins:'lr', getWidth:'getHeight', getHeight:'getWidth', setWidth:'setHeight', setHeight:'setWidth', gotWidth:'gotHeight', 
gotHeight:'gotWidth', setContentWidth:'setContentHeight', setContentHeight:'setContentWidth', setWidthInDom:'setHeightInDom', setHeightInDom:'setWidthInDom', getScrollLeft:'getScrollTop', setScrollLeft:'setScrollTop', scrollTo:'scrollTo'}, sizePolicy:{flex:{'':{readsWidth:1, readsHeight:0, setsWidth:0, setsHeight:1}, stretch:{readsWidth:0, readsHeight:0, setsWidth:1, setsHeight:1}, stretchmax:{readsWidth:1, readsHeight:0, setsWidth:1, setsHeight:1}}, '':{readsWidth:1, readsHeight:1, setsWidth:0, 
setsHeight:0}, stretch:{readsWidth:0, readsHeight:1, setsWidth:1, setsHeight:0}, stretchmax:{readsWidth:1, readsHeight:1, setsWidth:1, setsHeight:0}}}}}, 1, 0, 0, 0, ['layout.box'], 0, [Ext.layout.container, 'Box', Ext.layout, 'BoxLayout'], 0);
Ext.cmd.derive('Ext.layout.container.HBox', Ext.layout.container.Box, {alternateClassName:'Ext.layout.HBoxLayout', type:'hbox', vertical:false}, 0, 0, 0, 0, ['layout.hbox'], 0, [Ext.layout.container, 'HBox', Ext.layout, 'HBoxLayout'], 0);
Ext.cmd.derive('Ext.layout.container.VBox', Ext.layout.container.Box, {alternateClassName:'Ext.layout.VBoxLayout', type:'vbox', vertical:true}, 0, 0, 0, 0, ['layout.vbox'], 0, [Ext.layout.container, 'VBox', Ext.layout, 'VBoxLayout'], 0);
Ext.cmd.derive('Ext.toolbar.Toolbar', Ext.container.Container, {alternateClassName:'Ext.Toolbar', isToolbar:true, baseCls:'x-toolbar', ariaRole:'toolbar', focusableContainer:true, defaultType:'button', layout:undefined, vertical:undefined, enableOverflow:false, overflowHandler:null, defaultButtonUI:'default-toolbar', defaultFieldUI:'default', defaultFooterButtonUI:'default', defaultFooterFieldUI:'default', trackMenus:true, itemCls:'x-toolbar-item', statics:{shortcuts:{'-':'tbseparator', ' ':'tbspacer'}, 
shortcutsHV:{0:{'-\x3e':{xtype:'tbfill', height:0}}, 1:{'-\x3e':{xtype:'tbfill', width:0}}}}, initComponent:function() {
  var me = this, layout = me.layout, vertical = me.vertical;
  if (vertical === undefined) {
    me.vertical = vertical = me.dock === 'right' || me.dock === 'left';
  }
  me.layout = layout = Ext.applyIf(Ext.isString(layout) ? {type:layout} : layout || {}, {type:vertical ? 'vbox' : 'hbox', align:vertical ? 'stretchmax' : 'middle'});
  if (me.overflowHandler) {
    layout.overflowHandler = me.overflowHandler;
  } else {
    if (me.enableOverflow) {
      layout.overflowHandler = 'menu';
    }
  }
  if (vertical) {
    me.addClsWithUI('vertical');
  }
  if (me.ui === 'footer') {
    me.ignoreBorderManagement = true;
  }
  Ext.container.Container.prototype.initComponent.call(this);
}, afterFirstLayout:function(width, height) {
  var me = this, el = me.layout.getRenderTarget().dom;
  Ext.container.Container.prototype.afterFirstLayout.call(this, width, height);
  if (me.trackMenus) {
    me.addPlugin({ptype:'mouseenter', element:el, delegate:function(e) {
      return e.parentNode === el;
    }, handler:me.onItemOver, scope:me});
  }
}, getRefItems:function(deep) {
  var me = this, items = Ext.container.Container.prototype.getRefItems.apply(this, arguments), layout = me.layout, handler;
  if (deep && (me.enableOverflow || me.overflowHandler === 'menu')) {
    handler = layout.overflowHandler;
    if (handler && handler.menu) {
      items = items.concat(handler.menu.getRefItems(deep));
    }
  }
  return items;
}, lookupComponent:function(c) {
  var args = arguments, shortcut, T;
  if (typeof c === 'string' && c[0] !== '@') {
    T = Ext.toolbar.Toolbar;
    shortcut = T.shortcutsHV[this.vertical ? 1 : 0][c] || T.shortcuts[c];
    if (typeof shortcut === 'string') {
      c = {xtype:shortcut};
    } else {
      if (shortcut) {
        c = Ext.apply({}, shortcut);
      } else {
        c = {xtype:'tbtext', text:c};
      }
    }
    this.applyDefaults(c);
    args = [c];
  }
  return Ext.container.Container.prototype.lookupComponent.apply(this, args);
}, onBeforeAdd:function(component) {
  var me = this, isFooter = me.ui === 'footer', defaultButtonUI = isFooter ? me.defaultFooterButtonUI : me.defaultButtonUI;
  if (component.isSegmentedButton) {
    if (component.getDefaultUI() === 'default' && !component.config.hasOwnProperty('defaultUI')) {
      component.setDefaultUI(defaultButtonUI);
    }
  } else {
    if (component.ui === 'default' && !component.hasOwnProperty('ui')) {
      if (component.isButton) {
        component.ui = defaultButtonUI;
      } else {
        if (component.isFormField) {
          component.ui = isFooter ? me.defaultFooterFieldUI : me.defaultFieldUI;
        }
      }
    }
  }
  if (component instanceof Ext.toolbar.Separator) {
    component.setUI(me.vertical ? 'vertical' : 'horizontal');
  }
  Ext.container.Container.prototype.onBeforeAdd.apply(this, arguments);
}, onAdd:function(component) {
  var me = this;
  if (component.needArrowKeys && me.focusableContainer && !me.hasOwnProperty('focusableContainer')) {
    me.focusableContainer = false;
    me.ariaRole = 'group';
  }
  Ext.container.Container.prototype.onAdd.apply(this, arguments);
  me.trackMenu(component);
}, onRemove:function(c) {
  Ext.container.Container.prototype.onRemove.apply(this, arguments);
  this.trackMenu(c, true);
}, privates:{applyDefaults:function(c) {
  if (!Ext.isString(c)) {
    c = Ext.container.Container.prototype.applyDefaults.apply(this, arguments);
  }
  return c;
}, trackMenu:function(item, remove) {
  var me = this;
  if (item.menu) {
    item[remove ? 'un' : 'on']({menushow:me.onButtonMenuShow, menuhide:me.onButtonMenuHide, scope:me});
  }
}, getChildItemsToDisable:function() {
  return this.items.getRange();
}, onItemOver:function(e, target) {
  var btn = Ext.Component.from(target), activeMenuBtn = this.activeMenuBtn;
  if (activeMenuBtn && activeMenuBtn !== btn && btn.showMenu && btn.menu) {
    btn.focus();
    btn.showMenu(e);
  }
}, onButtonMenuShow:function(btn) {
  this.activeMenuBtn = btn;
}, onButtonMenuHide:function(btn) {
  this.activeMenuBtn = null;
}}}, 0, ['toolbar'], ['component', 'box', 'container', 'toolbar'], {'component':true, 'box':true, 'container':true, 'toolbar':true}, ['widget.toolbar'], 0, [Ext.toolbar, 'Toolbar', Ext, 'Toolbar'], 0);
Ext.define('Ext.theme.neptune.toolbar.Toolbar', {override:'Ext.toolbar.Toolbar', usePlainButtons:false, border:false});
Ext.cmd.derive('Ext.dd.DragDrop', Ext.Base, {constructor:function(id, sGroup, config) {
  if (id) {
    this.init(id, sGroup, config);
  }
}, id:null, config:null, dragElId:null, handleElId:null, invalidHandleTypes:null, invalidHandleIds:null, invalidHandleClasses:null, startPageX:0, startPageY:0, groups:null, locked:false, lock:function() {
  this.locked = true;
}, moveOnly:false, unlock:function() {
  this.locked = false;
}, isTarget:true, padding:null, _domRef:null, __ygDragDrop:true, constrainX:false, constrainY:false, minX:0, maxX:0, minY:0, maxY:0, maintainOffset:false, xTicks:null, yTicks:null, primaryButtonOnly:true, available:false, hasOuterHandles:false, triggerEvent:'mousedown', b4StartDrag:function(x, y) {
}, startDrag:function(x, y) {
}, b4Drag:function(e) {
}, onDrag:function(e) {
}, onDragEnter:function(e, id) {
}, b4DragOver:function(e) {
}, onDragOver:function(e, id) {
}, b4DragOut:function(e) {
}, onDragOut:function(e, id) {
}, b4DragDrop:function(e) {
}, onDragDrop:function(e, id) {
}, onInvalidDrop:function(e) {
}, b4EndDrag:function(e) {
}, endDrag:function(e) {
}, b4MouseDown:function(e) {
}, onMouseDown:function(e) {
}, onMouseUp:function(e) {
}, onAvailable:function() {
}, defaultPadding:{left:0, right:0, top:0, bottom:0}, constrainTo:function(constrainTo, pad, inContent) {
  if (Ext.isNumber(pad)) {
    pad = {left:pad, right:pad, top:pad, bottom:pad};
  }
  pad = pad || this.defaultPadding;
  var ddBox = Ext.get(this.getEl()).getBox(), constrainEl = Ext.get(constrainTo), s = constrainEl.getScroll(), c, constrainDom = constrainEl.dom, xy, topSpace, leftSpace;
  if (constrainDom === document.body) {
    c = {x:s.left, y:s.top, width:Ext.Element.getViewportWidth(), height:Ext.Element.getViewportHeight()};
  } else {
    xy = constrainEl.getXY();
    c = {x:xy[0], y:xy[1], width:constrainDom.clientWidth, height:constrainDom.clientHeight};
  }
  topSpace = ddBox.y - c.y;
  leftSpace = ddBox.x - c.x;
  this.resetConstraints();
  this.setXConstraint(leftSpace - (pad.left || 0), c.width - leftSpace - ddBox.width - (pad.right || 0), this.xTickSize);
  this.setYConstraint(topSpace - (pad.top || 0), c.height - topSpace - ddBox.height - (pad.bottom || 0), this.yTickSize);
}, getEl:function() {
  if (!this._domRef) {
    this._domRef = Ext.getDom(this.id);
  }
  return this._domRef;
}, getDragEl:function() {
  return Ext.getDom(this.dragElId);
}, init:function(id, sGroup, config) {
  var me = this;
  me.el = me.el || Ext.get(id);
  me.initTarget(id, sGroup, config);
  Ext.get(me.id).on(me.triggerEvent, me.handleMouseDown, me);
  if (Ext.supports.Touch && me.triggerEvent === 'longpress') {
    Ext.get(me.id).swallowEvent('contextmenu', true);
  }
}, initTarget:function(id, sGroup, config) {
  this.config = config || {};
  this.DDMInstance = Ext.dd.DragDropManager;
  this.groups = {};
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  this.id = id;
  this.addToGroup(sGroup ? sGroup : 'default');
  this.handleElId = id;
  this.setDragElId(id);
  this.invalidHandleTypes = {A:'A'};
  this.invalidHandleIds = {};
  this.invalidHandleClasses = [];
  this.applyConfig();
  this.handleOnAvailable();
}, applyConfig:function() {
  this.padding = this.config.padding || [0, 0, 0, 0];
  this.isTarget = this.config.isTarget !== false;
  this.maintainOffset = this.config.maintainOffset;
  this.primaryButtonOnly = this.config.primaryButtonOnly !== false;
}, handleOnAvailable:function() {
  this.available = true;
  this.resetConstraints();
  this.onAvailable();
}, setPadding:function(iTop, iRight, iBot, iLeft) {
  if (!iRight && 0 !== iRight) {
    this.padding = [iTop, iTop, iTop, iTop];
  } else {
    if (!iBot && 0 !== iBot) {
      this.padding = [iTop, iRight, iTop, iRight];
    } else {
      this.padding = [iTop, iRight, iBot, iLeft];
    }
  }
}, setInitPosition:function(diffX, diffY) {
  var el = this.getEl(), dx, dy, p;
  if (!this.DDMInstance.verifyEl(el)) {
    return;
  }
  dx = diffX || 0;
  dy = diffY || 0;
  p = Ext.fly(el).getXY();
  this.initPageX = p[0] - dx;
  this.initPageY = p[1] - dy;
  this.lastPageX = p[0];
  this.lastPageY = p[1];
  this.setStartPosition(p);
}, setStartPosition:function(pos) {
  var p = pos || Ext.fly(this.getEl()).getXY();
  this.deltaSetXY = null;
  this.startPageX = p[0];
  this.startPageY = p[1];
}, addToGroup:function(sGroup) {
  this.groups[sGroup] = true;
  this.DDMInstance.regDragDrop(this, sGroup);
}, removeFromGroup:function(sGroup) {
  if (this.groups[sGroup]) {
    delete this.groups[sGroup];
  }
  this.DDMInstance.removeDDFromGroup(this, sGroup);
}, setDragElId:function(id) {
  this.dragElId = id;
}, setHandleElId:function(id) {
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  this.handleElId = id;
  this.DDMInstance.regHandle(this.id, id);
}, setOuterHandleElId:function(id) {
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  Ext.get(id).on(this.triggerEvent, this.handleMouseDown, this);
  this.setHandleElId(id);
  this.hasOuterHandles = true;
}, unreg:function() {
  var me = this, el;
  if (me._domRef) {
    el = Ext.fly(me.id);
    if (el) {
      el.un(me.triggerEvent, me.handleMouseDown, me);
    }
  }
  me._domRef = null;
  me.DDMInstance._remove(me, me.autoGroup);
}, destroy:function() {
  this.unreg();
  this.callParent();
}, isLocked:function() {
  return this.DDMInstance.isLocked() || this.locked;
}, handleMouseDown:function(e, oDD) {
  var me = this;
  if (me.primaryButtonOnly && e.button || me.isLocked()) {
    return;
  }
  me.DDMInstance.refreshCache(me.groups);
  if (me.hasOuterHandles || me.DDMInstance.isOverTarget(e.getPoint(), me)) {
    if (me.clickValidator(e)) {
      me.setStartPosition();
      me.b4MouseDown(e);
      me.onMouseDown(e);
      me.DDMInstance.handleMouseDown(e, me);
      me.DDMInstance.stopEvent(e);
    }
  }
}, clickValidator:function(e) {
  var target = e.getTarget();
  return this.isValidHandleChild(target) && (this.id === this.handleElId || this.DDMInstance.handleWasClicked(target, this.id));
}, addInvalidHandleType:function(tagName) {
  var type = tagName.toUpperCase();
  this.invalidHandleTypes[type] = type;
}, addInvalidHandleId:function(id) {
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  this.invalidHandleIds[id] = id;
}, addInvalidHandleClass:function(cssClass) {
  this.invalidHandleClasses.push(cssClass);
}, removeInvalidHandleType:function(tagName) {
  var type = tagName.toUpperCase();
  delete this.invalidHandleTypes[type];
}, removeInvalidHandleId:function(id) {
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  delete this.invalidHandleIds[id];
}, removeInvalidHandleClass:function(cssClass) {
  var invalidHandleClasses = this.invalidHandleClasses, len = invalidHandleClasses.length, i;
  for (i = 0; i < len; ++i) {
    if (invalidHandleClasses[i] === cssClass) {
      delete invalidHandleClasses[i];
    }
  }
}, isValidHandleChild:function(node) {
  var valid = true, nodeName, i, len;
  try {
    nodeName = node.nodeName.toUpperCase();
  } catch (e$37) {
    nodeName = node.nodeName;
  }
  valid = valid && !this.invalidHandleTypes[nodeName];
  valid = valid && !this.invalidHandleIds[node.id];
  for (i = 0, len = this.invalidHandleClasses.length; valid && i < len; ++i) {
    valid = !Ext.fly(node).hasCls(this.invalidHandleClasses[i]);
  }
  return valid;
}, setXTicks:function(iStartX, iTickSize) {
  this.xTicks = [];
  this.xTickSize = iTickSize;
  var tickMap = {}, i;
  for (i = this.initPageX; i >= this.minX; i = i - iTickSize) {
    if (!tickMap[i]) {
      this.xTicks[this.xTicks.length] = i;
      tickMap[i] = true;
    }
  }
  for (i = this.initPageX; i <= this.maxX; i = i + iTickSize) {
    if (!tickMap[i]) {
      this.xTicks[this.xTicks.length] = i;
      tickMap[i] = true;
    }
  }
  Ext.Array.sort(this.xTicks, this.DDMInstance.numericSort);
}, setYTicks:function(iStartY, iTickSize) {
  this.yTicks = [];
  this.yTickSize = iTickSize;
  var tickMap = {}, i;
  for (i = this.initPageY; i >= this.minY; i = i - iTickSize) {
    if (!tickMap[i]) {
      this.yTicks[this.yTicks.length] = i;
      tickMap[i] = true;
    }
  }
  for (i = this.initPageY; i <= this.maxY; i = i + iTickSize) {
    if (!tickMap[i]) {
      this.yTicks[this.yTicks.length] = i;
      tickMap[i] = true;
    }
  }
  Ext.Array.sort(this.yTicks, this.DDMInstance.numericSort);
}, setXConstraint:function(iLeft, iRight, iTickSize) {
  this.leftConstraint = iLeft;
  this.rightConstraint = iRight;
  this.minX = this.initPageX - iLeft;
  this.maxX = this.initPageX + iRight;
  if (iTickSize) {
    this.setXTicks(this.initPageX, iTickSize);
  }
  this.constrainX = true;
}, clearConstraints:function() {
  this.constrainX = false;
  this.constrainY = false;
  this.clearTicks();
}, clearTicks:function() {
  this.xTicks = null;
  this.yTicks = null;
  this.xTickSize = 0;
  this.yTickSize = 0;
}, setYConstraint:function(iUp, iDown, iTickSize) {
  this.topConstraint = iUp;
  this.bottomConstraint = iDown;
  this.minY = this.initPageY - iUp;
  this.maxY = this.initPageY + iDown;
  if (iTickSize) {
    this.setYTicks(this.initPageY, iTickSize);
  }
  this.constrainY = true;
}, resetConstraints:function() {
  if (this.initPageX || this.initPageX === 0) {
    var dx = this.maintainOffset ? this.lastPageX - this.initPageX : 0, dy = this.maintainOffset ? this.lastPageY - this.initPageY : 0;
    this.setInitPosition(dx, dy);
  } else {
    this.setInitPosition();
  }
  if (this.constrainX) {
    this.setXConstraint(this.leftConstraint, this.rightConstraint, this.xTickSize);
  }
  if (this.constrainY) {
    this.setYConstraint(this.topConstraint, this.bottomConstraint, this.yTickSize);
  }
}, getTick:function(val, tickArray) {
  if (!tickArray) {
    return val;
  } else {
    if (tickArray[0] >= val) {
      return tickArray[0];
    } else {
      var i, len, next, diff1, diff2;
      for (i = 0, len = tickArray.length; i < len; ++i) {
        next = i + 1;
        if (tickArray[next] && tickArray[next] >= val) {
          diff1 = val - tickArray[i];
          diff2 = tickArray[next] - val;
          return diff2 > diff1 ? tickArray[i] : tickArray[next];
        }
      }
      return tickArray[tickArray.length - 1];
    }
  }
}, toString:function() {
  return 'DragDrop ' + this.id;
}}, 3, 0, 0, 0, 0, 0, [Ext.dd, 'DragDrop'], 0);
Ext.cmd.derive('Ext.dd.DD', Ext.dd.DragDrop, {constructor:function(id, sGroup, config) {
  if (id) {
    this.init(id, sGroup, config);
  }
}, scroll:true, autoOffset:function(iPageX, iPageY) {
  var x = iPageX - this.startPageX, y = iPageY - this.startPageY;
  this.setDelta(x, y);
}, setDelta:function(iDeltaX, iDeltaY) {
  this.deltaX = iDeltaX;
  this.deltaY = iDeltaY;
}, setDragElPos:function(iPageX, iPageY) {
  var el = this.getDragEl();
  this.alignElWithMouse(el, iPageX, iPageY);
}, alignElWithMouse:function(el, iPageX, iPageY) {
  var oCoord = this.getTargetCoord(iPageX, iPageY), fly = el.dom ? el : Ext.fly(el, '_dd'), elSize = fly.getSize(), EL = Ext.Element, vpSize, aCoord, newLeft, newTop;
  if (!this.deltaSetXY) {
    vpSize = this.cachedViewportSize = {width:EL.getDocumentWidth(), height:EL.getDocumentHeight()};
    aCoord = [Math.max(0, Math.min(oCoord.x, vpSize.width - elSize.width)), Math.max(0, Math.min(oCoord.y, vpSize.height - elSize.height))];
    fly.setXY(aCoord);
    newLeft = this.getLocalX(fly);
    newTop = fly.getLocalY();
    this.deltaSetXY = [newLeft - oCoord.x, newTop - oCoord.y];
  } else {
    vpSize = this.cachedViewportSize;
    this.setLocalXY(fly, Math.max(0, Math.min(oCoord.x + this.deltaSetXY[0], vpSize.width - elSize.width)), Math.max(0, Math.min(oCoord.y + this.deltaSetXY[1], vpSize.height - elSize.height)));
  }
  this.cachePosition(oCoord.x, oCoord.y);
  this.autoScroll(oCoord.x, oCoord.y, el.offsetHeight, el.offsetWidth);
  return oCoord;
}, cachePosition:function(iPageX, iPageY) {
  if (iPageX) {
    this.lastPageX = iPageX;
    this.lastPageY = iPageY;
  } else {
    var aCoord = Ext.fly(this.getEl()).getXY();
    this.lastPageX = aCoord[0];
    this.lastPageY = aCoord[1];
  }
}, autoScroll:function(x, y, h, w) {
  if (this.scroll) {
    var clientH = Ext.Element.getViewportHeight(), clientW = Ext.Element.getViewportWidth(), st = this.DDMInstance.getScrollTop(), sl = this.DDMInstance.getScrollLeft(), bot = h + y, right = w + x, toBot = clientH + st - y - this.deltaY, toRight = clientW + sl - x - this.deltaX, thresh = 40, scrAmt = document.all ? 80 : 30;
    if (bot > clientH && toBot < thresh) {
      window.scrollTo(sl, st + scrAmt);
    }
    if (y < st && st > 0 && y - st < thresh) {
      window.scrollTo(sl, st - scrAmt);
    }
    if (right > clientW && toRight < thresh) {
      window.scrollTo(sl + scrAmt, st);
    }
    if (x < sl && sl > 0 && x - sl < thresh) {
      window.scrollTo(sl - scrAmt, st);
    }
  }
}, getTargetCoord:function(iPageX, iPageY) {
  var x = iPageX - this.deltaX, y = iPageY - this.deltaY;
  if (this.constrainX) {
    if (x < this.minX) {
      x = this.minX;
    }
    if (x > this.maxX) {
      x = this.maxX;
    }
  }
  if (this.constrainY) {
    if (y < this.minY) {
      y = this.minY;
    }
    if (y > this.maxY) {
      y = this.maxY;
    }
  }
  x = this.getTick(x, this.xTicks);
  y = this.getTick(y, this.yTicks);
  return {x:x, y:y};
}, applyConfig:function() {
  Ext.dd.DragDrop.prototype.applyConfig.call(this);
  this.scroll = this.config.scroll !== false;
}, b4MouseDown:function(e) {
  var xy = e.getXY();
  this.autoOffset(xy[0], xy[1]);
}, b4Drag:function(e) {
  var xy = e.getXY();
  this.setDragElPos(xy[0], xy[1]);
}, toString:function() {
  return 'DD ' + this.id;
}, getLocalX:function(el) {
  return el.getLocalX();
}, setLocalXY:function(el, x, y) {
  el.setLocalXY(x, y);
}}, 3, 0, 0, 0, 0, 0, [Ext.dd, 'DD'], 0);
Ext.cmd.derive('Ext.dd.DDProxy', Ext.dd.DD, {statics:{dragElId:'ygddfdiv'}, constructor:function(id, sGroup, config) {
  if (id) {
    this.init(id, sGroup, config);
    this.initFrame();
  }
}, resizeFrame:true, centerFrame:false, createFrame:function() {
  var self = this, body = document.body, div, s;
  if (!body || !body.firstChild) {
    Ext.defer(function() {
      self.createFrame();
    }, 50);
    return;
  }
  div = this.getDragEl();
  if (!div) {
    div = document.createElement('div');
    div.id = this.dragElId;
    div.setAttribute('role', 'presentation');
    s = div.style;
    s.position = 'absolute';
    s.visibility = 'hidden';
    s.cursor = 'move';
    s.border = '2px solid #aaa';
    s.zIndex = 999;
    body.insertBefore(div, body.firstChild);
  }
}, initFrame:function() {
  this.createFrame();
}, applyConfig:function() {
  Ext.dd.DD.prototype.applyConfig.call(this);
  this.resizeFrame = this.config.resizeFrame !== false;
  this.centerFrame = this.config.centerFrame;
  this.setDragElId(this.config.dragElId || Ext.dd.DDProxy.dragElId);
}, showFrame:function(iPageX, iPageY) {
  var me = this, dragEl = me.getDragEl(), s = dragEl.style;
  me._resizeProxy();
  if (me.centerFrame) {
    me.setDelta(Math.round(parseInt(s.width, 10) / 2), Math.round(parseInt(s.height, 10) / 2));
  }
  me.setDragElPos(iPageX, iPageY);
  Ext.fly(dragEl).show();
}, _resizeProxy:function() {
  if (this.resizeFrame) {
    var el = this.getEl();
    Ext.fly(this.getDragEl()).setSize(el.offsetWidth, el.offsetHeight);
  }
}, b4MouseDown:function(e) {
  var xy = e.getXY(), x = xy[0], y = xy[1];
  this.autoOffset(x, y);
  this.setDragElPos(x, y);
}, b4StartDrag:function(x, y) {
  this.showFrame(x, y);
}, b4EndDrag:function(e) {
  Ext.fly(this.getDragEl()).hide();
}, endDrag:function(e) {
  var lel = this.getEl(), del = this.getDragEl();
  del.style.visibility = '';
  this.beforeMove();
  lel.style.visibility = 'hidden';
  Ext.dd.DDM.moveToEl(lel, del);
  del.style.visibility = 'hidden';
  lel.style.visibility = '';
  this.afterDrag();
}, beforeMove:function() {
}, afterDrag:function() {
}, toString:function() {
  return 'DDProxy ' + this.id;
}}, 3, 0, 0, 0, 0, 0, [Ext.dd, 'DDProxy'], 0);
Ext.cmd.derive('Ext.dd.StatusProxy', Ext.Component, {animRepair:false, childEls:['ghost'], renderTpl:['\x3cdiv class\x3d"x-dd-drop-icon" role\x3d"presentation"\x3e\x3c/div\x3e\x3cdiv id\x3d"{id}-ghost" data-ref\x3d"ghost" class\x3d"x-dd-drag-ghost" role\x3d"presentation"\x3e\x3c/div\x3e'], repairCls:'x-dd-drag-repair', ariaRole:'presentation', skipLayout:true, alignOnScroll:false, constructor:function(config) {
  var me = this;
  config = config || {};
  Ext.apply(me, {hideMode:'visibility', hidden:true, floating:true, id:me.id || Ext.id(), cls:'x-dd-drag-proxy ' + this.dropNotAllowed, shadow:config.shadow || false, renderTo:Ext.getDetachedBody()});
  Ext.Component.prototype.constructor.apply(this, arguments);
  this.dropStatus = this.dropNotAllowed;
}, dropAllowed:'x-dd-drop-ok', dropNotAllowed:'x-dd-drop-nodrop', setStatus:function(cssClass) {
  cssClass = cssClass || this.dropNotAllowed;
  if (this.dropStatus !== cssClass) {
    this.el.replaceCls(this.dropStatus, cssClass);
    this.dropStatus = cssClass;
  }
}, reset:function(clearGhost) {
  var me = this, clsPrefix = 'x-dd-drag-proxy ';
  me.el.replaceCls(clsPrefix + me.dropAllowed, clsPrefix + me.dropNotAllowed);
  me.dropStatus = me.dropNotAllowed;
  if (clearGhost) {
    me.ghost.setHtml('');
  }
}, update:function(html) {
  if (typeof html === 'string') {
    this.ghost.setHtml(html);
  } else {
    this.ghost.setHtml('');
    html.style.margin = '0';
    this.ghost.dom.appendChild(html);
  }
  var el = this.ghost.dom.firstChild;
  if (el) {
    Ext.fly(el).setStyle('float', 'none');
  }
}, getGhost:function() {
  return this.ghost;
}, hide:function(clear) {
  Ext.Component.prototype.hide.call(this);
  if (clear) {
    this.reset(true);
  }
}, stop:function() {
  if (this.anim && this.anim.isAnimated && this.anim.isAnimated()) {
    this.anim.stop();
  }
}, sync:function() {
  this.el.syncUnderlays();
}, repair:function(xy, callback, scope) {
  var me = this;
  me.callback = callback;
  me.scope = scope;
  if (xy && me.animRepair !== false) {
    me.el.addCls(me.repairCls);
    me.el.setUnderlaysVisible(false);
    me.anim = me.el.animate({duration:me.repairDuration || 500, easing:'ease-out', to:{x:xy[0], y:xy[1]}, stopAnimation:true, callback:me.afterRepair, scope:me});
  } else {
    me.afterRepair();
  }
}, afterRepair:function() {
  var me = this;
  me.hide(true);
  me.el.removeCls(me.repairCls);
  if (typeof me.callback === 'function') {
    me.callback.call(me.scope || me);
  }
  delete me.callback;
  delete me.scope;
}}, 1, 0, ['component', 'box'], {'component':true, 'box':true}, 0, 0, [Ext.dd, 'StatusProxy'], 0);
Ext.cmd.derive('Ext.dd.DragSource', Ext.dd.DDProxy, {dropAllowed:'x-dd-drop-ok', dropNotAllowed:'x-dd-drop-nodrop', animRepair:true, repairHighlightColor:'c3daf9', constructor:function(el, config) {
  this.el = Ext.get(el);
  if (!this.dragData) {
    this.dragData = {};
  }
  Ext.apply(this, config);
  if (!this.proxy) {
    this.proxy = new Ext.dd.StatusProxy({id:this.el.id + '-drag-status-proxy', animRepair:this.animRepair});
  }
  Ext.dd.DDProxy.prototype.constructor.call(this, this.el.dom, this.ddGroup || this.group, {dragElId:this.proxy.id, resizeFrame:false, isTarget:false, scroll:this.scroll === true});
  this.dragging = false;
}, getDragData:function(e) {
  return this.dragData;
}, onDragEnter:function(e, id) {
  var target = Ext.dd.DragDropManager.getDDById(id), status;
  this.cachedTarget = target;
  if (this.beforeDragEnter(target, e, id) !== false) {
    if (target.isNotifyTarget) {
      status = target.notifyEnter(this, e, this.dragData);
      this.proxy.setStatus(status);
    } else {
      this.proxy.setStatus(this.dropAllowed);
    }
    if (this.afterDragEnter) {
      this.afterDragEnter(target, e, id);
    }
  }
}, beforeDragEnter:function(target, e, id) {
  return true;
}, onDragOver:function(e, id) {
  var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id), status;
  if (this.beforeDragOver(target, e, id) !== false) {
    if (target.isNotifyTarget) {
      status = target.notifyOver(this, e, this.dragData);
      this.proxy.setStatus(status);
    }
    if (this.afterDragOver) {
      this.afterDragOver(target, e, id);
    }
  }
}, beforeDragOver:function(target, e, id) {
  return true;
}, onDragOut:function(e, id) {
  var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id);
  if (this.beforeDragOut(target, e, id) !== false) {
    if (target.isNotifyTarget) {
      target.notifyOut(this, e, this.dragData);
    }
    this.proxy.reset();
    if (this.afterDragOut) {
      this.afterDragOut(target, e, id);
    }
  }
  this.cachedTarget = null;
}, beforeDragOut:function(target, e, id) {
  return true;
}, onDragDrop:function(e, id) {
  var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id);
  if (this.beforeDragDrop(target, e, id) !== false) {
    if (target.isNotifyTarget) {
      if (target.notifyDrop(this, e, this.dragData) !== false) {
        this.onValidDrop(target, e, id);
      } else {
        this.onInvalidDrop(target, e, id);
      }
    } else {
      this.onValidDrop(target, e, id);
    }
    if (this.afterDragDrop) {
      this.afterDragDrop(target, e, id);
    }
  }
  delete this.cachedTarget;
}, beforeDragDrop:function(target, e, id) {
  return true;
}, onValidDrop:function(target, e, id) {
  this.hideProxy();
  if (this.afterValidDrop) {
    this.afterValidDrop(target, e, id);
  }
}, getRepairXY:function(e, data) {
  return this.el.getXY();
}, onInvalidDrop:function(target, e, id) {
  var me = this;
  if (!e) {
    e = target;
    target = null;
    id = e.getTarget().id;
  }
  if (me.beforeInvalidDrop(target, e, id) !== false) {
    if (me.cachedTarget) {
      if (me.cachedTarget.isNotifyTarget) {
        me.cachedTarget.notifyOut(me, e, me.dragData);
      }
      me.cacheTarget = null;
    }
    me.proxy.repair(me.getRepairXY(e, me.dragData), me.afterRepair, me);
    if (me.afterInvalidDrop) {
      me.afterInvalidDrop(e, id);
    }
  }
}, afterRepair:function() {
  var me = this;
  if (Ext.enableFx) {
    me.el.highlight(me.repairHighlightColor);
  }
  me.dragging = false;
}, beforeInvalidDrop:function(target, e, id) {
  return true;
}, handleMouseDown:function(e) {
  if (this.dragging) {
    return;
  }
  var data = this.getDragData(e);
  if (data && this.onBeforeDrag(data, e) !== false) {
    this.dragData = data;
    this.proxy.stop();
    Ext.dd.DDProxy.prototype.handleMouseDown.apply(this, arguments);
  }
}, onBeforeDrag:function(data, e) {
  return true;
}, onStartDrag:Ext.emptyFn, alignElWithMouse:function() {
  this.proxy.ensureAttachedToBody(true);
  return Ext.dd.DDProxy.prototype.alignElWithMouse.apply(this, arguments);
}, startDrag:function(x, y) {
  this.proxy.reset();
  this.proxy.hidden = false;
  this.dragging = true;
  this.proxy.update('');
  this.onInitDrag(x, y);
  this.proxy.show();
}, onInitDrag:function(x, y) {
  var clone = this.el.dom.cloneNode(true);
  clone.id = Ext.id();
  this.proxy.update(clone);
  this.onStartDrag(x, y);
  return true;
}, getProxy:function() {
  return this.proxy;
}, hideProxy:function() {
  this.proxy.hide();
  this.proxy.reset(true);
  this.dragging = false;
}, triggerCacheRefresh:function() {
  Ext.dd.DDM.refreshCache(this.groups);
}, b4EndDrag:function(e) {
}, endDrag:function(e) {
  this.onEndDrag(this.dragData, e);
}, onEndDrag:function(data, e) {
}, autoOffset:function(x, y) {
  this.setDelta(-12, -20);
}, destroy:function() {
  Ext.destroy(this.proxy);
  Ext.dd.DDProxy.prototype.destroy.call(this);
}}, 1, 0, 0, 0, 0, 0, [Ext.dd, 'DragSource'], 0);
Ext.cmd.derive('Ext.panel.Proxy', Ext.Base, {alternateClassName:'Ext.dd.PanelProxy', moveOnDrag:true, constructor:function(panel, config) {
  var me = this;
  me.panel = panel;
  me.id = me.panel.id + '-ddproxy';
  Ext.apply(me, config);
}, insertProxy:true, setStatus:Ext.emptyFn, reset:Ext.emptyFn, update:Ext.emptyFn, stop:Ext.emptyFn, sync:Ext.emptyFn, getEl:function() {
  return this.ghost.el;
}, getGhost:function() {
  return this.ghost;
}, getProxy:function() {
  return this.proxy;
}, hide:function() {
  var me = this;
  if (me.ghost) {
    if (me.proxy) {
      me.proxy.destroy();
      delete me.proxy;
    }
    me.panel.unghost(null, me.moveOnDrag);
    delete me.ghost;
  }
}, show:function() {
  var me = this, panelSize;
  if (!me.ghost) {
    panelSize = me.panel.getSize();
    me.panel.el.setVisibilityMode(Ext.Element.DISPLAY);
    me.ghost = me.panel.ghost();
    if (me.insertProxy) {
      me.proxy = me.panel.el.insertSibling({role:'presentation', cls:'x-panel-dd-spacer'});
      me.proxy.setSize(panelSize);
    }
  }
}, repair:function(xy, callback, scope) {
  this.hide();
  Ext.callback(callback, scope || this);
}, moveProxy:function(parentNode, before) {
  if (this.proxy) {
    parentNode.insertBefore(this.proxy.dom, before);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.panel, 'Proxy', Ext.dd, 'PanelProxy'], 0);
Ext.cmd.derive('Ext.panel.DD', Ext.dd.DragSource, {constructor:function(panel, cfg) {
  var me = this;
  me.panel = panel;
  me.dragData = {panel:panel};
  me.panelProxy = new Ext.panel.Proxy(panel, cfg);
  me.proxy = me.panelProxy.proxy;
  Ext.dd.DragSource.prototype.constructor.call(this, panel.el, cfg);
  me.setupEl(panel);
}, setupEl:function(panel) {
  var me = this, header = panel.header, el = panel.body;
  if (header) {
    me.setHandleElId(header.id);
    el = header.el;
  }
  if (el) {
    el.setStyle('cursor', 'move');
    me.scroll = false;
  } else {
    panel.on('boxready', me.setupEl, me, {single:true});
  }
}, showFrame:Ext.emptyFn, startDrag:Ext.emptyFn, b4StartDrag:function(x, y) {
  this.panelProxy.show();
}, b4MouseDown:function(e) {
  var xy = e.getXY(), x = xy[0], y = xy[1];
  this.autoOffset(x, y);
}, onInitDrag:function(x, y) {
  this.onStartDrag(x, y);
  return true;
}, createFrame:Ext.emptyFn, getDragEl:function(e) {
  var ghost = this.panelProxy.ghost;
  if (ghost) {
    return ghost.el.dom;
  }
}, endDrag:function(e) {
  this.panelProxy.hide();
  this.panel.saveState();
}, autoOffset:function(x, y) {
  x -= this.startPageX;
  y -= this.startPageY;
  this.setDelta(x, y);
}, onInvalidDrop:function(target, e, id) {
  var me = this;
  if (me.beforeInvalidDrop(target, e, id) !== false) {
    if (me.cachedTarget) {
      if (me.cachedTarget.isNotifyTarget) {
        me.cachedTarget.notifyOut(me, e, me.dragData);
      }
      me.cacheTarget = null;
    }
    if (me.afterInvalidDrop) {
      me.afterInvalidDrop(e, id);
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.panel, 'DD'], 0);
Ext.cmd.derive('Ext.layout.component.Dock', Ext.layout.component.Component, {alternateClassName:'Ext.layout.component.AbstractDock', type:'dock', horzAxisProps:{name:'horz', oppositeName:'vert', dockBegin:'left', dockEnd:'right', horizontal:true, marginBegin:'margin-left', maxSize:'maxWidth', minSize:'minWidth', pos:'x', setSize:'setWidth', shrinkWrapDock:'shrinkWrapDockWidth', size:'width', sizeModel:'widthModel'}, vertAxisProps:{name:'vert', oppositeName:'horz', dockBegin:'top', dockEnd:'bottom', 
horizontal:false, marginBegin:'margin-top', maxSize:'maxHeight', minSize:'minHeight', pos:'y', setSize:'setHeight', shrinkWrapDock:'shrinkWrapDockHeight', size:'height', sizeModel:'heightModel'}, initializedBorders:-1, horizontalCollapsePolicy:{width:true, x:true}, verticalCollapsePolicy:{height:true, y:true}, finishRender:function() {
  var me = this, target, items;
  Ext.layout.component.Component.prototype.finishRender.call(this);
  target = me.getRenderTarget();
  items = me.getDockedItems();
  me.finishRenderItems(target, items);
}, isItemBoxParent:function(itemContext) {
  return true;
}, isItemShrinkWrap:function(item) {
  return true;
}, noBorderClasses:['x-docked-noborder-top', 'x-docked-noborder-right', 'x-docked-noborder-bottom', 'x-docked-noborder-left'], noBorderClassesSides:{top:'x-docked-noborder-top', right:'x-docked-noborder-right', bottom:'x-docked-noborder-bottom', left:'x-docked-noborder-left'}, borderWidthProps:{top:'border-top-width', right:'border-right-width', bottom:'border-bottom-width', left:'border-left-width'}, _itemCls:'x-docked', handleItemBorders:function() {
  var me = this, owner = me.owner, borders, docked, lastItems = me.lastDockedItems, oldBorders = me.borders, currentGeneration = owner.dockedItems.generation, noBorderClassesSides = me.noBorderClassesSides, borderWidthProps = me.borderWidthProps, i, ln, item, dock, side, collapsed = me.collapsed;
  if (me.initializedBorders === currentGeneration || owner.border && !owner.manageBodyBorders || owner.collapsed && owner.collapseMode === 'mini') {
    return;
  }
  me.initializedBorders = currentGeneration;
  me.collapsed = false;
  me.lastDockedItems = docked = me.getLayoutItems();
  me.collapsed = collapsed;
  borders = {top:[], right:[], bottom:[], left:[]};
  for (i = 0, ln = docked.length; i < ln; i++) {
    item = docked[i];
    dock = item.dock;
    if (item.ignoreBorderManagement) {
      continue;
    }
    if (!borders[dock].satisfied) {
      borders[dock].push(item);
      borders[dock].satisfied = true;
    }
    if (!borders.top.satisfied && dock !== 'bottom') {
      borders.top.push(item);
    }
    if (!borders.right.satisfied && dock !== 'left') {
      borders.right.push(item);
    }
    if (!borders.bottom.satisfied && dock !== 'top') {
      borders.bottom.push(item);
    }
    if (!borders.left.satisfied && dock !== 'right') {
      borders.left.push(item);
    }
  }
  if (lastItems) {
    for (i = 0, ln = lastItems.length; i < ln; i++) {
      item = lastItems[i];
      if (!item.destroyed && !item.ignoreBorderManagement && !owner.manageBodyBorders) {
        item.removeCls(me.noBorderClasses);
      }
    }
  }
  if (oldBorders) {
    for (side in oldBorders) {
      if (owner.manageBodyBorders && oldBorders[side].satisfied) {
        owner.setBodyStyle(borderWidthProps[side], '');
      }
    }
  }
  for (side in borders) {
    ln = borders[side].length;
    if (!owner.manageBodyBorders) {
      for (i = 0; i < ln; i++) {
        borders[side][i].addCls(noBorderClassesSides[side]);
      }
      if (!borders[side].satisfied && !owner.bodyBorder || owner.bodyBorder === false) {
        owner.addBodyCls(noBorderClassesSides[side]);
      } else {
        owner.removeBodyCls(noBorderClassesSides[side]);
      }
    } else {
      if (borders[side].satisfied) {
        owner.setBodyStyle(borderWidthProps[side], '1px');
      }
    }
  }
  me.borders = borders;
}, beforeLayoutCycle:function(ownerContext) {
  var me = this, owner = me.owner, shrinkWrap = me.sizeModels.shrinkWrap, shrinkWrapDock = owner.shrinkWrapDock, collapsedHorz, collapsedVert;
  if (owner.collapsed) {
    if (owner.collapsedVertical()) {
      collapsedVert = true;
      ownerContext.measureDimensions = 1;
    } else {
      collapsedHorz = true;
      ownerContext.measureDimensions = 2;
    }
  }
  ownerContext.collapsedVert = collapsedVert;
  ownerContext.collapsedHorz = collapsedHorz;
  if (collapsedVert) {
    ownerContext.heightModel = shrinkWrap;
  } else {
    if (collapsedHorz) {
      ownerContext.widthModel = shrinkWrap;
    }
  }
  shrinkWrapDock = shrinkWrapDock === true ? 3 : shrinkWrapDock || 0;
  ownerContext.shrinkWrapDockHeight = shrinkWrapDock & 1 && ownerContext.heightModel.shrinkWrap;
  ownerContext.shrinkWrapDockWidth = shrinkWrapDock & 2 && ownerContext.widthModel.shrinkWrap;
}, beginLayout:function(ownerContext) {
  var me = this, owner = me.owner, docked = me.getLayoutItems(), layoutContext = ownerContext.context, dockedItemCount = docked.length, lastCollapsedState = me.lastCollapsedState, dockedItems, i, item, itemContext, offsets, collapsed, dock;
  Ext.layout.component.Component.prototype.beginLayout.apply(this, arguments);
  collapsed = owner.getCollapsed();
  if (collapsed !== lastCollapsedState && lastCollapsedState !== undefined) {
    if (me.owner.collapsed) {
      ownerContext.isCollapsingOrExpanding = 1;
      owner.addClsWithUI(owner.collapsedCls);
    } else {
      ownerContext.isCollapsingOrExpanding = 2;
      owner.removeClsWithUI(owner.collapsedCls);
      ownerContext.lastCollapsedState = me.lastCollapsedState;
    }
  }
  me.lastCollapsedState = collapsed;
  ownerContext.dockedItems = dockedItems = [];
  for (i = 0; i < dockedItemCount; i++) {
    item = docked[i];
    if (item.rendered) {
      dock = item.dock;
      itemContext = layoutContext.getCmp(item);
      itemContext.dockedAt = {x:0, y:0};
      itemContext.offsets = offsets = Ext.Element.parseBox(item.offsets || 0);
      itemContext.horizontal = dock === 'top' || dock === 'bottom';
      offsets.width = offsets.left + offsets.right;
      offsets.height = offsets.top + offsets.bottom;
      dockedItems.push(itemContext);
    }
  }
  ownerContext.bodyContext = ownerContext.getEl('body');
}, beginLayoutCycle:function(ownerContext) {
  var me = this, docked = ownerContext.dockedItems, len = docked.length, owner = me.owner, frameBody = owner.frameBody, lastHeightModel = me.lastHeightModel, i, item, dock;
  Ext.layout.component.Component.prototype.beginLayoutCycle.apply(this, arguments);
  if (me.owner.manageHeight) {
    if (me.lastBodyDisplay) {
      owner.body.dom.style.display = me.lastBodyDisplay = '';
    }
  } else {
    if (me.lastBodyDisplay !== 'inline-block') {
      owner.body.dom.style.display = me.lastBodyDisplay = 'inline-block';
    }
    if (lastHeightModel && lastHeightModel.shrinkWrap && !ownerContext.heightModel.shrinkWrap) {
      owner.body.dom.style.marginBottom = '';
    }
  }
  if (ownerContext.widthModel.auto) {
    if (ownerContext.widthModel.shrinkWrap) {
      owner.el.setWidth(null);
    }
    owner.body.setWidth(null);
    if (frameBody) {
      frameBody.setWidth(null);
    }
  }
  if (ownerContext.heightModel.auto) {
    owner.body.setHeight(null);
    if (frameBody) {
      frameBody.setHeight(null);
    }
  }
  if (ownerContext.collapsedVert) {
    ownerContext.setContentHeight(0);
  } else {
    if (ownerContext.collapsedHorz) {
      ownerContext.setContentWidth(0);
    }
  }
  for (i = 0; i < len; i++) {
    item = docked[i].target;
    dock = item.dock;
    if (dock === 'right') {
      item.setLocalX(0);
    } else {
      if (dock !== 'left') {
        continue;
      }
    }
  }
}, calculate:function(ownerContext) {
  var me = this, measure = me.measureAutoDimensions(ownerContext, ownerContext.measureDimensions), state = ownerContext.state, horzDone = state.horzDone, vertDone = state.vertDone, bodyContext = ownerContext.bodyContext, framing, horz, vert, forward, backward;
  ownerContext.borderInfo || ownerContext.getBorderInfo();
  ownerContext.paddingInfo || ownerContext.getPaddingInfo();
  ownerContext.frameInfo || ownerContext.getFrameInfo();
  bodyContext.borderInfo || bodyContext.getBorderInfo();
  bodyContext.paddingInfo || bodyContext.getPaddingInfo();
  if (!ownerContext.frameBorder) {
    if (!(framing = ownerContext.framing)) {
      ownerContext.frameBorder = ownerContext.borderInfo;
      ownerContext.framePadding = ownerContext.paddingInfo;
    } else {
      ownerContext.frameBorder = framing.border;
      ownerContext.framePadding = framing.padding;
    }
  }
  horz = !horzDone && me.createAxis(ownerContext, measure.contentWidth, ownerContext.widthModel, me.horzAxisProps, ownerContext.collapsedHorz);
  vert = !vertDone && me.createAxis(ownerContext, measure.contentHeight, ownerContext.heightModel, me.vertAxisProps, ownerContext.collapsedVert);
  for (forward = 0, backward = ownerContext.dockedItems.length; backward--; ++forward) {
    if (horz) {
      me.dockChild(ownerContext, horz, backward, forward);
    }
    if (vert) {
      me.dockChild(ownerContext, vert, backward, forward);
    }
  }
  if (horz && me.finishAxis(ownerContext, horz)) {
    state.horzDone = horzDone = horz;
  }
  if (vert && me.finishAxis(ownerContext, vert)) {
    state.vertDone = vertDone = vert;
  }
  if (horzDone && vertDone && me.finishConstraints(ownerContext, horzDone, vertDone)) {
    me.finishPositions(ownerContext, horzDone, vertDone);
  } else {
    me.done = false;
  }
}, createAxis:function(ownerContext, contentSize, sizeModel, axisProps, collapsedAxis) {
  var me = this, begin = 0, owner = me.owner, maxSize = owner[axisProps.maxSize], minSize = owner[axisProps.minSize] || 0, dockBegin = axisProps.dockBegin, dockEnd = axisProps.dockEnd, posProp = axisProps.pos, sizeProp = axisProps.size, hasMaxSize = maxSize != null, shrinkWrap = sizeModel.shrinkWrap, bodyContext, framing, padding, end;
  if (shrinkWrap) {
    if (collapsedAxis) {
      end = 0;
    } else {
      bodyContext = ownerContext.bodyContext;
      end = contentSize + bodyContext.borderInfo[sizeProp];
    }
  } else {
    framing = ownerContext.frameBorder;
    padding = ownerContext.framePadding;
    begin = framing[dockBegin] + padding[dockBegin];
    end = ownerContext.getProp(sizeProp) - (framing[dockEnd] + padding[dockEnd]);
  }
  return {shrinkWrap:sizeModel.shrinkWrap, sizeModel:sizeModel, initialBegin:begin, begin:begin, end:end, collapsed:collapsedAxis, horizontal:axisProps.horizontal, ignoreFrameBegin:null, ignoreFrameEnd:null, initialSize:end - begin, maxChildSize:0, hasMinMaxConstraints:(minSize || hasMaxSize) && sizeModel.shrinkWrap, minSize:minSize, maxSize:hasMaxSize ? maxSize : 1000000000, bodyPosProp:me.owner.manageHeight ? posProp : axisProps.marginBegin, dockBegin:dockBegin, dockEnd:dockEnd, posProp:posProp, 
  sizeProp:sizeProp, setSize:axisProps.setSize, shrinkWrapDock:ownerContext[axisProps.shrinkWrapDock], sizeModelName:axisProps.sizeModel, dockedPixelsEnd:0};
}, dockChild:function(ownerContext, axis, backward, forward) {
  var me = this, itemContext = ownerContext.dockedItems[axis.shrinkWrap ? backward : forward], item = itemContext.target, dock = item.dock, sizeProp = axis.sizeProp, pos, size;
  if (item.ignoreParentFrame && ownerContext.isCollapsingOrExpanding) {
    itemContext.clearMarginCache();
  }
  if (!itemContext.marginInfo) {
    itemContext.getMarginInfo();
  }
  if (dock === axis.dockBegin) {
    if (axis.shrinkWrap) {
      pos = me.dockOutwardBegin(ownerContext, itemContext, item, axis);
    } else {
      pos = me.dockInwardBegin(ownerContext, itemContext, item, axis);
    }
  } else {
    if (dock === axis.dockEnd) {
      if (axis.shrinkWrap) {
        pos = me.dockOutwardEnd(ownerContext, itemContext, item, axis);
      } else {
        pos = me.dockInwardEnd(ownerContext, itemContext, item, axis);
      }
    } else {
      if (axis.shrinkWrapDock) {
        size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
        axis.maxChildSize = Math.max(axis.maxChildSize, size);
        pos = 0;
      } else {
        pos = me.dockStretch(ownerContext, itemContext, item, axis);
      }
    }
  }
  itemContext.dockedAt[axis.posProp] = pos;
}, dockInwardBegin:function(ownerContext, itemContext, item, axis) {
  var pos = axis.begin, sizeProp = axis.sizeProp, ignoreParentFrame = item.ignoreParentFrame, delta, size, dock;
  if (ignoreParentFrame) {
    axis.ignoreFrameBegin = itemContext;
    dock = item.dock;
    delta = ownerContext.frameBorder[dock];
    pos -= delta + ownerContext.framePadding[dock];
  }
  if (!item.overlay) {
    size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
    axis.begin += size;
    if (ignoreParentFrame) {
      axis.begin -= delta;
    }
  }
  return pos;
}, dockInwardEnd:function(ownerContext, itemContext, item, axis) {
  var sizeProp = axis.sizeProp, size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp], pos = axis.end - size, frameEnd;
  if (!item.overlay) {
    axis.end = pos;
  }
  if (item.ignoreParentFrame) {
    axis.ignoreFrameEnd = itemContext;
    frameEnd = ownerContext.frameBorder[item.dock];
    pos += frameEnd + ownerContext.framePadding[item.dock];
    axis.end += frameEnd;
  }
  return pos;
}, dockOutwardBegin:function(ownerContext, itemContext, item, axis) {
  var pos = axis.begin, sizeProp = axis.sizeProp, size;
  if (axis.collapsed) {
    axis.ignoreFrameBegin = axis.ignoreFrameEnd = itemContext;
  } else {
    if (item.ignoreParentFrame) {
      axis.ignoreFrameBegin = itemContext;
    }
  }
  if (!item.overlay) {
    size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
    pos -= size;
    axis.begin = pos;
  }
  return pos;
}, dockOutwardEnd:function(ownerContext, itemContext, item, axis) {
  var pos = axis.end, sizeProp = axis.sizeProp, size;
  size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
  if (axis.collapsed) {
    axis.ignoreFrameBegin = axis.ignoreFrameEnd = itemContext;
  } else {
    if (item.ignoreParentFrame) {
      axis.ignoreFrameEnd = itemContext;
    }
  }
  if (!item.overlay) {
    axis.end = pos + size;
    axis.dockedPixelsEnd += size;
  }
  return pos;
}, dockStretch:function(ownerContext, itemContext, item, axis) {
  var dock = item.dock, sizeProp = axis.sizeProp, horizontal = dock === 'top' || dock === 'bottom', border = ownerContext.frameBorder, offsets = itemContext.offsets, padding = ownerContext.framePadding, endProp = horizontal ? 'right' : 'bottom', startProp = horizontal ? 'left' : 'top', pos = axis.begin + offsets[startProp], margin, size;
  if (item.stretch !== false) {
    size = axis.end - pos - offsets[endProp];
    if (item.ignoreParentFrame) {
      pos -= padding[startProp] + border[startProp];
      size += padding[sizeProp] + border[sizeProp];
    }
    margin = itemContext.marginInfo;
    size -= margin[sizeProp];
    itemContext[axis.setSize](size);
  }
  return pos;
}, finishAxis:function(ownerContext, axis) {
  if (isNaN(axis.maxChildSize)) {
    return false;
  }
  var axisBegin = axis.begin, size = axis.end - axisBegin, collapsed = axis.collapsed, setSizeMethod = axis.setSize, beginName = axis.dockBegin, endName = axis.dockEnd, padding = ownerContext.framePadding, border = ownerContext.frameBorder, borderBegin = border[beginName], framing = ownerContext.framing, framingBegin = framing && framing[beginName], paddingBegin = collapsed ? 0 : padding[beginName], sizeProp = axis.sizeProp, ignoreFrameBegin = axis.ignoreFrameBegin, ignoreFrameEnd = axis.ignoreFrameEnd, 
  bodyContext = ownerContext.bodyContext, extraPaddingBegin = Math.max(borderBegin + paddingBegin - framingBegin, 0), bodyPos, bodySize, delta, dirty;
  if (axis.shrinkWrap) {
    bodySize = axis.initialSize;
    if (framing) {
      delta = -axisBegin + borderBegin + paddingBegin;
      bodyPos = delta - framingBegin - extraPaddingBegin;
    } else {
      bodyPos = -axisBegin;
      delta = bodyPos + paddingBegin;
    }
    if (!collapsed) {
      size += padding[sizeProp];
    }
    if (ignoreFrameBegin) {
      delta -= borderBegin;
      bodyPos -= borderBegin;
      ignoreFrameBegin.dockedAt[axis.posProp] -= paddingBegin;
    } else {
      size += borderBegin;
    }
    if (collapsed) {
    } else {
      if (ignoreFrameEnd) {
        ignoreFrameEnd.dockedAt[axis.posProp] += padding[endName];
      } else {
        size += border[endName];
      }
    }
    axis.size = size;
    if (!axis.horizontal && !this.owner.manageHeight) {
      dirty = false;
    }
  } else {
    if (framing) {
      delta = 0;
      bodyPos = axisBegin - framingBegin - extraPaddingBegin;
    } else {
      delta = -borderBegin;
      bodyPos = axisBegin - paddingBegin - borderBegin;
    }
    bodySize = size;
  }
  axis.delta = delta;
  bodyContext[setSizeMethod](bodySize, dirty);
  bodyContext.setProp(axis.bodyPosProp, bodyPos);
  return !isNaN(size);
}, beforeInvalidateShrinkWrapDock:function(itemContext, options) {
  var sizeModelName = options.axis.sizeModelName;
  if (!itemContext[sizeModelName].constrainedMin) {
    itemContext[sizeModelName] = Ext.layout.SizeModel.calculated;
  }
}, afterInvalidateShrinkWrapDock:function(itemContext, options) {
  var axis = options.axis, me = options.layout, pos;
  if (itemContext[axis.sizeModelName].calculated) {
    pos = me.dockStretch(options.ownerContext, itemContext, itemContext.target, axis);
    itemContext.setProp(axis.posProp, axis.delta + pos);
  }
}, finishConstraints:function(ownerContext, horz, vert) {
  var me = this, sizeModels = me.sizeModels, publishWidth = horz.shrinkWrap, publishHeight = vert.shrinkWrap, owner = me.owner, dirty, height, width, heightModel, widthModel, size, minSize, maxSize, maxChildSize, desiredSize;
  if (publishWidth) {
    size = horz.size;
    minSize = horz.collapsed ? 0 : horz.minSize;
    maxSize = horz.maxSize;
    maxChildSize = horz.maxChildSize;
    desiredSize = Math.max(size, maxChildSize);
    if (desiredSize > maxSize) {
      widthModel = sizeModels.constrainedMax;
      width = maxSize;
    } else {
      if (desiredSize < minSize) {
        widthModel = sizeModels.constrainedMin;
        width = minSize;
      } else {
        if (size < maxChildSize) {
          widthModel = sizeModels.constrainedDock;
          owner.dockConstrainedWidth = width = maxChildSize;
        } else {
          width = size;
        }
      }
    }
  }
  if (publishHeight) {
    size = vert.size;
    minSize = vert.collapsed ? 0 : vert.minSize;
    maxSize = vert.maxSize;
    maxChildSize = vert.maxChildSize;
    desiredSize = Math.max(size, maxChildSize + size - vert.initialSize);
    if (desiredSize > maxSize) {
      heightModel = sizeModels.constrainedMax;
      height = maxSize;
    } else {
      if (desiredSize < minSize) {
        heightModel = sizeModels.constrainedMin;
        height = minSize;
      } else {
        if (size < maxChildSize) {
          heightModel = sizeModels.constrainedDock;
          owner.dockConstrainedHeight = height = maxChildSize;
        } else {
          if (!ownerContext.collapsedVert && !owner.manageHeight) {
            dirty = false;
            ownerContext.bodyContext.setProp('margin-bottom', vert.dockedPixelsEnd);
          }
          height = size;
        }
      }
    }
  }
  if (widthModel || heightModel) {
    if (widthModel && heightModel && widthModel.constrainedMax && heightModel.constrainedByMin) {
      ownerContext.invalidate({widthModel:widthModel});
      return false;
    }
    if (!ownerContext.widthModel.calculatedFromShrinkWrap && !ownerContext.heightModel.calculatedFromShrinkWrap) {
      ownerContext.invalidate({widthModel:widthModel, heightModel:heightModel});
      return false;
    }
  } else {
    me.invalidateAxes(ownerContext, horz, vert);
  }
  if (publishWidth) {
    ownerContext.setWidth(width);
    if (widthModel) {
      ownerContext.widthModel = widthModel;
    }
  }
  if (publishHeight) {
    ownerContext.setHeight(height, dirty);
    if (heightModel) {
      ownerContext.heightModel = heightModel;
    }
  }
  return true;
}, invalidateAxes:function(ownerContext, horz, vert) {
  var before = this.beforeInvalidateShrinkWrapDock, after = this.afterInvalidateShrinkWrapDock, horzSize = horz.end - horz.begin, vertSize = vert.initialSize, invalidateHorz = horz.shrinkWrapDock && horz.maxChildSize <= horzSize, invalidateVert = vert.shrinkWrapDock && vert.maxChildSize <= vertSize, dockedItems, len, i, itemContext, itemSize, isHorz, axis, sizeProp;
  if (invalidateHorz || invalidateVert) {
    if (invalidateVert) {
      vert.begin = vert.initialBegin;
      vert.end = vert.begin + vert.initialSize;
    }
    dockedItems = ownerContext.dockedItems;
    for (i = 0, len = dockedItems.length; i < len; ++i) {
      itemContext = dockedItems[i];
      isHorz = itemContext.horizontal;
      axis = null;
      if (invalidateHorz && isHorz) {
        sizeProp = horz.sizeProp;
        itemSize = horzSize;
        axis = horz;
      } else {
        if (invalidateVert && !isHorz) {
          sizeProp = vert.sizeProp;
          itemSize = vertSize;
          axis = vert;
        }
      }
      if (axis) {
        itemSize -= itemContext.getMarginInfo()[sizeProp];
        if (itemSize !== itemContext.props[sizeProp]) {
          itemContext.invalidate({before:before, after:after, axis:axis, ownerContext:ownerContext, layout:this});
        }
      }
    }
  }
}, finishPositions:function(ownerContext, horz, vert) {
  var dockedItems = ownerContext.dockedItems, length = dockedItems.length, deltaX = horz.delta, deltaY = vert.delta, index, itemContext;
  for (index = 0; index < length; ++index) {
    itemContext = dockedItems[index];
    itemContext.setProp('x', deltaX + itemContext.dockedAt.x);
    itemContext.setProp('y', deltaY + itemContext.dockedAt.y);
  }
}, finishedLayout:function(ownerContext) {
  var me = this, target = ownerContext.target;
  Ext.layout.component.Component.prototype.finishedLayout.apply(this, arguments);
  if (!ownerContext.animatePolicy) {
    if (ownerContext.isCollapsingOrExpanding === 1) {
      target.afterCollapse(false);
    } else {
      if (ownerContext.isCollapsingOrExpanding === 2) {
        target.afterExpand(false);
      }
    }
  }
}, getAnimatePolicy:function(ownerContext) {
  var me = this, lastCollapsedState, policy;
  if (ownerContext.isCollapsingOrExpanding === 1) {
    lastCollapsedState = me.lastCollapsedState;
  } else {
    if (ownerContext.isCollapsingOrExpanding === 2) {
      lastCollapsedState = ownerContext.lastCollapsedState;
    }
  }
  if (lastCollapsedState === 'left' || lastCollapsedState === 'right') {
    policy = me.horizontalCollapsePolicy;
  } else {
    if (lastCollapsedState === 'top' || lastCollapsedState === 'bottom') {
      policy = me.verticalCollapsePolicy;
    }
  }
  return policy;
}, getDockedItems:function(order, beforeBody) {
  var me = this, renderedOnly = order === 'visual', all = renderedOnly ? Ext.ComponentQuery.query('[rendered]', me.owner.dockedItems.items) : me.owner.dockedItems.items, sort = all && all.length && order !== false, renderOrder, dock, dockedItems, i, isBefore, length;
  if (beforeBody == null) {
    dockedItems = sort && !renderedOnly ? all.slice() : all;
  } else {
    dockedItems = [];
    for (i = 0, length = all.length; i < length; ++i) {
      dock = all[i].dock;
      isBefore = dock === 'top' || dock === 'left';
      if (beforeBody ? isBefore : !isBefore) {
        dockedItems.push(all[i]);
      }
    }
    sort = sort && dockedItems.length;
  }
  if (sort) {
    renderOrder = (order = order || 'render') === 'render';
    Ext.Array.sort(dockedItems, function(a, b) {
      var aw, bw;
      if (renderOrder && (aw = me.owner.dockOrder[a.dock]) !== (bw = me.owner.dockOrder[b.dock])) {
        if (!(aw + bw)) {
          return aw - bw;
        }
      }
      aw = me.getItemWeight(a, order);
      bw = me.getItemWeight(b, order);
      if (aw !== undefined && bw !== undefined) {
        return aw - bw;
      }
      return 0;
    });
  }
  return dockedItems || [];
}, getItemWeight:function(item, order) {
  var weight = item.weight || this.owner.defaultDockWeights[item.dock];
  return weight[order] || weight;
}, getLayoutItems:function() {
  var me = this, items, itemCount, item, i, result;
  if (me.owner.collapsed) {
    result = me.owner.getCollapsedDockedItems();
  } else {
    items = me.getDockedItems('visual');
    itemCount = items.length;
    result = [];
    for (i = 0; i < itemCount; i++) {
      item = items[i];
      if (!item.hidden) {
        result.push(item);
      }
    }
  }
  return result;
}, measureContentWidth:function(ownerContext) {
  var bodyContext = ownerContext.bodyContext;
  return bodyContext.el.getWidth() - bodyContext.getBorderInfo().width;
}, measureContentHeight:function(ownerContext) {
  var bodyContext = ownerContext.bodyContext;
  return bodyContext.el.getHeight() - bodyContext.getBorderInfo().height;
}, redoLayout:function(ownerContext) {
  var me = this, owner = me.owner;
  if (ownerContext.isCollapsingOrExpanding === 1) {
    if (owner.reExpander) {
      owner.reExpander.el.show();
    }
    owner.addClsWithUI(owner.collapsedCls);
    ownerContext.redo(true);
  } else {
    if (ownerContext.isCollapsingOrExpanding === 2) {
      owner.removeClsWithUI(owner.collapsedCls);
      ownerContext.bodyContext.redo();
    }
  }
}, getRenderTarget:function() {
  return this.owner.bodyWrap;
}, renderChildren:function() {
  var me = this, items = me.getDockedItems(), target = me.getRenderTarget();
  me.handleItemBorders();
  me.renderItems(items, target);
}, renderItems:function(items, target) {
  var me = this, owner = me.owner, dockedItemIds = {}, dockedItemCount = items.length, bodyDom = owner.body.dom, bodyWrapDom = owner.bodyWrap.dom, hasFrame = !!owner.frameSize, bodyContainer = owner.bodyContainer, childNodes, childNodeCount, hasDockedToEl, item, dom, elFound, gap, bodyBaseIndex, bodyDockIndex, wrapBaseIndex, wrapDockIndex, i, insertPosition, insertTarget;
  if (dockedItemCount) {
    for (i = 0; i < dockedItemCount; i++) {
      item = items[i];
      dockedItemIds[item.id] = item;
      if (item.dockToEl) {
        hasDockedToEl = true;
      }
    }
    childNodes = me.getRenderTarget().dom.childNodes;
    childNodeCount = childNodes.length;
    gap = 0;
    for (i = 0; i < childNodeCount; ++i) {
      dom = childNodes[i];
      elFound = dom === bodyDom;
      if (elFound) {
        bodyBaseIndex = i;
        break;
      }
      if (dockedItemIds[dom.id]) {
        ++gap;
      }
    }
    bodyBaseIndex -= gap;
    if (hasDockedToEl) {
      elFound = false;
      gap = 0;
      childNodes = owner.el.dom.childNodes;
      childNodeCount = childNodes.length;
      for (i = 0; i < childNodeCount; i++) {
        dom = childNodes[i];
        if (hasFrame) {
          elFound = dom === bodyWrapDom || dom === bodyContainer;
          if (!elFound && Ext.fly(dom).contains(bodyWrapDom)) {
            elFound = true;
            owner.bodyContainer = dom;
          }
        } else {
          elFound = dom === bodyWrapDom;
        }
        if (elFound) {
          wrapBaseIndex = i;
          break;
        }
        if (dockedItemIds[dom.id]) {
          ++gap;
        }
      }
      wrapBaseIndex -= gap;
    }
    bodyDockIndex = wrapDockIndex = 0;
    for (i = 0; i < dockedItemCount; i++) {
      item = items[i];
      if (item.dockToEl) {
        insertTarget = owner.el;
        insertPosition = wrapBaseIndex + wrapDockIndex++;
        if (item.dock === 'right' || item.dock === 'bottom') {
          insertPosition++;
          if (hasFrame) {
            insertPosition++;
          }
        } else {
          if (hasFrame && insertPosition > 0) {
            insertPosition--;
          }
        }
      } else {
        insertTarget = target;
        insertPosition = bodyBaseIndex + bodyDockIndex++;
        if (item.dock === 'right' || item.dock === 'bottom') {
          insertPosition++;
        }
      }
      if (!item.rendered) {
        me.renderItem(item, insertTarget, insertPosition);
      } else {
        if (!me.isValidParent(item, insertTarget, insertPosition)) {
          me.moveItem(item, insertTarget, insertPosition);
        }
      }
    }
  }
}, undoLayout:function(ownerContext) {
  var me = this, owner = me.owner;
  if (ownerContext.isCollapsingOrExpanding === 1) {
    if (owner.reExpander) {
      owner.reExpander.el.hide();
    }
    owner.removeClsWithUI(owner.collapsedCls);
    ownerContext.undo(true);
  } else {
    if (ownerContext.isCollapsingOrExpanding === 2) {
      owner.addClsWithUI(owner.collapsedCls);
      ownerContext.bodyContext.undo();
    }
  }
}, sizePolicy:{nostretch:{setsWidth:0, setsHeight:0}, horz:{shrinkWrap:{setsWidth:1, setsHeight:0, readsWidth:1}, stretch:{setsWidth:1, setsHeight:0}}, vert:{shrinkWrap:{setsWidth:0, setsHeight:1, readsHeight:1}, stretch:{setsWidth:0, setsHeight:1}}, stretchV:{setsWidth:0, setsHeight:1}, autoStretchH:{readsWidth:1, setsWidth:1, setsHeight:0}, autoStretchV:{readsHeight:1, setsWidth:0, setsHeight:1}}, getItemSizePolicy:function(item, ownerSizeModel) {
  var me = this, policy = me.sizePolicy, shrinkWrapDock = me.owner.shrinkWrapDock, dock, vertical;
  if (item.stretch === false) {
    return policy.nostretch;
  }
  dock = item.dock;
  vertical = dock === 'left' || dock === 'right';
  shrinkWrapDock = shrinkWrapDock === true ? 3 : shrinkWrapDock || 0;
  if (vertical) {
    policy = policy.vert;
    shrinkWrapDock = shrinkWrapDock & 1;
  } else {
    policy = policy.horz;
    shrinkWrapDock = shrinkWrapDock & 2;
  }
  if (shrinkWrapDock) {
    if (!ownerSizeModel) {
      ownerSizeModel = me.owner.getSizeModel();
    }
    if (ownerSizeModel[vertical ? 'height' : 'width'].shrinkWrap) {
      return policy.shrinkWrap;
    }
  }
  return policy.stretch;
}, configureItem:function(item, pos) {
  Ext.layout.component.Component.prototype.configureItem.apply(this, arguments);
  item.addCls(this._itemCls);
  if (!item.ignoreBorderManagement) {
    item.addClsWithUI(this.getDockCls(item.dock));
  }
}, getDockCls:function(dock) {
  return 'docked-' + dock;
}, afterRemove:function(item) {
  var dom;
  Ext.layout.component.Component.prototype.afterRemove.apply(this, arguments);
  item.removeCls(this._itemCls);
  if (!item.ignoreBorderManagement) {
    item.removeClsWithUI(this.getDockCls(item.dock));
  }
  dom = item.el && item.el.dom;
  if (dom && !item.destroying) {
    dom.parentNode.removeChild(dom);
  }
  this.childrenChanged = true;
}, borderCollapseMap:{}, getBorderCollapseTable:function() {
  var me = this, map = me.borderCollapseMap, owner = me.owner, baseCls = owner.baseCls, ui = owner.ui, table;
  map = map[baseCls] || (map[baseCls] = {});
  table = map[ui];
  if (!table) {
    baseCls += '-' + ui + '-outer-border-';
    map[ui] = table = [0, baseCls + 'l', baseCls + 'b', baseCls + 'bl', baseCls + 'r', baseCls + 'rl', baseCls + 'rb', baseCls + 'rbl', baseCls + 't', baseCls + 'tl', baseCls + 'tb', baseCls + 'tbl', baseCls + 'tr', baseCls + 'trl', baseCls + 'trb', baseCls + 'trbl'];
  }
  return table;
}}, 0, 0, 0, 0, ['layout.dock'], 0, [Ext.layout.component, 'Dock', Ext.layout.component, 'AbstractDock'], 0);
Ext.define('Ext.theme.neptune.layout.component.Dock', {override:'Ext.layout.component.Dock', noBorderClassTable:[0, 'x-noborder-l', 'x-noborder-b', 'x-noborder-bl', 'x-noborder-r', 'x-noborder-rl', 'x-noborder-rb', 'x-noborder-rbl', 'x-noborder-t', 'x-noborder-tl', 'x-noborder-tb', 'x-noborder-tbl', 'x-noborder-tr', 'x-noborder-trl', 'x-noborder-trb', 'x-noborder-trbl'], edgeMasks:{top:8, right:4, bottom:2, left:1}, handleItemBorders:function() {
  var me = this, edges = 0, maskT = 8, maskR = 4, maskB = 2, maskL = 1, owner = me.owner, bodyBorder = owner.bodyBorder, ownerBorder = owner.border, collapsed = me.collapsed, edgeMasks = me.edgeMasks, noBorderCls = me.noBorderClassTable, dockedItemsGen = owner.dockedItems.generation, b, borderCls, docked, edgesTouched, i, ln, item, dock, lastValue, mask, addCls, removeCls;
  if (me.initializedBorders === dockedItemsGen) {
    return;
  }
  addCls = [];
  removeCls = [];
  borderCls = me.getBorderCollapseTable();
  noBorderCls = me.getBorderClassTable ? me.getBorderClassTable() : noBorderCls;
  me.initializedBorders = dockedItemsGen;
  me.collapsed = false;
  docked = me.getDockedItems('visual');
  me.collapsed = collapsed;
  for (i = 0, ln = docked.length; i < ln; i++) {
    item = docked[i];
    if (item.ignoreBorderManagement) {
      continue;
    }
    dock = item.dock;
    mask = edgesTouched = 0;
    addCls.length = 0;
    removeCls.length = 0;
    if (dock !== 'bottom') {
      if (edges & maskT) {
        b = item.border;
      } else {
        b = ownerBorder;
        if (b !== false) {
          edgesTouched += maskT;
        }
      }
      if (b === false) {
        mask += maskT;
      }
    }
    if (dock !== 'left') {
      if (edges & maskR) {
        b = item.border;
      } else {
        b = ownerBorder;
        if (b !== false) {
          edgesTouched += maskR;
        }
      }
      if (b === false) {
        mask += maskR;
      }
    }
    if (dock !== 'top') {
      if (edges & maskB) {
        b = item.border;
      } else {
        b = ownerBorder;
        if (b !== false) {
          edgesTouched += maskB;
        }
      }
      if (b === false) {
        mask += maskB;
      }
    }
    if (dock !== 'right') {
      if (edges & maskL) {
        b = item.border;
      } else {
        b = ownerBorder;
        if (b !== false) {
          edgesTouched += maskL;
        }
      }
      if (b === false) {
        mask += maskL;
      }
    }
    if ((lastValue = item.lastBorderMask) !== mask) {
      item.lastBorderMask = mask;
      if (lastValue) {
        removeCls[0] = noBorderCls[lastValue];
      }
      if (mask) {
        addCls[0] = noBorderCls[mask];
      }
    }
    if ((lastValue = item.lastBorderCollapse) !== edgesTouched) {
      item.lastBorderCollapse = edgesTouched;
      if (lastValue) {
        removeCls[removeCls.length] = borderCls[lastValue];
      }
      if (edgesTouched) {
        addCls[addCls.length] = borderCls[edgesTouched];
      }
    }
    if (removeCls.length) {
      item.removeCls(removeCls);
    }
    if (addCls.length) {
      item.addCls(addCls);
    }
    edges |= edgeMasks[dock];
  }
  mask = edgesTouched = 0;
  addCls.length = 0;
  removeCls.length = 0;
  if (edges & maskT) {
    b = bodyBorder;
  } else {
    b = ownerBorder;
    if (b !== false) {
      edgesTouched += maskT;
    }
  }
  if (b === false) {
    mask += maskT;
  }
  if (edges & maskR) {
    b = bodyBorder;
  } else {
    b = ownerBorder;
    if (b !== false) {
      edgesTouched += maskR;
    }
  }
  if (b === false) {
    mask += maskR;
  }
  if (edges & maskB) {
    b = bodyBorder;
  } else {
    b = ownerBorder;
    if (b !== false) {
      edgesTouched += maskB;
    }
  }
  if (b === false) {
    mask += maskB;
  }
  if (edges & maskL) {
    b = bodyBorder;
  } else {
    b = ownerBorder;
    if (b !== false) {
      edgesTouched += maskL;
    }
  }
  if (b === false) {
    mask += maskL;
  }
  if ((lastValue = me.lastBodyBorderMask) !== mask) {
    me.lastBodyBorderMask = mask;
    if (lastValue) {
      removeCls[0] = noBorderCls[lastValue];
    }
    if (mask) {
      addCls[0] = noBorderCls[mask];
    }
  }
  if ((lastValue = me.lastBodyBorderCollapse) !== edgesTouched) {
    me.lastBodyBorderCollapse = edgesTouched;
    if (lastValue) {
      removeCls[removeCls.length] = borderCls[lastValue];
    }
    if (edgesTouched) {
      addCls[addCls.length] = borderCls[edgesTouched];
    }
  }
  if (removeCls.length) {
    owner.removeBodyCls(removeCls);
  }
  if (addCls.length) {
    owner.addBodyCls(addCls);
  }
}, onRemove:function(item) {
  var me = this, lastBorderMask = item.lastBorderMask, lastBorderCollapse = item.lastBorderCollapse;
  if (!item.destroyed && !item.ignoreBorderManagement) {
    if (lastBorderMask) {
      item.lastBorderMask = 0;
      item.removeCls(me.noBorderClassTable[lastBorderMask]);
    }
    if (lastBorderCollapse) {
      item.lastBorderCollapse = 0;
      item.removeCls(me.getBorderCollapseTable()[lastBorderCollapse]);
    }
  }
  (arguments.callee.$previous || Ext.layout.component.Component.prototype.onRemove).call(this, item);
}});
Ext.cmd.derive('Ext.util.Memento', Ext.Base, function() {
  function captureOne(src, target, prop, prefix) {
    src[prefix ? prefix + prop : prop] = target[prop];
  }
  function removeOne(src, target, prop) {
    delete src[prop];
  }
  function restoreOne(src, target, prop, prefix) {
    var name = prefix ? prefix + prop : prop, value = src[name];
    if (value || src.hasOwnProperty(name)) {
      restoreValue(target, prop, value);
    }
  }
  function restoreValue(target, prop, value) {
    if (Ext.isDefined(value)) {
      target[prop] = value;
    } else {
      delete target[prop];
    }
  }
  function doMany(doOne, src, target, props, prefix) {
    if (src) {
      if (Ext.isArray(props)) {
        var p, pLen = props.length;
        for (p = 0; p < pLen; p++) {
          doOne(src, target, props[p], prefix);
        }
      } else {
        doOne(src, target, props, prefix);
      }
    }
  }
  return {data:null, target:null, constructor:function(target, props) {
    this.data = {};
    if (target) {
      this.target = target;
      if (props) {
        this.capture(props);
      }
    }
  }, capture:function(props, target, prefix) {
    var me = this;
    doMany(captureOne, me.data || (me.data = {}), target || me.target, props, prefix);
  }, remove:function(props) {
    doMany(removeOne, this.data, null, props);
  }, restore:function(props, clear, target, prefix) {
    doMany(restoreOne, this.data, target || this.target, props, prefix);
    if (clear !== false) {
      this.remove(props);
    }
  }, restoreAll:function(clear, target) {
    var me = this, t = target || this.target, data = me.data, prop;
    clear = clear !== false;
    for (prop in data) {
      if (data.hasOwnProperty(prop)) {
        restoreValue(t, prop, data[prop]);
        if (clear) {
          delete data[prop];
        }
      }
    }
  }};
}(), 1, 0, 0, 0, 0, 0, [Ext.util, 'Memento'], 0);
Ext.cmd.derive('Ext.container.DockingContainer', Ext.Base, {isDockingContainer:true, defaultDockWeights:{top:{render:1, visual:1}, left:{render:3, visual:5}, right:{render:5, visual:7}, bottom:{render:7, visual:3}}, dockOrder:{top:-1, left:-1, right:1, bottom:1}, horizontalDocks:0, addDocked:function(items, pos) {
  var me = this, rendered = me.rendered, i = 0, dockedItems = me.dockedItems, lastIndex = dockedItems.getCount(), index, instanced, item, length;
  items = me.prepareItems(items);
  length = items.length;
  if (rendered) {
    Ext.suspendLayouts();
  }
  if (pos === undefined) {
    pos = lastIndex;
  } else {
    pos = Math.min(pos, lastIndex);
  }
  for (; i < length; i++) {
    item = items[i];
    if (item.isDetached) {
      item.reattachToBody();
    }
    item.dock = item.dock || 'top';
    if (item.dock === 'left' || item.dock === 'right') {
      me.horizontalDocks++;
    }
    index = pos + i;
    dockedItems.insert(index, item);
    instanced = !!item.instancedCmp;
    delete item.instancedCmp;
    item.onAdded(me, index, instanced);
    delete item.$initParent;
    if (me.onDockedAdd !== Ext.emptyFn) {
      me.onDockedAdd(item);
    }
    if (me.hasListeners.dockedadd) {
      me.fireEvent('dockedadd', me, item, index);
    }
  }
  if (me.rendered) {
    me.updateLayout();
    Ext.resumeLayouts(true);
  }
  return items;
}, destroyDockedItems:function() {
  var dockedItems = this.dockedItems, c;
  if (dockedItems) {
    while (c = dockedItems.first()) {
      this.removeDocked(c, {destroy:true});
    }
  }
}, doRenderDockedItems:function(out, renderData, after) {
  var me = renderData.$comp, layout = me.componentLayout, tabGuard = me.tabGuard && me.lookupTpl('tabGuardTpl'), items, tree;
  if (layout.getDockedItems) {
    items = layout.getDockedItems('render', !after);
    tree = items && layout.getItemsRenderTree(items);
    if (tree) {
      Ext.DomHelper.generateMarkup(tree, out);
    }
  }
}, getDockedComponent:function(comp) {
  if (Ext.isObject(comp)) {
    comp = comp.getItemId();
  }
  return this.dockedItems.get(comp);
}, getDockedItems:function(selector, beforeBody) {
  var dockedItems = this.getComponentLayout().getDockedItems('render', beforeBody);
  if (selector && dockedItems.length) {
    dockedItems = Ext.ComponentQuery.query(selector, dockedItems);
  }
  return dockedItems;
}, getDockingRefItems:function(deep, containerItems) {
  var selector = deep && '*,* *', dockedItems = this.getDockedItems(selector, true), items;
  dockedItems.push.apply(dockedItems, containerItems);
  items = this.getDockedItems(selector, false);
  dockedItems.push.apply(dockedItems, items);
  return dockedItems;
}, initDockingItems:function() {
  var me = this, items = me.dockedItems;
  if (!items || !items.isMixedCollection) {
    me.dockedItems = new Ext.util.ItemCollection;
    if (items) {
      me.addDocked(items);
    }
  }
}, insertDocked:function(pos, items) {
  this.addDocked(items, pos);
}, onDockedAdd:Ext.emptyFn, onDockedRemove:Ext.emptyFn, removeDocked:function(item, flags) {
  var me = this, layout, hasLayout, doDestroy, doDetach;
  if (!me.dockedItems.contains(item)) {
    return item;
  }
  if (flags == null) {
    doDestroy = me.autoDestroy;
  } else {
    if (typeof flags === 'boolean') {
      doDestroy = flags;
    } else {
      doDestroy = 'destroy' in flags && flags.destroy;
      doDetach = 'detach' in flags && flags.detach;
    }
  }
  if (item.dock === 'left' || item.dock === 'right') {
    me.horizontalDocks--;
  }
  layout = me.componentLayout;
  hasLayout = layout && me.rendered;
  if (hasLayout) {
    layout.onRemove(item);
  }
  me.dockedItems.remove(item);
  if (!item.destroyed) {
    item.onRemoved(item.destroying || doDestroy);
  }
  me.onDockedRemove(item);
  if (doDestroy) {
    item.destroy();
  } else {
    if (!me.destroyed) {
      if (hasLayout) {
        layout.afterRemove(item);
      }
      if (doDetach && item.rendered) {
        item.detachFromBody();
      }
    }
  }
  if (me.hasListeners.dockedremove) {
    me.fireEvent('dockedremove', me, item);
  }
  if (!me.destroying) {
    me.updateLayout();
  }
  return item;
}, moveDocked:function(item, side) {
  var me = this;
  if (me.rendered) {
    Ext.suspendLayouts();
  }
  me.removeDocked(item, {destroy:false, detach:true});
  item.dock = side;
  me.addDocked(item);
  if (me.rendered) {
    if (item.frame) {
      item.updateFrame();
    }
    Ext.resumeLayouts(true);
  }
}, setupDockingRenderTpl:function(renderTpl) {
  renderTpl.renderDockedItems = this.doRenderDockedItems;
}}, 0, 0, 0, 0, 0, 0, [Ext.container, 'DockingContainer'], 0);
Ext.cmd.derive('Ext.panel.Panel', Ext.container.Container, {alternateClassName:'Ext.Panel', childEls:['bodyWrap', 'body'], renderTpl:['\x3ctpl if\x3d"headingText"\x3e', '\x3cdiv id\x3d"{id}-headingEl" data-ref\x3d"headingEl" role\x3d"heading"', ' class\x3d"', 'x-', 'hidden-clip" style\x3d"height:0"\x3e', '{headingText}', '\x3c/div\x3e', '\x3c/tpl\x3e', '\x3ctpl if\x3d"hasTabGuard"\x3e{% this.renderTabGuard(out, values, \'before\'); %}\x3c/tpl\x3e', '\x3cdiv id\x3d"{id}-bodyWrap" data-ref\x3d"bodyWrap" class\x3d"{baseCls}-bodyWrap"', 
'\x3ctpl if\x3d"bodyWrapAriaAttributes"\x3e', '\x3ctpl foreach\x3d"bodyWrapAriaAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e', '\x3ctpl else\x3e', ' role\x3d"presentation"', '\x3c/tpl\x3e', '\x3e', '{% this.renderDockedItems(out,values,0); %}', '\x3cdiv id\x3d"{id}-body" data-ref\x3d"body" class\x3d"{baseCls}-body\x3ctpl if\x3d"bodyCls"\x3e {bodyCls}\x3c/tpl\x3e', ' {baseCls}-body-{ui}\x3ctpl if\x3d"uiCls"\x3e', '\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-body-{parent.ui}-{.}\x3c/tpl\x3e', '\x3c/tpl\x3e{childElCls}"', 
'\x3ctpl if\x3d"bodyAriaAttributes"\x3e', '\x3ctpl foreach\x3d"bodyAriaAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e', '\x3ctpl else\x3e', ' role\x3d"presentation"', '\x3c/tpl\x3e', '\x3ctpl if\x3d"bodyStyle"\x3e style\x3d"{bodyStyle}"\x3c/tpl\x3e\x3e', '{%this.renderContainer(out,values);%}', '\x3c/div\x3e', '{% this.renderDockedItems(out,values,1); %}', '\x3c/div\x3e', '\x3ctpl if\x3d"hasTabGuard"\x3e{% this.renderTabGuard(out, values, \'after\'); %}\x3c/tpl\x3e'], headerPosition:'top', iconAlign:'left', 
titleAlign:'left', titleRotation:'default', titlePosition:0, headerConfigs:{glyph:1, icon:1, iconAlign:1, iconCls:1, title:1, titleAlign:1, titlePosition:1, titleRotation:1}, beforeRenderConfig:{glyph:null, headerPosition:null, icon:null, iconAlign:null, iconCls:null, title:null, titleAlign:null, titlePosition:null, titleRotation:null}, animCollapse:Ext.enableFx, border:true, closable:false, closeAction:'destroy', closeToolText:'Close panel', collapsed:false, collapsedCls:'collapsed', collapseFirst:true, 
collapsible:undefined, collapseToolText:'Collapse panel', expandToolText:'Expand panel', constrain:false, constrainHeader:false, dockedItems:null, tbar:null, bbar:null, fbar:null, lbar:null, rbar:null, buttons:null, floatable:true, frame:false, frameHeader:true, hideCollapseTool:false, manageHeight:true, maskElement:'el', minButtonWidth:75, preventHeader:false, maintainTitlePosition:false, shrinkWrapDock:false, titleCollapse:undefined, baseCls:'x-panel', bodyPosProps:{x:'x', y:'y'}, componentLayout:'dock', 
contentPaddingProperty:'bodyPadding', emptyArray:[], isPanel:true, defaultBindProperty:'title', addBodyCls:function(cls) {
  var me = this, body = me.rendered ? me.body : me.getProtoBody();
  body.addCls(cls);
  return me;
}, addTool:function(tools) {
  if (!Ext.isArray(tools)) {
    tools = [tools];
  }
  var me = this, header = me.header, len = tools.length, curTools = me.tools, t, tool;
  if (!header || !header.isHeader) {
    header = null;
    if (!curTools) {
      me.tools = curTools = [];
    }
  }
  for (t = 0; t < len; t++) {
    tool = tools[t];
    if (typeof tool !== 'string' && !tool.isTool) {
      tool = Ext.apply({}, tool);
    }
    tool.toolOwner = me;
    if (header) {
      header.addTool(tool);
    } else {
      curTools.push(tool);
    }
  }
  me.updateHeader();
}, addTools:Ext.emptyFn, getClosable:function() {
  return this.closable;
}, setClosable:function(closable) {
  var me = this, tab = me.tab;
  closable = !!closable;
  if (me.closable !== closable) {
    me.closable = closable;
    if (tab) {
      tab.setClosable(closable);
    }
  }
}, setCollapsible:function(collapsible) {
  var me = this, current = me.collapsible, collapseTool = me.collapseTool;
  me.collapsible = collapsible;
  if (collapsible && !current) {
    me.updateCollapseTool();
    collapseTool = me.collapseTool;
    if (collapseTool) {
      collapseTool.show();
    }
  } else {
    if (!collapsible && current) {
      if (collapseTool) {
        collapseTool.hide();
      }
    }
  }
}, addUIClsToElement:function(cls) {
  var me = this, result = Ext.container.Container.prototype.addUIClsToElement.apply(this, arguments);
  me.addBodyCls(['x-' + cls, me.baseCls + '-body-' + cls, me.baseCls + '-body-' + me.ui + '-' + cls]);
  return result;
}, afterCollapse:function(animated) {
  var me = this, ownerLayout = me.ownerLayout;
  me.isCollapsingOrExpanding = 0;
  me.updateCollapseTool();
  if (animated) {
    me.removeCls('x-animating-size');
  }
  if (ownerLayout) {
    ownerLayout.afterCollapse(me, animated);
  }
  me.setHiddenDocked();
  me.fireEvent('collapse', me);
}, afterExpand:function(animated) {
  var me = this, ownerLayout = me.ownerLayout;
  me.isCollapsingOrExpanding = 0;
  me.updateCollapseTool();
  if (animated) {
    me.removeCls('x-animating-size');
  }
  if (ownerLayout) {
    ownerLayout.afterExpand(me, animated);
  }
  me.fireEvent('expand', me);
  me.fireHierarchyEvent('expand');
}, doDestroy:function() {
  var me = this;
  if (me.slideOutTask) {
    me.slideOutTask.cancel();
  }
  Ext.destroy(me.placeholder, me.ghostPanel, me.dd, me.accordionHeaderKeyNav, me.accordionBodyKeyNav, me.defaultButtonKeyNav);
  me.destroyDockedItems();
  Ext.container.Container.prototype.doDestroy.call(this);
}, beforeRender:function() {
  var me = this, wasCollapsed;
  me.getProtoBody();
  Ext.container.Container.prototype.beforeRender.call(this);
  me.initTools();
  if (!(me.preventHeader || me.header === false) || me.isViewportBorderChild) {
    me.updateHeader();
  }
  me.afterHeaderInit = true;
  if (me.collapsed) {
    if (me.isPlaceHolderCollapse()) {
      if (!me.hidden) {
        me.setHiddenState(true);
        me.preventCollapseFire = true;
        me.placeholderCollapse();
        delete me.preventCollapseFire;
        wasCollapsed = me.collapsed;
        me.collapsed = false;
      }
    } else {
      me.beginCollapse();
      me.addClsWithUI(me.collapsedCls);
    }
  }
  if (wasCollapsed) {
    me.collapsed = wasCollapsed;
  }
}, getMemento:function(name) {
  var me = this;
  if (name && typeof name === 'string') {
    name += 'Memento';
    return me[name] || (me[name] = new Ext.util.Memento(me));
  }
}, beginCollapse:function() {
  var me = this, lastBox = me.lastBox, rendered = me.rendered, collapseMemento = me.getMemento('collapse'), sizeModel = me.getSizeModel(), header = me.header, reExpander;
  collapseMemento.capture(['height', 'minHeight', 'width', 'minWidth']);
  if (lastBox) {
    collapseMemento.capture(me.restoreDimension(), lastBox, 'last.');
  }
  if (me.collapsedVertical()) {
    if (sizeModel.width.shrinkWrap) {
      me.width = rendered ? me.getWidth() : me.width || me.minWidth || 100;
    }
    delete me.height;
    me.minHeight = 0;
  } else {
    if (me.collapsedHorizontal()) {
      if (sizeModel.height.shrinkWrap) {
        me.height = rendered ? me.getHeight() : me.height || me.minHeight || 100;
      }
      delete me.width;
      me.minWidth = 0;
    }
  }
  if (me.ownerCt) {
    me.ownerCt.getLayout().beginCollapse(me);
  }
  if (!me.isPlaceHolderCollapse() && header !== false) {
    if (header === (reExpander = me.getReExpander())) {
      header.collapseImmune = true;
      header.getInherited().collapseImmune = true;
      header.addClsWithUI(me.getHeaderCollapsedClasses(header));
      if (header.rendered) {
        header.updateFrame();
      }
    } else {
      if (reExpander.el) {
        reExpander.el.show();
        reExpander.hidden = false;
      }
    }
  }
  if (me.resizer) {
    me.resizer.disable();
  }
  if (me.rendered) {
    me.ariaEl.dom.setAttribute('aria-expanded', false);
    if (me.isAccordionPanel) {
      me.body.dom.setAttribute('aria-hidden', true);
    }
  }
}, beginDrag:function() {
  if (this.floatingDescendants) {
    this.floatingDescendants.hide();
  }
}, beginExpand:function() {
  var me = this, lastBox = me.lastBox, collapseMemento = me.getMemento('collapse'), restoreDimension = me.restoreDimension(), header = me.header, reExpander;
  if (collapseMemento) {
    collapseMemento.restore(['minHeight', 'minWidth', restoreDimension]);
    if (lastBox) {
      collapseMemento.restore(restoreDimension, true, lastBox, 'last.');
    }
  }
  if (me.ownerCt) {
    me.ownerCt.getLayout().beginExpand(me);
  }
  if (!me.isPlaceHolderCollapse() && header !== false) {
    if (header === (reExpander = me.getReExpander())) {
      delete header.collapseImmune;
      delete header.getInherited().collapseImmune;
      header.removeClsWithUI(me.getHeaderCollapsedClasses(header));
      if (header.rendered) {
        header.expanding = true;
        header.updateFrame();
        delete header.expanding;
      }
    } else {
      reExpander.hidden = true;
      reExpander.el.hide();
    }
  }
  if (me.resizer) {
    me.resizer.enable();
  }
  if (me.rendered) {
    me.ariaEl.dom.setAttribute('aria-expanded', true);
    if (me.isAccordionPanel) {
      me.body.dom.setAttribute('aria-hidden', false);
    }
  }
}, bridgeToolbars:function() {
  var me = this, docked = [], minButtonWidth = me.minButtonWidth, fbar, fbarDefaults, fbarIsButtons;
  function initToolbar(toolbar, pos, useButtonAlign, disableFocusableContainer) {
    if (Ext.isArray(toolbar)) {
      toolbar = {xtype:'toolbar', items:toolbar};
    } else {
      if (!toolbar.isComponent) {
        toolbar = Ext.apply({}, toolbar);
      }
    }
    if (!toolbar.xtype) {
      toolbar.xtype = 'toolbar';
    }
    toolbar.dock = pos;
    if (disableFocusableContainer) {
      toolbar.focusableContainer = false;
    }
    if (useButtonAlign) {
      toolbar.layout = Ext.apply({pack:{left:'start', center:'center'}[me.buttonAlign] || 'end'}, toolbar.layout);
    }
    return toolbar;
  }
  if (me.tbar) {
    docked.push(initToolbar(me.tbar, 'top'));
    me.tbar = null;
  }
  if (me.bbar) {
    docked.push(initToolbar(me.bbar, 'bottom'));
    me.bbar = null;
  }
  if (me.buttons) {
    me.fbar = me.buttons;
    me.buttons = null;
    fbarIsButtons = true;
  }
  if (me.fbar) {
    fbar = initToolbar(me.fbar, 'bottom', true, fbarIsButtons);
    fbar.ui = 'footer';
    if (minButtonWidth) {
      fbarDefaults = fbar.defaults;
      fbar.defaults = function(config) {
        var defaults = fbarDefaults || {}, isButton = !config.xtype || config.isButton, cls;
        if (!isButton) {
          cls = Ext.ClassManager.getByAlias('widget.' + config.xtype);
          if (cls) {
            isButton = cls.prototype.isButton;
          }
        }
        if (isButton && !('minWidth' in defaults)) {
          defaults = Ext.apply({minWidth:minButtonWidth}, defaults);
        }
        return defaults;
      };
    }
    docked.push(fbar);
    me.fbar = null;
  }
  if (me.lbar) {
    docked.push(initToolbar(me.lbar, 'left'));
    me.lbar = null;
  }
  if (me.rbar) {
    docked.push(initToolbar(me.rbar, 'right'));
    me.rbar = null;
  }
  if (me.dockedItems) {
    if (me.dockedItems.isMixedCollection) {
      me.addDocked(docked);
    } else {
      if (!Ext.isArray(me.dockedItems)) {
        me.dockedItems = [me.dockedItems];
      }
      me.dockedItems = me.dockedItems.concat(docked);
    }
  } else {
    me.dockedItems = docked;
  }
}, close:function() {
  if (this.fireEvent('beforeclose', this) !== false) {
    this.doClose();
  }
}, collapse:function(direction, animate) {
  var me = this, collapseDir = direction || me.collapseDirection, ownerCt = me.ownerCt, layout = me.ownerLayout, rendered = me.rendered;
  if (me.isCollapsingOrExpanding) {
    return me;
  }
  if (arguments.length < 2) {
    animate = me.animCollapse;
  }
  if (me.collapsed || me.fireEvent('beforecollapse', me, direction, animate) === false) {
    return me;
  }
  if (layout && layout.onBeforeComponentCollapse) {
    if (layout.onBeforeComponentCollapse(me) === false) {
      return me;
    }
  }
  if (rendered && ownerCt && me.isPlaceHolderCollapse()) {
    return me.placeholderCollapse(direction, animate);
  }
  me.collapsed = collapseDir;
  if (rendered) {
    me.beginCollapse();
  }
  me.getInherited().collapsed = true;
  me.fireHierarchyEvent('collapse');
  if (rendered) {
    me.doCollapseExpand(1, animate);
  }
  return me;
}, collapsedHorizontal:function() {
  var dir = this.getCollapsed();
  return dir === 'left' || dir === 'right';
}, collapsedVertical:function() {
  var dir = this.getCollapsed();
  return dir === 'top' || dir === 'bottom';
}, convertCollapseDir:function(collapseDir) {
  return collapseDir.substr(0, 1);
}, createGhost:function(cls) {
  var me = this, header = me.header, frame = me.frame && !me.alwaysFramed;
  return {xtype:'panel', hidden:false, header:header ? {titleAlign:header.getTitleAlign()} : null, ui:frame ? me.ui.replace(/-framed$/, '') : me.ui, id:me.id + '-ghost', renderTo:Ext.getBody(), resizable:false, draggable:false, closable:false, focusable:false, floating:true, alignOnScroll:false, shadow:false, frame:frame, shim:me.shim, alwaysFramed:me.alwaysFramed, overlapHeader:me.overlapHeader, headerPosition:me.getHeaderPosition(), titleRotation:me.getTitleRotation(), baseCls:me.baseCls, getRefOwner:function() {
    return me.getRefOwner();
  }, cls:me.baseCls + '-ghost ' + (cls || '')};
}, createReExpander:function(direction, defaults) {
  var me = this, isLeft = direction === 'left', isRight = direction === 'right', isVertical = isLeft || isRight, ownerCt = me.ownerCt, header = me.header, result = Ext.apply({hideMode:'offsets', title:me.getTitle(), titleAlign:me.getTitleAlign(), titlePosition:me.getTitlePosition(), vertical:isVertical, textCls:me.headerTextCls, icon:me.getIcon(), iconCls:me.getIconCls(), iconAlign:me.getIconAlign(), glyph:me.getGlyph(), baseCls:me.self.prototype.baseCls + '-header', ui:me.ui, frame:me.frame && me.frameHeader, 
  ignoreParentFrame:me.frame || me.overlapHeader, ignoreBorderManagement:me.frame || me.ignoreHeaderBorderManagement, indicateDrag:me.draggable, collapseImmune:true, ariaRole:me.ariaRole, preventRefocus:true, ownerCt:ownerCt && me.collapseMode === 'placeholder' ? ownerCt : me, ownerLayout:me.componentLayout, forceOrientation:true, margin:me.margin, defaultFocus:'tool[isDefaultExpandTool]'}, defaults);
  if (me.collapseMode === 'mini') {
    if (isVertical) {
      result.width = 1;
    } else {
      result.height = 1;
    }
  }
  if (header) {
    Ext.apply(result, {focusableContainer:header.focusableContainer, activeChildTabIndex:header.activeChildTabIndex, inactiveChildTabIndex:header.inactiveChildTabIndex, allowFocusingDisabledChildren:header.allowFocusingDisabledChildren});
  }
  if (!me.hideCollapseTool) {
    if (!me.maintainTitlePosition && (isLeft || isRight && me.isPlaceHolderCollapse())) {
      result.titlePosition = 1;
    }
    result.tools = [{xtype:'tool', type:'expand-' + me.getOppositeDirection(direction), isDefaultExpandTool:true, uiCls:['top'], handler:me.toggleCollapse, scope:me, tooltip:me.expandToolText}];
  }
  result = new Ext.panel.Header(result);
  result.addClsWithUI(me.getHeaderCollapsedClasses(result));
  result.expandTool = result.down('tool[isDefaultExpandTool\x3dtrue]');
  return result;
}, doClose:function() {
  this.fireEvent('close', this);
  this[this.closeAction]();
}, doCollapseExpand:function(flags, animate) {
  var me = this, originalAnimCollapse = me.animCollapse, ownerLayout = me.ownerLayout;
  me.animCollapse = animate;
  me.isCollapsingOrExpanding = flags;
  if (animate) {
    me.addCls('x-animating-size');
  }
  if (ownerLayout && !animate) {
    ownerLayout.onContentChange(me);
  } else {
    me.updateLayout({isRoot:true});
  }
  me.animCollapse = originalAnimCollapse;
  return me;
}, endDrag:function() {
  if (this.floatingDescendants) {
    this.floatingDescendants.show();
  }
}, expand:function(animate) {
  var me = this, layout = me.ownerLayout, rendered = me.rendered;
  if (me.isCollapsingOrExpanding) {
    return me;
  }
  if (!arguments.length) {
    animate = me.animCollapse;
  }
  if (!me.collapsed && !me.floatedFromCollapse) {
    return me;
  }
  if (me.fireEvent('beforeexpand', me, animate) === false) {
    return me;
  }
  if (layout && layout.onBeforeComponentExpand) {
    if (layout.onBeforeComponentExpand(me) === false) {
      return me;
    }
  }
  delete me.getInherited().collapsed;
  if (rendered && me.isPlaceHolderCollapse()) {
    return me.placeholderExpand(animate);
  }
  me.restoreHiddenDocked();
  if (rendered) {
    me.beginExpand();
  }
  me.collapsed = false;
  if (me.rendered) {
    me.doCollapseExpand(2, animate);
  }
  return me;
}, findReExpander:function(direction) {
  var me = this, c = Ext.Component, dockedItems = me.dockedItems.items, dockedItemCount = dockedItems.length, comp, i;
  if (me.collapseMode === 'mini') {
    return;
  }
  switch(direction) {
    case c.DIRECTION_TOP:
    case c.DIRECTION_BOTTOM:
      for (i = 0; i < dockedItemCount; i++) {
        comp = dockedItems[i];
        if (!comp.hidden) {
          if (comp.isHeader && (!comp.dock || comp.dock === 'top' || comp.dock === 'bottom')) {
            return comp;
          }
        }
      }
      break;
    case c.DIRECTION_LEFT:
    case c.DIRECTION_RIGHT:
      for (i = 0; i < dockedItemCount; i++) {
        comp = dockedItems[i];
        if (!comp.hidden) {
          if (comp.isHeader && (comp.dock === 'left' || comp.dock === 'right')) {
            return comp;
          }
        }
      }
      break;
    default:
      throw 'Panel#findReExpander must be passed a valid collapseDirection';
  }
}, floatCollapsedPanel:function() {
  var me = this, placeholder = me.placeholder, splitter = me.splitter, phBox = Ext.util.Region.from(placeholder.getBox(false, true)), floatCls = Ext.panel.Panel.floatCls, collapsed = me.collapsed, layoutOwner = me.ownerCt || me, slideDirection, myBox, hoverlisteners = {mouseleave:me.onMouseLeaveFloated, mouseenter:me.onMouseEnterFloated, scope:me, destroyable:true};
  if (me.isSliding) {
    return;
  }
  if (me.el.hasCls(floatCls)) {
    me.slideOutFloatedPanel();
    return;
  }
  me.isSliding = true;
  placeholder.el.hide();
  placeholder.hidden = true;
  me.el.show();
  me.setHiddenState(false);
  me.collapsed = false;
  layoutOwner.updateLayout();
  placeholder.el.show();
  placeholder.hidden = false;
  me.el.hide();
  me.setHiddenState(true);
  me.collapsed = collapsed;
  layoutOwner.updateLayout();
  myBox = me.getBox(false, true);
  if (me.fireEvent('beginfloat', me) === false) {
    return;
  }
  me.slideOutTask = me.slideOutTask || new Ext.util.DelayedTask(me.slideOutFloatedPanel, me);
  me.pointerLeaveListener = Ext.getDoc().on({mousedown:me.onFloatedPointerEvent, mousemove:me.onFloatedPointerEvent, scope:me, destroyable:true});
  if (!me.placeholderListener) {
    me.placeholderListener = placeholder.on({resize:me.onPlaceholderResize, scope:me, destroyable:true});
  }
  me.phHoverListeners = placeholder.el.on(hoverlisteners);
  me.elHoverListeners = me.el.on(hoverlisteners);
  me.el.addCls(floatCls);
  me.floated = collapsed;
  if (me.collapseTool) {
    me.collapseTool.el.hide();
  }
  if (splitter) {
    phBox = phBox.union(splitter.getBox(false, true));
  }
  switch(me.collapsed) {
    case 'top':
      me.width = phBox.width;
      me.setLocalXY(myBox.x, myBox.y + phBox.height);
      break;
    case 'right':
      me.height = phBox.height;
      me.setLocalXY(myBox.x - phBox.width, myBox.y);
      break;
    case 'bottom':
      me.width = phBox.width;
      me.setLocalXY(myBox.x, myBox.y - phBox.height);
      break;
    case 'left':
      me.height = phBox.height;
      me.setLocalXY(myBox.x + phBox.width, myBox.y);
      break;
  }
  slideDirection = me.convertCollapseDir(me.collapsed);
  me.floatedFromCollapse = me.collapsed;
  me.collapsed = false;
  me.setHiddenState(false);
  me.el.slideIn(slideDirection, {preserveScroll:true, duration:Ext.Number.from(me.animCollapse, Ext.fx.Anim.prototype.duration), listeners:{afteranimate:function() {
    me.isSliding = false;
    me.fireEvent('endfloat', me);
    me.fireEvent('float', me);
  }}});
}, onFloatedPointerEvent:function(event) {
  var me = this;
  if (me.owns(event) || me.placeholder.owns(event) || me.splitter && me.splitter.owns(event) || me.floatCollapsedPanel && me.el.getRegion().contains(event.getPoint())) {
    me.slideOutTask.cancel();
  } else {
    me.slideOutTask.delay(500);
  }
}, onMouseEnterFloated:function(e) {
  this.slideOutTask.cancel();
}, onMouseLeaveFloated:function(e) {
  var toElement = e.getRelatedTarget();
  if (toElement && (this.owns(toElement) || this.placeholder.owns(toElement))) {
    return;
  }
  this.slideOutTask.delay(500);
}, onPlaceholderResize:function(ph, newWidth, newHeight) {
  var me = this, splitter = me.splitter, myBox = me.getBox(false, true), phBox = Ext.util.Region.from(ph.getBox(false, true));
  if (splitter) {
    phBox = phBox.union(splitter.getBox(false, true));
  }
  switch(me.floated) {
    case 'top':
      me.width = newWidth;
      me.setLocalY(phBox.y + phBox.height);
      break;
    case 'right':
      me.height = newHeight;
      me.setLocalX(phBox.x - myBox.width);
      break;
    case 'bottom':
      me.width = newWidth;
      me.setLocalY(phBox.y - myBox.height);
      break;
    case 'left':
      me.height = newHeight;
      me.setLocalX(phBox.x + phBox.width);
      break;
  }
  me.updateLayout({isRoot:true});
}, getAnimationProps:function() {
  var me = this, props;
  props = Ext.container.Container.prototype.getAnimationProps.call(this);
  if (typeof me.animCollapseDuration === 'number') {
    props.duration = me.animCollapseDuration;
  } else {
    if (typeof me.animCollapse === 'number') {
      props.duration = me.animCollapse;
    }
  }
  return props;
}, getCollapsed:function() {
  var me = this;
  if (me.collapsed === true) {
    return me.collapseDirection;
  }
  return me.collapsed;
}, getCollapsedDockedItems:function() {
  var me = this;
  return me.header === false || me.collapseMode === 'placeholder' ? me.emptyArray : [me.getReExpander()];
}, getComponent:function(comp) {
  var component = Ext.container.Container.prototype.getComponent.apply(this, arguments);
  if (component === undefined && !Ext.isNumber(comp)) {
    component = this.getDockedComponent(comp);
  }
  return component;
}, getHeader:function() {
  return this.header;
}, getHeaderCollapsedClasses:function(header) {
  var me = this, collapsedCls = me.collapsedCls, collapsedClasses;
  collapsedClasses = [collapsedCls, collapsedCls + '-' + header.getDockName()];
  if (me.border && (!me.frame || me.frame && Ext.supports.CSS3BorderRadius)) {
    collapsedClasses.push(collapsedCls + '-border-' + header.getDockName());
  }
  return collapsedClasses;
}, getOppositeDirection:function(d) {
  var c = Ext.Component;
  switch(d) {
    case c.DIRECTION_TOP:
      return c.DIRECTION_BOTTOM;
    case c.DIRECTION_RIGHT:
      return c.DIRECTION_LEFT;
    case c.DIRECTION_BOTTOM:
      return c.DIRECTION_TOP;
    case c.DIRECTION_LEFT:
      return c.DIRECTION_RIGHT;
  }
}, getPlaceholder:function(direction) {
  var me = this, collapseDir = direction || me.collapseDirection, listeners = null, placeholder = me.placeholder, floatable = me.floatable, titleCollapse = me.titleCollapse;
  if (!placeholder) {
    if (floatable || me.collapsible && titleCollapse) {
      listeners = {click:{fn:function(e, target) {
        var expandTool = placeholder.expandTool;
        if (!(expandTool && expandTool.el.dom.contains(arguments[1]))) {
          me[!titleCollapse && floatable ? 'floatCollapsedPanel' : 'toggleCollapse']();
        }
      }, element:'el', scope:me}};
    }
    me.placeholder = placeholder = Ext.widget(me.createReExpander(collapseDir, {id:me.id + '-placeholder', listeners:listeners}));
  }
  if (!placeholder.placeholderFor) {
    if (!placeholder.isComponent) {
      me.placeholder = placeholder = me.lookupComponent(placeholder);
    }
    Ext.applyIf(placeholder, {margin:me.margin, placeholderFor:me, synthetic:true});
    placeholder.addCls(['x-region-collapsed-placeholder', 'x-region-collapsed-' + collapseDir + '-placeholder', me.collapsedCls]);
  }
  return placeholder;
}, getProtoBody:function() {
  var me = this, body = me.protoBody;
  if (!body) {
    me.protoBody = body = new Ext.util.ProtoElement({cls:me.bodyCls, style:me.bodyStyle, clsProp:'bodyCls', styleProp:'bodyStyle', styleIsText:true});
  }
  return body;
}, getReExpander:function(direction) {
  var me = this, collapseDir = direction || me.collapseDirection, reExpander = me.reExpander || me.findReExpander(collapseDir), titleCollapse = me.titleCollapse, listeners = null;
  me.expandDirection = me.getOppositeDirection(collapseDir);
  if (!reExpander) {
    if (titleCollapse) {
      listeners = {click:{fn:me.toggleCollapse, element:'el', scope:me}};
    }
    me.reExpander = reExpander = me.createReExpander(collapseDir, {dock:collapseDir, cls:'x-docked ' + me.baseCls + '-' + me.ui + '-collapsed', isCollapsedExpander:true, listeners:listeners});
    me.dockedItems.insert(0, reExpander);
  }
  return reExpander;
}, getRefItems:function(deep) {
  var placeholder = this.placeholder, result;
  if (placeholder) {
    result = [placeholder];
    if (deep && placeholder.getRefItems) {
      result.push.apply(result, placeholder.getRefItems(deep));
    }
  } else {
    result = [];
  }
  result.push.apply(result, this.getDockingRefItems(deep, Ext.container.Container.prototype.getRefItems.call(this, deep)));
  return result;
}, getState:function() {
  var me = this, state = Ext.container.Container.prototype.getState.call(this) || {}, collapsed = me.collapsed, floated = me.floated, memento, placeholder;
  if (floated) {
    me.collapsed = floated;
  }
  state = me.addPropertyToState(state, 'collapsed');
  if (floated) {
    me.collapsed = collapsed;
  }
  if (me.getCollapsed()) {
    memento = me.getMemento('collapse').data;
    state = me.addPropertyToState(state, 'collapsed', memento);
    placeholder = me.isPlaceHolderCollapse();
    if (me.collapsedVertical()) {
      if (placeholder) {
        state = me.addPropertyToState(state, 'height');
        delete state.width;
      } else {
        delete state.height;
        if (memento) {
          state = me.addPropertyToState(state, 'height', memento.height);
        }
      }
    } else {
      if (placeholder) {
        state = me.addPropertyToState(state, 'width');
        delete state.height;
      } else {
        delete state.width;
        if (memento) {
          state = me.addPropertyToState(state, 'width', memento.width);
        }
      }
    }
  }
  return state;
}, applyState:function(state) {
  var me = this, collapseMemento = {}, collapsed;
  if (state) {
    collapsed = state.collapsed;
    if (collapsed) {
      collapseMemento = me.getMemento('collapse');
      Ext.Object.merge(collapseMemento.data, collapsed);
      state.collapsed = true;
    }
    Ext.container.Container.prototype.applyState.apply(this, arguments);
  }
}, ghost:function(cls) {
  var me = this, myEl = me.el, ghostPanel = me.ghostPanel, box = me.getBox(), header = me.header, ghostHeader, tools, icon, iconCls, glyph, i;
  Ext.suspendLayouts();
  if (!ghostPanel) {
    me.ghostPanel = ghostPanel = Ext.widget(me.createGhost(cls));
    ghostPanel.el.dom.removeAttribute('tabIndex');
  } else {
    ghostPanel.el.show();
  }
  ghostPanel.setHiddenState(false);
  ghostPanel.setXY([box.x, box.y]);
  ghostPanel.setSize(box.width, box.height);
  ghostPanel.floatParent = me.floatParent;
  if (header && !me.preventHeader && me.lastHeaderGen !== header.items.generation) {
    ghostHeader = ghostPanel.header;
    tools = ghostHeader.query('tool');
    for (i = tools.length; i--;) {
      ghostHeader.remove(tools[i]);
    }
    ghostHeader.setTitlePosition(0);
    ghostPanel.addTool(me.ghostTools());
    ghostPanel.setTitle(me.getTitle());
    ghostHeader.setTitlePosition(header.getTitlePosition());
    ghostHeader.setIconAlign(header.getIconAlign());
    ghostHeader.setTitleAlign(header.getTitleAlign());
    iconCls = me.getIconCls();
    if (iconCls) {
      ghostPanel.setIconCls(iconCls);
    } else {
      icon = me.getIcon();
      if (icon) {
        ghostPanel.setIcon(icon);
      } else {
        glyph = me.getGlyph();
        if (glyph) {
          ghostPanel.setGlyph(glyph);
        }
      }
    }
    ghostHeader.addCls('x-header-ghost');
    me.lastHeaderGen = header.items.generation;
  }
  Ext.resumeLayouts(true);
  me.elVisMode = myEl.getVisibilityMode();
  myEl.setVisibilityMode(Ext.Element.CLIP);
  myEl.hide();
  return ghostPanel;
}, ghostTools:function() {
  var tools = [], header = this.header, headerTools = header ? header.query('tool[hidden\x3dfalse]') : [], t, tLen, tool;
  if (headerTools.length) {
    t = 0;
    tLen = headerTools.length;
    for (; t < tLen; t++) {
      tool = headerTools[t];
      tools.push({type:tool.type, focusable:false});
    }
  } else {
    tools = [{type:'placeholder'}];
  }
  return tools;
}, initBodyBorder:function() {
  var me = this;
  if (me.frame && me.bodyBorder) {
    if (!Ext.isNumber(me.bodyBorder)) {
      me.bodyBorder = 1;
    }
    me.getProtoBody().setStyle('border-width', this.unitizeBox(me.bodyBorder));
  }
}, initBodyStyles:function() {
  var me = this, body = me.getProtoBody();
  if (me.bodyPadding !== undefined) {
    if (me.layout.managePadding) {
      body.setStyle('padding', 0);
    } else {
      body.setStyle('padding', this.unitizeBox(me.bodyPadding === true ? 5 : me.bodyPadding));
    }
  }
  me.initBodyBorder();
}, initBorderProps:function() {
  var me = this;
  if (me.frame && me.border && me.bodyBorder === undefined) {
    me.bodyBorder = false;
  }
  if (me.frame && me.border && (me.bodyBorder === false || me.bodyBorder === 0)) {
    me.manageBodyBorders = true;
  }
}, initComponent:function() {
  var me = this;
  if (me.collapsible) {
    me.addStateEvents(['expand', 'collapse']);
  }
  if (me.unstyled) {
    me.setUI('plain');
  }
  if (me.frame) {
    me.setUI(me.ui + '-framed');
  }
  me.bridgeToolbars();
  me.initBorderProps();
  Ext.container.Container.prototype.initComponent.call(this);
  me.collapseDirection = me.collapseDirection || me.getHeaderPosition() || Ext.Component.DIRECTION_TOP;
  if (typeof me.animCollapse === 'number') {
    me.animCollapseDuration = me.animCollapse;
  }
  me.hiddenOnCollapse = new Ext.dom.CompositeElement;
}, initItems:function() {
  Ext.container.Container.prototype.initItems.call(this);
  this.initDockingItems();
}, initRenderData:function() {
  var me = this, bodyWrapRole = me.bodyWrapAriaRole, bodyRole = me.bodyAriaRole, data;
  data = Ext.container.Container.prototype.initRenderData.call(this);
  me.initBodyStyles();
  me.protoBody.writeTo(data);
  delete me.protoBody;
  if (me.headingText) {
    data.headingText = me.headingText;
    me.addChildEl('headingEl');
  }
  if (bodyWrapRole) {
    data.bodyWrapAriaAttributes = {role:bodyWrapRole};
    if (!me.ariaStaticRoles[bodyWrapRole] && me.bodyWrapAriaRenderAttributes) {
      Ext.apply(data.bodyWrapAriaAttributes, me.bodyWrapAriaRenderAttributes);
    }
  }
  if (bodyRole) {
    data.bodyAriaAttributes = {role:bodyRole};
    if (!me.ariaStaticRoles[bodyRole] && me.bodyAriaRenderAttributes) {
      Ext.apply(data.bodyAriaAttributes, me.bodyAriaRenderAttributes);
    }
  }
  return data;
}, calculateConstrainedPosition:function(constrainTo, proposedPosition, local, proposedSize) {
  var me = this, header = me.header, lastBox, fp;
  if (me.constrainHeader) {
    lastBox = header.lastBox;
    if (proposedSize) {
      if (!header.vertical) {
        proposedSize = [proposedSize[0], lastBox ? lastBox.height : proposedSize[1]];
      } else {
        proposedSize = [lastBox ? lastBox.width : proposedSize[0], proposedSize[1]];
      }
    } else {
      if (lastBox) {
        proposedSize = [lastBox.width, lastBox.height];
      }
    }
    fp = me.floatParent;
    constrainTo = constrainTo || me.constrainTo || (fp ? fp.getTargetEl() : null) || me.container || me.el.parent();
  }
  return Ext.container.Container.prototype.calculateConstrainedPosition.call(this, constrainTo, proposedPosition, local, proposedSize);
}, initTools:function() {
  var me = this, tools = me.tools, len = tools && tools.length, i, toolCfg, tool;
  me.tools = [];
  if (len) {
    for (i = 0; i < len; ++i) {
      tool = tools[i];
      if (typeof tool !== 'string' && !tool.isTool) {
        tool = Ext.apply({}, tool);
      }
      me.tools.push(tool);
      tool.toolOwner = me;
    }
  }
  if (me.collapsible && !(me.hideCollapseTool || me.header === false || me.preventHeader)) {
    me.updateCollapseTool();
    if (me.collapseFirst) {
      me.tools.unshift(me.collapseTool);
    }
  }
  me.addTools();
  if (me.pinnable) {
    me.initPinnable();
  }
  if (me.closable) {
    me.addClsWithUI('closable');
    toolCfg = {xtype:'tool', type:'close', scope:me, handler:me.close, tooltip:me.closeToolText};
    if (me.isAccordionPanel || me.disableCloseToolFocus) {
      toolCfg.focusable = false;
      toolCfg.ariaRole = 'presentation';
    }
    me.addTool(toolCfg);
  }
  if (me.collapseTool && !me.collapseFirst) {
    me.addTool(me.collapseTool);
  }
}, isLayoutRoot:function() {
  if (this.floatedFromCollapse) {
    return true;
  }
  return Ext.container.Container.prototype.isLayoutRoot.call(this);
}, isPlaceHolderCollapse:function() {
  return this.collapseMode === 'placeholder';
}, isVisible:function(deep) {
  var me = this;
  if (me.collapsed && me.placeholder) {
    return me.placeholder.isVisible(deep);
  }
  return Ext.container.Container.prototype.isVisible.apply(this, arguments);
}, onBoxReady:function() {
  var me = this, target;
  Ext.container.Container.prototype.onBoxReady.apply(this, arguments);
  if (me.collapsed) {
    me.setHiddenDocked();
  }
  if (me.isAccordionPanel) {
    me.ariaEl = me.header.titleCmp.el;
    me.ariaEl.dom.setAttribute('aria-expanded', !me.collapsed);
    me.ariaEl.dom.setAttribute('aria-controls', me.body.id);
    me.body.dom.setAttribute('aria-labelledby', me.header.titleCmp.id);
    me.body.dom.setAttribute('aria-hidden', !!me.collapsed);
    me.accordionHeaderKeyNav = new Ext.util.KeyNav({target:me.header.titleCmp.el, scope:me, left:me.navigateAccordionHeader, right:me.navigateAccordionHeader, up:me.navigateAccordionHeader, down:me.navigateAccordionHeader, home:me.navigateAccordionHeader, end:me.navigateAccordionHeader, space:me.toggleCollapse, enter:me.toggleCollapse, del:{alt:true, fn:me.maybeClose}});
    me.accordionBodyKeyNav = new Ext.util.KeyNav({target:me.bodyWrap, scope:me, up:{ctrl:true, fn:me.navigateAccordionBody}});
  }
  if (me.defaultButton) {
    target = me.defaultButtonTarget ? me[me.defaultButtonTarget] : me.body;
    me.defaultButtonKeyNav = new Ext.util.KeyNav({target:target, scope:me, defaultEventAction:'stopEvent', enter:me.fireDefaultButton});
  }
}, onHide:function(animateTarget, cb, scope) {
  var me = this, dd = me.dd;
  if (me.floatedFromCollapse) {
    me.slideOutFloatedPanel(true);
  }
  if (me.draggable && dd) {
    dd.endDrag();
  }
  if (me.collapsed && me.placeholder) {
    if (me.splitter) {
      Ext.suspendLayouts();
      me.splitter.hide();
      Ext.resumeLayouts();
    }
    me.placeholder.hide();
  } else {
    Ext.container.Container.prototype.onHide.call(this, animateTarget, cb, scope);
  }
}, onRemoved:function(destroying) {
  var me = this;
  if (me.placeholder && !destroying) {
    me.ownerCt.remove(me.placeholder, false);
  }
  Ext.container.Container.prototype.onRemoved.apply(this, arguments);
}, onShow:function() {
  var me = this;
  if (me.collapsed && me.isPlaceHolderCollapse()) {
    if (me.splitter) {
      Ext.suspendLayouts();
      me.splitter.show();
      Ext.resumeLayouts();
    }
    me.setHiddenState(true);
    me.placeholderCollapse();
  } else {
    Ext.container.Container.prototype.onShow.apply(this, arguments);
  }
}, placeholderCollapse:function(direction, animate) {
  var me = this, ownerCt = me.ownerCt, collapseDir = direction || me.collapseDirection, floatCls = Ext.panel.Panel.floatCls, collapseTool = me.collapseTool, placeholder = me.getPlaceholder(collapseDir), slideInDirection;
  if (Ext.Component.layoutSuspendCount || me.isLayoutSuspended()) {
    animate = false;
  }
  me.fireEvent('beginfloat', me);
  me.isCollapsingOrExpanding = 1;
  me.setHiddenState(true);
  me.collapsed = collapseDir;
  if (placeholder.rendered) {
    if (placeholder.el.dom.parentNode !== me.el.dom.parentNode) {
      me.el.dom.parentNode.insertBefore(placeholder.el.dom, me.el.dom);
    }
    placeholder.hidden = false;
    placeholder.setHiddenState(false);
    placeholder.el.show();
    ownerCt.updateLayout();
  } else {
    ownerCt.insert(ownerCt.items.indexOf(me), placeholder);
  }
  if (me.rendered) {
    me.focusPlaceholderExpandTool = me.focusPlaceHolder = false;
    if (collapseTool && Ext.ComponentManager.getActiveComponent() === collapseTool) {
      me.focusPlaceholderExpandTool = true;
    } else {
      if (me.containsFocus) {
        me.focusPlaceHolder = true;
      }
    }
    me.el.setVisibilityMode(me.placeholderCollapseHideMode);
    if (animate) {
      me.el.addCls(floatCls);
      placeholder.el.hide();
      slideInDirection = me.convertCollapseDir(collapseDir);
      me.el.slideOut(slideInDirection, {preserveScroll:true, duration:Ext.Number.from(animate, Ext.fx.Anim.prototype.duration), listeners:{scope:me, afteranimate:function() {
        var me = this, placeholderEl = me.placeholder.el;
        me.el.removeCls(floatCls);
        placeholderEl.show();
        if (me.ownerCt) {
          placeholderEl.setStyle('display', 'none');
          placeholderEl.slideIn(slideInDirection, {easing:'linear', duration:100, listeners:{afteranimate:me.doPlaceholderCollapse, scope:me}});
        } else {
          me.doPlaceholderCollapse();
        }
      }}});
    } else {
      me.el.hide();
      me.doPlaceholderCollapse();
    }
  } else {
    me.isCollapsingOrExpanding = 0;
    if (!me.preventCollapseFire) {
      me.fireEvent('collapse', me);
    }
  }
  return me;
}, doPlaceholderCollapse:function() {
  var me = this, placeholder = me.placeholder, expandTool = placeholder.expandTool, dom;
  if (me.focusPlaceholderExpandTool && expandTool) {
    expandTool.focus();
  } else {
    if (me.focusPlaceHolder) {
      placeholder.focus();
    }
  }
  me.focusPlaceholderExpandTool = false;
  placeholder.setHiddenState(false);
  if (placeholder.rendered) {
    dom = placeholder.ariaEl.dom;
    dom.setAttribute('aria-hidden', false);
    dom.setAttribute('aria-expanded', false);
  }
  dom = me.ariaEl.dom;
  dom.setAttribute('aria-hidden', true);
  dom.setAttribute('aria-expanded', false);
  me.isCollapsingOrExpanding = 0;
  me.fireEvent('collapse', me);
  me.fireEvent('endfloat', me);
}, placeholderExpand:function(animate) {
  var me = this, collapseDir = me.collapsed, expandTool = me.placeholder.expandTool, floatCls = Ext.panel.Panel.floatCls, center = me.ownerLayout ? me.ownerLayout.centerRegion : null, finalPos, floatedPos;
  if (Ext.Component.layoutSuspendCount) {
    animate = false;
  }
  if (me.floatedFromCollapse) {
    floatedPos = me.getPosition(true);
    me.slideOutFloatedPanelBegin();
    me.slideOutFloatedPanelEnd();
    me.floated = false;
  }
  if (expandTool && Ext.ComponentManager.getActiveComponent() === expandTool) {
    me.focusHeaderCollapseTool = true;
    expandTool._ariaRole = expandTool.ariaEl.dom.getAttribute('role');
    expandTool._ariaLabel = expandTool.ariaEl.dom.getAttribute('aria-label');
    expandTool.ariaEl.dom.setAttribute('role', 'presentation');
    expandTool.ariaEl.dom.removeAttribute('aria-label');
  }
  if (animate) {
    Ext.suspendLayouts();
    me.placeholder.hide();
    me.el.show();
    me.collapsed = false;
    me.setHiddenState(false);
    if (center && !floatedPos) {
      center.hidden = true;
    }
    Ext.resumeLayouts(true);
    if (center) {
      center.hidden = false;
    }
    if (!me.floatedFromCollapse) {
      me.fireEvent('beginfloat', me);
    }
    me.el.addCls(floatCls);
    me.isCollapsingOrExpanding = 2;
    if (floatedPos) {
      finalPos = me.getXY();
      me.setLocalXY(floatedPos[0], floatedPos[1]);
      me.setXY([finalPos[0], finalPos[1]], {duration:Ext.Number.from(animate, Ext.fx.Anim.prototype.duration), listeners:{scope:me, afteranimate:function() {
        var me = this;
        me.el.removeCls(floatCls);
        me.isCollapsingOrExpanding = 0;
        me.fireEvent('expand', me);
        me.fireEvent('endfloat', me);
      }}});
    } else {
      me.el.hide();
      me.placeholder.el.show();
      me.placeholder.hidden = false;
      me.setHiddenState(false);
      me.el.slideIn(me.convertCollapseDir(collapseDir), {preserveScroll:true, duration:Ext.Number.from(animate, Ext.fx.Anim.prototype.duration), listeners:{afteranimate:me.doPlaceholderExpand, scope:me}});
    }
  } else {
    me.floated = me.collapsed = false;
    me.doPlaceholderExpand(true);
  }
  return me;
}, doPlaceholderExpand:function(nonAnimated) {
  nonAnimated = nonAnimated === true;
  var me = this, placeholder = me.placeholder, collapseTool = me.collapseTool, expandTool = placeholder.expandTool;
  if (nonAnimated) {
    Ext.suspendLayouts();
    me.show();
  }
  me.el.removeCls(Ext.panel.Panel.floatCls);
  placeholder.hide();
  if (nonAnimated) {
    Ext.resumeLayouts(true);
  } else {
    me.updateLayout();
  }
  if (me.focusHeaderCollapseTool && collapseTool) {
    collapseTool.focus();
  }
  me.focusHeaderCollapseTool = false;
  placeholder.ariaEl.dom.setAttribute('aria-expanded', true);
  me.ariaEl.dom.setAttribute('aria-expanded', true);
  if (expandTool && expandTool._ariaRole) {
    expandTool.ariaEl.dom.setAttribute('role', expandTool._ariaRole);
    expandTool.ariaEl.dom.setAttribute('aria-label', expandTool._ariaLabel);
    expandTool._ariaRole = expandTool._ariaLabel = null;
  }
  me.isCollapsingOrExpanding = 0;
  me.fireEvent('expand', me);
  me.fireEvent('endfloat', me);
}, remove:function(component, autoDestroy) {
  var dockedItems = this.dockedItems;
  if (dockedItems && dockedItems.contains(component)) {
    this.removeDocked(component, autoDestroy);
  } else {
    Ext.container.Container.prototype.remove.call(this, component, autoDestroy);
  }
  return component;
}, removeBodyCls:function(cls) {
  var me = this, body = me.rendered ? me.body : me.getProtoBody();
  body.removeCls(cls);
  return me;
}, removeUIClsFromElement:function(cls) {
  var me = this, result = Ext.container.Container.prototype.removeUIClsFromElement.apply(this, arguments);
  me.removeBodyCls(['x-' + cls, me.baseCls + '-body-' + cls, me.baseCls + '-body-' + me.ui + '-' + cls]);
  return result;
}, restoreDimension:function() {
  var dir = this.collapseDirection;
  return dir === 'top' || dir === 'bottom' ? 'height' : 'width';
}, restoreHiddenDocked:function() {
  this.setDockedItemsVisibility(this.hiddenOnCollapse, true);
}, setBodyStyle:function(style, value) {
  var me = this, body = me.rendered ? me.body : me.getProtoBody();
  if (Ext.isFunction(style)) {
    style = style();
  }
  if (arguments.length === 1) {
    if (Ext.isString(style)) {
      style = Ext.Element.parseStyles(style);
    }
    body.setStyle(style);
  } else {
    body.setStyle(style, value);
  }
  return me;
}, setBorder:function(border, targetEl) {
  if (targetEl) {
    return;
  }
  var me = this, header = me.header;
  if (!border) {
    border = 0;
  } else {
    if (border === true) {
      border = '1px';
    } else {
      border = me.unitizeBox(border);
    }
  }
  if (header) {
    if (header.isHeader) {
      header.setBorder(border);
    } else {
      header.border = border;
    }
  }
  if (me.rendered && me.bodyBorder !== false) {
    me.body.setStyle('border-width', border);
  }
  me.updateLayout();
  me.border = border;
}, setCollapsed:function(collapsed) {
  this[collapsed ? 'collapse' : 'expand']();
}, setDockedItemsVisibility:function(els, show) {
  var me = this, items = me.getDockedItems(), len = items.length, i = 0, item, reExpander;
  if (me.header !== false) {
    reExpander = me.getReExpander();
  }
  for (; i < len; i++) {
    item = items[i];
    if (item && item !== reExpander && item.el) {
      els.add(item.el);
    }
  }
  els.setStyle('visibility', show ? '' : 'hidden');
  els.clear();
}, setGlyph:function(glyph) {
  this.setHeaderConfig(glyph, 'glyph', 'setGlyph', true);
}, setIcon:function(icon) {
  this.setHeaderConfig(icon, 'icon', 'setIcon', true);
}, setIconCls:function(iconCls) {
  this.setHeaderConfig(iconCls, 'iconCls', 'setIconCls', true);
}, setIconAlign:function(iconAlign) {
  this.setHeaderConfig(iconAlign, 'iconAlign', 'setIconAlign', true);
}, setTitleAlign:function(titleAlign) {
  this.setHeaderConfig(titleAlign, 'titleAlign', 'setTitleAlign', true);
}, setTitlePosition:function(titlePosition) {
  this.setHeaderConfig(titlePosition, 'titlePosition', 'setTitlePosition', true);
}, setTitleRotation:function(titleRotation) {
  this.setHeaderConfig(titleRotation, 'titleRotation', 'setTitleRotation', true);
}, setTitle:function(title) {
  var me = this, oldTitle = me.title;
  if (title !== oldTitle && me.headingEl) {
    me.headingEl.setHtml(title);
  }
  this.setHeaderConfig(title, 'title', 'setTitle', false);
}, setHeaderConfig:function(value, prop, setter, addToHeaderCfg) {
  var me = this, oldValue = me[prop], header = me.header, placeholder = me.placeholder, reExpander = me.reExpander, eventName;
  if (value !== oldValue) {
    me[prop] = value;
    if (header) {
      if (header.isHeader) {
        header[setter](value);
      } else {
        if (addToHeaderCfg) {
          header[prop] = value;
        }
      }
    } else {
      if (me.rendered || me.afterHeaderInit) {
        me.updateHeader();
      }
    }
    if (reExpander) {
      reExpander[setter](value);
    }
    if (placeholder && placeholder[setter]) {
      placeholder[setter](value);
    }
    eventName = prop.toLowerCase() + 'change';
    if (me.hasListeners[eventName]) {
      me.fireEvent(eventName, me, value, oldValue);
    }
  }
}, setHiddenDocked:function() {
  var me = this, toHide = new Ext.dom.CompositeElement;
  me.hiddenOnCollapse.add(me.body);
  toHide.add(me.body);
  me.setDockedItemsVisibility(toHide, false);
}, setUI:function(ui) {
  var me = this;
  Ext.container.Container.prototype.setUI.apply(this, arguments);
  if (me.header && me.header.rendered) {
    me.header.setUI(ui);
  }
}, toggleCollapse:function() {
  return this.collapsed || this.floatedFromCollapse ? this.expand() : this.collapse();
}, updateCollapseTool:function() {
  var me = this, collapseTool = me.collapseTool, toolCfg;
  if (!collapseTool && me.collapsible) {
    me.collapseDirection = me.collapseDirection || me.getHeaderPosition() || 'top';
    toolCfg = {xtype:'tool', handler:me.toggleCollapse, scope:me};
    if (me.isAccordionPanel) {
      toolCfg.focusable = false;
      toolCfg.ariaRole = 'presentation';
    }
    me.collapseTool = me.expandTool = collapseTool = Ext.widget(toolCfg);
  }
  if (collapseTool) {
    if (me.collapsed && !me.isPlaceHolderCollapse()) {
      collapseTool.setType('expand-' + me.getOppositeDirection(me.collapseDirection));
      collapseTool.setTooltip(me.expandToolText);
    } else {
      collapseTool.setType('collapse-' + me.collapseDirection);
      collapseTool.setTooltip(me.collapseToolText);
    }
  }
}, navigateAccordionHeader:function(e) {
  var me = this, key, target;
  key = e.getKey();
  switch(key) {
    case e.UP:
    case e.LEFT:
      target = me.findAccordionSibling('prev');
      break;
    case e.DOWN:
    case e.RIGHT:
      target = me.findAccordionSibling('next');
      break;
    case e.HOME:
      target = me.findAccordionSibling('first');
      break;
    case e.END:
      target = me.findAccordionSibling('last');
      break;
    case e.DELETE:
      target = me.findAccordionSibling('prev') || me.findAccordionSibling('next');
      if (!target) {
        e.doNotClose = true;
      }
      break;
  }
  e.stopEvent();
  if (target && target !== me) {
    target.header.titleCmp.focus();
  }
}, navigateAccordionBody:function(e) {
  var target;
  if (e.getKey() === e.UP) {
    target = this;
  }
  e.stopEvent();
  if (target) {
    target.header.titleCmp.focus();
  }
}, findAccordionSibling:function(which, forceFind) {
  var me = this, siblingSel = '[isAccordionPanel]', sibling;
  switch(which) {
    case 'prev':
      sibling = me.prev(siblingSel);
      if (!sibling) {
        if (me.accordionWrapOver) {
          sibling = me.ownerCt.child(siblingSel + ':last');
        } else {
          if (forceFind) {
            sibling = me;
          }
        }
      }
      break;
    case 'next':
      sibling = me.next(siblingSel);
      if (!sibling) {
        if (me.accordionWrapOver) {
          sibling = me.ownerCt.child(siblingSel + ':first');
        } else {
          if (forceFind) {
            sibling = me;
          }
        }
      }
      break;
    case 'first':
      sibling = me.ownerCt.child(siblingSel + ':first');
      break;
    case 'last':
      sibling = me.ownerCt.child(siblingSel + ':last');
      break;
  }
  return sibling;
}, fireDefaultButton:function(e) {
  var me = this, refHolder, btn;
  if (e.target.tagName === 'TEXTAREA' || e.target.getAttribute('aria-multiline') === 'true') {
    return true;
  }
  refHolder = me.lookupReferenceHolder(false) || me;
  btn = refHolder.lookupReference(me.defaultButton);
  if (btn && btn.click) {
    btn.click(e);
    e.stopEvent();
    return false;
  }
}, maybeClose:function(e) {
  var me = this;
  if (me.closable) {
    me.navigateAccordionHeader(e);
    if (!e.doNotClose) {
      me.close();
    }
  }
}, canFocus:function(skipVisibility, includeFocusTarget) {
  if (this.collapsed) {
    return !!(this.placeholder && this.placeholder.canFocus(skipVisibility, includeFocusTarget));
  }
  return this.mixins.focusable.canFocus.call(this, skipVisibility, includeFocusTarget);
}, focus:function() {
  var me = this, placeholder = me.placeholder;
  if (me.collapsed && placeholder && placeholder.canFocus()) {
    placeholder.focus.apply(placeholder, arguments);
  } else {
    Ext.container.Container.prototype.focus.apply(this, arguments);
  }
}, onFocusEnter:function(e) {
  var me = this, ariaDom = me.ariaEl.dom;
  Ext.container.Container.prototype.onFocusEnter.call(this, e);
  if (me.isAccordionPanel && ariaDom) {
    ariaDom.setAttribute('aria-selected', true);
  }
}, onFocusLeave:function(e) {
  var me = this, ariaDom = me.ariaEl.dom;
  Ext.container.Container.prototype.onFocusLeave.call(this, e);
  if (me.isAccordionPanel && ariaDom) {
    ariaDom.setAttribute('aria-selected', 'false');
  }
}, updateHeaderPosition:function(position) {
  var header = this.header;
  if (header && header.isHeader) {
    header.setDock(position);
  }
}, unghost:function(show, matchPosition, focus) {
  var me = this, el = me.el, ghostPanel = me.ghostPanel;
  if (!ghostPanel) {
    return;
  }
  el.show();
  el.setVisibilityMode(me.elVisMode);
  if (show !== false) {
    if (matchPosition !== false) {
      me.setPagePosition(ghostPanel.getXY());
    }
  } else {
    el.hide();
  }
  ghostPanel.el.hide();
  ghostPanel.setHiddenState(true);
}, updateHeader:function(force) {
  var me = this, header = me.header, title = me.getTitle(), tools = me.tools, icon = me.getIcon(), glyph = me.getGlyph(), iconCls = me.getIconCls(), hasIcon = glyph || icon || iconCls, ariaDom = me.ariaEl.dom, headerPosition = me.getHeaderPosition(), vertical = headerPosition === 'left' || headerPosition === 'right', headingEl, ariaAttr;
  if (Ext.isObject(header) || header !== false && (force || (title || hasIcon) || tools && tools.length || me.collapsible && !me.titleCollapse)) {
    if (header && header.isHeader) {
      header.dockToEl = true;
      header.show();
    } else {
      if (Ext.isObject(header)) {
        me.syncHeaderConfigs(header);
      }
      header = me.header = Ext.widget(Ext.merge({xtype:'header', title:title, titleAlign:me.getTitleAlign(), titlePosition:me.getTitlePosition(), vertical:vertical, dock:me.getHeaderPosition() || 'top', dockToEl:true, titleRotation:me.getTitleRotation(), textCls:me.headerTextCls, iconCls:iconCls, iconAlign:me.getIconAlign(), icon:icon, glyph:glyph, baseCls:me.baseCls + '-header', tools:tools, ui:me.ui, id:me.id + '_header', overCls:me.headerOverCls, indicateDrag:me.draggable, frame:(me.frame || me.alwaysFramed) && 
      me.frameHeader, ignoreParentFrame:me.frame || me.overlapHeader, ignoreBorderManagement:me.frame || me.ignoreHeaderBorderManagement, isAccordionHeader:me.isAccordionPanel, ownerCt:me, synthetic:true, listeners:me.collapsible && me.titleCollapse ? {click:me.toggleCollapse, scope:me} : null}, me.header));
      me.addDocked(header, 0);
    }
    if (me.isAccordionPanel) {
      if (ariaDom) {
        ariaDom.setAttribute('aria-labelledby', header.id + '-title');
        ariaDom.removeAttribute('aria-label');
      } else {
        ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
        ariaAttr['aria-labelledby'] = header.id + '-title';
        delete ariaAttr['aria-label'];
      }
    } else {
      if (title) {
        if (me.ariaRole !== 'tabpanel') {
          if (ariaDom) {
            ariaDom.setAttribute('aria-labelledby', header.id + '-title-textEl');
            ariaDom.removeAttribute('aria-label');
          } else {
            ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
            ariaAttr['aria-labelledby'] = header.id + '-title-textEl';
            delete ariaAttr['aria-label'];
          }
        }
      } else {
        if (me.ariaRenderAttributes) {
          delete me.ariaRenderAttributes['aria-label'];
        }
      }
    }
  } else {
    if (header) {
      header.hide();
    }
    title = Ext.util.Format.stripTags(title);
    if (ariaDom) {
      if (!ariaDom.hasAttribute('aria-labelledby')) {
        if (title) {
          ariaDom.setAttribute('aria-label', title);
        } else {
          ariaDom.removeAttribute('aria-label');
        }
      }
    } else {
      ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
      if (!ariaAttr['aria-labelledby']) {
        if (title) {
          ariaAttr['aria-label'] = title;
        } else {
          delete ariaAttr['aria-label'];
        }
      }
    }
  }
  if (me.isViewportBorderChild && !me.hasOwnProperty('ariaRole')) {
    me.ariaRole = 'region';
  }
  if (title && me.ariaRole === 'region') {
    headingEl = me.headingEl;
    if (headingEl) {
      headingEl.setHtml(title);
    } else {
      if (me.rendered) {
        me.headingEl = Ext.dom.Helper.insertFirst(me.el, {tag:'div', id:me.id + '-headingEl', role:'heading', 'class':'x-hidden-clip', style:'height:0', html:title}, true);
        ariaDom.removeAttribute('aria-label');
        ariaDom.setAttribute('aria-labelledby', me.id + '-headingEl');
      } else {
        me.headingText = me.title;
        ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
        ariaAttr['aria-labelledby'] = me.id + '-headingEl';
        delete ariaAttr['aria-label'];
      }
    }
  } else {
    if (me.headingEl) {
      me.headingEl.destroy();
      me.headingEl = null;
    }
  }
}, statics:{floatCls:'x-border-region-slide-in'}, privates:{addUIToElement:function() {
  var me = this;
  Ext.container.Container.prototype.addUIToElement.apply(this, arguments);
  me.addBodyCls(me.baseCls + '-body-' + me.ui);
}, applyTargetCls:function(targetCls) {
  this.getProtoBody().addCls(targetCls);
}, getDefaultContentTarget:function() {
  return this.body;
}, getTargetEl:function() {
  var me = this;
  return me.body || me.protoBody || me.frameBody || me.el;
}, initDraggable:function() {
  var me = this;
  if (me.simpleDrag) {
    me.initSimpleDraggable();
  } else {
    me.dd = new Ext.panel.DD(me, Ext.isBoolean(me.draggable) ? null : me.draggable);
  }
}, initResizable:function(resizable) {
  Ext.container.Container.prototype.initResizable.call(this, resizable);
  if (this.collapsed) {
    this.resizer.disable();
  }
}, initSimpleDraggable:function() {
  var me = this, dd = me.draggable;
  if (!me.header && !dd.delegate) {
    me.updateHeader(true);
  }
  if (me.header || dd.delegate) {
    dd = Ext.apply({el:me.el, delegate:me.header && me.header.el}, dd);
    if (me.constrain || me.constrainHeader) {
      dd.constrain = me.constrain;
      dd.constrainDelegate = me.constrainHeader;
      dd.constrainTo = me.constrainTo || me.container;
    }
    dd = me.dd = new Ext.util.ComponentDragger(me, dd);
    me.relayEvents(dd, ['dragstart', 'drag', 'dragend']);
  }
}, removeUIFromElement:function() {
  var me = this;
  Ext.container.Container.prototype.removeUIFromElement.apply(this, arguments);
  me.removeBodyCls(me.baseCls + '-body-' + me.ui);
}, setupRenderTpl:function(renderTpl) {
  Ext.container.Container.prototype.setupRenderTpl.apply(this, arguments);
  this.setupDockingRenderTpl(renderTpl);
}, slideOutFloatedPanel:function(preventAnimate) {
  var me = this, compEl = me.el, collapseDirection, focusTarget, afterSlideOut = function() {
    me.slideOutFloatedPanelEnd();
    me.el.removeCls('x-border-region-slide-in');
    me.fireEvent('endfloat', me);
  };
  if (me.isSliding || me.destroyed) {
    return;
  }
  me.isSliding = true;
  me.floated = false;
  me.slideOutFloatedPanelBegin();
  if (preventAnimate) {
    compEl.hide();
    return afterSlideOut();
  }
  if (typeof me.collapsed === 'string') {
    collapseDirection = me.convertCollapseDir(me.collapsed);
  }
  me.fireEvent('beginfloat', me);
  compEl.slideOut(collapseDirection, {preserveScroll:true, duration:Ext.Number.from(me.animCollapse, Ext.fx.Anim.prototype.duration), listeners:{afteranimate:afterSlideOut}});
  if (this.containsFocus) {
    focusTarget = this.findFocusTarget();
    if (focusTarget) {
      focusTarget.focus();
    }
  }
}, slideOutFloatedPanelBegin:function() {
  var me = this;
  me.collapsed = me.floatedFromCollapse;
  me.setHiddenState(true);
  me.floatedFromCollapse = null;
  Ext.destroy(me.pointerLeaveListener, me.phHoverListeners, me.elHoverListeners);
}, slideOutFloatedPanelEnd:function(suppressEvents) {
  var me = this;
  if (me.collapseTool) {
    me.collapseTool.el.show();
  }
  me.slideOutTask.cancel();
  me.isSliding = false;
  if (!suppressEvents) {
    me.fireEvent('unfloat', me);
  }
}, syncHeaderConfigs:function(header) {
  var me = this, config, value;
  for (config in header) {
    value = header[config];
    if (me.headerConfigs[config] && value !== undefined) {
      me[config] = value;
    }
  }
}}}, 0, ['panel'], ['component', 'box', 'container', 'panel'], {'component':true, 'box':true, 'container':true, 'panel':true}, ['widget.panel'], [['docking', Ext.container.DockingContainer]], [Ext.panel, 'Panel', Ext, 'Panel'], function() {
  var proto = this.prototype;
  proto.animCollapse = Ext.enableFx;
  proto.placeholderCollapseHideMode = Ext.Element.VISIBILITY;
});
Ext.define('Ext.theme.neptune.panel.Panel', {override:'Ext.panel.Panel', border:false, bodyBorder:false, initBorderProps:Ext.emptyFn, initBodyBorder:function() {
  if (this.bodyBorder !== true) {
    arguments.callee.$previous.call(this);
  }
}});
Ext.cmd.derive('Ext.container.Monitor', Ext.Base, {target:null, selector:'', scope:null, addHandler:null, removeHandler:null, invalidateHandler:null, clearPropertiesOnDestroy:false, clearPrototypeOnDestroy:false, disabled:0, constructor:function(config) {
  Ext.apply(this, config);
}, destroy:function() {
  this.unbind();
  this.callParent();
}, bind:function(target) {
  var me = this;
  me.target = target;
  target.on('beforedestroy', me.disable, me);
  me.onContainerAdd(target);
}, unbind:function() {
  var me = this, target = me.target;
  if (target && !target.destroying && !target.destroyed) {
    me.onContainerRemove(target, target);
    target.un('beforedestroy', me.disable, me);
  }
  me.items = Ext.destroy(me.items);
}, disable:function() {
  ++this.disabled;
}, enable:function() {
  if (this.disabled > 0) {
    --this.disabled;
  }
}, handleAdd:function(ct, comp) {
  if (!this.disabled) {
    if (Ext.ComponentQuery.is(comp, this.selector)) {
      this.onItemAdd(comp.ownerCt, comp);
    }
    if (comp.isQueryable) {
      this.onContainerAdd(comp);
    }
  }
}, onItemAdd:function(ct, comp) {
  var me = this, items = me.items, handler = me.addHandler;
  if (!me.disabled) {
    if (handler) {
      handler.call(me.scope || comp, comp);
    }
    if (items) {
      items.add(comp);
    }
  }
  comp.clearPropertiesOnDestroy = comp.clearPrototypeOnDestroy = false;
}, onItemRemove:function(ct, comp) {
  var me = this, items = me.items, handler = me.removeHandler;
  if (!me.disabled) {
    if (handler) {
      handler.call(me.scope || comp, comp);
    }
    if (items) {
      items.remove(comp);
    }
  }
}, onContainerAdd:function(ct, preventChildren) {
  var me = this, items, len, i, comp;
  if (ct.isContainer) {
    ct.on({scope:me, add:me.handleAdd, dockedadd:me.handleAdd, remove:me.handleRemove, dockedremove:me.handleRemove});
  }
  if (preventChildren !== true) {
    items = ct.query(me.selector);
    for (i = 0, len = items.length; i < len; ++i) {
      comp = items[i];
      me.onItemAdd(comp.ownerCt, comp);
    }
  }
  items = ct.query('\x3econtainer');
  for (i = 0, len = items.length; i < len; ++i) {
    me.onContainerAdd(items[i], true);
  }
  ct.clearPropertiesOnDestroy = ct.clearPrototypeOnDestroy = false;
}, handleRemove:function(ct, comp) {
  var me = this;
  if (!me.disabled) {
    if (Ext.ComponentQuery.is(comp, me.selector)) {
      me.onItemRemove(ct, comp);
    }
    if (comp.isQueryable) {
      me.onContainerRemove(ct, comp);
    }
  }
}, onContainerRemove:function(ct, comp) {
  var me = this, items, i, len, item;
  if (!comp.destroyed && comp.isContainer) {
    me.removeCtListeners(comp);
    if (!comp.destroying) {
      items = comp.query(me.selector);
      for (i = 0, len = items.length; i < len; ++i) {
        item = items[i];
        me.onItemRemove(item.ownerCt, item);
      }
      items = comp.query('container');
      for (i = 0, len = items.length; i < len; ++i) {
        me.removeCtListeners(items[i]);
      }
    }
  }
  me.invalidateItems(true);
}, removeCtListeners:function(ct) {
  var me = this;
  ct.un({scope:me, add:me.handleAdd, dockedadd:me.handleAdd, remove:me.handleRemove, dockedremove:me.handleRemove});
}, getItems:function() {
  var me = this, items = me.items;
  if (!items) {
    items = me.items = new Ext.util.MixedCollection;
    items.addAll(me.target.query(me.selector));
  }
  return items;
}, invalidateItems:function(triggerHandler) {
  var me = this, handler = me.invalidateHandler;
  if (triggerHandler && handler) {
    handler.call(me.scope || me, me);
  }
  me.items = Ext.destroy(me.items);
}}, 1, 0, 0, 0, 0, 0, [Ext.container, 'Monitor'], 0);
Ext.cmd.derive('Ext.layout.container.Anchor', Ext.layout.container.Auto, {alternateClassName:'Ext.layout.AnchorLayout', type:'anchor', defaultAnchor:'100%', parseAnchorRE:/^(r|right|b|bottom)$/i, manageOverflow:true, setsItemSize:true, beginLayoutCycle:function(ownerContext) {
  var me = this, dimensions = 0, anchorSpec, childContext, childItems, i, length;
  Ext.layout.container.Auto.prototype.beginLayoutCycle.apply(this, arguments);
  childItems = ownerContext.childItems;
  length = childItems.length;
  for (i = 0; i < length; ++i) {
    childContext = childItems[i];
    anchorSpec = childContext.target.anchorSpec;
    if (anchorSpec) {
      if (childContext.widthModel.calculated && anchorSpec.right) {
        dimensions |= 1;
      }
      if (childContext.heightModel.calculated && anchorSpec.bottom) {
        dimensions |= 2;
      }
      if (dimensions === 3) {
        break;
      }
    }
  }
  ownerContext.anchorDimensions = dimensions;
}, calculateItems:function(ownerContext, containerSize) {
  var me = this, childItems = ownerContext.childItems, length = childItems.length, gotHeight = containerSize.gotHeight, gotWidth = containerSize.gotWidth, ownerHeight = containerSize.height, ownerWidth = containerSize.width, knownDimensions = (gotWidth ? 1 : 0) | (gotHeight ? 2 : 0), anchorDimensions = ownerContext.anchorDimensions, anchorSpec, childContext, childMargins, height, i, width;
  if (!anchorDimensions) {
    return true;
  }
  for (i = 0; i < length; i++) {
    childContext = childItems[i];
    childMargins = childContext.getMarginInfo();
    anchorSpec = childContext.target.anchorSpec;
    if (gotWidth && childContext.widthModel.calculated) {
      width = anchorSpec.right(ownerWidth) - childMargins.width;
      width = me.adjustWidthAnchor(width, childContext);
      childContext.setWidth(width);
    }
    if (gotHeight && childContext.heightModel.calculated) {
      height = anchorSpec.bottom(ownerHeight) - childMargins.height;
      height = me.adjustHeightAnchor(height, childContext);
      childContext.setHeight(height);
    }
  }
  return (knownDimensions & anchorDimensions) === anchorDimensions;
}, anchorFactory:{offset:function(delta) {
  return function(v) {
    return v + delta;
  };
}, ratio:function(ratio) {
  return function(v) {
    return Math.floor(v * ratio);
  };
}, standard:function(diff) {
  return function(v) {
    return v - diff;
  };
}}, parseAnchor:function(a, start, cstart) {
  if (a && a !== 'none') {
    var factory = this.anchorFactory, delta;
    if (this.parseAnchorRE.test(a)) {
      return factory.standard(cstart - start);
    }
    if (a.indexOf('%') !== -1) {
      return factory.ratio(parseFloat(a.replace('%', '')) * 0.01);
    }
    delta = parseInt(a, 10);
    if (!isNaN(delta)) {
      return factory.offset(delta);
    }
  }
  return null;
}, adjustWidthAnchor:function(value, childContext) {
  return value;
}, adjustHeightAnchor:function(value, childContext) {
  return value;
}, configureItem:function(item) {
  var me = this, owner = me.owner, anchor = item.anchor, anchorsArray, anchorWidth, anchorHeight;
  Ext.layout.container.Auto.prototype.configureItem.apply(this, arguments);
  if (!item.anchor && item.items && !Ext.isNumber(item.width)) {
    item.anchor = anchor = me.defaultAnchor;
  }
  if (owner.anchorSize) {
    if (typeof owner.anchorSize === 'number') {
      anchorWidth = owner.anchorSize;
    } else {
      anchorWidth = owner.anchorSize.width;
      anchorHeight = owner.anchorSize.height;
    }
  } else {
    anchorWidth = owner.initialConfig.width;
    anchorHeight = owner.initialConfig.height;
  }
  if (anchor) {
    anchorsArray = anchor.split(' ');
    item.anchorSpec = {right:me.parseAnchor(anchorsArray[0], item.initialConfig.width, anchorWidth), bottom:me.parseAnchor(anchorsArray[1], item.initialConfig.height, anchorHeight)};
  }
}, sizePolicy:{$:{readsWidth:1, readsHeight:1, setsWidth:0, setsHeight:0}, b:{readsWidth:1, readsHeight:0, setsWidth:0, setsHeight:1}, r:{$:{readsWidth:0, readsHeight:1, setsWidth:1, setsHeight:0}, b:{readsWidth:0, readsHeight:0, setsWidth:1, setsHeight:1}}}, getItemSizePolicy:function(item) {
  var anchorSpec = item.anchorSpec, key = '$', policy = this.sizePolicy, sizeModel;
  if (anchorSpec) {
    sizeModel = this.owner.getSizeModel();
    if (anchorSpec.right && !sizeModel.width.shrinkWrap) {
      policy = policy.r;
    }
    if (anchorSpec.bottom && !sizeModel.height.shrinkWrap) {
      key = 'b';
    }
  }
  return policy[key];
}}, 0, 0, 0, 0, ['layout.anchor'], 0, [Ext.layout.container, 'Anchor', Ext.layout, 'AnchorLayout'], 0);
Ext.cmd.derive('Ext.dd.DragTracker', Ext.Base, {active:false, trackOver:false, tolerance:5, autoStart:false, constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  me.dragRegion = new Ext.util.Region(0, 0, 0, 0);
  if (me.el) {
    me.initEl(me.el);
  }
  me.mixins.observable.constructor.call(me);
  if (me.disabled) {
    me.disable();
  }
  if (Ext.supports.Touch) {
    Ext.getWin().on({touchstart:'onWindowTouchStart', scope:me, capture:true});
  }
}, initEl:function(el) {
  var me = this, delegate = me.delegate, elCmp, touchScrollable, unselectable;
  me.el = el = Ext.get(el);
  if (delegate) {
    if (delegate.isElement) {
      me.handle = delegate;
      unselectable = delegate;
    }
  } else {
    unselectable = el;
  }
  if (unselectable) {
    unselectable.addCls('x-unselectable');
  }
  me.delegate = me.handle ? undefined : me.delegate;
  if (Ext.supports.Touch) {
    elCmp = Ext.Component.from(el);
    touchScrollable = elCmp && elCmp.getScrollable();
    if (touchScrollable) {
      elCmp = touchScrollable.getElement();
      if (me.handle && !elCmp.contains(me.handle)) {
        touchScrollable = false;
      } else {
        if (me.delegate && !elCmp.down(me.delegate)) {
          touchScrollable = false;
        } else {
          touchScrollable = touchScrollable.getX() || touchScrollable.getY();
        }
      }
    }
  }
  if (!me.handle) {
    me.handle = el;
  }
  me.handleListeners = {scope:me, delegate:me.delegate, dragstart:me.onDragStart};
  if (touchScrollable) {
    me.handleListeners.longpress = me.onMouseDown;
    me.handleListeners.mousedown = {fn:me.onMouseDown, delegate:me.delegate, translate:false};
    me.handleListeners.contextmenu = function(e) {
      e.stopEvent();
    };
  } else {
    me.handleListeners.mousedown = me.onMouseDown;
  }
  if (!Ext.supports.TouchEvents && (me.trackOver || me.overCls)) {
    Ext.apply(me.handleListeners, {mouseover:me.onMouseOver, mouseout:me.onMouseOut});
  }
  me.mon(me.handle, me.handleListeners);
  me.keyNav = new Ext.util.KeyNav({target:el, up:me.onResizeKeyDown, left:me.onResizeKeyDown, right:me.onResizeKeyDown, down:me.onResizeKeyDown, scope:me});
}, disable:function() {
  this.disabled = true;
}, enable:function() {
  this.disabled = false;
}, destroy:function() {
  this.endDrag({});
  Ext.destroy(this.keyNav);
  this.callParent();
}, onWindowTouchStart:function(e) {
  if (this.mouseIsDown) {
    this.onMouseUp(e);
  }
}, onMouseOver:function(e, target) {
  var me = this, handleCls, el, i, len, cls;
  if (!me.disabled) {
    if (e.within(e.target, true, true) || me.delegate) {
      handleCls = me.handleCls;
      me.mouseIsOut = false;
      if (handleCls) {
        for (i = 0, len = me.handleEls.length; i < len; i++) {
          el = me.handleEls[i];
          cls = el.delegateCls;
          if (!cls) {
            cls = el.delegateCls = [handleCls, '-', el.region, '-over'].join('');
          }
          el.addCls([cls, me.overCls]);
        }
      }
      me.fireEvent('mouseover', me, e, me.delegate ? e.getTarget(me.delegate, target) : me.handle);
    }
  }
}, onMouseOut:function(e) {
  var me = this, el, i, len;
  if (me.mouseIsDown) {
    me.mouseIsOut = true;
  } else {
    if (me.handleCls) {
      for (i = 0, len = me.handleEls.length; i < len; i++) {
        el = me.handleEls[i];
        el.removeCls([el.delegateCls, me.overCls]);
      }
    }
    me.fireEvent('mouseout', me, e);
  }
}, onMouseDown:function(e, target) {
  var me = this, trackEvent = e.parentEvent || e;
  if (e.button || me.disabled || trackEvent.dragTracked) {
    return;
  }
  me.dragTarget = me.delegate ? target : me.handle.dom;
  me.startXY = me.lastXY = e.getXY();
  me.startRegion = Ext.fly(me.dragTarget).getRegion();
  if (me.fireEvent('mousedown', me, e) === false || me.fireEvent('beforedragstart', me, e) === false || me.onBeforeStart(e) === false) {
    return;
  }
  me.mouseIsDown = true;
  trackEvent.dragTracked = true;
  me.el.setCapture();
  e.stopPropagation();
  if (me.preventDefault !== false || e.pointerType === 'touch') {
    e.preventDefault();
  }
  Ext.getDoc().on({scope:me, capture:true, mouseup:me.onMouseUp, mousemove:me.onMouseMove, selectstart:me.stopSelect});
  me.dragEnded = false;
  if (!me.tolerance) {
    me.triggerStart();
  } else {
    if (me.autoStart) {
      me.timer = Ext.defer(me.triggerStart, me.autoStart === true ? 1000 : me.autoStart, me, [e]);
    }
  }
}, onMouseMove:function(e, target) {
  var me = this, xy = e.getXY(), s = me.startXY;
  e.stopPropagation();
  if (me.preventDefault !== false) {
    e.preventDefault();
  }
  if (me.dragEnded) {
    return;
  }
  me.lastXY = xy;
  if (!me.active) {
    if (Math.max(Math.abs(s[0] - xy[0]), Math.abs(s[1] - xy[1])) > me.tolerance) {
      me.triggerStart(e);
    } else {
      return;
    }
  }
  if (me.fireEvent('mousemove', me, e) === false) {
    me.onMouseUp(e);
  } else {
    me.onDrag(e);
    me.fireEvent('drag', me, e);
  }
}, onMouseUp:function(e) {
  var me = this;
  me.mouseIsDown = false;
  if (me.mouseIsOut) {
    me.mouseIsOut = false;
    me.onMouseOut(e);
  }
  if (me.preventDefault !== false) {
    e.preventDefault();
  }
  if (Ext.isIE && document.releaseCapture) {
    document.releaseCapture();
  }
  me.fireEvent('mouseup', me, e);
  me.endDrag(e);
}, endDrag:function(e) {
  var me = this, wasActive = me.active;
  Ext.getDoc().un({mousemove:me.onMouseMove, mouseup:me.onMouseUp, selectstart:me.stopSelect, capture:true, scope:me});
  me.clearStart();
  me.active = false;
  me.dragEnded = true;
  if (wasActive) {
    me.onEnd(e);
    me.fireEvent('dragend', me, e);
  } else {
    me.onCancel(e);
  }
  me._constrainRegion = null;
}, triggerStart:function(e) {
  var me = this;
  me.clearStart();
  me.active = true;
  me.onStart(e);
  me.fireEvent('dragstart', me, e);
}, clearStart:function() {
  var timer = this.timer;
  if (timer) {
    Ext.undefer(timer);
    this.timer = null;
  }
}, stopSelect:function(e) {
  e.stopEvent();
  return false;
}, onBeforeStart:function(e) {
}, onStart:function(e) {
}, onDrag:function(e) {
}, onCancel:function(e) {
}, onEnd:function(e) {
}, getDragTarget:function() {
  return this.dragTarget;
}, getDragCt:function() {
  return this.el;
}, getConstrainRegion:function() {
  var me = this;
  if (me.constrainTo) {
    if (me.constrainTo instanceof Ext.util.Region) {
      return me.constrainTo;
    }
    if (!me._constrainRegion) {
      me._constrainRegion = Ext.fly(me.constrainTo).getViewRegion();
    }
  } else {
    if (!me._constrainRegion) {
      me._constrainRegion = me.getDragCt().getViewRegion();
    }
  }
  return me._constrainRegion;
}, getXY:function(constrain) {
  return constrain ? this.constrainModes[constrain](this, this.lastXY) : this.lastXY;
}, getOffset:function(constrain) {
  var xy = this.getXY(constrain), s = this.startXY;
  return [xy[0] - s[0], xy[1] - s[1]];
}, onDragStart:function(e) {
  e.stopPropagation();
}, constrainModes:{point:function(me, xy) {
  var dr = me.dragRegion, constrainTo = me.getConstrainRegion();
  if (!constrainTo) {
    return xy;
  }
  dr.x = dr.left = dr[0] = dr.right = xy[0];
  dr.y = dr.top = dr[1] = dr.bottom = xy[1];
  dr.constrainTo(constrainTo);
  return [dr.left, dr.top];
}, dragTarget:function(me, xy) {
  var s = me.startXY, dr = me.startRegion.copy(), constrainTo = me.getConstrainRegion(), adjust;
  if (!constrainTo) {
    return xy;
  }
  dr.translateBy(xy[0] - s[0], xy[1] - s[1]);
  if (dr.right > constrainTo.right) {
    xy[0] += adjust = constrainTo.right - dr.right;
    dr.left += adjust;
  }
  if (dr.left < constrainTo.left) {
    xy[0] += constrainTo.left - dr.left;
  }
  if (dr.bottom > constrainTo.bottom) {
    xy[1] += adjust = constrainTo.bottom - dr.bottom;
    dr.top += adjust;
  }
  if (dr.top < constrainTo.top) {
    xy[1] += constrainTo.top - dr.top;
  }
  return xy;
}}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.dd, 'DragTracker'], 0);
Ext.cmd.derive('Ext.resizer.SplitterTracker', Ext.dd.DragTracker, {enabled:true, overlayCls:'x-resizable-overlay', createDragOverlay:function() {
  var overlay, El = Ext.dom.Element;
  overlay = this.overlay = Ext.getBody().createChild({role:'presentation', cls:this.overlayCls, html:'\x26#160;'});
  overlay.unselectable();
  overlay.setSize(El.getDocumentWidth(), El.getDocumentHeight());
  overlay.show();
}, getPrevCmp:function() {
  var splitter = this.getSplitter();
  return splitter.previousSibling(':not([hidden])');
}, getNextCmp:function() {
  var splitter = this.getSplitter();
  return splitter.nextSibling(':not([hidden])');
}, onBeforeStart:function(e) {
  var me = this, prevCmp = me.getPrevCmp(), nextCmp = me.getNextCmp(), collapseEl = me.getSplitter().collapseEl, target = e.getTarget(), box;
  if (!prevCmp || !nextCmp) {
    return false;
  }
  if (collapseEl && target === collapseEl.dom) {
    return false;
  }
  if (nextCmp.collapsed || prevCmp.collapsed) {
    return false;
  }
  me.prevBox = prevCmp.getEl().getBox();
  me.nextBox = nextCmp.getEl().getBox();
  me.constrainTo = box = me.calculateConstrainRegion();
  if (!box) {
    return false;
  }
  return box;
}, onMouseDown:function(e, target) {
  Ext.dd.DragTracker.prototype.onMouseDown.call(this, e, target);
  if (this.mouseIsDown && this.getSplitter().el.dom === target) {
    Ext.dom.Element.maskIframes();
  }
}, onMouseUp:function(e) {
  Ext.dd.DragTracker.prototype.onMouseUp.call(this, e);
  Ext.dom.Element.unmaskIframes();
}, onStart:function(e) {
  var splitter = this.getSplitter();
  this.createDragOverlay();
  splitter.addCls(splitter.baseCls + '-active');
}, onResizeKeyDown:function(e) {
  var me = this, splitter = me.getSplitter(), key = e.getKey(), incrIdx = splitter.orientation === 'vertical' ? 0 : 1, incr = key === e.UP || key === e.LEFT ? -1 : 1, easing;
  if (!me.active && me.onBeforeStart(e)) {
    Ext.fly(e.target).on('keyup', me.onResizeKeyUp, me);
    me.triggerStart(e);
    me.onMouseDown(e);
    me.startXY = splitter.getXY();
    me.lastKeyDownXY = Ext.Array.slice(me.startXY);
    easing = me.easing = new Ext.fx.easing.Linear;
    easing.setStartTime(Ext.Date.now());
    easing.setStartValue(1);
    easing.setEndValue(4);
    easing.setDuration(2000);
  }
  if (me.active) {
    me.lastKeyDownXY[incrIdx] = Math.round(me.lastKeyDownXY[incrIdx] + incr * me.easing.getValue());
    me.lastXY = me.lastKeyDownXY;
    splitter.setXY(me.getXY('dragTarget'));
  }
}, onResizeKeyUp:function(e) {
  this.onMouseUp(e);
}, calculateConstrainRegion:function() {
  var me = this, splitter = me.getSplitter(), splitWidth = splitter.getWidth(), defaultMin = splitter.defaultSplitMin, orient = splitter.orientation, prevBox = me.prevBox, prevCmp = me.getPrevCmp(), nextBox = me.nextBox, nextCmp = me.getNextCmp(), prevConstrainRegion, nextConstrainRegion, constrainOptions;
  if (orient === 'vertical') {
    constrainOptions = {prevCmp:prevCmp, nextCmp:nextCmp, prevBox:prevBox, nextBox:nextBox, defaultMin:defaultMin, splitWidth:splitWidth};
    prevConstrainRegion = new Ext.util.Region(prevBox.y, me.getVertPrevConstrainRight(constrainOptions), prevBox.bottom, me.getVertPrevConstrainLeft(constrainOptions));
    nextConstrainRegion = new Ext.util.Region(nextBox.y, me.getVertNextConstrainRight(constrainOptions), nextBox.bottom, me.getVertNextConstrainLeft(constrainOptions));
  } else {
    prevConstrainRegion = new Ext.util.Region(prevBox.y + (prevCmp.minHeight || defaultMin), prevBox.right, (prevCmp.maxHeight ? prevBox.y + prevCmp.maxHeight : nextBox.bottom - (nextCmp.minHeight || defaultMin)) + splitWidth, prevBox.x);
    nextConstrainRegion = new Ext.util.Region((nextCmp.maxHeight ? nextBox.bottom - nextCmp.maxHeight : prevBox.y + (prevCmp.minHeight || defaultMin)) - splitWidth, nextBox.right, nextBox.bottom - (nextCmp.minHeight || defaultMin), nextBox.x);
  }
  return prevConstrainRegion.intersect(nextConstrainRegion);
}, performResize:function(e, offset) {
  var me = this, splitter = me.getSplitter(), orient = splitter.orientation, prevCmp = me.getPrevCmp(), nextCmp = me.getNextCmp(), owner = splitter.ownerCt, flexedSiblings = owner.query('\x3e[flex]'), len = flexedSiblings.length, vertical = orient === 'vertical', i = 0, dimension = vertical ? 'width' : 'height', totalFlex = 0, item, size;
  for (; i < len; i++) {
    item = flexedSiblings[i];
    size = vertical ? item.getWidth() : item.getHeight();
    totalFlex += size;
    item.flex = size;
  }
  offset = vertical ? offset[0] : offset[1];
  if (prevCmp) {
    size = me.prevBox[dimension] + offset;
    if (prevCmp.flex) {
      prevCmp.flex = size;
    } else {
      prevCmp[dimension] = size;
    }
  }
  if (nextCmp) {
    size = me.nextBox[dimension] - offset;
    if (nextCmp.flex) {
      nextCmp.flex = size;
    } else {
      nextCmp[dimension] = size;
    }
  }
  owner.updateLayout();
}, endDrag:function() {
  var me = this;
  if (me.overlay) {
    me.overlay.destroy();
    delete me.overlay;
  }
  Ext.dd.DragTracker.prototype.endDrag.apply(this, arguments);
}, onEnd:function(e) {
  var me = this, splitter = me.getSplitter();
  splitter.removeCls(splitter.baseCls + '-active');
  me.performResize(e, me.getResizeOffset());
}, onDrag:function(e) {
  var me = this, offset = me.getOffset('dragTarget'), splitter = me.getSplitter(), splitEl = splitter.getEl(), orient = splitter.orientation;
  if (orient === 'vertical') {
    splitEl.setX(me.startRegion.left + offset[0]);
  } else {
    splitEl.setY(me.startRegion.top + offset[1]);
  }
}, getSplitter:function() {
  return this.splitter;
}, getVertPrevConstrainRight:function(o) {
  return (o.prevCmp.maxWidth ? o.prevBox.x + o.prevCmp.maxWidth : o.nextBox.right - (o.nextCmp.minWidth || o.defaultMin)) + o.splitWidth;
}, getVertPrevConstrainLeft:function(o) {
  return o.prevBox.x + (o.prevCmp.minWidth || o.defaultMin);
}, getVertNextConstrainRight:function(o) {
  return o.nextBox.right - (o.nextCmp.minWidth || o.defaultMin);
}, getVertNextConstrainLeft:function(o) {
  return (o.nextCmp.maxWidth ? o.nextBox.right - o.nextCmp.maxWidth : o.prevBox.x + (o.prevBox.minWidth || o.defaultMin)) - o.splitWidth;
}, getResizeOffset:function() {
  return this.getOffset('dragTarget');
}}, 0, 0, 0, 0, 0, 0, [Ext.resizer, 'SplitterTracker'], 0);
Ext.cmd.derive('Ext.dd.DDTarget', Ext.dd.DragDrop, {constructor:function(id, sGroup, config) {
  if (id) {
    this.initTarget(id, sGroup, config);
  }
}, getDragEl:Ext.emptyFn, isValidHandleChild:Ext.emptyFn, startDrag:Ext.emptyFn, endDrag:Ext.emptyFn, onDrag:Ext.emptyFn, onDragDrop:Ext.emptyFn, onDragEnter:Ext.emptyFn, onDragOut:Ext.emptyFn, onDragOver:Ext.emptyFn, onInvalidDrop:Ext.emptyFn, onMouseDown:Ext.emptyFn, onMouseUp:Ext.emptyFn, setXConstraint:Ext.emptyFn, setYConstraint:Ext.emptyFn, resetConstraints:Ext.emptyFn, clearConstraints:Ext.emptyFn, clearTicks:Ext.emptyFn, setInitPosition:Ext.emptyFn, setDragElId:Ext.emptyFn, setHandleElId:Ext.emptyFn, 
setOuterHandleElId:Ext.emptyFn, addInvalidHandleClass:Ext.emptyFn, addInvalidHandleId:Ext.emptyFn, addInvalidHandleType:Ext.emptyFn, removeInvalidHandleClass:Ext.emptyFn, removeInvalidHandleId:Ext.emptyFn, removeInvalidHandleType:Ext.emptyFn, toString:function() {
  return 'DDTarget ' + this.id;
}}, 3, 0, 0, 0, 0, 0, [Ext.dd, 'DDTarget'], 0);
Ext.cmd.derive('Ext.dd.ScrollManager', Ext.Base, {singleton:true, vthresh:25 * (window.devicePixelRatio || 1), hthresh:25 * (window.devicePixelRatio || 1), increment:100, frequency:500, animate:true, animDuration:0.4, ddGroup:undefined, dirTrans:{up:-1, left:-1, down:1, right:1}, constructor:function() {
  var ddm = Ext.dd.DragDropManager;
  ddm.fireEvents = Ext.Function.createSequence(ddm.fireEvents, this.onFire, this);
  ddm.stopDrag = Ext.Function.createSequence(ddm.stopDrag, this.onStop, this);
  this.doScroll = this.doScroll.bind(this);
  this.ddmInstance = ddm;
  this.els = {};
  this.dragEl = null;
  this.proc = {};
}, onStop:function(e) {
  var sm = Ext.dd.ScrollManager;
  sm.dragEl = null;
  sm.clearProc();
}, triggerRefresh:function() {
  if (this.ddmInstance.dragCurrent) {
    this.ddmInstance.refreshCache(this.ddmInstance.dragCurrent.groups);
  }
}, doScroll:function() {
  var me = this;
  if (me.ddmInstance.dragCurrent) {
    var proc = me.proc, procEl = proc.el, scrollComponent = proc.component, ddScrollConfig = proc.el.ddScrollConfig, distance = ddScrollConfig && ddScrollConfig.increment ? ddScrollConfig.increment : me.increment, animate = ddScrollConfig && 'animate' in ddScrollConfig ? ddScrollConfig.animate : me.animate, afterScroll = function() {
      me.triggerRefresh();
    };
    if (animate) {
      if (animate === true) {
        animate = {callback:afterScroll};
      } else {
        animate.callback = animate.callback ? Ext.Function.createSequence(animate.callback, afterScroll) : afterScroll;
      }
    }
    if (scrollComponent) {
      distance = distance * me.dirTrans[proc.dir];
      if (proc.dir === 'up' || proc.dir === 'down') {
        scrollComponent.scrollBy(0, distance, animate);
      } else {
        scrollComponent.scrollBy(distance, 0, animate);
      }
    } else {
      procEl.scroll(proc.dir, distance, animate);
    }
    if (!animate) {
      afterScroll();
    }
  }
}, clearProc:function() {
  var proc = this.proc;
  if (proc.id) {
    Ext.uninterval(proc.id);
  }
  proc.id = 0;
  proc.el = null;
  proc.dir = '';
}, startProc:function(el, dir) {
  var me = this, proc = me.proc, group, freq;
  me.clearProc();
  proc.el = el;
  proc.dir = dir;
  group = el.ddScrollConfig ? el.ddScrollConfig.ddGroup : undefined;
  freq = el.ddScrollConfig && el.ddScrollConfig.frequency ? el.ddScrollConfig.frequency : me.frequency;
  if (group === undefined || me.ddmInstance.dragCurrent.ddGroup === group) {
    proc.id = Ext.interval(me.doScroll, freq);
  }
}, onFire:function(e, isDrop) {
  var me = this, pt, proc, els, id, el, elementRegion, configSource, ownerCt, scrollerOwner;
  if (isDrop || !me.ddmInstance.dragCurrent) {
    return;
  }
  if (!me.dragEl || me.dragEl !== me.ddmInstance.dragCurrent) {
    me.dragEl = me.ddmInstance.dragCurrent;
    me.refreshCache();
  }
  pt = e.getPoint();
  proc = me.proc;
  els = me.els;
  for (id in els) {
    el = els[id];
    elementRegion = el.getRegion();
    configSource = el.ddScrollConfig || me;
    if (elementRegion && elementRegion.contains(pt)) {
      if (!el.isScrollable()) {
        ownerCt = el.component && el.component.ownerCt;
        scrollerOwner = ownerCt && ownerCt.getScrollerOwner && ownerCt.getScrollerOwner();
        if (scrollerOwner) {
          el = scrollerOwner.getScrollable().getElement();
          elementRegion = el.getRegion();
        } else {
          continue;
        }
      }
      if (elementRegion.bottom - pt.y <= configSource.vthresh) {
        if (proc.el !== el) {
          me.startProc(el, 'down');
        }
        return;
      } else {
        if (elementRegion.right - pt.x <= configSource.hthresh) {
          if (proc.el !== el) {
            me.startProc(el, 'right');
          }
          return;
        } else {
          if (pt.y - elementRegion.top <= configSource.vthresh) {
            if (proc.el !== el) {
              me.startProc(el, 'up');
            }
            return;
          } else {
            if (pt.x - elementRegion.left <= configSource.hthresh) {
              if (proc.el !== el) {
                me.startProc(el, 'left');
              }
              return;
            }
          }
        }
      }
    }
  }
  me.clearProc();
}, register:function(el) {
  if (Ext.isArray(el)) {
    for (var i = 0, len = el.length; i < len; i++) {
      this.register(el[i]);
    }
  } else {
    el = Ext.get(el);
    this.els[el.id] = el;
  }
}, unregister:function(el) {
  if (Ext.isArray(el)) {
    for (var i = 0, len = el.length; i < len; i++) {
      this.unregister(el[i]);
    }
  } else {
    el = Ext.get(el);
    delete this.els[el.id];
  }
}, refreshCache:function() {
  var els = this.els, id;
  for (id in els) {
    if (typeof els[id] === 'object') {
      els[id]._region = els[id].getRegion();
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.dd, 'ScrollManager'], 0);
Ext.cmd.derive('Ext.dd.DropTarget', Ext.dd.DDTarget, {constructor:function(el, config) {
  this.el = Ext.get(el);
  Ext.apply(this, config);
  if (this.containerScroll) {
    Ext.dd.ScrollManager.register(this.el);
  }
  Ext.dd.DDTarget.prototype.constructor.call(this, this.el.dom, this.ddGroup || this.group, {isTarget:true});
}, containerScroll:false, dropAllowed:'x-dd-drop-ok', dropNotAllowed:'x-dd-drop-nodrop', isTarget:true, isNotifyTarget:true, notifyEnter:function(source, e, data) {
  if (this.overClass) {
    this.el.addCls(this.overClass);
  }
  return this.dropAllowed;
}, notifyOver:function(source, e, data) {
  return this.dropAllowed;
}, notifyOut:function(source, e, data) {
  if (this.overClass) {
    this.el.removeCls(this.overClass);
  }
}, notifyDrop:function(source, e, data) {
  if (this.overClass) {
    this.el.removeCls(this.overClass);
  }
  return false;
}, destroy:function() {
  if (this.containerScroll) {
    Ext.dd.ScrollManager.unregister(this.el);
  }
  Ext.dd.DDTarget.prototype.destroy.call(this);
}}, 1, 0, 0, 0, 0, 0, [Ext.dd, 'DropTarget'], 0);
Ext.cmd.derive('Ext.dd.DragZone', Ext.dd.DragSource, {constructor:function(el, config) {
  var me = this, scroll;
  Ext.dd.DragSource.prototype.constructor.call(this, el, config);
  scroll = me.containerScroll;
  if (scroll) {
    el = me.scrollEl || el;
    el = Ext.get(el);
    if (Ext.isObject(scroll)) {
      el.ddScrollConfig = scroll;
    }
    Ext.dd.ScrollManager.register(el);
  }
}, getDragData:function(e) {
  return Ext.dd.Registry.getHandleFromEvent(e);
}, onInitDrag:function(x, y) {
  this.proxy.update(this.dragData.ddel.cloneNode(true));
  this.onStartDrag(x, y);
  return true;
}, getRepairXY:function(e) {
  return Ext.fly(this.dragData.ddel).getXY();
}, destroy:function() {
  if (this.containerScroll) {
    Ext.dd.ScrollManager.unregister(this.scrollEl || this.el);
  }
  Ext.dd.DragSource.prototype.destroy.call(this);
}}, 1, 0, 0, 0, 0, 0, [Ext.dd, 'DragZone'], 0);
Ext.cmd.derive('Ext.dd.Registry', Ext.Base, {singleton:true, constructor:function() {
  this.elements = {};
  this.handles = {};
  this.autoIdSeed = 0;
}, getId:function(el, autogen) {
  if (typeof el === 'string') {
    return el;
  }
  var id = el.id;
  if (!id && autogen !== false) {
    id = 'extdd-' + ++this.autoIdSeed;
    el.id = id;
  }
  return id;
}, register:function(el, data) {
  data = data || {};
  if (typeof el === 'string') {
    el = document.getElementById(el);
  }
  data.ddel = el;
  this.elements[this.getId(el)] = data;
  if (data.isHandle !== false) {
    this.handles[data.ddel.id] = data;
  }
  if (data.handles) {
    var hs = data.handles, i, len;
    for (i = 0, len = hs.length; i < len; i++) {
      this.handles[this.getId(hs[i])] = data;
    }
  }
}, unregister:function(el) {
  var id = this.getId(el, false), data = this.elements[id], hs, i, len;
  if (data) {
    delete this.elements[id];
    if (data.handles) {
      hs = data.handles;
      for (i = 0, len = hs.length; i < len; i++) {
        delete this.handles[this.getId(hs[i], false)];
      }
    }
  }
}, getHandle:function(id) {
  if (typeof id !== 'string') {
    id = id.id;
  }
  return this.handles[id];
}, getHandleFromEvent:function(e) {
  var t = e.getTarget();
  return t ? this.handles[t.id] : null;
}, getTarget:function(id) {
  if (typeof id !== 'string') {
    id = id.id;
  }
  return this.elements[id];
}, getTargetFromEvent:function(e) {
  var t = e.getTarget();
  return t ? this.elements[t.id] || this.handles[t.id] : null;
}}, 1, 0, 0, 0, 0, 0, [Ext.dd, 'Registry'], 0);
Ext.cmd.derive('Ext.dd.DropZone', Ext.dd.DropTarget, {getTargetFromEvent:function(e) {
  return Ext.dd.Registry.getTargetFromEvent(e);
}, onNodeEnter:function(nodeData, source, e, data) {
}, onNodeOver:function(nodeData, source, e, data) {
  return this.dropAllowed;
}, onNodeOut:function(nodeData, source, e, data) {
}, onNodeDrop:function(nodeData, source, e, data) {
  return false;
}, onContainerOver:function(source, e, data) {
  return this.dropNotAllowed;
}, onContainerDrop:function(source, e, data) {
  return false;
}, notifyEnter:function(source, e, data) {
  Ext.dd.DropTarget.prototype.notifyEnter.call(this, source, e, data);
  return this.dropNotAllowed;
}, notifyOver:function(source, e, data) {
  var me = this, n = me.getTargetFromEvent(e);
  if (!n) {
    if (me.lastOverNode) {
      me.onNodeOut(me.lastOverNode, source, e, data);
      me.lastOverNode = null;
    }
    return me.onContainerOver(source, e, data);
  }
  if (me.lastOverNode !== n) {
    if (me.lastOverNode) {
      me.onNodeOut(me.lastOverNode, source, e, data);
    }
    me.onNodeEnter(n, source, e, data);
    me.lastOverNode = n;
  }
  return me.onNodeOver(n, source, e, data);
}, notifyOut:function(source, e, data) {
  Ext.dd.DropTarget.prototype.notifyOut.call(this, source, e, data);
  if (this.lastOverNode) {
    this.onNodeOut(this.lastOverNode, source, e, data);
    this.lastOverNode = null;
  }
}, notifyDrop:function(source, e, data) {
  var me = this, n = me.getTargetFromEvent(e), result = n ? me.onNodeDrop(n, source, e, data) : me.onContainerDrop(source, e, data);
  if (me.lastOverNode) {
    me.onNodeOut(me.lastOverNode, source, e, data);
    me.lastOverNode = null;
  }
  return result;
}, triggerCacheRefresh:function() {
  Ext.dd.DDM.refreshCache(this.groups);
}}, 0, 0, 0, 0, 0, 0, [Ext.dd, 'DropZone'], 0);
Ext.cmd.derive('Ext.event.publisher.MouseEnterLeave', Ext.event.publisher.Dom, {type:'mouseEnterLeave'}, 0, 0, 0, 0, 0, 0, [Ext.event.publisher, 'MouseEnterLeave'], function(MouseEnterLeave) {
  var eventMap = {mouseover:'mouseenter', mouseout:'mouseleave'};
  if (!Ext.supports.MouseEnterLeave) {
    MouseEnterLeave.override({handledDomEvents:['mouseover', 'mouseout'], handledEvents:['mouseenter', 'mouseleave'], publishDelegatedDomEvent:function(e) {
      var target, relatedTarget, id, el, type, event;
      this.callParent([e]);
      target = e.getTarget();
      relatedTarget = e.getRelatedTarget();
      if (relatedTarget && Ext.fly(target).contains(relatedTarget)) {
        return;
      }
      id = target.id;
      if (id) {
        el = Ext.cache[id];
        if (el) {
          type = eventMap[e.type];
          e = e.chain({type:type});
          if (el.hasListeners[type]) {
            event = el.events[type];
            if (event) {
              event = event.directs;
              if (event) {
                e.setCurrentTarget(el.dom);
                event.fire(e, e.target);
              }
            }
          }
        }
      }
    }});
  }
  MouseEnterLeave.instance = new MouseEnterLeave;
});
Ext.cmd.derive('Ext.form.action.Action', Ext.Base, {alternateClassName:'Ext.form.Action', submitEmptyText:true, constructor:function(config) {
  if (config) {
    Ext.apply(this, config);
  }
  var params = config.params;
  if (Ext.isString(params)) {
    this.params = Ext.Object.fromQueryString(params);
  }
}, run:Ext.emptyFn, onFailure:function(response) {
  var form = this.form, formActive = form && !form.destroying && !form.destroyed;
  this.response = response;
  this.failureType = Ext.form.action.Action.CONNECT_FAILURE;
  if (formActive) {
    form.afterAction(this, false);
  }
}, processResponse:function(response) {
  this.response = response;
  if (!response.responseText && !response.responseXML) {
    return true;
  }
  return this.result = this.handleResponse(response);
}, getUrl:function() {
  return this.url || this.form.url;
}, getMethod:function() {
  return (this.method || this.form.method || 'POST').toUpperCase();
}, getParams:function() {
  return Ext.apply({}, this.params, this.form.baseParams);
}, createCallback:function() {
  var me = this;
  return {success:me.onSuccess, failure:me.onFailure, scope:me, timeout:(me.timeout || me.form.timeout) * 1000};
}, statics:{CLIENT_INVALID:'client', SERVER_INVALID:'server', CONNECT_FAILURE:'connect', LOAD_FAILURE:'load'}}, 1, 0, 0, 0, 0, 0, [Ext.form.action, 'Action', Ext.form, 'Action'], 0);
Ext.cmd.derive('Ext.form.action.Load', Ext.form.action.Action, {alternateClassName:'Ext.form.Action.Load', type:'load', run:function() {
  Ext.Ajax.request(Ext.apply(this.createCallback(), {method:this.getMethod(), url:this.getUrl(), headers:this.headers, params:this.getParams()}));
}, onSuccess:function(response) {
  var result = this.processResponse(response), form = this.form, formActive = form && !form.destroying && !form.destroyed;
  if (result === true || !result.success || !result.data) {
    this.failureType = Ext.form.action.Action.LOAD_FAILURE;
    if (formActive) {
      form.afterAction(this, false);
    }
    return;
  }
  if (formActive) {
    form.clearInvalid();
    form.setValues(result.data);
    form.afterAction(this, true);
  }
}, handleResponse:function(response) {
  var reader = this.form.reader, rs, data;
  if (reader) {
    rs = reader.read(response);
    data = rs.records && rs.records[0] ? rs.records[0].data : null;
    return {success:rs.success, data:data};
  }
  return Ext.decode(response.responseText);
}}, 0, 0, 0, 0, ['formaction.load'], 0, [Ext.form.action, 'Load', Ext.form.Action, 'Load'], 0);
Ext.cmd.derive('Ext.form.action.Submit', Ext.form.action.Action, {alternateClassName:'Ext.form.Action.Submit', type:'submit', run:function() {
  var me = this, form = me.form;
  if (me.clientValidation === false || form.isValid()) {
    me.doSubmit();
  } else {
    me.failureType = Ext.form.action.Action.CLIENT_INVALID;
    form.afterAction(me, false);
  }
}, doSubmit:function() {
  var me = this, ajaxOptions = Ext.apply(me.createCallback(), {url:me.getUrl(), method:me.getMethod(), headers:me.headers}), form = me.form, jsonSubmit = me.jsonSubmit || form.jsonSubmit, paramsProp = jsonSubmit ? 'jsonData' : 'params', formInfo;
  if (form.hasUpload()) {
    formInfo = me.buildForm();
    ajaxOptions.form = formInfo.formEl;
    ajaxOptions.isUpload = true;
  } else {
    ajaxOptions[paramsProp] = me.getParams(jsonSubmit);
  }
  Ext.Ajax.request(ajaxOptions);
  if (formInfo) {
    me.cleanup(formInfo);
  }
}, cleanup:function(formInfo) {
  var formEl = formInfo.formEl, uploadEls = formInfo.uploadEls, uploadFields = formInfo.uploadFields, len = uploadFields.length, i, field;
  for (i = 0; i < len; ++i) {
    field = uploadFields[i];
    if (!field.clearOnSubmit) {
      field.restoreInput(uploadEls[i]);
    }
  }
  if (formEl) {
    Ext.removeNode(formEl);
  }
}, getParams:function(useModelValues) {
  var falseVal = false, configParams = Ext.form.action.Action.prototype.getParams.call(this), fieldParams = this.form.getValues(falseVal, falseVal, this.submitEmptyText !== falseVal, useModelValues, true);
  return Ext.apply({}, fieldParams, configParams);
}, buildForm:function() {
  var me = this, fieldsSpec = [], formSpec, formEl, basicForm = me.form, params = me.getParams(), uploadFields = [], uploadEls = [], fields = basicForm.getFields().items, i, len = fields.length, field, key, value, v, vLen, el;
  for (i = 0; i < len; ++i) {
    field = fields[i];
    if (field.isFileUpload()) {
      uploadFields.push(field);
    }
  }
  for (key in params) {
    if (params.hasOwnProperty(key)) {
      value = params[key];
      if (Ext.isArray(value)) {
        vLen = value.length;
        for (v = 0; v < vLen; v++) {
          fieldsSpec.push(me.getFieldConfig(key, value[v]));
        }
      } else {
        fieldsSpec.push(me.getFieldConfig(key, value));
      }
    }
  }
  formSpec = {tag:'form', role:'presentation', action:me.getUrl(), method:me.getMethod(), target:me.target ? Ext.isString(me.target) ? me.target : Ext.fly(me.target).dom.name : '_self', style:'display:none', cn:fieldsSpec};
  if (uploadFields.length) {
    formSpec.encoding = formSpec.enctype = 'multipart/form-data';
  }
  formEl = Ext.DomHelper.append(Ext.getBody(), formSpec);
  len = uploadFields.length;
  for (i = 0; i < len; ++i) {
    el = uploadFields[i].extractFileInput();
    formEl.appendChild(el);
    uploadEls.push(el);
  }
  return {formEl:formEl, uploadFields:uploadFields, uploadEls:uploadEls};
}, getFieldConfig:function(name, value) {
  return {tag:'input', type:'hidden', name:name, value:Ext.String.htmlEncode(value)};
}, onSuccess:function(response) {
  var form = this.form, formActive = form && !form.destroying && !form.destroyed, success = true, result = this.processResponse(response);
  if (result !== true && !result.success) {
    if (result.errors && formActive) {
      form.markInvalid(result.errors);
    }
    this.failureType = Ext.form.action.Action.SERVER_INVALID;
    success = false;
  }
  if (formActive) {
    form.afterAction(this, success);
  }
}, handleResponse:function(response) {
  var form = this.form, errorReader = form.errorReader, rs, errors, i, len, records, result;
  if (errorReader) {
    rs = errorReader.read(response);
    records = rs.records;
    errors = [];
    if (records) {
      for (i = 0, len = records.length; i < len; i++) {
        errors[i] = records[i].data;
      }
    }
    if (errors.length < 1) {
      errors = null;
    }
    result = {success:rs.success, errors:errors};
  } else {
    try {
      result = Ext.decode(response.responseText);
    } catch (e$38) {
      result = {success:false, errors:[]};
    }
  }
  return result;
}}, 0, 0, 0, 0, ['formaction.submit'], 0, [Ext.form.action, 'Submit', Ext.form.Action, 'Submit'], 0);
Ext.cmd.derive('Ext.form.action.StandardSubmit', Ext.form.action.Submit, {doSubmit:function() {
  var formInfo = this.buildForm();
  formInfo.formEl.submit();
  this.cleanup(formInfo);
}}, 0, 0, 0, 0, ['formaction.standardsubmit'], 0, [Ext.form.action, 'StandardSubmit'], 0);
Ext.cmd.derive('Ext.util.ComponentDragger', Ext.dd.DragTracker, {autoStart:500, constructor:function(comp, config) {
  this.comp = comp;
  this.initialConstrainTo = config.constrainTo;
  Ext.dd.DragTracker.prototype.constructor.call(this, config);
}, onStart:function(e) {
  var me = this, comp = me.comp;
  me.dragTarget = me.el;
  me.startRegion = me.el.getRegion();
  me.startPosition = comp.getXY();
  if (comp.ghost && !comp.liveDrag) {
    me.proxy = comp.ghost();
  }
  if (me.constrain || me.constrainDelegate) {
    me.constrainTo = me.calculateConstrainRegion();
  }
  if (comp.beginDrag) {
    comp.beginDrag();
  }
  Ext.dom.Element.maskIframes();
}, calculateConstrainRegion:function() {
  var me = this, comp = me.comp, constrainTo = me.initialConstrainTo || me.comp.el.dom.parentNode, constraintInsets = comp.constraintInsets, constrainEl, delegateRegion, elRegion, dragEl = me.proxy ? me.proxy.el : comp.el, shadow = dragEl.shadow, shadowSize = shadow && !me.constrainDelegate && comp.constrainShadow && !shadow.disabled ? shadow.getShadowSize() : 0;
  if (!(constrainTo instanceof Ext.util.Region)) {
    constrainEl = Ext.fly(constrainTo);
    constrainTo = constrainEl.getConstrainRegion();
  } else {
    constrainTo = constrainTo.copy();
  }
  if (constraintInsets) {
    constraintInsets = Ext.isObject(constraintInsets) ? constraintInsets : Ext.Element.parseBox(constraintInsets);
    constrainTo.adjust(constraintInsets.top, constraintInsets.right, constraintInsets.bottom, constraintInsets.left);
  }
  if (shadowSize) {
    constrainTo.adjust(shadowSize[0], -shadowSize[1], -shadowSize[2], shadowSize[3]);
  }
  if (me.constrainDelegate) {
    delegateRegion = Ext.fly(me.handle).getRegion();
    elRegion = dragEl.getRegion();
    constrainTo.adjust(elRegion.top - delegateRegion.top, elRegion.right - delegateRegion.right, elRegion.bottom - delegateRegion.bottom, elRegion.left - delegateRegion.left);
  }
  return constrainTo;
}, onDrag:function(e) {
  var me = this, comp = me.proxy && !me.comp.liveDrag ? me.proxy : me.comp, offset = me.getOffset(me.constrain || me.constrainDelegate ? 'dragTarget' : null);
  comp.setPagePosition(me.startPosition[0] + offset[0], me.startPosition[1] + offset[1]);
}, onEnd:function(e) {
  var comp = this.comp;
  if (comp.destroyed || comp.destroying) {
    return;
  }
  if (this.proxy && !comp.liveDrag) {
    comp.unghost();
  }
  if (comp.endDrag) {
    comp.endDrag();
  }
  Ext.dom.Element.unmaskIframes();
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'ComponentDragger'], 0);
Ext.cmd.derive('Ext.window.Window', Ext.panel.Panel, {alternateClassName:'Ext.Window', baseCls:'x-window', resizable:true, draggable:true, constrain:false, constrainHeader:false, plain:false, minimizable:false, maximizable:false, minHeight:50, minWidth:50, expandOnShow:true, collapsible:false, closable:true, hidden:true, autoRender:true, hideMode:'offsets', floating:true, alignOnScroll:false, itemCls:'x-window-item', overlapHeader:true, ignoreHeaderBorderManagement:true, alwaysFramed:true, isRootCfg:{isRoot:true}, 
isWindow:true, ariaRole:'dialog', focusable:true, tabGuard:true, closeToolText:'Close dialog', keyMap:{scope:'this', ESC:'onEsc'}, maskClickAction:'focus', disableCloseToolFocus:true, initComponent:function() {
  var me = this;
  me.frame = false;
  Ext.panel.Panel.prototype.initComponent.call(this);
  if (me.plain) {
    me.addClsWithUI('plain');
  }
  me.addStateEvents(['maximize', 'restore', 'resize', 'dragend']);
}, getElConfig:function() {
  var me = this, elConfig;
  elConfig = Ext.panel.Panel.prototype.getElConfig.call(this);
  elConfig.tabIndex = -1;
  return elConfig;
}, getFocusEl:function() {
  return this.getDefaultFocus() || this.el;
}, getState:function() {
  var me = this, state = Ext.panel.Panel.prototype.getState.call(this) || {}, maximized = !!me.maximized, ghostBox = me.ghostBox, pos;
  state.maximized = maximized;
  if (maximized) {
    pos = me.restorePos;
  } else {
    if (ghostBox) {
      pos = [ghostBox.x, ghostBox.y];
    } else {
      pos = me.getPosition(true);
    }
  }
  Ext.apply(state, {size:maximized ? me.restoreSize : me.getSize(), pos:pos});
  return state;
}, applyState:function(state) {
  var me = this;
  if (state) {
    me.maximized = state.maximized;
    if (me.maximized) {
      me.hasSavedRestore = true;
      me.restoreSize = state.size;
      me.restorePos = state.pos;
    } else {
      Ext.apply(me, {width:state.size.width, height:state.size.height, x:state.pos[0], y:state.pos[1]});
    }
  }
}, onRender:function(ct, position) {
  var me = this;
  Ext.panel.Panel.prototype.onRender.apply(this, arguments);
  if (me.header) {
    me.header.on({scope:me, click:me.onHeaderClick});
  }
  if (me.maximizable) {
    me.header.on({scope:me, dblclick:me.toggleMaximize});
  }
}, afterRender:function() {
  var me = this, header = me.header;
  if (me.maximized) {
    me.maximized = false;
    me.maximize(null, true);
    if (header) {
      header.removeCls(header.indicateDragCls);
    }
  }
  Ext.panel.Panel.prototype.afterRender.call(this);
  me.initTabGuards();
}, onEsc:function(e) {
  if (this.closable) {
    e.stopEvent();
    this.close();
    return false;
  }
}, doDestroy:function() {
  var me = this;
  if (me.rendered) {
    Ext.un('resize', me.onWindowResize, me);
    delete me.animateTarget;
    me.hide();
  }
  Ext.panel.Panel.prototype.doDestroy.call(this);
}, addTools:function() {
  var me = this, tools = [];
  Ext.panel.Panel.prototype.addTools.call(this);
  if (me.minimizable) {
    tools.push({type:'minimize', handler:'minimize', scope:me});
  }
  if (me.maximizable) {
    tools.push({type:'maximize', handler:'toggleMaximize', scope:me});
  }
  if (tools.length) {
    me.addTool(tools);
  }
}, addTool:function(tools) {
  var me = this;
  Ext.panel.Panel.prototype.addTool.call(this, tools);
  if (me.rendered && me.tabGuard) {
    me.initTabGuards();
  }
}, add:function() {
  var me = this, ret;
  ret = Ext.panel.Panel.prototype.add.apply(this, arguments);
  if (me.rendered && me.tabGuard) {
    me.initTabGuards();
  }
  return ret;
}, remove:function() {
  var me = this, ret;
  ret = Ext.panel.Panel.prototype.remove.apply(this, arguments);
  if (me.rendered && me.tabGuard) {
    me.initTabGuards();
  }
  return ret;
}, addDocked:function() {
  var me = this, ret;
  ret = Ext.panel.Panel.prototype.addDocked.apply(this, arguments);
  if (me.rendered && me.tabGuard) {
    me.initTabGuards();
  }
  return ret;
}, removeDocked:function() {
  var me = this, ret;
  ret = Ext.panel.Panel.prototype.removeDocked.apply(this, arguments);
  if (me.rendered && me.tabGuard) {
    me.initTabGuards();
  }
  return ret;
}, onShow:function() {
  var me = this;
  Ext.panel.Panel.prototype.onShow.apply(this, arguments);
  if (me.expandOnShow) {
    me.expand(false);
  }
  me.syncMonitorWindowResize();
  if (me.rendered && me.tabGuard) {
    me.initTabGuards();
  }
}, doClose:function() {
  var me = this;
  if (me.hidden) {
    me.fireEvent('close', me);
    if (me.closeAction === 'destroy' && !me.destroying && !me.destroyed) {
      me.destroy();
    }
  } else {
    me.hide(me.animateTarget, me.doClose, me);
  }
}, afterHide:function() {
  var me = this;
  me.syncMonitorWindowResize();
  Ext.panel.Panel.prototype.afterHide.apply(this, arguments);
  if (!me.destroyed && me.rendered && me.tabGuard) {
    me.initTabGuards();
  }
}, onWindowResize:function() {
  var me = this, sizeModel;
  if (!me.destroyed) {
    if (me.maximized) {
      me.fitContainer();
    } else {
      sizeModel = me.getSizeModel();
      if (sizeModel.width.natural || sizeModel.height.natural) {
        me.updateLayout();
      }
      me.doConstrain();
    }
  }
}, minimize:function() {
  this.fireEvent('minimize', this);
  return this;
}, resumeHeaderLayout:function(changed) {
  this.header.resumeLayouts(changed ? this.isRootCfg : null);
}, afterCollapse:function() {
  var me = this, header = me.header, tools = me.tools;
  if (header && me.maximizable) {
    header.suspendLayouts();
    tools.maximize.hide();
    this.resumeHeaderLayout(true);
  }
  if (me.resizer) {
    me.resizer.disable();
  }
  Ext.panel.Panel.prototype.afterCollapse.apply(this, arguments);
}, afterExpand:function() {
  var me = this, header = me.header, tools = me.tools, changed;
  if (header) {
    header.suspendLayouts();
    if (me.maximizable) {
      tools.maximize.show();
      changed = true;
    }
    this.resumeHeaderLayout(changed);
  }
  if (me.resizer) {
    me.resizer.enable();
  }
  Ext.panel.Panel.prototype.afterExpand.apply(this, arguments);
}, maximize:function(animate, initial) {
  var me = this, header = me.header, tools = me.tools, width = me.width, height = me.height, restore, changed;
  if (!me.maximized && !me.maximizing) {
    me.maximizing = true;
    me.expand(false);
    if (!me.hasSavedRestore) {
      restore = me.restoreSize = {width:width ? width : null, height:height ? height : null};
      if (initial) {
        me.restorePos = [me.x || 0, me.y || 0];
      } else {
        me.restorePos = me.getPosition();
      }
    }
    if (header) {
      header.suspendLayouts();
      if (tools.maximize) {
        tools.maximize.setType('restore');
      }
      if (me.collapseTool) {
        me.collapseTool.hide();
        changed = true;
      }
      me.resumeHeaderLayout(changed);
    }
    me.el.disableShadow();
    if (me.dd) {
      me.dd.disable();
      if (header) {
        header.removeCls(header.indicateDragCls);
      }
    }
    if (me.resizer) {
      me.resizer.disable();
    }
    me.el.addCls('x-window-maximized');
    me.container.addCls('x-window-maximized-ct');
    me.syncMonitorWindowResize();
    me.fitContainer(animate = animate || !!me.animateTarget ? {callback:function() {
      me.maximizing = false;
      me.maximized = true;
      if (!initial) {
        me.fireEvent('maximize', me);
      }
    }} : null);
    if (!animate) {
      me.maximizing = false;
      me.maximized = true;
      if (!initial) {
        me.fireEvent('maximize', me);
      }
    }
  }
  return me;
}, restore:function(animate) {
  var me = this, tools = me.tools, header = me.header, newBox = me.restoreSize, changed;
  if (me.maximized) {
    me.hasSavedRestore = null;
    me.removeCls('x-window-maximized');
    if (header) {
      header.suspendLayouts();
      if (tools.maximize) {
        tools.maximize.setType('maximize');
      }
      if (me.collapseTool) {
        me.collapseTool.show();
        changed = true;
      }
      me.resumeHeaderLayout(changed);
    }
    newBox.x = me.restorePos[0];
    newBox.y = me.restorePos[1];
    me.setBox(newBox, animate = animate || !!me.animateTarget ? {callback:function() {
      me.el.enableShadow(null, true);
      me.maximized = false;
      me.fireEvent('restore', me);
    }} : null);
    me.restorePos = me.restoreSize = null;
    if (me.dd) {
      me.dd.enable();
      if (header) {
        header.addCls(header.indicateDragCls);
      }
    }
    if (me.resizer) {
      me.resizer.enable();
    }
    me.container.removeCls('x-window-maximized-ct');
    me.syncMonitorWindowResize();
    if (!animate) {
      me.el.enableShadow(null, true);
      me.maximized = false;
      me.fireEvent('restore', me);
    }
  }
  return me;
}, syncMonitorWindowResize:function() {
  var me = this, currentlyMonitoring = me._monitoringResize, yes = me.monitorResize || me.constrain || me.constrainHeader || me.maximized, veto = me.hidden || me.destroying || me.destroyed;
  if (yes && !veto) {
    if (!currentlyMonitoring) {
      Ext.on('resize', me.onWindowResize, me, {buffer:1});
      me._monitoringResize = true;
    }
  } else {
    if (currentlyMonitoring) {
      Ext.un('resize', me.onWindowResize, me);
      me._monitoringResize = false;
    }
  }
}, toggleMaximize:function() {
  return this[this.maximized ? 'restore' : 'maximize']();
}, createGhost:function() {
  var ghost = Ext.panel.Panel.prototype.createGhost.apply(this, arguments);
  ghost.xtype = 'window';
  ghost.focusOnToFront = false;
  return ghost;
}, getDefaultFocus:function() {
  var me = this, result, defaultComp = me.defaultFocus, selector;
  if (defaultComp !== undefined) {
    if (Ext.isNumber(defaultComp)) {
      result = me.query('button')[defaultComp];
    } else {
      if (Ext.isString(defaultComp)) {
        selector = defaultComp;
        if (Ext.validIdRe.test(selector)) {
          result = me.down(Ext.makeIdSelector(selector));
        }
        if (!result) {
          result = me.down(selector);
        }
      } else {
        if (defaultComp.focus) {
          result = defaultComp;
        }
      }
    }
  }
  return result;
}, privates:{initDraggable:function() {
  this.initSimpleDraggable();
}, onHeaderClick:function(header, e) {
  var delegate;
  if (header.el.contains(e.getTarget())) {
    delegate = this.getDefaultFocus();
    if (delegate) {
      delegate.focus();
    }
  }
}, initResizable:function(resizable) {
  var me = this;
  Ext.panel.Panel.prototype.initResizable.call(this, resizable);
  if (me.maximized || me.maximizing) {
    me.resizer.disable();
  }
}, initSimpleDraggable:function() {
  var me = this, dd;
  Ext.panel.Panel.prototype.initSimpleDraggable.call(this);
  dd = me.dd;
  if (dd && me.maximized || me.maximizing) {
    dd.disable();
  }
}, onTabGuardFocusEnter:function(e, target) {
  var me = this, el = me.el, beforeGuard = me.tabGuardBeforeEl, afterGuard = me.tabGuardAfterEl, from = e.relatedTarget, nodes, forward, nextFocus;
  nodes = el.findTabbableElements({skipSelf:true});
  if (nodes[0] === beforeGuard.dom) {
    nodes.shift();
  }
  if (nodes[nodes.length - 1] === afterGuard.dom) {
    nodes.pop();
  }
  if (nodes.length === 0) {
    nextFocus = el;
  } else {
    if (from === el.dom) {
      forward = target === beforeGuard.dom;
    } else {
      if (el.contains(from)) {
        forward = !!e.forwardTab;
      } else {
        forward = target === beforeGuard.dom;
      }
    }
  }
  nextFocus = nextFocus || (forward ? nodes[0] : nodes[nodes.length - 1]);
  if (nextFocus) {
    Ext.fly(nextFocus).focus(nodes.length === 1 ? 1 : 0);
  }
}}}, 0, ['window'], ['component', 'box', 'container', 'panel', 'window'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true}, ['widget.window'], 0, [Ext.window, 'Window', Ext, 'Window'], 0);
Ext.cmd.derive('Ext.form.Labelable', Ext.Mixin, {isLabelable:true, mixinConfig:{id:'labelable', on:{beforeRender:'beforeLabelRender', onRender:'onLabelRender'}}, config:{childEls:['labelEl', 'bodyEl', 'errorEl', 'errorWrapEl', 'ariaErrorEl', 'ariaStatusEl', 'ariaHelpEl', 'labelTextEl']}, labelableRenderTpl:['{beforeLabelTpl}', '\x3clabel id\x3d"{id}-labelEl" data-ref\x3d"labelEl" class\x3d"{labelCls} {labelCls}-{ui} {labelClsExtra} ', '{childElCls} {unselectableCls}" style\x3d"{labelStyle}"', '\x3ctpl if\x3d"inputId \x26\x26 !skipLabelForAttribute"\x3e for\x3d"{inputId}"\x3c/tpl\x3e', 
' {labelAttrTpl}\x3e', '\x3cspan class\x3d"{labelInnerCls} {labelInnerCls}-{ui}" style\x3d"{labelInnerStyle}"\x3e', '{beforeLabelTextTpl}', '\x3cspan id\x3d"{id}-labelTextEl" data-ref\x3d"labelTextEl" class\x3d"{labelTextCls}"\x3e', '\x3ctpl if\x3d"fieldLabel"\x3e{fieldLabel}', '\x3ctpl if\x3d"labelSeparator"\x3e{labelSeparator}\x3c/tpl\x3e', '\x3c/tpl\x3e', '\x3c/span\x3e', '{afterLabelTextTpl}', '\x3c/span\x3e', '\x3c/label\x3e', '{afterLabelTpl}', '\x3cdiv id\x3d"{id}-bodyEl" data-ref\x3d"bodyEl" role\x3d"presentation"', 
' class\x3d"{baseBodyCls} {baseBodyCls}-{ui}\x3ctpl if\x3d"fieldBodyCls"\x3e', ' {fieldBodyCls} {fieldBodyCls}-{ui}\x3c/tpl\x3e {growCls} {extraFieldBodyCls}"', '\x3ctpl if\x3d"bodyStyle"\x3e style\x3d"{bodyStyle}"\x3c/tpl\x3e\x3e', '{beforeBodyEl}', '{beforeSubTpl}', '{[values.$comp.getSubTplMarkup(values)]}', '{afterSubTpl}', '{afterBodyEl}', '\x3ctpl if\x3d"renderAriaElements"\x3e', '\x3ctpl if\x3d"ariaHelp"\x3e', '\x3cspan id\x3d"{id}-ariaHelpEl" data-ref\x3d"ariaHelpEl"', ' class\x3d"x-hidden-offsets"\x3e', 
'{ariaHelp}', '\x3c/span\x3e', '\x3c/tpl\x3e', '\x3cspan id\x3d"{id}-ariaStatusEl" data-ref\x3d"ariaStatusEl" aria-hidden\x3d"true"', ' class\x3d"x-hidden-offsets"\x3e', '{ariaStatus}', '\x3c/span\x3e', '\x3cspan id\x3d"{id}-ariaErrorEl" data-ref\x3d"ariaErrorEl" aria-hidden\x3d"true" aria-live\x3d"assertive"', ' class\x3d"x-hidden-clip"\x3e', '\x3c/span\x3e', '\x3c/tpl\x3e', '\x3c/div\x3e', '\x3ctpl if\x3d"renderError"\x3e', '\x3cdiv id\x3d"{id}-errorWrapEl" data-ref\x3d"errorWrapEl" class\x3d"{errorWrapCls} {errorWrapCls}-{ui}', 
' {errorWrapExtraCls}" style\x3d"{errorWrapStyle}"\x3e', '\x3cdiv role\x3d"presentation" id\x3d"{id}-errorEl" data-ref\x3d"errorEl" ', 'class\x3d"{errorMsgCls} {invalidMsgCls} {invalidMsgCls}-{ui}" ', 'data-anchorTarget\x3d"{tipAnchorTarget}"\x3e', '\x3c/div\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e', {disableFormats:true}], activeErrorsTpl:undefined, htmlActiveErrorsTpl:['\x3ctpl if\x3d"errors \x26\x26 errors.length"\x3e', '\x3cul class\x3d"{listCls}"\x3e', '\x3ctpl for\x3d"errors"\x3e\x3cli\x3e{.}\x3c/li\x3e\x3c/tpl\x3e', 
'\x3c/ul\x3e', '\x3c/tpl\x3e'], plaintextActiveErrorsTpl:['\x3ctpl if\x3d"errors \x26\x26 errors.length"\x3e', '\x3ctpl for\x3d"errors"\x3e\x3ctpl if\x3d"xindex \x26gt; 1"\x3e\n\x3c/tpl\x3e{.}\x3c/tpl\x3e', '\x3c/tpl\x3e'], ariaActiveErrorsTpl:['\x3ctpl if\x3d"errors \x26\x26 errors.length"\x3e', '\x3ctpl for\x3d"errors" between\x3d". "\x3e{.}\x3c/tpl\x3e', '\x3c/tpl\x3e'], isFieldLabelable:true, formItemCls:'x-form-item', labelCls:'x-form-item-label', topLabelCls:'x-form-item-label-top', rightLabelCls:'x-form-item-label-right', 
labelInnerCls:'x-form-item-label-inner', labelTextCls:'x-form-item-label-text', topLabelSideErrorCls:'x-form-item-label-top-side-error', errorMsgCls:'x-form-error-msg', errorWrapCls:'x-form-error-wrap', errorWrapSideCls:'x-form-error-wrap-side', errorWrapUnderCls:'x-form-error-wrap-under', errorWrapUnderSideLabelCls:'x-form-error-wrap-under-side-label', baseBodyCls:'x-form-item-body', invalidIconCls:'x-form-invalid-icon', invalidUnderCls:'x-form-invalid-under', noLabelCls:'x-form-item-no-label', 
fieldBodyCls:'', extraFieldBodyCls:'', invalidCls:'x-form-invalid', fieldLabel:undefined, labelAlign:'left', labelWidth:100, labelPad:5, labelSeparator:':', hideLabel:false, hideEmptyLabel:true, preventMark:false, autoFitErrors:true, msgTarget:'qtip', msgTargets:{qtip:1, title:1, under:1, side:1, none:1}, noWrap:true, ariaHelp:undefined, ariaErrorText:'Input error. {0}.', labelableInsertions:['beforeBodyEl', 'afterBodyEl', 'beforeLabelTpl', 'afterLabelTpl', 'beforeSubTpl', 'afterSubTpl', 'beforeLabelTextTpl', 
'afterLabelTextTpl', 'labelAttrTpl'], statics:{initTip:function() {
  var tip = this.tip, cfg, copy;
  if (tip) {
    return;
  }
  cfg = {id:'ext-form-error-tip', ui:'form-invalid'};
  if (Ext.supports.Touch) {
    cfg.dismissDelay = 0;
    cfg.anchor = 'top';
    cfg.showDelay = 0;
    cfg.showOnTap = true;
    cfg.listeners = {beforeshow:function() {
      this.minWidth = Ext.fly(this.activeTarget.el).getWidth();
    }};
  }
  tip = this.tip = Ext.create('Ext.tip.QuickTip', cfg);
  copy = Ext.apply({}, tip.tagConfig);
  copy.attribute = 'errorqtip';
  tip.setTagConfig(copy);
}, destroyTip:function() {
  this.tip = Ext.destroy(this.tip);
}}, initLabelable:function() {
  var me = this, padding = me.padding;
  if (padding) {
    me.padding = undefined;
    me.extraMargins = Ext.Element.parseBox(padding);
  }
  if (Ext.isIE8) {
    me.restoreDisplay = Ext.Function.createDelayed(me.doRestoreDisplay, 0, me);
  }
  if (!me.activeErrorsTpl) {
    if (me.msgTarget === 'title') {
      me.activeErrorsTpl = me.plaintextActiveErrorsTpl;
    } else {
      me.activeErrorsTpl = me.htmlActiveErrorsTpl;
    }
  }
  me.addCls([me.formItemCls, me.formItemCls + '-' + me.ui]);
  me.lastActiveError = '';
  me.enableBubble('errorchange');
}, trimLabelSeparator:function() {
  var me = this, separator = me.labelSeparator, label = me.fieldLabel || '', lastChar = label.substr(label.length - 1);
  return lastChar === separator ? label.slice(0, -1) : label;
}, getFieldLabel:function() {
  return this.trimLabelSeparator();
}, setFieldLabel:function(label) {
  label = label || '';
  var me = this, separator = me.labelSeparator, labelEl = me.labelEl, errorWrapEl = me.errorWrapEl, sideLabel = me.labelAlign !== 'top', noLabelCls = me.noLabelCls, errorWrapUnderSideLabelCls = me.errorWrapUnderSideLabelCls;
  me.fieldLabel = label;
  if (me.rendered) {
    if (Ext.isEmpty(label) && me.hideEmptyLabel) {
      me.addCls(noLabelCls);
      if (sideLabel && errorWrapEl) {
        errorWrapEl.removeCls(errorWrapUnderSideLabelCls);
      }
    } else {
      if (separator) {
        label = me.trimLabelSeparator() + separator;
      }
      me.labelTextEl.dom.innerHTML = label;
      me.removeCls(noLabelCls);
      if (sideLabel && errorWrapEl) {
        errorWrapEl.addCls(errorWrapUnderSideLabelCls);
      }
    }
    me.updateLayout();
  }
}, setHideLabel:function(hideLabel) {
  var me = this;
  if (hideLabel !== me.hideLabel) {
    me.hideLabel = hideLabel;
    if (me.rendered) {
      me[hideLabel ? 'addCls' : 'removeCls'](me.noLabelCls);
      me.updateLayout();
    }
  }
}, setHideEmptyLabel:function(hideEmptyLabel) {
  var me = this, hide;
  if (hideEmptyLabel !== me.hideEmptyLabel) {
    me.hideEmptyLabel = hideEmptyLabel;
    if (me.rendered && !me.hideLabel) {
      hide = hideEmptyLabel && !me.getFieldLabel();
      me[hide ? 'addCls' : 'removeCls'](me.noLabelCls);
      me.updateLayout();
    }
  }
}, getInsertionRenderData:function(data, names) {
  var i = names.length, name, value;
  while (i--) {
    name = names[i];
    value = this[name];
    if (value) {
      if (typeof value !== 'string') {
        if (!value.isTemplate) {
          value = Ext.XTemplate.getTpl(this, name);
        }
        value = value.apply(data);
      }
    }
    data[name] = value || '';
  }
  return data;
}, getLabelableRenderData:function() {
  var me = this, labelAlign = me.labelAlign, topLabel = labelAlign === 'top', rightLabel = labelAlign === 'right', sideError = me.msgTarget === 'side', underError = me.msgTarget === 'under', errorMsgCls = me.errorMsgCls, labelPad = me.labelPad, labelWidth = me.labelWidth, labelClsExtra = me.labelClsExtra || '', errorWrapExtraCls = sideError ? me.errorWrapSideCls : me.errorWrapUnderCls, labelStyle = '', labelInnerStyle = '', labelVisible = me.hasVisibleLabel(), autoFitErrors = me.autoFitErrors, defaultBodyWidth = 
  me.defaultBodyWidth, bodyStyle, data;
  if (topLabel) {
    labelClsExtra += ' ' + me.topLabelCls;
    if (labelPad) {
      labelInnerStyle = 'padding-bottom:' + labelPad + 'px;';
    }
    if (sideError && !autoFitErrors) {
      labelClsExtra += ' ' + me.topLabelSideErrorCls;
    }
  } else {
    if (rightLabel) {
      labelClsExtra += ' ' + me.rightLabelCls;
    }
    if (labelPad) {
      labelStyle += me.getHorizontalPaddingStyle() + labelPad + 'px;';
    }
    labelStyle += 'width:' + (labelWidth + (labelPad ? labelPad : 0)) + 'px;';
    labelInnerStyle = 'width:' + labelWidth + 'px';
  }
  if (labelVisible) {
    if (!topLabel && underError) {
      errorWrapExtraCls += ' ' + me.errorWrapUnderSideLabelCls;
    }
  }
  if (defaultBodyWidth) {
    bodyStyle = 'min-width:' + defaultBodyWidth + 'px;max-width:' + defaultBodyWidth + 'px;';
  }
  data = {id:me.id, inputId:me.getInputId(), labelCls:me.labelCls, labelClsExtra:labelClsExtra, labelStyle:labelStyle + (me.labelStyle || ''), labelInnerStyle:labelInnerStyle, labelInnerCls:me.labelInnerCls, labelTextCls:me.labelTextCls, skipLabelForAttribute:!!me.skipLabelForAttribute, unselectableCls:Ext.Element.unselectableCls, bodyStyle:bodyStyle, baseBodyCls:me.baseBodyCls, fieldBodyCls:me.fieldBodyCls, extraFieldBodyCls:me.extraFieldBodyCls, errorWrapCls:me.errorWrapCls, errorWrapExtraCls:errorWrapExtraCls, 
  renderError:sideError || underError, invalidMsgCls:sideError ? me.invalidIconCls : underError ? me.invalidUnderCls : '', errorMsgCls:errorMsgCls, growCls:me.grow ? me.growCls : '', tipAnchorTarget:me.id + '-inputEl', errorWrapStyle:sideError && !autoFitErrors ? 'visibility:hidden' : 'display:none', fieldLabel:me.getFieldLabel(), labelSeparator:me.labelSeparator, renderAriaElements:!!me.renderAriaElements, ariaStatus:''};
  if (me.ariaHelp) {
    data.ariaHelp = Ext.String.htmlEncode(me.ariaHelp);
  }
  me.getInsertionRenderData(data, me.labelableInsertions);
  return data;
}, getHorizontalPaddingStyle:function() {
  return 'padding-right:';
}, beforeLabelRender:function() {
  var me = this;
  me.setFieldDefaults(me.getInherited().fieldDefaults);
  if (me.ownerLayout) {
    me.addCls('x-' + me.ownerLayout.type + '-form-item');
  }
  if (!me.hasVisibleLabel()) {
    me.addCls(me.noLabelCls);
  }
}, onLabelRender:function() {
  var me = this, style = {}, ExtElement = Ext.Element, errorWrapEl = me.errorWrapEl, margins, side;
  if (errorWrapEl) {
    errorWrapEl.setVisibilityMode(me.msgTarget === 'side' && !me.autoFitErrors ? ExtElement.VISIBILITY : ExtElement.DISPLAY);
  }
  if (me.extraMargins) {
    margins = me.el.getMargin();
    for (side in margins) {
      if (margins.hasOwnProperty(side)) {
        style['margin-' + side] = margins[side] + me.extraMargins[side] + 'px';
      }
    }
    me.el.setStyle(style);
  }
}, hasVisibleLabel:function() {
  if (this.hideLabel) {
    return false;
  }
  return !(this.hideEmptyLabel && !this.getFieldLabel());
}, getSubTplMarkup:function() {
  return '';
}, getInputId:function() {
  return '';
}, getActiveError:function() {
  return this.activeError || '';
}, hasActiveError:function() {
  return !!this.getActiveError();
}, setActiveError:function(msg) {
  this.setActiveErrors(msg);
}, getActiveErrors:function() {
  return this.activeErrors || [];
}, setActiveErrors:function(errors) {
  var me = this, errorWrapEl = me.errorWrapEl, msgTarget = me.msgTarget, isSide = msgTarget === 'side', isQtip = msgTarget === 'qtip', ariaErrorEl = me.ariaErrorEl, actionEl, activeError, tpl, targetEl, ariaTpl, errStr, errText;
  errors = Ext.Array.from(errors);
  tpl = me.lookupTpl('activeErrorsTpl');
  me.activeErrors = errors;
  activeError = me.activeError = tpl.apply({fieldLabel:me.fieldLabel, errors:errors, listCls:'x-list-plain'});
  me.renderActiveError();
  if (me.rendered) {
    actionEl = me.getActionEl();
    if (isSide) {
      me.errorEl.dom.setAttribute('data-errorqtip', activeError);
    } else {
      if (isQtip) {
        actionEl.dom.setAttribute('data-errorqtip', activeError);
      } else {
        if (msgTarget === 'title') {
          actionEl.dom.setAttribute('title', activeError);
        }
      }
    }
    if (msgTarget !== 'title' && ariaErrorEl) {
      ariaTpl = me.lookupTpl('ariaActiveErrorsTpl');
      errStr = ariaTpl.apply({errors:errors});
      errText = Ext.String.formatEncode(me.ariaErrorText, errStr, me.fieldLabel);
      if (ariaErrorEl.dom.innerHTML !== errText) {
        ariaErrorEl.dom.innerHTML = errText;
      }
      me.ariaStatusEl.dom.innerHTML = Ext.String.htmlEncode(errStr);
    }
    if (isSide || isQtip) {
      Ext.form.Labelable.initTip();
    }
    if (!me.msgTargets[msgTarget]) {
      targetEl = Ext.get(msgTarget);
      if (targetEl) {
        targetEl.dom.innerHTML = activeError;
      }
    }
  }
  if (errorWrapEl) {
    errorWrapEl.setVisible(errors.length > 0);
    if (isSide && me.autoFitErrors) {
      me.labelEl.addCls(me.topLabelSideErrorCls);
    }
    me.updateLayout();
  }
}, unsetActiveError:function() {
  var me = this, errorWrapEl = me.errorWrapEl, ariaErrorEl = me.ariaErrorEl, msgTarget = me.msgTarget, restoreDisplay = me.restoreDisplay, actionEl, targetEl;
  if (me.hasActiveError()) {
    delete me.activeError;
    delete me.activeErrors;
    me.renderActiveError();
    if (me.rendered) {
      actionEl = me.getActionEl();
      if (msgTarget === 'qtip') {
        actionEl.dom.removeAttribute('data-errorqtip');
      } else {
        if (msgTarget === 'title') {
          actionEl.dom.removeAttribute('title');
        }
      }
      if (msgTarget !== 'title' && ariaErrorEl) {
        ariaErrorEl.dom.innerHTML = me.ariaStatusEl.dom.innerHTML = '';
      }
      if (!me.msgTargets[msgTarget]) {
        targetEl = Ext.get(msgTarget);
        if (targetEl) {
          targetEl.dom.innerHTML = '';
        }
      }
      if (errorWrapEl) {
        errorWrapEl.hide();
        if (msgTarget === 'side' && me.autoFitErrors) {
          me.labelEl.removeCls(me.topLabelSideErrorCls);
        }
        me.updateLayout();
        if (restoreDisplay) {
          me.el.dom.style.display = 'block';
          me.restoreDisplay();
        }
      }
    }
  }
}, doRestoreDisplay:function() {
  var el = this.el;
  if (el && el.dom) {
    el.dom.style.display = '';
  }
}, renderActiveError:function() {
  var me = this, activeError = me.getActiveError(), hasError = !!activeError;
  if (activeError !== me.lastActiveError) {
    me.lastActiveError = activeError;
    me.fireEvent('errorchange', me, activeError);
  }
  if (me.rendered && !me.destroyed && !me.preventMark) {
    me.toggleInvalidCls(hasError);
    if (me.errorEl) {
      me.errorEl.dom.innerHTML = activeError;
    }
  }
}, toggleInvalidCls:function(hasError) {
  this.el[hasError ? 'addCls' : 'removeCls'](this.invalidCls);
}, setFieldDefaults:function(defaults) {
  var key;
  for (key in defaults) {
    if (!this.hasOwnProperty(key)) {
      this[key] = defaults[key];
    }
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.form, 'Labelable'], function() {
  if (Ext.supports.Touch) {
    this.prototype.msgTarget = 'side';
  }
});
Ext.cmd.derive('Ext.form.field.Field', Ext.Base, {mixinId:'field', isFormField:true, config:{validation:null, validationField:null}, disabled:false, submitValue:true, validateOnChange:true, valuePublishEvent:'change', suspendCheckChange:0, dirty:false, initField:function() {
  var me = this, valuePublishEvent = me.valuePublishEvent, len, i;
  me.initValue();
  if (Ext.isString(valuePublishEvent)) {
    me.on(valuePublishEvent, me.publishValue, me);
  } else {
    for (i = 0, len = valuePublishEvent.length; i < len; ++i) {
      me.on(valuePublishEvent[i], me.publishValue, me);
    }
  }
}, initValue:function() {
  var me = this;
  if ('value' in me) {
    me.suspendCheckChange++;
    me.setValue(me.value);
    me.suspendCheckChange--;
  }
  me.initialValue = me.originalValue = me.lastValue = me.getValue();
}, cleanupField:function() {
  delete this._ownerRecord;
}, getFieldIdentifier:function() {
  return this.isEditorComponent ? this.dataIndex : this.name;
}, getName:function() {
  return this.name;
}, getValue:function() {
  return this.value;
}, setValue:function(value) {
  var me = this;
  me.value = value;
  me.checkChange();
  return me;
}, isEqual:function(value1, value2) {
  return String(value1) === String(value2);
}, isEqualAsString:function(value1, value2) {
  return String(Ext.valueFrom(value1, '')) === String(Ext.valueFrom(value2, ''));
}, getSubmitData:function() {
  var me = this, data = null;
  if (!me.disabled && me.submitValue) {
    data = {};
    data[me.getName()] = '' + me.getValue();
  }
  return data;
}, getModelData:function(includeEmptyText, isSubmitting) {
  var me = this, data = null;
  if (!me.disabled && (me.submitValue || !isSubmitting)) {
    data = {};
    data[me.getFieldIdentifier()] = me.getValue();
  }
  return data;
}, reset:function() {
  var me = this;
  me.beforeReset();
  me.setValue(me.originalValue);
  me.clearInvalid();
  delete me.wasValid;
}, beforeReset:Ext.emptyFn, resetOriginalValue:function() {
  this.originalValue = this.getValue();
  this.checkDirty();
}, checkChange:function() {
  var me = this, newVal, oldVal;
  if (!me.suspendCheckChange && !me.destroying && !me.destroyed) {
    newVal = me.getValue();
    oldVal = me.lastValue;
    if (me.didValueChange(newVal, oldVal)) {
      me.lastValue = newVal;
      me.fireEvent('change', me, newVal, oldVal);
      me.onChange(newVal, oldVal);
    }
  }
}, didValueChange:function(newVal, oldVal) {
  return !this.isEqual(newVal, oldVal);
}, onChange:function(newVal) {
  var me = this;
  if (me.validateOnChange) {
    me.validate();
  }
  me.checkDirty();
}, publishValue:function() {
  var me = this;
  if (me.rendered && !me.getErrors().length) {
    me.publishState('value', me.getValue());
  }
}, isDirty:function() {
  var me = this;
  return !me.disabled && !me.isEqual(me.getValue(), me.originalValue);
}, checkDirty:function() {
  var me = this, isDirty = me.isDirty();
  if (isDirty !== me.wasDirty) {
    me.dirty = isDirty;
    me.fireEvent('dirtychange', me, isDirty);
    me.onDirtyChange(isDirty);
    me.wasDirty = isDirty;
  }
}, onDirtyChange:Ext.emptyFn, getErrors:function(value) {
  var errors = [], validationField = this.getValidationField(), validation = this.getValidation(), result;
  if (validationField) {
    result = validationField.validate(value, null, null, this._ownerRecord);
    if (result !== true) {
      errors.push(result);
    }
  }
  if (validation && validation !== true) {
    errors.push(validation);
  }
  return errors;
}, isValid:function() {
  var me = this;
  return me.disabled || Ext.isEmpty(me.getErrors());
}, validate:function() {
  return this.checkValidityChange(this.isValid());
}, checkValidityChange:function(isValid) {
  var me = this;
  if (isValid !== me.wasValid) {
    me.wasValid = isValid;
    me.fireEvent('validitychange', me, isValid);
  }
  return isValid;
}, setValidationField:function(value, record) {
  (arguments.callee.$previous || Ext.Base.prototype.setValidationField).call(this, value);
  this._ownerRecord = record;
}, batchChanges:function(fn) {
  try {
    this.suspendCheckChange++;
    fn();
  } finally {
    this.suspendCheckChange--;
  }
  this.checkChange();
}, isFileUpload:function() {
  return false;
}, extractFileInput:function() {
  return null;
}, markInvalid:Ext.emptyFn, clearInvalid:Ext.emptyFn, updateValidation:function(validation, oldValidation) {
  if (oldValidation) {
    this.validate();
  }
}, privates:{resetToInitialValue:function() {
  var me = this, originalValue = me.originalValue;
  me.originalValue = me.initialValue;
  me.reset();
  me.originalValue = originalValue;
}}}, 0, 0, 0, 0, 0, 0, [Ext.form.field, 'Field'], 0);
Ext.cmd.derive('Ext.form.field.Base', Ext.Component, {alternateClassName:['Ext.form.Field', 'Ext.form.BaseField'], focusable:true, shrinkWrap:true, fieldSubTpl:['\x3cinput id\x3d"{id}" data-ref\x3d"inputEl" type\x3d"{type}" {inputAttrTpl}', ' size\x3d"1"', '\x3ctpl if\x3d"name"\x3e name\x3d"{name}"\x3c/tpl\x3e', '\x3ctpl if\x3d"value"\x3e value\x3d"{[Ext.util.Format.htmlEncode(values.value)]}"\x3c/tpl\x3e', '\x3ctpl if\x3d"placeholder"\x3e placeholder\x3d"{placeholder}"\x3c/tpl\x3e', '{%if (values.maxLength !\x3d\x3d undefined){%} maxlength\x3d"{maxLength}"{%}%}', 
'\x3ctpl if\x3d"readOnly"\x3e readonly\x3d"readonly"\x3c/tpl\x3e', '\x3ctpl if\x3d"disabled"\x3e disabled\x3d"disabled"\x3c/tpl\x3e', '\x3ctpl if\x3d"tabIdx !\x3d null"\x3e tabindex\x3d"{tabIdx}"\x3c/tpl\x3e', '\x3ctpl if\x3d"fieldStyle"\x3e style\x3d"{fieldStyle}"\x3c/tpl\x3e', '\x3ctpl if\x3d"ariaEl \x3d\x3d \'inputEl\'"\x3e', '\x3ctpl foreach\x3d"ariaElAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e', '\x3c/tpl\x3e', '\x3ctpl foreach\x3d"inputElAriaAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e', ' class\x3d"{fieldCls} {typeCls} {typeCls}-{ui} {editableCls} {inputCls} {fixCls}" autocomplete\x3d"off"/\x3e', 
{disableFormats:true}], defaultBindProperty:'value', autoEl:{role:'presentation'}, subTplInsertions:['inputAttrTpl'], childEls:['inputEl'], inputType:'text', isTextInput:true, invalidText:'The value in this field is invalid', fieldCls:'x-form-field', focusCls:'form-focus', dirtyCls:'x-form-dirty', checkChangeEvents:Ext.isIE && (!document.documentMode || document.documentMode <= 9) ? ['change', 'propertychange', 'keyup'] : ['change', 'input', 'textInput', 'keyup', 'dragdrop'], ignoreChangeRe:/data\-errorqtip|style\.|className/, 
checkChangeBuffer:50, liquidLayout:true, readOnly:false, readOnlyCls:'x-form-readonly', validateOnBlur:true, validateOnFocusLeave:false, hasFocus:false, baseCls:'x-field', fieldBodyCls:'x-field-body', webkitBorderBoxBugCls:'x-webkit-border-box-bug', maskOnDisable:false, stretchInputElFixed:true, ariaEl:'inputEl', focusEl:'inputEl', renderAriaElements:true, initComponent:function() {
  var me = this;
  Ext.Component.prototype.initComponent.call(this);
  me.subTplData = me.subTplData || {};
  me.initLabelable();
  me.initField();
  me.initDefaultName();
  if (me.validateOnFocusLeave) {
    me.validateOnBlur = false;
  }
  if (me.readOnly) {
    me.addCls(me.readOnlyCls);
  }
  me.addCls('x-form-type-' + me.inputType);
  if (me.format && me.formatText && !me.ariaHelp) {
    me.ariaHelp = Ext.String.format(me.formatText, me.format);
  }
}, initDefaultName:function() {
  var me = this;
  if (!me.name) {
    me.name = me.getInputId();
  }
}, getInputId:function() {
  return this.inputId || (this.inputId = this.id + '-inputEl');
}, getSubTplData:function(fieldData) {
  var me = this, id = me.id, type = me.inputType, inputId = me.getInputId(), inputCls = me.inputCls || '', fixCls = '', data, ariaAttr, inputElAttr;
  if (Ext.supports.WebKitInputTableBoxModelBug) {
    fixCls += me.webkitBorderBoxBugCls;
  }
  data = Ext.apply({ui:me.ui, id:inputId, cmpId:id, name:me.name || inputId, disabled:me.disabled, readOnly:me.readOnly, value:me.getRawValue(), type:type, fieldCls:me.fieldCls, fieldStyle:me.getFieldStyle(), childElCls:fieldData.childElCls, tabIdx:me.tabIndex, inputCls:inputCls, typeCls:'x-form-' + (me.isTextInput ? 'text' : type), fixCls:fixCls, ariaEl:me.ariaEl}, me.subTplData);
  if (me.ariaRole) {
    ariaAttr = {};
    if (!me.ariaStaticRoles[me.ariaRole]) {
      ariaAttr['aria-hidden'] = !!me.hidden;
      ariaAttr['aria-disabled'] = !!me.disabled;
      inputElAttr = {'aria-invalid':false, 'aria-readonly':!!me.readOnly};
      if (me.ariaLabel) {
        ariaAttr['aria-label'] = Ext.String.htmlEncode(me.ariaLabel);
      }
      ariaAttr = Ext.apply(ariaAttr, me.getAriaAttributes());
      if (!ariaAttr['aria-describedby']) {
        if (me.ariaHelp) {
          inputElAttr['aria-describedby'] = id + '-ariaStatusEl ' + id + '-ariaHelpEl';
        } else {
          inputElAttr['aria-describedby'] = id + '-ariaStatusEl';
        }
      }
      data.inputElAriaAttributes = inputElAttr;
    }
    if (me.ariaRole !== 'native') {
      ariaAttr.role = me.ariaRole;
    }
    if (me.ariaLabel) {
      ariaAttr['aria-label'] = me.ariaLabel;
    }
    if (me.format && me.formatText && !data.title) {
      ariaAttr.title = Ext.String.formatEncode(me.formatText, me.format);
    }
    data.ariaElAttributes = ariaAttr;
  }
  me.getInsertionRenderData(data, me.subTplInsertions);
  return data;
}, getSubTplMarkup:function(fieldData) {
  var me = this, data = me.getSubTplData(fieldData), preSubTpl = me.lookupTpl('preSubTpl'), postSubTpl = me.lookupTpl('postSubTpl'), markup = '';
  if (preSubTpl) {
    markup += preSubTpl.apply(data);
  }
  markup += me.lookupTpl('fieldSubTpl').apply(data);
  if (postSubTpl) {
    markup += postSubTpl.apply(data);
  }
  return markup;
}, initRenderData:function() {
  return Ext.applyIf(Ext.Component.prototype.initRenderData.call(this), this.getLabelableRenderData());
}, setFieldStyle:function(style) {
  var me = this, inputEl = me.inputEl;
  if (inputEl) {
    inputEl.applyStyles(style);
  }
  me.fieldStyle = style;
}, getFieldStyle:function() {
  var style = this.fieldStyle;
  return Ext.isObject(style) ? Ext.DomHelper.generateStyles(style, null, true) : style || '';
}, onRender:function() {
  this.callParent(arguments);
  this.mixins.labelable.self.initTip();
  this.renderActiveError();
}, beforeBlur:function(e) {
  if (this.validateOnBlur) {
    this.validate();
  }
}, onFocusLeave:function(e) {
  if (this.validateOnFocusLeave) {
    this.validate();
  }
  Ext.Component.prototype.onFocusLeave.call(this, e);
  this.completeEdit();
}, completeEdit:Ext.emptyFn, isFileUpload:function() {
  return this.inputType === 'file';
}, getSubmitData:function() {
  var me = this, data = null, val;
  if (!me.disabled && me.submitValue) {
    val = me.getSubmitValue();
    if (val !== null) {
      data = {};
      data[me.getName()] = val;
    }
  }
  return data;
}, getSubmitValue:function() {
  return this.processRawValue(this.getRawValue());
}, getRawValue:function() {
  var me = this, v = me.inputEl ? me.inputEl.getValue() : Ext.valueFrom(me.rawValue, '');
  me.rawValue = v;
  return v;
}, setRawValue:function(value) {
  var me = this, rawValue = me.rawValue;
  if (!me.transformRawValue.$nullFn) {
    value = me.transformRawValue(value);
  }
  value = Ext.valueFrom(value, '');
  if (rawValue === undefined || rawValue !== value) {
    me.rawValue = value;
    if (me.inputEl) {
      me.bindChangeEvents(false);
      me.inputEl.dom.value = value;
      me.bindChangeEvents(true);
    }
  }
  if (me.rendered && me.reference) {
    me.publishState('rawValue', value);
  }
  return value;
}, transformRawValue:Ext.identityFn, valueToRaw:function(value) {
  return '' + Ext.valueFrom(value, '');
}, rawToValue:Ext.identityFn, processRawValue:Ext.identityFn, getValue:function() {
  var me = this, val = me.rawToValue(me.processRawValue(me.getRawValue()));
  me.value = val;
  return val;
}, setValue:function(value) {
  var me = this;
  me.setRawValue(me.valueToRaw(value));
  return me.mixins.field.setValue.call(me, value);
}, onBoxReady:function() {
  var me = this;
  Ext.Component.prototype.onBoxReady.apply(this, arguments);
  if (me.setReadOnlyOnBoxReady) {
    me.setReadOnly(me.readOnly);
  }
}, onDisable:function() {
  var me = this, inputEl = me.inputEl;
  Ext.Component.prototype.onDisable.call(this);
  if (inputEl) {
    inputEl.dom.disabled = true;
    if (me.hasActiveError()) {
      me.clearInvalid();
      me.hadErrorOnDisable = true;
    }
  }
  if (me.wasValid === false) {
    me.checkValidityChange(true);
  }
}, onEnable:function() {
  var me = this, inputEl = me.inputEl, mark = me.preventMark, valid;
  Ext.Component.prototype.onEnable.call(this);
  if (inputEl) {
    inputEl.dom.disabled = false;
  }
  if (me.wasValid !== undefined) {
    me.forceValidation = true;
    me.preventMark = !me.hadErrorOnDisable;
    valid = me.isValid();
    me.forceValidation = false;
    me.preventMark = mark;
    me.checkValidityChange(valid);
  }
  delete me.hadErrorOnDisable;
}, setReadOnly:function(readOnly) {
  var me = this, inputEl = me.inputEl, old = me.readOnly;
  readOnly = !!readOnly;
  me[readOnly ? 'addCls' : 'removeCls'](me.readOnlyCls);
  me.readOnly = readOnly;
  if (inputEl) {
    inputEl.dom.readOnly = readOnly;
    inputEl.dom.setAttribute('aria-readonly', readOnly);
  } else {
    if (me.rendering) {
      me.setReadOnlyOnBoxReady = true;
    }
  }
  if (readOnly !== old) {
    me.fireEvent('writeablechange', me, readOnly);
  }
}, fireKey:function(e, eOpts) {
  if (e.isSpecialKey()) {
    this.fireEvent('specialkey', this, e, eOpts);
  }
}, initEvents:function() {
  var me = this, inputEl = me.inputEl, onFieldMutation = me.onFieldMutation, events = me.checkChangeEvents, len = events.length, i, event;
  if (inputEl) {
    me.mon(inputEl, Ext.supports.SpecialKeyDownRepeat ? 'keydown' : 'keypress', me.fireKey, me);
    for (i = 0; i < len; ++i) {
      event = events[i];
      if (event === 'propertychange') {
        me.usesPropertychange = true;
      }
      if (event === 'textInput') {
        me.usesTextInput = true;
      }
      me.mon(inputEl, event, onFieldMutation, me);
    }
  }
  Ext.Component.prototype.initEvents.call(this);
}, onFieldMutation:function(e) {
  if (!this.readOnly && !(e.type === 'propertychange' && this.ignoreChangeRe.test(e.browserEvent.propertyName))) {
    this.startCheckChangeTask();
  }
}, startCheckChangeTask:function() {
  var me = this, task = me.checkChangeTask;
  if (!task) {
    me.checkChangeTask = task = new Ext.util.DelayedTask(me.doCheckChangeTask, me);
  }
  if (!me.bindNotifyListener) {
    me.bindNotifyListener = Ext.on('beforebindnotify', me.onBeforeNotify, me, {destroyable:true});
  }
  task.delay(me.checkChangeBuffer);
}, doCheckChangeTask:function() {
  var bindNotifyListener = this.bindNotifyListener;
  if (bindNotifyListener) {
    bindNotifyListener.destroy();
    this.bindNotifyListener = null;
  }
  this.checkChange();
}, publishValue:function() {
  var me = this;
  if (me.rendered && !me.getErrors().length) {
    me.publishState('value', me.getValue());
  }
}, onDirtyChange:function(isDirty) {
  var me = this;
  me[isDirty ? 'addCls' : 'removeCls'](me.dirtyCls);
  if (me.rendered && me.reference) {
    me.publishState('dirty', isDirty);
  }
}, isValid:function() {
  var me = this, disabled = me.disabled, validate = me.forceValidation || !disabled;
  return validate ? me.validateValue(me.processRawValue(me.getRawValue())) : disabled;
}, validateValue:function(value) {
  var me = this, errors = me.getErrors(value), isValid = Ext.isEmpty(errors);
  if (!me.preventMark) {
    if (isValid) {
      me.clearInvalid();
    } else {
      me.markInvalid(errors);
    }
  }
  return isValid;
}, markInvalid:function(errors) {
  var me = this, oldMsg = me.getActiveError(), active;
  me.setActiveErrors(Ext.Array.from(errors));
  active = me.getActiveError();
  if (oldMsg !== active) {
    me.setError(active);
    if (!me.ariaStaticRoles[me.ariaRole] && me.inputEl) {
      me.inputEl.dom.setAttribute('aria-invalid', true);
    }
  }
}, clearInvalid:function() {
  var me = this, hadError = me.hasActiveError();
  delete me.hadErrorOnDisable;
  me.unsetActiveError();
  if (hadError) {
    me.setError('');
    if (!me.ariaStaticRoles[me.ariaRole] && me.inputEl) {
      me.inputEl.dom.setAttribute('aria-invalid', false);
    }
  }
}, setError:function(error) {
  var me = this, msgTarget = me.msgTarget, prop;
  if (me.rendered) {
    if (msgTarget === 'title' || msgTarget === 'qtip') {
      prop = msgTarget === 'qtip' ? 'data-errorqtip' : 'title';
      me.getActionEl().dom.setAttribute(prop, error || '');
    } else {
      me.updateLayout();
    }
  }
}, renderActiveError:function() {
  var me = this, hasError = me.hasActiveError(), invalidCls = me.invalidCls + '-field';
  if (me.inputEl) {
    me.inputEl[hasError ? 'addCls' : 'removeCls']([invalidCls, invalidCls + '-' + me.ui]);
  }
  me.mixins.labelable.renderActiveError.call(me);
}, doDestroy:function() {
  var me = this, task = me.checkChangeTask;
  if (task) {
    task.cancel();
  }
  Ext.destroy(me.bindNotifyListener);
  me.cleanupField();
  Ext.Component.prototype.doDestroy.call(this);
}, privates:{applyBind:function(bind, currentBindings) {
  var me = this, valueBinding = currentBindings && currentBindings.value, bindings, newValueBind;
  bindings = Ext.Component.prototype.applyBind.call(this, bind, currentBindings);
  if (bindings) {
    newValueBind = bindings.value;
    me.hasBindingValue = !!newValueBind;
    if (newValueBind !== valueBinding && me.getInherited().modelValidation) {
      me.updateValueBinding(bindings);
    }
  }
  return bindings;
}, applyRenderSelectors:function() {
  var me = this;
  Ext.Component.prototype.applyRenderSelectors.call(this);
  if (!me.inputEl) {
    me.inputEl = me.el.getById(me.getInputId());
  }
}, bindChangeEvents:function(active) {
  var method = active ? 'resumeEvent' : 'suspendEvent', inputEl = this.inputEl;
  if (this.usesPropertychange) {
    inputEl[method]('propertychange');
  }
  if (this.usesTextInput) {
    inputEl[method]('textInput');
  }
}, getActionEl:function() {
  return this.inputEl || this.el;
}, getFocusEl:function() {
  return this.inputEl;
}, initRenderTpl:function() {
  var me = this;
  if (!me.hasOwnProperty('renderTpl')) {
    me.renderTpl = me.lookupTpl('labelableRenderTpl');
  }
  return Ext.Component.prototype.initRenderTpl.call(this);
}, onBeforeNotify:function() {
  this.checkChangeTask.cancel();
  this.checkChange();
}, updateValueBinding:function(bindings) {
  var me = this, newBinding = bindings.value, fieldBinding = bindings.$fieldBinding;
  if (fieldBinding) {
    fieldBinding.destroy();
    bindings.$fieldBinding = null;
  }
  if (newBinding && newBinding.bindValidationField) {
    me.fieldBinding = newBinding.bindValidationField('setValidationField', me);
  }
}}, deprecated:{5:{methods:{doComponentLayout:function() {
  this.bindChangeEvents(false);
  this.callParent(arguments);
  this.bindChangeEvents(true);
}}}}}, 0, ['field'], ['component', 'box', 'field'], {'component':true, 'box':true, 'field':true}, ['widget.field'], [[Ext.form.Labelable.prototype.mixinId || Ext.form.Labelable.$className, Ext.form.Labelable], [Ext.form.field.Field.prototype.mixinId || Ext.form.field.Field.$className, Ext.form.field.Field]], [Ext.form.field, 'Base', Ext.form, 'Field', Ext.form, 'BaseField'], 0);
Ext.cmd.derive('Ext.layout.component.field.Text', Ext.layout.component.Auto, {beginLayoutCycle:function(ownerContext, firstCycle) {
  var target = ownerContext.target;
  ownerContext.el.toggleCls(target.heightedCls, !ownerContext.heightModel.shrinkWrap || target.minHeight != null);
  Ext.layout.component.Auto.prototype.beginLayoutCycle.call(this, ownerContext, firstCycle);
}}, 0, 0, 0, 0, ['layout.textfield'], 0, [Ext.layout.component.field, 'Text'], 0);
Ext.cmd.derive('Ext.form.field.VTypes', Ext.Base, function() {
  var alpha = /^[a-zA-Z_]+$/, alphanum = /^[a-zA-Z0-9_]+$/, email = /^(")?(?:[^\."\s])(?:(?:[\.])?(?:[\w\-!#$%&'*+/=?^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/, url = /(((^https?)|(^ftp)):\/\/((([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*)|(localhost|LOCALHOST))\/?)/i;
  return {singleton:true, alternateClassName:'Ext.form.VTypes', email:function(value) {
    return email.test(value);
  }, emailText:'This field should be an e-mail address in the format "user@example.com"', emailMask:/[\w.\-@'"!#$%&'*+/=?^_`{|}~]/i, url:function(value) {
    return url.test(value);
  }, urlText:'This field should be a URL in the format "http://www.example.com"', alpha:function(value) {
    return alpha.test(value);
  }, alphaText:'This field should only contain letters and _', alphaMask:/[a-z_]/i, alphanum:function(value) {
    return alphanum.test(value);
  }, alphanumText:'This field should only contain letters, numbers and _', alphanumMask:/[a-z0-9_]/i};
}, 0, 0, 0, 0, 0, 0, [Ext.form.field, 'VTypes', Ext.form, 'VTypes'], 0);
Ext.cmd.derive('Ext.form.trigger.Trigger', Ext.Base, {factoryConfig:{defaultType:'trigger'}, repeatClick:false, hidden:false, hideOnReadOnly:undefined, tooltip:null, weight:0, preventMouseDown:true, focusOnMousedown:false, baseCls:'x-form-trigger', focusCls:'x-form-trigger-focus', overCls:'x-form-trigger-over', clickCls:'x-form-trigger-click', validIdRe:Ext.validIdRe, renderTpl:['\x3cdiv id\x3d"{triggerId}" class\x3d"{baseCls} {baseCls}-{ui} {cls} {cls}-{ui} {extraCls} ', '{childElCls}"\x3ctpl if\x3d"triggerStyle"\x3e style\x3d"{triggerStyle}"\x3c/tpl\x3e', 
'\x3ctpl if\x3d"ariaRole"\x3e role\x3d"{ariaRole}"\x3ctpl else\x3e role\x3d"presentation"\x3c/tpl\x3e', '\x3e', '{[values.$trigger.renderBody(values)]}', '\x3c/div\x3e'], constructor:function(config) {
  var me = this, cls;
  Ext.apply(me, config);
  if (me.compat4Mode) {
    cls = me.cls;
    me.focusCls = [me.focusCls, cls + '-focus'];
    me.overCls = [me.overCls, cls + '-over'];
    me.clickCls = [me.clickCls, cls + '-click'];
  }
}, afterFieldRender:function() {
  var me = this, tip = me.tooltip;
  me.initEvents();
  if (tip) {
    me.tooltip = null;
    me.setTooltip(tip);
  }
}, destroy:function() {
  var me = this;
  me.clickRepeater = me.el = Ext.destroy(me.clickRepeater, me.el);
  me.callParent();
}, getBodyRenderData:Ext.emptyFn, getEl:function() {
  return this.el || null;
}, getStateEl:function() {
  return this.el;
}, hide:function() {
  var me = this, el = me.el;
  me.hidden = true;
  if (el) {
    el.hide();
  }
}, initEvents:function() {
  var me = this, isFieldEnabled = me.isFieldEnabled, stateEl = me.getStateEl(), el = me.el;
  stateEl.addClsOnOver(me.overCls, isFieldEnabled, me);
  stateEl.addClsOnClick(me.clickCls, isFieldEnabled, me);
  if (me.repeatClick) {
    me.clickRepeater = new Ext.util.ClickRepeater(el, {preventDefault:true, handler:me.onClick, listeners:{mousedown:me.onClickRepeaterMouseDown, mouseup:me.onClickRepeaterMouseUp, scope:me}, scope:me});
  } else {
    me.field.mon(el, {click:me.onClick, mousedown:me.onMouseDown, scope:me});
  }
}, isFieldEnabled:function() {
  return !this.field.disabled;
}, isVisible:function() {
  var me = this, field = me.field, hidden = false;
  if (me.hidden || !field || !me.rendered || me.destroyed) {
    hidden = true;
  }
  return !hidden;
}, onClick:function() {
  var me = this, args = arguments, e = me.clickRepeater ? args[1] : args[0], handler = me.handler, field = me.field;
  if (handler && !field.readOnly && me.isFieldEnabled()) {
    Ext.callback(me.handler, me.scope, [field, me, e], 0, field);
  }
}, resolveListenerScope:function(scope) {
  return this.field.resolveSatelliteListenerScope(this, scope);
}, onMouseDown:function(e) {
  if (e.pointerType !== 'touch' && (!this.field.containsFocus || this.focusOnMousedown)) {
    this.field.focus();
  }
  if (this.preventMouseDown) {
    e.preventDefault();
  }
}, onClickRepeaterMouseDown:function(clickRepeater, e) {
  if (!e.parentEvent || e.parentEvent.type === 'mousedown') {
    this.field.inputEl.focus();
  }
  e.preventDefault();
}, onClickRepeaterMouseUp:function(clickRepeater, e) {
  var me = this, field = me.field;
  Ext.callback(me.endHandler, me.scope, [field, me, e], 0, field);
}, onFieldBlur:function() {
  this.getStateEl().removeCls(this.focusCls);
}, onFieldFocus:function() {
  this.getStateEl().addCls(this.focusCls);
}, onFieldRender:function() {
  var me = this, el = me.el = me.field.triggerWrap.selectNode('#' + me.domId, false);
  el.setVisibilityMode(Ext.Element.DISPLAY);
  me.rendered = true;
}, renderBody:function(renderData) {
  var me = this, bodyTpl = me.bodyTpl;
  Ext.apply(renderData, me.getBodyRenderData());
  return bodyTpl ? Ext.XTemplate.getTpl(me, 'bodyTpl').apply(renderData) : '';
}, renderTrigger:function(fieldData) {
  var me = this, width = me.width, triggerStyle = me.hidden ? 'display:none;' : '';
  if (width) {
    triggerStyle += 'width:' + width;
  }
  return Ext.XTemplate.getTpl(me, 'renderTpl').apply({$trigger:me, fieldData:fieldData, ui:fieldData.ui, childElCls:fieldData.childElCls, triggerId:me.domId = me.field.id + '-trigger-' + me.id, cls:me.cls, triggerStyle:triggerStyle, extraCls:me.extraCls, baseCls:me.baseCls, ariaRole:me.ariaRole});
}, setHidden:function(hidden) {
  if (hidden !== this.hidden) {
    this[hidden ? 'hide' : 'show']();
  }
}, setTooltip:function(tip) {
  var me = this, el = me.el, was = me.tooltip;
  if (tip !== was) {
    me.tooltip = tip;
    if (el) {
      el.dom.setAttribute('data-qtip', Ext.htmlEncode(tip));
    }
  }
}, setVisible:function(visible) {
  this.setHidden(!visible);
}, show:function() {
  var me = this, el = me.el;
  me.hidden = false;
  if (el) {
    el.show();
  }
}}, 1, 0, 0, 0, ['trigger.trigger'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.form.trigger, 'Trigger'], 0);
Ext.cmd.derive('Ext.form.field.Text', Ext.form.field.Base, {alternateClassName:['Ext.form.TextField', 'Ext.form.Text'], componentLayout:'textfield', config:{hideTrigger:false, autoHideInputMask:null, inputMask:null, triggers:undefined}, renderConfig:{editable:true}, growMin:30, growMax:800, allowBlank:true, validateBlank:false, allowOnlyWhitespace:true, minLength:0, maxLength:Number.MAX_VALUE, minLengthText:'The minimum length for this field is {0}', maxLengthText:'The maximum length for this field is {0}', 
blankText:'This field is required', regexText:'', emptyText:'', emptyCls:'x-form-empty-field', placeholderCoverCls:'x-placeholder-label', requiredCls:'x-form-required-field', ariaRole:'textbox', repeatTriggerClick:false, triggerWrapCls:'x-form-trigger-wrap', triggerWrapFocusCls:'x-form-trigger-wrap-focus', triggerWrapInvalidCls:'x-form-trigger-wrap-invalid', fieldBodyCls:'x-form-text-field-body', inputWrapCls:'x-form-text-wrap', inputWrapFocusCls:'x-form-text-wrap-focus', inputWrapInvalidCls:'x-form-text-wrap-invalid', 
growCls:'x-form-text-grow', heightedCls:'x-form-text-heighted', emptyClsElements:null, needArrowKeys:true, childEls:['triggerWrap', 'inputWrap', 'placeholderLabel'], preSubTpl:['\x3cdiv id\x3d"{cmpId}-triggerWrap" data-ref\x3d"triggerWrap"', '\x3ctpl if\x3d"ariaEl \x3d\x3d \'triggerWrap\'"\x3e', '\x3ctpl foreach\x3d"ariaElAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e', '\x3ctpl else\x3e', ' role\x3d"presentation"', '\x3c/tpl\x3e', ' class\x3d"{triggerWrapCls} {triggerWrapCls}-{ui}"\x3e', '\x3cdiv id\x3d{cmpId}-inputWrap data-ref\x3d"inputWrap"', 
' role\x3d"presentation" class\x3d"{inputWrapCls} {inputWrapCls}-{ui}"\x3e'], postSubTpl:['\x3ctpl if\x3d"!Ext.supports.Placeholder"\x3e', '\x3clabel id\x3d"{cmpId}-placeholderLabel" data-ref\x3d"placeholderLabel" for\x3d"{id}" class\x3d"{placeholderCoverCls} {placeholderCoverCls}-{ui}"\x3e{placeholder}\x3c/label\x3e', '\x3c/tpl\x3e', '\x3c/div\x3e', '\x3ctpl for\x3d"triggers"\x3e{[values.renderTrigger(parent)]}\x3c/tpl\x3e', '\x3c/div\x3e'], initComponent:function() {
  var me = this, emptyCls = me.emptyCls;
  if (me.allowOnlyWhitespace === false) {
    me.allowBlank = false;
  }
  if (me.grow) {
    me.liquidLayout = false;
  }
  if (me.size) {
    me.defaultBodyWidth = me.size * 6.5 + 20;
  }
  if (!me.onTrigger1Click) {
    me.onTrigger1Click = me.onTriggerClick;
  }
  Ext.form.field.Base.prototype.initComponent.call(this);
  if (me.readOnly) {
    me.setReadOnly(me.readOnly);
  }
  me.fieldFocusCls = me.baseCls + '-focus';
  me.emptyUICls = emptyCls + ' ' + emptyCls + '-' + me.ui;
  me.addStateEvents('change');
}, initEvents:function() {
  var me = this, el = me.inputEl;
  Ext.form.field.Base.prototype.initEvents.call(this);
  if (me.maskRe || me.vtype && me.disableKeyFilter !== true && (me.maskRe = Ext.form.field.VTypes[me.vtype + 'Mask'])) {
    me.mon(el, 'keypress', me.filterKeys, me);
  }
  if (me.enableKeyEvents) {
    me.mon(el, {scope:me, keyup:me.onKeyUp, keydown:me.onKeyDown, keypress:me.onKeyPress});
  }
}, isEqual:function(value1, value2) {
  return this.isEqualAsString(value1, value2);
}, onChange:function(newVal, oldVal) {
  Ext.form.field.Base.prototype.onChange.call(this, newVal, oldVal);
  this.autoSize();
}, getSubTplData:function(fieldData) {
  var me = this, value = me.getRawValue(), isEmpty = me.emptyText && value.length < 1, maxLength = me.maxLength, placeholder, data, inputElAttr;
  if (me.enforceMaxLength) {
    if (maxLength === Number.MAX_VALUE) {
      maxLength = undefined;
    }
  } else {
    maxLength = undefined;
  }
  if (me.emptyText) {
    placeholder = Ext.String.htmlEncode(me.emptyText);
  }
  data = Ext.apply(Ext.form.field.Base.prototype.getSubTplData.call(this, fieldData), {triggerWrapCls:me.triggerWrapCls, inputWrapCls:me.inputWrapCls, placeholderCoverCls:me.placeholderCoverCls, triggers:me.orderedTriggers, maxLength:maxLength, readOnly:!me.editable || me.readOnly, placeholder:placeholder, value:value, fieldCls:me.fieldCls + (me.allowBlank ? '' : ' ' + me.requiredCls) + (isEmpty ? ' ' + me.emptyUICls : '')});
  inputElAttr = data.inputElAriaAttributes;
  if (inputElAttr) {
    inputElAttr['aria-required'] = !me.allowBlank;
  }
  return data;
}, beforeRender:function() {
  var me = this, heighted = me.height != null || me.minHeight != null || !!(me.ownerLayout && me.ownerLayout.getItemSizePolicy(me, me.fakeSizeModel).setsHeight);
  if (heighted) {
    me.protoEl.addCls(me.heightedCls);
  }
  (arguments.callee.$previous || Ext.form.field.Base.prototype.beforeRender).call(this);
}, onRender:function() {
  var me = this, triggers = me.getTriggers(), elements = [], id;
  if (Ext.supports.FixedTableWidthBug) {
    me.el._needsTableWidthFix = true;
  }
  (arguments.callee.$previous || Ext.form.field.Base.prototype.onRender).call(this);
  me.emptyClsElements = [me.inputEl];
  if (triggers) {
    me.invokeTriggers('onFieldRender');
    for (id in triggers) {
      elements.push(triggers[id].el);
    }
    me.triggerEl = me.triggerCell = new Ext.CompositeElement(elements, true);
  }
  me.inputCell = me.inputWrap;
  me.refreshEmptyText();
}, onResize:function(width, height, oldWidth, oldHeight) {
  var me = this;
  if (me.rendered && me.grow) {
    me.autoSize();
  }
  Ext.form.field.Base.prototype.onResize.call(this, width, height, oldWidth, oldHeight);
}, afterRender:function() {
  Ext.form.field.Base.prototype.afterRender.call(this);
  this.invokeTriggers('afterFieldRender');
}, onBoxReady:function(width, height) {
  var me = this;
  Ext.form.field.Base.prototype.onBoxReady.call(this, width, height);
  if (!me.liquidLayout) {
    this.autoSize();
  }
}, applyInputMask:function(value, instance) {
  var field = Ext.field, InputMask = field && field['InputMask'];
  return value ? InputMask.from(value, instance) : null;
}, applyTriggers:function(triggers) {
  var me = this, hideAllTriggers = me.getHideTrigger(), readOnly = me.readOnly, orderedTriggers = me.orderedTriggers = [], repeatTriggerClick = me.repeatTriggerClick, id, triggerCfg, trigger, triggerCls, i;
  if (!triggers) {
    triggers = {};
    if (me.triggerCls && !me.trigger1Cls) {
      me.trigger1Cls = me.triggerCls;
    }
    for (i = 1; triggerCls = me['trigger' + i + 'Cls']; i++) {
      triggers['trigger' + i] = {cls:triggerCls, extraCls:'x-trigger-index-' + i, handler:'onTrigger' + i + 'Click', compat4Mode:true, scope:me};
    }
  }
  for (id in triggers) {
    if (triggers.hasOwnProperty(id)) {
      triggerCfg = triggers[id];
      triggerCfg.field = me;
      triggerCfg.id = id;
      if (readOnly && triggerCfg.hideOnReadOnly !== false || hideAllTriggers && triggerCfg.hidden !== false) {
        triggerCfg.hidden = true;
      }
      if (repeatTriggerClick && triggerCfg.repeatClick !== false) {
        triggerCfg.repeatClick = true;
      }
      trigger = triggers[id] = Ext.form.trigger.Trigger.create(triggerCfg);
      orderedTriggers.push(trigger);
    }
  }
  Ext.Array.sort(orderedTriggers, Ext.weightSortFn);
  return triggers;
}, invokeTriggers:function(methodName, args) {
  var me = this, triggers = me.getTriggers(), id, trigger;
  if (triggers) {
    for (id in triggers) {
      if (triggers.hasOwnProperty(id)) {
        trigger = triggers[id];
        trigger[methodName].apply(trigger, args || []);
      }
    }
  }
}, getTrigger:function(id) {
  return this.getTriggers()[id];
}, updateMinHeight:function(minHeight, oldMinHeight) {
  Ext.form.field.Base.prototype.updateMinHeight.call(this, minHeight, oldMinHeight);
  this.toggleCls('x-has-min-height', !!minHeight);
}, updateInputMask:function(inputMask, previous) {
  if (previous) {
    previous.release();
  }
  if (inputMask) {
    this.enableKeyEvents = true;
  }
}, updateHideTrigger:function(hideTrigger) {
  this.invokeTriggers(hideTrigger ? 'hide' : 'show');
}, updateEditable:function(editable, oldEditable) {
  this.setReadOnlyAttr(!editable || this.readOnly);
}, setReadOnly:function(readOnly) {
  var me = this, triggers = me.getTriggers(), hideTriggers = me.getHideTrigger(), trigger, id;
  readOnly = !!readOnly;
  Ext.form.field.Base.prototype.setReadOnly.call(this, readOnly);
  if (me.rendered) {
    me.setReadOnlyAttr(readOnly || !me.editable);
  }
  if (triggers) {
    for (id in triggers) {
      trigger = triggers[id];
      if (trigger.hideOnReadOnly === true || trigger.hideOnReadOnly !== false && !hideTriggers) {
        trigger.setVisible(!readOnly);
      }
    }
  }
}, setReadOnlyAttr:function(readOnly) {
  var me = this, readOnlyName = 'readonly', inputEl = me.inputEl.dom;
  if (readOnly) {
    inputEl.setAttribute(readOnlyName, readOnlyName);
  } else {
    inputEl.removeAttribute(readOnlyName);
  }
  if (!me.ariaStaticRoles[me.ariaRole]) {
    me.inputEl.dom.setAttribute('aria-readonly', !!readOnly);
  }
}, processRawValue:function(value) {
  var me = this, stripRe = me.stripCharsRe, mod, newValue;
  if (stripRe) {
    if (!stripRe.global) {
      mod = 'g';
      mod += stripRe.ignoreCase ? 'i' : '';
      mod += stripRe.multiline ? 'm' : '';
      stripRe = new RegExp(stripRe.source, mod);
    }
    newValue = value.replace(stripRe, '');
    if (newValue !== value) {
      me.setRawValue(newValue);
      if (me.lastValue === value) {
        me.lastValue = newValue;
      }
      value = newValue;
    }
  }
  return value;
}, onDisable:function() {
  Ext.form.field.Base.prototype.onDisable.call(this);
  if (Ext.isIE) {
    this.inputEl.dom.unselectable = 'on';
  }
}, onEnable:function() {
  Ext.form.field.Base.prototype.onEnable.call(this);
  if (Ext.isIE) {
    this.inputEl.dom.unselectable = '';
  }
}, onKeyDown:function(event) {
  var me = this, inputMask = me.getInputMask();
  if (inputMask) {
    inputMask.onKeyDown(me, me.getValue(), event);
  }
  this.fireEvent('keydown', this, event);
}, onKeyUp:function(e) {
  this.fireEvent('keyup', this, e);
}, onKeyPress:function(event) {
  var me = this, inputMask = me.getInputMask();
  if (inputMask) {
    inputMask.onKeyPress(me, me.getValue(), event);
  }
  me.fireEvent('keypress', me, event);
}, getEmptyText:function() {
  return this.emptyText;
}, setEmptyText:function(value) {
  var me = this, inputEl = me.inputEl;
  value = value || '';
  me.emptyText = value;
  if (me.rendered) {
    if (Ext.supports.Placeholder && !me.simulatePlaceholder) {
      if (value) {
        inputEl.dom.setAttribute('placeholder', value);
      } else {
        inputEl.dom.removeAttribute('placeholder');
      }
    } else {
      me.placeholderLabel.setHtml(value);
    }
    me.refreshEmptyText();
  }
  return this;
}, afterFirstLayout:function() {
  Ext.form.field.Base.prototype.afterFirstLayout.call(this);
  if (Ext.isIE && this.disabled) {
    var el = this.inputEl;
    if (el) {
      el.dom.unselectable = 'on';
    }
  }
}, toggleInvalidCls:function(hasError) {
  var method = hasError ? 'addCls' : 'removeCls';
  Ext.form.field.Base.prototype.toggleInvalidCls.call(this, hasError);
  this.triggerWrap[method](this.triggerWrapInvalidCls);
  this.inputWrap[method](this.inputWrapInvalidCls);
}, onFieldMutation:function(e) {
  this.refreshEmptyText();
  Ext.form.field.Base.prototype.onFieldMutation.call(this, e);
}, refreshEmptyText:function() {
  var me = this, inputEl = me.inputEl, emptyClsElements = me.emptyClsElements, value, isEmpty, i;
  if (inputEl) {
    value = me.getValue();
    isEmpty = !(inputEl.dom.value || Ext.isArray(value) && value.length);
    if (me.placeholderLabel) {
      me.placeholderLabel.setDisplayed(isEmpty);
    }
    for (i = 0; i < emptyClsElements.length; i++) {
      emptyClsElements[i].toggleCls(me.emptyUICls, isEmpty);
    }
  }
}, setValue:function(value) {
  value = Ext.form.field.Base.prototype.setValue.call(this, value);
  this.refreshEmptyText();
  return value;
}, onFocus:function(e) {
  var me = this, inputEl = me.inputEl.dom, inputMask = me.getInputMask(), value, len;
  Ext.form.field.Base.prototype.onFocus.call(this, e);
  if (me.emptyText) {
    me.autoSize();
  }
  if (inputMask) {
    inputMask.onFocus(me, inputEl.value);
  }
  me.addCls(me.fieldFocusCls);
  me.triggerWrap.addCls(me.triggerWrapFocusCls);
  me.inputWrap.addCls(me.inputWrapFocusCls);
  me.invokeTriggers('onFieldFocus', [e]);
  if (me.selectOnFocus && document.activeElement === inputEl) {
    value = inputEl.value;
    len = value.length;
    Ext.asap(me.selectText, me, [0, len]);
  }
}, onBlur:function(e) {
  var me = this, inputEl = me.inputEl.dom, inputMask = me.getInputMask(), value;
  Ext.form.field.Base.prototype.onBlur.call(this, e);
  value = inputEl && inputEl.value;
  me.removeCls(me.fieldFocusCls);
  me.triggerWrap.removeCls(me.triggerWrapFocusCls);
  me.inputWrap.removeCls(me.inputWrapFocusCls);
  me.invokeTriggers('onFieldBlur', [e]);
  if (inputMask && me.getAutoHideInputMask() !== false) {
    inputMask.onBlur(me, value);
  }
}, filterKeys:function(e) {
  if (e.ctrlKey && !e.altKey || e.isSpecialKey()) {
    return;
  }
  var charCode = String.fromCharCode(e.getCharCode());
  if (!this.maskRe.test(charCode)) {
    e.stopEvent();
  }
}, getState:function() {
  return this.addPropertyToState(Ext.form.field.Base.prototype.getState.call(this), 'value');
}, applyState:function(state) {
  Ext.form.field.Base.prototype.applyState.call(this, state);
  if (state.hasOwnProperty('value')) {
    this.setValue(state.value);
  }
}, getErrors:function(value) {
  value = arguments.length ? value == null ? '' : value : this.processRawValue(this.getRawValue());
  var me = this, errors = Ext.form.field.Base.prototype.getErrors.call(this, value), validator = me.validator, vtype = me.vtype, vtypes = Ext.form.field.VTypes, regex = me.regex, format = Ext.String.format, msg, trimmed, isBlank;
  if (Ext.isFunction(validator)) {
    msg = validator.call(me, value);
    if (msg !== true) {
      errors.push(msg);
    }
  }
  trimmed = me.allowOnlyWhitespace ? value : Ext.String.trim(value);
  if (trimmed.length < 1) {
    if (!me.allowBlank) {
      errors.push(me.blankText);
    }
    if (!me.validateBlank) {
      return errors;
    }
    isBlank = true;
  }
  if (!isBlank && value.length < me.minLength) {
    errors.push(format(me.minLengthText, me.minLength));
  }
  if (value.length > me.maxLength) {
    errors.push(format(me.maxLengthText, me.maxLength));
  }
  if (vtype) {
    if (!vtypes[vtype](value, me)) {
      errors.push(me.vtypeText || vtypes[vtype + 'Text']);
    }
  }
  if (regex && !regex.test(value)) {
    errors.push(me.regexText || me.invalidText);
  }
  return errors;
}, getCaretPos:function() {
  return this.inputEl.getCaretPos();
}, setCaretPos:function(pos) {
  this.inputEl.setCaretPos(pos);
}, getTextSelection:function() {
  return this.inputEl.getTextSelection();
}, selectText:function(start, end, direction) {
  if (!this.destroyed) {
    this.inputEl.selectText(start, end, direction);
    return this;
  }
}, getGrowWidth:function() {
  return this.inputEl.dom.value;
}, autoSize:function() {
  var me = this, triggers, triggerId, triggerWidth, inputEl, width, value;
  if (me.grow && me.rendered && me.getSizeModel().width.auto) {
    inputEl = me.inputEl;
    triggers = me.getTriggers();
    triggerWidth = 0;
    value = Ext.util.Format.htmlEncode(me.getGrowWidth() || (me.hasFocus ? '' : me.emptyText) || '');
    value = value.replace(/\s/g, '\x26nbsp;');
    for (triggerId in triggers) {
      triggerWidth += triggers[triggerId].el.getWidth();
    }
    width = inputEl.getTextWidth(value) + triggerWidth + me.inputWrap.getBorderWidth('lr') + me.triggerWrap.getBorderWidth('lr') + inputEl.getPadding('lr');
    width = Math.min(Math.max(width, me.growMin), me.growMax);
    me.bodyEl.setWidth(width);
    me.updateLayout();
    me.fireEvent('autosize', me, width);
  }
}, doDestroy:function() {
  var me = this;
  me.invokeTriggers('destroy');
  Ext.destroy(me.triggerRepeater);
  me.setInputMask(null);
  Ext.form.field.Base.prototype.doDestroy.call(this);
}, onTriggerClick:Ext.emptyFn, privates:{getTdType:function() {
  return 'textfield';
}}, deprecated:{5:{methods:{getTriggerWidth:function() {
  var triggers = this.getTriggers(), width = 0, id;
  if (triggers && this.rendered) {
    for (id in triggers) {
      if (triggers.hasOwnProperty(id)) {
        width += triggers[id].el.getWidth();
      }
    }
  }
  return width;
}}}}}, 0, ['textfield'], ['component', 'box', 'field', 'textfield'], {'component':true, 'box':true, 'field':true, 'textfield':true}, ['widget.textfield'], 0, [Ext.form.field, 'Text', Ext.form, 'TextField', Ext.form, 'Text'], function(TextField) {
  var calculated = Ext.layout.SizeModel.calculated;
  TextField.prototype.fakeSizeModel = calculated.pairsByHeightOrdinal[calculated.ordinal];
});
Ext.cmd.derive('Ext.form.field.TextArea', Ext.form.field.Text, {alternateClassName:'Ext.form.TextArea', fieldSubTpl:['\x3ctextarea id\x3d"{id}" data-ref\x3d"inputEl" rows\x3d"1" {inputAttrTpl}', '\x3ctpl if\x3d"name"\x3e name\x3d"{name}"\x3c/tpl\x3e', '\x3ctpl if\x3d"placeholder"\x3e placeholder\x3d"{placeholder}"\x3c/tpl\x3e', '\x3ctpl if\x3d"maxLength !\x3d\x3d undefined"\x3e maxlength\x3d"{maxLength}"\x3c/tpl\x3e', '\x3ctpl if\x3d"readOnly"\x3e readonly\x3d"readonly"\x3c/tpl\x3e', '\x3ctpl if\x3d"disabled"\x3e disabled\x3d"disabled"\x3c/tpl\x3e', 
'\x3ctpl if\x3d"tabIdx !\x3d null"\x3e tabindex\x3d"{tabIdx}"\x3c/tpl\x3e', ' class\x3d"{fieldCls} {typeCls} {typeCls}-{ui} {inputCls} {fixCls}" ', '\x3ctpl if\x3d"fieldStyle"\x3e style\x3d"{fieldStyle}"\x3c/tpl\x3e', '\x3ctpl foreach\x3d"ariaElAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e', '\x3ctpl foreach\x3d"inputElAriaAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e', ' autocomplete\x3d"off"\x3e\n', '\x3ctpl if\x3d"value"\x3e{[Ext.util.Format.htmlEncode(values.value)]}\x3c/tpl\x3e', '\x3c/textarea\x3e', 
{disableFormats:true}], growMin:60, growMax:1000, growAppend:'\n-', enterIsSpecial:false, preventScrollbars:false, returnRe:/\r/g, inputCls:'x-form-textarea', extraFieldBodyCls:'x-form-textarea-body', ariaAttributes:{'aria-multiline':true}, getSubTplData:function(fieldData) {
  var me = this, fieldStyle = me.getFieldStyle(), ret = Ext.form.field.Text.prototype.getSubTplData.apply(this, arguments);
  if (me.grow) {
    if (me.preventScrollbars) {
      ret.fieldStyle = (fieldStyle || '') + ';overflow:hidden;';
    }
  }
  return ret;
}, afterRender:function() {
  var me = this;
  Ext.form.field.Text.prototype.afterRender.apply(this, arguments);
  me.needsMaxCheck = me.enforceMaxLength && me.maxLength !== Number.MAX_VALUE && !Ext.supports.TextAreaMaxLength;
  if (me.needsMaxCheck) {
    me.inputEl.on('paste', me.onPaste, me);
  }
}, transformRawValue:function(value) {
  return this.stripReturns(value);
}, getValue:function() {
  return this.stripReturns(Ext.form.field.Text.prototype.getValue.call(this));
}, valueToRaw:function(value) {
  value = this.stripReturns(value);
  return Ext.form.field.Text.prototype.valueToRaw.call(this, value);
}, stripReturns:function(value) {
  if (value && typeof value === 'string') {
    value = value.replace(this.returnRe, '');
  }
  return value;
}, onPaste:function() {
  var me = this;
  if (!me.pasteTask) {
    me.pasteTask = new Ext.util.DelayedTask(me.pasteCheck, me);
  }
  me.pasteTask.delay(1);
}, pasteCheck:function() {
  var me = this, value = me.getValue(), max = me.maxLength;
  if (value.length > max) {
    value = value.substr(0, max);
    me.setValue(value);
  }
}, fireKey:function(e) {
  var me = this, key = e.getKey(), value;
  if (e.isSpecialKey() && (me.enterIsSpecial || (key !== e.ENTER || e.hasModifier()))) {
    me.fireEvent('specialkey', me, e);
  }
  if (me.needsMaxCheck && key !== e.BACKSPACE && key !== e.DELETE && !e.isNavKeyPress() && !me.isCutCopyPasteSelectAll(e, key)) {
    value = me.getValue();
    if (value.length >= me.maxLength) {
      e.stopEvent();
    }
  }
}, isCutCopyPasteSelectAll:function(e, key) {
  if (e.ctrlKey) {
    return key === e.A || key === e.C || key === e.V || key === e.X;
  }
  return false;
}, autoSize:function() {
  var me = this, inputEl, hideScroller, height, curWidth, value;
  if (me.grow && me.rendered && me.getSizeModel().height.auto) {
    inputEl = me.inputEl;
    curWidth = inputEl.getWidth(true);
    value = Ext.util.Format.htmlEncode(inputEl.dom.value) || '\x26#160;';
    value += me.growAppend;
    value = value.replace(/\n/g, '\x3cbr/\x3e');
    height = Ext.util.TextMetrics.measure(inputEl, value, curWidth).height + inputEl.getPadding('tb') + me.inputWrap.getBorderWidth('tb') + me.triggerWrap.getBorderWidth('tb');
    height = Math.min(Math.max(height, me.growMin), me.growMax);
    hideScroller = me.preventScrollbars || !me.growMax || height < me.growMax;
    inputEl.setStyle('overflow-y', hideScroller ? 'hidden' : 'auto');
    me.bodyEl.setHeight(height);
    me.updateLayout();
    me.fireEvent('autosize', me, height);
  }
}, doDestroy:function() {
  var task = this.pasteTask;
  if (task) {
    task.cancel();
  }
  Ext.form.field.Text.prototype.doDestroy.call(this);
}}, 0, ['textarea', 'textareafield'], ['component', 'box', 'field', 'textfield', 'textareafield', 'textarea'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'textareafield':true, 'textarea':true}, ['widget.textarea', 'widget.textareafield'], 0, [Ext.form.field, 'TextArea', Ext.form, 'TextArea'], 0);
Ext.cmd.derive('Ext.window.MessageBox', Ext.window.Window, {OK:1, YES:2, NO:4, CANCEL:8, OKCANCEL:9, YESNO:6, YESNOCANCEL:14, INFO:'x-message-box-info', WARNING:'x-message-box-warning', QUESTION:'x-message-box-question', ERROR:'x-message-box-error', hideMode:'offsets', closeAction:'hide', resizable:false, scrollable:true, title:'\x26#160;', defaultMinWidth:250, defaultMaxWidth:600, defaultMinHeight:110, defaultMaxHeight:500, minWidth:null, maxWidth:null, minHeight:null, maxHeight:null, constrain:true, 
cls:['x-message-box', 'x-hidden-offsets'], layout:{type:'vbox', align:'stretch'}, shrinkWrapDock:true, defaultTextHeight:75, minProgressWidth:250, minPromptWidth:250, buttonText:{ok:'OK', yes:'Yes', no:'No', cancel:'Cancel'}, buttonIds:['ok', 'yes', 'no', 'cancel'], baseIconCls:'x-message-box-icon', ariaRole:'alertdialog', makeButton:function(btnIdx) {
  var btnId = this.buttonIds[btnIdx];
  return new Ext.button.Button({handler:this.btnCallback, itemId:btnId, scope:this, text:this.buttonText[btnId], minWidth:75});
}, btnCallback:function(btn, event) {
  var me = this, value, field;
  if (event && event.type === 'keydown' && !event.isSpecialKey()) {
    event.getTarget(null, null, true).on({keyup:function(e) {
      me.btnCallback(btn, e);
    }, single:true});
    return;
  }
  if (me.cfg.prompt || me.cfg.multiline) {
    if (me.cfg.multiline) {
      field = me.textArea;
    } else {
      field = me.textField;
    }
    value = field.getValue();
    field.reset();
  }
  me.hide();
  me.userCallback(btn.itemId, value, me.cfg);
}, hide:function() {
  var me = this, cls = me.cfg ? me.cfg.cls : '';
  me.progressBar.reset();
  if (cls) {
    me.removeCls(cls);
  }
  Ext.window.Window.prototype.hide.apply(this, arguments);
}, constructor:function(cfg) {
  var me = this;
  Ext.window.Window.prototype.constructor.apply(this, arguments);
  me.minWidth = me.defaultMinWidth = me.minWidth || me.defaultMinWidth;
  me.maxWidth = me.defaultMaxWidth = me.maxWidth || me.defaultMaxWidth;
  me.minHeight = me.defaultMinHeight = me.minHeight || me.defaultMinHeight;
  me.maxHeight = me.defaultMaxHeight = me.maxHeight || me.defaultMaxHeight;
}, initComponent:function(cfg) {
  var me = this, baseId = me.id, i, button;
  me.title = me.title || '\x26#160;';
  me.iconCls = me.iconCls || '';
  me.topContainer = new Ext.container.Container({layout:'hbox', padding:10, style:{overflow:'hidden'}, items:[me.iconComponent = new Ext.Component({cls:me.baseIconCls}), me.promptContainer = new Ext.container.Container({flex:1, layout:{type:'vbox', align:'stretch'}, items:[me.msg = new Ext.Component({id:baseId + '-msg', cls:me.baseCls + '-text'}), me.textField = new Ext.form.field.Text({id:baseId + '-textfield', enableKeyEvents:true, ariaAttributes:{'aria-labelledby':me.msg.id}, listeners:{keydown:me.onPromptKey, 
  scope:me}}), me.textArea = new Ext.form.field.TextArea({id:baseId + '-textarea', height:75, ariaAttributes:{'aria-labelledby':me.msg.id}})]})]});
  me.progressBar = new Ext.ProgressBar({id:baseId + '-progressbar', margin:'0 10 10 10'});
  me.items = [me.topContainer, me.progressBar];
  me.msgButtons = [];
  for (i = 0; i < 4; i++) {
    button = me.makeButton(i);
    me.msgButtons[button.itemId] = button;
    me.msgButtons.push(button);
  }
  me.bottomTb = new Ext.toolbar.Toolbar({id:baseId + '-toolbar', ui:'footer', dock:'bottom', focusableContainer:false, ariaRole:null, layout:{pack:'center'}, items:[me.msgButtons[0], me.msgButtons[1], me.msgButtons[2], me.msgButtons[3]]});
  me.dockedItems = [me.bottomTb];
  me.on('close', me.onClose, me);
  Ext.window.Window.prototype.initComponent.call(this);
}, afterRender:function() {
  var me = this;
  Ext.window.Window.prototype.afterRender.apply(this, arguments);
  me.textField.labelEl.dom.removeAttribute('for');
  me.textArea.labelEl.dom.removeAttribute('for');
}, onClose:function() {
  var btn = this.msgButtons[3];
  if (btn) {
    this.btnCallback(btn);
  }
}, onPromptKey:function(textField, e) {
  var me = this;
  if (e.keyCode === e.RETURN || e.keyCode === 10) {
    if (me.msgButtons.ok.isVisible()) {
      me.msgButtons.ok.handler.call(me, me.msgButtons.ok);
    } else {
      if (me.msgButtons.yes.isVisible()) {
        me.msgButtons.yes.handler.call(me, me.msgButtons.yes);
      }
    }
  }
}, reconfigure:function(cfg) {
  var me = this, buttons = 0, hideToolbar = true, oldButtonText = me.buttonText, resizer = me.resizer, header = me.header, headerCfg = header && !header.isHeader, message = cfg && (cfg.message || cfg.msg), buttonTips = cfg.buttonTips, title, iconCls, resizeTracker, width, height, i, textArea, textField, msg, progressBar, msgButtons, wait, tool;
  me.updateButtonText();
  me.cfg = cfg = cfg || {};
  wait = cfg.wait;
  if (cfg.width) {
    width = cfg.width;
  }
  if (cfg.height) {
    height = cfg.height;
  }
  me.minWidth = cfg.minWidth || me.defaultMinWidth;
  me.maxWidth = cfg.maxWidth || me.defaultMaxWidth;
  me.minHeight = cfg.minHeight || me.defaultMinHeight;
  me.maxHeight = cfg.maxHeight || me.defaultMaxHeight;
  if ('maskClickAction' in cfg) {
    me.maskClickAction = cfg.maskClickAction;
  } else {
    delete me.maskClickAction;
  }
  if (resizer) {
    resizeTracker = resizer.resizeTracker;
    resizer.minWidth = resizeTracker.minWidth = me.minWidth;
    resizer.maxWidth = resizeTracker.maxWidth = me.maxWidth;
    resizer.minHeight = resizeTracker.minHeight = me.minHeight;
    resizer.maxHeight = resizeTracker.maxHeight = me.maxHeight;
  }
  delete me.defaultFocus;
  if (cfg.defaultFocus) {
    me.defaultFocus = cfg.defaultFocus;
  }
  me.animateTarget = cfg.animateTarget || undefined;
  me.modal = cfg.modal !== false;
  if (cfg.title != null) {
    title = cfg.title;
  } else {
    if (headerCfg && header.title != null) {
      title = header.title;
    } else {
      title = me.title;
    }
  }
  if (cfg.iconCls != null) {
    iconCls = cfg.iconCls;
  } else {
    if (headerCfg && header.iconCls != null) {
      iconCls = header.iconCls;
    } else {
      iconCls = me.iconCls;
    }
  }
  me.setTitle(title);
  me.setIconCls(iconCls);
  if (Ext.isObject(cfg.buttons)) {
    me.buttonText = cfg.buttons;
    buttons = 0;
  } else {
    me.buttonText = cfg.buttonText || me.buttonText;
    buttons = Ext.isNumber(cfg.buttons) ? cfg.buttons : 0;
  }
  Ext.each(me.buttonIds, function(buttonId) {
    me.msgButtons[buttonId].setTooltip(buttonTips && buttonTips[buttonId] || null);
  });
  buttons = buttons | me.updateButtonText();
  me.buttonText = oldButtonText;
  Ext.suspendLayouts();
  me.width = me.height = null;
  if (width || height) {
    if (width) {
      me.setWidth(width);
    }
    if (height) {
      me.setHeight(height);
    }
  }
  if (!me.rendered) {
    me.render(Ext.getBody());
  }
  me.closable = cfg.closable !== false && !wait;
  header = me.header;
  if (header) {
    tool = header.child('[type\x3dclose]');
    if (tool) {
      tool.setVisible(me.closable);
    }
    if (!cfg.title && !me.closable && !cfg.iconCls) {
      header.hide();
    } else {
      header.show();
    }
  }
  me.liveDrag = !cfg.proxyDrag;
  me.userCallback = Ext.Function.bindCallback(cfg.callback || cfg.fn || Ext.emptyFn, cfg.scope || Ext.global);
  me.setIcon(cfg.icon);
  msg = me.msg;
  if (message) {
    msg.setHtml(message);
    msg.show();
    me.ariaEl.dom.setAttribute('aria-describedby', msg.id);
  } else {
    msg.hide();
    me.ariaEl.dom.removeAttribute('aria-describedby');
  }
  textArea = me.textArea;
  textField = me.textField;
  if (cfg.prompt || cfg.multiline) {
    me.multiline = cfg.multiline;
    if (cfg.multiline) {
      textArea.setValue(cfg.value);
      textArea.setHeight(cfg.defaultTextHeight || me.defaultTextHeight);
      textArea.show();
      textField.hide();
      me.defaultFocus = textArea;
    } else {
      textField.setValue(cfg.value);
      textArea.hide();
      textField.show();
      me.defaultFocus = textField;
    }
    me.ariaEl.dom.removeAttribute('aria-describedby');
  } else {
    textArea.hide();
    textField.hide();
  }
  progressBar = me.progressBar;
  if (cfg.progress || wait) {
    progressBar.show();
    me.updateProgress(0, cfg.progressText);
    me.defaultFocus = progressBar;
    if (wait) {
      progressBar.wait(wait === true ? cfg.waitConfig : wait);
    }
  } else {
    progressBar.hide();
  }
  msgButtons = me.msgButtons;
  for (i = 0; i < 4; i++) {
    if (buttons & Math.pow(2, i)) {
      if (!me.defaultFocus) {
        me.defaultFocus = msgButtons[i];
      }
      msgButtons[i].show();
      hideToolbar = false;
    } else {
      msgButtons[i].hide();
    }
  }
  if (hideToolbar) {
    me.bottomTb.hide();
  } else {
    me.bottomTb.show();
  }
  Ext.resumeLayouts(true);
}, updateButtonText:function() {
  var me = this, buttonText = me.buttonText, buttons = 0, btnId, btn;
  for (btnId in buttonText) {
    if (buttonText.hasOwnProperty(btnId)) {
      btn = me.msgButtons[btnId];
      if (btn) {
        if (me.cfg && me.cfg.buttonText) {
          buttons = buttons | Math.pow(2, Ext.Array.indexOf(me.buttonIds, btnId));
        }
        if (btn.text !== buttonText[btnId]) {
          btn.setText(buttonText[btnId]);
        }
      }
    }
  }
  return buttons;
}, show:function(cfg) {
  var me = this, visibleFocusables;
  cfg = cfg || {};
  if (Ext.Component.layoutSuspendCount) {
    Ext.on({resumelayouts:function() {
      me.show(cfg);
    }, single:true});
    return me;
  }
  me.reconfigure(cfg);
  if (cfg.cls) {
    me.addCls(cfg.cls);
  }
  visibleFocusables = me.query('textfield:not([hidden]),textarea:not([hidden]),button:not([hidden])');
  me.preventFocusOnActivate = !visibleFocusables.length;
  Ext.window.Window.prototype.show.call(this);
  return me;
}, onShow:function() {
  Ext.window.Window.prototype.onShow.apply(this, arguments);
  this.center();
}, updateText:function(text) {
  this.msg.setHtml(text);
}, setIcon:function(icon, width, height) {
  var me = this, iconCmp = me.iconComponent, cls = me.messageIconCls;
  if (cls) {
    iconCmp.removeCls(cls);
  }
  if (icon) {
    iconCmp.show();
    if (width || height) {
      iconCmp.setSize(width || iconCmp.getWidth(), height || iconCmp.getHeight());
    }
    iconCmp.addCls('x-dlg-icon');
    iconCmp.addCls(me.messageIconCls = icon);
  } else {
    iconCmp.removeCls('x-dlg-icon');
    iconCmp.hide();
  }
  return me;
}, updateProgress:function(value, progressText, message) {
  this.progressBar.updateProgress(value, progressText);
  if (message) {
    this.updateText(message);
  }
  return this;
}, onEsc:function() {
  if (this.closable !== false) {
    Ext.window.Window.prototype.onEsc.apply(this, arguments);
  }
}, confirm:function(title, message, fn, scope) {
  if (Ext.isString(title)) {
    title = {title:title, icon:this.QUESTION, message:message, buttons:this.YESNO, callback:fn, scope:scope};
  }
  return this.show(title);
}, prompt:function(title, message, fn, scope, multiline, value) {
  if (Ext.isString(title)) {
    title = {prompt:true, title:title, minWidth:this.minPromptWidth, message:message, buttons:this.OKCANCEL, callback:fn, scope:scope, multiline:multiline, value:value};
  }
  return this.show(title);
}, wait:function(message, title, config) {
  if (Ext.isString(message)) {
    message = {title:title, message:message, closable:false, wait:true, modal:true, minWidth:this.minProgressWidth, waitConfig:config};
  }
  return this.show(message);
}, alert:function(title, message, fn, scope) {
  if (Ext.isString(title)) {
    title = {title:title, message:message, buttons:this.OK, fn:fn, scope:scope, minWidth:this.minWidth};
  }
  return this.show(title);
}, progress:function(title, message, progressText) {
  if (Ext.isString(title)) {
    title = {title:title, message:message, progress:true, progressText:progressText};
  }
  return this.show(title);
}, privates:{syncHeaderConfigs:Ext.privateFn}}, 1, ['messagebox'], ['component', 'box', 'container', 'panel', 'window', 'messagebox'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'messagebox':true}, ['widget.messagebox'], 0, [Ext.window, 'MessageBox'], function(MessageBox) {
  Ext.onInternalReady(function() {
    Ext.MessageBox = Ext.Msg = new MessageBox;
  });
});
Ext.cmd.derive('Ext.form.Basic', Ext.util.Observable, {alternateClassName:'Ext.form.BasicForm', taskDelay:10, constructor:function(owner, config) {
  var me = this, reader;
  me.owner = owner;
  me.fieldMonitors = {validitychange:me.checkValidityDelay, enable:me.checkValidityDelay, disable:me.checkValidityDelay, dirtychange:me.checkDirtyDelay, errorchange:me.checkErrorDelay, scope:me};
  me.checkValidityTask = new Ext.util.DelayedTask(me.checkValidity, me);
  me.checkDirtyTask = new Ext.util.DelayedTask(me.checkDirty, me);
  me.checkErrorTask = new Ext.util.DelayedTask(me.checkError, me);
  me.monitor = new Ext.container.Monitor({selector:'[isFormField]:not([excludeForm])', scope:me, addHandler:me.onFieldAdd, removeHandler:me.onFieldRemove, invalidateHandler:me.onMonitorInvalidate});
  me.monitor.bind(owner);
  Ext.apply(me, config);
  if (Ext.isString(me.paramOrder)) {
    me.paramOrder = me.paramOrder.split(/[\s,|]/);
  }
  reader = me.reader;
  if (reader && !reader.isReader) {
    if (typeof reader === 'string') {
      reader = {type:reader};
    }
    me.reader = Ext.createByAlias('reader.' + reader.type, reader);
  }
  reader = me.errorReader;
  if (reader && !reader.isReader) {
    if (typeof reader === 'string') {
      reader = {type:reader};
    }
    me.errorReader = Ext.createByAlias('reader.' + reader.type, reader);
  }
  Ext.util.Observable.prototype.constructor.call(this);
}, initialize:function() {
  this.initialized = true;
  this.onValidityChange(!this.hasInvalidField());
}, timeout:30, paramsAsHash:false, waitTitle:'Please Wait...', trackResetOnLoad:false, wasDirty:false, destroy:function() {
  var me = this, mon = me.monitor;
  Ext.undefer(me.actionTimer);
  if (mon) {
    mon.unbind();
    me.monitor = null;
  }
  me.clearListeners();
  me.checkValidityTask.cancel();
  me.checkDirtyTask.cancel();
  me.checkErrorTask.cancel();
  me.checkValidityTask = me.checkDirtyTask = me.checkErrorTask = null;
  Ext.util.Observable.prototype.destroy.call(this);
}, onFieldAdd:function(field) {
  field.on(this.fieldMonitors);
  this.onMonitorInvalidate();
}, onFieldRemove:function(field) {
  field.un(this.fieldMonitors);
  this.onMonitorInvalidate();
}, onMonitorInvalidate:function() {
  if (this.initialized) {
    this.checkValidityDelay();
  }
}, getFields:function() {
  return this.monitor.getItems();
}, getBoundItems:function() {
  var boundItems = this._boundItems;
  if (!boundItems || boundItems.getCount() === 0) {
    boundItems = this._boundItems = new Ext.util.MixedCollection;
    boundItems.addAll(this.owner.query('[formBind]'));
  }
  return boundItems;
}, hasInvalidField:function() {
  return !!this.getFields().findBy(function(field) {
    var preventMark = field.preventMark, isValid;
    field.preventMark = true;
    isValid = field.isValid();
    field.preventMark = preventMark;
    return !isValid;
  });
}, isValid:function() {
  var me = this, invalid;
  Ext.suspendLayouts();
  invalid = me.getFields().filterBy(function(field) {
    return !field.validate();
  });
  Ext.resumeLayouts(true);
  return invalid.length < 1;
}, checkValidity:function() {
  var me = this, valid;
  if (me.destroyed) {
    return;
  }
  valid = !me.hasInvalidField();
  if (valid !== me.wasValid) {
    me.onValidityChange(valid);
    me.fireEvent('validitychange', me, valid);
    me.wasValid = valid;
  }
}, checkValidityDelay:function() {
  var timer = this.taskDelay;
  if (timer) {
    this.checkValidityTask.delay(timer);
  } else {
    this.checkValidity();
  }
}, checkError:function() {
  this.fireEvent('errorchange', this);
}, checkErrorDelay:function() {
  var timer = this.taskDelay;
  if (timer) {
    this.checkErrorTask.delay(timer);
  } else {
    this.checkError();
  }
}, onValidityChange:function(valid) {
  var boundItems = this.getBoundItems(), items, i, iLen, cmp;
  if (boundItems) {
    items = boundItems.items;
    iLen = items.length;
    for (i = 0; i < iLen; i++) {
      cmp = items[i];
      if (cmp.disabled === valid) {
        cmp.setDisabled(!valid);
      }
    }
  }
}, isDirty:function() {
  return !!this.getFields().findBy(function(f) {
    return f.isDirty();
  });
}, checkDirtyDelay:function() {
  var timer = this.taskDelay;
  if (timer) {
    this.checkDirtyTask.delay(timer);
  } else {
    this.checkDirty();
  }
}, checkDirty:function() {
  var me = this, dirty;
  if (me.destroyed) {
    return;
  }
  dirty = this.isDirty();
  if (dirty !== this.wasDirty) {
    this.fireEvent('dirtychange', this, dirty);
    this.wasDirty = dirty;
  }
}, hasUpload:function() {
  return !!this.getFields().findBy(function(f) {
    return f.isFileUpload();
  });
}, doAction:function(action, options) {
  var me = this;
  if (Ext.isString(action)) {
    action = Ext.ClassManager.instantiateByAlias('formaction.' + action, Ext.apply({}, options, {form:me}));
  }
  if (me.fireEvent('beforeaction', me, action) !== false) {
    me.beforeAction(action);
    me.actionTimer = Ext.defer(action.run, 100, action);
  }
  return me;
}, submit:function(options) {
  options = options || {};
  var me = this, action;
  if (options.standardSubmit || me.standardSubmit) {
    action = 'standardsubmit';
  } else {
    action = me.api ? 'directsubmit' : 'submit';
  }
  return me.doAction(action, options);
}, load:function(options) {
  return this.doAction(this.api ? 'directload' : 'load', options);
}, updateRecord:function(record) {
  record = record || this._record;
  if (!record) {
    return this;
  }
  var fields = record.self.fields, values = this.getFieldValues(), obj = {}, i = 0, len = fields.length, name;
  for (; i < len; ++i) {
    name = fields[i].name;
    if (values.hasOwnProperty(name)) {
      obj[name] = values[name];
    }
  }
  record.beginEdit();
  record.set(obj);
  record.endEdit();
  return this;
}, loadRecord:function(record) {
  this._record = record;
  return this.setValues(record.getData());
}, getRecord:function() {
  return this._record;
}, beforeAction:function(action) {
  var me = this, waitMsg = action.waitMsg, maskCls = 'x-mask-loading', fields = me.getFields().items, f, fLen = fields.length, field, waitMsgTarget;
  for (f = 0; f < fLen; f++) {
    field = fields[f];
    if (field.isFormField && field.syncValue) {
      field.syncValue();
    }
  }
  if (waitMsg) {
    waitMsgTarget = me.waitMsgTarget;
    if (waitMsgTarget === true) {
      me.owner.el.mask(waitMsg, maskCls);
    } else {
      if (waitMsgTarget) {
        waitMsgTarget = me.waitMsgTarget = Ext.get(waitMsgTarget);
        waitMsgTarget.mask(waitMsg, maskCls);
      } else {
        me.floatingAncestor = me.owner.up('[floating]');
        if (me.floatingAncestor) {
          me.savePreventFocusOnActivate = me.floatingAncestor.preventFocusOnActivate;
          me.floatingAncestor.preventFocusOnActivate = true;
        }
        Ext.MessageBox.wait(waitMsg, action.waitTitle || me.waitTitle);
      }
    }
  }
}, afterAction:function(action, success) {
  var me = this;
  if (action.waitMsg) {
    var messageBox = Ext.MessageBox, waitMsgTarget = me.waitMsgTarget;
    if (waitMsgTarget === true) {
      me.owner.el.unmask();
    } else {
      if (waitMsgTarget) {
        waitMsgTarget.unmask();
      } else {
        messageBox.hide();
      }
    }
  }
  if (me.floatingAncestor) {
    me.floatingAncestor.preventFocusOnActivate = me.savePreventFocusOnActivate;
  }
  if (success) {
    if (action.reset) {
      me.reset();
    }
    Ext.callback(action.success, action.scope || action, [me, action]);
    me.fireEvent('actioncomplete', me, action);
  } else {
    Ext.callback(action.failure, action.scope || action, [me, action]);
    me.fireEvent('actionfailed', me, action);
  }
}, findField:function(id) {
  return this.getFields().findBy(function(f) {
    return f.id === id || f.name === id || f.dataIndex === id;
  });
}, markInvalid:function(errors) {
  var me = this, e, eLen, error, value, key;
  function mark(fieldId, msg) {
    var field = me.findField(fieldId);
    if (field) {
      field.markInvalid(msg);
    }
  }
  if (Ext.isArray(errors)) {
    eLen = errors.length;
    for (e = 0; e < eLen; e++) {
      error = errors[e];
      mark(error.id || error.field, error.msg || error.message);
    }
  } else {
    if (errors instanceof Ext.data.ErrorCollection) {
      eLen = errors.items.length;
      for (e = 0; e < eLen; e++) {
        error = errors.items[e];
        mark(error.field, error.message);
      }
    } else {
      for (key in errors) {
        if (errors.hasOwnProperty(key)) {
          value = errors[key];
          mark(key, value, errors);
        }
      }
    }
  }
  return this;
}, setValues:function(values) {
  var me = this, v, vLen, val;
  function setVal(fieldId, val) {
    var field = me.findField(fieldId);
    if (field) {
      field.setValue(val);
      if (me.trackResetOnLoad) {
        field.resetOriginalValue();
      }
    }
  }
  Ext.suspendLayouts();
  if (Ext.isArray(values)) {
    vLen = values.length;
    for (v = 0; v < vLen; v++) {
      val = values[v];
      setVal(val.id, val.value);
    }
  } else {
    Ext.iterate(values, setVal);
  }
  Ext.resumeLayouts(true);
  return this;
}, getValues:function(asString, dirtyOnly, includeEmptyText, useDataValues, isSubmitting) {
  var values = {}, fields = this.getFields().items, fLen = fields.length, isArray = Ext.isArray, dataMethod = useDataValues ? 'getModelData' : 'getSubmitData', field, data, val, bucket, name, f;
  for (f = 0; f < fLen; f++) {
    field = fields[f];
    if (!dirtyOnly || field.isDirty()) {
      data = field[dataMethod](includeEmptyText, isSubmitting);
      if (Ext.isObject(data)) {
        for (name in data) {
          if (data.hasOwnProperty(name)) {
            val = data[name];
            if (includeEmptyText && val === '') {
              val = field.emptyText || '';
            }
            if (!field.isRadio) {
              if (values.hasOwnProperty(name)) {
                bucket = values[name];
                if (!isArray(bucket)) {
                  bucket = values[name] = [bucket];
                }
                if (isArray(val)) {
                  values[name] = bucket.concat(val);
                } else {
                  bucket.push(val);
                }
              } else {
                values[name] = val;
              }
            } else {
              values[name] = values[name] || val;
            }
          }
        }
      }
    }
  }
  if (asString) {
    values = Ext.Object.toQueryString(values);
  }
  return values;
}, getFieldValues:function(dirtyOnly) {
  return this.getValues(false, dirtyOnly, false, true);
}, clearInvalid:function() {
  Ext.suspendLayouts();
  var me = this, fields = me.getFields().items, f, fLen = fields.length;
  for (f = 0; f < fLen; f++) {
    fields[f].clearInvalid();
  }
  Ext.resumeLayouts(true);
  return me;
}, reset:function(resetRecord) {
  Ext.suspendLayouts();
  var me = this, fields = me.getFields().items, f, fLen = fields.length;
  for (f = 0; f < fLen; f++) {
    fields[f].reset();
  }
  Ext.resumeLayouts(true);
  if (resetRecord === true) {
    delete me._record;
  }
  return me;
}, applyToFields:function(obj) {
  var fields = this.getFields().items, f, fLen = fields.length;
  for (f = 0; f < fLen; f++) {
    Ext.apply(fields[f], obj);
  }
  return this;
}, applyIfToFields:function(obj) {
  var fields = this.getFields().items, f, fLen = fields.length;
  for (f = 0; f < fLen; f++) {
    Ext.applyIf(fields[f], obj);
  }
  return this;
}}, 1, 0, 0, 0, 0, 0, [Ext.form, 'Basic', Ext.form, 'BasicForm'], 0);
Ext.cmd.derive('Ext.form.FieldAncestor', Ext.Mixin, {mixinConfig:{id:'fieldAncestor', after:{initInheritedState:'initFieldInheritedState'}, before:{doDestroy:'onBeforeDestroy'}}, initFieldAncestor:function() {
  var me = this;
  me.monitor = new Ext.container.Monitor({scope:me, selector:'[isFormField]:not([excludeForm])', addHandler:me.onChildFieldAdd, removeHandler:me.onChildFieldRemove});
  me.initFieldDefaults();
}, initMonitor:function() {
  this.monitor.bind(this);
}, initFieldInheritedState:function(inheritedState) {
  var inheritedFieldDefaults = inheritedState.fieldDefaults, fieldDefaults = this.fieldDefaults;
  if (fieldDefaults) {
    if (inheritedFieldDefaults) {
      inheritedState.fieldDefaults = Ext.apply(Ext.Object.chain(inheritedFieldDefaults), fieldDefaults);
    } else {
      inheritedState.fieldDefaults = fieldDefaults;
    }
  }
}, onChildFieldAdd:function(field) {
  var me = this;
  me.mon(field, 'errorchange', me.handleFieldErrorChange, me);
  me.mon(field, 'validitychange', me.handleFieldValidityChange, me);
}, onChildFieldRemove:function(field) {
  var me = this;
  me.mun(field, 'errorchange', me.handleFieldErrorChange, me);
  me.mun(field, 'validitychange', me.handleFieldValidityChange, me);
}, initFieldDefaults:function() {
  if (!this.fieldDefaults) {
    this.fieldDefaults = {};
  }
}, handleFieldValidityChange:function(field, isValid) {
  var me = this;
  if (field !== me) {
    me.fireEvent('fieldvaliditychange', me, field, isValid);
    me.onFieldValidityChange(field, isValid);
  }
}, handleFieldErrorChange:function(labelable, activeError) {
  var me = this;
  if (labelable !== me) {
    me.fireEvent('fielderrorchange', me, labelable, activeError);
    me.onFieldErrorChange(labelable, activeError);
  }
}, onFieldValidityChange:Ext.emptyFn, onFieldErrorChange:Ext.emptyFn, onBeforeDestroy:function() {
  this.monitor = Ext.destroy(this.monitor);
}}, 0, 0, 0, 0, 0, 0, [Ext.form, 'FieldAncestor'], 0);
Ext.cmd.derive('Ext.layout.component.field.FieldContainer', Ext.layout.component.Auto, {type:'fieldcontainer', waitForOuterHeightInDom:true, waitForOuterWidthInDom:true, beginLayout:function(ownerContext) {
  var containerEl = this.owner.containerEl;
  Ext.layout.component.Auto.prototype.beginLayout.call(this, ownerContext);
  ownerContext.hasRawContent = true;
  containerEl.setStyle('width', '');
  containerEl.setStyle('height', '');
  ownerContext.containerElContext = ownerContext.getEl('containerEl');
}, calculateOwnerHeightFromContentHeight:function(ownerContext, contentHeight) {
  var h = Ext.layout.component.Auto.prototype.calculateOwnerHeightFromContentHeight.call(this, ownerContext, contentHeight);
  return h + this.getHeightAdjustment();
}, calculateOwnerWidthFromContentWidth:function(ownerContext, contentWidth) {
  var w = Ext.layout.component.Auto.prototype.calculateOwnerWidthFromContentWidth.call(this, ownerContext, contentWidth);
  return w + this.getWidthAdjustment();
}, measureContentHeight:function(ownerContext) {
  return ownerContext.hasDomProp('containerLayoutDone') ? Ext.layout.component.Auto.prototype.measureContentHeight.call(this, ownerContext) : NaN;
}, measureContentWidth:function(ownerContext) {
  return ownerContext.hasDomProp('containerLayoutDone') ? Ext.layout.component.Auto.prototype.measureContentWidth.call(this, ownerContext) : NaN;
}, publishInnerHeight:function(ownerContext, height) {
  height -= this.getHeightAdjustment();
  ownerContext.containerElContext.setHeight(height);
}, publishInnerWidth:function(ownerContext, width) {
  width -= this.getWidthAdjustment();
  ownerContext.containerElContext.setWidth(width);
}, privates:{getHeightAdjustment:function() {
  var owner = this.owner, h = 0;
  if (owner.labelAlign === 'top' && owner.hasVisibleLabel()) {
    h += owner.labelEl.getHeight();
  }
  if (owner.msgTarget === 'under' && owner.hasActiveError()) {
    h += owner.errorWrapEl.getHeight();
  }
  return h + owner.bodyEl.getPadding('tb');
}, getWidthAdjustment:function() {
  var owner = this.owner, w = 0;
  if (owner.labelAlign !== 'top' && owner.hasVisibleLabel()) {
    w += owner.labelWidth + (owner.labelPad || 0);
  }
  if (owner.msgTarget === 'side' && owner.hasActiveError()) {
    w += owner.errorWrapEl.getWidth();
  }
  return w + owner.bodyEl.getPadding('lr');
}}}, 0, 0, 0, 0, ['layout.fieldcontainer'], 0, [Ext.layout.component.field, 'FieldContainer'], 0);
Ext.cmd.derive('Ext.form.FieldContainer', Ext.container.Container, {componentLayout:'fieldcontainer', componentCls:'x-form-fieldcontainer', shrinkWrap:true, autoEl:{tag:'div', role:'presentation'}, childEls:['containerEl'], combineLabels:false, labelConnector:', ', combineErrors:false, maskOnDisable:false, invalidCls:'', fieldSubTpl:['\x3cdiv id\x3d"{id}-containerEl" data-ref\x3d"containerEl" class\x3d"{containerElCls}"', '\x3ctpl if\x3d"ariaAttributes"\x3e', '\x3ctpl foreach\x3d"ariaAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e', 
'\x3ctpl else\x3e', ' role\x3d"presentation"', '\x3c/tpl\x3e', '\x3e', '{%this.renderContainer(out,values)%}', '\x3c/div\x3e'], initComponent:function() {
  var me = this;
  me.initLabelable();
  me.initFieldAncestor();
  Ext.container.Container.prototype.initComponent.call(this);
  me.initMonitor();
}, onAdd:function(labelItem) {
  var me = this;
  if (labelItem.isLabelable && Ext.isGecko && Ext.firefoxVersion < 37 && me.layout.type === 'absolute' && !me.hideLabel && me.labelAlign !== 'top') {
    labelItem.x += me.labelWidth + me.labelPad;
  }
  Ext.container.Container.prototype.onAdd.apply(this, arguments);
  if (labelItem.isLabelable && me.combineLabels) {
    labelItem.oldHideLabel = labelItem.hideLabel;
    labelItem.hideLabel = true;
  }
  me.updateLabel();
}, onRemove:function(labelItem, isDestroying) {
  var me = this;
  Ext.container.Container.prototype.onRemove.apply(this, arguments);
  if (!isDestroying) {
    if (labelItem.isLabelable && me.combineLabels) {
      labelItem.hideLabel = labelItem.oldHideLabel;
    }
    me.updateLabel();
  }
}, initRenderData:function() {
  var me = this, data = Ext.container.Container.prototype.initRenderData.call(this);
  data.containerElCls = me.containerElCls;
  data = Ext.applyIf(data, me.getLabelableRenderData());
  if (me.labelAlign === 'top' || me.msgTarget === 'under') {
    data.extraFieldBodyCls += ' x-field-container-body-vertical';
  }
  data.tipAnchorTarget = me.id + '-containerEl';
  return data;
}, getFieldLabel:function() {
  var label = this.fieldLabel || '';
  if (!label && this.combineLabels) {
    label = Ext.Array.map(this.query('[isFieldLabelable]'), function(field) {
      return field.getFieldLabel();
    }).join(this.labelConnector);
  }
  return label;
}, getSubTplData:function() {
  var ret = this.initRenderData();
  Ext.apply(ret, this.subTplData);
  return ret;
}, getSubTplMarkup:function(fieldData) {
  var me = this, tpl = me.lookupTpl('fieldSubTpl'), html;
  if (!tpl.renderContent) {
    me.setupRenderTpl(tpl);
  }
  html = tpl.apply(me.getSubTplData(fieldData));
  return html;
}, updateLabel:function() {
  var me = this, label = me.labelEl;
  if (label) {
    me.setFieldLabel(me.getFieldLabel());
  }
}, onFieldErrorChange:function() {
  if (this.combineErrors) {
    var me = this, oldError = me.getActiveError(), invalidFields = Ext.Array.filter(me.query('[isFormField]'), function(field) {
      return field.hasActiveError();
    }), newErrors = me.getCombinedErrors(invalidFields);
    if (newErrors) {
      me.setActiveErrors(newErrors);
    } else {
      me.unsetActiveError();
    }
    if (oldError !== me.getActiveError()) {
      me.updateLayout();
    }
  }
}, getCombinedErrors:function(invalidFields) {
  var errors = [], f, fLen = invalidFields.length, field, activeErrors, a, aLen, error, label;
  for (f = 0; f < fLen; f++) {
    field = invalidFields[f];
    activeErrors = field.getActiveErrors();
    aLen = activeErrors.length;
    for (a = 0; a < aLen; a++) {
      error = activeErrors[a];
      label = field.getFieldLabel();
      errors.push((label ? label + ': ' : '') + error);
    }
  }
  return errors;
}, privates:{applyTargetCls:function(targetCls) {
  var containerElCls = this.containerElCls;
  this.containerElCls = containerElCls ? containerElCls + ' ' + targetCls : targetCls;
}, getTargetEl:function() {
  return this.containerEl;
}, initRenderTpl:function() {
  var me = this;
  if (!me.hasOwnProperty('renderTpl')) {
    me.renderTpl = me.lookupTpl('labelableRenderTpl');
  }
  return Ext.container.Container.prototype.initRenderTpl.call(this);
}}}, 0, ['fieldcontainer'], ['component', 'box', 'container', 'fieldcontainer'], {'component':true, 'box':true, 'container':true, 'fieldcontainer':true}, ['widget.fieldcontainer'], [['labelable', Ext.form.Labelable], ['fieldAncestor', Ext.form.FieldAncestor]], [Ext.form, 'FieldContainer'], 0);
Ext.cmd.derive('Ext.layout.container.CheckboxGroup', Ext.layout.container.Container, {autoFlex:true, type:'checkboxgroup', createsInnerCt:true, childEls:['innerCt'], renderTpl:'\x3ctable id\x3d"{ownerId}-innerCt" data-ref\x3d"innerCt" class\x3d"x-table-plain" cellpadding\x3d"0"role\x3d"presentation" style\x3d"{tableStyle}"\x3e\x3ctbody role\x3d"presentation"\x3e\x3ctr role\x3d"presentation"\x3e\x3ctpl for\x3d"columns"\x3e\x3ctd class\x3d"{parent.colCls}" valign\x3d"top" style\x3d"{style}" role\x3d"presentation"\x3e{% this.renderColumn(out,parent,xindex-1) %}\x3c/td\x3e\x3c/tpl\x3e\x3c/tr\x3e\x3c/tbody\x3e\x3c/table\x3e', 
lastOwnerItemsGeneration:null, initLayout:function() {
  var me = this, owner = me.owner;
  me.columnsArray = Ext.isArray(owner.columns);
  me.autoColumns = !owner.columns || owner.columns === 'auto';
  if (!me.autoColumns) {
    me.vertical = owner.vertical || (owner.columns === 1 || owner.columns.length === 1);
  }
  Ext.layout.container.Container.prototype.initLayout.call(this);
}, beginLayout:function(ownerContext) {
  var me = this, columns, numCols, i, width, cwidth, totalFlex = 0, flexedCols = 0, autoFlex = me.autoFlex, innerCtStyle = me.innerCt.dom.style;
  Ext.layout.container.Container.prototype.beginLayout.apply(this, arguments);
  columns = me.rowNodes[0].children;
  ownerContext.innerCtContext = ownerContext.getEl('innerCt', me);
  if (!ownerContext.widthModel.shrinkWrap) {
    numCols = columns.length;
    if (me.columnsArray) {
      for (i = 0; i < numCols; i++) {
        width = me.owner.columns[i];
        if (width < 1) {
          totalFlex += width;
          flexedCols++;
        }
      }
      for (i = 0; i < numCols; i++) {
        width = me.owner.columns[i];
        if (width < 1) {
          cwidth = width / totalFlex * 100 + '%';
        } else {
          cwidth = width + 'px';
        }
        columns[i].style.width = cwidth;
      }
    } else {
      for (i = 0; i < numCols; i++) {
        cwidth = autoFlex ? 1 / numCols * 100 + '%' : '';
        columns[i].style.width = cwidth;
        flexedCols++;
      }
    }
    if (!flexedCols) {
      innerCtStyle.tableLayout = 'fixed';
      innerCtStyle.width = '';
    } else {
      if (flexedCols < numCols) {
        innerCtStyle.tableLayout = 'fixed';
        innerCtStyle.width = '100%';
      } else {
        innerCtStyle.tableLayout = 'auto';
        if (autoFlex) {
          innerCtStyle.width = '100%';
        } else {
          innerCtStyle.width = '';
        }
      }
    }
  } else {
    innerCtStyle.tableLayout = 'auto';
    innerCtStyle.width = '';
  }
}, cacheElements:function() {
  var me = this;
  Ext.layout.container.Container.prototype.cacheElements.call(this);
  me.rowNodes = me.innerCt.query('tr', true);
  me.tBodyNode = me.rowNodes[0].parentNode;
}, calculate:function(ownerContext) {
  var me = this, targetContext, widthShrinkWrap, heightShrinkWrap, shrinkWrap, table, targetPadding;
  if (!ownerContext.getDomProp('containerChildrenSizeDone')) {
    me.done = false;
  } else {
    targetContext = ownerContext.innerCtContext;
    widthShrinkWrap = ownerContext.widthModel.shrinkWrap;
    heightShrinkWrap = ownerContext.heightModel.shrinkWrap;
    shrinkWrap = heightShrinkWrap || widthShrinkWrap;
    table = targetContext.el.dom;
    targetPadding = shrinkWrap && targetContext.getPaddingInfo();
    if (widthShrinkWrap) {
      ownerContext.setContentWidth(table.offsetWidth + targetPadding.width, true);
    }
    if (heightShrinkWrap) {
      ownerContext.setContentHeight(table.offsetHeight + targetPadding.height, true);
    }
  }
}, doRenderColumn:function(out, renderData, columnIndex) {
  var me = renderData.$layout, owner = me.owner, columnCount = renderData.columnCount, items = owner.items.items, itemCount = items.length, item, itemIndex, rowCount, increment, tree;
  if (owner.vertical) {
    rowCount = Math.ceil(itemCount / columnCount);
    itemIndex = columnIndex * rowCount;
    itemCount = Math.min(itemCount, itemIndex + rowCount);
    increment = 1;
  } else {
    itemIndex = columnIndex;
    increment = columnCount;
  }
  for (; itemIndex < itemCount; itemIndex += increment) {
    item = items[itemIndex];
    me.configureItem(item);
    tree = item.getRenderTree();
    Ext.DomHelper.generateMarkup(tree, out);
  }
}, getColumnCount:function() {
  var me = this, owner = me.owner, ownerColumns = owner.columns;
  if (me.columnsArray) {
    return ownerColumns.length;
  }
  if (Ext.isNumber(ownerColumns)) {
    return ownerColumns;
  }
  return owner.items.length;
}, getItemSizePolicy:function(item) {
  return this.autoSizePolicy;
}, getRenderData:function() {
  var me = this, data = Ext.layout.container.Container.prototype.getRenderData.call(this), owner = me.owner, i, columns = me.getColumnCount(), width, column, cwidth, autoFlex = me.autoFlex, totalFlex = 0, flexedCols = 0;
  if (me.columnsArray) {
    for (i = 0; i < columns; i++) {
      width = me.owner.columns[i];
      if (width < 1) {
        totalFlex += width;
        flexedCols++;
      }
    }
  }
  data.colCls = owner.groupCls;
  data.columnCount = columns;
  data.columns = [];
  for (i = 0; i < columns; i++) {
    column = data.columns[i] = {};
    if (me.columnsArray) {
      width = me.owner.columns[i];
      if (width < 1) {
        cwidth = width / totalFlex * 100 + '%';
      } else {
        cwidth = width + 'px';
      }
      column.style = 'width:' + cwidth;
    } else {
      column.style = 'width:' + 1 / columns * 100 + '%';
      flexedCols++;
    }
  }
  data.tableStyle = !flexedCols ? 'table-layout:fixed;' : flexedCols < columns ? 'table-layout:fixed;width:100%' : autoFlex ? 'table-layout:auto;width:100%' : 'table-layout:auto;';
  return data;
}, isValidParent:Ext.returnTrue, setupRenderTpl:function(renderTpl) {
  Ext.layout.container.Container.prototype.setupRenderTpl.apply(this, arguments);
  renderTpl.renderColumn = this.doRenderColumn;
}, renderChildren:function() {
  var me = this, generation = me.owner.items.generation;
  if (me.lastOwnerItemsGeneration !== generation) {
    me.lastOwnerItemsGeneration = generation;
    me.renderItems(me.getLayoutItems());
  }
}, renderItems:function(items) {
  var me = this, itemCount = items.length, item, rowCount, columnCount, rowIndex, columnIndex, i;
  if (itemCount) {
    Ext.suspendLayouts();
    if (me.autoColumns) {
      columnCount = itemCount;
      rowCount = 1;
    } else {
      columnCount = me.columnsArray ? me.owner.columns.length : me.owner.columns;
      rowCount = Math.ceil(itemCount / columnCount);
    }
    for (i = 0; i < itemCount; i++) {
      item = items[i];
      rowIndex = me.getRenderRowIndex(i, rowCount, columnCount);
      columnIndex = me.getRenderColumnIndex(i, rowCount, columnCount);
      if (!item.rendered) {
        me.renderItem(item, rowIndex, columnIndex);
      } else {
        if (!me.isItemAtPosition(item, rowIndex, columnIndex)) {
          me.moveItem(item, rowIndex, columnIndex);
        }
      }
    }
    me.pruneRows(rowCount, columnCount);
    Ext.resumeLayouts(true);
  }
}, isItemAtPosition:function(item, rowIndex, columnIndex) {
  return item.el.dom === this.getItemNodeAt(rowIndex, columnIndex);
}, getRenderColumnIndex:function(itemIndex, rowCount, columnCount) {
  if (this.vertical) {
    return Math.floor(itemIndex / rowCount);
  } else {
    return itemIndex % columnCount;
  }
}, getRenderRowIndex:function(itemIndex, rowCount, columnCount) {
  if (this.vertical) {
    return itemIndex % rowCount;
  } else {
    return Math.floor(itemIndex / columnCount);
  }
}, getItemNodeAt:function(rowIndex, columnIndex) {
  var column = this.getColumnNodeAt(rowIndex, columnIndex);
  return this.vertical ? column.children[rowIndex] : column.children[0];
}, getRowNodeAt:function(rowIndex) {
  var me = this, row;
  rowIndex = me.vertical ? 0 : rowIndex;
  row = me.rowNodes[rowIndex];
  if (!row) {
    row = me.rowNodes[rowIndex] = document.createElement('tr');
    row.role = 'presentation';
    me.tBodyNode.appendChild(row);
  }
  return row;
}, getColumnNodeAt:function(rowIndex, columnIndex, row) {
  var column;
  row = row || this.getRowNodeAt(rowIndex);
  column = row.children[columnIndex];
  if (!column) {
    column = Ext.fly(row).appendChild({tag:'td', cls:this.owner.groupCls, vAlign:'top', role:'presentation'}, true);
  }
  return column;
}, pruneRows:function(rowCount, columnCount) {
  var me = this, rows = me.tBodyNode.children, columns, row, column, i, j;
  rowCount = me.vertical ? 1 : rowCount;
  while (rows.length > rowCount) {
    row = rows[rows.length - 1];
    while (row.children.length) {
      Ext.get(row.children[0]).destroy();
    }
    row.parentNode.removeChild(row);
  }
  for (i = rowCount - 1; i >= 0; i--) {
    row = rows[i];
    columns = row.children;
    while (columns.length > columnCount) {
      column = columns[columns.length - 1];
      Ext.get(column).destroy();
    }
    if (i > 0) {
      for (j = columns.length - 1; j >= 0; j--) {
        column = columns[j];
        if (column.children.length === 0) {
          Ext.get(column).destroy();
        } else {
          break;
        }
      }
    }
  }
}, renderItem:function(item, rowIndex, columnIndex) {
  var me = this, column, itemIndex;
  me.configureItem(item);
  itemIndex = me.vertical ? rowIndex : 0;
  column = Ext.get(me.getColumnNodeAt(rowIndex, columnIndex));
  item.render(column, itemIndex);
}, moveItem:function(item, rowIndex, columnIndex) {
  var me = this, column, itemIndex, targetNode;
  itemIndex = me.vertical ? rowIndex : 0;
  column = me.getColumnNodeAt(rowIndex, columnIndex);
  targetNode = column.children[itemIndex];
  column.insertBefore(item.el.dom, targetNode || null);
}, destroy:function() {
  if (this.owner.rendered) {
    var target = this.getRenderTarget(), cells, i, len;
    if (target) {
      cells = target.query('.' + this.owner.groupCls, false);
      for (i = 0, len = cells.length; i < len; i++) {
        cells[i].destroy();
      }
    }
  }
  Ext.layout.container.Container.prototype.destroy.call(this);
}}, 0, 0, 0, 0, ['layout.checkboxgroup'], 0, [Ext.layout.container, 'CheckboxGroup'], 0);
Ext.cmd.derive('Ext.form.CheckboxManager', Ext.util.MixedCollection, {singleton:true, getByName:function(name, formId) {
  return this.filterBy(function(item) {
    return item.name === name && item.getFormId() === formId;
  });
}}, 0, 0, 0, 0, 0, 0, [Ext.form, 'CheckboxManager'], 0);
Ext.cmd.derive('Ext.form.field.Checkbox', Ext.form.field.Base, {alternateClassName:'Ext.form.Checkbox', modelValue:true, modelValueUnchecked:false, stretchInputElFixed:false, childEls:['boxLabelEl', 'innerWrapEl', 'displayEl'], fieldSubTpl:['\x3cdiv id\x3d"{cmpId}-innerWrapEl" data-ref\x3d"innerWrapEl" role\x3d"presentation"', ' class\x3d"{wrapInnerCls}"\x3e', '\x3ctpl if\x3d"labelAlignedBefore"\x3e', '{beforeBoxLabelTpl}', '\x3clabel id\x3d"{cmpId}-boxLabelEl" data-ref\x3d"boxLabelEl" {boxLabelAttrTpl} class\x3d"{boxLabelCls} ', 
'{boxLabelCls}-{ui} {boxLabelCls}-{boxLabelAlign} {noBoxLabelCls} {childElCls}" for\x3d"{id}"\x3e', '{beforeBoxLabelTextTpl}', '{boxLabel}', '{afterBoxLabelTextTpl}', '\x3c/label\x3e', '{afterBoxLabelTpl}', '\x3c/tpl\x3e', '\x3cspan id\x3d"{cmpId}-displayEl" data-ref\x3d"displayEl" role\x3d"presentation" class\x3d"{fieldCls} {typeCls} ', '{typeCls}-{ui} {inputCls} {inputCls}-{ui} {fixCls} {childElCls} {afterLabelCls}"\x3e', '\x3cinput type\x3d"{inputType}" id\x3d"{id}" name\x3d"{inputName}" data-ref\x3d"inputEl" {inputAttrTpl}', 
'\x3ctpl if\x3d"tabIdx !\x3d null"\x3e tabindex\x3d"{tabIdx}"\x3c/tpl\x3e', '\x3ctpl if\x3d"disabled"\x3e disabled\x3d"disabled"\x3c/tpl\x3e', '\x3ctpl if\x3d"checked"\x3e checked\x3d"checked"\x3c/tpl\x3e', '\x3ctpl if\x3d"fieldStyle"\x3e style\x3d"{fieldStyle}"\x3c/tpl\x3e', ' class\x3d"{checkboxCls}" autocomplete\x3d"off" hidefocus\x3d"true" ', '\x3ctpl foreach\x3d"ariaElAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e', '\x3ctpl foreach\x3d"inputElAriaAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e', '/\x3e', 
'\x3c/span\x3e', '\x3ctpl if\x3d"!labelAlignedBefore"\x3e', '{beforeBoxLabelTpl}', '\x3clabel id\x3d"{cmpId}-boxLabelEl" data-ref\x3d"boxLabelEl" {boxLabelAttrTpl} class\x3d"{boxLabelCls} ', '{boxLabelCls}-{ui} {boxLabelCls}-{boxLabelAlign} {noBoxLabelCls} {childElCls}" for\x3d"{id}"\x3e', '{beforeBoxLabelTextTpl}', '{boxLabel}', '{afterBoxLabelTextTpl}', '\x3c/label\x3e', '{afterBoxLabelTpl}', '\x3c/tpl\x3e', '\x3c/div\x3e', {disableFormats:true, compiled:true}], publishes:{checked:1}, subTplInsertions:['beforeBoxLabelTpl', 
'afterBoxLabelTpl', 'beforeBoxLabelTextTpl', 'afterBoxLabelTextTpl', 'boxLabelAttrTpl', 'inputAttrTpl'], isCheckbox:true, focusCls:'form-checkbox-focus', fieldBodyCls:'x-form-cb-wrap', checked:false, checkedCls:'x-form-cb-checked', boxLabelCls:'x-form-cb-label', boxLabelAlign:'after', afterLabelCls:'x-form-cb-after', wrapInnerCls:'x-form-cb-wrap-inner', noBoxLabelCls:'x-form-cb-no-box-label', inputValue:'on', checkChangeEvents:[], changeEventName:'change', inputType:'checkbox', isTextInput:false, 
ariaRole:'native', onRe:/^on$/i, inputCls:'x-form-cb', _checkboxCls:'x-form-cb-input', initComponent:function() {
  var me = this, value = me.value;
  if (value !== undefined) {
    me.checked = me.isChecked(value, me.inputValue);
  }
  Ext.form.field.Base.prototype.initComponent.call(this);
  me.getManager().add(me);
}, initDefaultName:Ext.emptyFn, initValue:function() {
  var me = this, checked = !!me.checked;
  me.originalValue = me.initialValue = me.lastValue = checked;
  me.setValue(checked);
}, getElConfig:function() {
  var me = this;
  if (me.isChecked(me.rawValue, me.inputValue)) {
    me.addCls(me.checkedCls);
  }
  if (!me.fieldLabel) {
    me.skipLabelForAttribute = true;
  }
  return Ext.form.field.Base.prototype.getElConfig.call(this);
}, getModelData:function() {
  var me = this, o = Ext.form.field.Base.prototype.getModelData.apply(this, arguments);
  if (o) {
    o[me.getName()] = me.checked ? me.modelValue : me.modelValueUnchecked;
  }
  return o;
}, getSubTplData:function(fieldData) {
  var me = this, boxLabel = me.boxLabel, boxLabelAlign = me.boxLabelAlign, labelAlignedBefore = boxLabelAlign === 'before', data, inputElAttr;
  data = Ext.apply(Ext.form.field.Base.prototype.getSubTplData.call(this, fieldData), {inputType:me.inputType, checkboxCls:me._checkboxCls, disabled:me.readOnly || me.disabled, checked:!!me.checked, wrapInnerCls:me.wrapInnerCls, boxLabel:boxLabel, boxLabelCls:me.boxLabelCls, boxLabelAlign:boxLabelAlign, labelAlignedBefore:labelAlignedBefore, afterLabelCls:labelAlignedBefore ? me.afterLabelCls : '', noBoxLabelCls:!boxLabel ? me.noBoxLabelCls : '', inputName:me.name || me.id});
  inputElAttr = data.inputElAriaAttributes;
  if (inputElAttr) {
    delete inputElAttr['aria-readonly'];
  }
  return data;
}, initEvents:function() {
  var me = this;
  Ext.form.field.Base.prototype.initEvents.call(this);
  me.inputEl.on(me.changeEventName, me.onChangeEvent, me, {delegated:false});
  if (Ext.isIE) {
    me.bodyEl.on('mousedown', me.onBodyElMousedown, me);
  } else {
    if (Ext.isMac && (Ext.isGecko || Ext.isSafari)) {
      me.boxLabelEl.on('mousedown', me.onBoxLabelOrInputMousedown, me);
      me.inputEl.on('mousedown', me.onBoxLabelOrInputMousedown, me);
    }
  }
}, setBoxLabel:function(boxLabel) {
  var me = this;
  me.boxLabel = boxLabel;
  if (me.rendered) {
    me.boxLabelEl.setHtml(boxLabel);
    me.boxLabelEl[boxLabel ? 'removeCls' : 'addCls'](me.noBoxLabelCls);
    me.updateLayout();
  }
}, onBodyElMousedown:function(e) {
  if (e.target !== this.inputEl.dom) {
    e.preventDefault();
  }
}, onBoxLabelOrInputMousedown:function(e) {
  this.inputEl.focus();
  e.preventDefault();
}, onChangeEvent:function(e) {
  this.updateValueFromDom();
}, updateValueFromDom:function() {
  var me = this, inputEl = me.inputEl && me.inputEl.dom;
  if (inputEl) {
    me.checked = me.rawValue = me.value = inputEl.checked;
    me.checkChange();
  }
}, updateCheckedCls:function(checked) {
  var me = this;
  checked = checked != null ? checked : me.getValue();
  me[checked ? 'addCls' : 'removeCls'](me.checkedCls);
}, getRawValue:function() {
  var inputEl = this.inputEl && this.inputEl.dom;
  return inputEl ? inputEl.checked : this.checked;
}, getValue:function() {
  var inputEl = this.inputEl && this.inputEl.dom;
  return inputEl ? inputEl.checked : this.checked;
}, getSubmitValue:function() {
  var unchecked = this.uncheckedValue, uncheckedVal = Ext.isDefined(unchecked) ? unchecked : null;
  return this.getValue() ? this.inputValue : uncheckedVal;
}, isChecked:function(rawValue, inputValue) {
  var ret = false;
  if (rawValue === true || rawValue === 'true') {
    ret = true;
  } else {
    if (inputValue !== 'on' && (inputValue || inputValue === 0) && (Ext.isString(rawValue) || Ext.isNumber(rawValue))) {
      ret = rawValue == inputValue;
    } else {
      ret = rawValue === '1' || rawValue === 1 || this.onRe.test(rawValue);
    }
  }
  return ret;
}, setRawValue:function(value) {
  var me = this, inputEl = me.inputEl && me.inputEl.dom, checked = me.isChecked(value, me.inputValue);
  if (inputEl) {
    me.duringSetRawValue = true;
    inputEl.checked = checked;
    me.duringSetRawValue = false;
    me.updateCheckedCls(checked);
  }
  me.checked = me.rawValue = checked;
  if (!me.duringSetValue) {
    me.lastValue = checked;
  }
  return checked;
}, setValue:function(checked) {
  var me = this, boxes, i, len, box;
  if (Ext.isArray(checked)) {
    boxes = me.getManager().getByName(me.name, me.getFormId()).items;
    len = boxes.length;
    for (i = 0; i < len; ++i) {
      box = boxes[i];
      box.setValue(Ext.Array.contains(checked, box.inputValue));
    }
  } else {
    me.duringSetValue = true;
    Ext.form.field.Base.prototype.setValue.apply(this, arguments);
    delete me.duringSetValue;
  }
  return me;
}, valueToRaw:Ext.identityFn, onChange:function(newVal, oldVal) {
  var me = this, handler = me.handler;
  me.updateCheckedCls(newVal);
  if (handler) {
    Ext.callback(handler, me.scope, [me, newVal], 0, me);
  }
  Ext.form.field.Base.prototype.onChange.apply(this, arguments);
  if (me.reference && me.publishState) {
    me.publishState('checked', newVal);
  }
}, resetOriginalValue:function(fromBoxInGroup) {
  var me = this, boxes, box, len, i;
  if (!fromBoxInGroup) {
    boxes = me.getManager().getByName(me.name, me.getFormId()).items;
    len = boxes.length;
    for (i = 0; i < len; ++i) {
      box = boxes[i];
      if (box !== me) {
        boxes[i].resetOriginalValue(true);
      }
    }
  }
  Ext.form.field.Base.prototype.resetOriginalValue.call(this);
}, doDestroy:function() {
  this.getManager().removeAtKey(this.id);
  Ext.form.field.Base.prototype.doDestroy.call(this);
}, getManager:function() {
  return Ext.form.CheckboxManager;
}, onEnable:function() {
  var me = this, inputEl = me.inputEl && me.inputEl.dom;
  Ext.form.field.Base.prototype.onEnable.call(this);
  if (inputEl) {
    inputEl.disabled = me.readOnly;
  }
}, setReadOnly:function(readOnly) {
  var me = this, inputEl = me.inputEl && me.inputEl.dom;
  if (inputEl) {
    inputEl.disabled = !!readOnly || me.disabled;
  }
  Ext.form.field.Base.prototype.setReadOnly.apply(this, arguments);
}, getFormId:function() {
  var me = this, form;
  if (!me.formId) {
    form = me.up('form');
    if (form) {
      me.formId = form.id;
    }
  }
  return me.formId;
}, getFocusClsEl:function() {
  return this.displayEl;
}}, 0, ['checkbox', 'checkboxfield'], ['component', 'box', 'field', 'checkboxfield', 'checkbox'], {'component':true, 'box':true, 'field':true, 'checkboxfield':true, 'checkbox':true}, ['widget.checkbox', 'widget.checkboxfield'], 0, [Ext.form.field, 'Checkbox', Ext.form, 'Checkbox'], 0);
Ext.define('Ext.theme.triton.form.field.Checkbox', {override:'Ext.form.field.Checkbox', compatibility:Ext.isIE8, initComponent:function() {
  (arguments.callee.$previous || Ext.form.field.Base.prototype.initComponent).call(this);
  Ext.on({show:'onGlobalShow', scope:this});
}, onFocus:function(e) {
  var focusClsEl;
  (arguments.callee.$previous || Ext.form.field.Base.prototype.onFocus).call(this, e);
  focusClsEl = this.getFocusClsEl();
  if (focusClsEl) {
    focusClsEl.syncRepaint();
  }
}, onBlur:function(e) {
  var focusClsEl;
  (arguments.callee.$previous || Ext.form.field.Base.prototype.onBlur).call(this, e);
  focusClsEl = this.getFocusClsEl();
  if (focusClsEl) {
    focusClsEl.syncRepaint();
  }
}, onGlobalShow:function(cmp) {
  if (cmp.isAncestor(this)) {
    this.getFocusClsEl().syncRepaint();
  }
}});
Ext.cmd.derive('Ext.form.CheckboxGroup', Ext.form.FieldContainer, {isCheckboxGroup:true, columns:'auto', vertical:false, allowBlank:true, blankText:'You must select at least one item in this group', defaultType:'checkboxfield', defaultBindProperty:'value', groupCls:'x-form-check-group', extraFieldBodyCls:'x-form-checkboxgroup-body', layout:'checkboxgroup', componentCls:'x-form-checkboxgroup', ariaRole:'group', ariaEl:'containerEl', skipLabelForAttribute:true, ariaRenderAttributes:{'aria-invalid':false}, 
initComponent:function() {
  var me = this;
  me.name = me.name || me.id;
  Ext.form.FieldContainer.prototype.initComponent.call(this);
  me.initField();
}, initRenderData:function() {
  var me = this, data, ariaAttr, boxes, i, len, ids;
  data = Ext.form.FieldContainer.prototype.initRenderData.call(this);
  data.inputId = me.id + '-' + me.ariaEl;
  ariaAttr = data.ariaAttributes;
  if (ariaAttr) {
    if (!ariaAttr['aria-labelledby']) {
      ariaAttr['aria-labelledby'] = me.id + '-labelTextEl';
    }
  }
  return data;
}, initValue:function() {
  var me = this, valueCfg = me.value;
  me.originalValue = me.lastValue = valueCfg || me.getValue();
  if (valueCfg) {
    me.setValue(valueCfg);
  }
}, onAdd:function(field) {
  var me = this, items, len, i;
  if (field.isCheckbox) {
    if (field.name == null) {
      field.name = me.name;
    }
    me.mon(field, 'change', me.checkChange, me);
  } else {
    if (field.isContainer) {
      items = field.items.items;
      for (i = 0, len = items.length; i < len; i++) {
        me.onAdd(items[i]);
      }
    }
  }
  Ext.form.FieldContainer.prototype.onAdd.apply(this, arguments);
}, onRemove:function(item) {
  var me = this, items, len, i;
  if (item.isCheckbox) {
    me.mun(item, 'change', me.checkChange, me);
  } else {
    if (item.isContainer) {
      items = item.items.items;
      for (i = 0, len = items.length; i < len; i++) {
        me.onRemove(items[i]);
      }
    }
  }
  Ext.form.FieldContainer.prototype.onRemove.apply(this, arguments);
}, isEqual:function(value1, value2) {
  var toQueryString = Ext.Object.toQueryString;
  return toQueryString(value1) === toQueryString(value2);
}, getErrors:function() {
  var errors = [];
  if (!this.allowBlank && Ext.isEmpty(this.getChecked())) {
    errors.push(this.blankText);
  }
  return errors;
}, getBoxes:function(query) {
  return this.query('[isCheckbox]' + (query || ''));
}, eachBox:function(fn, scope) {
  Ext.Array.forEach(this.getBoxes(), fn, scope || this);
}, getChecked:function() {
  return this.getBoxes('[checked]');
}, isDirty:function() {
  var boxes = this.getBoxes(), b, bLen = boxes.length;
  for (b = 0; b < bLen; b++) {
    if (boxes[b].isDirty()) {
      return true;
    }
  }
}, setReadOnly:function(readOnly) {
  var boxes = this.getBoxes(), b, bLen = boxes.length;
  for (b = 0; b < bLen; b++) {
    boxes[b].setReadOnly(readOnly);
  }
  this.readOnly = readOnly;
}, reset:function() {
  var me = this, hadError = me.hasActiveError(), preventMark = me.preventMark;
  me.preventMark = true;
  me.batchChanges(function() {
    var boxes = me.getBoxes(), b, bLen = boxes.length;
    for (b = 0; b < bLen; b++) {
      boxes[b].reset();
    }
  });
  me.preventMark = preventMark;
  me.unsetActiveError();
  if (hadError) {
    me.updateLayout();
  }
}, resetOriginalValue:function() {
  var me = this, boxes = me.getBoxes(), b, bLen = boxes.length;
  for (b = 0; b < bLen; b++) {
    boxes[b].resetOriginalValue();
  }
  me.originalValue = me.getValue();
  me.checkDirty();
}, setValue:function(value) {
  var me = this, boxes = me.getBoxes(), b, bLen = boxes.length, box, name, cbValue;
  me.batchChanges(function() {
    Ext.suspendLayouts();
    for (b = 0; b < bLen; b++) {
      box = boxes[b];
      name = box.getName();
      cbValue = false;
      if (value) {
        if (Ext.isArray(value[name])) {
          cbValue = Ext.Array.contains(value[name], box.inputValue);
        } else {
          cbValue = value[name];
        }
      }
      box.setValue(cbValue);
    }
    Ext.resumeLayouts(true);
  });
  return me;
}, getValue:function() {
  var values = {}, boxes = this.getBoxes(), b, bLen = boxes.length, box, name, inputValue, bucket;
  for (b = 0; b < bLen; b++) {
    box = boxes[b];
    name = box.getName();
    inputValue = box.inputValue;
    if (box.getValue()) {
      if (values.hasOwnProperty(name)) {
        bucket = values[name];
        if (!Ext.isArray(bucket)) {
          bucket = values[name] = [bucket];
        }
        bucket.push(inputValue);
      } else {
        values[name] = inputValue;
      }
    }
  }
  return values;
}, getSubmitData:function() {
  return null;
}, getModelData:function() {
  return null;
}, validate:function() {
  var me = this, errors, isValid, wasValid;
  if (me.disabled) {
    isValid = true;
  } else {
    errors = me.getErrors();
    isValid = Ext.isEmpty(errors);
    wasValid = me.wasValid;
    if (isValid) {
      me.unsetActiveError();
    } else {
      me.setActiveError(errors);
    }
  }
  if (isValid !== wasValid) {
    me.wasValid = isValid;
    me.fireEvent('validitychange', me, isValid);
    me.updateLayout();
  }
  return isValid;
}}, 0, ['checkboxgroup'], ['component', 'box', 'container', 'fieldcontainer', 'checkboxgroup'], {'component':true, 'box':true, 'container':true, 'fieldcontainer':true, 'checkboxgroup':true}, ['widget.checkboxgroup'], [['field', Ext.form.field.Field]], [Ext.form, 'CheckboxGroup'], function() {
  this.borrow(Ext.form.field.Base, ['markInvalid', 'clearInvalid', 'setError']);
});
Ext.cmd.derive('Ext.form.Label', Ext.Component, {autoEl:'label', maskOnDisable:false, getElConfig:function() {
  var me = this;
  me.html = me.text ? Ext.util.Format.htmlEncode(me.text) : me.html || '';
  return Ext.apply(Ext.Component.prototype.getElConfig.call(this), {htmlFor:me.forId || ''});
}, setText:function(text, encode) {
  var me = this;
  encode = encode !== false;
  if (encode) {
    me.text = text;
    delete me.html;
  } else {
    me.html = text;
    delete me.text;
  }
  if (me.rendered) {
    me.el.dom.innerHTML = encode !== false ? Ext.util.Format.htmlEncode(text) : text;
    me.updateLayout();
  }
  return me;
}}, 0, ['label'], ['component', 'box', 'label'], {'component':true, 'box':true, 'label':true}, ['widget.label'], 0, [Ext.form, 'Label'], 0);
Ext.cmd.derive('Ext.form.Panel', Ext.panel.Panel, {alternateClassName:['Ext.FormPanel', 'Ext.form.FormPanel'], layout:'anchor', bodyAriaRole:'form', basicFormConfigs:['api', 'baseParams', 'errorReader', 'jsonSubmit', 'method', 'paramOrder', 'paramsAsHash', 'reader', 'standardSubmit', 'timeout', 'trackResetOnLoad', 'url', 'waitMsgTarget', 'waitTitle'], initComponent:function() {
  var me = this;
  if (me.frame) {
    me.border = false;
  }
  me.initFieldAncestor();
  Ext.panel.Panel.prototype.initComponent.call(this);
  me.relayEvents(me.form, ['beforeaction', 'actionfailed', 'actioncomplete', 'validitychange', 'dirtychange']);
  if (me.pollForChanges) {
    me.startPolling(me.pollInterval || 500);
  }
}, initItems:function() {
  Ext.panel.Panel.prototype.initItems.call(this);
  this.initMonitor();
  this.form = this.createForm();
}, afterFirstLayout:function() {
  Ext.panel.Panel.prototype.afterFirstLayout.apply(this, arguments);
  this.form.initialize();
}, createForm:function() {
  var cfg = {}, props = this.basicFormConfigs, len = props.length, i = 0, prop;
  for (; i < len; ++i) {
    prop = props[i];
    cfg[prop] = this[prop];
  }
  return new Ext.form.Basic(this, cfg);
}, getForm:function() {
  return this.form;
}, loadRecord:function(record) {
  return this.getForm().loadRecord(record);
}, getRecord:function() {
  return this.getForm().getRecord();
}, updateRecord:function(record) {
  return this.getForm().updateRecord(record);
}, getValues:function(asString, dirtyOnly, includeEmptyText, useDataValues) {
  return this.getForm().getValues(asString, dirtyOnly, includeEmptyText, useDataValues);
}, isDirty:function() {
  return this.form.isDirty();
}, isValid:function() {
  return this.form.isValid();
}, reset:function(resetRecord) {
  return this.form.reset(resetRecord);
}, hasInvalidField:function() {
  return this.form.hasInvalidField();
}, doDestroy:function() {
  this.stopPolling();
  this.form.destroy();
  Ext.panel.Panel.prototype.doDestroy.call(this);
}, load:function(options) {
  this.form.load(options);
}, submit:function(options) {
  this.form.submit(options);
}, startPolling:function(interval) {
  this.stopPolling();
  this.pollTask = Ext.util.TaskManager.start({interval:interval, run:this.checkChange, scope:this});
}, stopPolling:function() {
  var task = this.pollTask;
  if (task) {
    Ext.util.TaskManager.stop(task, true);
    this.pollTask = null;
  }
}, checkChange:function() {
  var fields = this.form.getFields().items, f, fLen = fields.length;
  for (f = 0; f < fLen; f++) {
    fields[f].checkChange();
  }
}}, 0, ['form'], ['component', 'box', 'container', 'panel', 'form'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true}, ['widget.form'], [['fieldAncestor', Ext.form.FieldAncestor]], [Ext.form, 'Panel', Ext, 'FormPanel', Ext.form, 'FormPanel'], 0);
Ext.cmd.derive('Ext.form.field.Picker', Ext.form.field.Text, {alternateClassName:'Ext.form.Picker', config:{triggers:{picker:{handler:'onTriggerClick', scope:'this', focusOnMousedown:true}}}, renderConfig:{editable:true}, keyMap:{scope:'this', DOWN:'onDownArrow', ESC:'onEsc'}, keyMapTarget:'inputEl', isPickerField:true, matchFieldWidth:true, pickerAlign:'tl-bl?', openCls:'x-pickerfield-open', isExpanded:false, applyTriggers:function(triggers) {
  var me = this, picker = triggers.picker;
  if (!picker.cls) {
    picker.cls = me.triggerCls;
  }
  return Ext.form.field.Text.prototype.applyTriggers.call(this, triggers);
}, getSubTplData:function(fieldData) {
  var me = this, data, ariaAttr;
  data = Ext.form.field.Text.prototype.getSubTplData.call(this, fieldData);
  if (!me.ariaStaticRoles[me.ariaRole]) {
    ariaAttr = data.ariaElAttributes;
    if (ariaAttr) {
      ariaAttr['aria-haspopup'] = true;
      ariaAttr['aria-expanded'] = false;
    }
  }
  return data;
}, initEvents:function() {
  Ext.form.field.Text.prototype.initEvents.call(this);
  if (Ext.isGecko) {
    this.inputEl.dom.setAttribute('autocomplete', 'off');
  }
}, updateEditable:function(editable, oldEditable) {
  var me = this;
  if (!editable) {
    me.inputEl.on('click', me.onInputElClick, me);
  } else {
    me.inputEl.un('click', me.onInputElClick, me);
  }
  Ext.form.field.Text.prototype.updateEditable.call(this, editable, oldEditable);
}, onEsc:function(e) {
  if (Ext.isIE) {
    e.preventDefault();
  }
  if (this.isExpanded) {
    this.collapse();
    e.stopEvent();
  }
}, onDownArrow:function(e) {
  var me = this;
  if (e.time - me.lastDownArrow > 150) {
    delete me.lastDownArrow;
  }
  if (!me.isExpanded) {
    e.stopEvent();
    me.onTriggerClick(me, me.getPickerTrigger(), e);
    me.lastDownArrow = e.time;
  } else {
    if (!e.stopped && e.time - me.lastDownArrow < 150) {
      delete me.lastDownArrow;
    }
  }
}, expand:function() {
  var me = this, bodyEl, picker, doc;
  if (me.rendered && !me.isExpanded && !me.destroyed) {
    bodyEl = me.bodyEl;
    picker = me.getPicker();
    doc = Ext.getDoc();
    picker.setMaxHeight(picker.initialConfig.maxHeight);
    if (me.matchFieldWidth) {
      picker.setWidth(me.bodyEl.getWidth());
    }
    picker.show();
    me.isExpanded = true;
    me.alignPicker();
    bodyEl.addCls(me.openCls);
    if (!me.ariaStaticRoles[me.ariaRole]) {
      if (!me.ariaEl.dom.hasAttribute('aria-owns')) {
        me.ariaEl.dom.setAttribute('aria-owns', picker.listEl ? picker.listEl.id : picker.el.id);
      }
      me.ariaEl.dom.setAttribute('aria-expanded', true);
    }
    me.touchListeners = doc.on({translate:false, touchstart:me.collapseIf, scope:me, delegated:false, destroyable:true});
    me.scrollListeners = Ext.on({scroll:me.onGlobalScroll, scope:me, destroyable:true});
    Ext.on('resize', me.alignPicker, me, {buffer:1});
    me.fireEvent('expand', me);
    me.onExpand();
  }
}, onExpand:Ext.emptyFn, alignPicker:function() {
  var me = this, picker;
  if (me.rendered && !me.destroyed) {
    picker = me.getPicker();
    if (picker.isVisible() && picker.isFloating()) {
      me.doAlign();
    }
  }
}, doAlign:function() {
  var me = this, picker = me.picker, aboveSfx = '-above', newPos, isAbove;
  picker.el.alignTo(me.triggerWrap, me.pickerAlign, me.pickerOffset);
  newPos = picker.floatParent ? picker.getOffsetsTo(picker.floatParent.getTargetEl()) : picker.getXY();
  picker.x = newPos[0];
  picker.y = newPos[1];
  isAbove = picker.el.getY() < me.inputEl.getY();
  me.bodyEl[isAbove ? 'addCls' : 'removeCls'](me.openCls + aboveSfx);
  picker[isAbove ? 'addCls' : 'removeCls'](picker.baseCls + aboveSfx);
}, collapse:function() {
  var me = this;
  if (me.isExpanded && !me.destroyed && !me.destroying) {
    var openCls = me.openCls, picker = me.picker, aboveSfx = '-above';
    picker.hide();
    me.isExpanded = false;
    me.bodyEl.removeCls([openCls, openCls + aboveSfx]);
    picker.el.removeCls(picker.baseCls + aboveSfx);
    if (!me.ariaStaticRoles[me.ariaRole]) {
      me.ariaEl.dom.setAttribute('aria-expanded', false);
    }
    me.touchListeners.destroy();
    me.scrollListeners.destroy();
    Ext.un('resize', me.alignPicker, me);
    me.fireEvent('collapse', me);
    me.onCollapse();
  }
}, onCollapse:Ext.emptyFn, collapseIf:function(e) {
  var me = this;
  if (!me.destroyed && !e.within(me.bodyEl, false, true) && !me.owns(e.target) && !Ext.fly(e.target).isFocusable()) {
    me.collapse();
  }
}, getPicker:function() {
  var me = this, picker = me.picker;
  if (!picker) {
    me.creatingPicker = true;
    me.picker = picker = me.createPicker();
    picker.ownerCmp = me;
    delete me.creatingPicker;
  }
  return me.picker;
}, onFocusLeave:function(e) {
  this.collapse();
  Ext.form.field.Text.prototype.onFocusLeave.call(this, e);
}, getRefItems:function() {
  var result = [];
  if (this.picker) {
    result[0] = this.picker;
  }
  return result;
}, getPickerTrigger:function() {
  return this.triggers && this.triggers.picker;
}, createPicker:Ext.emptyFn, onInputElClick:function(e) {
  this.onTriggerClick(this, this.getPickerTrigger(), e);
}, onTriggerClick:function(field, trigger, e) {
  var me = this;
  if (!me.readOnly && !me.disabled) {
    if (me.isExpanded) {
      me.collapse();
    } else {
      me.expand();
    }
  }
}, doDestroy:function() {
  var me = this, picker = me.picker;
  Ext.un('resize', me.alignPicker, me);
  Ext.destroy(me.keyNav, picker);
  if (picker) {
    me.picker = picker.pickerField = null;
  }
  Ext.form.field.Text.prototype.doDestroy.call(this);
}, privates:{onGlobalScroll:function(scroller) {
  var scrollEl = scroller.getElement();
  if (!this.picker.owns(scrollEl) && scrollEl.isAncestor(this.el)) {
    this.collapse();
  }
}}}, 0, ['pickerfield'], ['component', 'box', 'field', 'textfield', 'pickerfield'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true}, ['widget.pickerfield'], 0, [Ext.form.field, 'Picker', Ext.form, 'Picker'], 0);
Ext.cmd.derive('Ext.selection.Model', Ext.mixin.Observable, {alternateClassName:'Ext.AbstractSelectionModel', factoryConfig:{defaultType:'dataviewmodel'}, $configPrefixed:false, $configStrict:false, config:{store:null, selected:{}}, isSelectionModel:true, allowDeselect:undefined, toggleOnClick:true, ordered:false, selected:null, pruneRemoved:true, suspendChange:0, ignoreRightMouseSelection:false, constructor:function(cfg) {
  var me = this;
  me.modes = {SINGLE:true, SIMPLE:true, MULTI:true};
  Ext.mixin.Observable.prototype.constructor.call(this, cfg);
  me.setSelectionMode(me.mode);
  if (me.selectionMode !== 'SINGLE') {
    me.allowDeselect = true;
  }
}, updateStore:function(store, oldStore) {
  this.bindStore(store, !oldStore);
}, applySelected:function(selected) {
  if (!selected.isBag && !selected.isCollection) {
    selected = new Ext.util[this.ordered ? 'Collection' : 'Bag'](Ext.apply({rootProperty:'data'}, selected));
  }
  return selected;
}, getStoreListeners:function() {
  var me = this;
  return {add:me.onStoreAdd, clear:me.onStoreClear, remove:me.onStoreRemove, update:me.onStoreUpdate, idchanged:me.onIdChanged, load:me.onStoreLoad, refresh:me.onStoreRefresh, pageadd:me.onPageAdd, pageremove:me.onPageRemove};
}, onBindStore:function(store, oldStore, initial) {
  if (!initial) {
    this.updateSelectedInstances(this.selected);
  }
}, suspendChanges:function() {
  ++this.suspendChange;
}, resumeChanges:function() {
  if (this.suspendChange) {
    --this.suspendChange;
  }
}, selectAll:function(suppressEvent) {
  var me = this, selections = me.store.getRange(), start = me.getSelection().length;
  me.suspendChanges();
  me.doSelect(selections, true, suppressEvent);
  if (!me.destroyed) {
    me.resumeChanges();
    if (!suppressEvent) {
      me.maybeFireSelectionChange(me.getSelection().length !== start);
    }
  }
}, deselectAll:function(suppressEvent) {
  var me = this, selections = me.getSelection(), selIndexes = {}, store = me.store, start = selections.length, i, l, rec;
  for (i = 0, l = selections.length; i < l; i++) {
    rec = selections[i];
    selIndexes[rec.id] = store.indexOf(rec);
  }
  selections = Ext.Array.sort(selections, function(r1, r2) {
    var idx1 = selIndexes[r1.id], idx2 = selIndexes[r2.id];
    return idx1 < idx2 ? -1 : 1;
  });
  me.suspendChanges();
  me.doDeselect(selections, suppressEvent);
  if (!me.destroyed) {
    me.resumeChanges();
    if (!suppressEvent) {
      me.maybeFireSelectionChange(me.getSelection().length !== start);
    }
  }
}, getSelectionStart:function() {
  return this.selectionStart;
}, setSelectionStart:function(selection) {
  this.selectionStart = selection;
}, selectWithEvent:function(record, e) {
  var me = this, isSelected = me.isSelected(record), shift = e.shiftKey;
  switch(me.selectionMode) {
    case 'MULTI':
      me.selectWithEventMulti(record, e, isSelected);
      break;
    case 'SIMPLE':
      me.selectWithEventSimple(record, e, isSelected);
      break;
    case 'SINGLE':
      me.selectWithEventSingle(record, e, isSelected);
      break;
  }
  if (me.destroyed) {
    return;
  }
  if (!shift) {
    if (me.isSelected(record)) {
      me.selectionStart = record;
    } else {
      me.selectionStart = null;
    }
  }
}, vetoSelection:function(e) {
  if (e.stopSelection) {
    return true;
  } else {
    if (e.type !== 'keydown' && e.button !== 0) {
      if (this.ignoreRightMouseSelection || this.isSelected(e.record)) {
        return true;
      }
    } else {
      return e.type === 'mousedown';
    }
  }
}, onNavigate:function(e) {
  if (!e.record || this.vetoSelection(e.keyEvent)) {
    return;
  }
  this.onBeforeNavigate(e);
  var me = this, keyEvent = e.keyEvent, ctrlKey = keyEvent.ctrlKey || e.ctrlKey, recIdx = e.recordIndex, record = e.record, lastFocused = e.previousRecord, isSelected = me.isSelected(record), from = me.selectionStart && me.isSelected(e.previousRecord) ? me.selectionStart : me.selectionStart = e.previousRecord, fromIdx = e.previousRecordIndex, key = keyEvent.getCharCode(), isSpace = key === keyEvent.SPACE, changedRec = e.record !== e.previousRecord, direction = key === keyEvent.UP || key === keyEvent.PAGE_UP || 
  key === keyEvent.HOME || key === keyEvent.LEFT && changedRec ? 'up' : key === keyEvent.DOWN || key === keyEvent.PAGE_DOWN || key === keyEvent.END || key === keyEvent.RIGHT && changedRec ? 'down' : null;
  switch(me.selectionMode) {
    case 'MULTI':
      me.setSelectionStart(e.selectionStart);
      if (key === keyEvent.A && ctrlKey) {
        me.selected.beginUpdate();
        me.selectRange(0, me.store.getCount() - 1);
        me.selected.endUpdate();
      } else {
        if (isSpace) {
          if (keyEvent.shiftKey) {
            me.selectRange(from, record, ctrlKey);
          } else {
            if (isSelected) {
              if (me.allowDeselect) {
                me.doDeselect(record);
              }
            } else {
              me.doSelect(record, ctrlKey);
            }
          }
        } else {
          if (keyEvent.shiftKey && from) {
            if (direction === 'up' && fromIdx <= recIdx) {
              me.deselectRange(lastFocused, recIdx + 1);
            } else {
              if (direction === 'down' && fromIdx >= recIdx) {
                me.deselectRange(lastFocused, recIdx - 1);
              } else {
                if (from !== record) {
                  me.selectRange(from, record, ctrlKey);
                }
              }
            }
            me.lastSelected = record;
          } else {
            if (key) {
              if (!ctrlKey) {
                me.doSelect(record, false);
              }
            } else {
              me.selectWithEvent(record, keyEvent);
            }
          }
        }
      }
      break;
    case 'SIMPLE':
      if (key === keyEvent.A && ctrlKey) {
        me.selected.beginUpdate();
        me.selectRange(0, me.store.getCount() - 1);
        me.selected.endUpdate();
      } else {
        if (isSelected) {
          me.doDeselect(record);
        } else {
          me.doSelect(record, true);
        }
      }
      break;
    case 'SINGLE':
      if (!ctrlKey) {
        if (direction) {
          me.doSelect(record, false);
        } else {
          if (isSpace || !key) {
            me.selectWithEvent(record, keyEvent);
          }
        }
      }
  }
  if (!keyEvent.shiftKey && !me.destroyed && me.isSelected(record)) {
    me.selectionStart = record;
    me.selectionStartIdx = recIdx;
  }
}, selectRange:function(startRow, endRow, keepExisting) {
  var me = this, store = me.store, selected = me.selected.items, result, i, len, toSelect, toDeselect, idx, rec;
  if (me.isLocked()) {
    return;
  }
  result = me.normalizeRowRange(startRow, endRow);
  startRow = result[0];
  endRow = result[1];
  toSelect = [];
  for (i = startRow; i <= endRow; i++) {
    if (!me.isSelected(store.getAt(i))) {
      toSelect.push(store.getAt(i));
    }
  }
  if (!keepExisting) {
    toDeselect = [];
    me.suspendChanges();
    for (i = 0, len = selected.length; i < len; ++i) {
      rec = selected[i];
      idx = store.indexOf(rec);
      if (idx < startRow || idx > endRow) {
        toDeselect.push(rec);
      }
    }
    for (i = 0, len = toDeselect.length; i < len; ++i) {
      me.doDeselect(toDeselect[i]);
      if (me.destroyed) {
        break;
      }
    }
    if (!me.destroyed) {
      me.resumeChanges();
    }
  }
  if (!me.destroyed) {
    if (toSelect.length) {
      me.doMultiSelect(toSelect, true);
    } else {
      if (toDeselect) {
        me.maybeFireSelectionChange(toDeselect.length > 0);
      }
    }
  }
}, deselectRange:function(startRow, endRow) {
  var me = this, store = me.store, result, i, toDeselect, record;
  if (me.isLocked()) {
    return;
  }
  result = me.normalizeRowRange(startRow, endRow);
  startRow = result[0];
  endRow = result[1];
  toDeselect = [];
  for (i = startRow; i <= endRow; i++) {
    record = store.getAt(i);
    if (me.isSelected(record)) {
      toDeselect.push(record);
    }
  }
  if (toDeselect.length) {
    me.doDeselect(toDeselect);
  }
}, normalizeRowRange:function(startRow, endRow) {
  var store = this.store, tmp;
  if (!Ext.isNumber(startRow)) {
    startRow = store.indexOf(startRow);
  }
  startRow = Math.max(0, startRow);
  if (!Ext.isNumber(endRow)) {
    endRow = store.indexOf(endRow);
  }
  endRow = Math.min(endRow, store.getCount() - 1);
  if (startRow > endRow) {
    tmp = endRow;
    endRow = startRow;
    startRow = tmp;
  }
  return [startRow, endRow];
}, select:function(records, keepExisting, suppressEvent) {
  if (Ext.isDefined(records) && !(Ext.isArray(records) && !records.length)) {
    this.doSelect(records, keepExisting, suppressEvent);
  }
}, deselect:function(records, suppressEvent) {
  this.doDeselect(records, suppressEvent);
}, doSelect:function(records, keepExisting, suppressEvent) {
  var me = this, record;
  if (me.locked || records == null) {
    return;
  }
  if (typeof records === 'number') {
    record = me.store.getAt(records);
    if (!record) {
      return;
    }
    records = [record];
  }
  if (me.selectionMode === 'SINGLE') {
    if (records.isModel) {
      records = [records];
    }
    if (records.length) {
      me.doSingleSelect(records[0], suppressEvent);
    }
  } else {
    me.doMultiSelect(records, keepExisting, suppressEvent);
  }
}, doMultiSelect:function(records, keepExisting, suppressEvent) {
  var me = this, selected = me.selected, change = false, result, i, len, record, commit;
  if (me.locked) {
    return;
  }
  records = !Ext.isArray(records) ? [records] : records;
  len = records.length;
  if (!keepExisting && selected.getCount() > 0) {
    result = me.deselectDuringSelect(records, suppressEvent);
    if (me.destroyed) {
      return;
    }
    if (result[0]) {
      me.maybeFireSelectionChange(result[1] > 0 && !suppressEvent);
      return;
    } else {
      change = result[1] > 0;
    }
  }
  commit = function() {
    if (!selected.getCount()) {
      me.selectionStart = record;
    }
    if (!suppressEvent) {
      selected.add(record);
    }
    change = true;
  };
  for (i = 0; i < len; i++) {
    record = records[i];
    if (me.isSelected(record)) {
      continue;
    }
    me.onSelectChange(record, true, suppressEvent, commit);
    if (me.destroyed) {
      return;
    }
  }
  me.lastSelected = record;
  if (suppressEvent) {
    selected.add(records);
  }
  me.maybeFireSelectionChange(change && !suppressEvent);
}, deselectDuringSelect:function(toSelect, suppressEvent) {
  var me = this, selected = me.selected.getRange(), len = selected.length, changed = 0, failed = false, item, i;
  me.suspendChanges();
  me.deselectingDuringSelect = true;
  for (i = 0; i < len; ++i) {
    item = selected[i];
    if (!Ext.Array.contains(toSelect, item)) {
      if (me.doDeselect(item, suppressEvent)) {
        ++changed;
      } else {
        failed = true;
      }
    }
    if (me.destroyed) {
      failed = true;
      changed = 0;
      break;
    }
  }
  me.deselectingDuringSelect = false;
  if (!me.destroyed) {
    me.resumeChanges();
  }
  return [failed, changed];
}, doDeselect:function(records, suppressEvent) {
  var me = this, selected = me.selected, i = 0, len, record, attempted = 0, accepted = 0, commit;
  if (me.locked || !me.store) {
    return false;
  }
  if (typeof records === 'number') {
    record = me.store.getAt(records);
    if (!record) {
      return false;
    }
    records = [record];
  } else {
    if (!Ext.isArray(records)) {
      records = [records];
    }
  }
  commit = function() {
    ++accepted;
    if (!suppressEvent) {
      selected.remove(record);
    }
    if (record === me.selectionStart) {
      me.selectionStart = null;
    }
  };
  len = records.length;
  me.suspendChanges();
  for (; i < len; i++) {
    record = records[i];
    if (me.isSelected(record)) {
      if (me.lastSelected === record) {
        me.lastSelected = selected.last();
      }
      ++attempted;
      me.onSelectChange(record, false, suppressEvent, commit);
      if (me.destroyed) {
        return false;
      }
    }
  }
  me.resumeChanges();
  if (suppressEvent) {
    selected.remove(records);
  }
  me.maybeFireSelectionChange(accepted > 0 && !suppressEvent);
  return accepted === attempted;
}, doSingleSelect:function(record, suppressEvent) {
  var me = this, changed = false, selected = me.selected, commit;
  if (me.locked) {
    return;
  }
  if (me.isSelected(record)) {
    return;
  }
  commit = function() {
    if (selected.getCount()) {
      me.suspendChanges();
      var result = me.deselectDuringSelect([record], suppressEvent);
      if (me.destroyed) {
        return;
      }
      me.resumeChanges();
      if (result[0]) {
        return false;
      }
    }
    me.lastSelected = record;
    if (!selected.getCount()) {
      me.selectionStart = record;
    }
    selected.add(record);
    changed = true;
  };
  me.onSelectChange(record, true, suppressEvent, commit);
  if (changed && !me.destroyed) {
    me.maybeFireSelectionChange(!suppressEvent);
  }
}, maybeFireSelectionChange:function(fireEvent) {
  var me = this;
  if (fireEvent && !me.suspendChange) {
    me.fireEvent('selectionchange', me, me.getSelection());
  }
}, getSelection:function() {
  return this.selected.getRange();
}, getSelectionMode:function() {
  return this.selectionMode;
}, setSelectionMode:function(selMode) {
  selMode = selMode ? selMode.toUpperCase() : 'SINGLE';
  this.selectionMode = this.modes[selMode] ? selMode : 'SINGLE';
}, isLocked:function() {
  return this.locked;
}, setLocked:function(locked) {
  this.locked = !!locked;
}, isRangeSelected:function(startRow, endRow) {
  var me = this, store = me.store, i, result;
  result = me.normalizeRowRange(startRow, endRow);
  startRow = result[0];
  endRow = result[1];
  for (i = startRow; i <= endRow; i++) {
    if (!me.isSelected(store.getAt(i))) {
      return false;
    }
  }
  return true;
}, isSelected:function(record) {
  record = Ext.isNumber(record) ? this.store.getAt(record) : record;
  return this.selected ? this.selected.contains(record) : false;
}, hasSelection:function() {
  var selected = this.getSelected();
  return !!(selected && selected.getCount());
}, refresh:function() {
  var me = this, store = me.store, toBeRemoved = [], oldSelections = me.getSelection(), len = oldSelections.length, selected = me.getSelected(), change, d, storeData, selection, rec, i;
  if (!store || !(selected.isCollection || selected.isBag || selected.isRows) || !selected.getCount()) {
    return;
  }
  storeData = store.getData();
  if (storeData.getSource) {
    d = storeData.getSource();
    if (d) {
      storeData = d;
    }
  }
  me.refreshing = true;
  selected.beginUpdate();
  me.suspendChanges();
  for (i = 0; i < len; i++) {
    selection = oldSelections[i];
    rec = storeData.get(selection.getId());
    if (rec) {
      if (rec !== selection) {
        if (selected.replace) {
          selected.replace(rec);
        } else {
          selected.add(rec);
        }
      }
      if (!me.lastSelected) {
        me.lastSelected = rec;
      }
    } else {
      if (me.pruneRemoved) {
        toBeRemoved.push(selection);
      }
    }
  }
  if (toBeRemoved.length) {
    change = true;
    selected.remove(toBeRemoved);
  }
  me.resumeChanges();
  if (change) {
    selected.endUpdate();
  } else {
    selected.updating--;
  }
  me.refreshing = false;
  me.maybeFireSelectionChange(change);
}, clearSelections:function() {
  var selected = this.getSelected();
  if (selected) {
    selected.clear();
  }
  this.lastSelected = null;
}, onStoreAdd:Ext.emptyFn, onStoreClear:function() {
  if ((!this.store.isLoading() || this.store.clearing) && this.hasSelection()) {
    this.clearSelections();
    this.maybeFireSelectionChange(true);
  }
}, onStoreRemove:function(store, records, index, isMove) {
  var me = this, toDeselect = records, i, len, rec, moveMap;
  if (me.selectionStart && Ext.Array.contains(records, me.selectionStart)) {
    me.selectionStart = null;
  }
  if (isMove || me.locked || !me.pruneRemoved) {
    return;
  }
  moveMap = store.isMoving(null, true);
  if (moveMap) {
    toDeselect = null;
    for (i = 0, len = records.length; i < len; ++i) {
      rec = records[i];
      if (!moveMap[rec.id]) {
        (toDeselect || (toDeselect = [])).push(rec);
      }
    }
  }
  if (toDeselect) {
    me.deselect(toDeselect);
  }
}, onPageRemove:function(pageMap, pageNumber, records) {
  this.onStoreRemove(this.store, records);
}, onPageAdd:function(pageMap, pageNumber, records) {
  var len = records.length, i, record;
  for (i = 0; i < len; i++) {
    record = records[i];
    if (this.selected.get(record.id)) {
      this.selected.replace(record);
    }
  }
}, getCount:function() {
  return this.selected.getCount();
}, onUpdate:Ext.emptyFn, destroy:function() {
  var me = this;
  me.clearSelections();
  me.bindStore(null);
  me.selected = Ext.destroy(me.selected);
  Ext.mixin.Observable.prototype.destroy.call(this);
}, onStoreUpdate:Ext.emptyFn, onIdChanged:function(store, rec, oldId, newId) {
  this.selected.updateKey(rec, oldId);
}, onStoreRefresh:function() {
  this.updateSelectedInstances(this.selected);
}, updateSelectedInstances:function(selected) {
  var me = this, store = me.getStore(), lastSelected = me.lastSelected, removeCount = 0, prune = me.pruneRemovedOnRefresh(), items, length, i, selectedRec, rec, lastSelectedChanged;
  if (store && store.isBufferedStore) {
    return;
  }
  items = selected.getRange();
  length = items.length;
  if (lastSelected) {
    me.lastSelected = store.getById(lastSelected.id);
    lastSelectedChanged = me.lastSelected !== lastSelected;
  }
  me.refreshing = true;
  if (store) {
    for (i = 0; i < length; ++i) {
      selectedRec = items[i];
      rec = store.getById(selectedRec.id);
      if (rec) {
        if (rec !== selectedRec) {
          selected.add(rec);
        }
      } else {
        if (prune) {
          selected.remove(selectedRec);
          ++removeCount;
        }
      }
    }
  } else {
    removeCount = selected.getCount();
    selected.removeAll();
  }
  me.refreshing = false;
  me.maybeFireSelectionChange(removeCount > 0);
  if (lastSelectedChanged) {
    me.fireEvent('lastselectedchanged', me, me.getSelection(), lastSelected);
  }
}, pruneRemovedOnRefresh:function() {
  return this.pruneRemoved;
}, onStoreLoad:Ext.emptyFn, onSelectChange:function(record, isSelected, suppressEvent, commitFn) {
  var me = this, eventName = isSelected ? 'select' : 'deselect';
  if ((suppressEvent || me.fireEvent('before' + eventName, me, record)) !== false && commitFn() !== false) {
    if (!suppressEvent && !me.destroyed) {
      me.fireEvent(eventName, me, record);
    }
  }
}, onEditorKey:Ext.emptyFn, beforeViewRender:function(view) {
  Ext.Array.include(this.views || (this.views = []), view);
}, onHeaderClick:Ext.emptyFn, resolveListenerScope:function(defaultScope) {
  var view = this.view, scope;
  if (view) {
    scope = view.resolveSatelliteListenerScope(this, defaultScope);
  }
  return scope || Ext.mixin.Observable.prototype.resolveListenerScope.call(this, defaultScope);
}, bindComponent:Ext.emptyFn, privates:{onBeforeNavigate:Ext.privateFn, getLastSelected:function() {
  return this.lastSelected;
}, selectWithEventMulti:function(record, e, isSelected) {
  var me = this, shift = e.shiftKey, ctrl = e.ctrlKey, start = shift ? me.getSelectionStart() : null, selected = me.getSelection(), len = selected.length, toDeselect, i, item;
  if (shift && start) {
    me.selectRange(start, record, ctrl);
  } else {
    if (ctrl && isSelected) {
      if (me.allowDeselect) {
        me.doDeselect(record, false);
      }
    } else {
      if (ctrl) {
        me.doSelect(record, true, false);
      } else {
        if (isSelected && !shift && !ctrl && len > 1) {
          if (me.allowDeselect) {
            toDeselect = [];
            for (i = 0; i < len; ++i) {
              item = selected[i];
              if (item !== record) {
                toDeselect.push(item);
              }
            }
            me.doDeselect(toDeselect);
          }
        } else {
          if (!isSelected) {
            me.doSelect(record, false);
          }
        }
      }
    }
  }
}, selectWithEventSimple:function(record, e, isSelected) {
  if (isSelected) {
    this.doDeselect(record);
  } else {
    this.doSelect(record, true);
  }
}, selectWithEventSingle:function(record, e, isSelected) {
  var me = this, allowDeselect = me.allowDeselect;
  if (allowDeselect && !e.ctrlKey) {
    allowDeselect = me.toggleOnClick;
  }
  if (allowDeselect && isSelected) {
    me.doDeselect(record);
  } else {
    me.doSelect(record, false);
  }
}}}, 1, 0, 0, 0, ['selection.abstract'], [[Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder], [Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.selection, 'Model', Ext, 'AbstractSelectionModel'], 0);
Ext.cmd.derive('Ext.selection.DataViewModel', Ext.selection.Model, {deselectOnContainerClick:true, bindComponent:function(view) {
  var me = this, viewListeners;
  if (me.view !== view) {
    if (me.view) {
      me.navigationModel = null;
      Ext.destroy(me.viewListeners, me.navigationListeners);
    }
    me.view = view;
    if (view) {
      viewListeners = me.getViewListeners();
      viewListeners.scope = me;
      viewListeners.destroyable = true;
      me.navigationModel = view.getNavigationModel();
      me.viewListeners = view.on(viewListeners);
      me.navigationListeners = me.navigationModel.on({navigate:me.onNavigate, scope:me, destroyable:true});
    }
  }
}, getViewListeners:function() {
  var me = this, eventListeners = {};
  eventListeners[me.view.triggerCtEvent] = me.onContainerClick;
  return eventListeners;
}, onUpdate:function(record) {
  var view = this.view;
  if (view && this.isSelected(record)) {
    view.onItemSelect(record);
  }
}, onContainerClick:function() {
  if (this.deselectOnContainerClick) {
    this.deselectAll();
  }
}, onSelectChange:function(record, isSelected, suppressEvent, commitFn) {
  var me = this, view = me.view, eventName = isSelected ? 'select' : 'deselect', recordIndex = me.store.indexOf(record);
  if ((suppressEvent || me.fireEvent('before' + eventName, me, record, recordIndex)) !== false && commitFn() !== false) {
    if (view && !view.destroyed) {
      if (isSelected) {
        view.onItemSelect(record);
      } else {
        view.onItemDeselect(record);
      }
    }
    if (!suppressEvent && !me.destroyed) {
      me.fireEvent(eventName, me, record, recordIndex);
    }
  }
}, destroy:function() {
  this.bindComponent();
  Ext.destroy(this.keyNav);
  Ext.selection.Model.prototype.destroy.call(this);
}}, 0, 0, 0, 0, ['selection.dataviewmodel'], 0, [Ext.selection, 'DataViewModel'], 0);
Ext.cmd.derive('Ext.view.NavigationModel', Ext.Base, {config:{store:null}, focusCls:'x-view-item-focused', constructor:function() {
  this.mixins.observable.constructor.call(this);
}, bindComponent:function(view) {
  if (this.view !== view) {
    this.view = view;
    this.bindView(view);
  }
}, bindView:function(view) {
  var me = this, dataSource = view.dataSource, listeners;
  me.initKeyNav(view);
  if (!dataSource.isEmptyStore) {
    me.setStore(dataSource);
  }
  listeners = me.getViewListeners();
  listeners.destroyable = true;
  me.viewListeners = me.viewListeners || [];
  me.viewListeners.push(view.on(listeners));
}, updateStore:function(store) {
  this.mixins.storeholder.bindStore.apply(this, [store]);
}, getViewListeners:function() {
  var me = this;
  return {containermousedown:me.onContainerMouseDown, itemmousedown:me.onItemMouseDown, itemclick:me.onItemClick, itemcontextmenu:me.onItemMouseDown, scope:me};
}, initKeyNav:function(view) {
  var me = this;
  me.keyNav = new Ext.util.KeyNav({target:view, ignoreInputFields:true, eventName:'itemkeydown', defaultEventAction:'stopEvent', processEvent:me.processViewEvent, up:me.onKeyUp, down:me.onKeyDown, right:me.onKeyRight, left:me.onKeyLeft, pageDown:me.onKeyPageDown, pageUp:me.onKeyPageUp, home:me.onKeyHome, end:me.onKeyEnd, space:me.onKeySpace, enter:me.onKeyEnter, A:{ctrl:true, handler:me.onSelectAllKeyPress}, scope:me});
}, processViewEvent:function(view, record, node, index, event) {
  return event;
}, addKeyBindings:function(binding) {
  this.keyNav.addBindings(binding);
}, enable:function() {
  this.keyNav.enable();
  this.disabled = false;
}, disable:function() {
  this.keyNav.disable();
  this.disabled = true;
}, onContainerMouseDown:function(view, mousedownEvent) {
  if (Ext.getScrollbarSize().width) {
    if (!view.el.getClientRegion().contains(mousedownEvent.getPoint())) {
      mousedownEvent.preventDefault();
      view.lastFocused = 'scrollbar';
    }
  }
}, onItemMouseDown:function(view, record, item, index, mousedownEvent) {
  if (mousedownEvent.pointerType !== 'touch') {
    this.setPosition(index);
  }
}, onItemClick:function(view, record, item, index, clickEvent) {
  if (this.record === record) {
    this.fireNavigateEvent(clickEvent);
  } else {
    this.setPosition(index, clickEvent);
  }
}, setPosition:function(recordIndex, keyEvent, suppressEvent, preventNavigation, preventFocus) {
  var me = this, view = me.view, selModel = view.getSelectionModel(), dataSource = view.dataSource, newRecord, newRecordIndex;
  if (recordIndex == null || !view.all.getCount()) {
    me.record = me.recordIndex = null;
  } else {
    if (typeof recordIndex === 'number') {
      newRecordIndex = Math.max(Math.min(recordIndex, dataSource.getCount() - 1), 0);
      newRecord = dataSource.getAt(recordIndex);
    } else {
      if (recordIndex.isEntity) {
        newRecord = dataSource.getById(recordIndex.id);
        newRecordIndex = dataSource.indexOf(newRecord);
        if (newRecordIndex === -1) {
          newRecord = dataSource.getAt(0);
          newRecordIndex = 0;
        }
      } else {
        if (recordIndex.tagName) {
          newRecord = view.getRecord(recordIndex);
          newRecordIndex = dataSource.indexOf(newRecord);
        } else {
          newRecord = newRecordIndex = null;
        }
      }
    }
  }
  if (newRecord === me.record) {
    me.recordIndex = newRecordIndex;
    return me.focusPosition(newRecordIndex);
  }
  if (me.item) {
    me.item.removeCls(me.focusCls);
  }
  me.previousRecordIndex = me.recordIndex;
  me.previousRecord = me.record;
  me.previousItem = me.item;
  me.recordIndex = newRecordIndex;
  me.record = newRecord;
  preventNavigation = preventNavigation || me.record === me.lastFocused;
  if (newRecord) {
    me.focusPosition(me.recordIndex);
  } else {
    if (!preventFocus) {
      me.item = null;
    }
  }
  if (!suppressEvent) {
    selModel.fireEvent('focuschange', selModel, me.previousRecord, me.record);
  }
  if (!preventNavigation && keyEvent) {
    me.fireNavigateEvent(keyEvent);
  }
}, focusPosition:function(recordIndex) {
  var me = this;
  if (recordIndex != null && recordIndex !== -1) {
    if (recordIndex.isEntity) {
      recordIndex = me.view.dataSource.indexOf(recordIndex);
    }
    me.item = me.view.all.item(recordIndex);
    if (me.item) {
      me.lastFocused = me.record;
      me.lastFocusedIndex = me.recordIndex;
      me.focusItem(me.item);
    } else {
      me.record = null;
    }
  } else {
    me.item = null;
  }
}, focusItem:function(item) {
  item.addCls(this.focusCls);
  item.focus();
}, getPosition:function() {
  return this.record ? this.recordIndex : null;
}, getRecordIndex:function() {
  return this.recordIndex;
}, getItem:function() {
  return this.item;
}, getRecord:function() {
  return this.record;
}, getLastFocused:function() {
  if (this.view.dataSource.indexOf(this.lastFocused) === -1) {
    return null;
  }
  return this.lastFocused;
}, onKeyUp:function(keyEvent) {
  var newPosition = this.recordIndex - 1;
  if (newPosition < 0) {
    newPosition = this.view.all.getCount() - 1;
  }
  this.setPosition(newPosition, keyEvent);
}, onKeyDown:function(keyEvent) {
  var newPosition = this.recordIndex + 1;
  if (newPosition > this.view.all.getCount() - 1) {
    newPosition = 0;
  }
  this.setPosition(newPosition, keyEvent);
}, onKeyRight:function(keyEvent) {
  var newPosition = this.recordIndex + 1;
  if (newPosition > this.view.all.getCount() - 1) {
    newPosition = 0;
  }
  this.setPosition(newPosition, keyEvent);
}, onKeyLeft:function(keyEvent) {
  var newPosition = this.recordIndex - 1;
  if (newPosition < 0) {
    newPosition = this.view.all.getCount() - 1;
  }
  this.setPosition(newPosition, keyEvent);
}, onKeyPageDown:Ext.emptyFn, onKeyPageUp:Ext.emptyFn, onKeyHome:function(keyEvent) {
  this.setPosition(0, keyEvent);
}, onKeyEnd:function(keyEvent) {
  this.setPosition(this.view.all.getCount() - 1, keyEvent);
}, onKeySpace:function(keyEvent) {
  this.fireNavigateEvent(keyEvent);
}, onKeyEnter:function(keyEvent) {
  keyEvent.stopEvent();
  keyEvent.view.fireEvent('itemclick', keyEvent.view, keyEvent.record, keyEvent.item, keyEvent.recordIndex, keyEvent);
}, onSelectAllKeyPress:function(keyEvent) {
  this.fireNavigateEvent(keyEvent);
}, fireNavigateEvent:function(keyEvent) {
  var me = this;
  me.fireEvent('navigate', {navigationModel:me, keyEvent:keyEvent, previousRecordIndex:me.previousRecordIndex, previousRecord:me.previousRecord, previousItem:me.previousItem, recordIndex:me.recordIndex, record:me.record, item:me.item});
}, destroy:function() {
  this.setStore(null);
  Ext.destroy(this.viewListeners, this.keyNav);
  this.callParent();
}}, 1, 0, 0, 0, ['view.navigation.default'], [[Ext.util.Observable.prototype.mixinId || Ext.util.Observable.$className, Ext.util.Observable], [Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable], [Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder]], [Ext.view, 'NavigationModel'], 0);
Ext.cmd.derive('Ext.view.AbstractView', Ext.Component, {isDataView:true, inheritableStatics:{getRecord:function(node) {
  return this.getBoundView(node).getRecord(node);
}, getBoundView:function(node) {
  return Ext.getCmp(node.getAttribute('data-boundView'));
}}, defaultBindProperty:'store', renderBuffer:new Ext.dom.Fly(document.createElement('div')), statics:{updateDelay:Ext.platformTags.desktop ? 200 : 1000, queueRecordChange:function(view, store, record, operation, modifiedFieldNames) {
  var me = this, changeQueue = me.changeQueue || (me.changeQueue = {}), recId = record.internalId, recChange, updated, len, i, fieldName, value, checkForReversion;
  recChange = changeQueue[recId] || (changeQueue[recId] = {operation:operation, record:record, data:{}, views:[]});
  updated = recChange.data;
  Ext.Array.include(recChange.views, view);
  if (modifiedFieldNames && (len = modifiedFieldNames.length)) {
    for (i = 0; i < len; i++) {
      fieldName = modifiedFieldNames[i];
      value = record.data[fieldName];
      if (updated.hasOwnProperty(fieldName)) {
        if (record.isEqual(updated[fieldName], value)) {
          delete updated[fieldName];
          checkForReversion = true;
        }
      } else {
        updated[fieldName] = value;
      }
    }
    if (checkForReversion && !Ext.Object.getKeys(updated).length) {
      delete changeQueue[recId];
    }
  } else {
    Ext.apply(updated, record.data);
  }
  if (!me.flushQueueTask) {
    me.flushQueueTask = new Ext.util.DelayedTask(Ext.global.requestAnimationFrame ? Ext.Function.createAnimationFrame(me.flushChangeQueue, me) : me.flushChangeQueue.bind(me), me, null, false);
  }
  if (!me.flushTimer) {
    me.flushTimer = me.flushQueueTask.delay(Ext.view.AbstractView.updateDelay);
  }
}, flushChangeQueue:function() {
  var me = this, dirtyViews, len, changeQueue, recChange, recId, i, view;
  if (Ext.isScrolling) {
    return me.flushTimer = me.flushQueueTask.delay(1);
  }
  me.flushTimer = null;
  changeQueue = me.changeQueue;
  me.changeQueue = {};
  for (recId in changeQueue) {
    recChange = changeQueue[recId];
    dirtyViews = recChange.views;
    len = dirtyViews.length;
    for (i = 0; i < len; i++) {
      view = dirtyViews[i];
      if (!view.destroyed) {
        view.handleUpdate(view.dataSource, recChange.record, recChange.operation, Ext.Object.getKeys(recChange.data));
      }
    }
  }
}}, config:{store:'ext-empty-store', navigationModel:{type:'default'}, selectionModel:{type:'dataviewmodel'}}, publishes:['selection'], twoWayBindable:['selection'], selection:null, throttledUpdate:false, deferInitialRefresh:false, itemCls:'x-dataview-item', loadingText:'Loading...', loadMask:true, loadingUseMsg:true, selectedItemCls:'x-item-selected', emptyText:'', deferEmptyText:true, trackOver:false, blockRefresh:false, preserveScrollOnRefresh:false, preserveScrollOnReload:false, autoDestroyBoundStore:true, 
ariaRole:'listbox', itemAriaRole:'option', last:false, focusable:true, tabIndex:0, triggerEvent:'itemclick', triggerCtEvent:'containerclick', refreshNeeded:true, updateSuspendCounter:0, addCmpEvents:Ext.emptyFn, constructor:function(config) {
  if (config && config.selModel) {
    config.selectionModel = config.selModel;
  }
  Ext.Component.prototype.constructor.call(this, config);
}, initComponent:function() {
  var me = this, isDef = Ext.isDefined, itemTpl = me.itemTpl, memberFn = {}, selection = me.selection, store;
  if (selection) {
    me.selection = null;
    me.setSelection(selection);
  }
  if (itemTpl) {
    if (Ext.isArray(itemTpl)) {
      if (typeof itemTpl[itemTpl.length - 1] !== 'string') {
        itemTpl = itemTpl.slice(0);
        memberFn = itemTpl.pop();
      }
      itemTpl = itemTpl.join('');
    } else {
      if (Ext.isObject(itemTpl)) {
        memberFn = Ext.apply(memberFn, itemTpl.initialConfig);
        itemTpl = itemTpl.html;
      }
    }
    if (!me.itemSelector) {
      me.itemSelector = '.' + me.itemCls;
    }
    if (memberFn.fn) {
      memberFn.baseFn = memberFn.fn;
      delete memberFn.fn;
      itemTpl = '{%this.baseFn(out, values, parent, xindex, xcount, xkey)%}';
    }
    itemTpl = Ext.String.format('\x3ctpl for\x3d"."\x3e\x3cdiv class\x3d"{0}" role\x3d"{2}"\x3e{1}\x3c/div\x3e\x3c/tpl\x3e', me.itemCls, itemTpl, me.itemAriaRole);
    me.tpl = new Ext.XTemplate(itemTpl, memberFn);
  }
  Ext.Component.prototype.initComponent.call(this);
  me.tpl = me.lookupTpl('tpl');
  if (me.overItemCls) {
    me.trackOver = true;
  }
  me.addCmpEvents();
  store = me.store = Ext.data.StoreManager.lookup(me.store || 'ext-empty-store');
  if (!me.dataSource) {
    me.dataSource = store;
  }
  me.bindStore(store, true);
  me.getNavigationModel().bindComponent(this);
  if (!me.all) {
    me.all = new Ext.CompositeElementLite;
  }
  me.scrollState = {top:0, left:0};
  me.savedTabIndexAttribute = 'data-savedtabindex-' + me.id;
}, getElConfig:function() {
  var result = this.mixins.renderable.getElConfig.call(this);
  if (this.focusable) {
    result.tabIndex = 0;
  }
  return result;
}, onRender:function(parentNode, containerIdx) {
  var mask = this.loadMask;
  Ext.Component.prototype.onRender.call(this, parentNode, containerIdx);
  if (mask) {
    this.createMask(mask);
  }
}, beforeLayout:function() {
  var me = this;
  Ext.Component.prototype.beforeLayout.call(this);
  if (me.refreshNeeded && !me.pendingRefresh) {
    if (me.refreshCounter) {
      me.refreshView();
    } else {
      me.doFirstRefresh(me.dataSource);
    }
  }
}, onMaskBeforeShow:function() {
  var me = this, loadingHeight = me.loadingHeight;
  if (loadingHeight && loadingHeight > me.getHeight()) {
    me.hasLoadingHeight = true;
    me.oldMinHeight = me.minHeight;
    me.minHeight = loadingHeight;
    me.updateLayout();
  }
}, onMaskHide:function() {
  var me = this;
  if (!me.destroying && me.hasLoadingHeight) {
    me.minHeight = me.oldMinHeight;
    me.updateLayout();
    delete me.hasLoadingHeight;
  }
}, beforeRender:function() {
  Ext.Component.prototype.beforeRender.call(this);
  this.getSelectionModel().beforeViewRender(this);
}, afterRender:function() {
  Ext.Component.prototype.afterRender.call(this);
  if (this.focusable) {
    this.focusEl = this.el;
  }
}, getRefItems:function() {
  var mask = this.loadMask, result = [];
  if (mask && mask.isComponent) {
    result.push(mask);
  }
  return result;
}, getSelection:function() {
  return this.getSelectionModel().getSelection();
}, setSelection:function(selection) {
  var current = this.selection;
  if (selection !== current) {
    this.selection = selection;
    this.updateSelection(selection, current);
  }
}, updateSelection:function(selection) {
  var me = this, sm;
  if (!me.ignoreNextSelection) {
    me.ignoreNextSelection = true;
    sm = me.getSelectionModel();
    if (selection) {
      sm.select(selection);
    } else {
      sm.deselectAll();
    }
    me.ignoreNextSelection = false;
  }
  me.publishState('selection', selection);
}, updateBindSelection:function(selModel, selection) {
  var me = this, selected = null;
  if (!me.ignoreNextSelection) {
    me.ignoreNextSelection = true;
    if (selection.length) {
      selected = selModel.getLastSelected();
      me.hasHadSelection = true;
    }
    if (me.hasHadSelection) {
      me.setSelection(selected);
    }
    me.ignoreNextSelection = false;
  }
}, applySelectionModel:function(selModel, oldSelModel) {
  var me = this, grid = me.grid, mode, ariaAttr, ariaDom;
  if (oldSelModel) {
    if (!oldSelModel.destroyed) {
      oldSelModel.un({scope:me, selectionchange:me.updateBindSelection, lastselectedchanged:me.updateBindSelection});
    }
    Ext.destroy(me.selModelRelayer);
    selModel = Ext.Factory.selection(selModel);
  } else {
    if (selModel && selModel.isSelectionModel) {
      selModel.locked = me.disableSelection;
    } else {
      if (me.simpleSelect) {
        mode = 'SIMPLE';
      } else {
        if (me.multiSelect) {
          mode = 'MULTI';
        } else {
          mode = 'SINGLE';
        }
      }
      if (typeof selModel === 'string') {
        selModel = {type:selModel};
      }
      selModel = Ext.Factory.selection(Ext.apply({allowDeselect:me.allowDeselect || me.multiSelect, mode:mode, locked:me.disableSelection}, selModel));
    }
  }
  if (selModel.mode !== 'SINGLE') {
    ariaDom = (grid || me).ariaEl.dom;
    if (ariaDom) {
      ariaDom.setAttribute('aria-multiselectable', true);
    } else {
      if (!grid) {
        ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
        ariaAttr['aria-multiselectable'] = true;
      }
    }
  }
  me.selModelRelayer = me.relayEvents(selModel, ['selectionchange', 'beforeselect', 'beforedeselect', 'select', 'deselect', 'focuschange']);
  selModel.on({scope:me, lastselectedchanged:me.updateBindSelection, selectionchange:me.updateBindSelection});
  return selModel;
}, updateSelectionModel:function(selectionModel) {
  this.selModel = selectionModel;
}, applyNavigationModel:function(navigationModel) {
  return Ext.Factory.viewNavigation(navigationModel);
}, onFocusEnter:function(e) {
  var me = this, navigationModel = me.getNavigationModel(), focusPosition = me.lastFocused;
  me.lastFocused = null;
  if (focusPosition === 'scrollbar') {
    e.relatedTarget.focus();
    return;
  }
  me.toggleChildrenTabbability(false);
  if (!me.itemFocused && me.all.getCount()) {
    if (e.event.getTarget() === me.tabGuardEl) {
      focusPosition = me.all.getCount() - 1;
    } else {
      focusPosition = navigationModel.getLastFocused();
    }
    navigationModel.setPosition(focusPosition || 0, e.event, null, !focusPosition);
    me.itemFocused = navigationModel.getPosition() != null;
  }
  if (me.itemFocused) {
    me.el.dom.setAttribute('tabIndex', -1);
    if (me.tabGuardEl) {
      me.tabGuardEl.setAttribute('tabIndex', -1);
    }
  }
  Ext.Component.prototype.onFocusEnter.call(this, e);
}, onFocusLeave:function(e) {
  var me = this;
  if (me.itemFocused && !me.refreshing) {
    me.getNavigationModel().setPosition(null, e.event, null, true);
    me.itemFocused = false;
    me.el.dom.setAttribute('tabIndex', 0);
    if (me.tabGuardEl) {
      me.tabGuardEl.setAttribute('tabIndex', 0);
    }
  }
  Ext.Component.prototype.onFocusLeave.call(this, e);
}, cancelFocusTask:function() {
  var task = this.getFocusTask();
  if (task) {
    task.cancel();
  }
}, onRemoved:function(isDestroying) {
  Ext.Component.prototype.onRemoved.call(this, isDestroying);
  if (!isDestroying) {
    this.onFocusLeave({});
  }
}, refresh:function() {
  var me = this, items = me.all, prevItemCount = items.getCount(), refreshCounter = me.refreshCounter, targetEl, records, selModel = me.getSelectionModel(), restoreFocus, scroller = refreshCounter && items.getCount() && me.preserveScrollOnRefresh && me.getScrollable(), bufferedRenderer = me.bufferedRenderer, scrollPos;
  if (!me.rendered || me.destroyed) {
    return;
  }
  if (!me.hasListeners.beforerefresh || me.fireEvent('beforerefresh', me) !== false) {
    me.refreshing = true;
    restoreFocus = me.saveFocusState();
    targetEl = me.getTargetEl();
    records = me.getViewRange();
    if (scroller) {
      scrollPos = scroller.getPosition();
      if (!(scrollPos.x || scrollPos.y)) {
        scrollPos = null;
      }
    }
    if (refreshCounter || me.emptyEl) {
      me.clearViewEl();
    }
    if (refreshCounter) {
      me.refreshCounter++;
    } else {
      me.refreshCounter = 1;
    }
    me.tpl.append(targetEl, me.collectData(records, items.startIndex || 0));
    if (records.length < 1) {
      me.addEmptyText();
      items.clear();
    } else {
      me.collectNodes(targetEl.dom);
      me.updateIndexes(0);
    }
    restoreFocus();
    if (me.refreshSelmodelOnRefresh !== false) {
      selModel.refresh();
    }
    me.refreshNeeded = false;
    me.refreshSize(items.getCount() !== prevItemCount);
    me.fireItemMutationEvent('refresh', me, records);
    if (scroller) {
      scroller.scrollTo(scrollPos);
    }
    if (!me.viewReady) {
      me.viewReady = true;
      me.fireEvent('viewready', me);
    }
    me.refreshing = false;
    if (bufferedRenderer) {
      bufferedRenderer.refreshSize();
    }
    me.cleanupData();
  }
  if (!me.tabGuardEl) {
    me.tabGuardEl = me.el.createChild({cls:'x-tab-guard x-tab-guard-after', tabIndex:'0'}, null, true);
  }
}, addEmptyText:function() {
  var me = this, store = me.getStore();
  if (me.emptyText && !store.isLoading() && (!me.deferEmptyText || me.refreshCounter > 1 || store.isLoaded())) {
    if (!me.emptyEl) {
      me.emptyEl = Ext.core.DomHelper.insertHtml('beforeEnd', me.getTargetEl().dom, me.emptyText);
    } else {
      Ext.fly(me.emptyEl).setHtml(me.emptyText);
    }
  }
}, getEmptyText:function() {
  return this.emptyText;
}, setEmptyText:function(emptyText) {
  var me = this;
  if (me.emptyText !== emptyText) {
    me.emptyText = emptyText;
    me.refresh();
  }
  return me;
}, getViewRange:function() {
  return this.dataSource.getRange();
}, refreshSize:function(forceLayout) {
  var me = this, sizeModel = me.getSizeModel();
  if (sizeModel.height.shrinkWrap || sizeModel.width.shrinkWrap || forceLayout) {
    me.updateLayout();
  }
}, afterFirstLayout:function(width, height) {
  var me = this, scroller = me.getScrollable();
  if (scroller) {
    me.viewScrollListeners = scroller.on({scroll:me.onViewScroll, scrollend:me.onViewScrollEnd, scope:me, onFrame:!!Ext.global.requestAnimationFrame, destroyable:true});
  }
  Ext.Component.prototype.afterFirstLayout.call(this, width, height);
}, clearViewEl:function() {
  var me = this, targetEl = me.getTargetEl(), all = me.all, store = me.getStore(), i, removedItems, removedRecs, nodeContainerIsTarget = me.getNodeContainer() === targetEl;
  removedItems = all.slice();
  removedRecs = [];
  for (i = all.startIndex; i <= all.endIndex; i++) {
    removedRecs.push(store.getByInternalId(all.item(i, true).getAttribute('data-recordId')));
  }
  me.fireItemMutationEvent('itemremove', removedRecs, all.startIndex || 0, removedItems, me);
  me.clearEmptyEl();
  me.all.clear(!nodeContainerIsTarget);
  targetEl = nodeContainerIsTarget ? targetEl.dom : me.getNodeContainer();
  if (targetEl) {
    targetEl.innerHTML = '';
  }
}, clearEmptyEl:function() {
  var emptyEl = this.emptyEl;
  if (emptyEl) {
    Ext.removeNode(emptyEl);
  }
  this.emptyEl = null;
}, onViewScroll:function(scroller, x, y) {
  if (!this.destroyed) {
    this.fireEvent('scroll', this, x, y);
  }
}, onViewScrollEnd:function(scroller, x, y) {
  if (!this.destroyed) {
    this.fireEvent('scrollend', this, x, y);
  }
}, saveScrollState:function() {
  var me = this, state = me.scrollState;
  if (me.rendered) {
    state.left = me.getScrollX();
    state.top = me.getScrollY();
  }
}, restoreScrollState:function() {
  var me = this, state = me.scrollState;
  if (me.rendered) {
    me.setScrollX(state.left);
    me.setScrollY(state.top);
  }
}, prepareData:function(data, recordIndex, record) {
  var associatedData, attr, hasCopied;
  if (record) {
    associatedData = record.getAssociatedData();
    for (attr in associatedData) {
      if (associatedData.hasOwnProperty(attr)) {
        if (!hasCopied) {
          data = Ext.Object.chain(data);
          hasCopied = true;
        }
        data[attr] = associatedData[attr];
      }
    }
  }
  return data;
}, collectData:function(records, startIndex) {
  var data = [], i = 0, len = records.length, record;
  for (; i < len; i++) {
    record = records[i];
    data[i] = this.prepareData(record.data, startIndex + i, record);
  }
  return data;
}, cleanupData:Ext.emptyFn, bufferRender:function(records, index) {
  var me = this, div = me.renderBuffer, result = document.createDocumentFragment(), nodes, len, i;
  me.tpl.overwrite(div, me.collectData(records, index));
  nodes = div.query(me.getItemSelector());
  for (i = 0, len = nodes.length; i < len; i++) {
    result.appendChild(nodes[i]);
  }
  return {fragment:result, children:nodes};
}, nodeContainerSelector:null, setItemsDraggable:function(draggable) {
  var me = this, selector = '#' + me.id + ' ' + me.getItemSelector(), styleSheet = me.viewStyleSheet;
  if (draggable) {
    if (!styleSheet) {
      styleSheet = Ext.view.AbstractView.prototype.viewStyleSheet = Ext.util.CSS.createStyleSheet('', 'AbstractView');
    }
    Ext.util.CSS.createRule(styleSheet, selector, 'touch-action: pinch-zoom double-tap-zoom;-ms-touch-action: pinch-zoom double-tap-zoom;-webkit-user-drag: none;');
  } else {
    if (styleSheet) {
      Ext.util.CSS.deleteRule(selector);
    }
  }
}, getNodeContainerSelector:function() {
  return this.nodeContainerSelector;
}, onUpdate:function(store, record, operation, modifiedFieldNames, details) {
  var me = this, isFiltered = details && details.filtered;
  if (!isFiltered && me.getNode(record)) {
    if (me.throttledUpdate) {
      me.statics().queueRecordChange(me, store, record, operation, modifiedFieldNames);
    } else {
      me.handleUpdate(store, record, operation, modifiedFieldNames, details);
    }
  }
}, handleUpdate:function(store, record) {
  var me = this, index, node, selModel = me.getSelectionModel();
  if (me.viewReady && !me.refreshNeeded) {
    index = me.dataSource.indexOf(record);
    if (index > -1) {
      if (me.getNode(record)) {
        node = me.bufferRender([record], index).children[0];
        me.all.replaceElement(index, node, true);
        me.updateIndexes(index, index);
        selModel.onUpdate(record);
        me.refreshSizePending = true;
        if (selModel.isSelected(record)) {
          me.onItemSelect(record);
        }
        if (me.hasListeners.itemupdate) {
          me.fireEvent('itemupdate', record, index, node, me);
        }
        return node;
      }
    }
  }
}, onReplace:function(store, startIndex, oldRecords, newRecords) {
  var me = this, all = me.all, scroller = me.getScrollable(), yPos = scroller && scroller.getPosition().y, selModel = me.getSelectionModel(), origStart = startIndex, result, item, fragment, children, oldItems, endIndex, restoreFocus;
  if (me.rendered) {
    result = me.bufferRender(newRecords, startIndex, true);
    fragment = result.fragment;
    children = result.children;
    item = all.item(startIndex);
    if (item) {
      all.item(startIndex).insertSibling(fragment, 'before', true);
    } else {
      me.appendNodes(fragment);
    }
    all.insert(startIndex, children);
    if (oldRecords.length) {
      restoreFocus = me.saveFocusState();
    }
    startIndex += newRecords.length;
    endIndex = startIndex + oldRecords.length - 1;
    oldItems = all.removeRange(startIndex, endIndex, true);
    if (scroller) {
      scroller.scrollTo(null, yPos);
    }
    if (me.refreshSelmodelOnRefresh !== false) {
      selModel.refresh();
    }
    me.updateIndexes(startIndex);
    me.fireItemMutationEvent('itemremove', oldRecords, origStart, oldItems, me);
    me.fireItemMutationEvent('itemadd', newRecords, origStart, children, me);
    restoreFocus();
    me.refreshSize();
  }
}, onAdd:function(store, records, index) {
  var me = this, nodes, selModel = me.getSelectionModel();
  if (me.rendered && !me.refreshNeeded) {
    if (me.all.getCount() === 0) {
      me.refresh();
      nodes = me.all.slice();
    } else {
      nodes = me.doAdd(records, index);
      if (me.refreshSelmodelOnRefresh !== false) {
        selModel.refresh();
      }
      me.updateIndexes(index);
      me.refreshSizePending = true;
    }
    me.fireItemMutationEvent('itemadd', records, index, nodes, me);
  }
}, appendNodes:function(nodes) {
  var all = this.all, count = all.getCount();
  if (this.nodeContainerSelector) {
    this.getNodeContainer().appendChild(nodes);
  } else {
    all.item(count - 1).insertSibling(nodes, 'after');
  }
}, doAdd:function(records, index) {
  var me = this, result = me.bufferRender(records, index, true), fragment = result.fragment, children = result.children, all = me.all, count = all.getCount(), firstRowIndex = all.startIndex || 0, lastRowIndex = all.endIndex || count - 1;
  if (count === 0 || index > lastRowIndex) {
    me.appendNodes(fragment);
  } else {
    if (index <= firstRowIndex) {
      all.item(firstRowIndex).insertSibling(fragment, 'before', true);
    } else {
      all.item(index).insertSibling(children, 'before', true);
    }
  }
  all.insert(index, children);
  return children;
}, onRemove:function(store, records, index) {
  var me = this, rows = me.all, currIdx, i, record, nodes, node, restoreFocus;
  if (me.rendered && !me.refreshNeeded && rows.getCount()) {
    if (me.dataSource.getCount() === 0) {
      me.refresh();
    } else {
      restoreFocus = me.saveFocusState();
      nodes = [];
      for (i = records.length - 1; i >= 0; --i) {
        record = records[i];
        currIdx = index + i;
        if (nodes) {
          node = rows.item(currIdx);
          nodes[i] = node ? node.dom : undefined;
        }
        if (rows.item(currIdx)) {
          me.doRemove(record, currIdx);
        }
      }
      me.fireItemMutationEvent('itemremove', records, index, nodes, me);
      restoreFocus();
      me.updateIndexes(index);
    }
    me.refreshSizePending = true;
  }
}, doRemove:function(record, index) {
  this.all.removeElement(index, true);
}, eventLifecycleMap:{refresh:'onViewRefresh', itemremove:'onItemRemove', itemadd:'onItemAdd'}, fireItemMutationEvent:function(eventName) {
  var me = this, ownerGrid = me.ownerGrid, vm;
  Ext.suspendLayouts();
  if (ownerGrid) {
    if (eventName !== 'refresh') {
      vm = me.lookupViewModel();
    }
    ownerGrid[me.eventLifecycleMap[eventName]].apply(ownerGrid, Ext.Array.slice(arguments, 1));
  }
  me.fireEvent.apply(me, arguments);
  if (vm) {
    vm.notify();
  }
  Ext.resumeLayouts(true);
}, saveFocusState:function() {
  var me = this, store = me.dataSource || me.store, navModel = me.getNavigationModel(), lastFocusedIndex = navModel.recordIndex, lastFocusedRec = navModel.record, containsFocus = me.el.contains(Ext.Element.getActiveElement());
  if (lastFocusedRec) {
    if (containsFocus) {
      me.el.dom.focus();
    }
    return function() {
      if (store.getCount()) {
        lastFocusedIndex = Math.min(lastFocusedIndex, me.all.getCount() - 1);
        navModel.setPosition(store.contains(lastFocusedRec) ? lastFocusedRec : lastFocusedIndex, null, null, true, !containsFocus);
      }
    };
  }
  return Ext.emptyFn;
}, refreshNode:function(record) {
  if (Ext.isNumber(record)) {
    record = this.store.getAt(record);
  }
  this.onUpdate(this.dataSource, record);
}, updateIndexes:function(startIndex, endIndex) {
  var me = this, nodes = me.all.elements, records = me.getViewRange(), selModel = me.getSelectionModel(), myId = me.id, node, record, i;
  startIndex = startIndex || 0;
  endIndex = endIndex || (endIndex === 0 ? 0 : nodes.length - 1);
  for (i = startIndex; i <= endIndex; i++) {
    node = nodes[i];
    record = records[i];
    node.setAttribute('data-recordIndex', i);
    node.setAttribute('data-recordId', record.internalId);
    node.setAttribute('data-boundView', myId);
    if (selModel.getLastSelected()) {
      me[selModel.isSelected(record) ? 'onItemSelect' : 'onItemDeselect'](record);
    }
  }
}, bindStore:function(store, initial) {
  var me = this, selModel = me.getSelectionModel(), navModel = me.getNavigationModel();
  if (selModel && !selModel.destroyed) {
    selModel.bindStore(store, initial);
    selModel.bindComponent(store ? me : null);
  }
  me.mixins.storeholder.bindStore.apply(me, arguments);
  if (navModel && !navModel.destroyed) {
    navModel.setStore(store);
  }
  if (store && me.componentLayoutCounter && !me.blockRefresh) {
    me.doFirstRefresh(store, !initial);
  }
}, doFirstRefresh:function(store, noDefer) {
  var me = this;
  if (me.deferInitialRefresh && !noDefer) {
    Ext.defer(me.doFirstRefresh, 1, me, [store, true]);
  } else {
    if (store && !me.deferRefreshForLoad(store)) {
      me.refresh();
    }
  }
}, onUnbindStore:function(store) {
  this.setMaskBind(null);
  if (this.dataSource === store) {
    this.dataSource = null;
  }
}, onBindStore:function(store, oldStore) {
  var me = this;
  if (me.store.isBufferedStore) {
    me.store.preserveScrollOnReload = me.preserveScrollOnReload;
  }
  if (oldStore && oldStore.isBufferedStore) {
    delete oldStore.preserveScrollOnReload;
  }
  me.setMaskBind(store);
  if (!me.dataSource) {
    me.dataSource = store;
  }
}, setMaskBind:function(store) {
  var mask = this.loadMask;
  if (this.rendered && mask && store && !mask.bindStore) {
    mask = this.createMask();
  }
  if (mask && mask.bindStore) {
    mask.bindStore(store);
  }
}, getStoreListeners:function() {
  var me = this;
  return {refresh:me.onDataRefresh, replace:me.onReplace, add:me.onAdd, remove:me.onRemove, update:me.onUpdate, clear:me.onDataRefresh, beginupdate:me.onBeginUpdate, endupdate:me.onEndUpdate};
}, onBeginUpdate:function() {
  ++this.updateSuspendCounter;
  Ext.suspendLayouts();
}, onEndUpdate:function() {
  var me = this;
  if (me.updateSuspendCounter) {
    --me.updateSuspendCounter;
  }
  Ext.resumeLayouts(true);
  if (me.refreshSizePending) {
    me.refreshSize(true);
    me.refreshSizePending = false;
  }
}, onDataRefresh:function(store) {
  var me = this, preserveScrollOnRefresh = me.preserveScrollOnRefresh;
  if (store.loadCount > (me.lastRefreshLoadCount || 0)) {
    me.preserveScrollOnRefresh = me.preserveScrollOnReload;
  }
  me.refreshView();
  me.preserveScrollOnRefresh = preserveScrollOnRefresh;
  me.lastRefreshLoadCount = store.loadCount;
}, refreshView:function(startIndex) {
  var me = this, blocked = me.blockRefresh || !me.rendered || me.up('[collapsed],[isCollapsingOrExpanding\x3d1],[hidden]'), bufferedRenderer = me.bufferedRenderer;
  if (blocked) {
    me.refreshNeeded = true;
  } else {
    if (bufferedRenderer) {
      bufferedRenderer.refreshView(startIndex);
    } else {
      me.refresh();
    }
  }
}, findItemByChild:function(node) {
  return Ext.fly(node).findParent(this.getItemSelector(), this.getTargetEl());
}, findTargetByEvent:function(e) {
  return e.getTarget(this.getItemSelector(), this.getTargetEl());
}, getSelectedNodes:function() {
  var nodes = [], records = this.getSelectionModel().getSelection(), ln = records.length, i = 0;
  for (; i < ln; i++) {
    nodes.push(this.getNode(records[i]));
  }
  return nodes;
}, getRecords:function(nodes) {
  var me = this, records = [], i;
  for (i = 0; i < nodes.length; i++) {
    records.push(me.getRecord(nodes[i]));
  }
  return records;
}, getRecord:function(node) {
  var dom = Ext.getDom(node), id = dom.getAttribute('data-recordId');
  return this.dataSource.getByInternalId(id);
}, isSelected:function(node) {
  var r = this.getRecord(node);
  return this.getSelectionModel().isSelected(r);
}, select:function(records, keepExisting, suppressEvent) {
  this.getSelectionModel().select(records, keepExisting, suppressEvent);
}, deselect:function(records, suppressEvent) {
  this.getSelectionModel().deselect(records, suppressEvent);
}, getNode:function(nodeInfo) {
  var me = this, out;
  if (me.rendered && (nodeInfo || nodeInfo === 0)) {
    if (Ext.isString(nodeInfo)) {
      out = document.getElementById(nodeInfo);
    } else {
      if (nodeInfo.isModel) {
        out = me.getNodeByRecord(nodeInfo);
      } else {
        if (Ext.isNumber(nodeInfo)) {
          out = me.all.elements[nodeInfo];
        } else {
          if (nodeInfo.target && nodeInfo.target.nodeType) {
            nodeInfo = nodeInfo.target;
          }
          out = Ext.fly(nodeInfo).findParent(me.itemSelector, me.getTargetEl());
        }
      }
    }
  }
  return out || null;
}, getNodeByRecord:function(record) {
  var index = this.store.indexOf(record);
  return this.all.elements[index] || null;
}, getNodes:function(start, end) {
  var all = this.all;
  if (end !== undefined) {
    end++;
  }
  return all.slice(start, end);
}, indexOf:function(node) {
  node = this.getNode(node);
  if (!node && node !== 0) {
    return -1;
  }
  if (node.getAttribute('data-recordIndex')) {
    return Number(node.getAttribute('data-recordIndex'));
  }
  return this.all.indexOf(node);
}, doDestroy:function() {
  var me = this, count = me.updateSuspendCounter, tabGuardEl = me.tabGuardEl;
  if (me.viewScrollListeners) {
    me.viewScrollListeners.destroy();
  }
  if (me.all && !me.all.destroyed) {
    me.all.clear();
  }
  if (tabGuardEl) {
    if (tabGuardEl.parentNode) {
      tabGuardEl.parentNode.removeChild(tabGuardEl);
    }
  }
  me.emptyEl = null;
  me.setItemsDraggable(false);
  me.bindStore(null);
  if (me.selModelRelayer) {
    me.selModelRelayer.destroy();
  }
  Ext.destroy(me.navigationModel, me.selectionModel, me.loadMask);
  while (count--) {
    Ext.resumeLayouts(true);
  }
  Ext.Component.prototype.doDestroy.call(this);
}, onItemSelect:function(record) {
  var node = this.getNode(record);
  if (node) {
    Ext.fly(node).addCls(this.selectedItemCls);
    node.setAttribute('aria-selected', 'true');
  }
  return node;
}, onItemDeselect:function(record) {
  var node = this.getNode(record);
  if (node) {
    Ext.fly(node).removeCls(this.selectedItemCls);
    node.setAttribute('aria-selected', 'false');
  }
  return node;
}, getItemSelector:function() {
  return this.itemSelector;
}, addItemCls:function(itemInfo, cls) {
  var item = this.getNode(itemInfo);
  if (item) {
    Ext.fly(item).addCls(cls);
  }
}, removeItemCls:function(itemInfo, cls) {
  var item = this.getNode(itemInfo);
  if (item) {
    Ext.fly(item).removeCls(cls);
  }
}, setStore:function(newStore) {
  var me = this;
  if (me.store !== newStore) {
    if (me.isConfiguring) {
      me.store = newStore;
    } else {
      me.bindStore(newStore, false);
    }
  }
}, privates:{deferRefreshForLoad:function(store) {
  return store.isLoading();
}, toggleChildrenTabbability:function(enableTabbing) {
  var focusEl = this.getTargetEl();
  if (enableTabbing) {
    focusEl.restoreTabbableState({skipSelf:true});
  } else {
    focusEl.saveTabbableState({skipSelf:true, includeSaved:false});
  }
}, collectNodes:function(targetEl) {
  var all = this.all, options = {role:this.itemAriaRole};
  all.fill(Ext.fly(targetEl).query(this.getItemSelector()), all.startIndex || 0);
  if (this.focusable) {
    options.tabindex = '-1';
  }
  all.set(options);
}, createMask:function(mask) {
  var me = this, maskStore = me.getStore(), cfg;
  if (maskStore && !maskStore.isEmptyStore && !maskStore.loadsSynchronously()) {
    cfg = {target:me, msg:me.loadingText, useMsg:me.loadingUseMsg, store:maskStore};
    if (me.loadingCls) {
      cfg.msgCls = me.loadingCls;
    }
    if (Ext.isObject(mask)) {
      cfg = Ext.apply(cfg, mask);
    }
    me.loadMask = new Ext.LoadMask(cfg);
    me.loadMask.on({scope:me, beforeshow:me.onMaskBeforeShow, hide:me.onMaskHide});
  }
  return me.loadMask;
}, getNodeContainer:function() {
  var target = this.getTargetEl(), selector = this.nodeContainerSelector;
  return selector ? target.down(selector, true) : target;
}, getOverflowEl:function() {
  return Ext.Component.prototype.getTargetEl.call(this);
}}}, 1, 0, ['component', 'box'], {'component':true, 'box':true}, 0, [[Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder]], [Ext.view, 'AbstractView'], function() {
  Ext.deprecate('extjs', '4.0', function() {
    Ext.view.AbstractView.override({getSelectionCount:function() {
      if (Ext.global.console) {
        Ext.global.console.warn('DataView: getSelectionCount will be removed, please interact with the Ext.selection.DataViewModel');
      }
      return this.selModel.getSelection().length;
    }, getSelectedRecords:function() {
      if (Ext.global.console) {
        Ext.global.console.warn('DataView: getSelectedRecords will be removed, please interact with the Ext.selection.DataViewModel');
      }
      return this.selModel.getSelection();
    }, select:function(records, keepExisting, supressEvents) {
      if (Ext.global.console) {
        Ext.global.console.warn("DataView: select will be removed, please access select through a DataView's SelectionModel, ie: view.getSelectionModel().select()");
      }
      var sm = this.getSelectionModel();
      return sm.select.apply(sm, arguments);
    }, clearSelections:function() {
      if (Ext.global.console) {
        Ext.global.console.warn("DataView: clearSelections will be removed, please access deselectAll through DataView's SelectionModel, ie: view.getSelectionModel().deselectAll()");
      }
      var sm = this.getSelectionModel();
      return sm.deselectAll();
    }});
  });
});
Ext.cmd.derive('Ext.view.View', Ext.view.AbstractView, {alternateClassName:'Ext.DataView', inputTagRe:/^textarea$|^input$/i, keyEventRe:/^key/, manageLayoutScroll:false, inheritableStatics:{EventMap:{longpress:'LongPress', mousedown:'MouseDown', mouseup:'MouseUp', click:'Click', dblclick:'DblClick', contextmenu:'ContextMenu', mouseover:'MouseOver', mouseout:'MouseOut', mouseenter:'MouseEnter', mouseleave:'MouseLeave', keydown:'KeyDown', keyup:'KeyUp', keypress:'KeyPress', focus:'Focus'}, TouchEventMap:{touchstart:'mousedown', 
touchend:'mouseup', tap:'click', doubletap:'dblclick'}}, afterRender:function() {
  var me = this;
  Ext.view.AbstractView.prototype.afterRender.call(this);
  me.mon(me.el, {scope:me, click:me.handleEvent, longpress:me.handleEvent, mousedown:me.handleEvent, mouseup:me.handleEvent, dblclick:me.handleEvent, contextmenu:me.handleEvent, keydown:me.handleEvent, keyup:me.handleEvent, keypress:me.handleEvent, mouseover:me.handleMouseOver, mouseout:me.handleMouseOut});
}, getTargetSelector:function() {
  return this.dataRowSelector || this.itemSelector;
}, handleMouseOver:function(e) {
  var me = this, itemSelector = me.getTargetSelector(), item = e.getTarget(itemSelector);
  if (!me.destroyed) {
    if (item) {
      if (me.mouseOverItem !== item && me.el.contains(item)) {
        me.mouseOverItem = e.item = item;
        e.newType = 'mouseenter';
        me.handleEvent(e);
      }
    } else {
      me.handleEvent(e);
    }
  }
}, handleMouseOut:function(e) {
  var me = this, itemSelector = me.getTargetSelector(), item = e.getTarget(itemSelector), computedRelatedTarget = e.getRelatedTarget(itemSelector), sourceView;
  if (item === computedRelatedTarget && !(item === null && computedRelatedTarget === null)) {
    return;
  }
  if (!me.destroyed) {
    if (item && (sourceView = me.self.getBoundView(item))) {
      e.item = item;
      e.newType = 'mouseleave';
      sourceView.handleEvent(e);
      sourceView.mouseOverItem = null;
    } else {
      me.handleEvent(e);
    }
  }
}, handleEvent:function(e) {
  var me = this, isKeyEvent = me.keyEventRe.test(e.type);
  e.isInputFieldEvent = Ext.fly(e.target).isInputField();
  e.view = me;
  e.item = e.getTarget(me.itemSelector);
  if (e.item) {
    e.record = me.getRecord(e.item);
  }
  if (me.processUIEvent(e) !== false && !me.destroyed) {
    me.processSpecialEvent(e);
  }
  if (isKeyEvent && !e.isInputFieldEvent) {
    if (e.getKey() === e.SPACE || e.isNavKeyPress(true)) {
      e.preventDefault();
    }
  }
  e.view = null;
}, processItemEvent:Ext.emptyFn, processContainerEvent:Ext.emptyFn, processSpecialEvent:Ext.emptyFn, processUIEvent:function(e) {
  if (!Ext.getBody().isAncestor(e.target)) {
    return;
  }
  var me = this, item = e.item, self = me.self, map = self.EventMap, touchMap = self.TouchEventMap, index, record = e.record, type = e.type, newType = type;
  if (e.newType) {
    newType = e.newType;
  }
  if (item) {
    newType = touchMap[newType] || newType;
    index = e.recordIndex = me.indexInStore ? me.indexInStore(record) : me.indexOf(item);
    if (!record || me.processItemEvent(record, item, index, e) === false) {
      return false;
    }
    if (me['onBeforeItem' + map[newType]](record, item, index, e) === false || me.fireEvent('beforeitem' + newType, me, record, item, index, e) === false || me['onItem' + map[newType]](record, item, index, e) === false) {
      return false;
    }
    me.fireEvent('item' + newType, me, record, item, index, e);
  } else {
    type = touchMap[type] || type;
    if (me.processContainerEvent(e) === false || me['onBeforeContainer' + map[type]](e) === false || me.fireEvent('beforecontainer' + type, me, e) === false || me['onContainer' + map[type]](e) === false) {
      return false;
    }
    me.fireEvent('container' + type, me, e);
  }
  return true;
}, onItemMouseEnter:function(record, item, index, e) {
  if (this.trackOver) {
    this.highlightItem(item);
  }
}, onItemMouseLeave:function(record, item, index, e) {
  if (this.trackOver) {
    this.clearHighlight();
  }
}, onItemMouseDown:Ext.emptyFn, onItemLongPress:Ext.emptyFn, onItemMouseUp:Ext.emptyFn, onItemFocus:Ext.emptyFn, onItemClick:Ext.emptyFn, onItemDblClick:Ext.emptyFn, onItemContextMenu:Ext.emptyFn, onItemKeyDown:Ext.emptyFn, onItemKeyUp:Ext.emptyFn, onItemKeyPress:Ext.emptyFn, onBeforeItemLongPress:Ext.emptyFn, onBeforeItemMouseDown:Ext.emptyFn, onBeforeItemMouseUp:Ext.emptyFn, onBeforeItemFocus:Ext.emptyFn, onBeforeItemMouseEnter:Ext.emptyFn, onBeforeItemMouseLeave:Ext.emptyFn, onBeforeItemClick:Ext.emptyFn, 
onBeforeItemDblClick:Ext.emptyFn, onBeforeItemContextMenu:Ext.emptyFn, onBeforeItemKeyDown:Ext.emptyFn, onBeforeItemKeyUp:Ext.emptyFn, onBeforeItemKeyPress:Ext.emptyFn, onContainerMouseDown:Ext.emptyFn, onContainerLongPress:Ext.emptyFn, onContainerMouseUp:Ext.emptyFn, onContainerMouseOver:Ext.emptyFn, onContainerMouseOut:Ext.emptyFn, onContainerClick:Ext.emptyFn, onContainerDblClick:Ext.emptyFn, onContainerContextMenu:Ext.emptyFn, onContainerKeyDown:Ext.emptyFn, onContainerKeyUp:Ext.emptyFn, onContainerKeyPress:Ext.emptyFn, 
onBeforeContainerMouseDown:Ext.emptyFn, onBeforeContainerLongPress:Ext.emptyFn, onBeforeContainerMouseUp:Ext.emptyFn, onBeforeContainerMouseOver:Ext.emptyFn, onBeforeContainerMouseOut:Ext.emptyFn, onBeforeContainerClick:Ext.emptyFn, onBeforeContainerDblClick:Ext.emptyFn, onBeforeContainerContextMenu:Ext.emptyFn, onBeforeContainerKeyDown:Ext.emptyFn, onBeforeContainerKeyUp:Ext.emptyFn, onBeforeContainerKeyPress:Ext.emptyFn, setHighlightedItem:function(item) {
  var me = this, highlighted = me.highlightedItem, overItemCls = me.overItemCls;
  if (highlighted !== item) {
    if (highlighted) {
      Ext.fly(highlighted).removeCls(overItemCls);
      if (Ext.isIE8) {
        me.repaintBorder(highlighted);
        me.repaintBorder(highlighted.nextSibling);
      }
      if (me.hasListeners.unhighlightitem) {
        me.fireEvent('unhighlightitem', me, highlighted);
      }
    }
    me.highlightedItem = item;
    if (item) {
      Ext.fly(item).addCls(me.overItemCls);
      if (Ext.isIE8) {
        me.repaintBorder(item.nextSibling);
      }
      if (me.hasListeners.highlightitem) {
        me.fireEvent('highlightitem', me, item);
      }
    }
  }
}, highlightItem:function(item) {
  this.setHighlightedItem(item);
}, clearHighlight:function() {
  this.setHighlightedItem(undefined);
}, handleUpdate:function(store, record) {
  var me = this, node, newNode, highlighted;
  if (me.viewReady) {
    node = me.getNode(record);
    newNode = Ext.view.AbstractView.prototype.handleUpdate.apply(this, arguments);
    highlighted = me.highlightedItem;
    if (highlighted && highlighted === node) {
      delete me.highlightedItem;
      if (newNode) {
        me.highlightItem(newNode);
      }
    }
  }
}, refresh:function() {
  this.clearHighlight();
  Ext.view.AbstractView.prototype.refresh.apply(this, arguments);
}, focusNode:function(rec) {
  var me = this, node = Ext.fly(me.getNode(rec)), el = me.el, adjustmentY = 0, adjustmentX = 0, elRegion = el.getRegion(), nodeRegion;
  elRegion.bottom = elRegion.top + el.dom.clientHeight;
  elRegion.right = elRegion.left + el.dom.clientWidth;
  if (node) {
    nodeRegion = node.getRegion();
    if (nodeRegion.top < elRegion.top) {
      adjustmentY = nodeRegion.top - elRegion.top;
    } else {
      if (nodeRegion.bottom > elRegion.bottom) {
        adjustmentY = nodeRegion.bottom - elRegion.bottom;
      }
    }
    if (nodeRegion.left < elRegion.left) {
      adjustmentX = nodeRegion.left - elRegion.left;
    } else {
      if (nodeRegion.right > elRegion.right) {
        adjustmentX = nodeRegion.right - elRegion.right;
      }
    }
    if (adjustmentX || adjustmentY) {
      me.scrollBy(adjustmentX, adjustmentY, false);
    }
    node.set({tabIndex:-1});
    node.focus();
  }
}, privates:{repaintBorder:function(rowIdx) {
  var node = this.getNode(rowIdx);
  if (node) {
    node.className = node.className;
  }
}}}, 0, ['dataview'], ['component', 'box', 'dataview'], {'component':true, 'box':true, 'dataview':true}, ['widget.dataview'], 0, [Ext.view, 'View', Ext, 'DataView'], 0);
Ext.cmd.derive('Ext.view.BoundListKeyNav', Ext.view.NavigationModel, {navigateOnSpace:true, initKeyNav:function(view) {
  var me = this, field = view.pickerField;
  if (!me.keyNav) {
    Ext.view.NavigationModel.prototype.initKeyNav.call(this, view);
    me.keyNav.map.addBinding({key:Ext.event.Event.ESC, fn:me.onKeyEsc, scope:me});
  }
  if (!field) {
    return;
  }
  if (!field.rendered) {
    field.on('render', Ext.Function.bind(me.initKeyNav, me, [view], 0), me, {single:true});
    return;
  }
  me.fieldKeyNav = new Ext.util.KeyNav({disabled:true, target:field.inputEl, forceKeyDown:true, up:me.onKeyUp, down:me.onKeyDown, right:me.onKeyRight, left:me.onKeyLeft, pageDown:me.onKeyPageDown, pageUp:me.onKeyPageUp, home:me.onKeyHome, end:me.onKeyEnd, tab:me.onKeyTab, space:me.onKeySpace, enter:me.onKeyEnter, A:{ctrl:true, handler:me.onSelectAllKeyPress}, priority:1001, scope:me});
}, processViewEvent:function(view, record, node, index, event) {
  if (event.within(view.listWrap)) {
    return event;
  }
  if (event.getKey() === event.ESC) {
    if (Ext.fly(event.target).isInputField()) {
      event.target = event.target.parentNode;
    }
    return event;
  }
}, enable:function() {
  this.fieldKeyNav.enable();
  Ext.view.NavigationModel.prototype.enable.call(this);
}, disable:function() {
  this.fieldKeyNav.disable();
  Ext.view.NavigationModel.prototype.disable.call(this);
}, onItemMouseDown:function(view, record, item, index, event) {
  Ext.view.NavigationModel.prototype.onItemMouseDown.call(this, view, record, item, index, event);
  if (event.pointerType === 'mouse') {
    event.preventDefault();
  }
}, onKeyUp:function(e) {
  var me = this, boundList = me.view, allItems = boundList.all, oldItem = boundList.highlightedItem, oldItemIdx = oldItem ? boundList.indexOf(oldItem) : -1, newItemIdx = oldItemIdx > 0 ? oldItemIdx - 1 : allItems.getCount() - 1;
  me.setPosition(newItemIdx);
  e.preventDefault();
}, onKeyDown:function(e) {
  var me = this, boundList = me.view, allItems = boundList.all, oldItem = boundList.highlightedItem, oldItemIdx = oldItem ? boundList.indexOf(oldItem) : -1, newItemIdx = oldItemIdx < allItems.getCount() - 1 ? oldItemIdx + 1 : 0;
  me.setPosition(newItemIdx);
  e.preventDefault();
}, onKeyLeft:Ext.returnTrue, onKeyRight:Ext.returnTrue, onKeyTab:function(e) {
  var view = this.view, field = view.pickerField;
  if (view.isVisible()) {
    if (field.selectOnTab) {
      this.selectHighlighted(e);
    }
    if (field.collapse) {
      field.collapse();
    }
  }
  return true;
}, onKeyEnter:function(e) {
  var view = this.view, selModel = view.getSelectionModel(), field = view.pickerField, count = selModel.getCount();
  e.stopEvent();
  this.selectHighlighted(e);
  if (!field.multiSelect && count === selModel.getCount() && field.collapse) {
    field.collapse();
  }
  field.fireEvent('specialkey', field, e, {fromBoundList:true});
  return false;
}, onKeySpace:function() {
  if (this.navigateOnSpace) {
    Ext.view.NavigationModel.prototype.onKeySpace.apply(this, arguments);
  }
  return true;
}, onKeyEsc:function() {
  if (this.view.pickerField) {
    this.view.pickerField.collapse();
  }
}, focusItem:function(item) {
  var me = this, boundList = me.view;
  if (typeof item === 'number') {
    item = boundList.all.item(item);
  }
  if (item) {
    item = item.dom;
    boundList.highlightItem(item);
    boundList.getScrollable().ensureVisible(item, {x:false});
  }
}, selectHighlighted:function(e) {
  var me = this, boundList = me.view, selModel = boundList.getSelectionModel(), highlightedRec, highlightedPosition = me.recordIndex;
  if (boundList.all.getCount()) {
    highlightedRec = me.getRecord();
    if (highlightedRec) {
      if (e.getKey() === e.ENTER || !selModel.isSelected(highlightedRec)) {
        selModel.selectWithEvent(highlightedRec, e);
        if (!boundList.store.data.contains(highlightedRec)) {
          me.setPosition(Math.min(highlightedPosition, boundList.store.getCount() - 1));
        }
      }
    }
  }
}, destroy:function() {
  this.fieldKeyNav = Ext.destroy(this.fieldKeyNav);
  Ext.view.NavigationModel.prototype.destroy.call(this);
}}, 0, 0, 0, 0, ['view.navigation.boundlist'], 0, [Ext.view, 'BoundListKeyNav'], 0);
Ext.cmd.derive('Ext.layout.component.BoundList', Ext.layout.component.Auto, {type:'component', beginLayout:function(ownerContext) {
  var me = this, owner = me.owner, toolbar = owner.pagingToolbar;
  me.scrollPos = owner.listWrap.getScroll();
  Ext.layout.component.Auto.prototype.beginLayout.apply(this, arguments);
  if (owner.floating) {
    ownerContext.savedXY = owner.getXY();
    owner.setXY([0, -9999]);
  }
  if (toolbar) {
    ownerContext.toolbarContext = ownerContext.context.getCmp(toolbar);
  }
  ownerContext.listContext = ownerContext.getEl('listWrap');
}, beginLayoutCycle:function(ownerContext) {
  var owner = this.owner;
  Ext.layout.component.Auto.prototype.beginLayoutCycle.apply(this, arguments);
  if (ownerContext.heightModel.auto) {
    owner.el.setHeight('auto');
    owner.listWrap.setHeight('auto');
  }
}, getLayoutItems:function() {
  var toolbar = this.owner.pagingToolbar;
  return toolbar ? [toolbar] : [];
}, isValidParent:function() {
  return true;
}, finishedLayout:function(ownerContext) {
  var me = this, xy = ownerContext.savedXY, owner = me.owner, listWrap = owner.listWrap, scrollPos = me.scrollPos;
  Ext.layout.component.Auto.prototype.finishedLayout.apply(this, arguments);
  if (xy) {
    me.owner.setXY(xy);
  }
  listWrap.setScrollLeft(scrollPos.left);
  listWrap.setScrollTop(scrollPos.top);
}, measureContentWidth:function(ownerContext) {
  return this.owner.listWrap.getWidth();
}, measureContentHeight:function(ownerContext) {
  return this.owner.listWrap.getHeight();
}, publishInnerHeight:function(ownerContext, height) {
  var toolbar = ownerContext.toolbarContext, toolbarHeight = 0;
  if (toolbar) {
    toolbarHeight = toolbar.getProp('height');
  }
  if (toolbarHeight === undefined) {
    this.done = false;
  } else {
    ownerContext.listContext.setHeight(height - ownerContext.getFrameInfo().height - toolbarHeight);
  }
}, calculateOwnerHeightFromContentHeight:function(ownerContext) {
  var height = Ext.layout.component.Auto.prototype.calculateOwnerHeightFromContentHeight.apply(this, arguments), toolbar = ownerContext.toolbarContext;
  if (toolbar) {
    height += toolbar.getProp('height');
  }
  return height;
}}, 0, 0, 0, 0, ['layout.boundlist'], 0, [Ext.layout.component, 'BoundList'], 0);
Ext.cmd.derive('Ext.toolbar.Item', Ext.Component, {alternateClassName:'Ext.Toolbar.Item', enable:Ext.emptyFn, disable:Ext.emptyFn, focus:Ext.emptyFn}, 0, ['tbitem'], ['component', 'box', 'tbitem'], {'component':true, 'box':true, 'tbitem':true}, ['widget.tbitem'], 0, [Ext.toolbar, 'Item', Ext.Toolbar, 'Item'], 0);
Ext.cmd.derive('Ext.toolbar.TextItem', Ext.toolbar.Item, {alternateClassName:'Ext.Toolbar.TextItem', text:'', baseCls:'x-toolbar-text', ariaRole:null, beforeRender:function() {
  var text = this.text;
  Ext.toolbar.Item.prototype.beforeRender.call(this);
  if (text) {
    this.html = text;
  }
}, setText:function(text) {
  this.update(text);
}}, 0, ['tbtext'], ['component', 'box', 'tbitem', 'tbtext'], {'component':true, 'box':true, 'tbitem':true, 'tbtext':true}, ['widget.tbtext'], 0, [Ext.toolbar, 'TextItem', Ext.Toolbar, 'TextItem'], 0);
Ext.cmd.derive('Ext.form.trigger.Spinner', Ext.form.trigger.Trigger, {cls:'x-form-trigger-spinner', spinnerCls:'x-form-spinner', spinnerUpCls:'x-form-spinner-up', spinnerDownCls:'x-form-spinner-down', focusCls:'x-form-spinner-focus', overCls:'x-form-spinner-over', clickCls:'x-form-spinner-click', focusFieldOnClick:true, vertical:true, bodyTpl:'\x3ctpl if\x3d"vertical"\x3e\x3cdiv class\x3d"{spinnerCls} {spinnerCls}-{ui} {spinnerUpCls} {spinnerUpCls}-{ui} {childElCls} {upDisabledCls}"\x3e\x3c/div\x3e\x3c/tpl\x3e\x3cdiv class\x3d"{spinnerCls} {spinnerCls}-{ui} {spinnerDownCls} {spinnerDownCls}-{ui} {childElCls} {downDisabledCls}"\x3e\x3c/div\x3e\x3ctpl if\x3d"!vertical"\x3e\x3cdiv class\x3d"{spinnerCls} {spinnerCls}-{ui} {spinnerUpCls} {spinnerUpCls}-{ui} {childElCls} {upDisabledCls}"\x3e\x3c/div\x3e\x3c/tpl\x3e', 
destroy:function() {
  var me = this;
  if (me.spinnerEl) {
    me.spinnerEl.destroy();
    me.spinnerEl = me.upEl = me.downEl = null;
  }
  Ext.form.trigger.Trigger.prototype.destroy.call(this);
}, getBodyRenderData:function() {
  var me = this;
  return {vertical:me.vertical, upDisabledCls:me.upEnabled ? '' : me.spinnerUpCls + '-disabled', downDisabledCls:me.downEnabled ? '' : me.spinnerDownCls + '-disabled', spinnerCls:me.spinnerCls, spinnerUpCls:me.spinnerUpCls, spinnerDownCls:me.spinnerDownCls};
}, getStateEl:function() {
  return this.spinnerEl;
}, onClick:function() {
  var me = this, args = arguments, e = me.clickRepeater ? args[1] : args[0], field = me.field;
  if (!field.readOnly && !field.disabled) {
    if (me.upEl.contains(e.target)) {
      Ext.callback(me.upHandler, me.scope, [field, me, e], 0, field);
    } else {
      if (me.downEl.contains(e.target)) {
        Ext.callback(me.downHandler, me.scope, [field, me, e], 0, field);
      }
    }
  }
  field.inputEl.focus();
}, onFieldRender:function() {
  var me = this, vertical = me.vertical, spinnerEl, elements;
  Ext.form.trigger.Trigger.prototype.onFieldRender.call(this);
  spinnerEl = me.spinnerEl = me.el.select('.' + me.spinnerCls, true);
  elements = spinnerEl.elements;
  me.upEl = vertical ? elements[0] : elements[1];
  me.downEl = vertical ? elements[1] : elements[0];
}, setUpEnabled:function(enabled) {
  this.upEl[enabled ? 'removeCls' : 'addCls'](this.spinnerUpCls + '-disabled');
}, setDownEnabled:function(enabled) {
  this.downEl[enabled ? 'removeCls' : 'addCls'](this.spinnerDownCls + '-disabled');
}}, 0, 0, 0, 0, ['trigger.spinner'], 0, [Ext.form.trigger, 'Spinner'], 0);
Ext.cmd.derive('Ext.form.field.Spinner', Ext.form.field.Text, {alternateClassName:'Ext.form.Spinner', config:{triggers:{spinner:{type:'spinner', upHandler:'onSpinnerUpClick', downHandler:'onSpinnerDownClick', endHandler:'onSpinEnd', scope:'this'}}}, spinUpEnabled:true, spinDownEnabled:true, keyNavEnabled:true, mouseWheelEnabled:true, repeatTriggerClick:true, onSpinUp:Ext.emptyFn, onSpinDown:Ext.emptyFn, ariaRole:'spinbutton', applyTriggers:function(triggers) {
  var me = this, spinnerTrigger = triggers.spinner;
  spinnerTrigger.upEnabled = me.spinUpEnabled;
  spinnerTrigger.downEnabled = me.spinDownEnabled;
  return Ext.form.field.Text.prototype.applyTriggers.call(this, triggers);
}, onRender:function() {
  var me = this, spinnerTrigger = me.getTrigger('spinner');
  (arguments.callee.$previous || Ext.form.field.Text.prototype.onRender).call(this);
  if (me.keyNavEnabled) {
    me.spinnerKeyNav = new Ext.util.KeyNav({target:me.inputEl, scope:me, up:me.spinUp, down:me.spinDown});
    me.inputEl.on({keyup:me.onInputElKeyUp, scope:me});
  }
  if (me.mouseWheelEnabled) {
    me.mon(me.bodyEl, 'mousewheel', me.onMouseWheel, me);
  }
  me.spinUpEl = spinnerTrigger.upEl;
  me.spinDownEl = spinnerTrigger.downEl;
}, onSpinnerUpClick:function() {
  this.spinUp();
}, onSpinnerDownClick:function() {
  this.spinDown();
}, spinUp:function() {
  var me = this;
  if (me.spinUpEnabled && !me.disabled) {
    me.fireEvent('spin', me, 'up');
    me.fireEvent('spinup', me);
    me.onSpinUp();
  }
}, spinDown:function() {
  var me = this;
  if (me.spinDownEnabled && !me.disabled) {
    me.fireEvent('spin', me, 'down');
    me.fireEvent('spindown', me);
    me.onSpinDown();
  }
}, setSpinUpEnabled:function(enabled) {
  var me = this, wasEnabled = me.spinUpEnabled;
  me.spinUpEnabled = enabled;
  if (wasEnabled !== enabled && me.rendered) {
    me.getTrigger('spinner').setUpEnabled(enabled);
  }
}, setSpinDownEnabled:function(enabled) {
  var me = this, wasEnabled = me.spinDownEnabled;
  me.spinDownEnabled = enabled;
  if (wasEnabled !== enabled && me.rendered) {
    me.getTrigger('spinner').setDownEnabled(enabled);
  }
}, onMouseWheel:function(e) {
  var me = this, delta;
  if (me.hasFocus) {
    delta = e.getWheelDelta();
    if (delta > 0) {
      me.spinUp();
    } else {
      if (delta < 0) {
        me.spinDown();
      }
    }
    e.stopEvent();
    me.onSpinEnd();
  }
}, onInputElKeyUp:function(e) {
  if (e.keyCode === e.UP || e.keyCode === e.DOWN) {
    this.onSpinEnd();
  }
}, doDestroy:function() {
  Ext.destroyMembers(this, 'spinnerKeyNav');
  Ext.form.field.Text.prototype.doDestroy.call(this);
}}, 0, ['spinnerfield'], ['component', 'box', 'field', 'textfield', 'spinnerfield'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'spinnerfield':true}, ['widget.spinnerfield'], 0, [Ext.form.field, 'Spinner', Ext.form, 'Spinner'], function(Spinner) {
  var spinEnd = function() {
    if (!this.destroying && !this.destroyed) {
      this.fireEvent('spinend', this);
    }
  };
  Spinner.prototype.onSpinEnd = Ext.Function.createBuffered(spinEnd, 100);
});
Ext.cmd.derive('Ext.form.field.Number', Ext.form.field.Spinner, {alternateClassName:['Ext.form.NumberField', 'Ext.form.Number'], allowExponential:true, allowDecimals:true, decimalSeparator:null, submitLocaleSeparator:true, decimalPrecision:2, minValue:Number.NEGATIVE_INFINITY, maxValue:Number.MAX_VALUE, step:1, minText:'The minimum value for this field is {0}', maxText:'The maximum value for this field is {0}', nanText:'{0} is not a valid number', negativeText:'The value cannot be negative', baseChars:'0123456789', 
autoStripChars:false, initComponent:function() {
  var me = this;
  if (me.decimalSeparator === null) {
    me.decimalSeparator = Ext.util.Format.decimalSeparator;
  }
  Ext.form.field.Spinner.prototype.initComponent.call(this);
  me.setMinValue(me.minValue);
  me.setMaxValue(me.maxValue);
}, getSubTplData:function(fieldData) {
  var me = this, min = me.minValue, max = me.maxValue, data, inputElAttr, value;
  data = Ext.form.field.Spinner.prototype.getSubTplData.call(this, fieldData);
  inputElAttr = data.inputElAriaAttributes;
  if (inputElAttr) {
    if (min > Number.NEGATIVE_INFINITY) {
      inputElAttr['aria-valuemin'] = min;
    }
    if (max < Number.MAX_VALUE) {
      inputElAttr['aria-valuemax'] = max;
    }
    value = me.getValue();
    if (value != null && value >= min && value <= max) {
      inputElAttr['aria-valuenow'] = value;
    }
  }
  return data;
}, setValue:function(value) {
  var me = this, bind, valueBind;
  if (me.hasFocus) {
    bind = me.getBind();
    valueBind = bind && bind.value;
    if (valueBind && valueBind.syncing && value === me.value) {
      return me;
    }
  }
  return Ext.form.field.Spinner.prototype.setValue.call(this, value);
}, getErrors:function(value) {
  value = arguments.length > 0 ? value : this.processRawValue(this.getRawValue());
  var me = this, errors = Ext.form.field.Spinner.prototype.getErrors.call(this, value), format = Ext.String.format, num;
  if (value.length < 1) {
    return errors;
  }
  value = String(value).replace(me.decimalSeparator, '.');
  if (isNaN(value)) {
    errors.push(format(me.nanText, value));
  }
  num = me.parseValue(value);
  if (me.minValue === 0 && num < 0) {
    errors.push(this.negativeText);
  } else {
    if (num < me.minValue) {
      errors.push(format(me.minText, me.minValue));
    }
  }
  if (num > me.maxValue) {
    errors.push(format(me.maxText, me.maxValue));
  }
  return errors;
}, rawToValue:function(rawValue) {
  var value = this.fixPrecision(this.parseValue(rawValue));
  if (value === null) {
    value = rawValue || null;
  }
  return value;
}, valueToRaw:function(value) {
  var me = this, decimalSeparator = me.decimalSeparator;
  value = me.parseValue(value);
  value = me.fixPrecision(value);
  value = Ext.isNumber(value) ? value : parseFloat(String(value).replace(decimalSeparator, '.'));
  value = isNaN(value) ? '' : String(value).replace('.', decimalSeparator);
  return value;
}, getSubmitValue:function() {
  var me = this, value = Ext.form.field.Spinner.prototype.getSubmitValue.call(this);
  if (!me.submitLocaleSeparator) {
    value = value.replace(me.decimalSeparator, '.');
  }
  return value;
}, onChange:function(newValue) {
  var ariaDom = this.ariaEl.dom;
  this.toggleSpinners();
  Ext.form.field.Spinner.prototype.onChange.apply(this, arguments);
  if (ariaDom) {
    if (Ext.isNumber(newValue) && isFinite(newValue)) {
      ariaDom.setAttribute('aria-valuenow', newValue);
    } else {
      ariaDom.removeAttribute('aria-valuenow');
    }
  }
}, toggleSpinners:function() {
  var me = this, value = me.getValue(), valueIsNull = value === null, enabled;
  if (me.spinUpEnabled || me.spinUpDisabledByToggle) {
    enabled = valueIsNull || value < me.maxValue;
    me.setSpinUpEnabled(enabled, true);
  }
  if (me.spinDownEnabled || me.spinDownDisabledByToggle) {
    enabled = valueIsNull || value > me.minValue;
    me.setSpinDownEnabled(enabled, true);
  }
}, setMinValue:function(value) {
  var me = this, ariaDom = me.ariaEl.dom, minValue, allowed, ariaDom;
  me.minValue = minValue = Ext.Number.from(value, Number.NEGATIVE_INFINITY);
  me.toggleSpinners();
  if (ariaDom) {
    if (minValue > Number.NEGATIVE_INFINITY) {
      ariaDom.setAttribute('aria-valuemin', minValue);
    } else {
      ariaDom.removeAttribute('aria-valuemin');
    }
  }
  if (me.disableKeyFilter !== true) {
    allowed = me.baseChars + '';
    if (me.allowExponential) {
      allowed += me.decimalSeparator + 'e+-';
    } else {
      if (me.allowDecimals) {
        allowed += me.decimalSeparator;
      }
      if (me.minValue < 0) {
        allowed += '-';
      }
    }
    allowed = Ext.String.escapeRegex(allowed);
    me.maskRe = new RegExp('[' + allowed + ']');
    if (me.autoStripChars) {
      me.stripCharsRe = new RegExp('[^' + allowed + ']', 'gi');
    }
  }
}, setMaxValue:function(value) {
  var ariaDom = this.ariaEl.dom, maxValue;
  this.maxValue = maxValue = Ext.Number.from(value, Number.MAX_VALUE);
  if (ariaDom) {
    if (maxValue < Number.MAX_VALUE) {
      ariaDom.setAttribute('aria-valuemax', maxValue);
    } else {
      ariaDom.removeAttribute('aria-valuemax');
    }
  }
  this.toggleSpinners();
}, parseValue:function(value) {
  value = parseFloat(String(value).replace(this.decimalSeparator, '.'));
  return isNaN(value) ? null : value;
}, fixPrecision:function(value) {
  var me = this, nan = isNaN(value), precision = me.decimalPrecision;
  if (nan || !value) {
    return nan ? '' : value;
  } else {
    if (!me.allowDecimals || precision <= 0) {
      precision = 0;
    }
  }
  return parseFloat(Ext.Number.toFixed(parseFloat(value), precision));
}, onBlur:function(e) {
  var me = this, v = me.rawToValue(me.getRawValue());
  if (!Ext.isEmpty(v)) {
    me.setValue(v);
  }
  Ext.form.field.Spinner.prototype.onBlur.call(this, e);
}, setSpinUpEnabled:function(enabled, internal) {
  Ext.form.field.Spinner.prototype.setSpinUpEnabled.apply(this, arguments);
  if (!internal) {
    delete this.spinUpDisabledByToggle;
  } else {
    this.spinUpDisabledByToggle = !enabled;
  }
}, onSpinUp:function() {
  var me = this;
  if (!me.readOnly) {
    me.setSpinValue(Ext.Number.constrain(me.getValue() + me.step, me.minValue, me.maxValue));
  }
}, setSpinDownEnabled:function(enabled, internal) {
  Ext.form.field.Spinner.prototype.setSpinDownEnabled.apply(this, arguments);
  if (!internal) {
    delete this.spinDownDisabledByToggle;
  } else {
    this.spinDownDisabledByToggle = !enabled;
  }
}, onSpinDown:function() {
  var me = this;
  if (!me.readOnly) {
    me.setSpinValue(Ext.Number.constrain(me.getValue() - me.step, me.minValue, me.maxValue));
  }
}, setSpinValue:function(value) {
  var me = this;
  if (me.enforceMaxLength) {
    if (me.fixPrecision(value).toString().length > me.maxLength) {
      return;
    }
  }
  me.setValue(value);
}}, 0, ['numberfield'], ['component', 'box', 'field', 'textfield', 'spinnerfield', 'numberfield'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'spinnerfield':true, 'numberfield':true}, ['widget.numberfield'], 0, [Ext.form.field, 'Number', Ext.form, 'NumberField', Ext.form, 'Number'], 0);
Ext.cmd.derive('Ext.toolbar.Paging', Ext.toolbar.Toolbar, {alternateClassName:'Ext.PagingToolbar', displayInfo:false, prependButtons:false, displayMsg:'Displaying {0} - {1} of {2}', emptyMsg:'No data to display', beforePageText:'Page', afterPageText:'of {0}', firstText:'First Page', prevText:'Previous Page', nextText:'Next Page', lastText:'Last Page', refreshText:'Refresh', inputItemWidth:30, emptyPageData:{total:0, currentPage:0, pageCount:0, toRecord:0, fromRecord:0}, defaultBindProperty:'store', 
getPagingItems:function() {
  var me = this, inputListeners = {scope:me, blur:me.onPagingBlur};
  inputListeners[Ext.supports.SpecialKeyDownRepeat ? 'keydown' : 'keypress'] = me.onPagingKeyDown;
  return [{itemId:'first', tooltip:me.firstText, overflowText:me.firstText, iconCls:'x-tbar-page-first', disabled:true, handler:me.moveFirst, scope:me}, {itemId:'prev', tooltip:me.prevText, overflowText:me.prevText, iconCls:'x-tbar-page-prev', disabled:true, handler:me.movePrevious, scope:me}, '-', me.beforePageText, {xtype:'numberfield', itemId:'inputItem', name:'inputItem', cls:'x-tbar-page-number', allowDecimals:false, minValue:1, hideTrigger:true, enableKeyEvents:true, keyNavEnabled:false, selectOnFocus:true, 
  submitValue:false, isFormField:false, width:me.inputItemWidth, margin:'-1 2 3 2', listeners:inputListeners}, {xtype:'tbtext', itemId:'afterTextItem', html:Ext.String.format(me.afterPageText, 1)}, '-', {itemId:'next', tooltip:me.nextText, overflowText:me.nextText, iconCls:'x-tbar-page-next', disabled:true, handler:me.moveNext, scope:me}, {itemId:'last', tooltip:me.lastText, overflowText:me.lastText, iconCls:'x-tbar-page-last', disabled:true, handler:me.moveLast, scope:me}, '-', {itemId:'refresh', 
  tooltip:me.refreshText, overflowText:me.refreshText, iconCls:'x-tbar-loading', disabled:me.store.isLoading(), handler:me.doRefresh, scope:me}];
}, initComponent:function() {
  var me = this, userItems = me.items || me.buttons || [], pagingItems;
  me.bindStore(me.store || 'ext-empty-store', true);
  pagingItems = me.getPagingItems();
  if (me.prependButtons) {
    me.items = userItems.concat(pagingItems);
  } else {
    me.items = pagingItems.concat(userItems);
  }
  delete me.buttons;
  if (me.displayInfo) {
    me.items.push('-\x3e');
    me.items.push({xtype:'tbtext', itemId:'displayItem'});
  }
  Ext.toolbar.Toolbar.prototype.initComponent.call(this);
}, beforeRender:function() {
  Ext.toolbar.Toolbar.prototype.beforeRender.apply(this, arguments);
  this.updateBarInfo();
}, onAdded:function(owner) {
  var me = this, oldStore = me.store, autoStore = me._autoStore, listener, store;
  if (autoStore === undefined) {
    me._autoStore = autoStore = !(oldStore && !oldStore.isEmptyStore);
  }
  if (autoStore) {
    listener = me._storeChangeListener;
    if (listener) {
      listener.destroy();
      listener = null;
    }
    store = owner && owner.store;
    if (store) {
      listener = owner.on({destroyable:true, scope:me, storechange:'onOwnerStoreChange'});
    }
    me._storeChangeListener = listener;
    me.onOwnerStoreChange(owner, store);
  }
  Ext.toolbar.Toolbar.prototype.onAdded.apply(this, arguments);
}, onOwnerStoreChange:function(owner, store) {
  this.setStore(store || Ext.getStore('ext-empty-store'));
}, updateBarInfo:function() {
  var me = this;
  if (!me.store.isLoading()) {
    me.calledInternal = true;
    me.onLoad();
    me.calledInternal = false;
  }
}, updateInfo:function() {
  var me = this, displayItem = me.child('#displayItem'), store = me.store, pageData = me.getPageData(), count, msg;
  if (displayItem) {
    count = store.getCount();
    if (count === 0) {
      msg = me.emptyMsg;
    } else {
      msg = Ext.String.format(me.displayMsg, pageData.fromRecord, pageData.toRecord, pageData.total);
    }
    displayItem.setText(msg);
  }
}, onLoad:function() {
  var me = this, pageData, currPage, pageCount, afterText, count, isEmpty, item;
  count = me.store.getCount();
  isEmpty = count === 0;
  if (!isEmpty) {
    pageData = me.getPageData();
    currPage = pageData.currentPage;
    pageCount = pageData.pageCount;
    if (currPage > pageCount) {
      if (pageCount > 0) {
        me.store.loadPage(pageCount);
      } else {
        me.getInputItem().reset();
      }
      return;
    }
    afterText = Ext.String.format(me.afterPageText, isNaN(pageCount) ? 1 : pageCount);
  } else {
    currPage = 0;
    pageCount = 0;
    afterText = Ext.String.format(me.afterPageText, 0);
  }
  Ext.suspendLayouts();
  item = me.child('#afterTextItem');
  if (item) {
    item.update(afterText);
  }
  item = me.getInputItem();
  if (item) {
    item.setDisabled(isEmpty).setValue(currPage);
  }
  me.setChildDisabled('#first', currPage === 1 || isEmpty);
  me.setChildDisabled('#prev', currPage === 1 || isEmpty);
  me.setChildDisabled('#next', currPage === pageCount || isEmpty);
  me.setChildDisabled('#last', currPage === pageCount || isEmpty);
  me.setChildDisabled('#refresh', false);
  me.updateInfo();
  Ext.resumeLayouts(true);
  if (!me.calledInternal) {
    me.fireEvent('change', me, pageData || me.emptyPageData);
  }
}, setChildDisabled:function(selector, disabled) {
  var item = this.child(selector);
  if (item) {
    item.setDisabled(disabled);
  }
}, getPageData:function() {
  var store = this.store, totalCount = store.getTotalCount(), pageCount = Math.ceil(totalCount / store.pageSize), toRecord = Math.min(store.currentPage * store.pageSize, totalCount);
  return {total:totalCount, currentPage:store.currentPage, pageCount:Ext.Number.isFinite(pageCount) ? pageCount : 1, fromRecord:(store.currentPage - 1) * store.pageSize + 1, toRecord:toRecord || totalCount};
}, onLoadError:function() {
  this.setChildDisabled('#refresh', false);
}, getInputItem:function() {
  return this.child('#inputItem');
}, readPageFromInput:function(pageData) {
  var inputItem = this.getInputItem(), pageNum = false, v;
  if (inputItem) {
    v = inputItem.getValue();
    pageNum = parseInt(v, 10);
    if (!v || isNaN(pageNum)) {
      inputItem.setValue(pageData.currentPage);
      return false;
    }
  }
  return pageNum;
}, onPagingBlur:function(e) {
  var inputItem = this.getInputItem(), curPage;
  if (inputItem) {
    curPage = this.getPageData().currentPage;
    inputItem.setValue(curPage);
  }
}, onPagingKeyDown:function(field, e) {
  this.processKeyEvent(field, e);
}, processKeyEvent:function(field, e) {
  var me = this, key = e.getKey(), pageData = me.getPageData(), increment = e.shiftKey ? 10 : 1, pageNum;
  if (key === e.RETURN) {
    e.stopEvent();
    pageNum = me.readPageFromInput(pageData);
    if (pageNum !== false) {
      pageNum = Math.min(Math.max(1, pageNum), pageData.pageCount);
      if (pageNum !== pageData.currentPage && me.fireEvent('beforechange', me, pageNum) !== false) {
        me.store.loadPage(pageNum);
      }
    }
  } else {
    if (key === e.HOME || key === e.END) {
      e.stopEvent();
      pageNum = key === e.HOME ? 1 : pageData.pageCount;
      field.setValue(pageNum);
    } else {
      if (key === e.UP || key === e.PAGE_UP || key === e.DOWN || key === e.PAGE_DOWN) {
        e.stopEvent();
        pageNum = me.readPageFromInput(pageData);
        if (pageNum) {
          if (key === e.DOWN || key === e.PAGE_DOWN) {
            increment *= -1;
          }
          pageNum += increment;
          if (pageNum >= 1 && pageNum <= pageData.pageCount) {
            field.setValue(pageNum);
          }
        }
      }
    }
  }
}, beforeLoad:function() {
  this.setChildDisabled('#refresh', true);
}, moveFirst:function() {
  if (this.fireEvent('beforechange', this, 1) !== false) {
    this.store.loadPage(1);
    return true;
  }
  return false;
}, movePrevious:function() {
  var me = this, store = me.store, prev = store.currentPage - 1;
  if (prev > 0) {
    if (me.fireEvent('beforechange', me, prev) !== false) {
      store.previousPage();
      return true;
    }
  }
  return false;
}, moveNext:function() {
  var me = this, store = me.store, total = me.getPageData().pageCount, next = store.currentPage + 1;
  if (next <= total) {
    if (me.fireEvent('beforechange', me, next) !== false) {
      store.nextPage();
      return true;
    }
  }
  return false;
}, moveLast:function() {
  var me = this, last = me.getPageData().pageCount;
  if (me.fireEvent('beforechange', me, last) !== false) {
    me.store.loadPage(last);
    return true;
  }
  return false;
}, doRefresh:function() {
  var me = this, store = me.store, current = store.currentPage;
  if (me.fireEvent('beforechange', me, current) !== false) {
    store.loadPage(current);
    return true;
  }
  return false;
}, getStoreListeners:function() {
  return {beforeload:this.beforeLoad, load:this.onLoad, exception:this.onLoadError};
}, onBindStore:function() {
  if (this.rendered) {
    this.updateBarInfo();
  }
}, doDestroy:function() {
  var me = this, listener = me._storeChangeListener;
  if (listener) {
    listener.destroy();
    me._storeChangeListener = null;
  }
  me.bindStore(null);
  Ext.toolbar.Toolbar.prototype.doDestroy.call(this);
}}, 0, ['pagingtoolbar'], ['component', 'box', 'container', 'toolbar', 'pagingtoolbar'], {'component':true, 'box':true, 'container':true, 'toolbar':true, 'pagingtoolbar':true}, ['widget.pagingtoolbar'], [[Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder]], [Ext.toolbar, 'Paging', Ext, 'PagingToolbar'], 0);
Ext.define('Ext.theme.neptune.toolbar.Paging', {override:'Ext.toolbar.Paging', defaultButtonUI:'plain-toolbar', inputItemWidth:40});
Ext.define('Ext.theme.triton.toolbar.Paging', {override:'Ext.toolbar.Paging', inputItemWidth:50});
Ext.cmd.derive('Ext.view.BoundList', Ext.view.View, {alternateClassName:'Ext.BoundList', pageSize:0, baseCls:'x-boundlist', itemCls:'x-boundlist-item', listItemCls:'', shadow:false, trackOver:true, preserveScrollOnRefresh:true, enableInitialSelection:false, refreshSelmodelOnRefresh:true, componentLayout:'boundlist', navigationModel:'boundlist', scrollable:true, ariaEl:'listEl', tabIndex:-1, childEls:['listWrap', 'listEl'], renderTpl:['\x3cdiv id\x3d"{id}-listWrap" data-ref\x3d"listWrap"', ' class\x3d"{baseCls}-list-ct ', 
Ext.dom.Element.unselectableCls, '"\x3e', '\x3cul id\x3d"{id}-listEl" data-ref\x3d"listEl" class\x3d"', 'x-', 'list-plain"', '\x3ctpl foreach\x3d"ariaAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e', '\x3e', '\x3c/ul\x3e', '\x3c/div\x3e', '{%', 'var pagingToolbar\x3dvalues.$comp.pagingToolbar;', 'if (pagingToolbar) {', 'Ext.DomHelper.generateMarkup(pagingToolbar.getRenderTree(), out);', '}', '%}', {disableFormats:true}], focusOnToFront:false, alignOnScroll:false, initComponent:function() {
  var me = this, baseCls = me.baseCls, itemCls = me.itemCls;
  me.selectedItemCls = baseCls + '-selected';
  if (me.trackOver) {
    me.overItemCls = baseCls + '-item-over';
  }
  me.itemSelector = '.' + itemCls;
  if (me.floating) {
    me.addCls(baseCls + '-floating');
  }
  if (!me.tpl) {
    me.generateTpl();
  } else {
    if (!me.tpl.isTemplate) {
      me.tpl = new Ext.XTemplate(me.tpl);
    }
  }
  if (me.pageSize) {
    me.pagingToolbar = me.createPagingToolbar();
  }
  Ext.view.View.prototype.initComponent.call(this);
}, generateTpl:function() {
  var me = this;
  me.tpl = new Ext.XTemplate('\x3ctpl for\x3d"."\x3e', '\x3cli role\x3d"option" unselectable\x3d"on" class\x3d"' + me.itemCls + '"\x3e' + me.getInnerTpl(me.displayField) + '\x3c/li\x3e', '\x3c/tpl\x3e');
}, setDisplayField:function(displayField) {
  this.displayField = displayField;
  this.generateTpl();
}, getRefOwner:function() {
  return this.pickerField || Ext.view.View.prototype.getRefOwner.call(this);
}, getRefItems:function() {
  var result = Ext.view.View.prototype.getRefItems.call(this), toolbar = this.pagingToolbar;
  if (toolbar) {
    result.push(toolbar);
  }
  return result;
}, createPagingToolbar:function() {
  var me = this;
  return new Ext.toolbar.Paging({id:me.id + '-paging-toolbar', pageSize:me.pageSize, store:me.dataSource, border:false, ownerCt:me, ownerLayout:me.getComponentLayout()});
}, refresh:function() {
  var me = this, tpl = me.tpl;
  tpl.field = me.pickerField;
  tpl.store = me.store;
  Ext.view.View.prototype.refresh.call(this);
  tpl.field = tpl.store = null;
  if (!me.ariaStaticRoles[me.ariaRole]) {
    me.refreshAriaAttributes();
  }
}, refreshAriaAttributes:function() {
  var me = this, store = me.store, selModel = me.getSelectionModel(), multiSelect, totalCount, nodes, node, record, index, i, len;
  totalCount = store.isFiltered() ? store.getCount() : store.getTotalCount() || store.getCount();
  nodes = me.getNodes();
  multiSelect = me.pickerField && me.pickerField.multiSelect;
  for (i = 0, len = nodes.length; i < len; i++) {
    node = nodes[i];
    record = null;
    if (totalCount !== len) {
      record = me.getRecord(node);
      index = store.indexOf(record);
      node.setAttribute('aria-setsize', totalCount);
      node.setAttribute('aria-posinset', index);
    }
    if (multiSelect) {
      record = record || me.getRecord(node);
      node.setAttribute('aria-selected', selModel.isSelected(record));
    }
  }
}, bindStore:function(store, initial) {
  var toolbar = this.pagingToolbar;
  Ext.view.View.prototype.bindStore.apply(this, arguments);
  if (toolbar) {
    toolbar.bindStore(store, initial);
  }
}, getInnerTpl:function(displayField) {
  return '{' + displayField + '}';
}, onShow:function() {
  var field = this.pickerField;
  Ext.view.View.prototype.onShow.call(this);
  if (field && field.rendered && !field.hasFocus) {
    field.focus();
  }
}, afterComponentLayout:function(width, height, oldWidth, oldHeight) {
  var field = this.pickerField;
  Ext.view.View.prototype.afterComponentLayout.call(this, width, height, oldWidth, oldHeight);
  if (field && field.alignPicker) {
    field.alignPicker();
  }
}, onItemSelect:function(record) {
  var me = this, node;
  node = Ext.view.View.prototype.onItemSelect.call(this, record);
  if (node) {
    if (me.ariaSelectable) {
      node.setAttribute('aria-selected', 'true');
    } else {
      node.removeAttribute('aria-selected');
    }
  }
  return node;
}, onItemDeselect:function(record) {
  var me = this, node;
  node = Ext.view.View.prototype.onItemDeselect.call(this, record);
  if (node && me.ariaSelectable) {
    if (me.pickerField && me.pickerField.multiSelect) {
      node.setAttribute('aria-selected', 'false');
    } else {
      node.removeAttribute('aria-selected');
    }
  }
  return node;
}, onItemClick:function(record) {
  var me = this, field = me.pickerField, valueField, selected;
  if (!field) {
    return;
  }
  valueField = field.valueField;
  selected = me.getSelectionModel().getSelection();
  if (!field.multiSelect && selected.length) {
    selected = selected[0];
    if (selected && field.isEqual(record.get(valueField), selected.get(valueField)) && field.collapse) {
      field.collapse();
    }
  }
}, onContainerClick:function(e) {
  var toolbar = this.pagingToolbar, clientRegion;
  if (toolbar && toolbar.rendered && e.within(toolbar.el)) {
    return false;
  }
  if (Ext.isIE10 || Ext.isIE11) {
    clientRegion = this.listWrap.getClientRegion();
    if (!e.getPoint().isContainedBy(clientRegion)) {
      return false;
    }
  }
}, doDestroy:function() {
  this.pagingToolbar = Ext.destroy(this.pagingToolbar);
  Ext.view.View.prototype.doDestroy.call(this);
}, privates:{getNodeContainer:function() {
  return this.listEl;
}, getTargetEl:function() {
  return this.listEl;
}, getOverflowEl:function() {
  return this.listWrap;
}, finishRenderChildren:function() {
  var toolbar = this.pagingToolbar;
  Ext.view.View.prototype.finishRenderChildren.apply(this, arguments);
  if (toolbar) {
    toolbar.finishRender();
  }
}}}, 0, ['boundlist'], ['component', 'box', 'dataview', 'boundlist'], {'component':true, 'box':true, 'dataview':true, 'boundlist':true}, ['widget.boundlist'], [[Ext.mixin.Queryable.prototype.mixinId || Ext.mixin.Queryable.$className, Ext.mixin.Queryable]], [Ext.view, 'BoundList', Ext, 'BoundList'], 0);
Ext.cmd.derive('Ext.form.field.ComboBox', Ext.form.field.Picker, {alternateClassName:'Ext.form.ComboBox', config:{filters:null, selection:null, valueNotFoundText:null, displayTpl:null, delimiter:', ', displayField:'text'}, publishes:['selection'], twoWayBindable:['selection'], triggerCls:'x-form-arrow-trigger', hiddenName:'', collapseOnSelect:false, hiddenDataCls:'x-hidden-display x-form-data-hidden', ariaRole:'combobox', autoDestroyBoundStore:true, childEls:{'hiddenDataEl':true}, filtered:false, 
afterRender:function() {
  var me = this;
  Ext.form.field.Picker.prototype.afterRender.apply(this, arguments);
  me.setHiddenValue(me.value);
}, multiSelect:false, triggerAction:'all', allQuery:'', queryParam:'query', queryMode:'remote', queryCaching:true, autoLoadOnValue:false, pageSize:0, anyMatch:false, caseSensitive:false, autoSelect:true, autoSelectLast:true, typeAhead:false, typeAheadDelay:250, selectOnTab:true, forceSelection:false, growToLongestValue:true, clearFilterOnBlur:true, defaultListConfig:{loadingHeight:70, minWidth:70, maxHeight:300, shadow:'sides'}, transformInPlace:true, clearValueOnEmpty:true, newlineRe:/\r?\n/g, getGrowWidth:function() {
  var me = this, value = me.inputEl.dom.value, field, store, dataLn, currentLongestLength, i, item, itemLn;
  if (me.growToLongestValue) {
    field = me.displayField;
    store = me.store;
    dataLn = store.data.length;
    currentLongestLength = 0;
    for (i = 0; i < dataLn; i++) {
      item = store.getAt(i).data[field];
      itemLn = item.length;
      if (itemLn > currentLongestLength) {
        currentLongestLength = itemLn;
        value = item;
      }
    }
  }
  return value;
}, initComponent:function() {
  var me = this, isDefined = Ext.isDefined, store = me.store, transform = me.transform, transformSelect, isLocalMode;
  if ('pinList' in me) {
    me.collapseOnSelect = !me.pinList;
  }
  if (transform) {
    transformSelect = Ext.getDom(transform);
    if (transformSelect) {
      if (!me.store) {
        store = Ext.Array.map(Ext.Array.from(transformSelect.options), function(option) {
          return [option.value, option.text];
        });
      }
      if (!me.name) {
        me.name = transformSelect.name;
      }
      if (!('value' in me)) {
        me.value = transformSelect.value;
      }
    }
  }
  if (!me.displayTpl) {
    me.setDisplayTpl(false);
  }
  me.bindStore(store || 'ext-empty-store', true, true);
  isLocalMode = me.queryMode === 'local';
  if (!isDefined(me.queryDelay)) {
    me.queryDelay = isLocalMode ? 10 : 500;
  }
  if (!isDefined(me.minChars)) {
    me.minChars = isLocalMode ? 0 : 4;
  }
  Ext.form.field.Picker.prototype.initComponent.call(this);
  me.doQueryTask = new Ext.util.DelayedTask(me.doRawQuery, me);
  if (transformSelect) {
    if (me.transformInPlace) {
      me.render(transformSelect.parentNode, transformSelect);
      delete me.renderTo;
    }
    Ext.removeNode(transformSelect);
  }
}, initEvents:function() {
  var me = this;
  Ext.form.field.Picker.prototype.initEvents.call(this);
  me.altArrowKeyNav = new Ext.util.KeyNav({target:me.inputEl, forceKeyDown:true, priority:1002, scope:me, down:{alt:true, handler:me.onAltDownArrow}, up:{alt:true, handler:me.onAltUpArrow}});
}, getSubTplData:function(fieldData) {
  var me = this, id = me.id, data, ariaAttr;
  data = Ext.form.field.Picker.prototype.getSubTplData.call(this, fieldData);
  if (!me.ariaStaticRoles[me.ariaRole]) {
    ariaAttr = data.ariaElAttributes;
    if (ariaAttr) {
      ariaAttr['aria-owns'] = id + '-inputEl ' + id + '-picker-listEl';
      ariaAttr['aria-autocomplete'] = 'list';
    }
  }
  return data;
}, getSubTplMarkup:function(fieldData) {
  var me = this, hiddenDataElMarkup = '', markup = Ext.form.field.Picker.prototype.getSubTplMarkup.apply(this, arguments);
  if (me.hiddenName) {
    hiddenDataElMarkup = '\x3cdiv id\x3d"' + fieldData.id + '-hiddenDataEl" data-ref\x3d"hiddenDataEl" class\x3d"' + me.hiddenDataCls + '" role\x3d"presentation"\x3e\x3c/div\x3e';
  }
  return hiddenDataElMarkup + markup;
}, applyDisplayTpl:function(displayTpl) {
  var me = this;
  if (!displayTpl) {
    displayTpl = new Ext.XTemplate('\x3ctpl for\x3d"."\x3e{[typeof values \x3d\x3d\x3d "string" ? values : values["' + me.getDisplayField() + '"]]}\x3ctpl if\x3d"xindex \x3c xcount"\x3e' + me.getDelimiter() + '\x3c/tpl\x3e\x3c/tpl\x3e');
    displayTpl.auto = true;
  } else {
    if (!displayTpl.isTemplate) {
      displayTpl = new Ext.XTemplate(displayTpl);
    }
  }
  return displayTpl;
}, applyFilters:function(filters, collection) {
  var me = this;
  if (filters === null || filters.isFilterCollection) {
    return filters;
  }
  if (filters) {
    if (!collection) {
      collection = this.getFilters();
    }
    collection.beginUpdate();
    collection.splice(0, collection.length, filters);
    collection.each(function(filter) {
      filter.ownerId = me.id;
    });
    collection.endUpdate();
  }
  return collection;
}, applyValueNotFoundText:function(v) {
  var me = this, valueNotFoundRecord = me.valueNotFoundRecord || (me.valueNotFoundRecord = new Ext.data.Model), displayField = me.getDisplayField(), valueField = me.valueField;
  valueNotFoundRecord.set(displayField, v);
  if (valueField && displayField !== valueField) {
    valueNotFoundRecord.set(valueField, v);
  }
  return v;
}, getFilters:function(autoCreate) {
  var ret = this.filters;
  if (!ret && autoCreate !== false) {
    ret = new Ext.util.FilterCollection;
    this.setFilters(ret);
  }
  return ret;
}, updateFilters:function(newFilters, oldFilters) {
  var me = this;
  if (oldFilters) {
    oldFilters.un('endupdate', 'onEndUpdateFilters', me);
  }
  if (newFilters) {
    newFilters.on('endupdate', 'onEndUpdateFilters', me);
  }
  me.onEndUpdateFilters(newFilters);
}, onEndUpdateFilters:function(filters) {
  var me = this, was = me.filtered, is = !!filters && filters.length > 0, old, storeFilters;
  if (was || is) {
    me.filtered = is;
    old = [];
    storeFilters = me.store.getFilters();
    storeFilters.each(function(filter) {
      if (filter.ownerId === me.id && !filters.contains(filter)) {
        old.push(filter);
      }
    });
    storeFilters.splice(0, old, filters.items);
  }
}, clearLocalFilter:function() {
  var me = this, filter = me.queryFilter;
  if (filter) {
    me.queryFilter = null;
    me.changingFilters = true;
    me.store.removeFilter(filter, true);
    me.changingFilters = false;
  }
}, completeEdit:function(e) {
  var me = this;
  Ext.form.field.Picker.prototype.completeEdit.call(this, e);
  me.doQueryTask.cancel();
  me.assertValue();
  if (me.queryFilter && me.queryMode === 'local' && me.clearFilterOnBlur) {
    me.clearLocalFilter();
  }
}, onFocus:function(e) {
  var me = this;
  Ext.form.field.Picker.prototype.onFocus.call(this, e);
  if (me.triggerAction !== 'all' && me.queryFilter && me.queryMode === 'local' && me.clearFilterOnBlur) {
    delete me.lastQuery;
    me.doRawQuery();
  }
}, onAltDownArrow:function(e) {
  e.stopEvent();
  if (!this.isExpanded) {
    this.onDownArrow(e);
  }
  return false;
}, onAltUpArrow:function(e) {
  e.stopEvent();
  if (this.isExpanded) {
    this.onEsc(e);
  }
  return false;
}, assertValue:function() {
  var me = this, rawValue = me.getRawValue(), displayValue = me.getDisplayValue(), lastRecords = me.lastSelectedRecords, preventChange = false, value, rec;
  if (me.forceSelection) {
    if (me.multiSelect) {
      if (rawValue !== displayValue) {
        me.setRawValue(displayValue);
      }
    } else {
      rec = me.findRecordByDisplay(rawValue);
      if (!rec) {
        if (lastRecords && (!me.allowBlank || me.rawValue)) {
          rec = lastRecords[0];
        } else {
          if (me.displayTplData && me.displayTplData.length) {
            rec = me.findRecordByValue(me.displayTplData[0][me.valueField]);
          }
        }
      } else {
        if (me.getDisplayValue([me.getRecordDisplayData(rec)]) === displayValue) {
          rec = null;
          preventChange = true;
        }
      }
      if (rec) {
        me.select(rec, true);
        me.fireEvent('select', me, rec);
      } else {
        if (!preventChange) {
          if (lastRecords) {
            delete me.lastSelectedRecords;
          }
          me.setRawValue('');
        }
      }
    }
  } else {
    if ((value = me.getValue()) && value == rawValue) {
      rec = me.findRecordByDisplay(value);
      if (rec && (rec !== (lastRecords && lastRecords[0]) || me.displayField !== me.valueField)) {
        me.select(rec, true);
        me.fireEvent('select', me, rec);
      }
    }
  }
  me.collapse();
}, onTypeAhead:function() {
  var me = this, displayField = me.displayField, record = me.store.findRecord(displayField, me.getRawValue()), newValue, len, selStart;
  if (record) {
    newValue = record.get(displayField);
    len = newValue.length;
    selStart = me.getRawValue().length;
    if (selStart !== 0 && selStart !== len) {
      me.lastMutatedValue = newValue;
      me.setRawValue(newValue);
      me.selectText(selStart, newValue.length);
    }
  }
}, resetToDefault:Ext.emptyFn, beforeReset:function() {
  Ext.form.field.Picker.prototype.beforeReset.call(this);
  this.clearLocalFilter();
}, onUnbindStore:function() {
  var me = this, picker = me.picker;
  if (me.queryFilter && !me.store.destroyed) {
    me.clearLocalFilter();
  }
  if (picker) {
    picker.bindStore(null);
  }
  me.pickerSelectionModel.destroy();
}, onBindStore:function(store, initial) {
  var me = this, picker = me.picker, extraKeySpec, valueCollectionConfig;
  if (store) {
    if (store.autoCreated) {
      me.queryMode = 'local';
      me.valueField = me.displayField = 'field1';
      if (!store.expanded) {
        me.displayField = 'field2';
      }
      if (me.getDisplayTpl().auto) {
        me.setDisplayTpl(null);
      }
    }
    if (!Ext.isDefined(me.valueField)) {
      me.valueField = me.displayField;
    }
    extraKeySpec = {byValue:{rootProperty:'data', unique:false}};
    extraKeySpec.byValue.property = me.valueField;
    store.setExtraKeys(extraKeySpec);
    if (me.displayField === me.valueField) {
      store.byText = store.byValue;
    } else {
      extraKeySpec.byText = {rootProperty:'data', unique:false};
      extraKeySpec.byText.property = me.displayField;
      store.setExtraKeys(extraKeySpec);
    }
    valueCollectionConfig = {rootProperty:'data', extraKeys:{byInternalId:{property:'internalId'}, byValue:{property:me.valueField, rootProperty:'data'}}, listeners:{beginupdate:me.onValueCollectionBeginUpdate, endupdate:me.onValueCollectionEndUpdate, scope:me}};
    me.valueCollection = new Ext.util.Collection(valueCollectionConfig);
    me.pickerSelectionModel = new Ext.selection.DataViewModel({mode:me.multiSelect ? 'SIMPLE' : 'SINGLE', ordered:true, deselectOnContainerClick:false, enableInitialSelection:false, pruneRemoved:false, selected:me.valueCollection, store:store, listeners:{scope:me, lastselectedchanged:me.updateBindSelection}});
    if (!initial) {
      me.resetToDefault();
    }
    if (picker) {
      me.pickerSelectionModel.on({scope:me, beforeselect:me.onBeforeSelect, beforedeselect:me.onBeforeDeselect});
      picker.setSelectionModel(me.pickerSelectionModel);
      if (picker.getStore() !== store) {
        picker.bindStore(store);
      }
    }
  }
}, bindStore:function(store, preventFilter, initial) {
  var me = this, filter = me.queryFilter;
  me.mixins.storeholder.bindStore.call(me, store, initial);
  store = me.getStore();
  if (store && filter && !preventFilter) {
    store.getFilters().add(filter);
  }
  if (!initial && store && !store.isEmptyStore) {
    me.setValueOnData();
  }
}, getStoreListeners:function(store) {
  if (!store.isEmptyStore) {
    var me = this, result = {datachanged:me.onDataChanged, load:me.onLoad, exception:me.onException, update:me.onStoreUpdate, remove:me.checkValueOnChange};
    if (!store.getRemoteFilter()) {
      result.filterchange = me.checkValueOnChange;
    }
    return result;
  }
}, onDataChanged:function() {
  if (this.grow && this.growToLongestValue) {
    this.autoSize();
  }
}, checkValueOnChange:function() {
  var me = this;
  if (!me.destroying && me.getStore().isLoaded()) {
    if (me.multiSelect) {
    } else {
      if (me.forceSelection && !me.changingFilters && !me.findRecordByValue(me.value)) {
        if (me.queryMode != 'local' && (me.hasFocus || me.isPaging)) {
          return;
        }
        me.setValue(null);
      }
    }
  }
}, onStoreUpdate:function(store, record) {
  this.updateValue();
}, onException:function() {
  this.isPaging = false;
  this.collapse();
}, onLoad:function(store, records, success) {
  var me = this, needsValueUpdating = !me.valueCollection.byValue.get(me.value);
  if (success && needsValueUpdating && !me.isPaging && !(store.lastOptions && 'rawQuery' in store.lastOptions)) {
    me.setValueOnData();
  }
  me.checkValueOnChange();
  me.isPaging = false;
}, setValueOnData:function() {
  var me = this;
  me.setValue(me.value);
  if (me.isExpanded && me.getStore().getCount()) {
    me.doAutoSelect();
  }
}, doRawQuery:function() {
  var me = this, rawValue = me.inputEl.dom.value;
  if (me.multiSelect) {
    rawValue = rawValue.split(me.delimiter).pop();
  }
  me.doQuery(rawValue, false, true);
}, doQuery:function(queryString, forceAll, rawQuery) {
  var me = this, store = me.getStore(), filters = store.getFilters(), queryPlan = me.beforeQuery({lastQuery:me.lastQuery || '', query:queryString || '', rawQuery:rawQuery, forceAll:forceAll, combo:me, cancel:false}), refreshFilters;
  if (queryPlan !== false && !queryPlan.cancel) {
    refreshFilters = !!queryString && (!me.queryFilter || me.queryFilter && filters.indexOf(me.queryFilter) < 0);
    if (me.queryCaching && !refreshFilters && queryPlan.query === me.lastQuery) {
      me.getPicker().refresh();
      me.expand();
      me.afterQuery(queryPlan);
    } else {
      me.lastQuery = queryPlan.query;
      if (me.queryMode === 'local') {
        me.doLocalQuery(queryPlan);
      } else {
        me.doRemoteQuery(queryPlan);
      }
    }
    return true;
  } else {
    me.startCheckChangeTask();
  }
  return false;
}, beforeQuery:function(queryPlan) {
  var me = this;
  if (me.fireEvent('beforequery', queryPlan) === false) {
    queryPlan.cancel = true;
  } else {
    if (!queryPlan.cancel) {
      if (queryPlan.query.length < me.minChars && !queryPlan.forceAll) {
        queryPlan.cancel = true;
      }
    }
  }
  return queryPlan;
}, doLocalQuery:function(queryPlan) {
  var me = this, queryString = queryPlan.query, store = me.getStore(), value = queryString, filter;
  me.clearLocalFilter();
  if (queryString) {
    if (me.enableRegEx) {
      try {
        value = new RegExp(value);
      } catch (e$39) {
        value = null;
      }
    }
    if (value !== null) {
      me.changingFilters = true;
      filter = me.queryFilter = new Ext.util.Filter({id:me.id + '-filter', anyMatch:me.anyMatch, caseSensitive:me.caseSensitive, root:'data', property:me.displayField, value:value});
      store.addFilter(filter, true);
      me.changingFilters = false;
    }
  }
  if (me.store.getCount() || me.getPicker().emptyText) {
    me.getPicker().refresh();
    me.expand();
  } else {
    me.collapse();
  }
  me.afterQuery(queryPlan);
}, doRemoteQuery:function(queryPlan) {
  var me = this, loadCallback = function() {
    if (!me.destroyed) {
      me.afterQuery(queryPlan);
    }
  };
  me.expand();
  if (me.pageSize) {
    me.loadPage(1, {rawQuery:queryPlan.rawQuery, callback:loadCallback});
  } else {
    me.store.load({params:me.getParams(queryPlan.query), rawQuery:queryPlan.rawQuery, callback:loadCallback});
  }
}, afterQuery:function(queryPlan) {
  var me = this;
  if (me.store.getCount()) {
    if (me.typeAhead) {
      me.doTypeAhead(queryPlan);
    }
    if (queryPlan.rawQuery) {
      if (me.picker && !me.picker.getSelectionModel().hasSelection()) {
        me.doAutoSelect();
      }
    } else {
      me.doAutoSelect();
    }
  }
  me.startCheckChangeTask();
}, loadPage:function(pageNum, options) {
  this.isPaging = true;
  this.store.loadPage(pageNum, Ext.apply({params:this.getParams(this.lastQuery)}, options));
}, onPageChange:function(toolbar, newPage) {
  this.loadPage(newPage);
  return false;
}, getParams:function(queryString) {
  var params = {}, param = this.queryParam;
  if (param) {
    params[param] = queryString;
  }
  return params;
}, doAutoSelect:function() {
  var me = this, store = me.store, picker = me.picker, itemNode = 0, selectionModel, lastSelected;
  if (picker && me.autoSelect && store.getCount() > 0) {
    if (me.autoSelectLast) {
      selectionModel = picker.getSelectionModel();
      lastSelected = selectionModel.lastSelected;
      if (lastSelected && selectionModel.selected.length && store.indexOf(lastSelected) > -1) {
        itemNode = lastSelected;
      }
    }
    picker.getNavigationModel().setPosition(itemNode);
  }
}, doTypeAhead:function(queryPlan) {
  var me = this;
  if (!me.typeAheadTask) {
    me.typeAheadTask = new Ext.util.DelayedTask(me.onTypeAhead, me);
  }
  if (queryPlan.query.length > queryPlan.lastQuery.length || !Ext.String.startsWith(queryPlan.lastQuery, queryPlan.query)) {
    me.typeAheadTask.delay(me.typeAheadDelay);
  }
}, onTriggerClick:function(comboBox, trigger, e) {
  var me = this, oldAutoSelect;
  if (!me.readOnly && !me.disabled) {
    if (me.isExpanded) {
      me.collapse();
    } else {
      if (e && e.type === 'keydown' && e.altKey) {
        oldAutoSelect = me.autoSelect;
        me.autoSelect = false;
        me.expand();
        me.autoSelect = oldAutoSelect;
      } else {
        if (me.triggerAction === 'all') {
          me.doQuery(me.allQuery, true);
        } else {
          if (me.triggerAction === 'last') {
            me.doQuery(me.lastQuery, true);
          } else {
            me.doQuery(me.getRawValue(), false, true);
          }
        }
      }
    }
  }
}, onFieldMutation:function(e) {
  var me = this, key = e.getKey(), isDelete = key === e.BACKSPACE || key === e.DELETE, rawValue = me.inputEl.dom.value, len = rawValue.length;
  if (!me.readOnly && (rawValue !== me.lastMutatedValue || isDelete) && key !== e.TAB) {
    me.lastMutatedValue = rawValue;
    me.refreshEmptyText();
    if (len && (e.type !== 'keyup' || (!e.isSpecialKey() || isDelete))) {
      me.doQueryTask.delay(me.queryDelay);
    } else {
      if (!len && (!key || isDelete)) {
        ++me.suspendCheckChange;
        if (!me.multiSelect) {
          me.value = null;
          me.displayTplData = undefined;
        }
        if (me.clearValueOnEmpty) {
          me.valueCollection.beginUpdate();
          me.pickerSelectionModel.deselectAll();
          me.valueCollection.removeAll();
          me.valueCollection.endUpdate();
        }
        me.collapse();
        if (me.queryFilter) {
          me.clearLocalFilter();
        }
        me.lastQuery = null;
        --me.suspendCheckChange;
      }
      Ext.form.field.Picker.prototype.onFieldMutation.call(this, e);
    }
  }
}, doDestroy:function() {
  var me = this;
  me.doQueryTask.cancel();
  if (me.typeAheadTask) {
    me.typeAheadTask.cancel();
    me.typeAheadTask = null;
  }
  me.bindStore(null);
  Ext.destroy(me.altArrowKeyNav, me.valueCollection);
  Ext.form.field.Picker.prototype.doDestroy.call(this);
}, onAdded:function() {
  var me = this;
  Ext.form.field.Picker.prototype.onAdded.apply(this, arguments);
  if (me.picker) {
    me.picker.ownerCt = me.up('[floating]');
    me.picker.registerWithOwnerCt();
  }
}, createPicker:function() {
  var me = this, picker, pickerCfg = Ext.apply({xtype:'boundlist', id:me.id + '-picker', pickerField:me, selectionModel:me.pickerSelectionModel, floating:true, hidden:true, store:me.getPickerStore(), displayField:me.displayField, preserveScrollOnRefresh:true, pageSize:me.pageSize, tpl:me.tpl, ariaSelectable:me.ariaSelectable}, me.listConfig, me.defaultListConfig);
  picker = me.picker = Ext.widget(pickerCfg);
  if (me.pageSize) {
    picker.pagingToolbar.on('beforechange', me.onPageChange, me);
  }
  if (!picker.initialConfig.maxHeight) {
    picker.on({beforeshow:me.onBeforePickerShow, scope:me});
  }
  picker.getSelectionModel().on({beforeselect:me.onBeforeSelect, beforedeselect:me.onBeforeDeselect, focuschange:me.onFocusChange, scope:me});
  picker.getNavigationModel().navigateOnSpace = false;
  return picker;
}, getPickerStore:function() {
  return this.store;
}, onBeforePickerShow:function(picker) {
  var me = this, heightAbove = me.getPosition()[1] - Ext.getBody().getScroll().top, heightBelow = Ext.Element.getViewportHeight() - heightAbove - me.getHeight();
  picker.maxHeight = Math.max(heightAbove, heightBelow) - 5;
}, onBeforeSelect:function(list, record, recordIndex) {
  return this.fireEvent('beforeselect', this, record, recordIndex);
}, onBeforeDeselect:function(list, record, recordIndex) {
  return this.fireEvent('beforedeselect', this, record, recordIndex);
}, onFocusChange:function(selModel, prevRecord, newRecord) {
  var picker = this.picker, inputEl = this.inputEl, el;
  if (newRecord) {
    el = picker.getNodeByRecord(newRecord);
    if (!el.id) {
    }
    if (el) {
      if (!el.id) {
        el.id = Ext.id();
      }
      inputEl.dom.setAttribute('aria-activedescendant', el.id);
    } else {
      inputEl.dom.removeAttribute('aria-activedescendant');
    }
  }
}, getSelection:function() {
  var selModel = this.getPicker().getSelectionModel(), selection = selModel.getSelection();
  return selection.length ? selModel.getLastSelected() : null;
}, updateSelection:function(selection) {
  var me = this, sm;
  if (!me.ignoreNextSelection) {
    me.ignoreNextSelection = true;
    sm = me.getPicker().getSelectionModel();
    if (selection) {
      sm.select(selection);
      me.hasHadSelection = true;
    } else {
      sm.deselectAll();
    }
    me.ignoreNextSelection = false;
  }
}, updateBindSelection:function(selModel, selection) {
  var me = this, selected = null;
  if (!me.ignoreNextSelection) {
    me.ignoreNextSelection = true;
    if (selection.length) {
      selected = selModel.getLastSelected();
      me.hasHadSelection = true;
    }
    if (me.hasHadSelection) {
      me.setSelection(selected);
    }
    me.ignoreNextSelection = false;
  }
}, onValueCollectionBeginUpdate:Ext.emptyFn, onValueCollectionEndUpdate:function() {
  var me = this, store = me.store, selectedRecords = me.valueCollection.getRange(), selectedRecord = selectedRecords[0], selectionCount = selectedRecords.length;
  me.updateBindSelection(me.pickerSelectionModel, selectedRecords);
  if (me.isSelectionUpdating()) {
    return;
  }
  Ext.suspendLayouts();
  me.lastSelection = selectedRecords;
  if (selectionCount) {
    me.lastSelectedRecords = selectedRecords;
  }
  me.updateValue();
  if (selectionCount && (!me.multiSelect && store.contains(selectedRecord) || me.collapseOnSelect || !store.getCount())) {
    me.updatingValue = true;
    me.collapse();
    me.updatingValue = false;
  }
  Ext.resumeLayouts(true);
  if (!me.suspendCheckChange) {
    if (!me.multiSelect) {
      selectedRecords = selectedRecord;
    }
    me.fireEvent('select', me, selectedRecords);
  }
}, isSelectionUpdating:function() {
  var selModel = this.pickerSelectionModel;
  return selModel.deselectingDuringSelect || selModel.refreshing;
}, onExpand:function() {
  var me = this, picker = me.getPicker(), keyNav = picker.getNavigationModel(), node;
  if (keyNav) {
    keyNav.enable();
  }
  me.doAutoSelect();
  node = picker.highlightedItem;
  if (node) {
    if (!node.id) {
      node.id = Ext.id();
    }
    me.inputEl.dom.setAttribute('aria-activedescendant', node.id);
  }
}, onCollapse:function() {
  var me = this, keyNav = me.getPicker().getNavigationModel();
  if (keyNav) {
    keyNav.disable();
  }
  if (me.updatingValue) {
    me.doQueryTask.cancel();
  }
  me.inputEl.dom.removeAttribute('aria-activedescendant');
}, select:function(r, assert) {
  var me = this, picker = me.picker, fireSelect;
  if (r && r.isModel && assert === true && picker) {
    fireSelect = !picker.getSelectionModel().isSelected(r);
  }
  if (!fireSelect) {
    me.suspendEvent('select');
  }
  me.setValue(r);
  me.resumeEvent('select');
}, findRecord:function(field, value) {
  var ds = this.store, idx = ds.findExact(field, value);
  return idx !== -1 ? ds.getAt(idx) : false;
}, getSelectedRecord:function() {
  return this.findRecordByValue(this.value) || null;
}, findRecordByValue:function(value) {
  var result = this.store.byValue.get(value), ret = false;
  if (result) {
    ret = result[0] || result;
  }
  return ret;
}, findRecordByDisplay:function(value) {
  var result = this.store.byText.get(value), ret = false;
  if (result) {
    ret = result[0] || result;
  }
  return ret;
}, addValue:function(value) {
  if (value != null) {
    return this.doSetValue(value, true);
  }
}, setValue:function(value) {
  var me = this, bind, valueBind;
  if (me.hasFocus) {
    bind = me.getBind();
    valueBind = bind && bind.value;
    if (valueBind && valueBind.syncing) {
      if (Ext.isEmpty(value) && Ext.isEmpty(me.value) || value === me.value) {
        return me;
      } else {
        if (Ext.isArray(value) && Ext.isArray(me.value) && Ext.Array.equals(value, me.value)) {
          return me;
        }
      }
    }
  } else {
    me.lastSelectedRecords = null;
  }
  if (value != null) {
    me.doSetValue(value);
  } else {
    me.suspendEvent('select');
    me.valueCollection.beginUpdate();
    me.pickerSelectionModel.deselectAll();
    me.valueCollection.endUpdate();
    me.resumeEvent('select');
  }
  return me;
}, setRawValue:function(rawValue) {
  Ext.form.field.Picker.prototype.setRawValue.call(this, rawValue);
  this.lastMutatedValue = rawValue;
}, doSetValue:function(value, add) {
  var me = this, store = me.getStore(), Model = store.getModel(), matchedRecords = [], valueArray = [], autoLoadOnValue = me.autoLoadOnValue, isLoaded = store.getCount() > 0 || store.isLoaded(), pendingLoad = store.hasPendingLoad(), unloaded = autoLoadOnValue && !isLoaded && !pendingLoad, forceSelection = me.forceSelection, selModel = me.pickerSelectionModel, displayField = me.displayField, valueField = me.valueField, displayIsValue = displayField === valueField, isEmptyStore = store.isEmptyStore, 
  lastSelection = me.lastSelection, i, len, record, dataObj, valueChanged, key, val;
  if (pendingLoad || unloaded || !isLoaded || isEmptyStore) {
    if (!value.isModel) {
      if (add) {
        me.value = Ext.Array.from(me.value).concat(value);
      } else {
        me.value = value;
      }
      me.setHiddenValue(me.value);
      me.setRawValue(displayIsValue ? value : '');
      if (displayIsValue && !Ext.isEmpty(value) && me.inputEl && me.emptyText) {
        me.inputEl.removeCls(me.emptyUICls);
      }
    }
    if (unloaded && !isEmptyStore) {
      store.load();
    }
    if (!value.isModel || isEmptyStore) {
      return me;
    }
  }
  value = add ? Ext.Array.from(me.value).concat(value) : Ext.Array.from(value);
  for (i = 0, len = value.length; i < len; i++) {
    record = val = value[i];
    if (!record || !record.isModel) {
      record = me.findRecordByValue(key = record);
      if (!record) {
        record = me.valueCollection.find(valueField, key);
      }
    }
    if (!record) {
      if (!forceSelection) {
        if (!record && val) {
          dataObj = {};
          if (Ext.isObject(val)) {
            dataObj[displayField] = val[displayField];
            dataObj[valueField] = val[valueField];
          } else {
            dataObj[displayField] = val;
            if (valueField && displayField !== valueField) {
              dataObj[valueField] = val;
            }
          }
          record = new Model(dataObj);
        }
      } else {
        if (me.valueNotFoundRecord) {
          record = me.valueNotFoundRecord;
        }
      }
    }
    if (record) {
      matchedRecords.push(record);
      valueArray.push(record.get(valueField));
    }
  }
  if (lastSelection) {
    len = lastSelection.length;
    if (len === matchedRecords.length) {
      for (i = 0; !valueChanged && i < len; i++) {
        if (Ext.Array.indexOf(me.lastSelection, matchedRecords[i]) === -1) {
          valueChanged = true;
        }
      }
    } else {
      valueChanged = true;
    }
  } else {
    valueChanged = matchedRecords.length;
  }
  if (valueChanged) {
    me.suspendEvent('select');
    me.valueCollection.beginUpdate();
    if (matchedRecords.length) {
      selModel.select(matchedRecords, false);
    } else {
      selModel.deselectAll();
    }
    me.valueCollection.endUpdate();
    me.resumeEvent('select');
  } else {
    me.updateValue();
  }
  return me;
}, updateValue:function() {
  var me = this, selectedRecords = me.valueCollection.getRange(), len = selectedRecords.length, valueArray = [], displayTplData = me.displayTplData || (me.displayTplData = []), inputEl = me.inputEl, i, record, displayValue;
  displayTplData.length = 0;
  for (i = 0; i < len; i++) {
    record = selectedRecords[i];
    displayTplData.push(me.getRecordDisplayData(record));
    if (record !== me.valueNotFoundRecord) {
      valueArray.push(record.get(me.valueField));
    }
  }
  me.setHiddenValue(valueArray);
  me.value = me.multiSelect ? valueArray : valueArray[0];
  if (!Ext.isDefined(me.value)) {
    me.value = undefined;
  }
  me.displayTplData = displayTplData;
  displayValue = me.getDisplayValue();
  me.setRawValue(displayValue);
  me.refreshEmptyText();
  me.checkChange();
  if (!me.lastSelectedRecords && selectedRecords.length) {
    me.lastSelectedRecords = selectedRecords;
  }
  if (inputEl && me.typeAhead && me.hasFocus) {
    me.selectText(displayValue.length);
  }
}, setHiddenValue:function(values) {
  var me = this, name = me.hiddenName, i, dom, childNodes, input, valueCount, childrenCount;
  if (!me.hiddenDataEl || !name) {
    return;
  }
  values = Ext.Array.from(values);
  dom = me.hiddenDataEl.dom;
  childNodes = dom.childNodes;
  input = childNodes[0];
  valueCount = values.length;
  childrenCount = childNodes.length;
  if (!input && valueCount > 0) {
    me.hiddenDataEl.setHtml(Ext.DomHelper.markup({tag:'input', type:'hidden', name:name}));
    childrenCount = 1;
    input = dom.firstChild;
  }
  while (childrenCount > valueCount) {
    dom.removeChild(childNodes[0]);
    --childrenCount;
  }
  while (childrenCount < valueCount) {
    dom.appendChild(input.cloneNode(true));
    ++childrenCount;
  }
  for (i = 0; i < valueCount; i++) {
    childNodes[i].value = values[i];
  }
}, getDisplayValue:function(tplData) {
  var s;
  tplData = tplData || this.displayTplData;
  s = this.getDisplayTpl().apply(tplData);
  s = s == null ? '' : String(s);
  return s.replace(this.newlineRe, '');
}, getRecordDisplayData:function(record) {
  return record.data;
}, getValue:function() {
  var me = this, store = me.getStore(), picker = me.picker, rawValue = me.getRawValue(), value = me.value;
  if (!store.isEmptyStore && me.getDisplayValue() !== rawValue) {
    me.displayTplData = undefined;
    if (picker) {
      me.valueCollection.suspendEvents();
      picker.getSelectionModel().deselectAll();
      me.valueCollection.resumeEvents();
      me.lastSelection = null;
    }
    if (store.isLoaded() && (me.multiSelect || me.forceSelection)) {
      value = me.value = undefined;
    } else {
      value = me.value = rawValue;
    }
  }
  me.value = value == null ? null : value;
  return me.value;
}, getSubmitValue:function() {
  var value = this.getValue();
  if (Ext.isEmpty(value)) {
    value = '';
  }
  return value;
}, isEqual:function(v1, v2) {
  var fromArray = Ext.Array.from, i, len;
  v1 = fromArray(v1);
  v2 = fromArray(v2);
  len = v1.length;
  if (len !== v2.length) {
    return false;
  }
  for (i = 0; i < len; i++) {
    if (v2[i] !== v1[i]) {
      return false;
    }
  }
  return true;
}, clearValue:function() {
  this.setValue(null);
}}, 0, ['combo', 'combobox'], ['component', 'box', 'field', 'textfield', 'pickerfield', 'combobox', 'combo'], {'component':true, 'box':true, 'field':true, 'textfield':true, 'pickerfield':true, 'combobox':true, 'combo':true}, ['widget.combo', 'widget.combobox'], [[Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder]], [Ext.form.field, 'ComboBox', Ext.form, 'ComboBox'], 0);
Ext.cmd.derive('Ext.picker.Month', Ext.Component, {alternateClassName:'Ext.MonthPicker', isMonthPicker:true, focusable:true, childEls:['bodyEl', 'prevEl', 'nextEl', 'monthEl', 'yearEl', 'buttons'], renderTpl:['\x3cdiv id\x3d"{id}-bodyEl" data-ref\x3d"bodyEl" class\x3d"{baseCls}-body"\x3e', '\x3cdiv id\x3d"{id}-monthEl" data-ref\x3d"monthEl" class\x3d"{baseCls}-months"\x3e', '\x3ctpl for\x3d"months"\x3e', '\x3cdiv class\x3d"{parent.baseCls}-item {parent.baseCls}-month"\x3e', '\x3ca style\x3d"{parent.monthStyle}" role\x3d"button" hidefocus\x3d"on" class\x3d"{parent.baseCls}-item-inner"\x3e{.}\x3c/a\x3e', 
'\x3c/div\x3e', '\x3c/tpl\x3e', '\x3c/div\x3e', '\x3cdiv id\x3d"{id}-yearEl" data-ref\x3d"yearEl" class\x3d"{baseCls}-years"\x3e', '\x3cdiv class\x3d"{baseCls}-yearnav"\x3e', '\x3cdiv class\x3d"{baseCls}-yearnav-button-ct"\x3e', '\x3ca id\x3d"{id}-prevEl" data-ref\x3d"prevEl" class\x3d"{baseCls}-yearnav-button {baseCls}-yearnav-prev" hidefocus\x3d"on" role\x3d"button"\x3e\x3c/a\x3e', '\x3c/div\x3e', '\x3cdiv class\x3d"{baseCls}-yearnav-button-ct"\x3e', '\x3ca id\x3d"{id}-nextEl" data-ref\x3d"nextEl" class\x3d"{baseCls}-yearnav-button {baseCls}-yearnav-next" hidefocus\x3d"on" role\x3d"button"\x3e\x3c/a\x3e', 
'\x3c/div\x3e', '\x3c/div\x3e', '\x3ctpl for\x3d"years"\x3e', '\x3cdiv class\x3d"{parent.baseCls}-item {parent.baseCls}-year"\x3e', '\x3ca hidefocus\x3d"on" class\x3d"{parent.baseCls}-item-inner" role\x3d"button"\x3e{.}\x3c/a\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e', '\x3c/div\x3e', '\x3cdiv class\x3d"x-clear"\x3e\x3c/div\x3e', '\x3ctpl if\x3d"showButtons"\x3e', '\x3cdiv id\x3d"{id}-buttons" data-ref\x3d"buttons" class\x3d"{baseCls}-buttons"\x3e{%', 'var me\x3dvalues.$comp, okBtn\x3dme.okBtn, cancelBtn\x3dme.cancelBtn;', 
'okBtn.ownerLayout \x3d cancelBtn.ownerLayout \x3d me.componentLayout;', 'okBtn.ownerCt \x3d cancelBtn.ownerCt \x3d me;', 'Ext.DomHelper.generateMarkup(okBtn.getRenderTree(), out);', 'Ext.DomHelper.generateMarkup(cancelBtn.getRenderTree(), out);', '%}\x3c/div\x3e', '\x3c/tpl\x3e', '\x3c/div\x3e'], okText:'OK', cancelText:'Cancel', baseCls:'x-monthpicker', showButtons:true, footerButtonUI:'default', measureWidth:35, measureMaxHeight:20, smallCls:'x-monthpicker-small', totalYears:10, yearOffset:5, 
monthOffset:6, alignOnScroll:false, initComponent:function() {
  var me = this;
  me.selectedCls = me.baseCls + '-selected';
  if (me.small) {
    me.addCls(me.smallCls);
  }
  me.setValue(me.value);
  me.activeYear = me.getYear((new Date).getFullYear() - 4, -4);
  if (me.showButtons) {
    me.okBtn = new Ext.button.Button({ui:me.footerButtonUI, text:me.okText, handler:me.onOkClick, scope:me});
    me.cancelBtn = new Ext.button.Button({ui:me.footerButtonUI, text:me.cancelText, handler:me.onCancelClick, scope:me});
  }
  Ext.Component.prototype.initComponent.call(this);
}, beforeRender:function() {
  var me = this, i = 0, months = [], shortName = Ext.Date.getShortMonthName, monthLen = me.monthOffset, margin = me.monthMargin, style = '';
  if (me.padding && !me.width) {
    me.cacheWidth();
  }
  Ext.Component.prototype.beforeRender.call(this);
  for (; i < monthLen; ++i) {
    months.push(shortName(i), shortName(i + monthLen));
  }
  if (Ext.isDefined(margin)) {
    style = 'margin: 0 ' + margin + 'px;';
  }
  Ext.apply(me.renderData, {months:months, years:me.getYears(), showButtons:me.showButtons, monthStyle:style});
}, cacheWidth:function() {
  var me = this, padding = me.parseBox(me.padding), widthEl = Ext.getBody().createChild({cls:me.baseCls + ' ' + me.borderBoxCls, style:'position:absolute;top:-1000px;left:-1000px;', html:'\x26nbsp;'});
  me.self.prototype.width = widthEl.getWidth() + padding.left + padding.right;
  widthEl.destroy();
}, afterRender:function() {
  var me = this, body = me.bodyEl;
  Ext.Component.prototype.afterRender.call(this);
  if (me.up('[floating\x3dtrue]')) {
    me.el.on('mousedown', me.onElClick, me, {translate:false});
  }
  body.on({scope:me, click:'onBodyClick', dblclick:'onBodyClick'});
  me.years = body.select('.' + me.baseCls + '-year a');
  me.months = body.select('.' + me.baseCls + '-month a');
  me.backRepeater = new Ext.util.ClickRepeater(me.prevEl, {handler:Ext.Function.bind(me.adjustYear, me, [-me.totalYears])});
  me.prevEl.addClsOnOver(me.baseCls + '-yearnav-prev-over');
  me.nextRepeater = new Ext.util.ClickRepeater(me.nextEl, {handler:Ext.Function.bind(me.adjustYear, me, [me.totalYears])});
  me.nextEl.addClsOnOver(me.baseCls + '-yearnav-next-over');
  me.updateBody();
  if (!Ext.isDefined(me.monthMargin)) {
    Ext.picker.Month.prototype.monthMargin = me.calculateMonthMargin();
  }
}, calculateMonthMargin:function() {
  var me = this, months = me.months, first = months.first(), itemMargin = first.getMargin('l');
  while (itemMargin && me.getLargest() > me.measureMaxHeight) {
    --itemMargin;
    months.setStyle('margin', '0 ' + itemMargin + 'px');
  }
  return itemMargin;
}, getLargest:function(months) {
  var largest = 0;
  this.months.each(function(item) {
    var h = item.getHeight();
    if (h > largest) {
      largest = h;
    }
  });
  return largest;
}, setValue:function(value) {
  var me = this, active = me.activeYear, year;
  if (!value) {
    me.value = [null, null];
  } else {
    if (Ext.isDate(value)) {
      me.value = [value.getMonth(), value.getFullYear()];
    } else {
      me.value = [value[0], value[1]];
    }
  }
  if (me.rendered) {
    year = me.value[1];
    if (year !== null) {
      if (year < active || year > active + me.yearOffset) {
        me.activeYear = year - me.yearOffset + 1;
      }
    }
    me.updateBody();
  }
  return me;
}, getValue:function() {
  return this.value;
}, hasSelection:function() {
  var value = this.value;
  return value[0] !== null && value[1] !== null;
}, getYears:function() {
  var me = this, offset = me.yearOffset, start = me.activeYear, end = start + offset, i = start, years = [];
  for (; i < end; ++i) {
    years.push(i, i + offset);
  }
  return years;
}, updateBody:function() {
  var me = this, years = me.years, months = me.months, yearNumbers = me.getYears(), cls = me.selectedCls, value = me.getYear(null), month = me.value[0], monthOffset = me.monthOffset, year, yearItems, y, yLen, el;
  if (me.rendered) {
    years.removeCls(cls);
    months.removeCls(cls);
    yearItems = years.elements;
    yLen = yearItems.length;
    for (y = 0; y < yLen; y++) {
      el = Ext.fly(yearItems[y]);
      year = yearNumbers[y];
      el.dom.innerHTML = year;
      if (year === value) {
        el.addCls(cls);
      }
    }
    if (month !== null) {
      if (month < monthOffset) {
        month = month * 2;
      } else {
        month = (month - monthOffset) * 2 + 1;
      }
      months.item(month).addCls(cls);
    }
  }
}, getYear:function(defaultValue, offset) {
  var year = this.value[1];
  offset = offset || 0;
  return year === null ? defaultValue : year + offset;
}, onElClick:function(e) {
  e.stopEvent();
}, onBodyClick:function(e, t) {
  var me = this, isDouble = e.type === 'dblclick';
  if (e.getTarget('.' + me.baseCls + '-month')) {
    e.stopEvent();
    me.onMonthClick(t, isDouble);
  } else {
    if (e.getTarget('.' + me.baseCls + '-year')) {
      e.stopEvent();
      me.onYearClick(t, isDouble);
    }
  }
}, adjustYear:function(offset) {
  if (typeof offset !== 'number') {
    offset = this.totalYears;
  }
  this.activeYear += offset;
  this.updateBody();
}, onOkClick:function() {
  this.fireEvent('okclick', this, this.value);
}, onCancelClick:function() {
  this.fireEvent('cancelclick', this);
}, onMonthClick:function(target, isDouble) {
  var me = this;
  me.value[0] = me.resolveOffset(me.months.indexOf(target), me.monthOffset);
  me.updateBody();
  me.fireEvent('month' + (isDouble ? 'dbl' : '') + 'click', me, me.value);
  me.fireEvent('select', me, me.value);
}, onYearClick:function(target, isDouble) {
  var me = this;
  me.value[1] = me.activeYear + me.resolveOffset(me.years.indexOf(target), me.yearOffset);
  me.updateBody();
  me.fireEvent('year' + (isDouble ? 'dbl' : '') + 'click', me, me.value);
  me.fireEvent('select', me, me.value);
}, resolveOffset:function(index, offset) {
  if (index % 2 === 0) {
    return index / 2;
  } else {
    return offset + Math.floor(index / 2);
  }
}, doDestroy:function() {
  Ext.destroy(this.backRepeater, this.nextRepeater, this.okBtn, this.cancelBtn);
  Ext.Component.prototype.doDestroy.call(this);
}, privates:{finishRenderChildren:function() {
  var me = this;
  Ext.Component.prototype.finishRenderChildren.apply(this, arguments);
  if (this.showButtons) {
    me.okBtn.finishRender();
    me.cancelBtn.finishRender();
  }
}}}, 0, ['monthpicker'], ['component', 'box', 'monthpicker'], {'component':true, 'box':true, 'monthpicker':true}, ['widget.monthpicker'], 0, [Ext.picker, 'Month', Ext, 'MonthPicker'], 0);
Ext.define('Ext.theme.neptune.picker.Month', {override:'Ext.picker.Month', measureMaxHeight:36});
Ext.define('Ext.theme.triton.picker.Month', {override:'Ext.picker.Month', footerButtonUI:'default-toolbar', calculateMonthMargin:Ext.emptyFn});
Ext.cmd.derive('Ext.picker.Date', Ext.Component, {alternateClassName:'Ext.DatePicker', todayText:'Today', ariaTitle:'Date Picker: {0}', ariaTitleDateFormat:'F d', todayTip:'{0} (Spacebar)', minText:'This date is before the minimum date', ariaMinText:'This date is before the minimum date', maxText:'This date is after the maximum date', ariaMaxText:'This date is after the maximum date', disabledDaysText:'Disabled', ariaDisabledDaysText:'This day of week is disabled', disabledDatesText:'Disabled', ariaDisabledDatesText:'This date is disabled', 
nextText:'Next Month (Control+Right)', prevText:'Previous Month (Control+Left)', monthYearText:'Choose a month (Control+Up/Down to move years)', monthYearFormat:'F Y', showToday:true, disableAnim:false, baseCls:'x-datepicker', longDayFormat:'F d, Y', footerButtonUI:'default', isDatePicker:true, alignOnScroll:false, ariaRole:'region', focusable:true, childEls:['innerEl', 'eventEl', 'prevEl', 'nextEl', 'middleBtnEl', 'footerEl'], border:true, renderTpl:['\x3cdiv id\x3d"{id}-innerEl" data-ref\x3d"innerEl" role\x3d"presentation"\x3e', 
'\x3cdiv class\x3d"{baseCls}-header"\x3e', '\x3cdiv id\x3d"{id}-prevEl" data-ref\x3d"prevEl" class\x3d"{baseCls}-prev {baseCls}-arrow" role\x3d"presentation" title\x3d"{prevText}"\x3e\x3c/div\x3e', '\x3cdiv id\x3d"{id}-middleBtnEl" data-ref\x3d"middleBtnEl" class\x3d"{baseCls}-month" role\x3d"heading"\x3e{%this.renderMonthBtn(values, out)%}\x3c/div\x3e', '\x3cdiv id\x3d"{id}-nextEl" data-ref\x3d"nextEl" class\x3d"{baseCls}-next {baseCls}-arrow" role\x3d"presentation" title\x3d"{nextText}"\x3e\x3c/div\x3e', 
'\x3c/div\x3e', '\x3ctable role\x3d"grid" id\x3d"{id}-eventEl" data-ref\x3d"eventEl" class\x3d"{baseCls}-inner" cellspacing\x3d"0" tabindex\x3d"0" aria-readonly\x3d"true"\x3e', '\x3cthead\x3e', '\x3ctr role\x3d"row"\x3e', '\x3ctpl for\x3d"dayNames"\x3e', '\x3cth role\x3d"columnheader" class\x3d"{parent.baseCls}-column-header" aria-label\x3d"{.}"\x3e', '\x3cdiv role\x3d"presentation" class\x3d"{parent.baseCls}-column-header-inner"\x3e{.:this.firstInitial}\x3c/div\x3e', '\x3c/th\x3e', '\x3c/tpl\x3e', 
'\x3c/tr\x3e', '\x3c/thead\x3e', '\x3ctbody\x3e', '\x3ctr role\x3d"row"\x3e', '\x3ctpl for\x3d"days"\x3e', '{#:this.isEndOfWeek}', '\x3ctd role\x3d"gridcell"\x3e', '\x3cdiv hidefocus\x3d"on" class\x3d"{parent.baseCls}-date"\x3e\x3c/div\x3e', '\x3c/td\x3e', '\x3c/tpl\x3e', '\x3c/tr\x3e', '\x3c/tbody\x3e', '\x3c/table\x3e', '\x3ctpl if\x3d"showToday"\x3e', '\x3cdiv id\x3d"{id}-footerEl" data-ref\x3d"footerEl" role\x3d"presentation" class\x3d"{baseCls}-footer"\x3e{%this.renderTodayBtn(values, out)%}\x3c/div\x3e', 
'\x3c/tpl\x3e', '\x3cdiv id\x3d"{id}-todayText" class\x3d"x-hidden-clip"\x3e{todayText}.\x3c/div\x3e', '\x3cdiv id\x3d"{id}-ariaMinText" class\x3d"x-hidden-clip"\x3e{ariaMinText}.\x3c/div\x3e', '\x3cdiv id\x3d"{id}-ariaMaxText" class\x3d"x-hidden-clip"\x3e{ariaMaxText}.\x3c/div\x3e', '\x3cdiv id\x3d"{id}-ariaDisabledDaysText" class\x3d"x-hidden-clip"\x3e{ariaDisabledDaysText}.\x3c/div\x3e', '\x3cdiv id\x3d"{id}-ariaDisabledDatesText" class\x3d"x-hidden-clip"\x3e{ariaDisabledDatesText}.\x3c/div\x3e', 
'\x3c/div\x3e', {firstInitial:function(value) {
  return Ext.picker.Date.prototype.getDayInitial(value);
}, isEndOfWeek:function(value) {
  value--;
  var end = value % 7 === 0 && value !== 0;
  return end ? '\x3c/tr\x3e\x3ctr role\x3d"row"\x3e' : '';
}, renderTodayBtn:function(values, out) {
  Ext.DomHelper.generateMarkup(values.$comp.todayBtn.getRenderTree(), out);
}, renderMonthBtn:function(values, out) {
  Ext.DomHelper.generateMarkup(values.$comp.monthBtn.getRenderTree(), out);
}}], initHour:12, numDays:42, initComponent:function() {
  var me = this, clearTime = Ext.Date.clearTime;
  me.selectedCls = me.baseCls + '-selected';
  me.disabledCellCls = me.baseCls + '-disabled';
  me.prevCls = me.baseCls + '-prevday';
  me.activeCls = me.baseCls + '-active';
  me.cellCls = me.baseCls + '-cell';
  me.nextCls = me.baseCls + '-prevday';
  me.todayCls = me.baseCls + '-today';
  me.defaultValue = Ext.isDate(me.defaultValue) ? me.defaultValue : new Date;
  if (!me.format) {
    me.format = Ext.Date.defaultFormat;
  }
  if (!me.dayNames) {
    me.dayNames = Ext.Date.dayNames;
  }
  if (me.startDay == null) {
    me.startDay = Ext.Date.firstDayOfWeek;
  }
  me.dayNames = me.dayNames.slice(me.startDay).concat(me.dayNames.slice(0, me.startDay));
  Ext.Component.prototype.initComponent.call(this);
  me.value = me.value ? clearTime(me.value, true) : clearTime(me.defaultValue);
  me.initDisabledDays();
}, getRefOwner:function() {
  return this.pickerField || Ext.Component.prototype.getRefOwner.call(this);
}, getRefItems:function() {
  var results = [], monthBtn = this.monthBtn, todayBtn = this.todayBtn;
  if (monthBtn) {
    results.push(monthBtn);
  }
  if (todayBtn) {
    results.push(todayBtn);
  }
  return results;
}, beforeRender:function() {
  var me = this, encode = Ext.String.htmlEncode, days = new Array(me.numDays), today = Ext.Date.format(new Date, me.format);
  if (me.padding && !me.width) {
    me.cacheWidth();
  }
  me.monthBtn = new Ext.button.Split({ownerCt:me, ownerLayout:me.getComponentLayout(), text:'', tooltip:me.monthYearText, tabIndex:-1, ariaRole:'presentation', listeners:{click:me.doShowMonthPicker, arrowclick:me.doShowMonthPicker, scope:me}});
  if (me.showToday) {
    me.todayBtn = new Ext.button.Button({ui:me.footerButtonUI, ownerCt:me, ownerLayout:me.getComponentLayout(), text:Ext.String.format(me.todayText, today), tooltip:Ext.String.format(me.todayTip, today), tooltipType:'title', tabIndex:-1, ariaRole:'presentation', handler:me.selectToday, scope:me});
  }
  Ext.Component.prototype.beforeRender.call(this);
  Ext.applyIf(me, {renderData:{}});
  Ext.apply(me.renderData, {dayNames:me.dayNames, showToday:me.showToday, prevText:encode(me.prevText), nextText:encode(me.nextText), todayText:encode(me.todayText), ariaMinText:encode(me.ariaMinText), ariaMaxText:encode(me.ariaMaxText), ariaDisabledDaysText:encode(me.ariaDisabledDaysText), ariaDisabledDatesText:encode(me.ariaDisabledDatesText), days:days});
  me.protoEl.unselectable();
}, cacheWidth:function() {
  var me = this, padding = me.parseBox(me.padding), widthEl = Ext.getBody().createChild({cls:me.baseCls + ' ' + me.borderBoxCls, style:'position:absolute;top:-1000px;left:-1000px;'});
  me.self.prototype.width = widthEl.getWidth() + padding.left + padding.right;
  widthEl.destroy();
}, onRender:function(container, position) {
  var me = this, dateCellSelector = 'div.' + me.baseCls + '-date';
  Ext.Component.prototype.onRender.apply(this, arguments);
  me.cells = me.eventEl.select('tbody td');
  me.textNodes = me.eventEl.query(dateCellSelector);
  me.eventEl.set({'aria-labelledby':me.monthBtn.id});
  me.mon(me.eventEl, {scope:me, mousewheel:me.handleMouseWheel, click:{fn:me.handleDateClick, delegate:dateCellSelector}});
}, initEvents:function() {
  var me = this;
  Ext.Component.prototype.initEvents.call(this);
  if (me.pickerField) {
    me.el.on('mousedown', me.onMouseDown, me);
  }
  me.monthBtn.el.on('mousedown', me.onMouseDown, me);
  me.prevRepeater = new Ext.util.ClickRepeater({el:me.prevEl, handler:me.showPrevMonth, scope:me, mousedownStopEvent:true});
  me.nextRepeater = new Ext.util.ClickRepeater({el:me.nextEl, handler:me.showNextMonth, scope:me, mousedownStopEvent:true});
  me.keyNav = new Ext.util.KeyNav(Ext.apply({target:me.eventEl, scope:me, left:me.onLeftKey, right:me.onRightKey, up:me.onUpKey, down:me.onDownKey, pageUp:me.onPageUpKey, pageDown:me.onPageDownKey, home:me.onHomeKey, end:me.onEndKey, enter:me.onEnterKey, space:me.onSpaceKey, tab:function(e) {
    this.handleTabKey(e);
    return true;
  }}, me.keyNavConfig));
  if (me.disabled) {
    me.syncDisabled(true, true);
  }
  if (me.minDate && me.minDate > me.value) {
    me.value = me.minDate;
  } else {
    if (me.maxDate && me.maxDate < me.value) {
      me.value = me.maxDate;
    }
  }
  me.update(me.value);
}, onMouseDown:function(e) {
  e.preventDefault();
}, handleTabKey:function(e) {
  var me = this, t = me.getSelectedDate(me.activeDate), handler = me.handler;
  if (!me.disabled && t.dateValue && !Ext.fly(t.parentNode).hasCls(me.disabledCellCls)) {
    me.setValue(new Date(t.dateValue));
    me.fireEvent('select', me, me.value);
    if (handler) {
      Ext.callback(handler, me.scope, [me, me.value], null, me, me);
    }
    if (me.pickerField && me.pickerField.isEditorComponent) {
      e.preventDefault();
    }
    me.onSelect();
  } else {
    me.fireEventArgs('tabout', [me]);
  }
}, getSelectedDate:function(date) {
  var me = this, t = date.getTime(), cells = me.cells, cls = me.selectedCls, cellItems = cells.elements, cLen = cellItems.length, cell, c;
  cells.removeCls(cls);
  for (c = 0; c < cLen; c++) {
    cell = cellItems[c].firstChild;
    if (cell.dateValue === t) {
      return cell;
    }
  }
  return null;
}, initDisabledDays:function() {
  var me = this, dd = me.disabledDates, re = '(?:', len, d, dLen, dI;
  if (!me.disabledDatesRE && dd) {
    len = dd.length - 1;
    dLen = dd.length;
    for (d = 0; d < dLen; d++) {
      dI = dd[d];
      re += Ext.isDate(dI) ? '^' + Ext.String.escapeRegex(Ext.Date.dateFormat(dI, me.format)) + '$' : dI;
      if (d !== len) {
        re += '|';
      }
    }
    me.disabledDatesRE = new RegExp(re + ')');
  }
}, setDisabledDates:function(dd) {
  var me = this;
  if (Ext.isArray(dd)) {
    me.disabledDates = dd;
    me.disabledDatesRE = null;
  } else {
    me.disabledDatesRE = dd;
  }
  me.initDisabledDays();
  me.update(me.value, true);
  return me;
}, setDisabledDays:function(disabledDays) {
  this.disabledDays = disabledDays;
  return this.update(this.value, true);
}, setMinDate:function(minDate) {
  this.minDate = minDate;
  return this.update(this.value, true);
}, setMaxDate:function(maxDate) {
  this.maxDate = maxDate;
  return this.update(this.value, true);
}, setValue:function(value) {
  this.value = Ext.Date.clearTime(value || this.defaultValue, true);
  return this.update(this.value);
}, getValue:function() {
  return this.value;
}, getDayInitial:function(value) {
  return value.substr(0, 1);
}, onEnable:function() {
  var me = this;
  Ext.Component.prototype.onEnable.call(this);
  me.syncDisabled(false, true);
  me.update(me.activeDate);
}, onShow:function() {
  var me = this;
  Ext.Component.prototype.onShow.call(this);
  me.syncDisabled(false);
  if (me.pickerField) {
    me.startValue = me.pickerField.getValue();
  }
}, onHide:function() {
  Ext.Component.prototype.onHide.call(this);
  this.syncDisabled(true);
}, onDisable:function() {
  Ext.Component.prototype.onDisable.call(this);
  this.syncDisabled(true, true);
}, getActive:function() {
  return this.activeDate || this.value;
}, runAnimation:function(isHide) {
  var picker = this.monthPicker, options = {duration:200, callback:function() {
    picker.setVisible(!isHide);
  }};
  if (isHide) {
    picker.el.slideOut('t', options);
  } else {
    picker.el.slideIn('t', options);
  }
}, hideMonthPicker:function(animate) {
  var me = this, picker = me.monthPicker;
  if (picker && picker.isVisible()) {
    me.focus();
    if (me.shouldAnimate(animate)) {
      me.runAnimation(true);
    } else {
      picker.hide();
    }
  }
  return me;
}, doShowMonthPicker:function() {
  this.showMonthPicker();
}, doHideMonthPicker:function() {
  this.hideMonthPicker();
}, showMonthPicker:function(animate) {
  var me = this, el = me.el, picker;
  if (me.rendered && !me.disabled) {
    picker = me.createMonthPicker();
    if (!picker.isVisible()) {
      picker.setValue(me.getActive());
      picker.setSize(el.getSize());
      picker.floatParent = null;
      picker.setPosition(-el.getBorderWidth('l'), -el.getBorderWidth('t'));
      if (me.shouldAnimate(animate)) {
        me.runAnimation(false);
      } else {
        picker.show();
      }
    }
  }
  return me;
}, shouldAnimate:function(animate) {
  return Ext.isDefined(animate) ? animate : !this.disableAnim;
}, createMonthPicker:function() {
  var me = this, picker = me.monthPicker;
  if (!picker) {
    me.monthPicker = picker = new Ext.picker.Month({renderTo:me.el, ownerCmp:me, floating:true, padding:me.padding, shadow:false, small:me.showToday === false, footerButtonUI:me.footerButtonUI, listeners:{scope:me, cancelclick:me.onCancelClick, okclick:me.onOkClick, yeardblclick:me.onOkClick, monthdblclick:me.onOkClick}});
    if (!me.disableAnim) {
      picker.el.setStyle('display', 'none');
    }
    picker.hide();
    me.on('beforehide', me.doHideMonthPicker, me);
  }
  return picker;
}, onLeftKey:function(e) {
  if (e.ctrlKey) {
    this.showPrevMonth();
  } else {
    this.update(Ext.Date.add(this.activeDate, Ext.Date.DAY, -1));
  }
  e.preventDefault();
}, onRightKey:function(e) {
  if (e.ctrlKey) {
    this.showNextMonth();
  } else {
    this.update(Ext.Date.add(this.activeDate, Ext.Date.DAY, 1));
  }
  e.preventDefault();
}, onUpKey:function(e) {
  if (e.ctrlKey) {
    this.showNextYear();
  } else {
    this.update(Ext.Date.add(this.activeDate, Ext.Date.DAY, -7));
  }
  e.preventDefault();
}, onDownKey:function(e) {
  if (e.ctrlKey) {
    this.showPrevYear();
  } else {
    this.update(Ext.Date.add(this.activeDate, Ext.Date.DAY, 7));
  }
  e.preventDefault();
}, onPageUpKey:function(e) {
  if (e.ctrlKey) {
    this.showPrevYear();
  } else {
    this.showPrevMonth();
  }
  e.preventDefault();
}, onPageDownKey:function(e) {
  if (e.ctrlKey) {
    this.showNextYear();
  } else {
    this.showNextMonth();
  }
  e.preventDefault();
}, onHomeKey:function(e) {
  this.update(Ext.Date.getFirstDateOfMonth(this.activeDate));
  e.preventDefault();
}, onEndKey:function(e) {
  this.update(Ext.Date.getLastDateOfMonth(this.activeDate));
  e.preventDefault();
}, onEnterKey:function(e) {
  this.handleDateClick(e, this.activeCell.firstChild);
}, onSpaceKey:function(e) {
  var me = this, pickerField = me.pickerField, startValue, value, pickerValue;
  me.setValue(new Date(me.activeCell.firstChild.dateValue));
  if (pickerField) {
    startValue = me.startValue;
    value = me.value;
    pickerValue = pickerField.getValue();
    if (pickerValue && startValue && pickerValue.getTime() === value.getTime()) {
      pickerField.setValue(startValue);
    } else {
      pickerField.setValue(value);
    }
  }
  e.preventDefault();
}, onOkClick:function(picker, value) {
  var me = this, month = value[0], year = value[1], date = new Date(year, month, me.getActive().getDate());
  if (date.getMonth() !== month) {
    date = Ext.Date.getLastDateOfMonth(new Date(year, month, 1));
  }
  me.setValue(date);
  me.hideMonthPicker();
}, onCancelClick:function() {
  this.selectedUpdate(this.activeDate);
  this.hideMonthPicker();
}, showPrevMonth:function(e) {
  return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.MONTH, -1));
}, showNextMonth:function(e) {
  return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.MONTH, 1));
}, showPrevYear:function() {
  return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.YEAR, -1));
}, showNextYear:function() {
  return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.YEAR, 1));
}, handleMouseWheel:function(e) {
  var delta;
  e.stopEvent();
  if (!this.disabled) {
    delta = e.getWheelDelta();
    if (delta > 0) {
      this.showPrevMonth();
    } else {
      if (delta < 0) {
        this.showNextMonth();
      }
    }
  }
}, handleDateClick:function(e, t) {
  var me = this, handler = me.handler;
  e.stopEvent();
  if (!me.disabled && t.dateValue && !Ext.fly(t.parentNode).hasCls(me.disabledCellCls)) {
    me.setValue(new Date(t.dateValue));
    me.fireEvent('select', me, me.value);
    if (handler) {
      Ext.callback(handler, me.scope, [me, me.value], null, me, me);
    }
    me.onSelect();
  }
}, onSelect:function() {
  if (this.hideOnSelect) {
    this.hide();
  }
}, selectToday:function() {
  var me = this, btn = me.todayBtn, handler = me.handler;
  if (btn && !btn.disabled) {
    me.setValue(Ext.Date.clearTime(new Date));
    me.fireEvent('select', me, me.value);
    if (handler) {
      Ext.callback(handler, me.scope, [me, me.value], null, me, me);
    }
    me.onSelect();
  }
  return me;
}, selectedUpdate:function(date) {
  var me = this, t = date.getTime(), cells = me.cells, cls = me.selectedCls, c, cLen = cells.getCount(), cell;
  me.eventEl.dom.setAttribute('aria-busy', 'true');
  cell = me.activeCell;
  if (cell) {
    Ext.fly(cell).removeCls(cls);
    cell.setAttribute('aria-selected', false);
  }
  for (c = 0; c < cLen; c++) {
    cell = cells.item(c);
    if (me.textNodes[c].dateValue === t) {
      me.activeCell = cell.dom;
      me.eventEl.dom.setAttribute('aria-activedescendant', cell.dom.id);
      cell.dom.setAttribute('aria-selected', true);
      cell.addCls(cls);
      me.fireEvent('highlightitem', me, cell);
      break;
    }
  }
  me.eventEl.dom.removeAttribute('aria-busy');
}, fullUpdate:function(date) {
  var me = this, cells = me.cells.elements, textNodes = me.textNodes, disabledCls = me.disabledCellCls, eDate = Ext.Date, i = 0, extraDays = 0, newDate = +eDate.clearTime(date, true), today = +eDate.clearTime(new Date), min = me.minDate ? eDate.clearTime(me.minDate, true) : Number.NEGATIVE_INFINITY, max = me.maxDate ? eDate.clearTime(me.maxDate, true) : Number.POSITIVE_INFINITY, ddMatch = me.disabledDatesRE, ddText = me.disabledDatesText, ddays = me.disabledDays ? me.disabledDays.join('') : false, 
  ddaysText = me.disabledDaysText, format = me.format, days = eDate.getDaysInMonth(date), firstOfMonth = eDate.getFirstDateOfMonth(date), startingPos = firstOfMonth.getDay() - me.startDay, previousMonth = eDate.add(date, eDate.MONTH, -1), ariaTitleDateFormat = me.ariaTitleDateFormat, prevStart, current, disableToday, tempDate, setCellClass, html, cls, formatValue, value;
  if (startingPos < 0) {
    startingPos += 7;
  }
  days += startingPos;
  prevStart = eDate.getDaysInMonth(previousMonth) - startingPos;
  current = new Date(previousMonth.getFullYear(), previousMonth.getMonth(), prevStart, me.initHour);
  if (me.showToday) {
    tempDate = eDate.clearTime(new Date);
    disableToday = tempDate < min || tempDate > max || ddMatch && format && ddMatch.test(eDate.dateFormat(tempDate, format)) || ddays && ddays.indexOf(tempDate.getDay()) !== -1;
    me.todayDisabled = disableToday;
    if (!me.disabled) {
      me.todayBtn.setDisabled(disableToday);
    }
  }
  setCellClass = function(cellIndex, cls) {
    var cell = cells[cellIndex], describedBy = [];
    if (!cell.hasAttribute('id')) {
      cell.setAttribute('id', me.id + '-cell-' + cellIndex);
    }
    value = +eDate.clearTime(current, true);
    cell.firstChild.dateValue = value;
    cell.setAttribute('aria-label', eDate.format(current, ariaTitleDateFormat));
    cell.removeAttribute('aria-describedby');
    cell.removeAttribute('data-qtip');
    if (value === today) {
      cls += ' ' + me.todayCls;
      describedBy.push(me.id + '-todayText');
    }
    if (value === newDate) {
      me.activeCell = cell;
      me.eventEl.dom.setAttribute('aria-activedescendant', cell.id);
      cell.setAttribute('aria-selected', true);
      cls += ' ' + me.selectedCls;
      me.fireEvent('highlightitem', me, cell);
    } else {
      cell.setAttribute('aria-selected', false);
    }
    if (value < min) {
      cls += ' ' + disabledCls;
      describedBy.push(me.id + '-ariaMinText');
      cell.setAttribute('data-qtip', me.minText);
    } else {
      if (value > max) {
        cls += ' ' + disabledCls;
        describedBy.push(me.id + '-ariaMaxText');
        cell.setAttribute('data-qtip', me.maxText);
      } else {
        if (ddays && ddays.indexOf(current.getDay()) !== -1) {
          cell.setAttribute('data-qtip', ddaysText);
          describedBy.push(me.id + '-ariaDisabledDaysText');
          cls += ' ' + disabledCls;
        } else {
          if (ddMatch && format) {
            formatValue = eDate.dateFormat(current, format);
            if (ddMatch.test(formatValue)) {
              cell.setAttribute('data-qtip', ddText.replace('%0', formatValue));
              describedBy.push(me.id + '-ariaDisabledDatesText');
              cls += ' ' + disabledCls;
            }
          }
        }
      }
    }
    if (describedBy.length) {
      cell.setAttribute('aria-describedby', describedBy.join(' '));
    }
    cell.className = cls + ' ' + me.cellCls;
  };
  me.eventEl.dom.setAttribute('aria-busy', 'true');
  for (; i < me.numDays; ++i) {
    if (i < startingPos) {
      html = ++prevStart;
      cls = me.prevCls;
    } else {
      if (i >= days) {
        html = ++extraDays;
        cls = me.nextCls;
      } else {
        html = i - startingPos + 1;
        cls = me.activeCls;
      }
    }
    textNodes[i].innerHTML = html;
    current.setDate(current.getDate() + 1);
    setCellClass(i, cls);
  }
  me.eventEl.dom.removeAttribute('aria-busy');
  me.monthBtn.setText(Ext.Date.format(date, me.monthYearFormat));
}, update:function(date, forceRefresh) {
  var me = this, active = me.activeDate;
  if (me.rendered) {
    me.activeDate = date;
    if (!forceRefresh && active && me.el && active.getMonth() === date.getMonth() && active.getFullYear() === date.getFullYear()) {
      me.selectedUpdate(date, active);
    } else {
      me.fullUpdate(date, active);
    }
  }
  return me;
}, doDestroy:function() {
  var me = this;
  if (me.rendered) {
    Ext.destroy(me.keyNav, me.monthPicker, me.monthBtn, me.nextRepeater, me.prevRepeater, me.todayBtn, me.todayElSpan);
  }
  Ext.Component.prototype.doDestroy.call(this);
}, privates:{finishRenderChildren:function() {
  var me = this;
  Ext.Component.prototype.finishRenderChildren.call(this);
  me.monthBtn.finishRender();
  if (me.showToday) {
    me.todayBtn.finishRender();
  }
}, getFocusEl:function() {
  return this.eventEl;
}, syncDisabled:function(disabled, doButton) {
  var me = this, keyNav = me.keyNav, todayBtn = me.todayBtn;
  if (keyNav) {
    keyNav.setDisabled(disabled);
    me.prevRepeater.setDisabled(disabled);
    me.nextRepeater.setDisabled(disabled);
  }
  if (doButton && todayBtn) {
    todayBtn.setDisabled(me.todayDisabled || disabled);
  }
}}}, 0, ['datepicker'], ['component', 'box', 'datepicker'], {'component':true, 'box':true, 'datepicker':true}, ['widget.datepicker'], 0, [Ext.picker, 'Date', Ext, 'DatePicker'], 0);
Ext.define('Ext.theme.triton.picker.Date', {override:'Ext.picker.Date', footerButtonUI:'default-toolbar'});
Ext.cmd.derive('Ext.tip.Tip', Ext.panel.Panel, {alternateClassName:'Ext.Tip', minWidth:40, maxWidth:500, shadow:'sides', constrainPosition:true, autoRender:true, hidden:true, baseCls:'x-tip', focusOnToFront:false, maskOnDisable:false, closeAction:'hide', alwaysFramed:true, frameHeader:false, initComponent:function() {
  var me = this;
  me.floating = Ext.apply({}, {shadow:me.shadow}, me.self.prototype.floating);
  Ext.panel.Panel.prototype.initComponent.apply(this, arguments);
  me.constrain = me.constrain || me.constrainPosition;
}, showAt:function(xy) {
  var me = this;
  me.calledFromShowAt = true;
  Ext.panel.Panel.prototype.showAt.apply(this, arguments);
  if (me.isVisible()) {
    me.doAlignment(me.getRegion().alignTo({target:new Ext.util.Point(xy[0], xy[1]), inside:me.constrainPosition ? Ext.getBody().getRegion().adjust(5, -5, -5, 5) : null, align:'tl-tl', overlap:true}));
  }
  me.calledFromShowAt = 0;
}, doAlignment:function(newRegion) {
  var me = this, anchorEl = me.anchorEl, anchorRegion = newRegion.anchor;
  me.setPagePosition([newRegion.x, newRegion.y]);
  if (anchorEl) {
    anchorEl.removeCls(me.anchorCls);
    if (anchorRegion) {
      me.anchorCls = 'x-tip-anchor-' + anchorRegion.position;
      anchorEl.addCls(me.anchorCls);
      anchorEl.show();
      if (anchorRegion.align & 1) {
        anchorEl.setTop(newRegion.anchor.y - newRegion.y);
        anchorEl.dom.style.left = '';
      } else {
        anchorEl.setLeft(newRegion.anchor.x - newRegion.x);
        anchorEl.dom.style.top = '';
      }
    } else {
      anchorEl.hide();
    }
  }
}, privates:{initDraggable:function() {
  var me = this;
  me.draggable = {el:me.getDragEl(), delegate:me.header.el, constrain:me, constrainTo:me.el.dom.parentNode};
  Ext.Component.prototype.initDraggable.call(me);
}}, ghost:undefined, unghost:undefined}, 0, ['tip'], ['component', 'box', 'container', 'panel', 'tip'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tip':true}, ['widget.tip'], 0, [Ext.tip, 'Tip', Ext, 'Tip'], 0);
Ext.cmd.derive('Ext.tip.ToolTip', Ext.tip.Tip, {alternateClassName:'Ext.ToolTip', autoHide:true, showDelay:500, hideDelay:200, dismissDelay:5000, mouseOffset:[15, 18], trackMouse:false, anchorToTarget:true, targetCounter:0, quickShowInterval:250, hideAction:'hide', fadeOutDuration:1000, defaultAlign:'bl-tl', ariaRole:'tooltip', alwaysOnTop:true, initComponent:function() {
  var me = this;
  Ext.tip.Tip.prototype.initComponent.call(this);
  me.setTarget(me.target);
  me.currentTarget = new Ext.dom.Fly;
}, onRender:function(ct, position) {
  var me = this;
  Ext.tip.Tip.prototype.onRender.apply(this, arguments);
  me.anchorEl = me.el.createChild({role:'presentation', cls:'x-tip-anchor'});
}, show:function() {
  if (!this.currentTarget.dom && this.target) {
    return this.showBy(this.target);
  }
  Ext.tip.Tip.prototype.show.call(this);
}, setTarget:function(target) {
  var me = this, listeners;
  if (me.targetListeners) {
    me.targetListeners.destroy();
  }
  if (target) {
    me.target = target = Ext.get(target.el || target);
    listeners = {mouseover:'onTargetOver', mouseout:'onTargetOut', mousemove:'onMouseMove', tap:'onTargetTap', scope:me, destroyable:true};
    me.targetListeners = target.on(listeners);
  } else {
    me.target = null;
  }
}, onMouseMove:function(e) {
  var me = this, dismissDelay = me.dismissDelay;
  me.pointerEvent = e;
  if (me.isVisible() && me.currentTarget.contains(e.target)) {
    if (dismissDelay && me.autoHide !== false) {
      me.clearTimer('dismiss');
      me.dismissTimer = Ext.defer(me.hide, dismissDelay, me);
    }
    if (me.trackMouse) {
      me.doAlignment(me.getAlignRegion());
    }
  }
}, getAlignRegion:function() {
  var me = this, anchorEl = me.anchorEl, align = me.getAnchorAlign(), overlap, alignSpec, target, mouseOffset = me.mouseOffset;
  if (!me.anchorSize) {
    anchorEl.addCls('x-tip-anchor-top');
    anchorEl.show();
    me.anchorSize = new Ext.util.Offset(anchorEl.getWidth(false, true), anchorEl.getHeight(false, true));
    anchorEl.removeCls('x-tip-anchor-top');
    anchorEl.hide();
  }
  if ((me.anchor || me.align) && me.anchorToTarget && !me.trackMouse) {
    target = me.currentTarget.getRegion();
  } else {
    target = me.pointerEvent ? me.pointerEvent.getPoint().adjust(-Math.abs(mouseOffset[1]), Math.abs(mouseOffset[0]), Math.abs(mouseOffset[1]), -Math.abs(mouseOffset[0])) : new Ext.util.Point;
    if (!me.anchor) {
      overlap = true;
      if (mouseOffset[0] > 0) {
        if (mouseOffset[1] > 0) {
          align = 'tl-br';
        } else {
          align = 'bl-tr';
        }
      } else {
        if (mouseOffset[1] > 0) {
          align = 'tr-bl';
        } else {
          align = 'br-tl';
        }
      }
    }
  }
  alignSpec = {align:me.convertPositionSpec(align), axisLock:me.axisLock, target:target, overlap:overlap, offset:me.targetOffset, inside:me.constrainPosition ? me.constrainTo || Ext.getBody().getRegion().adjust(5, -5, -5, 5) : null};
  if (me.anchor) {
    alignSpec.anchorSize = me.anchorSize;
  }
  return me.getRegion().alignTo(alignSpec);
}, fadeOut:function() {
  var me = this;
  me.el.fadeOut({duration:me.fadeOutDuration, callback:function() {
    me.hide();
    me.el.setOpacity('');
  }});
}, getAnchorAlign:function() {
  switch(this.anchor) {
    case 'top':
      return 'tl-bl';
    case 'left':
      return 'tl-tr';
    case 'right':
      return 'tr-tl';
    default:
      return this.defaultAlign;
  }
}, onTargetTap:function(e) {
  if (this.showOnTap && e.pointerType !== 'mouse' && Ext.fly(e.target).isVisible(true)) {
    this.onTargetOver(e);
  }
}, onTargetOver:function(e) {
  var me = this, delegate = me.delegate, currentTarget = me.currentTarget, fromElement = e.relatedTarget || e.fromElement, newTarget, myListeners = me.hasListeners;
  if (me.disabled) {
    return;
  }
  if (delegate) {
    if (currentTarget.contains(e.target)) {
      return;
    }
    newTarget = e.getTarget(delegate);
    if (newTarget && e.getRelatedTarget(delegate) === newTarget) {
      return;
    }
  } else {
    if (!me.target.contains(fromElement)) {
      newTarget = me.target.dom;
    } else {
      return;
    }
  }
  if (newTarget) {
    if ((myListeners.beforeshow || myListeners.show) && me.isVisible()) {
      me.hide();
    }
    me.triggerElement = newTarget;
    me.pointerEvent = e;
    currentTarget.attach(newTarget);
    me.handleTargetOver(newTarget, e);
  } else {
    if (currentTarget.dom) {
      me.handleTargetOut();
    }
  }
}, handleTargetOver:function(target, event) {
  if (event.pointerType !== 'mouse') {
    this.showFromDelay();
  } else {
    this.delayShow();
  }
}, delayShow:function() {
  var me = this;
  me.clearTimer('hide');
  if (me.hidden && !me.showTimer) {
    if (me.delegate && Ext.Date.getElapsed(me.lastHidden) < me.quickShowInterval) {
      me.showFromDelay();
    } else {
      me.showTimer = Ext.defer(me.showFromDelay, me.pointerEvent.pointerType !== 'mouse' ? 0 : me.showDelay, me);
    }
  } else {
    if (!me.hidden && me.autoHide !== false) {
      me.showFromDelay();
    }
  }
}, showFromDelay:function() {
  var me = this;
  if (!me.disabled) {
    me.fireEvent('hovertarget', me, me.currentTarget, me.currentTarget.dom);
    if (me.isVisible()) {
      me.realignToTarget();
    } else {
      me.triggerElement = me.currentTarget.dom;
      me.fromDelayShow = true;
      me.show();
      me.fromDelayShow = false;
    }
  }
}, onTargetOut:function(e) {
  if (this.currentTarget.dom && !this.currentTarget.contains(e.relatedTarget)) {
    this.handleTargetOut();
  }
}, handleTargetOut:function() {
  var me = this;
  if (me.showTimer) {
    me.clearTimer('show');
  }
  if (me.isVisible() && me.autoHide) {
    me.delayHide();
  }
}, delayHide:function() {
  var me = this;
  if (!me.hidden && !me.hideTimer) {
    me.clearTimer('dismiss');
    me.hideTimer = Ext.defer(me[me.hideAction], me.hideDelay, me);
  }
}, hide:function() {
  var me = this;
  me.currentTarget.detach();
  me.clearTimer('dismiss');
  me.lastHidden = new Date;
  if (me.anchorEl) {
    me.anchorEl.hide();
  }
  Ext.tip.Tip.prototype.hide.apply(this, arguments);
  me.triggerElement = null;
}, afterShow:function() {
  Ext.tip.Tip.prototype.afterShow.call(this);
  this.realignToTarget();
}, realignToTarget:function() {
  var me = this;
  me.clearTimers();
  if (!me.calledFromShowAt) {
    me.doAlignment(me.getAlignRegion());
  }
  if (me.dismissDelay && me.autoHide !== false) {
    me.dismissTimer = Ext.defer(me.hide, me.dismissDelay, me);
  }
}, showBy:function(target) {
  var me = this;
  me.align = me.defaultAlign;
  if (target.isEvent) {
    me.currentTarget.attach(target.target);
    me.pointerEvent = target;
  } else {
    me.currentTarget.attach(Ext.getDom(target.el || target));
    me.triggerElement = me.currentTarget.dom;
  }
  if (me.isVisible()) {
    me.realignToTarget();
  } else {
    me.show();
  }
  return me;
}, _timerNames:{}, clearTimer:function(name) {
  var me = this, names = me._timerNames, propName = names[name] || (names[name] = name + 'Timer'), timer = me[propName];
  if (timer) {
    Ext.undefer(timer);
    me[propName] = null;
    if (name === 'show' && me.isHidden()) {
      me.currentTarget.detach();
    }
  }
}, clearTimers:function() {
  var me = this;
  me.clearTimer('show');
  me.clearTimer('dismiss');
  me.clearTimer('hide');
  me.clearTimer('enable');
}, onShow:function() {
  var me = this;
  Ext.tip.Tip.prototype.onShow.call(this);
  me.mousedownListener = Ext.on({mousedown:'onDocMouseDown', scope:me, destroyable:true});
}, onHide:function() {
  var me = this;
  Ext.tip.Tip.prototype.onHide.call(this);
  Ext.destroy(me.mousedownListener);
}, onDocMouseDown:function(e) {
  var me = this, delegate = me.delegate;
  if (e.within(me.el.dom)) {
    if (e.pointerType !== 'mouse' && me.allowOver) {
      me.clearTimer('dismiss');
    }
  } else {
    if (!me.closable) {
      if (e.within(me.target) && (!delegate || e.getTarget(delegate))) {
        me.delayHide();
      } else {
        me.disable();
        me.enableTimer = Ext.defer(me.enable, 100, me);
      }
    }
  }
}, doEnable:function() {
  if (!this.destroyed) {
    this.enable();
  }
}, onDisable:function() {
  Ext.tip.Tip.prototype.onDisable.call(this);
  this.clearTimers();
  this.hide();
}, doDestroy:function() {
  var me = this;
  me.clearTimers();
  me.destroyMembers('mousedownListener', 'anchorEl');
  Ext.tip.Tip.prototype.doDestroy.call(this);
}, privates:{getTrackMouse:function() {
  return this.trackMouse;
}, clipTo:function(clippingEl, sides) {
  var clippingRegion;
  if (clippingEl.isRegion) {
    clippingRegion = clippingEl;
  } else {
    clippingRegion = (clippingEl.isComponent ? clippingEl.el : Ext.fly(clippingEl)).getConstrainRegion();
  }
  Ext.tip.Tip.prototype.clipTo.call(this, clippingRegion, sides);
  this.anchorEl.clipTo(clippingRegion, sides);
}}}, 0, ['tooltip'], ['component', 'box', 'container', 'panel', 'tip', 'tooltip'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tip':true, 'tooltip':true}, ['widget.tooltip'], 0, [Ext.tip, 'ToolTip', Ext, 'ToolTip'], 0);
Ext.cmd.derive('Ext.tip.QuickTip', Ext.tip.ToolTip, {alternateClassName:'Ext.QuickTip', interceptTitles:false, title:'\x26#160;', tagConfig:{namespace:'data-', attribute:'qtip', width:'qwidth', target:'target', title:'qtitle', hide:'hide', cls:'qclass', align:'qalign', anchor:'anchor', showDelay:'qshowDelay', hideAction:'hideAction', anchorTarget:'anchorTarget'}, isQuickTip:true, shrinkWrapDock:true, initComponent:function() {
  var me = this;
  me.delegate = me.delegate.bind(me);
  me.target = me.target || Ext.getDoc();
  me.targets = me.targets || {};
  me.header = me.header || {};
  me.header.focusableContainer = false;
  Ext.tip.ToolTip.prototype.initComponent.call(this);
}, setTagConfig:function(cfg) {
  this.tagConfig = Ext.apply({}, cfg);
  delete this.tagConfig.attr;
}, text:null, register:function(config) {
  var configs = Ext.isArray(config) ? config : arguments, i = 0, len = configs.length, target, j, targetLen;
  for (; i < len; i++) {
    config = configs[i];
    target = config.target;
    if (target) {
      if (Ext.isArray(target)) {
        for (j = 0, targetLen = target.length; j < targetLen; j++) {
          this.targets[Ext.id(target[j])] = config;
        }
      } else {
        this.targets[Ext.id(target)] = config;
      }
    }
  }
}, unregister:function(el) {
  delete this.targets[Ext.id(el)];
}, cancelShow:function(el) {
  var me = this, currentTarget = me.currentTarget;
  el = Ext.getDom(el);
  if (me.isVisible()) {
    if (currentTarget.dom === el) {
      me.hide();
    }
  } else {
    if (currentTarget.dom === el) {
      me.clearTimer('show');
    }
  }
}, delegate:function(target) {
  var me = this, cfg = me.tagConfig, attr = cfg.attr || (cfg.attr = cfg.namespace + cfg.attribute), text;
  text = target.getAttribute(attr) || me.interceptTitles && target.title;
  return !!text;
}, getTipText:function(target) {
  var titleText = target.title, cfg = this.tagConfig, attr = cfg.attr || (cfg.attr = cfg.namespace + cfg.attribute);
  if (this.interceptTitles && titleText) {
    target.setAttribute(attr, titleText);
    target.removeAttribute('title');
    return titleText;
  } else {
    return target.getAttribute(attr);
  }
}, onTargetOver:function(event) {
  var me = this, currentTarget = me.currentTarget, target = event.target, targets, registeredTarget, key;
  if (!target || target.nodeType !== 1 || target === document.documentElement || target === document.body) {
    return;
  }
  me.pointerEvent = event;
  targets = me.targets;
  for (key in targets) {
    if (targets.hasOwnProperty(key)) {
      registeredTarget = targets[key];
      target = Ext.getDom(registeredTarget.target);
      if (target && Ext.fly(target).contains(event.target) && !Ext.fly(target).contains(event.relatedTarget)) {
        currentTarget.attach(target);
        me.activeTarget = registeredTarget;
        registeredTarget.el = currentTarget;
        me.anchor = registeredTarget.anchor;
        me.activateTarget();
        return;
      }
    }
  }
  Ext.tip.ToolTip.prototype.onTargetOver.call(this, event);
}, handleTargetOver:function(target, event) {
  var me = this, currentTarget = me.currentTarget, cfg = me.tagConfig, ns = cfg.namespace, tipText = me.getTipText(target, event), autoHide;
  if (tipText) {
    autoHide = currentTarget.getAttribute(ns + cfg.hide);
    me.activeTarget = {el:currentTarget, text:tipText, width:+currentTarget.getAttribute(ns + cfg.width) || null, autoHide:autoHide !== 'user' && autoHide !== 'false', title:currentTarget.getAttribute(ns + cfg.title), cls:currentTarget.getAttribute(ns + cfg.cls), align:currentTarget.getAttribute(ns + cfg.align), showDelay:currentTarget.getAttribute(ns + cfg.showDelay), hideAction:currentTarget.getAttribute(ns + cfg.hideAction), alignTarget:currentTarget.getAttribute(ns + cfg.anchorTarget)};
    if (!me.initialConfig.hasOwnProperty('anchor')) {
      me.anchor = currentTarget.getAttribute(ns + cfg.anchor);
    }
    if (me.anchor && !me.initialConfig.hasOwnProperty('anchorTarget')) {
      me.alignTarget = me.activeTarget.alignTarget || target;
    }
    me.activateTarget();
  }
}, activateTarget:function() {
  var me = this, activeTarget = me.activeTarget, delay = activeTarget.showDelay, hideAction = activeTarget.hideAction;
  if (me.isVisible()) {
    me.updateContent();
    me.realignToTarget();
  } else {
    if (activeTarget.showDelay) {
      delay = me.showDelay;
      me.showDelay = parseInt(activeTarget.showDelay, 10);
    }
    me.delayShow();
    if (activeTarget.showDelay) {
      me.showDelay = delay;
    }
    if (!(hideAction = activeTarget.hideAction)) {
      delete me.hideAction;
    } else {
      me.hideAction = hideAction;
    }
  }
}, getAnchorAlign:function() {
  var active = this.activeTarget;
  return active && active.align || Ext.tip.ToolTip.prototype.getAnchorAlign.call(this);
}, getAlignRegion:function() {
  var me = this, activeTarget = me.activeTarget, currentTargetDom = me.currentTarget.dom, result;
  if (activeTarget && activeTarget.alignTarget && me.anchor && !me.initialConfig.hasOwnProperty('anchorTarget')) {
    me.currentTarget.attach(Ext.getDom(activeTarget.alignTarget));
  }
  me.anchorToTarget = !!(activeTarget.align || me.anchor);
  result = Ext.tip.ToolTip.prototype.getAlignRegion.call(this);
  me.currentTarget.attach(currentTargetDom);
  return result;
}, handleTargetOut:function(e) {
  var me = this, active = me.activeTarget, autoHide = me.autoHide, hideDelay = me.hideDelay;
  if (active && autoHide !== false) {
    me.autoHide = true;
    if (active.hideDelay) {
      me.hideDelay = parseInt(active.hideDelay, 10);
    }
    Ext.tip.ToolTip.prototype.handleTargetOut.call(this, e);
    me.autoHide = autoHide;
    me.hideDelay = hideDelay;
  }
}, targetTextEmpty:function() {
  var me = this, target = me.activeTarget, cfg = me.tagConfig, el, text;
  if (target) {
    el = target.el;
    if (el) {
      text = el.getAttribute(cfg.namespace + cfg.attribute);
      if (!text && !me.targets[Ext.id(target.el.dom)]) {
        return true;
      }
    }
  }
  return false;
}, show:function() {
  var me = this, fromDelay = me.fromDelayShow;
  if (fromDelay && me.targetTextEmpty()) {
    me.activeTarget = null;
    me.currentTarget.detach();
    return;
  }
  Ext.tip.ToolTip.prototype.show.apply(this, arguments);
}, beforeShow:function() {
  this.updateContent();
  Ext.tip.ToolTip.prototype.beforeShow.apply(this, arguments);
}, updateContent:function() {
  var me = this, target = me.activeTarget, header = me.header, dismiss, cls;
  if (target) {
    me.suspendLayouts();
    if (target.title) {
      me.setTitle(target.title);
      header.show();
    } else {
      if (header) {
        header.hide();
      }
    }
    me.update(target.text);
    me.autoHide = target.autoHide;
    dismiss = target.dismissDelay;
    me.dismissDelay = Ext.isNumber(dismiss) ? dismiss : me.dismissDelay;
    cls = me.lastCls;
    if (cls) {
      me.removeCls(cls);
      delete me.lastCls;
    }
    cls = target.cls;
    if (cls) {
      me.addCls(cls);
      me.lastCls = cls;
    }
    me.setWidth(target.width);
    me.align = target.align;
    me.resumeLayouts(true);
  }
}, hide:function() {
  this.activeTarget = null;
  Ext.tip.ToolTip.prototype.hide.call(this);
}}, 0, ['quicktip'], ['component', 'box', 'container', 'panel', 'tip', 'tooltip', 'quicktip'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tip':true, 'tooltip':true, 'quicktip':true}, ['widget.quicktip'], 0, [Ext.tip, 'QuickTip', Ext, 'QuickTip'], 0);
Ext.cmd.derive('Ext.tip.QuickTipManager', Ext.Base, {singleton:true, alternateClassName:'Ext.QuickTips', disabled:false, init:function(autoRender, config) {
  var me = this;
  if (!me.tip) {
    if (!Ext.isReady) {
      Ext.onInternalReady(function() {
        Ext.tip.QuickTipManager.init(autoRender, config);
      });
      return false;
    }
    var tipConfig = Ext.apply({disabled:me.disabled, id:'ext-quicktips-tip'}, config), className = tipConfig.className, xtype = tipConfig.xtype;
    if (className) {
      delete tipConfig.className;
    } else {
      if (xtype) {
        className = 'widget.' + xtype;
        delete tipConfig.xtype;
      }
    }
    if (autoRender !== false) {
      tipConfig.renderTo = document.body;
    }
    me.tip = Ext.create(className || 'Ext.tip.QuickTip', tipConfig);
    me.tip.destroy = Ext.emptyFn;
    Ext.quickTipsActive = true;
  }
}, destroy:function() {
  var tip = this.tip;
  if (tip) {
    delete tip.destroy;
    tip.destroy();
    this.tip = null;
  }
  Ext.quickTipsActive = false;
}, ddDisable:function() {
  var me = this, tip = me.tip;
  if (tip && !me.disabled) {
    tip.disable();
  }
}, ddEnable:function() {
  var me = this, tip = me.tip;
  if (tip && !me.disabled) {
    tip.enable();
  }
}, enable:function() {
  var me = this, tip = me.tip;
  if (tip) {
    tip.enable();
  }
  me.disabled = false;
}, disable:function() {
  var me = this, tip = me.tip;
  if (tip) {
    tip.disable();
  }
  me.disabled = true;
}, isEnabled:function() {
  var tip = this.tip;
  return tip !== undefined && !tip.disabled;
}, getQuickTip:function() {
  return this.tip;
}, register:function() {
  var tip = this.tip;
  tip.register.apply(tip, arguments);
}, unregister:function() {
  var tip = this.tip;
  tip.unregister.apply(tip, arguments);
}, tips:function() {
  var tip = this.tip;
  tip.register.apply(tip, arguments);
}}, 0, 0, 0, 0, 0, 0, [Ext.tip, 'QuickTipManager', Ext, 'QuickTips'], 0);
Ext.cmd.derive('Ext.toolbar.Separator', Ext.toolbar.Item, {alternateClassName:'Ext.Toolbar.Separator', baseCls:'x-toolbar-separator', ariaRole:'separator'}, 0, ['tbseparator'], ['component', 'box', 'tbitem', 'tbseparator'], {'component':true, 'box':true, 'tbitem':true, 'tbseparator':true}, ['widget.tbseparator'], 0, [Ext.toolbar, 'Separator', Ext.Toolbar, 'Separator'], 0);
Ext.cmd.derive('Ext.grid.CellContext', Ext.Base, {isCellContext:true, generation:0, constructor:function(view) {
  this.view = view;
}, setPosition:function(row, col) {
  var me = this;
  if (arguments.length === 1) {
    if (row.length) {
      col = row[0];
      row = row[1];
    } else {
      if (row.isCellContext) {
        return me.setAll(row.view, row.rowIdx, row.colIdx, row.record, row.column);
      } else {
        if (row.view) {
          me.view = row.view;
        }
        col = row.column;
        row = row.row;
      }
    }
  }
  me.setRow(row);
  me.setColumn(col);
  return me;
}, setAll:function(view, recordIndex, columnIndex, record, columnHeader) {
  var me = this;
  me.view = view;
  me.rowIdx = recordIndex;
  me.colIdx = columnIndex;
  me.record = record;
  me.column = columnHeader;
  me.generation++;
  return me;
}, setRow:function(row) {
  var me = this, dataSource = me.view.dataSource, oldRecord = me.record, count;
  if (row !== undefined) {
    if (typeof row === 'number') {
      count = dataSource.getCount();
      row = row < 0 ? Math.max(count + row, 0) : Math.max(Math.min(row, count - 1), 0);
      me.rowIdx = row;
      me.record = dataSource.getAt(row);
    } else {
      if (row.isModel) {
        me.record = row;
        me.rowIdx = dataSource.indexOf(row);
      } else {
        if (row.tagName || row.isElement) {
          me.record = me.view.getRecord(row);
          me.rowIdx = me.record ? me.record.isCollapsedPlaceholder ? dataSource.indexOfPlaceholder(me.record) : dataSource.indexOf(me.record) : -1;
        }
      }
    }
  }
  if (me.record !== oldRecord) {
    me.generation++;
  }
  return me;
}, setColumn:function(col) {
  var me = this, colMgr = me.view.getVisibleColumnManager(), oldColumn = me.column;
  if (col !== undefined) {
    if (typeof col === 'number') {
      me.colIdx = col;
      me.column = colMgr.getHeaderAtIndex(col);
    } else {
      if (col.isHeader) {
        me.column = col;
        me.colIdx = colMgr.indexOf(col);
      }
    }
  }
  if (me.column !== oldColumn) {
    me.generation++;
  }
  return me;
}, setView:function(view) {
  this.view = view;
  this.refresh();
}, getCell:function(returnDom) {
  return this.view.getCellByPosition(this, returnDom);
}, getRow:function(returnDom) {
  var result = this.view.getRow(this.record);
  return returnDom ? result : Ext.get(result);
}, getNode:function(returnDom) {
  var result = this.view.getNode(this.record);
  return returnDom ? result : Ext.get(result);
}, isEqual:function(other) {
  return other && other.isCellContext && other.record === this.record && other.column === this.column;
}, clone:function() {
  var me = this, result = new me.self(me.view);
  result.rowIdx = me.rowIdx;
  result.colIdx = me.colIdx;
  result.record = me.record;
  result.column = me.column;
  return result;
}, privates:{isFirstColumn:function() {
  var cell = this.getCell(true);
  if (cell) {
    return !cell.previousSibling;
  }
}, isLastColumn:function() {
  var cell = this.getCell(true);
  if (cell) {
    return !cell.nextSibling;
  }
}, isLastRenderedRow:function() {
  return this.view.all.endIndex === this.rowIdx;
}, getLastColumnIndex:function() {
  var row = this.getRow(true);
  if (row) {
    return row.lastChild.cellIndex;
  }
  return -1;
}, refresh:function() {
  var me = this, newRowIdx = me.view.dataSource.indexOf(me.record), newColIdx = me.view.getVisibleColumnManager().indexOf(me.column);
  me.setRow(newRowIdx === -1 ? me.rowIdx : me.record);
  me.setColumn(newColIdx === -1 ? me.colIdx : me.column);
}, navigate:function(direction) {
  var me = this, columns = me.view.getVisibleColumnManager().getColumns();
  switch(direction) {
    case -1:
      do {
        if (!me.colIdx) {
          me.colIdx = columns.length - 1;
        } else {
          me.colIdx--;
        }
        me.setColumn(me.colIdx);
      } while (!me.getCell(true));
      break;
    case 1:
      do {
        if (me.colIdx >= columns.length) {
          me.colIdx = 0;
        } else {
          me.colIdx++;
        }
        me.setColumn(me.colIdx);
      } while (!me.getCell(true));
      break;
  }
}}, statics:{compare:function(c1, c2) {
  return c1.rowIdx - c2.rowIdx || c1.colIdx - c2.colIdx;
}}}, 1, 0, 0, 0, 0, 0, [Ext.grid, 'CellContext'], 0);
Ext.cmd.derive('Ext.grid.CellEditor', Ext.Editor, {isCellEditor:true, alignment:'l-l!', hideEl:false, cls:'x-small-editor x-grid-editor x-grid-cell-editor', treeNodeSelector:'.x-tree-node-text', shim:false, shadow:false, floating:true, alignOnScroll:false, useBoundValue:false, focusLeaveAction:'completeEdit', setGrid:function(grid) {
  this.grid = grid;
}, startEdit:function(boundEl, value, doFocus) {
  this.context = this.editingPlugin.context;
  Ext.Editor.prototype.startEdit.call(this, boundEl, value, doFocus);
}, onShow:function() {
  var me = this, innerCell = me.boundEl.dom.querySelector(me.context.view.innerSelector);
  if (innerCell) {
    if (me.isForTree) {
      innerCell = innerCell.querySelector(me.treeNodeSelector);
    }
    Ext.fly(innerCell).hide();
  }
  Ext.Editor.prototype.onShow.apply(this, arguments);
}, onFocusEnter:function() {
  var me = this, context = me.context, view = context.view;
  me.reattachToBody();
  context.node = view.getNode(context.record);
  context.row = view.getRow(context.record);
  context.cell = context.getCell(true);
  context.rowIdx = view.indexOf(context.row);
  me.realign(true);
  Ext.Editor.prototype.onFocusEnter.apply(this, arguments);
  me.focusEnterEvent = null;
}, onFocusLeave:function(e) {
  var me = this, view = me.context.view, related = Ext.fly(e.relatedTarget);
  if (me[me.focusLeaveAction]() === false) {
    e.event.stopEvent();
    return;
  }
  delete me.focusLeaveAction;
  if (!view.destroyed && view.el.contains(related) && (!related.isAncestor(e.target) || related === view.el) && !related.up(view.getCellSelector(), view.el, true)) {
    me.context.grid.setActionableMode(false, view.actionPosition);
  }
  me.cacheElement();
  Ext.container.Container.prototype.onFocusLeave.apply(me, arguments);
}, completeEdit:function(remainVisible) {
  var me = this, context = me.context;
  if (me.editing) {
    context.value = me.field.value;
    if (me.editingPlugin.validateEdit(context) === false) {
      if (context.cancel) {
        context.value = me.originalValue;
        me.editingPlugin.cancelEdit();
      }
      return !!context.cancel;
    }
  }
  Ext.Editor.prototype.completeEdit.call(this, remainVisible);
}, onEditComplete:function(remainVisible, canceling) {
  var me = this, activeElement = Ext.Element.getActiveElement(), ctx = me.context, store = ctx && ctx.store, boundEl;
  me.editing = false;
  boundEl = me.boundEl = me.context.getCell();
  if (boundEl) {
    me.restoreCell();
    if (boundEl.contains(activeElement) && boundEl.dom !== activeElement) {
      boundEl.focus();
    }
  }
  Ext.Editor.prototype.onEditComplete.apply(this, arguments);
  if (canceling) {
    me.editingPlugin.cancelEdit(me);
    if (remainVisible && store && store.isExpandingOrCollapsing) {
      me.cacheElement();
    }
  } else {
    me.editingPlugin.onEditComplete(me, me.getValue(), me.startValue);
  }
}, cacheElement:function(force) {
  if ((!this.editing || force) && !this.destroyed) {
    this.detachFromBody();
  }
}, onHide:function() {
  this.cacheElement(true);
  Ext.Editor.superclass.onHide.apply(this, arguments);
}, onSpecialKey:function(field, event, eOpts) {
  var me = this, key = event.getKey(), complete = me.completeOnEnter && key === event.ENTER && (!eOpts || !eOpts.fromBoundList), cancel = me.cancelOnEsc && key === event.ESC, view = me.editingPlugin.view;
  if (complete || cancel) {
    event.stopEvent();
    if (cancel) {
      me.focusLeaveAction = 'cancelEdit';
    }
    view.ownerGrid.setActionableMode(false);
  }
}, getRefOwner:function() {
  return this.column && this.column.getView();
}, restoreCell:function() {
  var me = this, innerCell = me.boundEl.dom.querySelector(me.context.view.innerSelector);
  if (innerCell) {
    if (me.isForTree) {
      innerCell = innerCell.querySelector(me.treeNodeSelector);
    }
    Ext.fly(innerCell).show();
  }
}, afterRender:function() {
  var me = this, field = me.field;
  Ext.Editor.prototype.afterRender.apply(this, arguments);
  if (field.isCheckbox) {
    field.mon(field.inputEl, {mousedown:me.onCheckBoxMouseDown, click:me.onCheckBoxClick, scope:me});
  }
}, onCheckBoxMouseDown:function() {
  this.completeEdit = Ext.emptyFn;
}, onCheckBoxClick:function() {
  delete this.completeEdit;
  this.field.focus(false, 10);
}, realign:function(autoSize) {
  var me = this, boundEl = me.boundEl, innerCell = boundEl.dom.querySelector(me.context.view.innerSelector), innerCellTextNode = innerCell.firstChild, width = boundEl.getWidth(), offsets = Ext.Array.clone(me.offsets), grid = me.grid, xOffset, v = '', isEmpty = !innerCellTextNode || innerCellTextNode.nodeType === 3 && !Ext.String.trim(v = innerCellTextNode.data).length;
  if (me.isForTree) {
    xOffset = me.getTreeNodeOffset(innerCell);
    width -= Math.abs(xOffset);
    offsets[0] += xOffset;
  }
  if (grid.columnLines) {
    width -= boundEl.getBorderWidth('rl');
  }
  if (autoSize === true) {
    me.field.setWidth(width);
  }
  if (isEmpty) {
    innerCell.innerHTML = 'X';
  }
  me.alignTo(boundEl, me.alignment, offsets);
  if (isEmpty) {
    innerCell.firstChild.data = v;
  }
}, getTreeNodeOffset:function(innerCell) {
  return Ext.fly(innerCell.querySelector(this.treeNodeSelector)).getOffsetsTo(innerCell)[0];
}}, 0, ['celleditor'], ['component', 'box', 'container', 'editor', 'celleditor'], {'component':true, 'box':true, 'container':true, 'editor':true, 'celleditor':true}, ['widget.celleditor'], 0, [Ext.grid, 'CellEditor'], 0);
Ext.cmd.derive('Ext.grid.ColumnComponentLayout', Ext.layout.component.Auto, {type:'columncomponent', setWidthInDom:true, _paddingReset:{paddingTop:'', paddingBottom:''}, columnAutoCls:'x-column-header-text-container-auto', beginLayout:function(ownerContext) {
  Ext.layout.component.Auto.prototype.beginLayout.apply(this, arguments);
  ownerContext.titleContext = ownerContext.getEl('titleEl');
}, beginLayoutCycle:function(ownerContext) {
  var me = this, owner = me.owner, shrinkWrap = ownerContext.widthModel.shrinkWrap;
  Ext.layout.component.Auto.prototype.beginLayoutCycle.apply(this, arguments);
  if (shrinkWrap) {
    owner.el.setWidth('');
  }
  owner.textContainerEl[shrinkWrap && !owner.isGroupHeader ? 'addCls' : 'removeCls'](me.columnAutoCls);
  owner.titleEl.setStyle(me._paddingReset);
}, publishInnerHeight:function(ownerContext, outerHeight) {
  var me = this, owner = me.owner, innerHeight;
  if (owner.getRootHeaderCt().hiddenHeaders) {
    ownerContext.setProp('innerHeight', 0);
    return;
  }
  if (!ownerContext.hasRawContent) {
    if (owner.headerWrap && !ownerContext.hasDomProp('width')) {
      me.done = false;
      return;
    }
    innerHeight = outerHeight - ownerContext.getBorderInfo().height;
    ownerContext.setProp('innerHeight', innerHeight - owner.titleEl.getHeight(), false);
  }
}, measureContentHeight:function(ownerContext) {
  return ownerContext.el.dom.offsetHeight;
}, publishInnerWidth:function(ownerContext, outerWidth) {
  if (!ownerContext.hasRawContent) {
    ownerContext.setProp('innerWidth', outerWidth - ownerContext.getBorderInfo().width, false);
  }
}, calculateOwnerHeightFromContentHeight:function(ownerContext, contentHeight) {
  var result = Ext.layout.component.Auto.prototype.calculateOwnerHeightFromContentHeight.apply(this, arguments), owner = this.owner;
  if (!ownerContext.hasRawContent) {
    if (!owner.headerWrap || ownerContext.hasDomProp('width')) {
      return contentHeight + owner.titleEl.getHeight() + ownerContext.getBorderInfo().height;
    }
    return null;
  }
  return result;
}, calculateOwnerWidthFromContentWidth:function(ownerContext, contentWidth) {
  var owner = this.owner, padWidth = ownerContext.getPaddingInfo().width, triggerOffset = this.getTriggerOffset(owner, ownerContext), inner;
  if (owner.isGroupHeader) {
    inner = contentWidth;
  } else {
    inner = Math.max(contentWidth, owner.textEl.getWidth() + ownerContext.titleContext.getPaddingInfo().width);
  }
  return inner + padWidth + triggerOffset;
}, getTriggerOffset:function(owner, ownerContext) {
  var width = 0;
  if (ownerContext.widthModel.shrinkWrap && !owner.menuDisabled) {
    if (owner.query('\x3e:not([hidden])').length === 0) {
      width = owner.getTriggerElWidth();
    }
  }
  return width;
}}, 0, 0, 0, 0, ['layout.columncomponent'], 0, [Ext.grid, 'ColumnComponentLayout'], 0);
Ext.cmd.derive('Ext.layout.container.Fit', Ext.layout.container.Container, {alternateClassName:['Ext.layout.FitLayout', 'Ext.layout.Fit'], itemCls:'x-fit-item', type:'fit', manageMargins:true, sizePolicies:[{readsWidth:1, readsHeight:1, setsWidth:0, setsHeight:0}, {readsWidth:0, readsHeight:1, setsWidth:1, setsHeight:0}, {readsWidth:1, readsHeight:0, setsWidth:0, setsHeight:1}, {readsWidth:0, readsHeight:0, setsWidth:1, setsHeight:1}], getItemSizePolicy:function(item, ownerSizeModel) {
  var sizeModel = ownerSizeModel || this.owner.getSizeModel(), mode = (sizeModel.width.shrinkWrap ? 0 : 1) | (sizeModel.height.shrinkWrap ? 0 : 2);
  return this.sizePolicies[mode];
}, beginLayoutCycle:function(ownerContext, firstCycle) {
  var me = this, resetHeight = me.lastHeightModel && me.lastHeightModel.calculated, resetWidth = me.lastWidthModel && me.lastWidthModel.calculated, resetSizes = resetWidth || resetHeight, maxChildMinHeight = 0, maxChildMinWidth = 0, c, childItems, i, item, length, margins, minHeight, minWidth, style, undef;
  Ext.layout.container.Container.prototype.beginLayoutCycle.apply(this, arguments);
  if (resetSizes && ownerContext.targetContext.el.dom.tagName.toUpperCase() !== 'TD') {
    resetSizes = resetWidth = resetHeight = false;
  }
  childItems = ownerContext.childItems;
  length = childItems.length;
  for (i = 0; i < length; ++i) {
    item = childItems[i];
    if (firstCycle) {
      c = item.target;
      minHeight = c.minHeight;
      minWidth = c.minWidth;
      if (minWidth || minHeight) {
        margins = item.marginInfo || item.getMarginInfo();
        minHeight += margins.height;
        minWidth += margins.height;
        if (maxChildMinHeight < minHeight) {
          maxChildMinHeight = minHeight;
        }
        if (maxChildMinWidth < minWidth) {
          maxChildMinWidth = minWidth;
        }
      }
    }
    if (resetSizes) {
      style = item.el.dom.style;
      if (resetHeight) {
        style.height = '';
      }
      if (resetWidth) {
        style.width = '';
      }
    }
  }
  if (firstCycle) {
    ownerContext.maxChildMinHeight = maxChildMinHeight;
    ownerContext.maxChildMinWidth = maxChildMinWidth;
  }
  c = ownerContext.target;
  ownerContext.overflowX = !ownerContext.widthModel.shrinkWrap && ownerContext.maxChildMinWidth && c.scrollFlags.x || undef;
  ownerContext.overflowY = !ownerContext.heightModel.shrinkWrap && ownerContext.maxChildMinHeight && c.scrollFlags.y || undef;
}, calculate:function(ownerContext) {
  var me = this, childItems = ownerContext.childItems, length = childItems.length, containerSize = me.getContainerSize(ownerContext), info = {length:length, ownerContext:ownerContext, targetSize:containerSize}, shrinkWrapWidth = ownerContext.widthModel.shrinkWrap, shrinkWrapHeight = ownerContext.heightModel.shrinkWrap, overflowX = ownerContext.overflowX, overflowY = ownerContext.overflowY, scrollbars, scrollbarSize, padding, i, contentWidth, contentHeight;
  ownerContext.state.info = info;
  if (overflowX || overflowY) {
    scrollbars = me.getScrollbarsNeeded(overflowX && containerSize.width, overflowY && containerSize.height, ownerContext.maxChildMinWidth, ownerContext.maxChildMinHeight);
    if (scrollbars) {
      scrollbarSize = Ext.getScrollbarSize();
      if (scrollbars & 1) {
        containerSize.height -= scrollbarSize.height;
      }
      if (scrollbars & 2) {
        containerSize.width -= scrollbarSize.width;
      }
    }
  }
  if (length > 0) {
    for (i = 0; i < length; ++i) {
      info.index = i;
      me.fitItem(childItems[i], info);
    }
  } else {
    info.contentWidth = info.contentHeight = 0;
  }
  if (shrinkWrapHeight || shrinkWrapWidth) {
    padding = ownerContext.targetContext.getPaddingInfo();
    if (shrinkWrapWidth) {
      if (overflowY && !containerSize.gotHeight) {
        me.done = false;
      } else {
        contentWidth = info.contentWidth + padding.width;
        if (scrollbars & 2) {
          contentWidth += scrollbarSize.width;
        }
        if (!ownerContext.setContentWidth(contentWidth)) {
          me.done = false;
        }
      }
    }
    if (shrinkWrapHeight) {
      if (overflowX && !containerSize.gotWidth) {
        me.done = false;
      } else {
        contentHeight = info.contentHeight + padding.height;
        if (scrollbars & 1) {
          contentHeight += scrollbarSize.height;
        }
        if (!ownerContext.setContentHeight(contentHeight)) {
          me.done = false;
        }
      }
    }
  }
}, fitItem:function(itemContext, info) {
  var me = this;
  if (itemContext.invalid) {
    me.done = false;
    return;
  }
  info.margins = itemContext.getMarginInfo();
  info.needed = info.got = 0;
  me.fitItemWidth(itemContext, info);
  me.fitItemHeight(itemContext, info);
  if (info.got !== info.needed) {
    me.done = false;
  }
}, fitItemWidth:function(itemContext, info) {
  var contentWidth, width;
  if (info.ownerContext.widthModel.shrinkWrap) {
    width = itemContext.getProp('width') + info.margins.width;
    contentWidth = info.contentWidth;
    if (contentWidth === undefined) {
      info.contentWidth = width;
    } else {
      info.contentWidth = Math.max(contentWidth, width);
    }
  } else {
    if (itemContext.widthModel.calculated) {
      ++info.needed;
      if (info.targetSize.gotWidth) {
        ++info.got;
        this.setItemWidth(itemContext, info);
      } else {
        return;
      }
    }
  }
  this.positionItemX(itemContext, info);
}, fitItemHeight:function(itemContext, info) {
  var contentHeight, height;
  if (info.ownerContext.heightModel.shrinkWrap) {
    height = itemContext.getProp('height') + info.margins.height;
    contentHeight = info.contentHeight;
    if (contentHeight === undefined) {
      info.contentHeight = height;
    } else {
      info.contentHeight = Math.max(contentHeight, height);
    }
  } else {
    if (itemContext.heightModel.calculated) {
      ++info.needed;
      if (info.targetSize.gotHeight) {
        ++info.got;
        this.setItemHeight(itemContext, info);
      } else {
        return;
      }
    }
  }
  this.positionItemY(itemContext, info);
}, positionItemX:function(itemContext, info) {
  var margins = info.margins;
  if (info.index || margins.left) {
    itemContext.setProp('x', margins.left);
  }
  if (margins.width && info.ownerContext.widthModel.shrinkWrap) {
    itemContext.setProp('margin-right', margins.width);
  }
}, positionItemY:function(itemContext, info) {
  var margins = info.margins;
  if (info.index || margins.top) {
    itemContext.setProp('y', margins.top);
  }
  if (margins.height && info.ownerContext.heightModel.shrinkWrap) {
    itemContext.setProp('margin-bottom', margins.height);
  }
}, setItemHeight:function(itemContext, info) {
  itemContext.setHeight(info.targetSize.height - info.margins.height);
}, setItemWidth:function(itemContext, info) {
  itemContext.setWidth(info.targetSize.width - info.margins.width);
}}, 0, 0, 0, 0, ['layout.fit'], 0, [Ext.layout.container, 'Fit', Ext.layout, 'FitLayout', Ext.layout, 'Fit'], 0);
Ext.cmd.derive('Ext.panel.Table', Ext.panel.Panel, {extraBaseCls:'x-grid', extraBodyCls:'x-grid-body', actionableModeCls:'x-grid-actionable', noHeaderBordersCls:'x-no-header-borders', defaultBindProperty:'store', layout:'fit', manageLayoutScroll:false, ariaRole:'presentation', config:{focused:null, headerBorders:true, hideHeaders:null}, publishes:['selection'], twoWayBindable:['selection'], selection:null, autoLoad:false, variableRowHeight:false, numFromEdge:2, trailingBufferZone:10, leadingBufferZone:20, 
hasView:false, viewType:null, deferRowRender:false, sortableColumns:true, multiColumnSort:false, enableLocking:false, scrollerOwner:true, enableColumnMove:true, sealedColumns:false, enableColumnResize:true, columnLines:false, rowLines:true, bufferedRenderer:true, preciseHeight:false, ownerGrid:null, colLinesCls:'x-grid-with-col-lines', rowLinesCls:'x-grid-with-row-lines', noRowLinesCls:'x-grid-no-row-lines', hiddenHeaderCtCls:'x-grid-header-ct-hidden', hiddenHeaderCls:'x-grid-header-hidden', resizeMarkerCls:'x-grid-resize-marker', 
emptyCls:'x-grid-empty', focusable:true, constructor:function(config) {
  var me = this, topGrid = config && config.ownerGrid, store;
  me.ownerGrid = topGrid || me;
  me.actionables = topGrid ? topGrid.actionables : [];
  Ext.panel.Panel.prototype.constructor.call(this, config);
  store = me.store;
  store.trackStateChanges = true;
  if (me.autoLoad) {
    if (!store.isEmptyStore) {
      store.load();
    }
  }
}, registerActionable:function(actionable) {
  Ext.Array.include(this.actionables, actionable);
}, initComponent:function() {
  var me = this, columns = me.columns || me.colModel || [], selection = me.selection, store, view, i, len, bufferedRenderer, headerCtCfg, headerCt;
  if (selection) {
    me.selection = null;
    me.setSelection(selection);
  }
  store = me.store;
  if (store && Ext.isObject(store) && !store.isStore && !store.storeId) {
    store = Ext.apply({autoDestroy:true}, store);
  }
  store = me.store = Ext.data.StoreManager.lookup(store || 'ext-empty-store');
  me.enableLocking = me.enableLocking || me.hasLockedColumns(columns);
  if (me.plugins) {
    me.plugins = me.constructPlugins();
  }
  if (me.columnLines) {
    me.addBodyCls(me.colLinesCls);
  }
  me.addBodyCls(me.rowLines ? me.rowLinesCls : me.noRowLinesCls);
  me.addBodyCls(me.extraBodyCls);
  if (me.enableLocking) {
    if (!me.mixins.lockable) {
      me.self.mixin('lockable', Ext.grid.locking.Lockable);
    }
    me.injectLockable();
  } else {
    if (columns.isRootHeader) {
      me.headerCt = headerCt = columns;
      headerCt.grid = me;
      headerCt.forceFit = !!me.forceFit;
      columns = [];
      me.columnManager = headerCt.columnManager;
      me.visibleColumnManager = headerCt.visibleColumnManager;
    } else {
      headerCtCfg = {grid:me, $initParent:me, forceFit:me.forceFit, sortable:me.sortableColumns, enableColumnMove:me.enableColumnMove, enableColumnResize:me.enableColumnResize, columnLines:me.columnLines, sealed:me.sealedColumns};
      if (Ext.isObject(columns)) {
        Ext.apply(headerCtCfg, columns);
        columns = columns.items;
        delete headerCtCfg.items;
      }
      me.headerCt = headerCt = new Ext.grid.header.Container(headerCtCfg);
    }
    if (Ext.isDefined(me.enableColumnHide)) {
      headerCt.enableColumnHide = me.enableColumnHide;
    }
  }
  me.scrollTask = new Ext.util.DelayedTask(me.syncHorizontalScroll, me);
  me.cls = (me.cls || '') + (' ' + me.extraBaseCls);
  delete me.autoScroll;
  bufferedRenderer = me.plugins && Ext.Array.findBy(me.plugins, function(p) {
    return p.isBufferedRenderer;
  });
  if (bufferedRenderer) {
    me.bufferedRenderer = bufferedRenderer;
  }
  if (!me.hasView) {
    if (store.isBufferedStore && !store.getRemoteSort()) {
      for (i = 0, len = columns.length; i < len; i++) {
        columns[i].sortable = false;
      }
    }
    me.relayHeaderCtEvents(headerCt);
    me.features = me.features || [];
    if (!Ext.isArray(me.features)) {
      me.features = [me.features];
    }
    me.viewConfig = me.viewConfig || {};
    view = me.getView();
    me.items = [view];
    me.hasView = true;
    me.bindStore(store, true);
    me.mon(view, {viewready:me.onViewReady, refresh:me.onRestoreHorzScroll, scope:me});
  }
  me.selModel = me.view.getSelectionModel();
  me.selModel.on({scope:me, lastselectedchanged:me.updateBindSelection, selectionchange:me.updateBindSelection});
  me.relayEvents(me.view, ['beforeitemlongpress', 'beforeitemmousedown', 'beforeitemmouseup', 'beforeitemmouseenter', 'beforeitemmouseleave', 'beforeitemclick', 'beforeitemdblclick', 'beforeitemcontextmenu', 'itemlongpress', 'itemmousedown', 'itemmouseup', 'itemmouseenter', 'itemmouseleave', 'itemclick', 'itemdblclick', 'itemcontextmenu', 'beforecellclick', 'cellclick', 'beforecelldblclick', 'celldblclick', 'beforecellcontextmenu', 'cellcontextmenu', 'beforecellmousedown', 'cellmousedown', 'beforecellmouseup', 
  'cellmouseup', 'beforecellkeydown', 'cellkeydown', 'rowclick', 'rowdblclick', 'rowcontextmenu', 'rowmousedown', 'rowmouseup', 'rowkeydown', 'beforeitemkeydown', 'itemkeydown', 'beforeitemkeyup', 'itemkeyup', 'beforeitemkeypress', 'itemkeypress', 'beforecontainermousedown', 'beforecontainermouseup', 'beforecontainermouseover', 'beforecontainermouseout', 'beforecontainerclick', 'beforecontainerdblclick', 'beforecontainercontextmenu', 'beforecontainerkeydown', 'beforecontainerkeyup', 'beforecontainerkeypress', 
  'containermouseup', 'containermousedown', 'containermouseover', 'containermouseout', 'containerclick', 'containerdblclick', 'containercontextmenu', 'containerkeydown', 'containerkeyup', 'containerkeypress', 'beforeselect', 'select', 'beforedeselect', 'deselect', 'beforerowexit']);
  if (!me.selModel.isSpreadsheetModel) {
    me.relayEvents(me.view, ['selectionchange']);
  }
  if (headerCt) {
    headerCt.view = me.view;
    (me.dockedItems = Ext.Array.from(me.dockedItems, true)).unshift(headerCt);
    headerCt.add(columns);
  }
  me.columns = me.headerCt.getGridColumns();
  Ext.panel.Panel.prototype.initComponent.call(this);
  me.syncHeaderVisibility();
  if (me.enableLocking) {
    me.afterInjectLockable();
  }
  me.addStateEvents(['columnresize', 'columnmove', 'columnhide', 'columnshow', 'sortchange', 'filteractivate', 'filterdeactivate', 'filterchange', 'groupchange']);
}, updateHideHeaders:function(hideHeaders) {
  if (!this.isConfiguring) {
    this.syncHeaderVisibility();
  }
}, beforeRender:function() {
  var me = this, bufferedRenderer = me.bufferedRenderer, ariaAttr;
  if (me.lockable) {
    me.getProtoBody().addCls(me.lockingBodyCls);
  } else {
    if (bufferedRenderer && me.getSizeModel().height.auto) {
      me.bufferedRenderer = bufferedRenderer = false;
    }
    if (bufferedRenderer && !bufferedRenderer.isBufferedRenderer) {
      bufferedRenderer = {xclass:'Ext.grid.plugin.BufferedRenderer'};
      Ext.copy(bufferedRenderer, me, 'variableRowHeight,numFromEdge,trailingBufferZone,leadingBufferZone,scrollToLoadBuffer', true);
      me.bufferedRenderer = me.addPlugin(bufferedRenderer);
    }
    ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
    ariaAttr['aria-readonly'] = !me.isEditable;
    ariaAttr['aria-multiselectable'] = me.selModel.selectionMode !== 'SINGLE';
  }
  Ext.panel.Panel.prototype.beforeRender.apply(this, arguments);
}, beforeLayout:function() {
  var lockable = this.mixins.lockable;
  if (lockable) {
    lockable.beforeLayout.call(this);
  }
  Ext.panel.Panel.prototype.beforeLayout.call(this);
}, onHide:function(animateTarget, cb, scope) {
  this.getView().onOwnerGridHide();
  Ext.panel.Panel.prototype.onHide.call(this, animateTarget, cb, scope);
}, onShow:function() {
  Ext.panel.Panel.prototype.onShow.call(this);
  this.getView().onOwnerGridShow();
}, getHeaderContainer:function() {
  return this.getView().getHeaderCt();
}, getColumns:function() {
  return this.getColumnManager().getColumns();
}, getVisibleColumns:function() {
  return this.getVisibleColumnManager().getColumns();
}, getScrollable:function() {
  return this.scrollable || this.view.getScrollable();
}, focus:function() {
  this.getView().focus();
}, disableColumnHeaders:function() {
  this.headerCt.disable();
}, enableColumnHeaders:function() {
  this.headerCt.enable();
}, hasLockedColumns:function(columns) {
  var i, len, column;
  if (columns.isRootHeader) {
    columns = columns.items.items;
  } else {
    if (Ext.isObject(columns)) {
      columns = columns.items;
    }
  }
  for (i = 0, len = columns.length; i < len; i++) {
    column = columns[i];
    if (!column.processed && column.locked) {
      return true;
    }
  }
}, relayHeaderCtEvents:function(headerCt) {
  this.relayEvents(headerCt, ['columnresize', 'columnmove', 'columnhide', 'columnshow', 'columnschanged', 'sortchange', 'headerclick', 'headercontextmenu', 'headertriggerclick']);
}, getState:function() {
  var me = this, state = Ext.panel.Panel.prototype.getState.call(this), storeState = me.store.getState();
  state = me.addPropertyToState(state, 'columns', me.headerCt.getColumnsState());
  if (storeState) {
    state.storeState = storeState;
  }
  return state;
}, applyState:function(state) {
  var me = this, sorter = state.sort, storeState = state.storeState, store = me.store, columns = state.columns = me.buildColumnHash(state.columns), bind, boundStore;
  Ext.panel.Panel.prototype.applyState.apply(this, arguments);
  if (columns) {
    me.headerCt.applyColumnsState(columns, storeState);
  }
  if (sorter) {
    if (store.getRemoteSort()) {
      store.sort({property:sorter.property, direction:sorter.direction, root:sorter.root}, null, false);
    } else {
      store.sort(sorter.property, sorter.direction);
    }
  } else {
    if (storeState) {
      bind = this.getBind();
      boundStore = bind && bind.store;
      if (boundStore && boundStore.isBinding) {
        me.getViewModel().bind('{' + boundStore.stub.path + '}', function(store) {
          store.applyState(storeState);
        }, this, {single:true});
      } else {
        store.applyState(storeState);
      }
    }
  }
}, buildColumnHash:function(columns) {
  var len, columnState, i, result;
  if (columns) {
    result = {};
    for (i = 0, len = columns.length; i < len; i++) {
      columnState = columns[i];
      columnState.index = i;
      if (columnState.columns) {
        columnState.columns = this.buildColumnHash(columnState.columns);
      }
      result[columnState.id] = columnState;
    }
    return result;
  }
}, getStore:function() {
  return this.store;
}, onViewRefresh:function(view, records) {
  this.onItemAdd(records, 0);
}, onItemAdd:function(records, index, nodes, view) {
  var me = this, recCount = records.length, freeRowContexts = me.freeRowContexts, liveRowContexts = me.liveRowContexts || (me.liveRowContexts = {}), rowContext, i, record;
  for (i = 0; i < recCount; i++) {
    record = records[i];
    if (!liveRowContexts[record.internalId]) {
      rowContext = freeRowContexts && freeRowContexts.shift();
      if (!rowContext) {
        rowContext = new Ext.grid.RowContext({ownerGrid:me});
      }
      me.liveRowContexts[record.internalId] = rowContext;
      rowContext.setRecord(record, index++);
    }
  }
}, onItemRemove:function(records, index, nodes, view) {
  var me = this, freeRowContexts = me.freeRowContexts || (me.freeRowContexts = []), liveRowContexts = me.liveRowContexts, len = nodes.length, i, id, context;
  for (i = 0; i < len; i++) {
    id = nodes[i].getAttribute('data-recordId');
    context = liveRowContexts[id];
    if (context) {
      context.free(view);
      freeRowContexts.push(context);
      delete liveRowContexts[id];
    }
  }
}, createManagedWidget:function(view, ownerId, widgetConfig, record) {
  return this.liveRowContexts[record.internalId].getWidget(view, ownerId, widgetConfig);
}, destroyManagedWidgets:function(ownerId) {
  var me = this, contexts = me.liveRowContexts, freeRowContexts = me.freeRowContexts, len = freeRowContexts && freeRowContexts.length, i, recInternalId, rowWidgets;
  for (recInternalId in contexts) {
    rowWidgets = contexts[recInternalId].widgets;
    if (rowWidgets) {
      Ext.destroy(rowWidgets[ownerId]);
      delete rowWidgets[ownerId];
    }
  }
  for (i = 0; i < len; i++) {
    rowWidgets = freeRowContexts[i].widgets;
    if (rowWidgets) {
      Ext.destroy(rowWidgets[ownerId]);
      delete rowWidgets[ownerId];
    }
  }
}, getManagedWidgets:function(ownerId) {
  var me = this, contexts = me.liveRowContexts, recInternalId, result = [];
  for (recInternalId in contexts) {
    result.push(contexts[recInternalId].widgets[ownerId]);
  }
  return result;
}, getView:function() {
  var me = this, scroll, scrollable, viewConfig;
  if (!me.view) {
    viewConfig = me.viewConfig;
    scroll = viewConfig.scroll || me.scroll;
    scrollable = me.scrollable;
    if (scrollable == null && viewConfig.scrollable == null && scroll !== null) {
      if (scroll === true || scroll === 'both') {
        scrollable = true;
      } else {
        if (scroll === false || scroll === 'none') {
          scrollable = false;
        } else {
          if (scroll === 'vertical') {
            scrollable = {x:false, y:true};
          } else {
            if (scroll === 'horizontal') {
              scrollable = {x:true, y:false};
            }
          }
        }
      }
    }
    viewConfig = Ext.apply({grid:me, ownerGrid:me.ownerGrid, deferInitialRefresh:me.deferRowRender, variableRowHeight:me.variableRowHeight, preserveScrollOnRefresh:true, trackOver:me.trackMouseOver !== false, throttledUpdate:me.throttledUpdate === true, xtype:me.viewType, store:me.store, headerCt:me.headerCt, columnLines:me.columnLines, rowLines:me.rowLines, navigationModel:'grid', features:me.features, panel:me, emptyText:me.emptyText || ''}, me.viewConfig);
    if (!('scrollable' in viewConfig || 'scroll' in viewConfig || 'autoScroll' in viewConfig) && scrollable != null) {
      viewConfig.scrollable = scrollable;
    }
    viewConfig.$initParent = me;
    Ext.create(viewConfig);
    delete viewConfig.$initParent;
    if (me.view.emptyText) {
      me.view.emptyText = '\x3cdiv class\x3d"' + me.emptyCls + '"\x3e' + me.view.emptyText + '\x3c/div\x3e';
    }
    me.view.getComponentLayout().headerCt = me.headerCt;
    me.mon(me.view, {uievent:me.processEvent, scope:me});
    if (me.hasListeners.viewcreated) {
      me.fireEvent('viewcreated', me, me.view);
    }
  }
  return me.view;
}, getEmptyText:function() {
  return this.view.emptyText;
}, setEmptyText:function(emptyText) {
  this.emptyText = emptyText;
  this.view.setEmptyText('\x3cdiv class\x3d"' + this.emptyCls + '"\x3e' + emptyText + '\x3c/div\x3e');
  return this;
}, getColumnManager:function() {
  return this.columnManager;
}, getVisibleColumnManager:function() {
  return this.visibleColumnManager;
}, getTopLevelColumnManager:function() {
  return this.ownerGrid.getColumnManager();
}, getTopLevelVisibleColumnManager:function() {
  return this.ownerGrid.getVisibleColumnManager();
}, setAutoScroll:Ext.emptyFn, applyScrollable:function(scrollable) {
  var view = this.view;
  view = view && (view.normalView || view);
  if (view) {
    view.setScrollable(scrollable);
  }
  return scrollable;
}, processEvent:function(type, view, cell, recordIndex, cellIndex, e, record, row) {
  var header = e.position.column;
  if (header) {
    return header.processEvent.apply(header, arguments);
  }
}, ensureVisible:function(record, options) {
  this.doEnsureVisible(record, options);
}, scrollByDeltaY:function(yDelta, animate) {
  this.getView().scrollBy(null, yDelta, animate);
}, scrollByDeltaX:function(xDelta, animate) {
  this.getView().scrollBy(xDelta, null, animate);
}, afterCollapse:function() {
  this.saveScrollPos();
  Ext.panel.Panel.prototype.afterCollapse.apply(this, arguments);
}, afterExpand:function() {
  Ext.panel.Panel.prototype.afterExpand.apply(this, arguments);
  this.restoreScrollPos();
}, saveScrollPos:Ext.emptyFn, restoreScrollPos:Ext.emptyFn, onHeaderResize:Ext.emptyFn, onHeaderMove:function(headerCt, header, colsToMove, fromIdx, toIdx) {
  var me = this;
  if (me.optimizedColumnMove === false) {
    me.view.refreshView();
  } else {
    me.view.moveColumn(fromIdx, toIdx, colsToMove);
  }
  me.delayScroll();
}, onHeaderHide:function(headerCt, header) {
  var view = this.view;
  if (!headerCt.childHideCount && view.refreshCounter) {
    view.refreshView();
  }
}, onHeaderShow:function(headerCt, header) {
  var view = this.view;
  if (view.refreshCounter) {
    view.refreshView();
  }
}, onHeadersChanged:function(headerCt, header) {
  var me = this;
  if (me.rendered && !me.reconfiguring) {
    me.view.refreshView();
    me.delayScroll();
  }
}, delayScroll:function() {
  var target = this.view;
  if (target) {
    this.scrollTask.delay(10, null, null, [target]);
  }
}, onViewReady:function() {
  this.fireEvent('viewready', this);
}, onRestoreHorzScroll:function() {
  var me = this, x = me.scrollXPos;
  if (x) {
    me.syncHorizontalScroll(me, true);
  }
}, getScrollerOwner:function() {
  var rootCmp = this;
  if (!this.scrollerOwner) {
    rootCmp = this.up('[scrollerOwner]');
  }
  return rootCmp;
}, getLhsMarker:function() {
  var me = this;
  return me.lhsMarker || (me.lhsMarker = Ext.DomHelper.append(me.el, {role:'presentation', cls:me.resizeMarkerCls}, true));
}, getRhsMarker:function() {
  var me = this;
  return me.rhsMarker || (me.rhsMarker = Ext.DomHelper.append(me.el, {role:'presentation', cls:me.resizeMarkerCls}, true));
}, getSelection:function() {
  return this.getSelectionModel().getSelection();
}, setSelection:function(selection) {
  var current = this.selection;
  if (selection !== current) {
    this.selection = selection;
    this.updateSelection(selection, current);
  }
}, updateSelection:function(selection) {
  var me = this, sm;
  if (!me.ignoreNextSelection) {
    me.ignoreNextSelection = true;
    sm = me.getSelectionModel();
    if (selection) {
      sm.select(selection);
    } else {
      sm.deselectAll();
    }
    me.ignoreNextSelection = false;
  }
  me.publishState('selection', selection);
}, updateBindSelection:function(selModel, selection) {
  var me = this, selected = null;
  if (!me.ignoreNextSelection) {
    me.ignoreNextSelection = true;
    if (selection.length) {
      selected = selModel.getLastSelected();
      me.hasHadSelection = true;
    }
    if (me.hasHadSelection) {
      me.setSelection(selected);
    }
    me.ignoreNextSelection = false;
  }
}, updateFocused:function(record) {
  this.getNavigationModel().setPosition(record);
}, updateHeaderBorders:function(headerBorders) {
  this[headerBorders ? 'removeCls' : 'addCls'](this.noHeaderBordersCls);
}, getNavigationModel:function() {
  return this.getView().getNavigationModel();
}, getSelectionModel:function() {
  return this.getView().getSelectionModel();
}, getScrollTarget:function() {
  var items = this.getScrollerOwner().query('tableview');
  return items[items.length - 1];
}, syncHorizontalScroll:function(target, setBody) {
  var me = this, x = me.view.getScrollX(), scrollTarget;
  setBody = setBody === true;
  if (me.rendered && (setBody || x !== me.scrollXPos)) {
    if (setBody) {
      scrollTarget = me.getScrollTarget();
      scrollTarget.setScrollX(x);
    }
    me.headerCt.setScrollX(x);
    me.scrollXPos = x;
  }
}, onStoreLoad:Ext.emptyFn, getEditorParent:function() {
  return this.body;
}, bindStore:function(store, initial) {
  var me = this, view = me.getView(), oldStore = me.getStore();
  if (store) {
    me.store = store;
    if (view.store !== store) {
      view.bindStore(store, false);
    }
    me.mon(store, {load:me.onStoreLoad, scope:me});
    me.storeRelayers = me.relayEvents(store, ['filterchange', 'groupchange']);
    if (!me.reconfiguring && me.hasListeners.storechange && store !== oldStore) {
      me.fireEvent('storechange', me, store, oldStore);
    }
  } else {
    me.unbindStore();
  }
}, unbindStore:function() {
  var me = this, store = me.store, view;
  if (store) {
    store.trackStateChanges = false;
    me.store = null;
    me.mun(store, {load:me.onStoreLoad, scope:me});
    Ext.destroy(me.storeRelayers);
    view = me.view;
    if (view.store) {
      view.bindStore(null);
    } else {
      if (!store.destroyed && store.autoDestroy) {
        store.destroy();
      }
    }
    if (!me.reconfiguring && me.hasListeners.storechange) {
      me.fireEvent('storechange', me, null, store);
    }
  }
}, setColumns:function(columns) {
  if (columns.length || this.getColumnManager().getColumns().length) {
    this.reconfigure(undefined, columns);
  }
}, setStore:function(store) {
  var me = this;
  me.reconfigure(store, undefined, true);
  if (me.isVisible(true)) {
    if (store && me.autoLoad && !store.isEmptyStore && !(store.loading || store.isLoaded())) {
      store.load();
    }
  } else {
    if (!me.globalShowListener) {
      me.globalShowListener = Ext.GlobalEvents.on({show:me.onGlobalShow, scope:me, destroyable:true});
    }
  }
}, onGlobalShow:function(comp) {
  var me = this, store = me.store;
  if (comp === me || comp.isAncestor(me) && me.isVisible(true)) {
    if (store && me.autoLoad && !store.isEmptyStore && !(store.loading || store.isLoaded())) {
      store.load();
    }
    Ext.destroy(me.globalShowListener);
  }
}, reconfigure:function(store, columns, allowUnbind) {
  var me = this, oldStore = me.store, headerCt = me.headerCt, lockable = me.lockable, oldColumns = headerCt ? headerCt.items.getRange() : me.columns, view = me.getView(), scroller, block, refreshCounter, storeChanged, columnsChanged, restoreFocus;
  if (arguments.length === 1 && Ext.isArray(store)) {
    columns = store;
    store = null;
  }
  if (columns) {
    columns = Ext.Array.slice(columns);
  }
  me.reconfiguring = true;
  if (store) {
    store = Ext.StoreManager.lookup(store);
    storeChanged = store && store !== oldStore;
  } else {
    if (allowUnbind) {
      store = Ext.StoreManager.lookup('ext-empty-store');
      storeChanged = store !== oldStore;
    }
  }
  me.fireEvent('beforereconfigure', me, store, columns, oldStore, oldColumns);
  Ext.suspendLayouts();
  if (me.rendered && me.layoutCounter && (scroller = me.getScrollable())) {
    scroller.scrollTo(0, 0);
  }
  if (lockable) {
    me.reconfigureLockable(store, columns, allowUnbind);
  } else {
    block = view.blockRefresh;
    view.blockRefresh = true;
    restoreFocus = view.saveFocusState();
    if (storeChanged) {
      me.unbindStore();
      me.bindStore(store);
    }
    if (columns) {
      delete me.scrollXPos;
      headerCt.removeAll();
      headerCt.add(columns);
      columnsChanged = true;
    }
    headerCt.onOwnerGridReconfigure(storeChanged, columnsChanged);
    refreshCounter = view.refreshCounter;
  }
  Ext.resumeLayouts(true);
  me.reconfiguring = false;
  if (lockable) {
    me.afterReconfigureLockable();
  } else {
    view.blockRefresh = block;
    if (view.refreshCounter === refreshCounter) {
      view.refreshView();
      restoreFocus();
    }
  }
  me.fireEvent('reconfigure', me, store, columns, oldStore, oldColumns);
  delete me.reconfiguring;
  if (storeChanged) {
    me.fireEvent('storechange', me, store, oldStore);
    if (!oldStore.destroyed && oldStore.autoDestroy) {
      oldStore.destroy();
    }
  }
}, doDestroy:function() {
  var me = this, task = me.scrollTask, view = me.view;
  if (view) {
    view.destroying = true;
  }
  if (me.lockable) {
    me.destroyLockable();
  }
  if (task) {
    task.cancel();
  }
  Ext.destroy(me.rowContextParent, me.plugins, me.focusEnterLeaveListeners, me.freeRowContents, Ext.Object.getValues(me.liveRowContexts), me.lhsMarker, me.rhsMarker);
  Ext.panel.Panel.prototype.doDestroy.call(this);
  me.unbindStore();
}, getElementHeight:function(el) {
  var rect = this.preciseHeight && el.getBoundingClientRect();
  return rect ? rect.height || rect.bottom - rect.top : el.offsetHeight;
}, getElementSize:function(el) {
  var rect = this.preciseHeight && el.getBoundingClientRect();
  return {width:rect ? rect.width || rect.right - rect.left : el.offsetWidth, height:rect ? rect.height || rect.bottom - rect.top : el.offsetHeight};
}, privates:{initFocusableElement:function() {
}, doEnsureVisible:function(record, options) {
  if (this.lockable) {
    return this.ensureLockedVisible(record, options);
  }
  if (typeof record !== 'number' && !record.isEntity) {
    record = this.store.getById(record);
  }
  var me = this, view = me.getView(), domNode = view.getNode(record), isLocking = me.ownerGrid.lockable, callback, scope, animate, highlight, select, doFocus, verticalScroller, column, cell, targetContext, internalCallback, scrollPromise;
  if (options) {
    callback = options.callback;
    scope = options.scope;
    animate = options.animate;
    highlight = options.highlight;
    select = options.select;
    doFocus = options.focus;
    column = options.column;
  }
  if (me.deferredEnsureVisible) {
    me.deferredEnsureVisible.destroy();
  }
  if (!view.componentLayoutCounter) {
    me.deferredEnsureVisible = view.on({resize:me.doEnsureVisible, args:Ext.Array.slice(arguments), scope:me, single:true, destroyable:true});
    return;
  }
  if (typeof column === 'number') {
    column = me.ownerGrid.getVisibleColumnManager().getColumns()[column];
  }
  if (domNode) {
    if (!record.isEntity) {
      record = view.getRecord(domNode);
    }
    verticalScroller = isLocking ? me.ownerGrid.getScrollable() : view.getScrollable();
    if (callback || select || doFocus) {
      internalCallback = function() {
        targetContext = (new Ext.grid.CellContext(view)).setPosition(record, column || 0);
        if (select) {
          view.getSelectionModel().selectByPosition(targetContext);
        }
        if (doFocus) {
          view.getNavigationModel().setPosition(targetContext);
        }
        Ext.callback(callback, scope || me, [true, record, domNode]);
      };
    }
    if (verticalScroller) {
      if (column) {
        cell = Ext.fly(domNode).selectNode(column.getCellSelector());
      }
      if (isLocking && column) {
        verticalScroller.ensureVisible(domNode, {x:false});
        scrollPromise = view.getScrollable().ensureVisible(cell || domNode, {animation:animate, highlight:highlight});
      } else {
        scrollPromise = verticalScroller.ensureVisible(cell || domNode, {animation:animate, highlight:highlight, x:!!column});
      }
      if (scrollPromise && internalCallback) {
        scrollPromise.then(internalCallback);
      }
    }
  } else {
    if (view.bufferedRenderer) {
      view.bufferedRenderer.scrollTo(record, {animate:animate, highlight:highlight, select:select, focus:doFocus, column:column, callback:function(recordIdx, record, domNode) {
        Ext.callback(callback, scope || me, [true, record, domNode]);
      }});
    } else {
      Ext.callback(callback, scope || me, [false, null]);
    }
  }
}, getFocusEl:function() {
  return this.getView().getFocusEl();
}, getRowContextViewModelParent:function() {
  var vm = this.lookupViewModel() || this.rowContextParent;
  if (!vm) {
    this.rowContextParent = vm = new Ext.app.ViewModel;
  }
  return vm;
}, handleWidgetViewChange:function(view, ownerId) {
  var contexts = this.liveRowContexts, freeRowContexts = this.freeRowContexts, len = freeRowContexts && freeRowContexts.length, i, recInternalId;
  for (recInternalId in contexts) {
    contexts[recInternalId].handleWidgetViewChange(view, ownerId);
  }
  for (i = 0; i < len; i++) {
    freeRowContexts[i].handleWidgetViewChange(view, ownerId);
  }
}, initInheritedState:function(inheritedState, inheritedStateInner) {
  inheritedState.inLockedGrid = !!this.isLocked;
  Ext.panel.Panel.prototype.initInheritedState.call(this, inheritedState, inheritedStateInner);
}, setActionableMode:function(enabled, position) {
  var me = this.ownerGrid;
  if (!me.destroying && me.view.setActionableMode(enabled, position) !== false) {
    me.fireEvent('actionablemodechange', enabled);
    me[enabled ? 'addCls' : 'removeCls'](me.actionableModeCls);
    return true;
  }
}, getOverflowStyle:function() {
  this.scrollFlags = this._scrollFlags['false']['false'];
  return {overflowX:'hidden', overflowY:'hidden'};
}, getOverflowEl:function() {
  return null;
}, shouldAutoHideHeaders:function() {
  var me = this, columns = me.headerCt.items.items, len = columns.length, autoHideHeaders = !!len, column, i;
  for (i = 0; autoHideHeaders && i < len; i++) {
    column = columns[i];
    if (!column.isEmptyText(column.text, true) || column.columns || column.isGroupHeader && column.items.items.length) {
      autoHideHeaders = false;
    }
  }
  return autoHideHeaders;
}, syncHeaderVisibility:function() {
  var me = this, headerCt = me.headerCt, hideHeaders = me.hideHeaders, viewScroller, currentHideHeaderState;
  if (me.lockable) {
    me.syncLockableHeaderVisibility();
    return;
  }
  if (hideHeaders == null) {
    hideHeaders = me.shouldAutoHideHeaders();
  }
  currentHideHeaderState = headerCt.height === 0;
  if (!headerCt.rendered || hideHeaders !== currentHideHeaderState) {
    headerCt.setHeight(hideHeaders ? 0 : null);
    headerCt.hiddenHeaders = hideHeaders;
    headerCt.toggleCls(me.hiddenHeaderCtCls, hideHeaders);
    me.toggleCls(me.hiddenHeaderCls, hideHeaders);
    if (!hideHeaders) {
      headerCt.setScrollable({x:false, y:false});
      viewScroller = me.view.getScrollable();
      if (viewScroller) {
        headerCt.getScrollable().addPartner(viewScroller, 'x');
      }
    }
  }
}}}, 1, ['tablepanel'], ['component', 'box', 'container', 'panel', 'tablepanel'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true}, ['widget.tablepanel'], 0, [Ext.panel, 'Table'], 0);
Ext.define('Ext.theme.neptune.panel.Table', {override:'Ext.panel.Table', lockableBodyBorder:true, initComponent:function() {
  var me = this;
  (arguments.callee.$previous || Ext.panel.Panel.prototype.initComponent).call(this);
  if (!me.hasOwnProperty('bodyBorder') && !me.hideHeaders && (me.lockableBodyBorder || !me.lockable)) {
    me.bodyBorder = true;
  }
}});
Ext.cmd.derive('Ext.grid.ColumnLayout', Ext.layout.container.HBox, {type:'gridcolumn', firstHeaderCls:'x-column-header-first', lastHeaderCls:'x-column-header-last', initLayout:function() {
  Ext.layout.container.HBox.prototype.initLayout.call(this);
  if (this.scrollbarWidth === undefined) {
    this.self.prototype.scrollbarWidth = Ext.getScrollbarSize().width;
  }
}, beginLayout:function(ownerContext) {
  var me = this, owner = me.owner, firstCls = me.firstHeaderCls, lastCls = me.lastHeaderCls, bothCls = [firstCls, lastCls], items = me.getVisibleItems(), len = items.length, i, item;
  Ext.layout.container.HBox.prototype.beginLayout.call(this, ownerContext);
  for (i = 0; i < len; i++) {
    item = items[i];
    if (len === 1) {
      item.addCls(bothCls);
    } else {
      if (i === 0) {
        item.addCls(firstCls);
        item.removeCls(lastCls);
      } else {
        if (i === len - 1) {
          item.removeCls(firstCls);
          item.addCls(lastCls);
        } else {
          item.removeCls(bothCls);
        }
      }
    }
  }
  me.scrollbarWidth = 0;
  if (owner.isRootHeader && !owner.grid.isLocked) {
    me.determineScrollbarWidth(ownerContext);
  }
  if (!me.scrollbarWidth) {
    ownerContext.manageScrollbar = false;
  }
}, moveItemBefore:function(item, before) {
  var prevOwner = item.ownerCt, nextSibling = before && before.nextSibling();
  if (item !== before && prevOwner) {
    prevOwner.remove(item, {destroy:false, detach:false});
    if (before && before.destroyed) {
      before = nextSibling;
    }
  }
  return Ext.layout.container.HBox.prototype.moveItemBefore.call(this, item, before);
}, determineScrollbarWidth:function(ownerContext) {
  var me = this, owner = me.owner, grid = owner.grid, reserveScrollbar = grid.reserveScrollbar, scrollable = grid.view.getScrollable(), manageScrollbar = !reserveScrollbar && scrollable && scrollable.getY();
  ownerContext.manageScrollbar = manageScrollbar;
  if (!grid.ownerGrid.collapsed && (reserveScrollbar || manageScrollbar)) {
    delete me.scrollbarWidth;
  }
}, calculate:function(ownerContext) {
  var me = this, owner = me.owner, grid = owner.grid, viewContext = ownerContext.viewContext, state = ownerContext.state, context = ownerContext.context, lockingPartnerContext, columnsChanged, columns, len, i, column, scrollbarAdjustment, viewOverflowY;
  Ext.layout.container.HBox.prototype.calculate.call(this, ownerContext);
  if (grid && owner.isRootHeader && state.parallelDone) {
    lockingPartnerContext = viewContext.lockingPartnerContext;
    if (grid.forceFit && !state.reflexed) {
      if (me.convertWidthsToFlexes(ownerContext)) {
        me.cacheFlexes(ownerContext);
        me.done = false;
        ownerContext.invalidate({state:{reflexed:true, scrollbarAdjustment:me.getScrollbarAdjustment(ownerContext)}});
        return;
      }
    }
    if ((columnsChanged = state.columnsChanged) === undefined) {
      columns = ownerContext.target.getVisibleGridColumns();
      columnsChanged = false;
      for (i = 0, len = columns.length; i < len; i++) {
        column = context.getCmp(columns[i]);
        if (!column.lastBox || column.props.width !== column.lastBox.width) {
          (columnsChanged || (columnsChanged = []))[i] = column;
        }
      }
      state.columnsChanged = columnsChanged;
      ownerContext.setProp('columnsChanged', columnsChanged);
    }
    if (ownerContext.manageScrollbar) {
      scrollbarAdjustment = me.getScrollbarAdjustment(ownerContext);
      if (scrollbarAdjustment) {
        viewOverflowY = viewContext.getProp('viewOverflowY');
        if (viewOverflowY === undefined) {
          me.done = false;
          return;
        }
        if (!viewOverflowY) {
          if (lockingPartnerContext) {
            lockingPartnerContext.invalidate();
            lockingPartnerContext.headerContext.invalidate();
          }
          viewContext.invalidate();
          ownerContext.invalidate({state:{scrollbarAdjustment:0}});
        }
      }
    }
  }
}, finishedLayout:function(ownerContext) {
  Ext.layout.container.HBox.prototype.finishedLayout.call(this, ownerContext);
  if (this.owner.ariaRole === 'rowgroup') {
    this.innerCt.dom.setAttribute('role', 'row');
  }
  ownerContext.props.columnsChanged = null;
}, convertWidthsToFlexes:function(ownerContext) {
  var me = this, totalWidth = 0, calculated = me.sizeModels.calculated, childItems, len, i, childContext, item;
  childItems = ownerContext.childItems;
  len = childItems.length;
  for (i = 0; i < len; i++) {
    childContext = childItems[i];
    item = childContext.target;
    totalWidth += childContext.props.width;
    if (!(item.fixed || item.resizable === false)) {
      item.flex = ownerContext.childItems[i].flex = childContext.props.width;
      item.width = null;
      childContext.widthModel = calculated;
    }
  }
  return totalWidth !== ownerContext.props.width;
}, getScrollbarAdjustment:function(ownerContext) {
  var me = this, state = ownerContext.state, grid = me.owner.grid, scrollbarAdjustment = state.scrollbarAdjustment;
  if (scrollbarAdjustment === undefined) {
    scrollbarAdjustment = 0;
    if (grid.reserveScrollbar || ownerContext.manageScrollbar && !grid.ownerGrid.getSizeModel().height.shrinkWrap) {
      scrollbarAdjustment = me.scrollbarWidth;
    }
    state.scrollbarAdjustment = scrollbarAdjustment;
  }
  return scrollbarAdjustment;
}, getContainerSize:function(ownerContext) {
  var me = this, got, needed, padding, gotWidth, gotHeight, width, height, result;
  if (me.owner.isRootHeader) {
    result = Ext.layout.container.HBox.prototype.getContainerSize.call(this, ownerContext);
    if (result.gotWidth) {
      result.width -= me.getScrollbarAdjustment(ownerContext);
    }
  } else {
    padding = ownerContext.paddingContext.getPaddingInfo();
    got = needed = 0;
    if (!ownerContext.widthModel.shrinkWrap) {
      ++needed;
      width = ownerContext.getProp('innerWidth');
      gotWidth = typeof width === 'number';
      if (gotWidth) {
        ++got;
        width -= padding.width;
        if (width < 0) {
          width = 0;
        }
      }
    }
    if (!ownerContext.heightModel.shrinkWrap) {
      ++needed;
      height = ownerContext.getProp('innerHeight');
      gotHeight = typeof height === 'number';
      if (gotHeight) {
        ++got;
        height -= padding.height;
        if (height < 0) {
          height = 0;
        }
      }
    }
    return {width:width, height:height, needed:needed, got:got, gotAll:got === needed, gotWidth:gotWidth, gotHeight:gotHeight};
  }
  return result;
}, publishInnerCtSize:function(ownerContext) {
  var me = this, owner = me.owner, cw = ownerContext.peek('contentWidth'), adjustment = 0;
  if (cw != null && owner.isRootHeader) {
    adjustment = -ownerContext.state.scrollbarAdjustment;
  }
  return Ext.layout.container.HBox.prototype.publishInnerCtSize.call(this, ownerContext, adjustment);
}, roundFlex:function(width) {
  return Math.round(width);
}}, 0, 0, 0, 0, ['layout.gridcolumn'], 0, [Ext.grid, 'ColumnLayout'], 0);
Ext.cmd.derive('Ext.grid.ColumnManager', Ext.Base, {alternateClassName:['Ext.grid.ColumnModel'], columns:null, constructor:function(visibleOnly, headerCt, secondHeaderCt) {
  this.headerCt = headerCt;
  if (secondHeaderCt) {
    this.secondHeaderCt = secondHeaderCt;
  }
  this.visibleOnly = !!visibleOnly;
}, getColumns:function() {
  if (!this.columns) {
    this.cacheColumns();
  }
  return this.columns;
}, hasVariableRowHeight:function() {
  var me = this, columns = me.getColumns(), len = columns.length, i;
  if (me.variableRowHeight == null) {
    me.variableRowHeight = false;
    for (i = 0; !me.variableRowHeight && i < len; i++) {
      me.variableRowHeight = !!columns[i].variableRowHeight;
    }
  }
  return me.variableRowHeight;
}, getHeaderIndex:function(header) {
  if (header.isGroupHeader) {
    header = this.getHeaderColumns(header)[0];
  }
  return Ext.Array.indexOf(this.getColumns(), header);
}, getHeaderAtIndex:function(index) {
  var columns = this.getColumns(), col = columns[index];
  return col || null;
}, getPreviousSibling:function(header) {
  var index = this.getHeaderIndex(header), col = null;
  if (index > 0) {
    col = this.getColumns()[index - 1];
  }
  return col;
}, getNextSibling:function(header) {
  var index = this.getHeaderIndex(header), col;
  if (index !== -1) {
    col = this.getColumns()[index + 1];
  }
  return col || null;
}, getFirst:function() {
  var columns = this.getColumns();
  return columns.length > 0 ? columns[0] : null;
}, getLast:function() {
  var columns = this.getColumns(), len = columns.length;
  return len > 0 ? columns[len - 1] : null;
}, getHeaderByDataIndex:function(dataIndex) {
  var columns = this.getColumns(), len = columns.length, i, header;
  if (Ext.isEmpty(dataIndex)) {
    return null;
  }
  for (i = 0; i < len; ++i) {
    header = columns[i];
    if (header.dataIndex === dataIndex) {
      return header;
    }
  }
  return null;
}, getHeaderById:function(id) {
  var columns = this.getColumns(), len = columns.length, i, header;
  for (i = 0; i < len; ++i) {
    header = columns[i];
    if (header.getItemId() === id) {
      return header;
    }
  }
  return null;
}, getVisibleHeaderClosestToIndex:function(index) {
  var result = this.getHeaderAtIndex(index);
  if (result && result.hidden) {
    result = result.next(':not([hidden])') || result.prev(':not([hidden])');
  }
  return result;
}, cacheColumns:function() {
  var columns = this.getHeaderColumns(this.headerCt), second = this.secondHeaderCt;
  if (second) {
    columns = columns.concat(this.getHeaderColumns(second));
  }
  this.columns = columns;
}, getHeaderColumns:function(header) {
  var result = this.visibleOnly ? header.getVisibleGridColumns() : header.getGridColumns();
  return Ext.Array.clone(result);
}, invalidate:function() {
  var root = this.rootColumns;
  this.columns = this.variableRowHeight = null;
  if (root) {
    root.invalidate();
  }
}, destroy:function() {
  this.columns = this.rootColumns = null;
  this.callParent();
}}, 1, 0, 0, 0, 0, 0, [Ext.grid, 'ColumnManager', Ext.grid, 'ColumnModel'], function() {
  this.createAlias('indexOf', 'getHeaderIndex');
});
Ext.cmd.derive('Ext.grid.NavigationModel', Ext.view.NavigationModel, {focusCls:'x-grid-item-focused', getViewListeners:function() {
  var me = this;
  return {focusmove:{element:'el', fn:me.onFocusMove}, containermousedown:me.onContainerMouseDown, cellmousedown:me.onCellMouseDown, cellclick:me.onCellClick, itemmousedown:me.onItemMouseDown, itemclick:me.onItemClick, itemcontextmenu:me.onItemClick, scope:me};
}, initKeyNav:function(view) {
  var me = this, nav;
  if (!me.keyNav) {
    me.keyNav = [];
    me.position = new Ext.grid.CellContext(view);
  }
  nav = new Ext.util.KeyNav({target:view, ignoreInputFields:true, eventName:Ext.supports.SpecialKeyDownRepeat ? 'itemkeydown' : 'itemkeypress', defaultEventAction:'stopEvent', processEvent:me.processViewEvent, up:me.onKeyUp, down:me.onKeyDown, right:me.onKeyRight, left:me.onKeyLeft, pageDown:me.onKeyPageDown, pageUp:me.onKeyPageUp, home:me.onKeyHome, end:me.onKeyEnd, space:me.onKeySpace, enter:me.onKeyEnter, esc:me.onKeyEsc, 113:{ctrl:false, shift:false, alt:false, handler:me.onKeyF2}, tab:me.onKeyTab, 
  A:{ctrl:true, handler:me.onSelectAllKeyPress}, scope:me});
  me.keyNav.push(nav);
  me.onKeyNavCreate(nav);
}, onKeyNavCreate:Ext.emptyFn, addKeyBindings:function(binding) {
  var len = this.keyNav.length, i;
  for (i = 0; i < len; i++) {
    this.keyNav[i].addBindings(binding);
  }
}, enable:function() {
  var len = this.keyNav.length, i;
  for (i = 0; i < len; i++) {
    this.keyNav[i].enable();
  }
  this.disabled = false;
}, disable:function() {
  var len = this.keyNav.length, i;
  for (i = 0; i < len; i++) {
    this.keyNav[i].disable();
  }
  this.disabled = true;
}, processViewEvent:function(view, record, row, recordIndex, event) {
  var key = event.getKey();
  if (view.actionableMode) {
    this.map.ignoreInputFields = false;
    if (key === event.TAB || key === event.ESC || key === event.F2) {
      return event;
    }
  } else {
    this.map.ignoreInputFields = true;
    return key === event.TAB ? null : event;
  }
}, onContainerMouseDown:function(view, mousedownEvent) {
  var me = this, context = new Ext.grid.CellContext(view), lastFocused, position;
  Ext.view.NavigationModel.prototype.onContainerMouseDown.call(this, view, mousedownEvent);
  lastFocused = view.lastFocused;
  position = view.actionableMode && view.actionPosition || lastFocused;
  if (!position || lastFocused === 'scrollbar') {
    return;
  }
  context.setPosition(position.record, position.column);
  mousedownEvent.position = context;
  me.attachClosestCell(mousedownEvent);
  if (!me.position.isEqual(context)) {
    me.setPosition(context, null, mousedownEvent);
  }
}, onCellMouseDown:function(view, cell, cellIndex, record, row, recordIndex, mousedownEvent) {
  var targetComponent = Ext.Component.from(mousedownEvent, cell), actionableEl = mousedownEvent.getTarget(this.isFocusableEl, cell), ac;
  if (view.actionableMode) {
    if (!actionableEl) {
      actionableEl = (ac = Ext.ComponentManager.getActiveComponent()) && ac !== view && ac.owns(mousedownEvent);
    }
    if (actionableEl) {
      view.setActionableMode(true, mousedownEvent.position);
    } else {
      view.setActionableMode(false, mousedownEvent.position);
    }
    return;
  }
  if (mousedownEvent.pointerType !== 'touch') {
    if (mousedownEvent.position.column.cellFocusable !== false) {
      if (actionableEl) {
        if (!view.containsFocus) {
          view.containsFocus = true;
          view.toggleChildrenTabbability(false);
        }
        if (view.setActionableMode(true, mousedownEvent.position) !== false) {
          actionableEl.focus();
        }
      } else {
        cell.focus();
      }
      if (mousedownEvent.button === 2) {
        this.fireNavigateEvent(mousedownEvent);
      }
      if (targetComponent && targetComponent.isFocusable && targetComponent.isFocusable()) {
        view.setActionableMode(true, mousedownEvent.position);
        targetComponent.focus();
      }
    } else {
      mousedownEvent.preventDefault(true);
    }
  }
}, onCellClick:function(view, cell, cellIndex, record, row, recordIndex, clickEvent) {
  var me = this, targetComponent = Ext.Component.from(clickEvent, cell), clickOnFocusable = targetComponent && targetComponent.isFocusable && targetComponent.isFocusable();
  if (!Ext.isIE10m && !view.el.contains(Ext.Element.getActiveElement()) && clickEvent.pointerType !== 'touch') {
    return;
  }
  if (view.actionableMode) {
    if (!clickEvent.position.isEqual(view.actionPosition)) {
      if (!clickOnFocusable) {
        view.setActionableMode(false, clickEvent.position);
      }
    }
    me.fireEvent('navigate', {view:view, navigationModel:me, keyEvent:clickEvent, previousPosition:me.previousPosition, previousRecordIndex:me.previousRecordIndex, previousRecord:me.previousRecord, previousItem:me.previousItem, previousCell:me.previousCell, previousColumnIndex:me.previousColumnIndex, previousColumn:me.previousColumn, position:clickEvent.position, recordIndex:clickEvent.position.rowIdx, record:clickEvent.position.record, selectionStart:me.selectionStart, item:clickEvent.item, cell:clickEvent.position.cellElement, 
    columnIndex:clickEvent.position.colIdx, column:clickEvent.position.column});
  } else {
    if (me.position.isEqual(clickEvent.position) || clickOnFocusable) {
      if (Ext.isIE10m && !me.record) {
        return;
      }
      me.fireNavigateEvent(clickEvent);
    } else {
      if (clickEvent.position.column.cellFocusable !== false) {
        me.setPosition(clickEvent.position, null, clickEvent);
      } else {
        clickEvent.preventDefault();
      }
    }
  }
}, onFocusMove:function(e) {
  var view = Ext.Component.from(e.delegatedTarget, null, 'tableview'), cell = e.target, isCell = Ext.fly(cell).is(view.cellSelector), record, column, newPosition;
  if (view) {
    if (e.toElement === view.el.dom) {
      view.actionableMode = false;
      return view.onFocusEnter(e);
    }
    if (!view.actionableMode && isCell) {
      record = view.getRecord(cell);
      column = view.getHeaderByCell(cell);
      if (record && column) {
        newPosition = (new Ext.grid.CellContext(view)).setPosition(record, column);
        if (!newPosition.isEqual(this.position)) {
          this.setPosition(newPosition);
        }
      }
    } else {
      if ((view.actionableMode || view.activating) && !isCell && view.el.contains(e.target) && view.el.dom !== e.target) {
        view.ownerGrid.fireEvent('cellactivate', view.ownerGrid, view.actionPosition);
      }
    }
  }
}, onItemMouseDown:function(view, record, item, index, mousedownEvent) {
  var me = this, scroller;
  if (!mousedownEvent.position.cellElement && mousedownEvent.pointerType !== 'touch') {
    if (!view.enableTextSelection) {
      mousedownEvent.preventDefault();
    }
    me.attachClosestCell(mousedownEvent);
    if (!me.position.isEqual(mousedownEvent.position)) {
      me.setPosition(mousedownEvent.position, null, mousedownEvent);
    }
    scroller = view.getScrollable();
    if (scroller) {
      scroller.restoreState();
    }
  }
}, onItemClick:function(view, record, item, index, clickEvent) {
  if (!clickEvent.position.cellElement) {
    this.attachClosestCell(clickEvent);
    if (clickEvent.pointerType === 'touch') {
      this.setPosition(clickEvent.position, null, clickEvent);
    } else {
      this.fireNavigateEvent(clickEvent);
    }
  }
}, attachClosestCell:function(event) {
  var position = event.position, targetCell = position.cellElement, x, columns, len, i, column, b;
  if (!targetCell) {
    x = event.getX();
    columns = position.view.getVisibleColumnManager().getColumns();
    len = columns.length;
    for (i = 0; i < len; i++) {
      column = columns[i];
      b = columns[i].getBox();
      if (x >= b.left && x < b.right) {
        position.setColumn(columns[i]);
        position.rowElement = position.getRow(true);
        position.cellElement = position.getCell(true);
        return;
      }
    }
  }
}, deferSetPosition:function(delay, recordIndex, columnIndex, keyEvent, suppressEvent, preventNavigation) {
  var setPositionTask = this.view.getFocusTask();
  setPositionTask.delay(delay, this.setPosition, this, [recordIndex, columnIndex, keyEvent, suppressEvent, preventNavigation]);
  return setPositionTask;
}, setPosition:function(recordIndex, columnIndex, keyEvent, suppressEvent, preventNavigation) {
  var me = this, clearing = recordIndex == null && columnIndex == null, isClear = me.record == null && me.recordIndex == null && me.item == null, view, scroller, selModel, dataSource, columnManager, newRecordIndex, newColumnIndex, newRecord, newColumn, columns;
  if (recordIndex && recordIndex.isCellContext) {
    view = recordIndex.view;
  } else {
    if (keyEvent && keyEvent.view) {
      view = keyEvent.view;
    } else {
      if (me.lastFocused) {
        view = me.lastFocused.view;
      } else {
        view = me.view;
      }
    }
  }
  view.cancelFocusTask();
  if (view.destroyed || !view.refreshCounter || !view.ownerCt || clearing && isClear || !view.all.getCount()) {
    return;
  }
  selModel = view.getSelectionModel();
  dataSource = view.dataSource;
  columnManager = view.getVisibleColumnManager();
  columns = columnManager.getColumns();
  if (recordIndex && recordIndex.isCellContext) {
    newRecord = recordIndex.record;
    newRecordIndex = recordIndex.rowIdx;
    newColumnIndex = Math.min(recordIndex.colIdx, columns.length - 1);
    newColumn = columns[newColumnIndex];
    if (dataSource.indexOf(newRecord) === -1) {
      scroller = view.getScrollable();
      me.recordIndex = -1;
      if (scroller && scroller.getPosition().y >= scroller.getMaxPosition().y - view.all.last(true).offsetHeight) {
        recordIndex.rowIdx--;
      }
      newRecordIndex = Math.min(recordIndex.rowIdx, dataSource.getCount() - 1);
      newRecord = dataSource.getAt(newRecordIndex);
    }
  } else {
    if (clearing) {
      newRecord = newRecordIndex = null;
    } else {
      if (columnIndex == null) {
        columnIndex = me.lastFocused ? me.lastFocused.column : 0;
      }
      if (typeof recordIndex === 'number') {
        newRecordIndex = Math.max(Math.min(recordIndex, dataSource.getCount() - 1), 0);
        newRecord = dataSource.getAt(recordIndex);
      } else {
        if (recordIndex.isEntity) {
          newRecord = recordIndex;
          newRecordIndex = dataSource.indexOf(newRecord);
        } else {
          if (recordIndex.tagName) {
            newRecord = view.getRecord(recordIndex);
            newRecordIndex = dataSource.indexOf(newRecord);
            if (newRecordIndex === -1) {
              newRecord = null;
            }
          } else {
            if (isClear) {
              return;
            }
            clearing = true;
            newRecord = newRecordIndex = null;
          }
        }
      }
    }
    if (newRecord) {
      if (newRecordIndex === -1) {
        me.recordIndex = -1;
        newRecord = dataSource.getAt(0);
        newRecordIndex = 0;
        columnIndex = null;
      }
      if (columnIndex == null) {
        if (!(newColumn = me.column)) {
          newColumnIndex = 0;
          newColumn = columns[0];
        }
      } else {
        if (typeof columnIndex === 'number') {
          newColumn = columns[columnIndex];
          newColumnIndex = columnIndex;
        } else {
          newColumn = columnIndex;
          newColumnIndex = columnManager.indexOf(columnIndex);
        }
      }
    } else {
      clearing = true;
      newColumn = newColumnIndex = null;
    }
  }
  if (newColumn && columnManager.indexOf(newColumn) === -1) {
    if (newColumnIndex === -1) {
      newColumnIndex = 0;
    } else {
      newColumnIndex = Math.min(newColumnIndex, columns.length - 1);
    }
    newColumn = columns[newColumnIndex];
  }
  if (view.actionableMode && !clearing) {
    return view.ownerGrid.setActionableMode(false, (new Ext.grid.CellContext(view)).setPosition(newRecord, newColumn));
  }
  if (newRecordIndex === me.recordIndex && newColumnIndex === me.columnIndex && view === me.position.view) {
    return me.focusPosition(me.position);
  }
  if (me.cell) {
    me.cell.removeCls(me.focusCls);
  }
  me.previousRecordIndex = me.recordIndex;
  me.previousRecord = me.record;
  me.previousItem = me.item;
  me.previousCell = me.cell;
  me.previousColumn = me.column;
  me.previousColumnIndex = me.columnIndex;
  me.previousPosition = me.position.clone();
  me.selectionStart = selModel.selectionStart;
  me.position.setAll(view, me.recordIndex = newRecordIndex, me.columnIndex = newColumnIndex, me.record = newRecord, me.column = newColumn);
  if (clearing) {
    me.item = me.cell = null;
  } else {
    me.focusPosition(me.position, preventNavigation);
  }
  if (!suppressEvent) {
    selModel.fireEvent('focuschange', selModel, me.previousRecord, me.record);
    view.fireEvent('rowfocus', me.record, me.item, me.recordIndex);
    view.fireEvent('cellfocus', me.record, me.cell, me.position);
  }
  if (keyEvent && !preventNavigation && me.cell !== me.previousCell) {
    me.fireNavigateEvent(keyEvent);
  }
}, focusPosition:function(position) {
  var me = this, view, row, scroller;
  me.item = me.cell = null;
  if (position && position.record && position.column) {
    view = position.view;
    if (position.rowElement) {
      row = me.item = position.rowElement;
    } else {
      row = view.getRowByRecord(position.record);
    }
    if (row) {
      me.cell = position.cellElement || Ext.fly(row).down(position.column.getCellSelector(), true);
      if (me.cell) {
        me.cell = new Ext.dom.Fly(me.cell);
        view.lastFocused = me.lastFocused = me.position.clone();
        scroller = view.getScrollable();
        if (scroller) {
          scroller.ensureVisible(me.cell);
        }
        me.focusItem(me.cell);
        view.focusEl = me.cell;
      } else {
        me.position.setAll();
        me.record = me.column = me.recordIndex = me.columnIndex = null;
      }
    } else {
      row = view.dataSource.indexOf(position.record);
      me.position.setAll();
      me.record = me.column = me.recordIndex = me.columnIndex = null;
      if (row !== -1 && view.bufferedRenderer) {
        me.lastKeyEvent = null;
        view.bufferedRenderer.scrollTo(row, false, me.afterBufferedScrollTo, me);
      }
    }
  }
}, focusItem:function(item) {
  item.addCls(this.focusCls);
  item.focus();
}, getCell:function() {
  return this.cell;
}, getPosition:function(skipChecks) {
  var me = this, position = me.position, curIndex, view, dataSource;
  if (position.record && position.column) {
    if (skipChecks) {
      return position;
    }
    view = position.view;
    dataSource = view.dataSource;
    curIndex = dataSource.indexOf(position.record);
    if (curIndex === -1) {
      curIndex = position.rowIdx;
      if (!(position.record = dataSource.getAt(curIndex))) {
        curIndex = -1;
      }
    }
    if (curIndex === -1 || view.getVisibleColumnManager().indexOf(position.column) === -1) {
      position.setAll();
      me.record = me.column = me.recordIndex = me.columnIndex = null;
    } else {
      return position;
    }
  }
  return null;
}, getLastFocused:function() {
  var me = this, view, lastFocused = me.lastFocused;
  if (lastFocused && lastFocused.record && lastFocused.column) {
    view = lastFocused.view;
    if (view.dataSource.indexOf(lastFocused.record) !== -1 && view.getVisibleColumnManager().indexOf(lastFocused.column) !== -1) {
      return lastFocused;
    }
  }
}, onKeyTab:function(keyEvent) {
  var forward = !keyEvent.shiftKey, view = keyEvent.position.view, ret, focusTarget, position;
  ret = view.findFocusPosition(keyEvent.target, keyEvent.position, forward, keyEvent);
  focusTarget = ret.target;
  position = ret.position;
  if (focusTarget) {
    this.actionPosition = position.view.actionPosition = position;
    Ext.fly(focusTarget).focus();
  } else {
    view.onRowExit(keyEvent, keyEvent.item, keyEvent.item[forward ? 'nextSibling' : 'previousSibling'], forward);
  }
  keyEvent.preventDefault();
}, onKeyUp:function(keyEvent) {
  var newRecord = keyEvent.view.walkRecs(keyEvent.record, -1), pos = this.getPosition();
  if (newRecord) {
    pos.setRow(newRecord);
    if (!pos.getCell(true)) {
      pos.navigate(-1);
    }
    this.setPosition(pos, null, keyEvent);
  }
}, onKeyDown:function(keyEvent) {
  var newRecord = keyEvent.record.isExpandingOrCollapsing ? null : keyEvent.view.walkRecs(keyEvent.record, 1), pos = this.getPosition();
  if (newRecord) {
    pos.setRow(newRecord);
    if (!pos.getCell(true)) {
      pos.navigate(-1);
    }
    this.setPosition(pos, null, keyEvent);
  }
}, onKeyRight:function(keyEvent) {
  var newPosition = this.move('right', keyEvent);
  if (newPosition) {
    this.setPosition(newPosition, null, keyEvent);
  }
}, onKeyLeft:function(keyEvent) {
  var newPosition = this.move('left', keyEvent);
  if (newPosition) {
    this.setPosition(newPosition, null, keyEvent);
  }
}, onKeyEnter:function(keyEvent) {
  var eventArgs = ['cellclick', keyEvent.view, keyEvent.position.cellElement, keyEvent.position.colIdx, keyEvent.record, keyEvent.position.rowElement, keyEvent.recordIndex, keyEvent], actionCell = keyEvent.position.getCell(true);
  if (actionCell) {
    if (!actionCell.querySelector('[tabIndex\x3d"-1"]')) {
      keyEvent.stopEvent();
      keyEvent.view.fireEvent.apply(keyEvent.view, eventArgs);
      eventArgs[0] = 'celldblclick';
      keyEvent.view.fireEvent.apply(keyEvent.view, eventArgs);
    }
    if (!this.view.actionableMode) {
      this.view.ownerGrid.setActionableMode(true, this.getPosition());
    }
  }
}, onKeyF2:function(keyEvent) {
  var grid = this.view.ownerGrid, actionableMode = grid.actionableMode;
  grid.setActionableMode(!actionableMode, actionableMode ? null : this.getPosition());
}, onKeyEsc:function(keyEvent) {
  var grid = this.view.ownerGrid;
  if (grid.actionableMode) {
    grid.setActionableMode(false);
  } else {
    return true;
  }
}, move:function(dir, keyEvent) {
  var me = this, position = me.getPosition(), result = position, rowVeto = keyEvent.shiftKey && (dir === 'right' || dir === 'left');
  if (position && position.record) {
    while (result) {
      result = result.view.walkCells(result, dir, rowVeto ? me.vetoRowChange : null, me);
      if (result && result.getCell(true) && result.column.cellFocusable !== false) {
        return result;
      }
    }
  }
}, vetoRowChange:function(newPosition) {
  return this.getPosition().record === newPosition.record;
}, onKeyPageDown:function(keyEvent) {
  var me = this, view = keyEvent.view, rowsVisible = me.getRowsVisible(), newIdx, newRecord;
  if (rowsVisible) {
    if (view.bufferedRenderer) {
      newIdx = Math.min(keyEvent.recordIndex + rowsVisible, view.dataSource.getCount() - 1);
      me.lastKeyEvent = keyEvent;
      view.bufferedRenderer.scrollTo(newIdx, false, me.afterBufferedScrollTo, me);
    } else {
      newRecord = view.walkRecs(keyEvent.record, rowsVisible);
      me.setPosition(newRecord, null, keyEvent);
    }
  }
}, onKeyPageUp:function(keyEvent) {
  var me = this, view = keyEvent.view, rowsVisible = me.getRowsVisible(), newIdx, newRecord;
  if (rowsVisible) {
    if (view.bufferedRenderer) {
      newIdx = Math.max(keyEvent.recordIndex - rowsVisible, 0);
      me.lastKeyEvent = keyEvent;
      view.bufferedRenderer.scrollTo(newIdx, false, me.afterBufferedScrollTo, me);
    } else {
      newRecord = view.walkRecs(keyEvent.record, -rowsVisible);
      me.setPosition(newRecord, null, keyEvent);
    }
  }
}, onKeyHome:function(keyEvent) {
  var me = this, view = keyEvent.view;
  if (keyEvent.altKey) {
    if (view.bufferedRenderer) {
      me.lastKeyEvent = keyEvent;
      view.bufferedRenderer.scrollTo(0, false, me.afterBufferedScrollTo, me);
    } else {
      me.setPosition(view.walkRecs(keyEvent.record, -view.dataSource.indexOf(keyEvent.record)), null, keyEvent);
    }
  } else {
    me.setPosition(keyEvent.record, 0, keyEvent);
  }
}, afterBufferedScrollTo:function(newIdx, newRecord) {
  this.setPosition(newRecord, null, this.lastKeyEvent, null, !this.lastKeyEvent);
}, onKeyEnd:function(keyEvent) {
  var me = this, view = keyEvent.view;
  if (keyEvent.altKey) {
    if (view.bufferedRenderer) {
      me.lastKeyEvent = keyEvent;
      view.bufferedRenderer.scrollTo(view.store.getCount() - 1, false, me.afterBufferedScrollTo, me);
    } else {
      me.setPosition(view.walkRecs(keyEvent.record, view.dataSource.getCount() - 1 - view.dataSource.indexOf(keyEvent.record)), null, keyEvent);
    }
  } else {
    me.setPosition(keyEvent.record, keyEvent.view.getVisibleColumnManager().getColumns().length - 1, keyEvent);
  }
}, getRowsVisible:function() {
  var rowsVisible = false, view = this.view, firstRow = view.all.first(), rowHeight, gridViewHeight;
  if (firstRow) {
    rowHeight = firstRow.getHeight();
    gridViewHeight = view.el.getHeight();
    rowsVisible = Math.floor(gridViewHeight / rowHeight);
  }
  return rowsVisible;
}, fireNavigateEvent:function(keyEvent) {
  var me = this;
  me.fireEvent('navigate', {view:me.position.view, navigationModel:me, keyEvent:keyEvent || new Ext.event.Event({}), previousPosition:me.previousPosition, previousRecordIndex:me.previousRecordIndex, previousRecord:me.previousRecord, previousItem:me.previousItem, previousCell:me.previousCell, previousColumnIndex:me.previousColumnIndex, previousColumn:me.previousColumn, position:me.position, recordIndex:me.recordIndex, record:me.record, selectionStart:me.selectionStart, item:me.item, cell:me.cell, 
  columnIndex:me.columnIndex, column:me.column});
}, isFocusableEl:function(el) {
  return Ext.fly(el).isFocusable();
}}, 0, 0, 0, 0, ['view.navigation.grid'], 0, [Ext.grid, 'NavigationModel'], 0);
Ext.cmd.derive('Ext.view.TableLayout', Ext.layout.component.Auto, {type:'tableview', beginLayout:function(ownerContext) {
  var me = this, owner = me.owner, ownerGrid = owner.ownerGrid, partner = owner.lockingPartner, partnerContext = ownerContext.lockingPartnerContext, partnerVisible = partner && partner.grid.isVisible() && !(partner.grid.collapsed || partner.grid.floatedFromCollapse), context = ownerContext.context, scrollable = ownerGrid.getScrollable();
  ownerContext.doSyncRowHeights = partnerVisible && (ownerGrid.syncRowHeight || ownerGrid.syncRowHeightOnNextLayout);
  ownerContext.allowScrollX = scrollable && scrollable.config && scrollable.config.x;
  if (!me.columnFlusherId) {
    me.columnFlusherId = me.id + '-columns';
    me.rowHeightFlusherId = me.id + '-rows';
  }
  Ext.layout.component.Auto.prototype.beginLayout.call(this, ownerContext);
  if (partnerVisible) {
    if (!partnerContext && partner.componentLayout.isRunning()) {
      (partnerContext = ownerContext.lockingPartnerContext = context.getCmp(partner)).lockingPartnerContext = ownerContext;
      if (!partnerContext.lockingPartnerContext) {
        partnerContext.lockingPartnerContext = ownerContext;
      }
    }
    if (ownerContext.doSyncRowHeights) {
      if (partnerContext && !partnerContext.rowHeightSynchronizer) {
        partnerContext.rowHeightSynchronizer = partnerContext.target.syncRowHeightBegin();
      }
      ownerContext.rowHeightSynchronizer = me.owner.syncRowHeightBegin();
    }
  }
  (ownerContext.headerContext = context.getCmp(me.headerCt)).viewContext = ownerContext;
}, beginLayoutCycle:function(ownerContext, firstCycle) {
  Ext.layout.component.Auto.prototype.beginLayoutCycle.call(this, ownerContext, firstCycle);
  if (ownerContext.syncRowHeights) {
    ownerContext.target.syncRowHeightClear(ownerContext.rowHeightSynchronizer);
    ownerContext.syncRowHeights = false;
  }
}, calculate:function(ownerContext) {
  var me = this, context = ownerContext.context, lockingPartnerContext = ownerContext.lockingPartnerContext, headerContext = ownerContext.headerContext, ownerCtContext = ownerContext.ownerCtContext, owner = me.owner, columnsChanged = headerContext.getProp('columnsChanged'), state = ownerContext.state, overflowable, columnFlusher, otherSynchronizer, synchronizer, rowHeightFlusher, bodyDom = owner.body.dom, bodyHeight, ctSize, overflowY, overflowX, scrollbarHeight;
  if (!owner.all.getCount() && (!bodyDom || !owner.body.child('table', true))) {
    ownerContext.setProp('viewOverflowY', false);
    Ext.layout.component.Auto.prototype.calculate.call(this, ownerContext);
    return;
  }
  if (me.calcCount === 1 && me.owner.bufferedRenderer) {
    me.owner.bufferedRenderer.beforeTableLayout(ownerContext);
  }
  if (columnsChanged === undefined) {
    me.done = false;
    return;
  }
  if (columnsChanged) {
    if (!(columnFlusher = state.columnFlusher)) {
      context.queueFlush(state.columnFlusher = columnFlusher = {ownerContext:ownerContext, columnsChanged:columnsChanged, layout:me, id:me.columnFlusherId, flush:me.flushColumnWidths}, true);
    }
    if (!columnFlusher.flushed) {
      me.done = false;
      return;
    }
  }
  if (ownerContext.doSyncRowHeights) {
    if (!(rowHeightFlusher = state.rowHeightFlusher)) {
      if (!(synchronizer = state.rowHeights)) {
        state.rowHeights = synchronizer = ownerContext.rowHeightSynchronizer;
        me.owner.syncRowHeightMeasure(synchronizer);
        ownerContext.setProp('rowHeights', synchronizer);
      }
      if (!(otherSynchronizer = lockingPartnerContext.getProp('rowHeights'))) {
        me.done = false;
        return;
      }
      context.queueFlush(state.rowHeightFlusher = rowHeightFlusher = {ownerContext:ownerContext, synchronizer:synchronizer, otherSynchronizer:otherSynchronizer, layout:me, id:me.rowHeightFlusherId, flush:me.flushRowHeights}, true);
    }
    if (!rowHeightFlusher.flushed) {
      me.done = false;
      return;
    }
  }
  Ext.layout.component.Auto.prototype.calculate.call(this, ownerContext);
  if (!ownerContext.heightModel.shrinkWrap) {
    if (!ownerCtContext.heightModel.shrinkWrap) {
      overflowable = true;
      ctSize = ownerCtContext.target.layout.getContainerSize(ownerCtContext);
      if (!ctSize.gotHeight) {
        me.done = false;
        return;
      }
      bodyHeight = bodyDom.offsetHeight;
      if (bodyHeight > ctSize.height) {
        overflowY = true;
      }
    }
  }
  scrollbarHeight = Ext.getScrollbarSize().height;
  if (me.done && ownerContext.allowScrollX && scrollbarHeight) {
    if (!owner.lockingPartner) {
      if (owner.isAutoTree) {
        overflowX = true;
      } else {
        overflowX = !!ownerContext.headerContext.state.boxPlan.tooNarrow;
      }
      ownerContext.setProp('overflowX', overflowX);
    }
    if (overflowX && bodyHeight && overflowable) {
      overflowY = bodyHeight + scrollbarHeight > ctSize.height;
    }
  }
  if (me.done || overflowY != null) {
    ownerContext.setProp('viewOverflowY', !!overflowY);
  }
}, measureContentHeight:function(ownerContext) {
  var owner = this.owner, bodyDom = owner.body.dom, emptyEl = owner.emptyEl, bodyHeight = 0;
  if (emptyEl) {
    bodyHeight += emptyEl.offsetHeight;
  }
  if (bodyDom) {
    bodyHeight += bodyDom.offsetHeight;
  }
  if (ownerContext.headerContext.state.boxPlan.tooNarrow) {
    bodyHeight += Ext.getScrollbarSize().height;
  }
  return bodyHeight;
}, flushColumnWidths:function() {
  var flusher = this, me = flusher.layout, ownerContext = flusher.ownerContext, columnsChanged = flusher.columnsChanged, owner = ownerContext.target, len = columnsChanged.length, column, i, colWidth, lastBox;
  if (ownerContext.state.columnFlusher !== flusher) {
    return;
  }
  for (i = 0; i < len; i++) {
    if (!(column = columnsChanged[i])) {
      continue;
    }
    colWidth = column.props.width;
    owner.body.select(owner.getColumnSizerSelector(column.target)).setWidth(colWidth);
    if (column.target.onCellsResized) {
      column.target.onCellsResized(colWidth);
    }
    lastBox = column.lastBox;
    if (lastBox) {
      lastBox.width = colWidth;
    }
  }
  flusher.flushed = true;
  if (!me.pending) {
    ownerContext.context.queueLayout(me);
  }
}, flushRowHeights:function() {
  var flusher = this, me = flusher.layout, ownerContext = flusher.ownerContext;
  if (ownerContext.state.rowHeightFlusher !== flusher) {
    return;
  }
  ownerContext.target.syncRowHeightFinish(flusher.synchronizer, flusher.otherSynchronizer);
  flusher.flushed = true;
  ownerContext.syncRowHeights = true;
  if (!me.pending) {
    ownerContext.context.queueLayout(me);
  }
}, finishedLayout:function(ownerContext) {
  var me = this, ownerGrid = me.owner.ownerGrid, nodeContainer = Ext.fly(me.owner.getNodeContainer()), scroller = this.owner.getScrollable(), buffered;
  Ext.layout.component.Auto.prototype.finishedLayout.call(this, ownerContext);
  if (nodeContainer) {
    nodeContainer.setWidth(ownerContext.headerContext.props.contentWidth);
  }
  buffered = me.owner.bufferedRenderer;
  if (buffered) {
    buffered.afterTableLayout(ownerContext);
  }
  if (ownerGrid) {
    ownerGrid.syncRowHeightOnNextLayout = false;
  }
  if (scroller && !scroller.isScrolling) {
    if (buffered) {
      if (buffered.nextRefreshStartIndex === 0 || me.owner.hasVariableRowHeight()) {
        return;
      }
    }
    scroller.restoreState();
  }
}, getLayoutItems:function() {
  return this.owner.getRefItems();
}, isValidParent:function() {
  return true;
}}, 0, 0, 0, 0, ['layout.tableview'], 0, [Ext.view, 'TableLayout'], 0);
Ext.cmd.derive('Ext.grid.locking.RowSynchronizer', Ext.Base, {constructor:function(view, rowEl) {
  var me = this, rowTpl;
  me.view = view;
  me.rowEl = rowEl;
  me.els = {};
  me.add('data', view.rowSelector);
  for (rowTpl = view.rowTpl; rowTpl; rowTpl = rowTpl.nextTpl) {
    if (rowTpl.beginRowSync) {
      rowTpl.beginRowSync(me);
    }
  }
}, add:function(name, selector) {
  var el = Ext.fly(this.rowEl).down(selector, true);
  if (el) {
    this.els[name] = {el:el};
  }
}, finish:function(other) {
  var me = this, els = me.els, otherEls = other.els, otherEl, growth = 0, otherGrowth = 0, delta, name, otherHeight;
  for (name in els) {
    otherEl = otherEls[name];
    otherHeight = otherEl ? otherEl.height : 0;
    delta = otherHeight - els[name].height;
    if (delta > 0) {
      growth += delta;
      Ext.fly(els[name].el).setHeight(otherHeight);
    } else {
      otherGrowth -= delta;
    }
  }
  otherHeight = other.rowHeight + otherGrowth;
  if (Ext.isIE9 && me.view.ownerGrid.rowLines) {
    otherHeight--;
  }
  if (me.rowHeight + growth < otherHeight) {
    Ext.fly(me.rowEl).setHeight(otherHeight);
  }
}, measure:function() {
  var me = this, els = me.els, grid = me.view.ownerGrid, name;
  me.rowHeight = grid.getElementHeight(me.rowEl);
  for (name in els) {
    els[name].height = grid.getElementHeight(els[name].el);
  }
}, reset:function() {
  var els = this.els, name;
  this.rowEl.style.height = '';
  for (name in els) {
    els[name].el.style.height = '';
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.grid.locking, 'RowSynchronizer'], 0);
Ext.cmd.derive('Ext.view.NodeCache', Ext.Base, {statics:{range:document.createRange && document.createRange()}, constructor:function(view) {
  this.view = view;
  this.clear();
  this.el = new Ext.dom.Fly;
}, destroy:function() {
  var me = this;
  if (!me.destroyed) {
    me.el.destroy();
    me.el = me.view = null;
    me.destroyed = true;
  }
  me.callParent();
}, clear:function(removeDom) {
  var me = this, elements = me.elements, range = me.statics().range, key;
  if (me.count && removeDom) {
    if (range && Ext.getBody().contains(elements[0])) {
      range.setStartBefore(elements[me.startIndex]);
      range.setEndAfter(elements[me.endIndex]);
      range.deleteContents();
    } else {
      for (key in elements) {
        Ext.removeNode(elements[key]);
      }
    }
  }
  me.elements = {};
  me.count = me.startIndex = 0;
  me.endIndex = -1;
}, fill:function(newElements, startIndex, fixedNodes) {
  fixedNodes = fixedNodes || 0;
  var me = this, elements = me.elements = {}, i, len = newElements.length - fixedNodes;
  if (!startIndex) {
    startIndex = 0;
  }
  for (i = 0; i < len; i++) {
    elements[startIndex + i] = newElements[i + fixedNodes];
  }
  me.startIndex = startIndex;
  me.endIndex = startIndex + len - 1;
  me.count = len;
  return this;
}, insert:function(insertPoint, nodes) {
  var me = this, elements = me.elements, i, nodeCount = nodes.length;
  if (me.count) {
    if (insertPoint < me.count) {
      for (i = me.endIndex + nodeCount; i >= insertPoint + nodeCount; i--) {
        elements[i] = elements[i - nodeCount];
        elements[i].setAttribute('data-recordIndex', i);
      }
    }
    me.endIndex = me.endIndex + nodeCount;
  } else {
    me.startIndex = insertPoint;
    me.endIndex = insertPoint + nodeCount - 1;
  }
  for (i = 0; i < nodeCount; i++, insertPoint++) {
    elements[insertPoint] = nodes[i];
    elements[insertPoint].setAttribute('data-recordIndex', insertPoint);
  }
  me.count += nodeCount;
}, invoke:function(fn, args) {
  var me = this, element, i;
  fn = Ext.dom.Element.prototype[fn];
  for (i = me.startIndex; i <= me.endIndex; i++) {
    element = me.item(i);
    if (element) {
      fn.apply(element, args);
    }
  }
  return me;
}, item:function(index, asDom) {
  var el = this.elements[index], result = null;
  if (el) {
    result = asDom ? this.elements[index] : this.el.attach(this.elements[index]);
  }
  return result;
}, first:function(asDom) {
  return this.item(this.startIndex, asDom);
}, last:function(asDom) {
  return this.item(this.endIndex, asDom);
}, moveBlock:function(increment) {
  var me = this, elements = me.elements, node, end, step, i;
  if (!increment) {
    return;
  }
  if (increment < 0) {
    i = me.startIndex - 1;
    end = me.endIndex;
    step = 1;
  } else {
    i = me.endIndex + 1;
    end = me.startIndex;
    step = -1;
  }
  me.startIndex += increment;
  me.endIndex += increment;
  do {
    i += step;
    node = elements[i + increment] = elements[i];
    node.setAttribute('data-recordIndex', i + increment);
    if (i < me.startIndex || i > me.endIndex) {
      delete elements[i];
    }
  } while (i !== end);
  delete elements[i];
}, getCount:function() {
  return this.count;
}, slice:function(start, end) {
  var elements = this.elements, result = [], i;
  if (!end) {
    end = this.endIndex;
  } else {
    end = Math.min(this.endIndex, end - 1);
  }
  for (i = start || this.startIndex; i <= end; i++) {
    result.push(elements[i]);
  }
  return result;
}, replaceElement:function(el, replacement, domReplace) {
  var elements = this.elements, index = typeof el === 'number' ? el : this.indexOf(el);
  if (index > -1) {
    replacement = Ext.getDom(replacement);
    if (domReplace) {
      el = elements[index];
      el.parentNode.insertBefore(replacement, el);
      Ext.removeNode(el);
      replacement.setAttribute('data-recordIndex', index);
    }
    this.elements[index] = replacement;
  }
  return this;
}, indexOf:function(el) {
  var elements = this.elements, index;
  el = Ext.getDom(el);
  for (index = this.startIndex; index <= this.endIndex; index++) {
    if (elements[index] === el) {
      return index;
    }
  }
  return -1;
}, clip:function(removeEnd, removeCount) {
  var me = this, elements = me.elements, removed = [], start, end, el, i;
  if (removeEnd === 1) {
    start = me.startIndex;
    me.startIndex += removeCount;
  } else {
    me.endIndex -= removeCount;
    start = me.endIndex + 1;
  }
  for (i = start, end = start + removeCount - 1; i <= end; i++) {
    el = elements[i];
    removed.push(el);
    Ext.removeNode(el);
    delete elements[i];
  }
  me.count -= removeCount;
  me.view.fireItemMutationEvent('itemremove', me.view.dataSource.getRange(start, end), start, removed, me.view);
}, removeRange:function(start, end, removeDom) {
  var me = this, elements = me.elements, removed = [], el, i, removeCount, fromPos;
  if (end == null) {
    end = me.endIndex + 1;
  } else {
    end = Math.min(me.endIndex + 1, end + 1);
  }
  if (start == null) {
    start = me.startIndex;
  }
  removeCount = end - start;
  for (i = start, fromPos = end; i <= me.endIndex; i++, fromPos++) {
    el = elements[i];
    if (i < end) {
      removed.push(el);
      if (removeDom) {
        Ext.removeNode(el);
      }
    }
    if (fromPos <= me.endIndex) {
      el = elements[i] = elements[fromPos];
      el.setAttribute('data-recordIndex', i);
    } else {
      delete elements[i];
    }
  }
  me.count -= removeCount;
  me.endIndex -= removeCount;
  return removed;
}, removeElement:function(keys, removeDom) {
  var me = this, inKeys, key, elements = me.elements, el, deleteCount, keyIndex = 0, index, fromIndex;
  if (Ext.isArray(keys)) {
    inKeys = keys;
    keys = [];
    deleteCount = inKeys.length;
    for (keyIndex = 0; keyIndex < deleteCount; keyIndex++) {
      key = inKeys[keyIndex];
      if (typeof key !== 'number') {
        key = me.indexOf(key);
      }
      if (key >= me.startIndex && key <= me.endIndex) {
        keys[keys.length] = key;
      }
    }
    Ext.Array.sort(keys);
    deleteCount = keys.length;
  } else {
    if (keys < me.startIndex || keys > me.endIndex) {
      return;
    }
    deleteCount = 1;
    keys = [keys];
  }
  for (index = fromIndex = keys[0], keyIndex = 0; index <= me.endIndex; index++, fromIndex++) {
    if (keyIndex < deleteCount && index === keys[keyIndex]) {
      fromIndex++;
      keyIndex++;
      if (removeDom) {
        Ext.removeNode(elements[index]);
      }
    }
    if (fromIndex <= me.endIndex && fromIndex >= me.startIndex) {
      el = elements[index] = elements[fromIndex];
      el.setAttribute('data-recordIndex', index);
    } else {
      delete elements[index];
    }
  }
  me.endIndex -= deleteCount;
  me.count -= deleteCount;
}, scroll:function(newRecords, direction, removeCount) {
  var me = this, view = me.view, store = view.store, elements = me.elements, recCount = newRecords.length, nodeContainer = view.getNodeContainer(), range = me.statics().range, i, el, removeEnd, children, result, removeStart, removedRecords, removedItems;
  if (!(newRecords.length || removeCount)) {
    return;
  }
  if (direction === -1) {
    if (removeCount) {
      removedRecords = [];
      removedItems = [];
      removeStart = me.endIndex - removeCount + 1;
      if (range) {
        range.setStartBefore(elements[removeStart]);
        range.setEndAfter(elements[me.endIndex]);
        range.deleteContents();
        for (i = removeStart; i <= me.endIndex; i++) {
          el = elements[i];
          delete elements[i];
          removedRecords.push(store.getByInternalId(el.getAttribute('data-recordId')));
          removedItems.push(el);
        }
      } else {
        for (i = removeStart; i <= me.endIndex; i++) {
          el = elements[i];
          delete elements[i];
          Ext.removeNode(el);
          removedRecords.push(store.getByInternalId(el.getAttribute('data-recordId')));
          removedItems.push(el);
        }
      }
      view.fireItemMutationEvent('itemremove', removedRecords, removeStart, removedItems, view);
      me.endIndex -= removeCount;
    }
    if (newRecords.length) {
      result = view.bufferRender(newRecords, me.startIndex -= recCount);
      children = result.children;
      for (i = 0; i < recCount; i++) {
        elements[me.startIndex + i] = children[i];
      }
      nodeContainer.insertBefore(result.fragment, nodeContainer.firstChild);
      view.fireItemMutationEvent('itemadd', newRecords, me.startIndex, children, view);
    }
  } else {
    if (removeCount) {
      removedRecords = [];
      removedItems = [];
      removeEnd = me.startIndex + removeCount;
      if (range) {
        range.setStartBefore(elements[me.startIndex]);
        range.setEndAfter(elements[removeEnd - 1]);
        range.deleteContents();
        for (i = me.startIndex; i < removeEnd; i++) {
          el = elements[i];
          delete elements[i];
          removedRecords.push(store.getByInternalId(el.getAttribute('data-recordId')));
          removedItems.push(el);
        }
      } else {
        for (i = me.startIndex; i < removeEnd; i++) {
          el = elements[i];
          delete elements[i];
          Ext.removeNode(el);
          removedRecords.push(store.getByInternalId(el.getAttribute('data-recordId')));
          removedItems.push(el);
        }
      }
      view.fireItemMutationEvent('itemremove', removedRecords, me.startIndex, removedItems, view);
      me.startIndex = removeEnd;
    }
    result = view.bufferRender(newRecords, me.endIndex + 1);
    children = result.children;
    for (i = 0; i < recCount; i++) {
      elements[me.endIndex += 1] = children[i];
    }
    nodeContainer.appendChild(result.fragment);
    view.fireItemMutationEvent('itemadd', newRecords, me.endIndex + 1, children, view);
  }
  me.count = me.endIndex - me.startIndex + 1;
  return children;
}, sumHeights:function() {
  var result = 0, elements = this.elements, i;
  for (i = this.startIndex; i <= this.endIndex; i++) {
    result += elements[i].offsetHeight;
  }
  return result;
}}, 1, 0, 0, 0, 0, 0, [Ext.view, 'NodeCache'], function() {
  Ext.dom.CompositeElementLite.importElementMethods.call(this);
});
Ext.cmd.derive('Ext.scroll.TableScroller', Ext.scroll.Scroller, {config:{lockingScroller:null}, privates:{getEnsureVisibleXY:function(el, options) {
  var lockingScroller = this.getLockingScroller(), position = this.getPosition(), newPosition;
  if (el && el.element && !el.isElement) {
    options = el;
    el = options.element;
  }
  options = options || {};
  if (lockingScroller) {
    position.y = lockingScroller.position.y;
  }
  newPosition = Ext.fly(el).getScrollIntoViewXY(this.getElement(), position.x, position.y);
  newPosition.x = options.x === false ? position.x : newPosition.x;
  if (lockingScroller) {
    newPosition.y = options.y === false ? position.y : Ext.fly(el).getScrollIntoViewXY(lockingScroller.getElement(), position.x, position.y).y;
  }
  return newPosition;
}, doScrollTo:function(x, y, animate) {
  var lockingScroller, lockedPromise, ret;
  if (y != null) {
    lockingScroller = this.getLockingScroller();
    if (lockingScroller) {
      lockedPromise = lockingScroller.doScrollTo(null, y, animate);
      y = null;
    }
  }
  ret = Ext.scroll.Scroller.prototype.doScrollTo.call(this, x, y, animate);
  if (lockedPromise) {
    ret = Ext.Promise.all([ret, lockedPromise]);
  }
  return ret;
}, restoreState:function() {
  var me = this, el = me.getScrollElement(), lockingScroller = me.getLockingScroller(), trackingScrollTop;
  if (el) {
    trackingScrollTop = lockingScroller ? lockingScroller.trackingScrollTop : me.trackingScrollTop;
    if (trackingScrollTop !== undefined) {
      if (!me.restoreTimer) {
        me.restoreTimer = Ext.defer(function() {
          me.restoreTimer = null;
        }, 50);
      }
      me.doScrollTo(me.trackingScrollLeft, trackingScrollTop, false);
    }
  }
}}}, 0, 0, 0, 0, ['scroller.table'], 0, [Ext.scroll, 'TableScroller'], 0);
Ext.cmd.derive('Ext.view.Table', Ext.view.View, {alternateClassName:'Ext.grid.View', isTableView:true, config:{selectionModel:{type:'rowmodel'}}, inheritableStatics:{normalSideEvents:['deselect', 'select', 'beforedeselect', 'beforeselect', 'selectionchange'], events:['blur', 'focus', 'move', 'resize', 'destroy', 'beforedestroy', 'boxready', 'afterrender', 'render', 'beforerender', 'removed', 'hide', 'beforehide', 'show', 'beforeshow', 'enable', 'disable', 'added', 'deactivate', 'beforedeactivate', 
'activate', 'beforeactivate', 'cellkeydown', 'beforecellkeydown', 'cellmouseup', 'beforecellmouseup', 'cellmousedown', 'beforecellmousedown', 'cellcontextmenu', 'beforecellcontextmenu', 'celldblclick', 'beforecelldblclick', 'cellclick', 'beforecellclick', 'refresh', 'itemremove', 'itemadd', 'beforeitemupdate', 'itemupdate', 'viewready', 'beforerefresh', 'unhighlightitem', 'highlightitem', 'focuschange', 'containerkeydown', 'containercontextmenu', 'containerdblclick', 'containerclick', 'containermouseout', 
'containermouseover', 'containermouseup', 'containermousedown', 'beforecontainerkeydown', 'beforecontainercontextmenu', 'beforecontainerdblclick', 'beforecontainerclick', 'beforecontainermouseout', 'beforecontainermouseover', 'beforecontainermouseup', 'beforecontainermousedown', 'itemkeydown', 'itemcontextmenu', 'itemdblclick', 'itemclick', 'itemmouseleave', 'itemmouseenter', 'itemmouseup', 'itemmousedown', 'rowclick', 'rowcontextmenu', 'rowdblclick', 'rowkeydown', 'rowmouseup', 'rowmousedown', 'rowkeydown', 
'beforeitemkeydown', 'beforeitemcontextmenu', 'beforeitemdblclick', 'beforeitemclick', 'beforeitemmouseleave', 'beforeitemmouseenter', 'beforeitemmouseup', 'beforeitemmousedown', 'statesave', 'beforestatesave', 'staterestore', 'beforestaterestore', 'uievent', 'groupcollapse', 'groupexpand', 'scroll']}, scrollable:true, componentLayout:'tableview', baseCls:'x-grid-view', unselectableCls:'x-unselectable', firstCls:'x-grid-cell-first', lastCls:'x-grid-cell-last', itemCls:'x-grid-item', selectedItemCls:'x-grid-item-selected', 
selectedCellCls:'x-grid-cell-selected', focusedItemCls:'x-grid-item-focused', overItemCls:'x-grid-item-over', altRowCls:'x-grid-item-alt', dirtyCls:'x-grid-dirty-cell', rowClsRe:new RegExp('(?:^|\\s*)x-grid-item-alt(?:\\s+|$)', 'g'), cellRe:new RegExp('x-grid-cell-([^\\s]+)(?:\\s|$)', ''), positionBody:true, positionCells:false, stripeOnUpdate:null, actionableMode:false, trackOver:true, getRowClass:null, stripeRows:true, markDirty:true, ariaRole:'rowgroup', rowAriaRole:'row', cellAriaRole:'gridcell', 
tpl:['{%', 'view \x3d values.view;', 'if (!(columns \x3d values.columns)) {', 'columns \x3d values.columns \x3d view.ownerCt.getVisibleColumnManager().getColumns();', '}', 'values.fullWidth \x3d 0;', 'for (i \x3d 0, len \x3d columns.length; i \x3c len; i++) {', 'column \x3d columns[i];', 'values.fullWidth +\x3d (column.cellWidth \x3d column.lastBox ? column.lastBox.width : column.width || column.minWidth);', '}', 'tableCls\x3dvalues.tableCls\x3d[];', '%}', '\x3cdiv class\x3d"x-grid-item-container" role\x3d"presentation" style\x3d"width:{fullWidth}px"\x3e', 
'{[view.renderTHead(values, out, parent)]}', '{%', 'view.renderRows(values.rows, values.columns, values.viewStartIndex, out);', '%}', '{[view.renderTFoot(values, out, parent)]}', '\x3c/div\x3e', '{% ', 'view \x3d columns \x3d column \x3d null;', '%}', {definitions:'var view, tableCls, columns, i, len, column;', priority:0}], outerRowTpl:['\x3ctable id\x3d"{rowId}" role\x3d"presentation" ', 'data-boundView\x3d"{view.id}" ', 'data-recordId\x3d"{record.internalId}" ', 'data-recordIndex\x3d"{recordIndex}" ', 
'class\x3d"{[values.itemClasses.join(" ")]}" cellpadding\x3d"0" cellspacing\x3d"0" style\x3d"{itemStyle};width:0"\x3e', '{%', 'this.nextTpl.applyOut(values, out, parent)', '%}', '\x3c/table\x3e', {priority:9999}], rowTpl:['{%', 'var dataRowCls \x3d values.recordIndex \x3d\x3d\x3d -1 ? "" : " x-grid-row";', '%}', '\x3ctr class\x3d"{[values.rowClasses.join(" ")]} {[dataRowCls]}"', ' role\x3d"{rowRole}" {rowAttr:attributes}\x3e', '\x3ctpl for\x3d"columns"\x3e{%', 'parent.view.renderCell(values, parent.record, parent.recordIndex, parent.rowIndex, xindex - 1, out, parent)', 
'%}', '\x3c/tpl\x3e', '\x3c/tr\x3e', {priority:0}], cellTpl:['\x3ctd class\x3d"{tdCls}" {tdAttr} {cellAttr:attributes}', ' style\x3d"width:{column.cellWidth}px;', '{% if(values.tdStyle){out.push(values.tdStyle);}%}"', '{% if (values.column.cellFocusable \x3d\x3d\x3d false) {%}', ' role\x3d"presentation"', '{% } else { %}', ' role\x3d"{cellRole}" tabindex\x3d"-1"', '{% } %}', '  data-columnid\x3d"{[values.column.getItemId()]}"\x3e', '\x3cdiv {unselectableAttr} class\x3d"x-grid-cell-inner {innerCls}" ', 
'style\x3d"text-align:{align};', '{% if (values.style) {out.push(values.style);} %}" ', '{cellInnerAttr:attributes}\x3e{value}\x3c/div\x3e', '\x3c/td\x3e', {priority:0}], refreshSelmodelOnRefresh:false, scrollableType:'table', tableValues:{}, rowValues:{itemClasses:[], rowClasses:[]}, cellValues:{classes:['x-grid-cell x-grid-td']}, constructor:function(config) {
  if (config.grid.isTree) {
    config.baseCls = 'x-tree-view';
  }
  Ext.view.View.prototype.constructor.call(this, config);
}, hasVariableRowHeight:function(fromLockingPartner) {
  var me = this;
  return me.variableRowHeight || me.store.isGrouped() || me.getVisibleColumnManager().hasVariableRowHeight() || !fromLockingPartner && me.lockingPartner && me.lockingPartner.hasVariableRowHeight(true);
}, initComponent:function() {
  var me = this;
  if (me.columnLines) {
    me.addCls(me.grid.colLinesCls);
  }
  if (me.rowLines) {
    me.addCls(me.grid.rowLinesCls);
  }
  me.body = new Ext.dom.Fly;
  me.body.id = me.id + 'gridBody';
  if (!me.trackOver) {
    me.overItemCls = null;
  }
  me.headerCt.view = me;
  me.grid.view = me;
  me.initFeatures(me.grid);
  me.itemSelector = me.getItemSelector();
  me.all = new Ext.view.NodeCache(me);
  me.actionRowFly = new Ext.dom.Fly;
  Ext.view.View.prototype.initComponent.call(this);
}, applySelectionModel:function(selModel, oldSelModel) {
  var me = this, grid = me.ownerGrid, defaultType = selModel.type, disableSelection = me.disableSelection || grid.disableSelection;
  if (!oldSelModel) {
    if (!(selModel && selModel.isSelectionModel)) {
      selModel = grid.selModel || selModel;
    }
  }
  if (selModel) {
    if (selModel.isSelectionModel) {
      selModel.allowDeselect = grid.allowDeselect || selModel.selectionMode !== 'SINGLE';
      selModel.locked = disableSelection;
    } else {
      if (typeof selModel === 'string') {
        selModel = {type:selModel};
      } else {
        selModel.type = grid.selType || selModel.selType || selModel.type || defaultType;
      }
      if (!selModel.mode) {
        if (grid.simpleSelect) {
          selModel.mode = 'SIMPLE';
        } else {
          if (grid.multiSelect) {
            selModel.mode = 'MULTI';
          }
        }
      }
      selModel = Ext.Factory.selection(Ext.apply({allowDeselect:grid.allowDeselect, locked:disableSelection}, selModel));
    }
  }
  return selModel;
}, updateSelectionModel:function(selModel, oldSelModel) {
  var me = this;
  if (oldSelModel) {
    oldSelModel.un({scope:me, lastselectedchanged:me.updateBindSelection, selectionchange:me.updateBindSelection});
    Ext.destroy(me.selModelRelayer);
  }
  me.selModelRelayer = me.relayEvents(selModel, ['selectionchange', 'beforeselect', 'beforedeselect', 'select', 'deselect', 'focuschange']);
  selModel.on({scope:me, lastselectedchanged:me.updateBindSelection, selectionchange:me.updateBindSelection});
  me.selModel = selModel;
}, getVisibleColumnManager:function() {
  return this.ownerCt.getVisibleColumnManager();
}, getColumnManager:function() {
  return this.ownerCt.getColumnManager();
}, getTopLevelVisibleColumnManager:function() {
  return this.ownerGrid.getVisibleColumnManager();
}, moveColumn:function(fromIdx, toIdx, colsToMove) {
  var me = this, multiMove = colsToMove > 1, range = multiMove && document.createRange ? document.createRange() : null, fragment = multiMove && !range ? document.createDocumentFragment() : null, destinationCellIdx = toIdx, colCount = me.getGridColumns().length, lastIndex = colCount - 1, doFirstLastClasses = (me.firstCls || me.lastCls) && (toIdx === 0 || toIdx === colCount || fromIdx === 0 || fromIdx === lastIndex), i, j, rows, len, tr, cells, colGroups;
  if (me.rendered && toIdx !== fromIdx) {
    rows = me.el.query(me.rowSelector);
    for (i = 0, len = rows.length; i < len; i++) {
      tr = rows[i];
      cells = tr.childNodes;
      if (doFirstLastClasses) {
        if (cells.length === 1) {
          Ext.fly(cells[0]).addCls(me.firstCls);
          Ext.fly(cells[0]).addCls(me.lastCls);
          continue;
        }
        if (fromIdx === 0) {
          Ext.fly(cells[0]).removeCls(me.firstCls);
          Ext.fly(cells[1]).addCls(me.firstCls);
        } else {
          if (fromIdx === lastIndex) {
            Ext.fly(cells[lastIndex]).removeCls(me.lastCls);
            Ext.fly(cells[lastIndex - 1]).addCls(me.lastCls);
          }
        }
        if (toIdx === 0) {
          Ext.fly(cells[0]).removeCls(me.firstCls);
          Ext.fly(cells[fromIdx]).addCls(me.firstCls);
        } else {
          if (toIdx === colCount) {
            Ext.fly(cells[lastIndex]).removeCls(me.lastCls);
            Ext.fly(cells[fromIdx]).addCls(me.lastCls);
          }
        }
      }
      if (multiMove) {
        if (range) {
          range.setStartBefore(cells[fromIdx]);
          range.setEndAfter(cells[fromIdx + colsToMove - 1]);
          fragment = range.extractContents();
        } else {
          for (j = 0; j < colsToMove; j++) {
            fragment.appendChild(cells[fromIdx]);
          }
        }
        tr.insertBefore(fragment, cells[destinationCellIdx] || null);
      } else {
        tr.insertBefore(cells[fromIdx], cells[destinationCellIdx] || null);
      }
    }
    colGroups = me.el.query('colgroup');
    for (i = 0, len = colGroups.length; i < len; i++) {
      tr = colGroups[i];
      if (multiMove) {
        if (range) {
          range.setStartBefore(tr.childNodes[fromIdx]);
          range.setEndAfter(tr.childNodes[fromIdx + colsToMove - 1]);
          fragment = range.extractContents();
        } else {
          for (j = 0; j < colsToMove; j++) {
            fragment.appendChild(tr.childNodes[fromIdx]);
          }
        }
        tr.insertBefore(fragment, tr.childNodes[destinationCellIdx] || null);
      } else {
        tr.insertBefore(tr.childNodes[fromIdx], tr.childNodes[destinationCellIdx] || null);
      }
    }
  }
}, scrollToTop:Ext.emptyFn, addElListener:function(eventName, fn, scope) {
  this.mon(this, eventName, fn, scope, {element:'el'});
}, getGridColumns:function() {
  return this.ownerCt.getVisibleColumnManager().getColumns();
}, getHeaderAtIndex:function(index) {
  return this.ownerCt.getVisibleColumnManager().getHeaderAtIndex(index);
}, getCell:function(record, column, returnElement) {
  var row = this.getRow(record), cell;
  if (row) {
    if (typeof column === 'number') {
      column = this.getHeaderAtIndex(column);
    }
    cell = row.querySelector(column.getCellSelector());
    return returnElement ? Ext.get(cell) : cell;
  }
}, getFeature:function(id) {
  var features = this.featuresMC;
  if (features) {
    return features.get(id);
  }
}, findFeature:function(ftype) {
  if (this.features) {
    return Ext.Array.findBy(this.features, function(feature) {
      if (feature.ftype === ftype) {
        return true;
      }
    });
  }
}, initFeatures:function(grid) {
  var me = this, i, features, feature, len;
  me.tpl = this.lookupTpl('tpl');
  me.rowTpl = me.lookupTpl('rowTpl');
  me.addRowTpl(me.lookupTpl('outerRowTpl'));
  me.cellTpl = me.lookupTpl('cellTpl');
  me.featuresMC = new Ext.util.MixedCollection;
  features = me.features = me.constructFeatures();
  len = features ? features.length : 0;
  for (i = 0; i < len; i++) {
    feature = features[i];
    feature.view = me;
    feature.grid = grid;
    me.featuresMC.add(feature);
    feature.init(grid);
  }
}, renderTHead:function(values, out, parent) {
  var headers = values.view.headerFns, len, i;
  if (headers) {
    for (i = 0, len = headers.length; i < len; ++i) {
      headers[i].call(this, values, out, parent);
    }
  }
}, addHeaderFn:function(fn) {
  var headers = this.headerFns;
  if (!headers) {
    headers = this.headerFns = [];
  }
  headers.push(fn);
}, renderTFoot:function(values, out, parent) {
  var footers = values.view.footerFns, len, i;
  if (footers) {
    for (i = 0, len = footers.length; i < len; ++i) {
      footers[i].call(this, values, out, parent);
    }
  }
}, addFooterFn:function(fn) {
  var footers = this.footerFns;
  if (!footers) {
    footers = this.footerFns = [];
  }
  footers.push(fn);
}, addTpl:function(newTpl) {
  return this.insertTpl('tpl', newTpl);
}, addRowTpl:function(newTpl) {
  return this.insertTpl('rowTpl', newTpl);
}, addCellTpl:function(newTpl) {
  return this.insertTpl('cellTpl', newTpl);
}, insertTpl:function(which, newTpl) {
  var me = this, tpl, prevTpl;
  if (newTpl.isTemplate) {
    newTpl = Ext.Object.chain(newTpl);
  } else {
    newTpl = new Ext.XTemplate('{%this.nextTpl.applyOut(values, out, parent);%}', newTpl);
  }
  for (tpl = me[which]; newTpl.priority < tpl.priority; tpl = tpl.nextTpl) {
    prevTpl = tpl;
  }
  if (prevTpl) {
    prevTpl.nextTpl = newTpl;
  } else {
    me[which] = newTpl;
  }
  newTpl.nextTpl = tpl;
  return newTpl;
}, tplApplyOut:function(values, out, parent) {
  if (this.before) {
    if (this.before(values, out, parent) === false) {
      return;
    }
  }
  this.nextTpl.applyOut(values, out, parent);
  if (this.after) {
    this.after(values, out, parent);
  }
}, constructFeatures:function() {
  var me = this, features = me.features, feature, result, i = 0, len;
  if (features) {
    result = [];
    len = features.length;
    for (; i < len; i++) {
      feature = features[i];
      if (!feature.isFeature) {
        feature = Ext.create('feature.' + feature.ftype, feature);
      }
      result[i] = feature;
    }
  }
  return result;
}, beforeRender:function() {
  Ext.view.View.prototype.beforeRender.call(this);
  if (!this.enableTextSelection) {
    this.protoEl.unselectable();
  }
}, updateScrollable:function(scrollable) {
  var me = this, ownerGrid = me.grid.ownerGrid;
  if (!ownerGrid.lockable && scrollable.isScroller && scrollable !== ownerGrid.scrollable) {
    ownerGrid.scrollable = scrollable;
  }
}, afterComponentLayout:function(width, height, oldWidth, oldHeight) {
  var me = this, ownerGrid = me.grid.ownerGrid;
  if (ownerGrid.mixins.lockable) {
    ownerGrid.syncLockableLayout();
  }
  Ext.view.View.prototype.afterComponentLayout.call(this, width, height, oldWidth, oldHeight);
}, getElConfig:function() {
  var config = Ext.view.View.prototype.getElConfig.call(this);
  delete config['aria-hidden'];
  delete config['aria-disabled'];
  return config;
}, onBindStore:function(store) {
  var me = this, bufferedRenderer = me.bufferedRenderer;
  if (bufferedRenderer && bufferedRenderer.store !== store) {
    bufferedRenderer.bindStore(store);
  }
  if (me.all && me.all.getCount() && !me.grid.reconfiguring) {
    me.clearViewEl(true);
  }
  Ext.view.View.prototype.onBindStore.apply(this, arguments);
}, onOwnerGridHide:function() {
  var scroller = this.getScrollable(), bufferedRenderer = this.bufferedRederer;
  if (scroller) {
    scroller.suspendPartnerSync();
  }
  if (bufferedRenderer) {
    bufferedRenderer.disable();
  }
}, onOwnerGridShow:function() {
  var scroller = this.getScrollable(), bufferedRenderer = this.bufferedRederer;
  if (scroller) {
    scroller.resumePartnerSync();
  }
  if (bufferedRenderer) {
    bufferedRenderer.enable();
  }
}, getStoreListeners:function(store) {
  var me = this, result = Ext.view.View.prototype.getStoreListeners.call(this, store), dataSource = me.dataSource;
  if (dataSource && dataSource.isFeatureStore) {
    delete result.add;
    delete result.remove;
  }
  if (me.bufferedRenderer) {
    delete result.clear;
  }
  result.beforepageremove = me.beforePageRemove;
  return result;
}, beforePageRemove:function(pageMap, pageNumber) {
  var rows = this.all, pageSize = pageMap.getPageSize();
  if (rows.startIndex >= (pageNumber - 1) * pageSize && rows.endIndex <= pageNumber * pageSize - 1) {
    pageMap.get(pageNumber);
    return false;
  }
}, onViewScroll:function(scroller, x, y) {
  if (!this.destroyed && !this.ignoreScroll) {
    Ext.view.View.prototype.onViewScroll.call(this, scroller, x, y);
  }
}, createRowElement:function(record, index, updateColumns) {
  var me = this, div = me.renderBuffer, tplData = me.collectData([record], index), result;
  tplData.columns = updateColumns;
  me.tpl.overwrite(div, tplData);
  me.cleanupData();
  result = div.dom.querySelector(me.getNodeContainerSelector()).firstChild;
  Ext.fly(result).saveTabbableState(me.saveTabOptions);
  return result;
}, bufferRender:function(records, index) {
  var me = this, div = me.renderBuffer, result, range = document.createRange ? document.createRange() : null;
  me.tpl.overwrite(div, me.collectData(records, index));
  me.cleanupData();
  div.saveTabbableState(me.saveTabOptions);
  div = div.dom.querySelector(me.getNodeContainerSelector());
  if (range) {
    range.selectNodeContents(div);
    result = range.extractContents();
  } else {
    result = document.createDocumentFragment();
    while (div.firstChild) {
      result.appendChild(div.firstChild);
    }
  }
  return {fragment:result, children:Ext.Array.toArray(result.childNodes)};
}, collectData:function(records, startIndex) {
  var me = this, tableValues = me.tableValues;
  me.rowValues.view = me;
  tableValues.view = me;
  tableValues.rows = records;
  tableValues.columns = null;
  tableValues.viewStartIndex = startIndex;
  tableValues.tableStyle = 'width:' + me.headerCt.getTableWidth() + 'px';
  return tableValues;
}, cleanupData:function() {
  var tableValues = this.tableValues;
  tableValues.view = tableValues.columns = tableValues.rows = this.rowValues.view = null;
}, refreshSize:function(forceLayout) {
  var me = this, bodySelector = me.getBodySelector(), lockingPartner = me.lockingPartner, restoreFocus;
  if (!me.actionableMode) {
    restoreFocus = me.saveFocusState();
  }
  if (bodySelector) {
    me.body.attach(me.el.dom.querySelector(bodySelector));
  }
  if (!me.hasLoadingHeight) {
    Ext.suspendLayouts();
    Ext.view.View.prototype.refreshSize.call(this, forceLayout);
    if (forceLayout || me.hasVariableRowHeight() && me.dataSource.getCount()) {
      me.grid.updateLayout();
    }
    Ext.resumeLayouts(!lockingPartner || !lockingPartner.grid.isVisible() || lockingPartner.all.getCount() === me.all.getCount());
    if (restoreFocus) {
      restoreFocus();
    }
  }
}, isLayoutRoot:function() {
  return false;
}, clearViewEl:function(leaveNodeContainer) {
  var me = this, nodeContainer;
  if (me.rendered) {
    Ext.view.View.prototype.clearViewEl.call(this);
    if (!leaveNodeContainer) {
      nodeContainer = Ext.get(me.getNodeContainer());
      if (nodeContainer && nodeContainer.dom !== me.getTargetEl().dom) {
        nodeContainer.destroy();
      }
    }
  }
}, getRefItems:function(deep) {
  var me = this, rowContexts = me.ownerGrid.liveRowContexts, isLocked = !!me.isLockedView, result = Ext.view.View.prototype.getRefItems.call(this, deep), widgetCount, i, widgets, widget, recordId;
  for (recordId in rowContexts) {
    widgets = rowContexts[recordId].getWidgets();
    widgetCount = widgets.length;
    for (i = 0; i < widgetCount; i++) {
      widget = widgets[i];
      if (isLocked === widget.$fromLocked) {
        result[result.length] = widget;
        if (deep && widget.getRefItems) {
          result.push.apply(result, widget.getRefItems(true));
        }
      }
    }
  }
  return result;
}, getMaskTarget:function() {
  return this.ownerCt.body;
}, statics:{getBoundView:function(node) {
  return Ext.getCmp(node.getAttribute('data-boundView'));
}}, getRecord:function(node) {
  if (this.store.destroyed) {
    return;
  }
  if (node.isModel) {
    return node;
  }
  node = this.getNode(node);
  if (node) {
    return this.dataSource.getByInternalId(node.getAttribute('data-recordId'));
  }
}, indexOf:function(node) {
  node = this.getNode(node);
  if (!node && node !== 0) {
    return -1;
  }
  return this.all.indexOf(node);
}, indexInStore:function(node) {
  return node ? this.dataSource.indexOf(this.getRecord(node)) : -1;
}, indexOfRow:function(record) {
  var dataSource = this.dataSource, idx;
  if (record.isCollapsedPlaceholder) {
    idx = dataSource.indexOfPlaceholder(record);
  } else {
    idx = dataSource.indexOf(record);
  }
  return idx;
}, renderRows:function(rows, columns, viewStartIndex, out) {
  var me = this, rowValues = me.rowValues, rowCount = rows.length, i;
  rowValues.view = me;
  rowValues.columns = columns;
  rowValues.rowRole = me.rowAriaRole;
  me.cellValues.cellRole = me.cellAriaRole;
  for (i = 0; i < rowCount; i++, viewStartIndex++) {
    rowValues.itemClasses.length = rowValues.rowClasses.length = 0;
    me.renderRow(rows[i], viewStartIndex, out);
  }
  rowValues.view = rowValues.columns = rowValues.record = null;
}, renderColumnSizer:function(values, out) {
  var columns = values.columns || this.getGridColumns(), len = columns.length, i, column, width;
  out.push('\x3ccolgroup role\x3d"presentation"\x3e');
  for (i = 0; i < len; i++) {
    column = columns[i];
    width = column.cellWidth ? column.cellWidth : Ext.grid.header.Container.prototype.defaultWidth;
    out.push('\x3ccol role\x3d"presentation" class\x3d"', 'x-', 'grid-cell-', columns[i].getItemId(), '" style\x3d"width:' + width + 'px"\x3e');
  }
  out.push('\x3c/colgroup\x3e');
}, renderRow:function(record, rowIdx, out) {
  var me = this, isMetadataRecord = rowIdx === -1, selModel = me.selectionModel, rowValues = me.rowValues, itemClasses = rowValues.itemClasses, rowClasses = rowValues.rowClasses, itemCls = me.itemCls, cls, rowTpl = me.rowTpl;
  rowValues.rowAttr = {};
  rowValues.record = record;
  rowValues.recordId = record.internalId;
  rowValues.recordIndex = me.store.indexOf(record);
  rowValues.rowIndex = rowIdx;
  rowValues.rowId = me.getRowId(record);
  rowValues.itemCls = rowValues.rowCls = '';
  if (!rowValues.columns) {
    rowValues.columns = me.ownerCt.getVisibleColumnManager().getColumns();
  }
  itemClasses.length = rowClasses.length = 0;
  if (!isMetadataRecord) {
    itemClasses[0] = itemCls;
    if (!me.ownerCt.disableSelection && selModel.isRowSelected) {
      if (selModel.isRowSelected(record)) {
        itemClasses.push(me.selectedItemCls);
      }
    }
    if (me.stripeRows && rowIdx % 2 !== 0) {
      itemClasses.push(me.altRowCls);
    }
    if (me.getRowClass) {
      cls = me.getRowClass(record, rowIdx, null, me.dataSource);
      if (cls) {
        rowClasses.push(cls);
      }
    }
  }
  if (out) {
    rowTpl.applyOut(rowValues, out, me.tableValues);
  } else {
    return rowTpl.apply(rowValues, me.tableValues);
  }
}, renderCell:function(column, record, recordIndex, rowIndex, columnIndex, out) {
  var me = this, renderer = column.renderer, fullIndex, selModel = me.selectionModel, cellValues = me.cellValues, classes = cellValues.classes, fieldValue = record.data[column.dataIndex], cellTpl = me.cellTpl, enableTextSelection = column.enableTextSelection, value, clsInsertPoint, lastFocused = me.navigationModel.getPosition();
  if (enableTextSelection == null) {
    enableTextSelection = me.enableTextSelection;
  }
  cellValues.record = record;
  cellValues.column = column;
  cellValues.recordIndex = recordIndex;
  cellValues.rowIndex = rowIndex;
  cellValues.columnIndex = cellValues.cellIndex = columnIndex;
  cellValues.align = column.textAlign;
  cellValues.innerCls = column.innerCls;
  cellValues.tdCls = cellValues.tdStyle = cellValues.tdAttr = cellValues.style = '';
  cellValues.unselectableAttr = enableTextSelection ? '' : 'unselectable\x3d"on"';
  classes[1] = column.getCellId();
  clsInsertPoint = 2;
  if (renderer && renderer.call) {
    fullIndex = renderer.length > 4 ? me.ownerCt.columnManager.getHeaderIndex(column) : columnIndex;
    value = renderer.call(column.usingDefaultRenderer ? column : column.scope || me.ownerCt, fieldValue, cellValues, record, recordIndex, fullIndex, me.dataSource, me);
    if (cellValues.css) {
      record.cssWarning = true;
      cellValues.tdCls += ' ' + cellValues.css;
      cellValues.css = null;
    }
    if (cellValues.tdCls) {
      classes[clsInsertPoint++] = cellValues.tdCls;
    }
  } else {
    value = fieldValue;
  }
  cellValues.value = value == null || value.length === 0 ? column.emptyCellText : value;
  if (column.tdCls) {
    classes[clsInsertPoint++] = column.tdCls;
  }
  if (me.markDirty && record.dirty && record.isModified(column.dataIndex)) {
    classes[clsInsertPoint++] = me.dirtyCls;
    if (column.dirtyTextElementId) {
      cellValues.tdAttr = (cellValues.tdAttr ? cellValues.tdAttr + ' ' : '') + 'aria-describedby\x3d"' + column.dirtyTextElementId + '"';
    }
  }
  if (column.isFirstVisible) {
    classes[clsInsertPoint++] = me.firstCls;
  }
  if (column.isLastVisible) {
    classes[clsInsertPoint++] = me.lastCls;
  }
  if (!enableTextSelection) {
    classes[clsInsertPoint++] = me.unselectableCls;
  }
  if (selModel && (selModel.isCellModel || selModel.isSpreadsheetModel) && selModel.isCellSelected(me, recordIndex, column)) {
    classes[clsInsertPoint++] = me.selectedCellCls;
  }
  if (lastFocused && lastFocused.record.id === record.id && lastFocused.column === column) {
    classes[clsInsertPoint++] = me.focusedItemCls;
  }
  classes.length = clsInsertPoint;
  cellValues.tdCls = classes.join(' ');
  cellTpl.applyOut(cellValues, out);
  cellValues.column = cellValues.record = null;
}, getRow:function(nodeInfo) {
  var me = this, rowSelector = me.rowSelector;
  if (!nodeInfo && nodeInfo !== 0 || !me.rendered) {
    return null;
  }
  if (Ext.isString(nodeInfo)) {
    nodeInfo = Ext.getDom(nodeInfo);
    return nodeInfo && nodeInfo.querySelectorAll(rowSelector)[0];
  }
  if (Ext.isNumber(nodeInfo)) {
    nodeInfo = me.all.item(nodeInfo, true);
    return nodeInfo && nodeInfo.querySelectorAll(rowSelector)[0];
  }
  if (nodeInfo.isModel) {
    return me.getRowByRecord(nodeInfo);
  }
  nodeInfo = Ext.fly(nodeInfo.target || nodeInfo);
  if (nodeInfo.is(me.itemSelector)) {
    return me.getRowFromItem(nodeInfo);
  }
  return nodeInfo.findParent(rowSelector, me.getTargetEl());
}, getRowId:function(record) {
  return this.id + '-record-' + record.internalId;
}, constructRowId:function(internalId) {
  return this.id + '-record-' + internalId;
}, getNodeById:function(id) {
  id = this.constructRowId(id);
  return this.retrieveNode(id, false);
}, getRowById:function(id) {
  id = this.constructRowId(id);
  return this.retrieveNode(id, true);
}, getNodeByRecord:function(record) {
  return this.retrieveNode(this.getRowId(record), false);
}, getRowByRecord:function(record) {
  return this.retrieveNode(this.getRowId(record), true);
}, getRowFromItem:function(item) {
  var rows = Ext.getDom(item).tBodies[0].childNodes, len = rows.length, i;
  for (i = 0; i < len; i++) {
    if (Ext.fly(rows[i]).is(this.rowSelector)) {
      return rows[i];
    }
  }
}, retrieveNode:function(id, dataRow) {
  var result = this.el.getById(id, true);
  if (dataRow && result) {
    return result.querySelector(this.rowSelector, true);
  }
  return result;
}, updateIndexes:Ext.emptyFn, bodySelector:'div.x-grid-item-container', nodeContainerSelector:'div.x-grid-item-container', itemSelector:'table.x-grid-item', rowSelector:'tr.x-grid-row', cellSelector:'td.x-grid-cell', sizerSelector:'.x-grid-cell', innerSelector:'div.x-grid-cell-inner', getBodySelector:function() {
  return this.bodySelector;
}, getColumnSizerSelector:function(header) {
  var selector = this.sizerSelector + '-' + header.getItemId();
  return 'td' + selector + ',col' + selector;
}, getItemSelector:function() {
  return this.itemSelector;
}, getCellSelector:function(header) {
  return header ? header.getCellSelector() : this.cellSelector;
}, getCellInnerSelector:function(header) {
  return this.getCellSelector(header) + ' ' + this.innerSelector;
}, addRowCls:function(rowInfo, cls) {
  var row = this.getRow(rowInfo);
  if (row) {
    Ext.fly(row).addCls(cls);
  }
}, removeRowCls:function(rowInfo, cls) {
  var row = this.getRow(rowInfo);
  if (row) {
    Ext.fly(row).removeCls(cls);
  }
}, onRowSelect:function(rowIdx) {
  var me = this, rowNode;
  me.addItemCls(rowIdx, me.selectedItemCls);
  rowNode = me.getRow(rowIdx);
  if (rowNode) {
    rowNode.setAttribute('aria-selected', true);
  }
  if (Ext.isIE8) {
    me.repaintBorder(rowIdx + 1);
  }
}, onRowDeselect:function(rowIdx) {
  var me = this, rowNode;
  me.removeItemCls(rowIdx, me.selectedItemCls);
  rowNode = me.getRow(rowIdx);
  if (rowNode) {
    rowNode.removeAttribute('aria-selected');
  }
  if (Ext.isIE8) {
    me.repaintBorder(rowIdx + 1);
  }
}, onCellSelect:function(position) {
  var cell = this.getCellByPosition(position, true);
  if (cell) {
    Ext.fly(cell).addCls(this.selectedCellCls);
    cell.setAttribute('aria-selected', true);
  }
}, onCellDeselect:function(position) {
  var cell = this.getCellByPosition(position, true);
  if (cell) {
    Ext.fly(cell).removeCls(this.selectedCellCls);
    cell.removeAttribute('aria-selected');
  }
}, getCellInclusive:function(position, returnDom) {
  if (position) {
    var row = this.getRow(position.row), header = this.ownerCt.getColumnManager().getHeaderAtIndex(position.column), cell;
    if (header && row) {
      cell = row.querySelector(this.getCellSelector(header));
      return returnDom ? cell : Ext.get(cell);
    }
  }
  return false;
}, getColumnByPosition:function(position) {
  var view, column;
  if (position) {
    column = position.column;
    if (column && !column.destroyed && column.isColumn) {
      return column;
    } else {
      view = position.view || this;
      column = typeof column === 'number' ? column : position.colIdx;
      return view.getVisibleColumnManager().getHeaderAtIndex(column);
    }
  }
  return false;
}, getCellByPosition:function(position, returnDom) {
  if (position) {
    var view = position.view || this, row = view.getRow(position.record || position.row), header, cell;
    header = view.getColumnByPosition(position);
    if (header && row) {
      cell = row.querySelector(view.getCellSelector(header));
      return returnDom ? cell : Ext.get(cell);
    }
  }
  return false;
}, onFocusEnter:function(e) {
  var me = this, fromComponent = e.fromComponent, navigationModel = me.getNavigationModel(), focusPosition, cell, focusTarget;
  if (me.containsFocus) {
    return Ext.Component.prototype.onFocusEnter.call(me, e);
  }
  if (me.actionableMode) {
    if (me.actionPosition) {
      me.el.dom.setAttribute('tabIndex', '-1');
      me.cellFocused = true;
      return;
    }
    me.ownerGrid.setActionableMode(false);
  }
  e = e.event;
  if (!me.cellFocused && me.all.getCount() && me.dataSource.getCount()) {
    focusTarget = e.getTarget();
    if (focusTarget === me.el.dom) {
      if (me.lastFocused === 'scrollbar') {
        if (e.relatedTarget) {
          e.relatedTarget.focus();
        }
        return;
      }
      focusPosition = me.getDefaultFocusPosition(fromComponent);
      if (!focusPosition) {
        e.stopEvent();
        me.el.focus();
        return;
      }
      focusTarget = null;
    } else {
      if (focusTarget === me.tabGuardEl) {
        focusPosition = (new Ext.grid.CellContext(me)).setPosition(me.all.endIndex, me.getVisibleColumnManager().getColumns().length - 1);
        focusTarget = null;
      } else {
        if (cell = e.getTarget(me.getCellSelector())) {
          if (focusTarget === cell) {
            focusPosition = (new Ext.grid.CellContext(me)).setPosition(me.getRecord(focusTarget), me.getHeaderByCell(cell));
            focusTarget = null;
          } else {
            if (focusTarget && Ext.fly(focusTarget).isFocusable() && me.el.contains(focusTarget)) {
              focusPosition = (new Ext.grid.CellContext(me)).setPosition(me.getRecord(focusTarget), me.getHeaderByCell(cell));
            }
          }
        }
      }
    }
  }
  if (focusPosition) {
    me.toggleChildrenTabbability(false);
    if (focusTarget) {
      focusPosition.target = focusTarget;
      if (me.ownerGrid.setActionableMode(true, focusPosition)) {
        focusPosition = null;
      }
    }
    if (focusPosition) {
      navigationModel.setPosition(focusPosition, null, e, null, true);
    }
    me.cellFocused = me.el.contains(Ext.Element.getActiveElement());
    if (me.cellFocused) {
      me.el.dom.setAttribute('tabIndex', '-1');
    }
  }
  Ext.Component.prototype.onFocusEnter.call(me, e);
}, onFocusLeave:function(e) {
  var me = this, isLeavingGrid;
  if (!me.destroying && !me.refreshing) {
    isLeavingGrid = !me.lockingPartner || !e.toComponent || e.toComponent !== me.lockingPartner && !me.lockingPartner.isAncestor(e.toComponent);
    if (me.cellFocused) {
      if (isLeavingGrid) {
        me.getNavigationModel().setPosition(null, null, e.event, null, true);
      }
      me.cellFocused = false;
      me.focusEl = me.el;
      me.focusEl.dom.setAttribute('tabIndex', 0);
    }
    if (isLeavingGrid) {
      if (me.ownerGrid.actionableMode) {
        me.lastFocused = me.actionPosition;
        me.ownerGrid.setActionableMode(false);
      }
    } else {
      me.actionPosition = null;
    }
    Ext.Component.prototype.onFocusLeave.call(me, e);
  }
}, onRowFocus:function(rowIdx, highlight, suppressFocus) {
  var me = this;
  if (highlight) {
    me.addItemCls(rowIdx, me.focusedItemCls);
    if (!suppressFocus) {
      me.focusRow(rowIdx);
    }
  } else {
    me.removeItemCls(rowIdx, me.focusedItemCls);
  }
  if (Ext.isIE8) {
    me.repaintBorder(rowIdx + 1);
  }
}, focusRow:function(row, delay) {
  var me = this, focusTask = me.getFocusTask();
  if (delay) {
    focusTask.delay(Ext.isNumber(delay) ? delay : 10, me.focusRow, me, [row, false]);
    return;
  }
  focusTask.cancel();
  if (me.isVisible(true)) {
    me.getNavigationModel().setPosition(me.getRecord(row));
  }
}, focusNode:function(row, delay) {
  this.focusRow(row, delay);
}, scrollRowIntoView:function(row, animate) {
  row = this.getRow(row);
  if (row) {
    this.scrollElIntoView(row, false, animate);
  }
}, focusCell:function(position, delay) {
  var me = this, cell, focusTask = me.getFocusTask();
  if (delay) {
    focusTask.delay(Ext.isNumber(delay) ? delay : 10, me.focusCell, me, [position, false]);
    return;
  }
  focusTask.cancel();
  if (me.isVisible(true) && (cell = me.getCellByPosition(position))) {
    me.getNavigationModel().setPosition(position);
  }
}, findFocusPosition:function(from, currentPosition, forward, keyEvent) {
  var me = this, cell = currentPosition.cellElement, actionables = me.ownerGrid.actionables, len = actionables.length, position, tabbableChildren, focusTarget, i;
  position = currentPosition.clone();
  tabbableChildren = Ext.fly(cell).findTabbableElements();
  focusTarget = tabbableChildren[Ext.Array.indexOf(tabbableChildren, from) + (forward ? 1 : -1)];
  while (!focusTarget && (cell = cell[forward ? 'nextSibling' : 'previousSibling'])) {
    position.setColumn(me.getHeaderByCell(cell));
    for (i = 0; i < len; i++) {
      actionables[i].activateCell(position);
    }
    cell = position.getCell(true);
    if (cell && (tabbableChildren = Ext.fly(cell).findTabbableElements()).length) {
      focusTarget = tabbableChildren[forward ? 0 : tabbableChildren.length - 1];
    }
  }
  return {target:focusTarget, position:position};
}, getDefaultFocusPosition:function(fromComponent) {
  var me = this, store = me.dataSource, focusPosition = me.lastFocused, newPosition = (new Ext.grid.CellContext(me)).setPosition(0, 0), targetCell, scroller;
  if (fromComponent) {
    if (fromComponent.isColumn && fromComponent.cellFocusable !== false) {
      if (!focusPosition) {
        focusPosition = newPosition;
      }
      focusPosition.setColumn(fromComponent);
      focusPosition.setView(fromComponent.getView());
    } else {
      if (fromComponent.isTableView && fromComponent.lastFocused && fromComponent.ownerGrid === me.ownerGrid) {
        focusPosition = (new Ext.grid.CellContext(me)).setPosition(fromComponent.lastFocused.record, 0);
      }
    }
  }
  if (focusPosition) {
    scroller = me.getScrollable();
    if (!store.contains(focusPosition.record) || scroller && !scroller.isInView(focusPosition.getRow(true)).y) {
      focusPosition.setRow(store.getAt(Math.min(focusPosition.rowIdx, store.getCount() - 1)));
    }
  } else {
    focusPosition = newPosition;
    targetCell = me.el.dom.querySelector(me.getCellSelector() + '[tabIndex\x3d"-1"]');
    if (targetCell) {
      focusPosition.setPosition(me.getRecord(targetCell), me.getHeaderByCell(targetCell));
    } else {
      focusPosition = null;
    }
  }
  return focusPosition;
}, getLastFocused:function() {
  var me = this, lastFocused = me.lastFocused;
  if (lastFocused && lastFocused.record && lastFocused.column) {
    if (me.dataSource.indexOf(lastFocused.record) !== -1 && me.getVisibleColumnManager().indexOf(lastFocused.column) !== -1 && me.getNode(lastFocused.record)) {
      return lastFocused;
    }
  }
}, scrollCellIntoView:function(cell, animate) {
  if (cell.isCellContext) {
    cell = this.getCellByPosition(cell);
  }
  if (cell) {
    this.scrollElIntoView(cell, null, animate);
  }
}, scrollElIntoView:function(el, hscroll, animate) {
  var scroller = this.getScrollable();
  if (scroller) {
    scroller.ensureVisible(el, {animation:animate, x:hscroll});
  }
}, syncRowHeightBegin:function() {
  var me = this, itemEls = me.all, ln = itemEls.count, synchronizer = [], RowSynchronizer = Ext.grid.locking.RowSynchronizer, i, j, rowSync;
  for (i = 0, j = itemEls.startIndex; i < ln; i++, j++) {
    synchronizer[i] = rowSync = new RowSynchronizer(me, itemEls.elements[j]);
    rowSync.reset();
  }
  return synchronizer;
}, syncRowHeightClear:function(synchronizer) {
  var me = this, itemEls = me.all, ln = itemEls.count, i;
  for (i = 0; i < ln; i++) {
    synchronizer[i].reset();
  }
}, syncRowHeightMeasure:function(synchronizer) {
  var ln = synchronizer.length, i;
  for (i = 0; i < ln; i++) {
    synchronizer[i].measure();
  }
}, syncRowHeightFinish:function(synchronizer, otherSynchronizer) {
  var ln = synchronizer.length, bufferedRenderer = this.bufferedRenderer, i;
  for (i = 0; i < ln; i++) {
    synchronizer[i].finish(otherSynchronizer[i]);
  }
  if (bufferedRenderer) {
    bufferedRenderer.syncRowHeightsFinish();
  }
}, refreshNode:function(record) {
  if (Ext.isNumber(record)) {
    record = this.store.getAt(record);
  }
  this.handleUpdate(this.dataSource, record, null, null, null, true);
}, handleUpdate:function(store, record, operation, changedFieldNames, info, allColumns) {
  var me = this, recordIndex = me.store.indexOf(record), rowTpl = me.rowTpl, markDirty = me.markDirty, dirtyCls = me.dirtyCls, columnsToUpdate = [], hasVariableRowHeight = me.variableRowHeight, updateTypeFlags = 0, ownerCt = me.ownerCt, cellFly = me.cellFly || (me.self.prototype.cellFly = new Ext.dom.Fly), oldItemDom, oldDataRow, newItemDom, newAttrs, attLen, attName, attrIndex, overItemCls, columns, column, len, i, cellUpdateFlag, cell, fieldName, value, clearDirty, defaultRenderer, scope, elData, 
  emptyValue;
  operation = operation || Ext.data.Model.EDIT;
  clearDirty = operation !== Ext.data.Model.EDIT;
  if (me.viewReady) {
    me.updatingRows = true;
    oldItemDom = me.getNodeByRecord(record);
    if (oldItemDom) {
      if (record.isCollapsedPlaceholder) {
        Ext.fly(oldItemDom).syncContent(me.createRowElement(record, me.indexOfRow(record)));
        return;
      }
      overItemCls = me.overItemCls;
      columns = me.ownerCt.getVisibleColumnManager().getColumns();
      if (allColumns) {
        columnsToUpdate = columns;
        updateTypeFlags = 1;
      } else {
        for (i = 0, len = columns.length; i < len; i++) {
          column = columns[i];
          if (column.preventUpdate) {
            cell = oldItemDom.querySelector(column.getCellSelector());
            if (cell && !clearDirty && markDirty) {
              cellFly.attach(cell);
              if (record.isModified(column.dataIndex)) {
                cellFly.addCls(dirtyCls);
                if (column.dirtyTextElementId) {
                  cell.setAttribute('aria-describedby', column.dirtyTextElementId);
                }
              } else {
                cellFly.removeCls(dirtyCls);
                cell.removeAttribute('aria-describedby');
              }
            }
          } else {
            cellUpdateFlag = me.shouldUpdateCell(record, column, changedFieldNames);
            if (cellUpdateFlag) {
              updateTypeFlags = updateTypeFlags | cellUpdateFlag;
              columnsToUpdate[columnsToUpdate.length] = column;
              hasVariableRowHeight = hasVariableRowHeight || column.variableRowHeight;
            }
          }
        }
      }
      if (me.hasListeners.beforeitemupdate) {
        me.fireEvent('beforeitemupdate', record, recordIndex, oldItemDom, columnsToUpdate);
      }
      if (me.getRowClass || !me.getRowFromItem(oldItemDom) || updateTypeFlags & 1 || oldItemDom.tBodies[0].childNodes.length > 1) {
        elData = oldItemDom._extData;
        newItemDom = me.createRowElement(record, me.indexOfRow(record), columnsToUpdate);
        if (Ext.fly(oldItemDom, '_internal').hasCls(overItemCls)) {
          Ext.fly(newItemDom).addCls(overItemCls);
        }
        if (Ext.isIE9m && oldItemDom.mergeAttributes) {
          oldItemDom.mergeAttributes(newItemDom, true);
        } else {
          newAttrs = newItemDom.attributes;
          attLen = newAttrs.length;
          for (attrIndex = 0; attrIndex < attLen; attrIndex++) {
            attName = newAttrs[attrIndex].name;
            value = newAttrs[attrIndex].value;
            if (attName !== 'id' && oldItemDom.getAttribute(attName) !== value) {
              oldItemDom.setAttribute(attName, value);
            }
          }
        }
        if (elData) {
          elData.isSynchronized = false;
        }
        if (columns.length && (oldDataRow = me.getRow(oldItemDom))) {
          me.updateColumns(oldDataRow, newItemDom.querySelector(me.rowSelector), columnsToUpdate, record);
        }
        while (rowTpl) {
          if (rowTpl.syncContent) {
            if (rowTpl.syncContent(oldItemDom, newItemDom, changedFieldNames ? columnsToUpdate : null) === false) {
              break;
            }
          }
          rowTpl = rowTpl.nextTpl;
        }
      } else {
        for (i = 0, len = columnsToUpdate.length; i < len; i++) {
          column = columnsToUpdate[i];
          fieldName = column.dataIndex;
          value = record.get(fieldName);
          cell = oldItemDom.querySelector(column.getCellSelector());
          cellFly.attach(cell);
          if (!clearDirty && markDirty) {
            if (record.isModified(column.dataIndex)) {
              cellFly.addCls(dirtyCls);
              if (column.dirtyTextElementId) {
                cell.setAttribute('aria-describedby', column.dirtyTextElementId);
              }
            } else {
              cellFly.removeCls(dirtyCls);
              cell.removeAttribute('aria-describedby');
            }
          }
          defaultRenderer = column.usingDefaultRenderer;
          scope = defaultRenderer ? column : column.scope;
          if (column.updater) {
            Ext.callback(column.updater, scope, [cell, value, record, me, me.dataSource], 0, column, ownerCt);
          } else {
            if (column.renderer) {
              value = Ext.callback(column.renderer, scope, [value, null, record, 0, 0, me.dataSource, me], 0, column, ownerCt);
            }
            emptyValue = value == null || value.length === 0;
            value = emptyValue ? column.emptyCellText : value;
            if (column.producesHTML || emptyValue) {
              cell.querySelector(me.innerSelector).innerHTML = value;
            } else {
              cell.querySelector(me.innerSelector).childNodes[0].data = value;
            }
          }
          if (me.highlightClass) {
            Ext.fly(cell).addCls(me.highlightClass);
            if (!me.changedCells) {
              me.self.prototype.changedCells = [];
              me.prototype.clearChangedTask = new Ext.util.DelayedTask(me.clearChangedCells, me.prototype);
              me.clearChangedTask.delay(me.unhighlightDelay);
            }
            me.changedCells.push({cell:cell, cls:me.highlightClass, expires:Ext.Date.now() + 1000});
          }
        }
      }
      if (clearDirty && markDirty && !record.dirty) {
        Ext.fly(oldItemDom, '_internal').select('.' + dirtyCls).removeCls(dirtyCls).set({'aria-describedby':undefined});
      }
      if (hasVariableRowHeight) {
        Ext.suspendLayouts();
      }
      if (me.hasListeners.itemupdate) {
        me.fireEvent('itemupdate', record, recordIndex, oldItemDom, me);
      }
      if (hasVariableRowHeight) {
        me.ownerGrid.updateLayout();
        Ext.resumeLayouts(true);
      }
    }
    me.updatingRows = false;
  }
}, clearChangedCells:function() {
  var me = this, now = Ext.Date.now(), changedCell;
  for (var i = 0, len = me.changedCells.length; i < len;) {
    changedCell = me.changedCells[i];
    if (changedCell.expires <= now) {
      Ext.fly(changedCell.cell).removeCls(changedCell.highlightClass);
      Ext.Array.erase(me.changedCells, i, 1);
      len--;
    } else {
      break;
    }
  }
  if (len) {
    me.clearChangedTask.delay(me.unhighlightDelay);
  }
}, updateColumns:function(oldRow, newRow, columnsToUpdate, record) {
  var me = this, newAttrs, attLen, attName, attrIndex, colCount = columnsToUpdate.length, colIndex, column, oldCell, newCell, cellSelector = me.getCellSelector(), elData, value;
  if (oldRow.mergeAttributes) {
    oldRow.mergeAttributes(newRow, true);
  } else {
    newAttrs = newRow.attributes;
    attLen = newAttrs.length;
    for (attrIndex = 0; attrIndex < attLen; attrIndex++) {
      attName = newAttrs[attrIndex].name;
      value = newAttrs[attrIndex].value;
      if (attName !== 'id' && oldRow.getAttribute(attName) !== value) {
        oldRow.setAttribute(attName, value);
      }
    }
  }
  elData = oldRow._extData;
  if (elData) {
    elData.isSynchronized = false;
  }
  for (colIndex = 0; colIndex < colCount; colIndex++) {
    column = columnsToUpdate[colIndex];
    cellSelector = me.getCellSelector(column);
    oldCell = oldRow.querySelector(cellSelector);
    newCell = newRow.querySelector(cellSelector);
    newAttrs = newCell.attributes;
    attLen = newAttrs.length;
    for (attrIndex = 0; attrIndex < attLen; attrIndex++) {
      attName = newAttrs[attrIndex].name;
      value = newAttrs[attrIndex].value;
      if (attName !== 'id' && oldCell.getAttribute(attName) !== value) {
        oldCell.setAttribute(attName, value);
      }
    }
    elData = oldCell._extData;
    if (elData) {
      elData.isSynchronized = false;
    }
    me.oldCellFly.attach(oldCell.querySelector(me.innerSelector)).syncContent(newCell.querySelector(me.innerSelector));
    if (record && column.onItemAdd) {
      column.onItemAdd([record]);
    }
  }
}, shouldUpdateCell:function(record, column, changedFieldNames) {
  return column.shouldUpdateCell(record, changedFieldNames);
}, refresh:function() {
  var me = this;
  if (me.destroying) {
    return;
  }
  if (me.getVisibleColumnManager().getColumns().length) {
    Ext.view.View.prototype.refresh.apply(this, arguments);
    me.headerCt.setSortState();
  } else {
    if (me.refreshCounter) {
      me.clearViewEl(true);
    }
    me.addEmptyText();
  }
}, processContainerEvent:function(e) {
  var cmp = Ext.Component.from(e.target.parentNode);
  if (cmp && cmp.up(this.ownerCt)) {
    return false;
  }
}, processItemEvent:function(record, item, rowIndex, e) {
  var me = this, self = me.self, map = self.EventMap, type = e.type, features = me.features, len = features.length, i, cellIndex, result, feature, column, eventPosition = e.position = me.eventPosition || (me.eventPosition = new Ext.grid.CellContext), row, cell;
  if (Ext.isIE && type === 'mouseup' && !e.within(me.el)) {
    return false;
  }
  if (me.indexInStore(item) !== -1) {
    row = eventPosition.rowElement = item.querySelector(me.rowSelector);
    cell = e.getTarget(me.getCellSelector(), row);
    type = self.TouchEventMap[type] || type;
    if (cell) {
      if (!cell.parentNode) {
        return false;
      }
      column = me.getHeaderByCell(cell);
      if (column) {
        cellIndex = me.ownerCt.getColumnManager().getHeaderIndex(column);
      } else {
        column = cell = null;
        cellIndex = -1;
      }
    } else {
      cellIndex = -1;
    }
    eventPosition.setAll(me, rowIndex, column ? me.getVisibleColumnManager().getHeaderIndex(column) : -1, record, column);
    eventPosition.cellElement = cell;
    result = me.fireEvent('uievent', type, me, cell, rowIndex, cellIndex, e, record, row);
    if (result === false || Ext.view.View.prototype.processItemEvent.apply(this, arguments) === false) {
      return false;
    }
    for (i = 0; i < len; ++i) {
      feature = features[i];
      if (feature.wrapsItem) {
        if (feature.vetoEvent(record, row, rowIndex, e) === false) {
          me.processSpecialEvent(e);
          return false;
        }
      }
    }
    if (cell && type !== 'mouseover' && type !== 'mouseout') {
      result = !(me['onBeforeCell' + map[type]](cell, cellIndex, record, row, rowIndex, e) === false || me.fireEvent('beforecell' + type, me, cell, cellIndex, record, row, rowIndex, e) === false || me['onCell' + map[type]](cell, cellIndex, record, row, rowIndex, e) === false || me.fireEvent('cell' + type, me, cell, cellIndex, record, row, rowIndex, e) === false);
    }
    if (result !== false) {
      result = me.fireEvent('row' + type, me, record, row, rowIndex, e);
    }
    return result;
  } else {
    me.processSpecialEvent(e);
    if (e.pointerType === 'mouse') {
      e.preventDefault();
    }
    return false;
  }
}, processSpecialEvent:function(e) {
  var me = this, features = me.features, ln = features.length, type = e.type, i, feature, prefix, featureTarget, beforeArgs, args, panel = me.ownerCt;
  Ext.view.View.prototype.processSpecialEvent.apply(this, arguments);
  if (type === 'mouseover' || type === 'mouseout') {
    return;
  }
  type = me.self.TouchEventMap[type] || type;
  for (i = 0; i < ln; i++) {
    feature = features[i];
    if (feature.hasFeatureEvent) {
      featureTarget = e.getTarget(feature.eventSelector, me.getTargetEl());
      if (featureTarget) {
        prefix = feature.eventPrefix;
        beforeArgs = feature.getFireEventArgs('before' + prefix + type, me, featureTarget, e);
        args = feature.getFireEventArgs(prefix + type, me, featureTarget, e);
        if (me.fireEvent.apply(me, beforeArgs) === false || panel.fireEvent.apply(panel, beforeArgs) === false || me.fireEvent.apply(me, args) === false || panel.fireEvent.apply(panel, args) === false) {
          return false;
        }
      }
    }
  }
  return true;
}, onCellMouseDown:Ext.emptyFn, onCellLongPress:Ext.emptyFn, onCellMouseUp:Ext.emptyFn, onCellClick:Ext.emptyFn, onCellDblClick:Ext.emptyFn, onCellContextMenu:Ext.emptyFn, onCellKeyDown:Ext.emptyFn, onCellKeyUp:Ext.emptyFn, onCellKeyPress:Ext.emptyFn, onBeforeCellMouseDown:Ext.emptyFn, onBeforeCellLongPress:Ext.emptyFn, onBeforeCellMouseUp:Ext.emptyFn, onBeforeCellClick:Ext.emptyFn, onBeforeCellDblClick:Ext.emptyFn, onBeforeCellContextMenu:Ext.emptyFn, onBeforeCellKeyDown:Ext.emptyFn, onBeforeCellKeyUp:Ext.emptyFn, 
onBeforeCellKeyPress:Ext.emptyFn, expandToFit:function(header) {
  this.autoSizeColumn(header);
}, autoSizeColumn:function(header) {
  if (Ext.isNumber(header)) {
    header = this.getGridColumns()[header];
  }
  if (header) {
    if (header.isGroupHeader) {
      header.autoSize();
      return;
    }
    delete header.flex;
    header.setWidth(this.getMaxContentWidth(header));
  }
}, getMaxContentWidth:function(header) {
  var me = this, cells = me.el.query(header.getCellInnerSelector()), originalWidth = header.getWidth(), i = 0, ln = cells.length, columnSizer = me.body.select(me.getColumnSizerSelector(header)), max = Math.max, widthAdjust = 0, maxWidth;
  if (ln > 0) {
    if (Ext.supports.ScrollWidthInlinePaddingBug) {
      widthAdjust += me.getCellPaddingAfter(cells[0]);
    }
    if (me.columnLines) {
      widthAdjust += Ext.fly(cells[0].parentNode).getBorderWidth('lr');
    }
  }
  columnSizer.setWidth(1);
  header.textEl.setStyle({'text-overflow':'clip', display:'table-cell'});
  maxWidth = header.textEl.dom.offsetWidth + header.titleEl.getPadding('lr');
  header.textEl.setStyle({'text-overflow':'', display:''});
  for (; i < ln; i++) {
    maxWidth = max(maxWidth, cells[i].scrollWidth);
  }
  maxWidth += widthAdjust;
  maxWidth = max(maxWidth + 1, 40);
  columnSizer.setWidth(originalWidth);
  return maxWidth;
}, getPositionByEvent:function(e) {
  var me = this, cellNode = e.getTarget(me.cellSelector), rowNode = e.getTarget(me.itemSelector), record = me.getRecord(rowNode), header = me.getHeaderByCell(cellNode);
  return me.getPosition(record, header);
}, getHeaderByCell:function(cell) {
  if (cell) {
    return this.ownerGrid.getVisibleColumnManager().getHeaderById(Ext.getDom(cell).getAttribute('data-columnId'));
  }
  return false;
}, walkCells:function(pos, direction, verifierFn, scope) {
  var me = this, result = pos.clone(), lockingPartner = me.lockingPartner && me.lockingPartner.grid.isVisible() ? me.lockingPartner : null, rowIdx = pos.rowIdx, maxRowIdx = me.dataSource.getCount() - 1, columns = me.ownerCt.getVisibleColumnManager().getColumns();
  switch(direction.toLowerCase()) {
    case 'right':
      if (pos.isLastColumn()) {
        rowIdx = lockingPartner && me.isLockedView ? rowIdx : rowIdx + 1;
        if (rowIdx > maxRowIdx) {
          return false;
        }
        if (lockingPartner) {
          result.view = lockingPartner;
        }
        result.setPosition(rowIdx, 0);
      } else {
        result.navigate(+1);
      }
      break;
    case 'left':
      if (pos.isFirstColumn()) {
        rowIdx = lockingPartner && me.isNormalView ? rowIdx : rowIdx - 1;
        if (rowIdx < 0) {
          return false;
        }
        if (lockingPartner) {
          result.view = lockingPartner;
          columns = lockingPartner.getVisibleColumnManager().getColumns();
        }
        result.setPosition(rowIdx, columns[columns.length - 1]);
      } else {
        result.navigate(-1);
      }
      break;
    case 'up':
      if (rowIdx === 0) {
        return false;
      } else {
        result.setRow(rowIdx - 1);
      }
      break;
    case 'down':
      if (rowIdx === maxRowIdx) {
        return false;
      } else {
        result.setRow(rowIdx + 1);
      }
      break;
  }
  if (verifierFn && verifierFn.call(scope || me, result) !== true) {
    return false;
  }
  return result;
}, walkRows:function(startRow, distance) {
  var me = this, store = me.dataSource, moved = 0, lastValid = startRow, node, limit = distance < 0 ? 0 : store.getCount() - 1, increment = limit ? 1 : -1, result = startRow;
  do {
    if (limit ? result >= limit : result <= limit) {
      return lastValid || limit;
    }
    result += increment;
    if ((node = Ext.fly(me.getRow(result))) && node.isVisible(true)) {
      moved += increment;
      lastValid = result;
    }
  } while (moved !== distance);
  return result;
}, walkRecs:function(startRec, distance) {
  var me = this, store = me.dataSource, moved = 0, lastValid = startRec, node, limit = distance < 0 ? 0 : (store.isBufferedStore ? store.getTotalCount() : store.getCount()) - 1, increment = limit ? 1 : -1, testIndex = store.indexOf(startRec), rec;
  do {
    if (limit ? testIndex >= limit : testIndex <= limit) {
      return lastValid;
    }
    testIndex += increment;
    rec = store.getAt(testIndex);
    if (!rec.isCollapsedPlaceholder && (node = Ext.fly(me.getNodeByRecord(rec))) && node.isVisible(true)) {
      moved += increment;
      lastValid = rec;
    }
  } while (moved !== distance);
  return lastValid;
}, getFirstVisibleRowIndex:function() {
  var me = this, count = me.dataSource.isBufferedStore ? me.dataSource.getTotalCount() : me.dataSource.getCount(), result = me.indexOf(me.all.first()) - 1;
  do {
    result += 1;
    if (result === count) {
      return;
    }
  } while (!Ext.fly(me.getRow(result)).isVisible(true));
  return result;
}, getLastVisibleRowIndex:function() {
  var me = this, result = me.indexOf(me.all.last());
  do {
    result -= 1;
    if (result === -1) {
      return;
    }
  } while (!Ext.fly(me.getRow(result)).isVisible(true));
  return result;
}, getHeaderCt:function() {
  return this.headerCt;
}, getPosition:function(record, header) {
  return (new Ext.grid.CellContext(this)).setPosition(record, header);
}, doDestroy:function() {
  var me = this, features = me.featuresMC, feature, i, len;
  me.bindStore(null);
  if (features) {
    for (i = 0, len = features.getCount(); i < len; ++i) {
      feature = features.getAt(i);
      if (feature && !feature.destroyed) {
        feature.destroy();
      }
    }
  }
  me.all.destroy();
  me.body.destroy();
  me.actionRowFly.destroy();
  Ext.view.View.prototype.doDestroy.call(this);
}, onReplace:function(store, startIndex, oldRecords, newRecords) {
  var me = this, bufferedRenderer = me.bufferedRenderer, restoreFocus;
  if (me.rendered && bufferedRenderer) {
    restoreFocus = me.saveFocusState();
    bufferedRenderer.onReplace(store, startIndex, oldRecords, newRecords);
    restoreFocus();
  } else {
    Ext.view.View.prototype.onReplace.apply(this, arguments);
  }
  me.setPendingStripe(startIndex);
}, onResize:function(width, height, oldWidth, oldHeight) {
  var me = this, bufferedRenderer = me.bufferedRenderer;
  if (bufferedRenderer) {
    bufferedRenderer.onViewResize(me, width, height, oldWidth, oldHeight);
  }
  Ext.view.View.prototype.onResize.call(this, width, height, oldWidth, oldHeight);
}, onAdd:function(store, records, index) {
  var me = this, bufferedRenderer = me.bufferedRenderer;
  me.addingRows = true;
  if (me.rendered && bufferedRenderer && (bufferedRenderer.bodyTop || me.dataSource.getCount() + records.length >= bufferedRenderer.viewSize)) {
    bufferedRenderer.onReplace(store, index, [], records);
  } else {
    Ext.view.View.prototype.onAdd.apply(this, arguments);
  }
  me.setPendingStripe(index);
  me.addingRows = false;
}, onRemove:function(store, records, index) {
  var me = this, bufferedRenderer = me.bufferedRenderer, restoreFocus;
  if (me.rendered && bufferedRenderer && me.dataSource.getCount() + records.length >= bufferedRenderer.viewSize) {
    restoreFocus = me.saveFocusState();
    bufferedRenderer.onReplace(store, index, records, []);
    restoreFocus();
  } else {
    Ext.view.View.prototype.onRemove.apply(this, arguments);
  }
  if (me.actionPosition && Ext.Array.indexOf(records, me.actionPosition.record) !== -1) {
    me.actionPosition = null;
  }
  me.setPendingStripe(index);
}, saveFocusState:function() {
  var me = this, store = me.dataSource, actionableMode = me.actionableMode, navModel = me.getNavigationModel(), focusPosition = actionableMode ? me.actionPosition : navModel.getPosition(true), activeElement = Ext.fly(Ext.Element.getActiveElement()), focusCell = focusPosition && focusPosition.view === me && Ext.fly(focusPosition.getCell(true)), refocusRow, refocusCol, record;
  if (!me.skipSaveFocusState && focusCell && focusCell.contains(activeElement)) {
    focusPosition = focusPosition.clone();
    activeElement.suspendFocusEvents();
    if (actionableMode && focusCell.dom !== activeElement.dom) {
      me.suspendActionableMode();
    } else {
      actionableMode = false;
      navModel.setPosition();
    }
    activeElement.resumeFocusEvents();
    if (store.isExpandingOrCollapsing) {
      return Ext.emptyFn;
    }
    return function() {
      var all;
      store = me.dataSource;
      if (store.getCount()) {
        all = me.all;
        refocusRow = Math.min(Math.max(focusPosition.rowIdx, all.startIndex), all.endIndex);
        refocusCol = Math.min(focusPosition.colIdx, me.getVisibleColumnManager().getColumns().length - 1);
        record = focusPosition.record;
        focusPosition = (new Ext.grid.CellContext(me)).setPosition(record && store.contains(record) && !record.isCollapsedPlaceholder ? record : refocusRow, refocusCol);
        if (focusPosition.getCell(true)) {
          if (actionableMode) {
            me.resumeActionableMode(focusPosition);
          } else {
            navModel.setPosition(focusPosition, null, null, null, true);
            if (!navModel.getPosition()) {
              focusPosition.column.focus();
            }
          }
        }
      } else {
        focusPosition.column.focus();
      }
    };
  }
  return Ext.emptyFn;
}, onDataRefresh:function(store) {
  var me = this, owner = me.ownerCt;
  if (owner && owner.isCollapsingOrExpanding === 2) {
    owner.on('expand', me.onDataRefresh, me, {single:true});
    return;
  }
  Ext.view.View.prototype.onDataRefresh.call(this, store);
}, getViewRange:function() {
  var me = this;
  if (me.bufferedRenderer) {
    return me.bufferedRenderer.getViewRange();
  }
  return Ext.view.View.prototype.getViewRange.call(this);
}, setPendingStripe:function(index) {
  var current = this.stripeOnUpdate;
  if (current === null) {
    current = index;
  } else {
    current = Math.min(current, index);
  }
  this.stripeOnUpdate = current;
}, onEndUpdate:function() {
  var me = this, stripeOnUpdate = me.stripeOnUpdate, startIndex = me.all.startIndex;
  if (me.rendered && (stripeOnUpdate || stripeOnUpdate === 0)) {
    if (stripeOnUpdate < startIndex) {
      stripeOnUpdate = startIndex;
    }
    me.doStripeRows(stripeOnUpdate);
    me.stripeOnUpdate = null;
  }
  Ext.view.View.prototype.onEndUpdate.apply(this, arguments);
}, doStripeRows:function(startRow, endRow) {
  var me = this, rows, rowsLn, i, row;
  if (me.rendered && me.stripeRows) {
    rows = me.getNodes(startRow, endRow);
    for (i = 0, rowsLn = rows.length; i < rowsLn; i++) {
      row = rows[i];
      row.className = row.className.replace(me.rowClsRe, ' ');
      startRow++;
      if (startRow % 2 === 0) {
        row.className += ' ' + me.altRowCls;
      }
    }
  }
}, hasActiveFeature:function() {
  return this.isGrouping && this.store.isGrouped() || this.isRowWrapped;
}, getCellPaddingAfter:function(cell) {
  return Ext.fly(cell).getPadding('r');
}, privates:{saveTabOptions:{skipSelf:true, includeHidden:true}, collectNodes:function(targetEl) {
  this.all.fill(this.getNodeContainer().childNodes, this.all.startIndex);
}, setActionableMode:function(enabled, position) {
  var me = this, navModel = me.getNavigationModel(), activeEl, actionables = me.grid.actionables, len = actionables.length, i, record, column, isActionable = false, lockingPartner, cell;
  if (me.actionableMode === enabled) {
    if (!enabled || position.isEqual(me.actionPosition)) {
      return false;
    }
  }
  if (enabled) {
    if (position && (position.view === me || position.view === (lockingPartner = me.lockingPartner) && lockingPartner.actionableMode)) {
      isActionable = me.activateCell(position);
    }
    return isActionable;
  } else {
    activeEl = Ext.fly(Ext.Element.getActiveElement());
    if (me.el.contains(activeEl) && !Ext.fly(activeEl).is(me.getCellSelector())) {
      record = me.actionPosition && me.actionPosition.record || me.getRecord(activeEl);
      column = me.getHeaderByCell(activeEl.findParent(me.getCellSelector()));
      cell = position && position.getCell(true);
      if (!position || !cell) {
        position = (new Ext.grid.CellContext(me)).setPosition(record || 0, column || 0);
        cell = position.getCell(true);
      }
      Ext.fly(cell).focus();
      activeEl = Ext.fly(Ext.Element.getActiveElement());
      if (!(me.el.contains(activeEl) && activeEl.is(me.getCellSelector()))) {
        position = null;
      }
    }
    for (i = 0; i < len; i++) {
      if (actionables[i].deactivate) {
        actionables[i].deactivate();
      }
    }
    if (me.actionRow) {
      me.actionRow.saveTabbableState({skipSelf:true, includeSaved:false});
    }
    if (me.destroyed) {
      return false;
    }
    me.actionableMode = me.ownerGrid.actionableMode = false;
    me.actionPosition = navModel.actionPosition = me.actionRow = null;
    if (position) {
      navModel.setPosition(position);
    }
  }
}, activateCell:function(position) {
  var me = this, lockingPartner = position.view !== me ? me.lockingPartner : null, actionables = me.grid.actionables, len = actionables.length, navModel = me.getNavigationModel(), focusTarget = position.target, record, prevRow, focusRow, focusCell, i, isActionable, tabbableChildren;
  position = position.clone();
  record = position.record;
  position.view.grid.ensureVisible(record, {column:position.column});
  focusRow = me.all.item(position.rowIdx, true);
  if (me.actionPosition) {
    prevRow = me.all.item(me.actionPosition.rowIdx, true);
    if (prevRow && focusRow !== prevRow) {
      Ext.fly(prevRow).saveTabbableState({skipSelf:true, includeSaved:false});
    }
  }
  me.activating = true;
  if (!lockingPartner) {
    focusCell = Ext.fly(position.getCell(true));
    me.actionPosition = position;
    for (i = 0; i < len; i++) {
      isActionable = isActionable || actionables[i].activateCell(position, null, true);
    }
    focusCell = Ext.fly(position.getCell(true));
  }
  if (lockingPartner || focusCell && focusCell.restoreTabbableState({skipSelf:true}).length | (tabbableChildren = focusCell.findTabbableElements()).length || isActionable) {
    for (i = 0; i < len; i++) {
      if (actionables[i].activateRow) {
        actionables[i].activateRow(focusRow);
      }
    }
    if (lockingPartner || tabbableChildren.length) {
      Ext.fly(focusRow).restoreTabbableState({skipSelf:true});
      if (lockingPartner) {
        me.actionableMode = true;
        me.actionPosition = null;
        me.activating = false;
        return true;
      }
      if (tabbableChildren) {
        me.actionRow = me.actionRowFly.attach(focusRow);
        me.actionableMode = me.ownerGrid.actionableMode = true;
        navModel.setPosition();
        navModel.actionPosition = me.actionPosition = position;
        if (focusTarget && Ext.Array.contains(tabbableChildren, focusTarget)) {
          Ext.fly(focusTarget).focus();
        } else {
          Ext.fly(tabbableChildren[0]).focus();
        }
        me.activating = false;
        return true;
      }
    }
  }
  me.activating = false;
}, suspendActionableMode:function() {
  var me = this, actionables = me.grid.actionables, len = actionables.length, i;
  for (i = 0; i < len; i++) {
    actionables[i].suspend();
  }
}, resumeActionableMode:function(position) {
  var me = this, actionables = me.grid.actionables, len = actionables.length, i, activated;
  me.toggleChildrenTabbability(false);
  for (i = 0; i < len; i++) {
    activated = activated || actionables[i].resume(position);
  }
  if (!activated) {
    me.activateCell(position);
  }
}, onRowExit:function(keyEvent, prevRow, newRow, forward, wrapDone) {
  var me = this, direction = forward ? 'nextSibling' : 'previousSibling', lockingPartner = me.lockingPartner, rowIdx;
  if (lockingPartner && lockingPartner.grid.isVisible()) {
    rowIdx = me.all.indexOf(prevRow);
    if (forward) {
      if (me.isNormalView) {
        rowIdx++;
      }
    } else {
      if (me.isLockedView) {
        rowIdx--;
      }
    }
    me.actionPosition = null;
    me = lockingPartner;
    newRow = me.all.item(rowIdx, true);
  }
  if (!me.hasListeners.beforerowexit || me.fireEvent('beforerowexit', me, keyEvent, prevRow, newRow, forward) !== false) {
    me.findFirstActionableElement(keyEvent, newRow, direction, forward, wrapDone);
  } else {
    return false;
  }
}, findFirstActionableElement:function(keyEvent, focusRow, direction, forward, wrapDone) {
  var me = this, columns = me.getVisibleColumnManager().getColumns(), columnCount = columns.length, actionables = me.grid.actionables, actionableCount = actionables.length, position = new Ext.grid.CellContext(me), focusCell, focusTarget, i, j, column, isActionable, tabbableChildren, prevRow;
  if (focusRow) {
    position.setRow(focusRow);
    for (i = 0; i < actionableCount; i++) {
      if (actionables[i].activateRow) {
        actionables[i].activateRow(focusRow);
      }
    }
    for (i = forward ? 0 : columnCount - 1; (forward ? i < columnCount : i > -1) && !focusTarget; i = i + (forward ? 1 : -1)) {
      column = columns[i];
      position.setColumn(column);
      focusCell = (focusRow.dom || focusRow).querySelector(position.column.getCellSelector());
      for (j = 0; j < actionableCount; j++) {
        isActionable = isActionable || actionables[j].activateCell(position);
      }
      focusCell = Ext.fly(position.getCell(true));
      if (focusCell) {
        focusRow = position.getNode(true);
        focusCell.restoreTabbableState({skipSelf:true});
        if ((tabbableChildren = focusCell.findTabbableElements()).length || isActionable) {
          prevRow = me.actionRow && me.actionRow.dom;
          me.actionRow = me.actionRowFly.attach(focusRow);
          me.actionRow.restoreTabbableState({skipSelf:true});
          focusTarget = tabbableChildren[forward ? 0 : tabbableChildren.length - 1];
        }
      }
    }
    if (focusTarget) {
      me.actionPosition = me.getNavigationModel().actionPosition = position;
      Ext.fly(focusTarget).focus(Ext.asyncFocus ? 1 : 0);
      if (prevRow && focusRow !== prevRow) {
        Ext.fly(prevRow).saveTabbableState({skipSelf:true, includeSaved:false});
      }
    } else {
      me.onRowExit(keyEvent, focusRow, me.all.item(position.rowIdx + (forward ? 1 : -1)), forward, wrapDone);
    }
  } else {
    if (!wrapDone) {
      me.grid.ensureVisible(forward ? 0 : me.dataSource.getCount() - 1, {callback:function(success, record, row) {
        if (success) {
          me.findFirstActionableElement(keyEvent, row, direction, forward, true);
        } else {
          me.ownerGrid.setActionableMode(false);
        }
      }});
    } else {
      me.ownerGrid.setActionableMode(false);
    }
  }
}, stretchHeight:function(height) {
  var me = this, scroller = me.getScrollable(), stretchers = me.stretchers, shortfall;
  if (height && me.tabGuardEl) {
    if (stretchers) {
      stretchers[0].style.marginTop = stretchers[1].style.marginTop = me.el.dom.style.height = 0;
    }
    me.el.dom.style.height = scroller.constrainScrollRange(height) + 'px';
    shortfall = height - me.el.dom.offsetHeight;
    if (shortfall > 0) {
      me.el.dom.style.height = '';
      stretchers = me.getStretchers();
      shortfall = height - me.el.dom.offsetHeight;
      if (shortfall > 0) {
        stretchers[0].style.marginTop = scroller.constrainScrollRange(shortfall) + 'px';
        shortfall = height - me.el.dom.offsetHeight;
        if (shortfall > 0) {
          stretchers[1].style.marginTop = Math.min(shortfall, scroller.maxSpacerMargin || 0) + 'px';
        }
      }
    }
  }
}, getStretchers:function() {
  var me = this, stretchers = me.stretchers, stretchCfg;
  if (stretchers) {
    me.el.appendChild(stretchers);
  } else {
    stretchCfg = {cls:'x-scroller-spacer', style:'position:relative'};
    stretchers = me.stretchers = me.el.appendChild([stretchCfg, stretchCfg], true);
  }
  return stretchers;
}}}, 1, ['gridview', 'tableview'], ['component', 'box', 'dataview', 'tableview', 'gridview'], {'component':true, 'box':true, 'dataview':true, 'tableview':true, 'gridview':true}, ['widget.gridview', 'widget.tableview'], [[Ext.mixin.Queryable.prototype.mixinId || Ext.mixin.Queryable.$className, Ext.mixin.Queryable]], [Ext.view, 'Table', Ext.grid, 'View'], function(Table) {
  Table.prototype.oldCellFly = new Ext.dom.Fly;
});
Ext.cmd.derive('Ext.grid.Panel', Ext.panel.Table, {alternateClassName:['Ext.list.ListView', 'Ext.ListView', 'Ext.grid.GridPanel'], viewType:'tableview', ariaRole:'grid', lockable:false, rowLines:true}, 0, ['grid', 'gridpanel'], ['component', 'box', 'container', 'panel', 'tablepanel', 'gridpanel', 'grid'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'gridpanel':true, 'grid':true}, ['widget.grid', 'widget.gridpanel'], 0, [Ext.grid, 'Panel', Ext.list, 'ListView', 
Ext, 'ListView', Ext.grid, 'GridPanel'], 0);
Ext.cmd.derive('Ext.grid.RowContext', Ext.Base, {constructor:function(config) {
  Ext.apply(this, config);
  this.widgets = {};
}, setRecord:function(record, recordIndex) {
  var viewModel = this.viewModel;
  this.record = record;
  this.recordIndex = recordIndex;
  if (viewModel) {
    viewModel.set('record', record);
    viewModel.set('recordIndex', recordIndex);
  }
}, free:function(view) {
  var me = this, widgets = me.widgets, widgetId, widget, focusEl, viewModel = me.viewModel;
  me.record = null;
  if (viewModel) {
    viewModel.set('record');
    viewModel.set('recordIndex');
  }
  for (widgetId in widgets) {
    widget = widgets[widgetId];
    if (view && view.refreshing && !view.el.contains(widget.el)) {
      continue;
    }
    focusEl = widget.getFocusEl();
    if (focusEl) {
      if (focusEl.isTabbable(true)) {
        focusEl.saveTabbableState({includeHidden:true});
      }
      focusEl.blur();
    }
    widget.detachFromBody();
  }
}, getWidget:function(view, ownerId, widgetCfg) {
  var me = this, widgets = me.widgets || (me.widgets = {}), ownerGrid = me.ownerGrid, rowViewModel = ownerGrid.rowViewModel, rowVM = me.viewModel, result;
  if ((widgetCfg.bind || rowViewModel) && !rowVM) {
    if (typeof rowViewModel === 'string') {
      rowViewModel = {type:rowViewModel};
    }
    me.viewModel = rowVM = Ext.Factory.viewModel(Ext.merge({parent:ownerGrid.getRowContextViewModelParent(), data:{record:me.record, recordIndex:me.recordIndex}}, rowViewModel));
  }
  if (!(result = widgets[ownerId])) {
    result = widgets[ownerId] = Ext.widget(Ext.apply({ownerCmp:view, _rowContext:me, $vmParent:rowVM || ownerGrid.getRowContextViewModelParent(), initInheritedState:me.initInheritedStateHook, lookupViewModel:me.lookupViewModelHook}, widgetCfg));
    result.$fromLocked = !!view.isLockedView;
    if (result.isWidget) {
      result.initBindable();
    } else {
      result.collectContainerElement = true;
    }
  }
  return result;
}, getWidgets:function() {
  var widgets = this.widgets, id, result = [];
  for (id in widgets) {
    result.push(widgets[id]);
  }
  return result;
}, handleWidgetViewChange:function(view, ownerId) {
  var widget = this.widgets[ownerId];
  if (widget) {
    widget.ownerCmp = view;
    widget.$fromLocked = !!view.isLockedView;
  }
}, destroy:function() {
  var me = this, widgets = me.widgets, widgetId, widget;
  for (widgetId in widgets) {
    widget = widgets[widgetId];
    widget._rowContext = null;
    widget.destroy();
  }
  Ext.destroy(me.viewModel);
  me.callParent();
}, privates:{initInheritedStateHook:function(inheritedState, inheritedStateInner) {
  var vmParent = this.$vmParent;
  this.self.prototype.initInheritedState.call(this, inheritedState, inheritedStateInner);
  if (!inheritedState.hasOwnProperty('viewModel') && vmParent) {
    inheritedState.viewModel = vmParent;
  }
}, lookupViewModelHook:function(skipThis) {
  var ret = skipThis ? null : this.getViewModel();
  if (!ret) {
    ret = this.$vmParent || null;
  }
  return ret;
}}}, 1, 0, 0, 0, 0, 0, [Ext.grid, 'RowContext'], 0);
Ext.cmd.derive('Ext.grid.plugin.HeaderResizer', Ext.plugin.Abstract, {disabled:false, config:{dynamic:false}, colHeaderCls:'x-column-header', minColWidth:40, maxColWidth:1000, eResizeCursor:'col-resize', init:function(headerCt) {
  var me = this;
  me.headerCt = headerCt;
  headerCt.on('render', me.afterHeaderRender, me, {single:me});
  if (!me.minColWidth) {
    me.self.prototype.minColWidth = Ext.grid.column.Column.prototype.minWidth;
  }
}, destroy:function() {
  var me = this, tracker = me.tracker;
  if (tracker) {
    tracker.destroy();
    me.tracker = null;
  }
  me.headerCt.un('render', me.afterHeaderRender, me);
  me.headerCt = null;
  Ext.plugin.Abstract.prototype.destroy.call(this);
}, afterHeaderRender:function() {
  var me = this, headerCt = me.headerCt, el = headerCt.el;
  headerCt.mon(el, 'mousemove', me.onHeaderCtMouseMove, me);
  me.markerOwner = me.ownerGrid = me.headerCt.up('tablepanel').ownerGrid;
  me.tracker = new Ext.dd.DragTracker({disabled:me.disabled, onBeforeStart:me.onBeforeStart.bind(me), onStart:me.onStart.bind(me), onDrag:me.onDrag.bind(me), onEnd:me.onEnd.bind(me), onCancel:me.onCancel.bind(me), tolerance:3, autoStart:300, el:el});
  headerCt.setTouchAction({panX:false});
}, onHeaderCtMouseMove:function(e) {
  var me = this;
  if (me.headerCt.dragging || me.disabled) {
    if (me.activeHd) {
      me.activeHd.el.dom.style.cursor = '';
      delete me.activeHd;
    }
  } else {
    if (e.pointerType !== 'touch') {
      me.findActiveHeader(e);
    }
  }
}, findActiveHeader:function(e) {
  var me = this, headerCt = me.headerCt, headerEl = e.getTarget('.' + me.colHeaderCls, headerCt.el, true), ownerGrid = me.ownerGrid, ownerLockable = ownerGrid.ownerLockable, overHeader, resizeHeader, headers, header;
  me.activeHd = null;
  if (headerEl) {
    overHeader = Ext.getCmp(headerEl.id);
    if (overHeader.isAtEndEdge(e)) {
      if (headerCt.visibleColumnManager.getColumns().length === 1 && headerCt.forceFit) {
        return;
      }
      resizeHeader = overHeader;
    } else {
      if (overHeader.isAtStartEdge(e)) {
        headers = headerCt.visibleColumnManager.getColumns();
        header = overHeader.isGroupHeader ? overHeader.getGridColumns()[0] : overHeader;
        resizeHeader = headers[Ext.Array.indexOf(headers, header) - 1];
        if (!resizeHeader && ownerLockable && !ownerGrid.isLocked) {
          headers = ownerLockable.lockedGrid.headerCt.visibleColumnManager.getColumns();
          resizeHeader = headers[headers.length - 1];
        }
      }
    }
    if (resizeHeader) {
      if (resizeHeader.isGroupHeader) {
        headers = resizeHeader.getGridColumns();
        resizeHeader = headers[headers.length - 1];
      }
      if (resizeHeader && !(resizeHeader.fixed || resizeHeader.resizable === false)) {
        me.activeHd = resizeHeader;
        overHeader.el.dom.style.cursor = me.eResizeCursor;
        if (overHeader.triggerEl) {
          overHeader.triggerEl.dom.style.cursor = me.eResizeCursor;
        }
      }
    } else {
      overHeader.el.dom.style.cursor = '';
      if (overHeader.triggerEl) {
        overHeader.triggerEl.dom.style.cursor = '';
      }
    }
  }
  return me.activeHd;
}, onBeforeStart:function(e) {
  var me = this;
  me.dragHd = me.activeHd || e.pointerType === 'touch' && me.findActiveHeader(e);
  if (me.dragHd && !me.headerCt.dragging) {
    e.claimGesture();
    me.xDelta = me.dragHd.getX() + me.dragHd.getWidth() - me.tracker.getXY()[0];
    me.tracker.constrainTo = me.getConstrainRegion();
    return true;
  } else {
    me.headerCt.dragging = false;
    return false;
  }
}, onCancel:function(e) {
  this.dragHd = this.activeHd = null;
  this.headerCt.dragging = false;
}, getConstrainRegion:function() {
  var me = this, dragHdEl = me.dragHd.el, nextHd, ownerGrid = me.ownerGrid, widthModel = ownerGrid.getSizeModel().width, maxColWidth = widthModel.shrinkWrap ? me.headerCt.getWidth() - me.headerCt.visibleColumnManager.getColumns().length * me.minColWidth : me.maxColWidth, result;
  if (me.headerCt.forceFit) {
    nextHd = me.dragHd.nextNode('gridcolumn:not([hidden]):not([isGroupHeader])');
    if (nextHd && me.headerInSameGrid(nextHd)) {
      maxColWidth = dragHdEl.getWidth() + (nextHd.getWidth() - me.minColWidth);
    }
  } else {
    if (ownerGrid.isLocked && widthModel.shrinkWrap) {
      maxColWidth = me.dragHd.up('[scrollerOwner]').getTargetEl().getWidth(true) - ownerGrid.getWidth() - (ownerGrid.ownerLockable.normalGrid.visibleColumnManager.getColumns().length * me.minColWidth + Ext.getScrollbarSize().width);
    }
  }
  result = me.adjustConstrainRegion(dragHdEl.getRegion(), 0, 0, 0, me.minColWidth);
  result.right = dragHdEl.getX() + maxColWidth;
  return result;
}, onStart:function(e) {
  var me = this, dragHd = me.dragHd, width = dragHd.el.getWidth(), headerCt = dragHd.getRootHeaderCt(), x, y, markerOwner, lhsMarker, rhsMarker, markerHeight;
  me.headerCt.dragging = true;
  me.origWidth = width;
  if (!me.dynamic) {
    markerOwner = me.markerOwner;
    if (markerOwner.frame && markerOwner.resizable) {
      me.gridOverflowSetting = markerOwner.el.dom.style.overflow;
      markerOwner.el.dom.style.overflow = 'hidden';
    }
    x = me.getLeftMarkerX(markerOwner);
    lhsMarker = markerOwner.getLhsMarker();
    rhsMarker = markerOwner.getRhsMarker();
    markerHeight = me.ownerGrid.body.getHeight() + headerCt.getHeight();
    y = headerCt.getOffsetsTo(markerOwner)[1] - markerOwner.el.getBorderWidth('t');
    lhsMarker.dom.style.cursor = me.eResizeCursor;
    rhsMarker.dom.style.cursor = me.eResizeCursor;
    lhsMarker.setLocalY(y);
    rhsMarker.setLocalY(y);
    lhsMarker.setHeight(markerHeight);
    rhsMarker.setHeight(markerHeight);
    me.setMarkerX(lhsMarker, x);
    me.setMarkerX(rhsMarker, x + width);
  }
}, onDrag:function(e) {
  var me = this;
  if (me.dynamic) {
    me.doResize();
  } else {
    me.setMarkerX(me.getMovingMarker(me.markerOwner), me.calculateDragX(me.markerOwner));
  }
}, getMovingMarker:function(markerOwner) {
  return markerOwner.getRhsMarker();
}, onEnd:function(e) {
  var me = this, markerOwner = me.markerOwner;
  me.headerCt.dragging = false;
  if (me.dragHd) {
    if (!me.dynamic) {
      if ('gridOverflowSetting' in me) {
        markerOwner.el.dom.style.overflow = me.gridOverflowSetting;
      }
      me.setMarkerX(markerOwner.getLhsMarker(), -9999);
      me.setMarkerX(markerOwner.getRhsMarker(), -9999);
    }
    me.doResize();
    if (e.pointerType !== 'touch') {
      me.dragHd = null;
      me.activeHd.el.dom.style.cursor = me.eResizeCursor;
    } else {
      me.dragHd = me.activeHd = null;
    }
  }
  me.headerCt.blockNextEvent();
}, doResize:function() {
  var me = this, dragHd = me.dragHd, nextHd, offset = me.tracker.getOffset('point');
  if (dragHd && offset[0]) {
    if (dragHd.flex) {
      delete dragHd.flex;
    }
    Ext.suspendLayouts();
    me.adjustColumnWidth(offset[0] - me.xDelta);
    if (me.headerCt.forceFit) {
      nextHd = dragHd.nextNode('gridcolumn:not([hidden]):not([isGroupHeader])');
      if (nextHd && !me.headerInSameGrid(nextHd)) {
        nextHd = null;
      }
      if (nextHd) {
        delete nextHd.flex;
        nextHd.setWidth(nextHd.getWidth() - offset[0]);
      }
    }
    Ext.resumeLayouts(true);
  }
}, headerInSameGrid:function(header) {
  var grid = this.dragHd.up('tablepanel');
  return !!header.up(grid);
}, disable:function() {
  var tracker = this.tracker;
  this.disabled = true;
  if (tracker) {
    tracker.disable();
  }
}, enable:function() {
  var tracker = this.tracker;
  this.disabled = false;
  if (tracker) {
    tracker.enable();
  }
}, calculateDragX:function(markerOwner) {
  return this.tracker.getXY('point')[0] + this.xDelta - markerOwner.getX() - markerOwner.el.getBorderWidth('l');
}, getLeftMarkerX:function(markerOwner) {
  return this.dragHd.getX() - markerOwner.getX() - markerOwner.el.getBorderWidth('l') - 1;
}, setMarkerX:function(marker, x) {
  marker.setLocalX(x);
}, adjustConstrainRegion:function(region, t, r, b, l) {
  return region.adjust(t, r, b, l);
}, adjustColumnWidth:function(offsetX) {
  this.dragHd.setWidth(this.origWidth + offsetX);
}}, 0, 0, 0, 0, ['plugin.gridheaderresizer'], 0, [Ext.grid.plugin, 'HeaderResizer'], 0);
Ext.cmd.derive('Ext.grid.header.DragZone', Ext.dd.DragZone, {colHeaderSelector:'.x-column-header', colInnerSelector:'.x-column-header-inner', maxProxyWidth:120, constructor:function(headerCt) {
  var me = this;
  me.headerCt = headerCt;
  me.ddGroup = me.getDDGroup();
  me.autoGroup = true;
  Ext.dd.DragZone.prototype.constructor.call(this, headerCt.el);
  me.proxy.el.addCls('x-grid-col-dd');
}, getDDGroup:function() {
  return 'header-dd-zone-' + this.headerCt.up('[scrollerOwner]').id;
}, getDragData:function(e) {
  if (e.getTarget(this.colInnerSelector)) {
    var header = e.getTarget(this.colHeaderSelector), headerCmp, ddel;
    if (header) {
      headerCmp = Ext.getCmp(header.id);
      if (!this.headerCt.dragging && headerCmp.draggable && !(headerCmp.isAtStartEdge(e) || headerCmp.isAtEndEdge(e))) {
        ddel = document.createElement('div');
        ddel.role = 'presentation';
        ddel.innerHTML = headerCmp.text;
        return {ddel:ddel, header:headerCmp};
      }
    }
  }
  return false;
}, onBeforeDrag:function() {
  return !(this.headerCt.dragging || this.disabled);
}, onInitDrag:function() {
  this.headerCt.dragging = true;
  this.headerCt.hideMenu();
  Ext.dd.DragZone.prototype.onInitDrag.apply(this, arguments);
}, onDragDrop:function() {
  this.headerCt.dragging = false;
  Ext.dd.DragZone.prototype.onDragDrop.apply(this, arguments);
}, afterRepair:function() {
  Ext.dd.DragZone.prototype.afterRepair.call(this);
  this.headerCt.dragging = false;
}, getRepairXY:function() {
  return this.dragData.header.el.getXY();
}, disable:function() {
  this.disabled = true;
}, enable:function() {
  this.disabled = false;
}}, 1, 0, 0, 0, 0, 0, [Ext.grid.header, 'DragZone'], 0);
Ext.cmd.derive('Ext.grid.header.DropZone', Ext.dd.DropZone, {colHeaderCls:'x-column-header', proxyOffsets:[-4, -9], constructor:function(headerCt) {
  var me = this;
  me.headerCt = headerCt;
  me.ddGroup = me.getDDGroup();
  me.autoGroup = true;
  Ext.dd.DropZone.prototype.constructor.call(this, headerCt.el);
}, destroy:function() {
  Ext.destroy(this.topIndicator, this.bottomIndicator);
  Ext.dd.DropZone.prototype.destroy.call(this);
}, getDDGroup:function() {
  return 'header-dd-zone-' + this.headerCt.up('[scrollerOwner]').id;
}, getTargetFromEvent:function(e) {
  return e.getTarget('.' + this.colHeaderCls);
}, getTopIndicator:function() {
  if (!this.topIndicator) {
    this.topIndicator = Ext.getBody().createChild({role:'presentation', cls:'x-col-move-top', html:'\x26#160;'});
    this.indicatorXOffset = Math.floor((this.topIndicator.dom.offsetWidth + 1) / 2);
  }
  return this.topIndicator;
}, getBottomIndicator:function() {
  if (!this.bottomIndicator) {
    this.bottomIndicator = Ext.getBody().createChild({role:'presentation', cls:'x-col-move-bottom', html:'\x26#160;'});
  }
  return this.bottomIndicator;
}, getLocation:function(e, t) {
  var x = e.getXY()[0], region = Ext.fly(t).getRegion(), pos;
  if (region.right - x <= (region.right - region.left) / 2) {
    pos = 'after';
  } else {
    pos = 'before';
  }
  return {pos:pos, header:Ext.getCmp(t.id), node:t};
}, positionIndicator:function(data, node, e) {
  var me = this, dragHeader = data.header, dropLocation = me.getLocation(e, node), targetHeader = dropLocation.header, pos = dropLocation.pos, nextHd, prevHd, topIndicator, bottomIndicator, topAnchor, bottomAnchor, topXY, bottomXY, headerCtEl, minX, maxX, allDropZones, ln, i, dropZone;
  if (targetHeader === me.lastTargetHeader && pos === me.lastDropPos) {
    return;
  }
  nextHd = dragHeader.nextSibling('gridcolumn:not([hidden])');
  prevHd = dragHeader.previousSibling('gridcolumn:not([hidden])');
  me.lastTargetHeader = targetHeader;
  me.lastDropPos = pos;
  if (!targetHeader.draggable && pos === 'before' && targetHeader.getIndex() === 0) {
    return false;
  }
  data.dropLocation = dropLocation;
  if (dragHeader !== targetHeader && (pos === 'before' && nextHd !== targetHeader || pos === 'after' && prevHd !== targetHeader) && !targetHeader.isDescendantOf(dragHeader)) {
    allDropZones = Ext.dd.DragDropManager.getRelated(me);
    ln = allDropZones.length;
    i = 0;
    for (; i < ln; i++) {
      dropZone = allDropZones[i];
      if (dropZone !== me && dropZone.invalidateDrop) {
        dropZone.invalidateDrop();
      }
    }
    me.valid = true;
    topIndicator = me.getTopIndicator();
    bottomIndicator = me.getBottomIndicator();
    if (pos === 'before') {
      topAnchor = 'bc-tl';
      bottomAnchor = 'tc-bl';
    } else {
      topAnchor = 'bc-tr';
      bottomAnchor = 'tc-br';
    }
    topXY = topIndicator.getAlignToXY(targetHeader.el, topAnchor);
    bottomXY = bottomIndicator.getAlignToXY(targetHeader.el, bottomAnchor);
    headerCtEl = me.headerCt.el;
    minX = headerCtEl.getX() - me.indicatorXOffset;
    maxX = headerCtEl.getX() + headerCtEl.getWidth();
    topXY[0] = Ext.Number.constrain(topXY[0], minX, maxX);
    bottomXY[0] = Ext.Number.constrain(bottomXY[0], minX, maxX);
    topIndicator.setXY(topXY);
    bottomIndicator.setXY(bottomXY);
    topIndicator.show();
    bottomIndicator.show();
  } else {
    me.invalidateDrop();
  }
}, invalidateDrop:function() {
  this.valid = false;
  this.hideIndicators();
}, onNodeOver:function(node, dragZone, e, data) {
  var me = this, from = data.header, doPosition, fromPanel, to, toPanel;
  if (data.header.el.dom === node) {
    doPosition = false;
  } else {
    data.isLock = data.isUnlock = data.crossPanel = false;
    to = me.getLocation(e, node).header;
    doPosition = from.ownerCt === to.ownerCt;
    if (!doPosition && (!from.ownerCt.isSealed() && !to.ownerCt.isSealed())) {
      doPosition = true;
      fromPanel = from.up('tablepanel');
      toPanel = to.up('tablepanel');
      if (fromPanel !== toPanel) {
        data.crossPanel = true;
        data.isLock = toPanel.isLocked && !fromPanel.isLocked;
        data.isUnlock = !toPanel.isLocked && fromPanel.isLocked;
        if (data.isUnlock && from.lockable === false || data.isLock && !from.isLockable()) {
          doPosition = false;
        }
      }
    }
  }
  if (doPosition) {
    me.positionIndicator(data, node, e);
  } else {
    me.valid = false;
  }
  return me.valid ? me.dropAllowed : me.dropNotAllowed;
}, hideIndicators:function() {
  var me = this;
  me.getTopIndicator().hide();
  me.getBottomIndicator().hide();
  me.lastTargetHeader = me.lastDropPos = null;
}, onNodeOut:function() {
  this.hideIndicators();
}, getNestedHeader:function(header, first) {
  var items = header.items, pos;
  if (header.isGroupHeader && items.length) {
    pos = !first ? 'first' : 'last';
    header = this.getNestedHeader(items[pos](), first);
  }
  return header;
}, onNodeDrop:function(node, dragZone, e, data) {
  this.headerCt.blockNextEvent();
  if (!this.valid) {
    return;
  }
  var me = this, dragHeader = data.header, dropLocation = data.dropLocation, dropPosition = dropLocation.pos, targetHeader = dropLocation.header, fromCt = dragHeader.ownerCt, fromCtRoot = fromCt.getRootHeaderCt(), toCt = targetHeader.ownerCt, visibleColumnManager = me.headerCt.visibleColumnManager, visibleFromIdx = visibleColumnManager.getHeaderIndex(dragHeader), visibleToIdx, colsToMove, scrollerOwner, savedWidth;
  if (data.isLock || data.isUnlock) {
    scrollerOwner = fromCt.up('[scrollerOwner]');
    visibleToIdx = toCt.items.indexOf(targetHeader);
    if (dropPosition === 'after') {
      visibleToIdx++;
    }
    if (data.isLock) {
      scrollerOwner.lock(dragHeader, visibleToIdx, toCt);
    } else {
      scrollerOwner.unlock(dragHeader, visibleToIdx, toCt);
    }
  } else {
    visibleToIdx = dropPosition === 'after' ? visibleColumnManager.getHeaderIndex(me.getNestedHeader(targetHeader, 1)) + 1 : visibleColumnManager.getHeaderIndex(me.getNestedHeader(targetHeader, 0));
    me.invalidateDrop();
    savedWidth = dragHeader.getWidth();
    Ext.suspendLayouts();
    fromCtRoot.isDDMoveInGrid = !data.crossPanel;
    if (dragHeader.isGroupHeader && targetHeader.isGroupHeader) {
      dragHeader.setNestedParent(targetHeader);
    }
    if (dropPosition === 'before') {
      toCt.moveBefore(dragHeader, targetHeader);
    } else {
      toCt.moveAfter(dragHeader, targetHeader);
    }
    if (visibleToIdx >= 0 && !(targetHeader.isGroupHeader && (!targetHeader.items || !targetHeader.items.length)) && visibleFromIdx !== visibleToIdx) {
      colsToMove = dragHeader.isGroupHeader ? dragHeader.query('gridcolumn:not([hidden]):not([isGroupHeader])').length : 1;
      if (visibleFromIdx <= visibleToIdx && colsToMove > 1) {
        visibleToIdx -= colsToMove;
      }
      toCt.getRootHeaderCt().grid.view.moveColumn(visibleFromIdx, visibleToIdx, colsToMove);
    }
    fromCtRoot.fireEvent('columnmove', fromCt, dragHeader, visibleFromIdx, visibleToIdx);
    fromCtRoot.isDDMoveInGrid = false;
    if (toCt.isGroupHeader && !fromCt.isGroupHeader) {
      if (fromCt !== toCt) {
        dragHeader.savedFlex = dragHeader.flex;
        delete dragHeader.flex;
        dragHeader.width = savedWidth;
      }
    } else {
      if (!fromCt.isGroupHeader) {
        if (dragHeader.savedFlex) {
          dragHeader.flex = dragHeader.savedFlex;
          delete dragHeader.width;
        }
      }
    }
    Ext.resumeLayouts(true);
    if (me.headerCt.grid.floated) {
      me.headerCt.grid.updateLayout();
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.grid.header, 'DropZone'], 0);
Ext.cmd.derive('Ext.grid.plugin.HeaderReorderer', Ext.plugin.Abstract, {init:function(headerCt) {
  this.headerCt = headerCt;
  headerCt.on({boxready:this.onHeaderCtRender, single:true, scope:this});
}, destroy:function() {
  var me = this;
  me.headerCt.un('boxready', me.onHeaderCtRender, me);
  Ext.destroy(me.dragZone, me.dropZone);
  me.headerCt = me.dragZone = me.dropZone = null;
  Ext.plugin.Abstract.prototype.destroy.call(this);
}, onHeaderCtRender:function(headerCt) {
  var me = this;
  me.dragZone = new Ext.grid.header.DragZone(me.headerCt);
  me.dropZone = new Ext.grid.header.DropZone(me.headerCt);
  if (me.disabled) {
    me.dragZone.disable();
  }
  headerCt.setTouchAction({panX:false});
}, enable:function() {
  this.disabled = false;
  if (this.dragZone) {
    this.dragZone.enable();
  }
}, disable:function() {
  this.disabled = true;
  if (this.dragZone) {
    this.dragZone.disable();
  }
}}, 0, 0, 0, 0, ['plugin.gridheaderreorderer'], 0, [Ext.grid.plugin, 'HeaderReorderer'], 0);
Ext.cmd.derive('Ext.grid.header.Container', Ext.container.Container, {border:true, baseCls:'x-grid-header-ct', dock:'top', weight:100, defaultType:'gridcolumn', defaultWidth:100, sortAscText:'Sort Ascending', sortDescText:'Sort Descending', sortClearText:'Clear Sort', columnsText:'Columns', headerOpenCls:'x-column-header-open', menuSortAscCls:'x-hmenu-sort-asc', menuSortDescCls:'x-hmenu-sort-desc', menuColsIcon:'x-cols-icon', blockEvents:false, dragging:false, sortOnClick:true, focusableContainer:false, 
childHideCount:0, sortable:true, enableColumnHide:true, initComponent:function() {
  var me = this;
  me.plugins = me.plugins || [];
  me.defaults = me.defaults || {};
  if (!me.isColumn) {
    me.isRootHeader = true;
    if (me.enableColumnResize) {
      me.resizer = new Ext.grid.plugin.HeaderResizer;
      me.plugins.push(me.resizer);
    }
    if (me.enableColumnMove) {
      me.reorderer = new Ext.grid.plugin.HeaderReorderer;
      me.plugins.push(me.reorderer);
    }
  }
  if (me.isColumn && !me.isGroupHeader) {
    if (!me.items || me.items.length === 0) {
      me.isContainer = me.isFocusableContainer = false;
      if (!me.hasOwnProperty('focusable')) {
        me.focusable = true;
      }
      me.layout = {type:'container', calculate:Ext.emptyFn};
    }
  } else {
    me.layout = Ext.apply({type:'gridcolumn', align:'stretch'}, me.initialConfig.layout);
    me.defaults.columnLines = me.columnLines;
    if (me.isRootHeader) {
      if (!me.hiddenHeaders) {
        me.focusableContainer = true;
        me.ariaRole = 'rowgroup';
      }
      me.columnManager = new Ext.grid.ColumnManager(false, me);
      me.visibleColumnManager = new Ext.grid.ColumnManager(true, me);
      if (me.grid) {
        me.grid.columnManager = me.columnManager;
        me.grid.visibleColumnManager = me.visibleColumnManager;
      }
    } else {
      me.visibleColumnManager = new Ext.grid.ColumnManager(true, me);
      me.columnManager = new Ext.grid.ColumnManager(false, me);
    }
  }
  me.menuTask = new Ext.util.DelayedTask(me.updateMenuDisabledState, me);
  Ext.container.Container.prototype.initComponent.call(this);
}, isNested:function() {
  return !!this.getRootHeaderCt().down('[isNestedParent]');
}, isNestedGroupHeader:function() {
  var header = this, items = header.getRefOwner().query('\x3e:not([hidden])');
  return items.length === 1 && items[0] === header;
}, isSealed:function() {
  return !!(this.sealed || this.getInherited().sealed);
}, maybeShowNestedGroupHeader:function() {
  var items = this.items, item;
  if (items && items.length === 1 && (item = items.getAt(0)) && item.hidden) {
    item.show();
  }
}, setNestedParent:function(target) {
  target.isNestedParent = false;
  target.ownerCt.isNestedParent = !!(this.ownerCt.items.length === 1 && target.ownerCt.items.length === 1);
}, initEvents:function() {
  var me = this, onHeaderCtEvent, listeners;
  Ext.container.Container.prototype.initEvents.call(this);
  if (!me.isColumn && !me.isGroupHeader) {
    onHeaderCtEvent = me.onHeaderCtEvent;
    listeners = {click:onHeaderCtEvent, dblclick:onHeaderCtEvent, contextmenu:onHeaderCtEvent, mousedown:me.onHeaderCtMouseDown, mouseover:me.onHeaderCtMouseOver, mouseout:me.onHeaderCtMouseOut, scope:me};
    if (Ext.supports.Touch) {
      listeners.longpress = me.onHeaderCtLongPress;
    }
    me.mon(me.el, listeners);
  }
}, onHeaderCtEvent:function(e, t) {
  var me = this, headerEl = me.getHeaderElByEvent(e), header, targetEl, activeHeader;
  if (me.longPressFired) {
    me.longPressFired = false;
    return;
  }
  if (headerEl && !me.blockEvents) {
    header = Ext.getCmp(headerEl.id);
    if (header) {
      targetEl = header[header.clickTargetName];
      if (!header.isGroupHeader && !header.isContainer || e.within(targetEl)) {
        if (e.type === 'click' || e.type === 'tap') {
          activeHeader = header.onTitleElClick(e, targetEl, me.sortOnClick);
          if (activeHeader) {
            me.onHeaderTriggerClick(activeHeader, e, e.pointerType === 'touch' ? activeHeader.el : activeHeader.triggerEl);
          } else {
            me.onHeaderClick(header, e, t);
          }
        } else {
          if (e.type === 'contextmenu') {
            me.onHeaderContextMenu(header, e, t);
          } else {
            if (e.type === 'dblclick') {
              header.onTitleElDblClick(e, targetEl.dom);
            }
          }
        }
      }
    }
  }
}, blockNextEvent:function() {
  var me = this;
  me.blockEvents = true;
  if (!me.unblockTimer) {
    me.unblockTimer = Ext.asap(me.unblockEvents, me);
  }
}, unblockEvents:function() {
  this.blockEvents = this.unblockTimer = false;
}, onHeaderCtMouseDown:function(e, target) {
  var targetCmp = Ext.Component.from(target), cols, i, len, scrollable, col;
  if (!e.defaultPrevented && targetCmp !== this) {
    if (targetCmp.isGroupHeader) {
      cols = targetCmp.getVisibleGridColumns();
      scrollable = this.getScrollable();
      for (i = 0, len = cols.length; i < len; ++i) {
        col = cols[i];
        if (scrollable.doIsInView(col.el, true).x) {
          targetCmp = col;
          break;
        }
      }
    }
    targetCmp.focus();
  }
}, onHeaderCtMouseOver:function(e, t) {
  var headerEl, header, targetEl;
  if (!e.within(this.el, true)) {
    headerEl = e.getTarget('.' + Ext.grid.column.Column.prototype.baseCls);
    header = headerEl && Ext.getCmp(headerEl.id);
    if (header) {
      targetEl = header[header.clickTargetName];
      if (e.within(targetEl)) {
        header.onTitleMouseOver(e, targetEl.dom);
      }
    }
  }
}, onHeaderCtMouseOut:function(e, t) {
  var headerSelector = '.' + Ext.grid.column.Column.prototype.baseCls, outHeaderEl = e.getTarget(headerSelector), inHeaderEl = e.getRelatedTarget(headerSelector), header, targetEl;
  if (outHeaderEl !== inHeaderEl) {
    if (outHeaderEl) {
      header = Ext.getCmp(outHeaderEl.id);
      if (header) {
        targetEl = header[header.clickTargetName];
        header.onTitleMouseOut(e, targetEl.dom);
      }
    }
    if (inHeaderEl) {
      header = Ext.getCmp(inHeaderEl.id);
      if (header) {
        targetEl = header[header.clickTargetName];
        header.onTitleMouseOver(e, targetEl.dom);
      }
    }
  }
}, onHeaderCtLongPress:function(e) {
  var me = this, headerEl = me.getHeaderElByEvent(e), header;
  if (headerEl) {
    header = Ext.getCmp(headerEl.id);
    if (header && !header.menuDisabled) {
      me.longPressFired = true;
      me.showMenuBy(e, headerEl, header);
    }
  }
}, getHeaderElByEvent:function(e) {
  return e.getTarget('.' + Ext.grid.column.Column.prototype.baseCls);
}, isLayoutRoot:function() {
  if (this.hiddenHeaders) {
    return false;
  }
  return Ext.container.Container.prototype.isLayoutRoot.call(this);
}, getRootHeaderCt:function() {
  return this.isRootHeader ? this : this.up('[isRootHeader]');
}, doDestroy:function() {
  var me = this;
  if (me.menu) {
    me.menu.un('hide', me.onMenuHide, me);
  }
  Ext.unasap(me.unblockTimer);
  me.menuTask.cancel();
  Ext.destroy(me.visibleColumnManager, me.columnManager, me.menu);
  Ext.container.Container.prototype.doDestroy.call(this);
}, removeAll:function(autoDestroy) {
  var me = this;
  me.suspendEvent('columnschanged');
  Ext.container.Container.prototype.removeAll.call(this, autoDestroy);
  me.resumeEvent('columnschanged');
  me.fireEvent('columnschanged', me);
}, applyColumnsState:function(columnsState, storeState) {
  if (!columnsState) {
    return;
  }
  var me = this, items = me.items.items, count = items.length, i = 0, moved = false, newOrder = [], newCols = [], length, col, columnState, index;
  me.purgeCache();
  for (i = 0; i < count; i++) {
    col = items[i];
    columnState = columnsState[col.getStateId()];
    if (columnState) {
      index = columnState.index;
      newOrder[index] = col;
      if (i !== index) {
        moved = true;
      }
      if (col.applyColumnState) {
        col.applyColumnState(columnState, storeState);
      }
    } else {
      newCols.push({index:i, column:col});
    }
  }
  newOrder = Ext.Array.clean(newOrder);
  length = newCols.length;
  if (length) {
    for (i = 0; i < length; i++) {
      columnState = newCols[i];
      index = columnState.index;
      if (index < newOrder.length) {
        moved = true;
        Ext.Array.splice(newOrder, index, 0, columnState.column);
      } else {
        newOrder.push(columnState.column);
      }
    }
  }
  if (moved) {
    me.applyingState = true;
    me.removeAll(false);
    delete me.applyingState;
    me.add(newOrder);
  }
}, getColumnsState:function() {
  var me = this, columns = [], state;
  me.items.each(function(col) {
    state = col.getColumnState && col.getColumnState();
    if (state) {
      columns.push(state);
    }
  });
  return columns;
}, onAdd:function(c) {
  var me = this, rootHeader;
  Ext.container.Container.prototype.onAdd.apply(this, arguments);
  rootHeader = me.getRootHeaderCt();
  me.onHeadersChanged(c, rootHeader && rootHeader.isDDMoveInGrid);
}, move:function(fromIdx, toIdx) {
  var me = this, items = me.items, headerToMove;
  if (fromIdx.isComponent) {
    headerToMove = fromIdx;
    fromIdx = items.indexOf(headerToMove);
  } else {
    headerToMove = items.getAt(fromIdx);
  }
  headerToMove.visibleFromIdx = me.getRootHeaderCt().visibleColumnManager.indexOf(headerToMove);
  Ext.container.Container.prototype.move.apply(this, arguments);
}, onMove:function(headerToMove, fromIdx, toIdx) {
  var me = this, gridHeaderCt = me.getRootHeaderCt(), gridVisibleColumnManager = gridHeaderCt.visibleColumnManager, numColsToMove = 1, visibleToIdx;
  me.onHeadersChanged(headerToMove, true);
  visibleToIdx = gridVisibleColumnManager.indexOf(headerToMove);
  if (visibleToIdx >= headerToMove.visibleFromIdx) {
    visibleToIdx++;
  }
  Ext.container.Container.prototype.onMove.apply(this, arguments);
  if (headerToMove.isGroupHeader) {
    numColsToMove = headerToMove.visibleColumnManager.getColumns().length;
  }
  gridHeaderCt.onHeaderMoved(headerToMove, numColsToMove, headerToMove.visibleFromIdx, visibleToIdx);
}, maybeContinueRemove:function() {
  var me = this;
  return me.isGroupHeader && !me.applyingState && !me.isNestedParent && me.ownerCt && !me.items.getCount();
}, onRemove:function(c, isDestroying) {
  var me = this, ownerCt = me.ownerCt;
  Ext.container.Container.prototype.onRemove.call(this, c, isDestroying);
  if (!me.destroying) {
    if (!me.getRootHeaderCt().isDDMoveInGrid) {
      me.onHeadersChanged(c, false);
    }
    if (me.maybeContinueRemove()) {
      if (c.rendered) {
        c.detachFromBody();
      }
      me.destroyAfterRemoving = true;
      Ext.suspendLayouts();
      ownerCt.remove(me, false);
      Ext.resumeLayouts(true);
    }
  }
}, onHeadersChanged:function(c, isMove) {
  var gridPanel, gridHeaderCt = this.getRootHeaderCt();
  this.purgeHeaderCtCache(this);
  if (gridHeaderCt) {
    gridHeaderCt.onColumnsChanged();
    gridPanel = gridHeaderCt.ownerCt;
    if (gridPanel && !isMove) {
      gridPanel.onHeadersChanged(gridHeaderCt, c);
    }
  }
}, onHeaderMoved:function(header, colsToMove, fromIdx, toIdx) {
  var me = this, gridSection = me.ownerCt;
  if (me.rendered) {
    if (gridSection && gridSection.onHeaderMove) {
      gridSection.onHeaderMove(me, header, colsToMove, fromIdx, toIdx);
    }
    me.fireEvent('columnmove', me, header, fromIdx, toIdx);
  }
}, onColumnsChanged:function() {
  var me = this, menu = me.menu, columnItemSeparator, columnItem;
  if (me.rendered) {
    me.fireEvent('columnschanged', me);
    if (menu) {
      columnItemSeparator = menu.child('#columnItemSeparator');
      columnItem = menu.child('#columnItem');
      if (columnItemSeparator) {
        columnItemSeparator.destroy();
      }
      if (columnItem) {
        columnItem.destroy();
      }
    }
  }
}, lookupComponent:function(comp) {
  var result = Ext.container.Container.prototype.lookupComponent.apply(this, arguments);
  if (!result.isGroupHeader && result.width === undefined && !result.flex) {
    result.width = this.defaultWidth;
  }
  return result;
}, setSortState:function() {
  var store = this.up('[store]').store, columns = this.visibleColumnManager.getColumns(), len = columns.length, i, header, sorter;
  for (i = 0; i < len; i++) {
    header = columns[i];
    sorter = header.getSorter();
    if (sorter) {
      if (!store.getSorters().contains(sorter)) {
        sorter = null;
      }
    } else {
      sorter = store.getSorters().get(header.getSortParam());
    }
    header.setSortState(sorter);
  }
}, getHeaderMenu:function() {
  var menu = this.getMenu(), item;
  if (menu) {
    item = menu.child('#columnItem');
    if (item) {
      return item.menu;
    }
  }
  return null;
}, onHeaderVisibilityChange:function(header, visible) {
  var me = this, menu = me.getHeaderMenu(), item;
  me.purgeHeaderCtCache(header.ownerCt);
  if (menu) {
    item = me.getMenuItemForHeader(menu, header);
    if (item) {
      item.setChecked(visible, true);
    }
    if (menu.isVisible()) {
      me.menuTask.delay(50);
    }
  }
}, updateMenuDisabledState:function(menu) {
  var me = this, columns = me.query('gridcolumn:not([hidden])'), i, len = columns.length, item, checkItem, method;
  if (!menu) {
    menu = me.getMenu();
  }
  for (i = 0; i < len; ++i) {
    item = columns[i];
    checkItem = me.getMenuItemForHeader(menu, item);
    if (checkItem) {
      method = item.isHideable() ? 'enable' : 'disable';
      if (checkItem.menu) {
        method += 'CheckChange';
      }
      checkItem[method]();
    }
  }
}, getMenuItemForHeader:function(menu, header) {
  return header ? menu.down('menucheckitem[headerId\x3d' + header.id + ']') : null;
}, onHeaderShow:function(header) {
  var me = this, ownerCt = me.ownerCt, lastHiddenHeader = header.lastHiddenHeader;
  if (!ownerCt) {
    return;
  }
  if (me.forceFit) {
    delete me.flex;
  }
  if (lastHiddenHeader && !header.query('[hidden\x3dfalse]').length) {
    lastHiddenHeader.show();
    header.lastHiddenHeader = null;
  }
  me.onHeaderVisibilityChange(header, true);
  ownerCt.onHeaderShow(me, header);
  me.fireEvent('columnshow', me, header);
  me.fireEvent('columnschanged', this);
}, onHeaderHide:function(header) {
  var me = this, ownerCt = me.ownerCt;
  if (!ownerCt) {
    return;
  }
  me.onHeaderVisibilityChange(header, false);
  ownerCt.onHeaderHide(me, header);
  me.fireEvent('columnhide', me, header);
  me.fireEvent('columnschanged', this);
}, onHeaderResize:function(header, w) {
  var me = this, gridSection = me.ownerCt;
  if (gridSection) {
    gridSection.onHeaderResize(me, header, w);
  }
  me.fireEvent('columnresize', me, header, w);
}, onHeaderClick:function(header, e, t) {
  var me = this, selModel = header.getView().getSelectionModel(), ret;
  header.fireEvent('headerclick', me, header, e, t);
  ret = me.fireEvent('headerclick', me, header, e, t);
  if (ret !== false) {
    if (selModel.onHeaderClick) {
      selModel.onHeaderClick(me, header, e);
    }
  }
  return ret;
}, onHeaderContextMenu:function(header, e, t) {
  header.fireEvent('headercontextmenu', this, header, e, t);
  this.fireEvent('headercontextmenu', this, header, e, t);
}, onHeaderTriggerClick:function(header, e, t) {
  var me = this;
  if (header.fireEvent('headertriggerclick', me, header, e, t) !== false && me.fireEvent('headertriggerclick', me, header, e, t) !== false) {
    if (header.activeMenu) {
      if (e.pointerType) {
        header.activeMenu.hide();
      } else {
        header.activeMenu.focus();
      }
    } else {
      me.showMenuBy(e, t, header);
    }
  }
}, showMenuBy:function(clickEvent, t, header) {
  var menu = this.getMenu(), ascItem = menu.down('#ascItem'), descItem = menu.down('#descItem'), sortableMth, isTouch = clickEvent && clickEvent.pointerType === 'touch';
  menu.activeHeader = menu.ownerCmp = header;
  header.setMenuActive(menu);
  sortableMth = header.sortable ? 'enable' : 'disable';
  if (ascItem) {
    ascItem[sortableMth]();
  }
  if (descItem) {
    descItem[sortableMth]();
  }
  menu.autoFocus = !clickEvent || clickEvent.keyCode;
  menu.showBy(t, 'tl-bl?');
  if (!menu.isVisible()) {
    this.onMenuHide(menu);
  }
}, hideMenu:function() {
  if (this.menu) {
    this.menu.hide();
  }
}, onMenuHide:function(menu) {
  menu.activeHeader.setMenuActive(false);
}, purgeHeaderCtCache:function(headerCt) {
  while (headerCt) {
    headerCt.purgeCache();
    if (headerCt.isRootHeader) {
      return;
    }
    headerCt = headerCt.ownerCt;
  }
}, purgeCache:function() {
  var me = this, visibleColumnManager = me.visibleColumnManager, columnManager = me.columnManager;
  me.gridVisibleColumns = me.gridDataColumns = me.hideableColumns = null;
  if (visibleColumnManager) {
    visibleColumnManager.invalidate();
    columnManager.invalidate();
  }
}, getMenu:function() {
  var me = this, grid = me.view && me.view.ownerGrid;
  if (!me.menu) {
    me.menu = new Ext.menu.Menu({hideOnParentHide:false, items:me.getMenuItems(), listeners:{beforeshow:me.beforeMenuShow, hide:me.onMenuHide, scope:me}});
    me.fireEvent('menucreate', me, me.menu);
    if (grid) {
      grid.fireEvent('headermenucreate', grid, me.menu, me);
    }
  }
  return me.menu;
}, beforeMenuShow:function(menu) {
  var me = this, columnItem = menu.child('#columnItem'), hideableColumns, insertPoint;
  if (!columnItem) {
    hideableColumns = me.enableColumnHide ? me.getColumnMenu(me) : null;
    insertPoint = me.sortable ? 2 : 0;
    if (hideableColumns && hideableColumns.length) {
      menu.insert(insertPoint, [{itemId:'columnItemSeparator', xtype:'menuseparator'}, {itemId:'columnItem', text:me.columnsText, iconCls:me.menuColsIcon, menu:{items:hideableColumns}, hideOnClick:false}]);
    }
  }
  me.updateMenuDisabledState(me.menu);
}, getMenuItems:function() {
  var me = this, menuItems = [], hideableColumns = me.enableColumnHide ? me.getColumnMenu(me) : null;
  if (me.sortable) {
    menuItems = [{itemId:'ascItem', text:me.sortAscText, iconCls:me.menuSortAscCls, handler:me.onSortAscClick, scope:me}, {itemId:'descItem', text:me.sortDescText, iconCls:me.menuSortDescCls, handler:me.onSortDescClick, scope:me}];
  }
  if (hideableColumns && hideableColumns.length) {
    if (me.sortable) {
      menuItems.push({itemId:'columnItemSeparator', xtype:'menuseparator'});
    }
    menuItems.push({itemId:'columnItem', text:me.columnsText, iconCls:me.menuColsIcon, menu:hideableColumns, hideOnClick:false});
  }
  return menuItems;
}, onSortAscClick:function() {
  var menu = this.getMenu(), activeHeader = menu.activeHeader;
  activeHeader.sort('ASC');
}, onSortDescClick:function() {
  var menu = this.getMenu(), activeHeader = menu.activeHeader;
  activeHeader.sort('DESC');
}, getColumnMenu:function(headerContainer) {
  var menuItems = [], i = 0, item, items = headerContainer.query('\x3egridcolumn[hideable]'), itemsLn = items.length, menuItem;
  for (; i < itemsLn; i++) {
    item = items[i];
    menuItem = new Ext.menu.CheckItem({text:item.menuText || item.text, checked:!item.hidden, hideOnClick:false, headerId:item.id, menu:item.isGroupHeader ? this.getColumnMenu(item) : undefined, checkHandler:this.onColumnCheckChange, scope:this});
    menuItems.push(menuItem);
  }
  return menuItems.length ? menuItems : null;
}, onColumnCheckChange:function(checkItem, checked) {
  var header = Ext.getCmp(checkItem.headerId);
  if (header.rendered) {
    header[checked ? 'show' : 'hide']();
  } else {
    header.hidden = !checked;
  }
}, getColumnCount:function() {
  return this.getGridColumns().length;
}, getTableWidth:function() {
  var fullWidth = 0, headers = this.getVisibleGridColumns(), headersLn = headers.length, i;
  for (i = 0; i < headersLn; i++) {
    fullWidth += headers[i].getCellWidth() || 0;
  }
  return fullWidth;
}, getVisibleGridColumns:function() {
  var me = this, allColumns, rootHeader, result, len, i, column;
  if (me.gridVisibleColumns) {
    return me.gridVisibleColumns;
  }
  allColumns = me.getGridColumns();
  rootHeader = me.getRootHeaderCt();
  result = [];
  len = allColumns.length;
  for (i = 0; i < len; i++) {
    column = allColumns[i];
    if (!column.hidden && !column.isColumnHidden(rootHeader)) {
      result[result.length] = column;
    }
  }
  me.gridVisibleColumns = result;
  return result;
}, isColumnHidden:function(rootHeader) {
  var owner = this.getRefOwner();
  while (owner && owner !== rootHeader) {
    if (owner.hidden) {
      return true;
    }
    owner = owner.getRefOwner();
  }
  return false;
}, getGridColumns:function(inResult, hiddenAncestor) {
  if (!inResult && this.gridDataColumns) {
    return this.gridDataColumns;
  }
  var me = this, result = inResult || [], items, i, len, item, lastVisibleColumn;
  hiddenAncestor = hiddenAncestor || me.hidden;
  if (me.items) {
    items = me.items.items;
    if (items) {
      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        if (item.isGroupHeader) {
          item.visibleIndex = result.length;
          item.getGridColumns(result, hiddenAncestor);
        } else {
          item.hiddenAncestor = hiddenAncestor;
          result.push(item);
        }
      }
    }
  }
  if (!inResult) {
    me.gridDataColumns = result;
  }
  if (!inResult && len) {
    for (i = 0, len = result.length; i < len; i++) {
      item = result[i];
      item.fullColumnIndex = i;
      item.isFirstVisible = item.isLastVisible = false;
      if (!(item.hidden || item.hiddenAncestor)) {
        if (!lastVisibleColumn) {
          item.isFirstVisible = true;
        }
        lastVisibleColumn = item;
      }
    }
    if (lastVisibleColumn) {
      lastVisibleColumn.isLastVisible = true;
    }
  }
  return result;
}, getHideableColumns:function() {
  var me = this, result = me.hideableColumns;
  if (!result) {
    result = me.hideableColumns = me.query('[hideable]');
  }
  return result;
}, getHeaderIndex:function(header) {
  if (!this.columnManager) {
    this.columnManager = this.getRootHeaderCt().columnManager;
  }
  return this.columnManager.getHeaderIndex(header);
}, getHeaderAtIndex:function(index) {
  if (!this.columnManager) {
    this.columnManager = this.getRootHeaderCt().columnManager;
  }
  return this.columnManager.getHeaderAtIndex(index);
}, getVisibleHeaderClosestToIndex:function(index) {
  if (!this.visibleColumnManager) {
    this.visibleColumnManager = this.getRootHeaderCt().visibleColumnManager;
  }
  return this.visibleColumnManager.getVisibleHeaderClosestToIndex(index);
}, applyForceFit:function(header) {
  var me = this, view = me.view, minWidth = Ext.grid.plugin.HeaderResizer.prototype.minColWidth, useMinWidthForFlex = false, defaultWidth = Ext.grid.header.Container.prototype.defaultWidth, availFlex = me.el.dom.clientWidth - (view.el.dom.scrollHeight > view.el.dom.clientHeight ? Ext.getScrollbarSize().width : 0), totalFlex = 0, items = me.getVisibleGridColumns(), hidden = header.hidden, len, i, item, maxAvailFlexOneColumn, myWidth;
  function getTotalFlex() {
    for (i = 0, len = items.length; i < len; i++) {
      item = items[i];
      if (item === header) {
        continue;
      }
      item.flex = item.flex || item.width || item.getWidth();
      totalFlex += item.flex;
      item.width = null;
    }
  }
  function applyWidth() {
    var isCurrentHeader;
    for (i = 0, len = items.length; i < len; i++) {
      item = items[i];
      isCurrentHeader = item === header;
      if (useMinWidthForFlex && !isCurrentHeader) {
        item.flex = minWidth;
        item.width = null;
      } else {
        if (!isCurrentHeader) {
          myWidth = item.flex || defaultWidth;
          item.flex = Math.max(Math.ceil(myWidth / totalFlex * availFlex), minWidth);
          item.width = null;
        }
      }
      item.setWidth(item.width || item.flex);
    }
  }
  Ext.suspendLayouts();
  maxAvailFlexOneColumn = availFlex - (items.length + 1) * minWidth;
  header.flex = null;
  if (hidden) {
    myWidth = header.width || header.savedWidth || Math.floor(maxAvailFlexOneColumn / (items.length + 1));
    header.savedWidth = null;
  } else {
    myWidth = view.getMaxContentWidth(header);
  }
  if (myWidth > maxAvailFlexOneColumn) {
    header.width = maxAvailFlexOneColumn;
    useMinWidthForFlex = true;
  } else {
    header.width = myWidth;
    availFlex -= myWidth + defaultWidth;
    getTotalFlex();
  }
  applyWidth();
  Ext.resumeLayouts(true);
}, autoSizeColumn:function(header) {
  var view = this.view;
  if (view) {
    view.autoSizeColumn(header);
    if (this.forceFit) {
      this.applyForceFit(header);
    }
  }
}, getRefItems:function(deep) {
  var result = Ext.container.Container.prototype.getRefItems.call(this, deep);
  if (this.menu) {
    result.push(this.menu);
  }
  return result;
}, initInheritedState:function(inheritedState, inheritedStateInner) {
  if (this.sealed) {
    inheritedState.sealed = true;
  }
  Ext.container.Container.prototype.initInheritedState.call(this, inheritedState, inheritedStateInner);
}, privates:{beginChildHide:function() {
  ++this.childHideCount;
}, endChildHide:function() {
  --this.childHideCount;
}, getFocusables:function() {
  return this.isRootHeader ? this.getVisibleGridColumns() : this.items.items;
}, initFocusableContainerKeyNav:function(el) {
  var me = this;
  if (!me.focusableKeyNav) {
    me.focusableKeyNav = new Ext.util.KeyNav({target:el, scope:me, down:me.showHeaderMenu, left:me.onFocusableContainerLeftKey, right:me.onFocusableContainerRightKey, home:me.onHomeKey, end:me.onEndKey, space:me.onHeaderActivate, enter:me.onHeaderActivate});
  }
}, onHomeKey:function(e) {
  return this.focusChild(null, true, e);
}, onEndKey:function(e) {
  return this.focusChild(null, false, e);
}, showHeaderMenu:function(e) {
  var column = this.getFocusableFromEvent(e);
  if (column && column.isColumn && column.triggerEl) {
    this.onHeaderTriggerClick(column, e, column.triggerEl);
  }
}, onHeaderActivate:function(e) {
  var column = this.getFocusableFromEvent(e), view, lastFocused;
  if (column && column.isColumn) {
    view = column.getView();
    if (column.sortable && this.sortOnClick) {
      lastFocused = view.getNavigationModel().getLastFocused();
      column.toggleSortState();
      if (lastFocused) {
        view.ownerCt.ensureVisible(lastFocused.record);
      }
    } else {
      if (e.getKey() === e.SPACE) {
        column.onTitleElClick(e, e.target, this.sortOnClick);
      }
    }
    return this.onHeaderClick(column, e, column.el);
  }
}, onOwnerGridReconfigure:function(storeChanged, columnsChanged) {
  var me = this;
  if (!me.rendered || me.destroying || me.destroyed) {
    return;
  }
  if (storeChanged || columnsChanged) {
    if (Ext.Component.layoutSuspendCount) {
      me.$initFocusableContainerAfterLayout = true;
    } else {
      me.initFocusableContainer();
    }
  }
}}}, 0, ['headercontainer'], ['component', 'box', 'container', 'headercontainer'], {'component':true, 'box':true, 'container':true, 'headercontainer':true}, ['widget.headercontainer'], 0, [Ext.grid.header, 'Container'], 0);
Ext.cmd.derive('Ext.grid.column.Column', Ext.grid.header.Container, {alternateClassName:'Ext.grid.Column', config:{triggerVisible:false, sorter:null, align:'start'}, baseCls:'x-column-header', hoverCls:'x-column-header-over', ariaRole:'columnheader', focusableContainer:false, sortState:null, possibleSortStates:['ASC', 'DESC'], ariaSortStates:{ASC:'ascending', DESC:'descending'}, childEls:['titleEl', 'triggerEl', 'textEl', 'textContainerEl', 'textInnerEl'], headerWrap:false, renderTpl:['\x3cdiv id\x3d"{id}-titleEl" data-ref\x3d"titleEl" role\x3d"presentation"', 
'{tipMarkup}class\x3d"', 'x-', 'column-header-inner\x3ctpl if\x3d"!$comp.isContainer"\x3e ', 'x-', 'leaf-column-header\x3c/tpl\x3e', '\x3ctpl if\x3d"empty"\x3e ', 'x-', 'column-header-inner-empty\x3c/tpl\x3e"\x3e', '\x3cdiv id\x3d"{id}-textContainerEl" data-ref\x3d"textContainerEl" role\x3d"presentation" class\x3d"', 'x-', 'column-header-text-container"\x3e', '\x3cdiv role\x3d"presentation" class\x3d"', 'x-', 'column-header-text-wrapper"\x3e', '\x3cdiv id\x3d"{id}-textEl" data-ref\x3d"textEl" role\x3d"presentation" class\x3d"', 
'x-', 'column-header-text', '{childElCls}"\x3e', '\x3cspan id\x3d"{id}-textInnerEl" data-ref\x3d"textInnerEl" role\x3d"presentation" class\x3d"', 'x-', 'column-header-text-inner"\x3e{text}\x3c/span\x3e', '\x3c/div\x3e', '{%', 'values.$comp.afterText(out, values);', '%}', '\x3c/div\x3e', '\x3c/div\x3e', '\x3ctpl if\x3d"!menuDisabled"\x3e', '\x3cdiv id\x3d"{id}-triggerEl" data-ref\x3d"triggerEl" role\x3d"presentation" unselectable\x3d"on" class\x3d"', 'x-', 'column-header-trigger', '{childElCls}" style\x3d"{triggerStyle}"\x3e\x3c/div\x3e', 
'\x3c/tpl\x3e', '\x3c/div\x3e', '{%this.renderContainer(out,values)%}'], dataIndex:null, text:' ', menuText:null, emptyCellText:' ', sortable:true, resizable:true, hideable:true, menuDisabled:false, renderer:false, draggable:true, tooltipType:'qtip', initDraggable:Ext.emptyFn, tdCls:'', dirtyText:'Cell value has been edited', producesHTML:true, ignoreExport:false, exportStyle:null, exportRenderer:false, exportSummaryRenderer:false, isHeader:true, isColumn:true, scrollable:false, requiresMenu:false, 
tabIndex:-1, ascSortCls:'x-column-header-sort-ASC', descSortCls:'x-column-header-sort-DESC', componentLayout:'columncomponent', groupSubHeaderCls:'x-group-sub-header', groupHeaderCls:'x-group-header', clickTargetName:'titleEl', detachOnRemove:true, initResizable:Ext.emptyFn, rendererNames:{column:'renderer', edit:'editRenderer', summary:'summaryRenderer'}, formatterNames:{column:'formatter', edit:'editFormatter', summary:'summaryFormatter'}, initComponent:function() {
  var me = this;
  if (!me.rendererScope) {
    me.rendererScope = me.scope;
  }
  if (me.header != null) {
    me.text = me.header;
    me.header = null;
  }
  if (me.cellWrap) {
    me.tdCls = (me.tdCls || '') + ' x-wrap-cell';
  }
  if (me.columns != null) {
    me.isGroupHeader = true;
    me.ariaRole = 'presentation';
    me.items = me.columns;
    me.columns = null;
    me.cls = (me.cls || '') + ' ' + me.groupHeaderCls;
    me.sortable = me.resizable = false;
    me.align = 'center';
  } else {
    if (me.flex) {
      me.minWidth = me.minWidth || Ext.grid.plugin.HeaderResizer.prototype.minColWidth;
    }
  }
  me.addCls('x-column-header-align-' + me.getMappedAlignment(me.align));
  me.setupRenderer();
  me.setupRenderer('edit');
  me.setupRenderer('summary');
  Ext.grid.header.Container.prototype.initComponent.call(this);
}, beforeLayout:function() {
  var me = this, items = me.items, colCount = 0, flex = me.flex, len, i, item, hasFlexedChildren;
  if (flex && me.isGroupHeader) {
    if (!Ext.isArray(items)) {
      items = items.items;
    }
    len = items.length;
    for (i = 0; !hasFlexedChildren && i < len; i++) {
      item = items[i];
      if (item.isColumn && !item.hidden) {
        ++colCount;
        hasFlexedChildren = item.flex;
      }
    }
    if (!hasFlexedChildren && colCount) {
      me.savedFlex = flex;
      me.flex = null;
    }
  }
  Ext.grid.header.Container.prototype.beforeLayout.call(this);
}, onAdded:function(container, pos, instanced) {
  var me = this;
  Ext.grid.header.Container.prototype.onAdded.call(this, container, pos, instanced);
  me.view = me.rootHeaderCt = me.cellSelector = me.visibleIndex = null;
  if (!me.headerId) {
    me.calculateHeaderId();
  }
  me.configureStateInfo();
}, _initSorterFn:function(a, b) {
  var sorter = this, column = sorter.column, scope = column.resolveListenerScope(), name = sorter.methodName, fn = scope && scope[name], ret = 0;
  if (fn) {
    sorter.setSorterFn(fn);
    sorter.column = null;
    ret = fn.call(scope, a, b);
  }
  return ret;
}, applySorter:function(sorter) {
  var me = this, sorterFn = sorter ? sorter.sorterFn : null, tablepanel, ret;
  if (typeof sorterFn === 'string') {
    ret = new Ext.util.Sorter(Ext.applyIf({sorterFn:me._initSorterFn}, sorter));
    ret.methodName = sorterFn;
    ret.column = me;
  } else {
    tablepanel = me.getRootHeaderCt().up('tablepanel');
    ret = tablepanel.store.getData().getSorters().decodeSorter(sorter);
  }
  return ret;
}, updateAlign:function(align) {
  this.textAlign = this.getMappedAlignment(align);
}, bindFormatter:function(format) {
  var me = this;
  return function(v) {
    return format(v, me.rendererScope || me.resolveListenerScope());
  };
}, bindRenderer:function(renderer) {
  var me = this;
  me.hasCustomRenderer = true;
  return function() {
    return Ext.callback(renderer, me.rendererScope, arguments, 0, me);
  };
}, setupRenderer:function(type) {
  type = type || 'column';
  var me = this, format = me[me.formatterNames[type]], renderer = me[me.rendererNames[type]], isColumnRenderer = type === 'column', parser, dynamic;
  if (!format) {
    if (renderer) {
      if (typeof renderer === 'string') {
        renderer = me[me.rendererNames[type]] = me.bindRenderer(renderer);
        dynamic = true;
      }
      if (isColumnRenderer) {
        me.hasCustomRenderer = dynamic || renderer.length > 1;
      }
    } else {
      if (isColumnRenderer && me.defaultRenderer) {
        me.renderer = me.defaultRenderer;
        me.usingDefaultRenderer = true;
      }
    }
  } else {
    parser = Ext.app.bind.Parser.fly(format);
    format = parser.compileFormat();
    parser.release();
    me[me.formatterNames[type]] = null;
    me[me.rendererNames[type]] = me.bindFormatter(format);
  }
}, getView:function() {
  var rootHeaderCt;
  if (!this.view) {
    rootHeaderCt = this.getRootHeaderCt();
    if (rootHeaderCt) {
      this.view = rootHeaderCt.view;
    }
  }
  return this.view;
}, onFocusLeave:function(e) {
  Ext.grid.header.Container.prototype.onFocusLeave.call(this, e);
  if (this.activeMenu) {
    this.activeMenu.hide();
  }
}, initItems:function() {
  var me = this;
  Ext.grid.header.Container.prototype.initItems.apply(this, arguments);
  if (me.isGroupHeader) {
    if (me.config.hidden || !me.hasVisibleChildColumns()) {
      me.hide();
    }
  }
}, hasVisibleChildColumns:function() {
  var items = this.items.items, len = items.length, i, item;
  for (i = 0; i < len; ++i) {
    item = items[i];
    if (item.isColumn && !item.hidden) {
      return true;
    }
  }
  return false;
}, onAdd:function(child) {
  var me = this;
  if (child.isColumn) {
    child.isSubHeader = true;
    child.addCls(me.groupSubHeaderCls);
  }
  if (me.isGroupHeader && me.hidden && me.hasVisibleChildColumns()) {
    me.show();
  }
  Ext.grid.header.Container.prototype.onAdd.call(this, child);
}, onRemove:function(child, isDestroying) {
  var me = this;
  if (child.isSubHeader) {
    child.isSubHeader = false;
    child.removeCls(me.groupSubHeaderCls);
  }
  Ext.grid.header.Container.prototype.onRemove.call(this, child, isDestroying);
  if (!(me.destroyed || me.destroying) && !me.hasVisibleChildColumns() && (me.ownerCt && !me.ownerCt.isNested())) {
    me.hide();
  }
}, initRenderData:function() {
  var me = this, tipMarkup = '', tip = me.tooltip, text = me.text, attr = me.tooltipType === 'qtip' ? 'data-qtip' : 'title';
  if (!Ext.isEmpty(tip)) {
    tipMarkup = attr + '\x3d"' + tip + '" ';
  }
  return Ext.applyIf(Ext.grid.header.Container.prototype.initRenderData.apply(this, arguments), {text:text, empty:me.isEmptyText(text), menuDisabled:me.menuDisabled, tipMarkup:tipMarkup, triggerStyle:this.getTriggerVisible() ? 'display:block' : ''});
}, applyColumnState:function(state, storeState) {
  var me = this, sorter = me.getSorter(), stateSorters = storeState && storeState.sorters, len, i, savedSorter, mySorterId;
  if (sorter && stateSorters && (len = stateSorters.length)) {
    mySorterId = sorter.getId();
    for (i = 0; !savedSorter && i < len; i++) {
      if (stateSorters[i].id === mySorterId) {
        sorter.setDirection(stateSorters[i].direction);
        stateSorters[i] = sorter;
        break;
      }
    }
  }
  me.applyColumnsState(state.columns);
  if (state.hidden != null) {
    me.hidden = state.hidden;
  }
  if (state.locked != null) {
    me.locked = state.locked;
  }
  if (state.sortable != null) {
    me.sortable = state.sortable;
  }
  if (state.width != null) {
    me.flex = null;
    me.width = state.width;
  } else {
    if (state.flex != null) {
      me.width = null;
      me.flex = state.flex;
    }
  }
}, getColumnState:function() {
  var me = this, items = me.items.items, state = {id:me.getStateId()};
  me.savePropsToState(['hidden', 'sortable', 'locked', 'flex', 'width'], state);
  if (me.isGroupHeader && items && items.length) {
    state.columns = me.getColumnsState();
  }
  if ('width' in state) {
    delete state.flex;
  }
  return state;
}, setText:function(text) {
  var me = this, grid;
  me.text = text;
  if (me.rendered) {
    grid = me.getView().ownerGrid;
    me.textInnerEl.setHtml(text);
    me.titleEl.toggleCls('x-column-header-inner-empty', me.isEmptyText(text));
    grid.syncHeaderVisibility();
  }
}, getIndex:function() {
  return this.isGroupColumn ? false : this.getRootHeaderCt().getHeaderIndex(this);
}, getVisibleIndex:function() {
  return this.visibleIndex != null ? this.visibleIndex : this.isGroupColumn ? false : Ext.Array.indexOf(this.getRootHeaderCt().getVisibleGridColumns(), this);
}, getLabelChain:function() {
  var child = this, labels = [], parent;
  while (parent = child.up('headercontainer')) {
    if (parent.text) {
      labels.unshift(Ext.util.Format.stripTags(parent.text));
    }
    child = parent;
  }
  return labels;
}, beforeRender:function() {
  var me = this, rootHeaderCt = me.getRootHeaderCt(), isSortable = me.isSortable(), labels = [], ariaAttr;
  me.textAlign = me.getMappedAlignment(me.getAlign());
  Ext.grid.header.Container.prototype.beforeRender.call(this);
  if (!me.requiresMenu && !isSortable && !me.groupable && !me.lockable && (rootHeaderCt.grid.enableColumnHide === false || !rootHeaderCt.getHideableColumns().length)) {
    me.menuDisabled = true;
  }
  if (me.cellWrap) {
    me.variableRowHeight = true;
  }
  ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
  ariaAttr['aria-readonly'] = true;
  if (isSortable) {
    ariaAttr['aria-sort'] = me.ariaSortStates[me.sortState];
  }
  if (me.isSubHeader) {
    labels = me.getLabelChain();
    if (me.text) {
      labels.push(Ext.util.Format.stripTags(me.text));
    }
    if (labels.length) {
      ariaAttr['aria-label'] = labels.join(' ');
    }
  }
  me.protoEl.unselectable();
}, getTriggerElWidth:function() {
  var me = this, triggerEl = me.triggerEl, width = me.self.triggerElWidth;
  if (triggerEl && width === undefined) {
    triggerEl.setStyle('display', 'block');
    width = me.self.triggerElWidth = triggerEl.getWidth();
    triggerEl.setStyle('display', '');
  }
  return width;
}, afterComponentLayout:function(width, height, oldWidth, oldHeight) {
  var me = this, rootHeaderCt = me.getRootHeaderCt(), savedFlex = me.savedFlex;
  Ext.grid.header.Container.prototype.afterComponentLayout.call(this, width, height, oldWidth, oldHeight);
  if (rootHeaderCt && (oldWidth != null || me.flex) && width !== oldWidth) {
    rootHeaderCt.onHeaderResize(me, width);
  }
  if (savedFlex) {
    me.flex = savedFlex;
    delete me.savedFlex;
  }
}, doDestroy:function() {
  Ext.destroy(this.field, this.editor);
  Ext.grid.header.Container.prototype.doDestroy.call(this);
}, onTitleMouseOver:function() {
  this.titleEl.addCls(this.hoverCls);
}, onTitleMouseOut:function() {
  this.titleEl.removeCls(this.hoverCls);
}, onDownKey:function(e) {
  if (this.triggerEl) {
    this.onTitleElClick(e, this.triggerEl.dom || this.el.dom);
  }
}, onEnterKey:function(e) {
  this.onTitleElClick(e, this.el.dom);
}, onTitleElDblClick:function(e) {
  var me = this, prev, leafColumns, headerCt;
  if (me.isAtStartEdge(e)) {
    prev = me.previousNode('gridcolumn:not([hidden]):not([isGroupHeader])');
    if (prev && prev.getRootHeaderCt() === me.getRootHeaderCt()) {
      prev.autoSize();
    }
  } else {
    if (me.isAtEndEdge(e)) {
      if (me.isGroupHeader && e.getPoint().isContainedBy(me.layout.innerCt)) {
        leafColumns = me.query('gridcolumn:not([hidden]):not([isGroupHeader])');
        leafColumns[leafColumns.length - 1].autoSize();
        return;
      } else {
        headerCt = me.getRootHeaderCt();
        if (headerCt.visibleColumnManager.getColumns().length === 1 && headerCt.forceFit) {
          return;
        }
      }
      me.autoSize();
    }
  }
}, autoSize:function() {
  var me = this, leafColumns, numLeaves, i, headerCt;
  if (me.resizable) {
    if (me.isGroupHeader) {
      leafColumns = me.query('gridcolumn:not([hidden]):not([isGroupHeader])');
      numLeaves = leafColumns.length;
      headerCt = me.getRootHeaderCt();
      Ext.suspendLayouts();
      for (i = 0; i < numLeaves; i++) {
        headerCt.autoSizeColumn(leafColumns[i]);
      }
      Ext.resumeLayouts(true);
      return;
    }
    me.getRootHeaderCt().autoSizeColumn(me);
  }
}, isEmptyText:function(text, visual) {
  if (visual) {
    return Ext.String.trim(text).length === 0;
  } else {
    return text == null || text === '';
  }
}, onTitleElClick:function(e, t, sortOnClick) {
  var me = this, activeHeader, prevSibling, tapMargin;
  if (e.pointerType === 'touch') {
    prevSibling = me.previousSibling(':not([hidden])');
    if (!me.menuDisabled) {
      tapMargin = parseInt(me.triggerEl.getStyle('width'), 10);
      if (isNaN(tapMargin)) {
        tapMargin = me.getHandleWidth(e) * 3;
      }
      if (me.isAtEndEdge(e, tapMargin)) {
        activeHeader = me;
      }
    }
    if (!activeHeader && prevSibling && !prevSibling.menuDisabled && me.isAtStartEdge(e)) {
      activeHeader = prevSibling;
    }
  } else {
    activeHeader = me.triggerEl && (e.target === me.triggerEl.dom || t === me.triggerEl || e.within(me.triggerEl)) ? me : null;
  }
  if (sortOnClick !== false && (!activeHeader && !me.isAtStartEdge(e) && !me.isAtEndEdge(e) || e.getKey())) {
    me.toggleSortState();
  }
  return activeHeader;
}, processEvent:function(type, view, cell, recordIndex, cellIndex, e) {
  return this.fireEvent.apply(this, arguments);
}, isSortable:function() {
  var rootHeader = this.getRootHeaderCt(), grid = rootHeader ? rootHeader.grid : null, sortable = this.sortable;
  if (grid && grid.sortableColumns === false) {
    sortable = false;
  }
  return sortable;
}, toggleSortState:function() {
  if (this.isSortable()) {
    this.sort();
  }
}, sort:function(direction) {
  var me = this, grid = me.up('tablepanel'), store = grid.store, sorter = me.getSorter();
  Ext.suspendLayouts();
  if (sorter) {
    if (direction) {
      sorter.setDirection(direction);
    }
    store.sort(sorter, grid.multiColumnSort ? 'multi' : 'replace');
  } else {
    store.sort(me.getSortParam(), direction, grid.multiColumnSort ? 'multi' : 'replace');
  }
  Ext.resumeLayouts(true);
}, getSortParam:function() {
  return this.dataIndex;
}, setSortState:function(sorter) {
  var me = this, direction = sorter && sorter.getDirection(), ascCls = me.ascSortCls, descCls = me.descSortCls, rootHeaderCt = me.getRootHeaderCt(), ariaDom = me.ariaEl.dom, changed;
  switch(direction) {
    case 'DESC':
      if (!me.hasCls(descCls)) {
        me.addCls(descCls);
        me.sortState = 'DESC';
        changed = true;
      }
      me.removeCls(ascCls);
      break;
    case 'ASC':
      if (!me.hasCls(ascCls)) {
        me.addCls(ascCls);
        me.sortState = 'ASC';
        changed = true;
      }
      me.removeCls(descCls);
      break;
    default:
      me.removeCls([ascCls, descCls]);
      me.sortState = null;
      break;
  }
  if (ariaDom) {
    if (me.sortState) {
      ariaDom.setAttribute('aria-sort', me.ariaSortStates[me.sortState]);
    } else {
      ariaDom.removeAttribute('aria-sort');
    }
  }
  if (changed) {
    rootHeaderCt.fireEvent('sortchange', rootHeaderCt, me, direction);
  }
}, isHideable:function() {
  var result = {hideCandidate:this, result:this.hideable};
  if (result.result) {
    this.ownerCt.bubble(this.hasOtherMenuEnabledChildren, null, [result]);
  }
  return result.result;
}, hasOtherMenuEnabledChildren:function(result) {
  var visibleChildren, count;
  if (!this.isXType('headercontainer')) {
    result.result = false;
    return false;
  }
  visibleChildren = this.query('\x3egridcolumn:not([hidden]):not([menuDisabled])');
  count = visibleChildren.length;
  if (Ext.Array.contains(visibleChildren, result.hideCandidate)) {
    count--;
  }
  if (count) {
    return false;
  }
  result.hideCandidate = this;
}, isLockable:function() {
  var result = {result:this.lockable !== false};
  if (result.result) {
    this.ownerCt.bubble(this.hasMultipleVisibleChildren, null, [result]);
  }
  return result.result;
}, isLocked:function() {
  if (this.locked == null) {
    this.locked = this.getInherited().inLockedGrid;
  }
  return this.locked;
}, hasMultipleVisibleChildren:function(result) {
  if (!this.isXType('headercontainer')) {
    result.result = false;
    return false;
  }
  if (this.query('\x3egridcolumn:not([hidden])').length > 1) {
    return false;
  }
}, hide:function() {
  var me = this, rootHeaderCt = me.getRootHeaderCt(), owner = me.getRefOwner();
  if (owner.constructing) {
    Ext.grid.header.Container.prototype.hide.call(this);
    return me;
  }
  if (me.rendered && !me.isVisible()) {
    return me;
  }
  if (rootHeaderCt.forceFit) {
    me.visibleSiblingCount = rootHeaderCt.getVisibleGridColumns().length - 1;
    if (me.flex) {
      me.savedWidth = me.getWidth();
      me.flex = null;
    }
  }
  rootHeaderCt.beginChildHide();
  Ext.suspendLayouts();
  if (owner.isGroupHeader) {
    if (me.isNestedGroupHeader()) {
      owner.hide();
    }
    if (me.isSubHeader && !me.isGroupHeader && owner.query('\x3egridcolumn:not([hidden])').length === 1) {
      owner.lastHiddenHeader = me;
    }
  }
  Ext.grid.header.Container.prototype.hide.call(this);
  rootHeaderCt.endChildHide();
  rootHeaderCt.onHeaderHide(me);
  Ext.resumeLayouts(true);
  return me;
}, show:function() {
  var me = this, rootHeaderCt = me.getRootHeaderCt(), ownerCt = me.getRefOwner();
  if (me.isVisible()) {
    return me;
  }
  if (ownerCt.isGroupHeader) {
    ownerCt.lastHiddenHeader = null;
  }
  if (me.rendered) {
    if (rootHeaderCt.forceFit) {
      rootHeaderCt.applyForceFit(me);
    }
  }
  Ext.suspendLayouts();
  if (me.isSubHeader && ownerCt.hidden) {
    ownerCt.show(false, true);
  }
  Ext.grid.header.Container.prototype.show.apply(this, arguments);
  if (me.isGroupHeader) {
    me.maybeShowNestedGroupHeader();
  }
  ownerCt = me.getRootHeaderCt();
  if (ownerCt) {
    ownerCt.onHeaderShow(me);
  }
  Ext.resumeLayouts(true);
  return me;
}, shouldUpdateCell:function(record, changedFieldNames) {
  if (!this.preventUpdate) {
    if (this.hasCustomRenderer) {
      return 1;
    }
    if (changedFieldNames) {
      var len = changedFieldNames.length, i, field;
      for (i = 0; i < len; ++i) {
        field = changedFieldNames[i];
        if (field === this.dataIndex || field === record.idProperty) {
          return 2;
        }
      }
    } else {
      return 2;
    }
  }
}, getCellWidth:function() {
  var me = this, result;
  if (me.rendered && me.componentLayout && me.componentLayout.lastComponentSize) {
    result = me.componentLayout.lastComponentSize.width;
  } else {
    if (me.width) {
      result = me.width;
    } else {
      if (!me.isColumn) {
        result = me.getTableWidth();
      }
    }
  }
  return result;
}, getCellId:function() {
  return 'x-grid-cell-' + this.getItemId();
}, getCellSelector:function() {
  if (!this.cellSelector) {
    var view = this.getView();
    this.cellSelector = (view ? view.getCellSelector() : '') + '.' + this.getCellId();
  }
  return this.cellSelector;
}, getCellInnerSelector:function() {
  return this.getCellSelector() + ' .x-grid-cell-inner';
}, isAtStartEdge:function(e) {
  var offset = e.getXY()[0] - this.getX();
  if (offset < 0 && this.getIndex() === 0) {
    return false;
  }
  return offset < this.getHandleWidth(e);
}, isAtEndEdge:function(e, margin) {
  return this.getX() + this.getWidth() - e.getXY()[0] <= (margin || this.getHandleWidth(e));
}, getHandleWidth:function(e) {
  return e.pointerType === 'touch' ? 10 : 4;
}, setMenuActive:function(menu) {
  this.activeMenu = menu;
  this.titleEl[menu ? 'addCls' : 'removeCls'](this.headerOpenCls);
}, privates:{_alignMap:{start:'left', end:'right'}, afterText:function(out, values) {
  if (this.dirtyText) {
    this.dirtyTextElementId = this.id + '-dirty-cell-text';
    out.push('\x3cspan id\x3d"' + this.dirtyTextElementId + '" class\x3d"x-hidden-offsets"\x3e' + this.dirtyText + '\x3c/span\x3e');
  }
}, calculateHeaderId:function() {
  var me = this, ownerGrid, counterOwner, items, item, i, len;
  if (!me.headerId) {
    ownerGrid = me.up('tablepanel');
    if (!ownerGrid) {
      return;
    }
    items = me.items.items;
    if (items) {
      for (i = 0, len = items.length; i < len; ++i) {
        item = items[i];
        if (item.isColumn) {
          item.calculateHeaderId();
        }
      }
    }
    counterOwner = ownerGrid ? ownerGrid.ownerGrid : me.getRootHeaderCt();
    counterOwner.headerCounter = (counterOwner.headerCounter || 0) + 1;
    me.headerId = 'h' + counterOwner.headerCounter;
  }
  me.configureStateInfo();
}, getMappedAlignment:function(align) {
  return this._alignMap[align] || align;
}, configureStateInfo:function() {
  var me = this, sorter;
  if (!me.stateId) {
    me.stateId = me.initialConfig.id || me.headerId;
  }
  sorter = me.getSorter();
  if (!me.hasSetSorter && sorter && !sorter.initialConfig.id) {
    if (me.dataIndex || me.stateId) {
      sorter.setId((me.dataIndex || me.stateId) + '-sorter');
      me.hasSetSorter = true;
    }
  }
}, onLock:function(header) {
  var items = this.items.items, len = items.length, i, item;
  for (i = 0; i < len; ++i) {
    item = items[i];
    if (item.isColumn) {
      item.onLock(header);
    }
  }
}, onUnlock:function(header) {
  var items = this.items.items, len = items.length, i, item;
  for (i = 0; i < len; ++i) {
    item = items[i];
    if (item.isColumn) {
      item.onUnlock(header);
    }
  }
}}, deprecated:{5:{methods:{bindRenderer:function(renderer) {
  return function(value) {
    return Ext.util.Format[renderer](value);
  };
}}}}}, 0, ['gridcolumn'], ['component', 'box', 'container', 'headercontainer', 'gridcolumn'], {'component':true, 'box':true, 'container':true, 'headercontainer':true, 'gridcolumn':true}, ['widget.gridcolumn'], 0, [Ext.grid.column, 'Column', Ext.grid, 'Column'], 0);
Ext.define('Ext.theme.triton.grid.column.Column', {override:'Ext.grid.column.Column', compatibility:Ext.isIE8, onTitleMouseOver:function() {
  var triggerEl = this.triggerEl;
  arguments.callee.$previous.apply(this, arguments);
  if (triggerEl) {
    triggerEl.syncRepaint();
  }
}});
Ext.cmd.derive('Ext.grid.column.Check', Ext.grid.column.Column, {alternateClassName:['Ext.ux.CheckColumn', 'Ext.grid.column.CheckColumn'], isCheckColumn:true, config:{headerCheckbox:false}, align:'center', triggerEvent:'click', invert:false, ignoreExport:true, stopSelection:true, headerCheckedCls:'x-grid-hd-checker-on', headerCheckboxCls:'x-column-header-checkbox', checkboxCls:'x-grid-checkcolumn', checkboxCheckedCls:'x-grid-checkcolumn-checked', innerCls:'x-grid-checkcolumn-cell-inner', clickTargetName:'el', 
defaultFilterType:'boolean', checkboxAriaRole:'button', constructor:function(config) {
  this.scope = this;
  Ext.grid.column.Column.prototype.constructor.call(this, config);
}, afterComponentLayout:function() {
  var me = this;
  Ext.grid.column.Column.prototype.afterComponentLayout.apply(this, arguments);
  if (me.useAriaElements && me.headerCheckbox) {
    me.updateHeaderAriaDescription(me.areAllChecked());
  }
  if (!me.storeListeners) {
    me.updateHeaderState();
    me.storeListeners = me.getView().dataSource.on({datachanged:me.onDataChanged, scope:me, destroyable:true});
  }
}, onRemoved:function() {
  Ext.grid.column.Column.prototype.onRemoved.apply(this, arguments);
  this.storeListeners = Ext.destroy(this.storeListeners);
}, onDataChanged:function(store, records) {
  this.updateHeaderState();
}, updateHeaderCheckbox:function(headerCheckbox) {
  var me = this, cls = 'x-column-header-checkbox';
  if (headerCheckbox) {
    me.addCls(cls);
    me.sortable = false;
    if (me.useAriaElements) {
      me.updateHeaderAriaDescription(me.areAllChecked());
    }
  } else {
    me.removeCls(cls);
    if (me.useAriaElements && me.ariaEl.dom) {
      me.ariaEl.dom.removeAttribute('aria-describedby');
    }
  }
  me.updateHeaderState();
}, processEvent:function(type, view, cell, recordIndex, cellIndex, e, record, row) {
  var me = this, key = type === 'keydown' && e.getKey(), isClick = type === me.triggerEvent, disabled = me.disabled, ret, checked;
  e.stopSelection = !key && me.stopSelection;
  if (!disabled && (isClick || (key === e.ENTER || key === e.SPACE))) {
    checked = !me.isRecordChecked(record);
    if (me.fireEvent('beforecheckchange', me, recordIndex, checked, record, e) !== false) {
      me.setRecordCheck(record, recordIndex, checked, cell, e);
      if (isClick && !view.actionableMode) {
        e.preventDefault();
      }
      if (me.hasListeners.checkchange) {
        me.fireEvent('checkchange', me, recordIndex, checked, record, e);
      }
    }
  } else {
    ret = Ext.grid.column.Column.prototype.processEvent.apply(this, arguments);
  }
  return ret;
}, onTitleElClick:function(e, t, sortOnClick) {
  var me = this;
  if (!me.disabled && (e.keyCode || !me.text || Ext.fly(e.target).hasCls(me.headerCheckboxCls))) {
    me.toggleAll(e);
  } else {
    return Ext.grid.column.Column.prototype.onTitleElClick.call(this, e, t, sortOnClick);
  }
}, toggleAll:function(e) {
  var me = this, view = me.getView(), store = view.getStore(), checked = !me.allChecked, position;
  if (me.fireEvent('beforeheadercheckchange', me, checked, e) !== false) {
    if (me.hasListeners.checkchange || me.hasListeners.beforecheckchange) {
      position = e.position = new Ext.grid.CellContext(view);
    }
    store.each(function(record, recordIndex) {
      me.setRecordCheck(record, recordIndex, checked, view.getCell(record, me));
    });
    me.setHeaderStatus(checked, e);
    me.fireEvent('headercheckchange', me, checked, e);
  }
}, setHeaderStatus:function(checked, e) {
  var me = this;
  if (me.allChecked !== checked) {
    me.allChecked = checked;
    if (me.headerCheckbox) {
      me[checked ? 'addCls' : 'removeCls'](me.headerCheckedCls);
      if (me.useAriaElements) {
        me.updateHeaderAriaDescription(checked);
      }
    }
  }
}, updateHeaderState:function(e) {
  var me = this;
  if (!me.headerStateTimer) {
    me.headerStateTimer = Ext.raf(me.doUpdateHeaderState, me);
  }
}, doUpdateHeaderState:function(e) {
  var me = this;
  me.headerStateTimer = null;
  if (!me.destroyed && me.headerCheckbox) {
    me.setHeaderStatus(me.areAllChecked(), e);
  }
}, onEnable:function() {
  Ext.grid.column.Column.prototype.onEnable.apply(this, arguments);
  this._setDisabled(false);
}, onDisable:function() {
  this._setDisabled(true);
}, _setDisabled:function(disabled) {
  var me = this, cls = me.disabledCls, items;
  items = me.up('tablepanel').el.select(me.getCellSelector());
  if (disabled) {
    items.addCls(cls);
  } else {
    items.removeCls(cls);
  }
}, defaultRenderer:function(value, cellValues) {
  var me = this, cls = me.checkboxCls, tip = '';
  if (me.invert) {
    value = !value;
  }
  if (me.disabled) {
    cellValues.tdCls += ' ' + me.disabledCls;
  }
  if (value) {
    cls += ' ' + me.checkboxCheckedCls;
    tip = me.checkedTooltip;
  } else {
    tip = me.tooltip;
  }
  if (tip) {
    cellValues.tdAttr += ' data-qtip\x3d"' + Ext.htmlEncode(tip) + '"';
  }
  if (me.useAriaElements) {
    cellValues.tdAttr += ' aria-describedby\x3d"' + me.id + '-cell-description' + (!value ? '-not' : '') + '-selected"';
  }
  me.updateHeaderState();
  return '\x3cspan class\x3d"' + cls + '" role\x3d"' + me.checkboxAriaRole + '"' + (!me.ariaStaticRoles[me.checkboxAriaRole] ? ' tabIndex\x3d"0"' : '') + '\x3e\x3c/span\x3e';
}, isRecordChecked:function(record) {
  var prop = this.property;
  if (prop) {
    return record[prop];
  }
  return record.get(this.dataIndex);
}, areAllChecked:function() {
  var me = this, store = me.getView().getStore(), records, len, i;
  if (!store.isBufferedStore && store.getCount() > 0) {
    records = store.getData().items;
    len = records.length;
    for (i = 0; i < len; ++i) {
      if (!me.isRecordChecked(records[i])) {
        return false;
      }
    }
    return true;
  }
}, setRecordCheck:function(record, recordIndex, checked, cell) {
  var me = this, prop = me.property;
  if (prop ? record[prop] : record.get(me.dataIndex) != checked) {
    if (prop) {
      record[prop] = checked;
      me.updater(cell, checked);
    } else {
      record.set(me.dataIndex, checked);
    }
  }
}, updater:function(cell, value) {
  var me = this, tip;
  if (me.invert) {
    value = !value;
  }
  if (value) {
    tip = me.checkedTooltip;
  } else {
    tip = me.tooltip;
  }
  if (tip) {
    cell.setAttribute('data-qtip', tip);
  } else {
    cell.removeAttribute('data-qtip');
  }
  if (me.useAriaElements) {
    me.updateCellAriaDescription(null, value, cell);
  }
  cell = Ext.fly(cell);
  cell[me.disabled ? 'addCls' : 'removeCls'](me.disabledCls);
  Ext.fly(cell.down(me.getView().innerSelector, true).firstChild)[value ? 'addCls' : 'removeCls']('x-grid-checkcolumn-checked');
  me.updateHeaderState();
}, updateHeaderAriaDescription:function(isSelected) {
  var me = this;
  if (me.useAriaElements && me.ariaEl.dom) {
    me.ariaEl.dom.setAttribute('aria-describedby', me.id + '-header-description' + (!isSelected ? '-not' : '') + '-selected');
  }
}, updateCellAriaDescription:function(record, isSelected, cell) {
  var me = this;
  if (me.useAriaElements) {
    cell = cell || me.getView().getCell(record, me);
    if (cell) {
      cell.setAttribute('aria-describedby', me.id + '-cell-description' + (!isSelected ? '-not' : '') + '-selected');
    }
  }
}, doDestroy:function() {
  Ext.unraf(this.headerStateTimer);
  Ext.grid.column.Column.prototype.doDestroy.call(this);
}, privates:{afterText:function(out, values) {
  var me = this, id = me.id;
  out.push('\x3cspan role\x3d"presentation" class\x3d"', me.headerCheckboxCls, '"\x3e\x3c/span\x3e');
  if (me.useAriaElements) {
    out.push('\x3cspan id\x3d"' + id + '-header-description-selected" class\x3d"x-hidden-offsets"\x3e' + me.headerDeselectText + '\x3c/span\x3e\x3cspan id\x3d"' + id + '-header-description-not-selected" class\x3d"x-hidden-offsets"\x3e' + me.headerSelectText + '\x3c/span\x3e\x3cspan id\x3d"' + id + '-cell-description-selected" class\x3d"x-hidden-offsets"\x3e' + me.rowDeselectText + '\x3c/span\x3e\x3cspan id\x3d"' + id + '-cell-description-not-selected" class\x3d"x-hidden-offsets"\x3e' + me.rowSelectText + 
    '\x3c/span\x3e');
  }
}}}, 1, ['checkcolumn'], ['component', 'box', 'container', 'headercontainer', 'gridcolumn', 'checkcolumn'], {'component':true, 'box':true, 'container':true, 'headercontainer':true, 'gridcolumn':true, 'checkcolumn':true}, ['widget.checkcolumn'], 0, [Ext.grid.column, 'Check', Ext.ux, 'CheckColumn', Ext.grid.column, 'CheckColumn'], 0);
Ext.define('Ext.theme.triton.grid.column.Check', {override:'Ext.grid.column.Check', compatibility:Ext.isIE8, setRecordCheck:function(record, index, checked, cell) {
  arguments.callee.$previous.apply(this, arguments);
  Ext.fly(cell).syncRepaint();
}});
Ext.cmd.derive('Ext.menu.Item', Ext.Component, {alternateClassName:'Ext.menu.TextItem', isMenuItem:true, config:{glyph:null}, activated:false, activeCls:'x-menu-item-active', clickHideDelay:0, destroyMenu:true, disabledCls:'x-menu-item-disabled', hideOnClick:true, menuAlign:'tl-tr?', menuExpandDelay:200, menuHideDelay:200, tooltipType:'qtip', focusable:true, ariaRole:'menuitem', ariaEl:'itemEl', baseCls:'x-menu-item', arrowCls:'x-menu-item-arrow', baseIconCls:'x-menu-item-icon', textCls:'x-menu-item-text', 
indentCls:'x-menu-item-indent', indentNoSeparatorCls:'x-menu-item-indent-no-separator', indentRightIconCls:'x-menu-item-indent-right-icon', indentRightArrowCls:'x-menu-item-indent-right-arrow', linkCls:'x-menu-item-link', linkHrefCls:'x-menu-item-link-href', childEls:['itemEl', 'iconEl', 'textEl', 'arrowEl'], renderTpl:'\x3ctpl if\x3d"plain"\x3e{text}\x3ctpl else\x3e\x3ca id\x3d"{id}-itemEl" data-ref\x3d"itemEl" class\x3d"{linkCls}\x3ctpl if\x3d"hasHref"\x3e {linkHrefCls}\x3c/tpl\x3e{childElCls}" href\x3d"{href}" \x3ctpl if\x3d"hrefTarget"\x3e target\x3d"{hrefTarget}"\x3c/tpl\x3e hidefocus\x3d"true" unselectable\x3d"on"\x3ctpl if\x3d"tabIndex !\x3d null"\x3e tabindex\x3d"{tabIndex}"\x3c/tpl\x3e\x3ctpl foreach\x3d"ariaAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e\x3e\x3cspan id\x3d"{id}-textEl" data-ref\x3d"textEl" class\x3d"{textCls} {textCls}-{ui} {indentCls}{childElCls}" unselectable\x3d"on" role\x3d"presentation"\x3e{text}\x3c/span\x3e\x3ctpl if\x3d"hasIcon"\x3e\x3cdiv role\x3d"presentation" id\x3d"{id}-iconEl" data-ref\x3d"iconEl" class\x3d"{baseIconCls}-{ui} {baseIconCls}{[values.rightIcon ? "-right" : ""]} {iconCls}{childElCls} {glyphCls}" style\x3d"\x3ctpl if\x3d"icon"\x3ebackground-image:url({icon});\x3c/tpl\x3e\x3ctpl if\x3d"glyph"\x3e\x3ctpl if\x3d"glyphFontFamily"\x3efont-family:{glyphFontFamily};\x3c/tpl\x3e"\x3e{glyph}\x3ctpl else\x3e"\x3e\x3c/tpl\x3e\x3c/div\x3e\x3c/tpl\x3e\x3ctpl if\x3d"showCheckbox"\x3e\x3cdiv role\x3d"presentation" id\x3d"{id}-checkEl" data-ref\x3d"checkEl" class\x3d"{baseIconCls}-{ui} {baseIconCls}{[(values.hasIcon \x26\x26 !values.rightIcon) ? "-right" : ""]} {groupCls} {checkboxCls}{childElCls}"\x3e\x3c/div\x3e\x3c/tpl\x3e\x3ctpl if\x3d"hasMenu"\x3e\x3cdiv role\x3d"presentation" id\x3d"{id}-arrowEl" data-ref\x3d"arrowEl" class\x3d"{arrowCls} {arrowCls}-{ui}{childElCls}"\x3e\x3c/div\x3e\x3c/tpl\x3e\x3c/a\x3e\x3c/tpl\x3e', 
autoEl:{role:'presentation'}, maskOnDisable:false, iconAlign:'left', initComponent:function() {
  var me = this, cls = me.cls ? [me.cls] : [], menu;
  if (me.hasOwnProperty('canActivate')) {
    me.focusable = me.canActivate;
  }
  if (me.plain) {
    cls.push('x-menu-item-plain');
  }
  if (cls.length) {
    me.cls = cls.join(' ');
  }
  if (me.menu) {
    menu = me.menu;
    me.menu = null;
    me.setMenu(menu);
  }
  Ext.Component.prototype.initComponent.apply(this, arguments);
}, canFocus:function() {
  var me = this;
  return me.focusable && me.rendered && me.canActivate !== false && !me.destroying && !me.destroyed && me.isVisible(true);
}, onFocus:function(e) {
  var me = this;
  Ext.Component.prototype.onFocus.call(this, e);
  if (!me.plain) {
    me.addCls(me.activeCls);
  }
  me.activated = true;
  if (me.hasListeners.activate) {
    me.fireEvent('activate', me);
  }
}, onFocusLeave:function(e) {
  var me = this;
  Ext.Component.prototype.onFocusLeave.call(this, e);
  if (!me.plain) {
    me.removeCls(me.activeCls);
  }
  me.doHideMenu();
  me.activated = false;
  if (me.hasListeners.deactivate) {
    me.fireEvent('deactivate', me);
  }
}, doHideMenu:function() {
  var menu = this.menu;
  this.cancelDeferExpand();
  if (menu && menu.isVisible()) {
    menu.hide();
  }
}, deferHideParentMenus:function() {
  for (var menu = this.getRefOwner(); menu && (menu.isMenu && menu.floating || menu.isMenuItem); menu = menu.getRefOwner()) {
    if (menu.isMenu) {
      menu.hide();
    }
  }
}, expandMenu:function(event, delay) {
  var me = this;
  if (!me.disabled && me.activated && me.menu) {
    me.hideOnClick = false;
    me.cancelDeferHide();
    delay = delay == null ? me.menuExpandDelay : delay;
    if (delay === 0) {
      me.doExpandMenu(event);
    } else {
      me.cancelDeferExpand();
      me.expandMenuTimer = Ext.defer(me.doExpandMenu, delay, me, [event]);
    }
  }
}, doExpandMenu:function(clickEvent) {
  var me = this, menu = me.menu;
  if (!menu.isVisible()) {
    me.parentMenu.activeChild = menu;
    menu.ownerCmp = me;
    menu.parentMenu = me.parentMenu;
    menu.constrainTo = document.body;
    menu.autoFocus = !clickEvent || !clickEvent.pointerType;
    menu.showBy(me, me.menuAlign);
  } else {
    if (clickEvent && clickEvent.type === 'keydown') {
      menu.focus();
    }
  }
}, getRefItems:function(deep) {
  var menu = this.menu, items;
  if (menu) {
    items = menu.getRefItems(deep);
    items.unshift(menu);
  }
  return items || [];
}, getValue:function() {
  return this.value;
}, hideMenu:function(delay) {
  var me = this;
  if (me.menu) {
    me.cancelDeferExpand();
    me.hideMenuTimer = Ext.defer(me.doHideMenu, Ext.isNumber(delay) ? delay : me.menuHideDelay, me);
  }
}, onClick:function(e) {
  var me = this, clickHideDelay = me.clickHideDelay, browserEvent = e.browserEvent, clickResult, preventDefault;
  if (!me.href || me.disabled) {
    e.stopEvent();
    if (me.disabled) {
      return false;
    }
  }
  if (me.disabled || me.handlingClick) {
    return;
  }
  if (me.hideOnClick && !me.menu) {
    if (!clickHideDelay) {
      me.deferHideParentMenus();
    } else {
      me.deferHideParentMenusTimer = Ext.defer(me.deferHideParentMenus, clickHideDelay, me);
    }
  }
  clickResult = me.fireEvent('click', me, e);
  if (me.destroyed) {
    return;
  }
  if (clickResult !== false && me.handler) {
    Ext.callback(me.handler, me.scope, [me, e], 0, me);
  }
  if (me.destroyed) {
    return;
  }
  if (Ext.isIE9m) {
    preventDefault = browserEvent.returnValue === false ? true : false;
  } else {
    preventDefault = !!browserEvent.defaultPrevented;
  }
  if (me.href && e.type !== 'click' && !preventDefault) {
    me.handlingClick = true;
    me.itemEl.dom.click();
    me.handlingClick = false;
  }
  if (!me.hideOnClick && !me.hasFocus) {
    me.focus();
  }
  return clickResult;
}, onRemoved:function() {
  var me = this;
  if (me.activated && me.parentMenu.activeItem === me) {
    me.parentMenu.deactivateActiveItem();
  }
  Ext.Component.prototype.onRemoved.apply(this, arguments);
  me.parentMenu = me.ownerCmp = null;
}, doDestroy:function() {
  var me = this;
  if (me.rendered) {
    me.clearTip();
  }
  me.cancelDeferExpand();
  me.cancelDeferHide();
  Ext.undefer(me.deferHideParentMenusTimer);
  me.setMenu(null);
  Ext.Component.prototype.doDestroy.call(this);
}, beforeRender:function() {
  var me = this, glyph = me.glyph, glyphFontFamily, hasIcon = !!(me.icon || me.iconCls || glyph), hasMenu = !!me.menu, rightIcon = me.iconAlign === 'right' && !hasMenu, isCheckItem = me.isMenuCheckItem, indentCls = [], ownerCt = me.ownerCt, isOwnerPlain = ownerCt.plain;
  if (me.plain) {
    me.ariaEl = 'el';
  }
  Ext.Component.prototype.beforeRender.call(this);
  if (hasIcon) {
    if (hasMenu && me.showCheckbox) {
      hasIcon = false;
    }
  }
  if (glyph) {
    glyphFontFamily = glyph.fontFamily;
    glyph = glyph.character;
  }
  if (!isOwnerPlain || hasIcon && !rightIcon || isCheckItem) {
    if (ownerCt.showSeparator && !isOwnerPlain) {
      indentCls.push(me.indentCls);
    } else {
      indentCls.push(me.indentNoSeparatorCls);
    }
  }
  if (hasMenu) {
    indentCls.push(me.indentRightArrowCls);
  } else {
    if (hasIcon && (rightIcon || isCheckItem)) {
      indentCls.push(me.indentRightIconCls);
    }
  }
  Ext.applyIf(me.renderData, {hasHref:!!me.href, href:me.href || '#', hrefTarget:me.hrefTarget, icon:me.icon, iconCls:me.iconCls, glyph:glyph, glyphCls:glyph ? 'x-menu-item-glyph' : undefined, glyphFontFamily:glyphFontFamily, hasIcon:hasIcon, hasMenu:hasMenu, indent:!isOwnerPlain || hasIcon || isCheckItem, isCheckItem:isCheckItem, rightIcon:rightIcon, plain:me.plain, text:me.text, arrowCls:me.arrowCls, baseIconCls:me.baseIconCls, textCls:me.textCls, indentCls:indentCls.join(' '), linkCls:me.linkCls, 
  linkHrefCls:me.linkHrefCls, groupCls:me.group ? me.groupCls : '', tabIndex:me.tabIndex});
}, onRender:function() {
  var me = this;
  Ext.Component.prototype.onRender.apply(this, arguments);
  if (me.tooltip) {
    me.setTooltip(me.tooltip, true);
  }
}, getMenu:function() {
  return this.menu || null;
}, setMenu:function(menu, destroyMenu) {
  var me = this, oldMenu = me.menu, arrowEl = me.arrowEl, ariaDom = me.ariaEl.dom, ariaAttr, instanced;
  if (oldMenu) {
    oldMenu.ownerCmp = oldMenu.parentMenu = null;
    if (destroyMenu === true || destroyMenu !== false && me.destroyMenu) {
      Ext.destroy(oldMenu);
    }
    if (ariaDom) {
      ariaDom.removeAttribute('aria-haspopup');
      ariaDom.removeAttribute('aria-owns');
    } else {
      ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
      delete ariaAttr['aria-haspopup'];
      delete ariaAttr['aria-owns'];
    }
  }
  if (menu) {
    instanced = menu.isMenu;
    menu = me.menu = Ext.menu.Manager.get(menu, {ownerCmp:me, focusOnToFront:false});
    menu.setOwnerCmp(me, instanced);
    if (ariaDom) {
      ariaDom.setAttribute('aria-haspopup', true);
      ariaDom.setAttribute('aria-owns', menu.id);
    } else {
      ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
      ariaAttr['aria-haspopup'] = true;
      ariaAttr['aria-owns'] = menu.id;
    }
  } else {
    menu = me.menu = null;
  }
  if (menu && me.rendered && !me.destroying && arrowEl) {
    arrowEl[menu ? 'addCls' : 'removeCls'](me.arrowCls);
  }
}, setHandler:function(fn, scope) {
  this.handler = fn || null;
  this.scope = scope;
}, setIcon:function(icon) {
  var me = this, iconEl = me.iconEl, oldIcon = me.icon;
  if (me.glyph) {
    me.setGlyph(null);
  }
  if (iconEl) {
    iconEl.setStyle('background-image', icon ? 'url(' + icon + ')' : '');
  }
  me.icon = icon;
  me.fireEvent('iconchange', me, oldIcon, icon);
}, setIconCls:function(iconCls) {
  var me = this, iconEl = me.iconEl, oldCls = me.iconCls;
  if (me.glyph) {
    me.setGlyph(null);
  }
  if (iconEl) {
    iconEl.setStyle('background-image', '');
    if (me.iconCls) {
      iconEl.removeCls(me.iconCls);
    }
    if (iconCls) {
      iconEl.addCls(iconCls);
    }
  }
  me.iconCls = iconCls;
  me.fireEvent('iconchange', me, oldCls, iconCls);
}, setText:function(text) {
  var me = this, el = me.textEl || me.el, oldText = me.text;
  me.text = text;
  if (me.rendered) {
    el.setHtml(text || '');
    me.updateLayout();
  }
  me.fireEvent('textchange', me, oldText, text);
}, getTipAttr:function() {
  return this.tooltipType === 'qtip' ? 'data-qtip' : 'title';
}, clearTip:function() {
  if (Ext.quickTipsActive && Ext.isObject(this.tooltip)) {
    Ext.tip.QuickTipManager.unregister(this.itemEl);
  }
}, setTooltip:function(tooltip, initial) {
  var me = this;
  if (me.rendered) {
    if (!initial) {
      me.clearTip();
    }
    if (Ext.quickTipsActive && Ext.isObject(tooltip)) {
      Ext.tip.QuickTipManager.register(Ext.apply({target:me.itemEl.id}, tooltip));
      me.tooltip = tooltip;
    } else {
      me.itemEl.dom.setAttribute(me.getTipAttr(), tooltip);
    }
  } else {
    me.tooltip = tooltip;
  }
  return me;
}, getFocusEl:function() {
  return this.plain ? this.el : this.itemEl;
}, getFocusClsEl:function() {
  return this.el;
}, privates:{cancelDeferExpand:function() {
  window.clearTimeout(this.expandMenuTimer);
}, cancelDeferHide:function() {
  window.clearTimeout(this.hideMenuTimer);
}}, applyGlyph:function(glyph, oldGlyph) {
  if (glyph) {
    if (!glyph.isGlyph) {
      glyph = new Ext.Glyph(glyph);
    }
    if (glyph.isEqual(oldGlyph)) {
      glyph = undefined;
    }
  }
  return glyph;
}, updateGlyph:function(glyph, oldGlyph) {
  var iconEl = this.iconEl;
  if (iconEl) {
    iconEl.setStyle('background-image', 'none');
    this.icon = null;
    if (glyph) {
      iconEl.dom.innerHTML = glyph.character;
      iconEl.setStyle(glyph.getStyle());
    } else {
      iconEl.dom.innerHTML = '';
    }
  }
}}, 0, ['menuitem'], ['component', 'box', 'menuitem'], {'component':true, 'box':true, 'menuitem':true}, ['widget.menuitem'], [[Ext.mixin.Queryable.prototype.mixinId || Ext.mixin.Queryable.$className, Ext.mixin.Queryable]], [Ext.menu, 'Item', Ext.menu, 'TextItem'], 0);
Ext.define('Ext.theme.triton.menu.Item', {override:'Ext.menu.Item', compatibility:Ext.isIE8, onFocus:function(e) {
  (arguments.callee.$previous || Ext.Component.prototype.onFocus).call(this, e);
  this.repaintIcons();
}, onFocusLeave:function(e) {
  (arguments.callee.$previous || Ext.Component.prototype.onFocusLeave).call(this, e);
  this.repaintIcons();
}, privates:{repaintIcons:function() {
  var iconEl = this.iconEl, arrowEl = this.arrowEl, checkEl = this.checkEl;
  if (iconEl) {
    iconEl.syncRepaint();
  }
  if (arrowEl) {
    arrowEl.syncRepaint();
  }
  if (checkEl) {
    checkEl.syncRepaint();
  }
}}});
Ext.cmd.derive('Ext.menu.CheckItem', Ext.menu.Item, {checkedCls:'x-menu-item-checked', uncheckedCls:'x-menu-item-unchecked', groupCls:'x-menu-group-icon', hideOnClick:false, checkChangeDisabled:false, submenuText:'{0} submenu', ariaRole:'menuitemcheckbox', childEls:['checkEl'], defaultBindProperty:'checked', showCheckbox:true, isMenuCheckItem:true, checkboxCls:'x-menu-item-checkbox', initComponent:function() {
  var me = this, checked = me.checked;
  me.checkedConfigure = checked;
  me.checked = !!checked;
  Ext.menu.Item.prototype.initComponent.call(this);
  if (me.group) {
    Ext.menu.Manager.registerCheckable(me);
    if (me.initialConfig.hideOnClick !== false) {
      me.hideOnClick = true;
    }
  }
}, beforeRender:function() {
  var me = this, ariaAttr;
  Ext.menu.Item.prototype.beforeRender.call(this);
  Ext.apply(me.renderData, {checkboxCls:me.checkboxCls, showCheckbox:me.showCheckbox});
  ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
  ariaAttr['aria-checked'] = me.menu ? 'mixed' : me.checked;
  if (me.menu) {
    ariaAttr['aria-label'] = Ext.String.formatEncode(me.submenuText, me.text);
  }
}, afterRender:function() {
  var me = this;
  Ext.menu.Item.prototype.afterRender.call(this);
  me.checked = !me.checked;
  me.initial = true;
  me.setChecked(!me.checked, true);
  me.initial = false;
  if (me.checkChangeDisabled) {
    me.disableCheckChange();
  }
  if (Ext.isGecko && me.checkEl) {
    me.checkEl.on('mousedown', me.onMouseDownCheck);
  }
}, disableCheckChange:function() {
  var me = this, checkEl = me.checkEl;
  if (checkEl) {
    checkEl.addCls(me.disabledCls);
  }
  if (Ext.isIE8 && me.rendered) {
    me.el.repaint();
  }
  me.checkChangeDisabled = true;
}, enableCheckChange:function() {
  var me = this, checkEl = me.checkEl;
  if (checkEl) {
    checkEl.removeCls(me.disabledCls);
  }
  me.checkChangeDisabled = false;
}, onMouseDownCheck:function(e) {
  e.preventDefault();
}, onClick:function(e) {
  var me = this;
  if (!(me.disabled || me.checkChangeDisabled || me.checked && me.group || me.menu && 'touch' === e.pointerType && !me.checkEl.contains(e.target))) {
    me.setChecked(!me.checked);
    if (e.type === 'keydown' && me.menu) {
      return false;
    }
  }
  return Ext.menu.Item.prototype.onClick.call(this, e);
}, doDestroy:function() {
  Ext.menu.Manager.unregisterCheckable(this);
  Ext.menu.Item.prototype.doDestroy.call(this);
}, setText:function(text) {
  var me = this, ariaDom = me.ariaEl.dom;
  Ext.menu.Item.prototype.setText.call(this, text);
  if (ariaDom && me.menu) {
    ariaDom.setAttribute('aria-label', Ext.String.formatEncode(me.submenuText, text));
  }
}, setChecked:function(checked, suppressEvents) {
  var me = this, checkedCls = me.checkedCls, uncheckedCls = me.uncheckedCls, el = me.el, ariaDom = me.ariaEl.dom, checkedConfigure = me.checkedConfigure;
  if (me.checked !== checked && (suppressEvents || me.fireEvent('beforecheckchange', me, checked) !== false)) {
    if (el) {
      if (checked) {
        el.addCls(checkedCls);
        el.removeCls(uncheckedCls);
      } else {
        el.addCls(uncheckedCls);
        el.removeCls(checkedCls);
      }
    }
    if (ariaDom) {
      ariaDom.setAttribute('aria-checked', me.menu ? 'mixed' : !!checked);
    }
    me.checked = checked;
    me.checkedConfigure = checked;
    Ext.menu.Manager.onCheckChange(me, checked);
    if (!(me.initial && checkedConfigure == null)) {
      me.publishState('checked', checked);
    }
    if (!suppressEvents) {
      Ext.callback(me.checkHandler, me.scope, [me, checked], 0, me);
      me.fireEvent('checkchange', me, checked);
    }
  }
}}, 0, ['menucheckitem'], ['component', 'box', 'menuitem', 'menucheckitem'], {'component':true, 'box':true, 'menuitem':true, 'menucheckitem':true}, ['widget.menucheckitem'], 0, [Ext.menu, 'CheckItem'], 0);
Ext.cmd.derive('Ext.menu.Separator', Ext.menu.Item, {focusable:false, canActivate:false, hideOnClick:false, plain:true, separatorCls:'x-menu-item-separator', text:'\x26#160;', ariaRole:'separator', beforeRender:function() {
  this.addCls(this.separatorCls);
  Ext.menu.Item.prototype.beforeRender.call(this);
}}, 0, ['menuseparator'], ['component', 'box', 'menuitem', 'menuseparator'], {'component':true, 'box':true, 'menuitem':true, 'menuseparator':true}, ['widget.menuseparator'], 0, [Ext.menu, 'Separator'], 0);
Ext.define('Ext.theme.neptune.menu.Separator', {override:'Ext.menu.Separator', border:true});
Ext.cmd.derive('Ext.menu.Menu', Ext.panel.Panel, {defaultType:'menuitem', enableKeyNav:true, allowOtherMenus:false, ariaRole:'menu', floating:true, constrain:true, hidden:true, hideMode:'visibility', ignoreParentClicks:false, mouseLeaveDelay:50, isMenu:true, showSeparator:true, minWidth:undefined, defaultMinWidth:120, defaultAlign:'tl-bl?', focusOnToFront:false, bringParentToFront:false, alignOnScroll:false, focusable:true, tabIndex:-1, focusableContainer:true, defaultFocus:':focusable', allowFocusingDisabledChildren:true, 
menuClickBuffer:0, baseCls:'x-menu', _iconSeparatorCls:'x-menu-icon-separator', _itemCmpCls:'x-menu-item-cmp', layout:{type:'vbox', align:'stretchmax', overflowHandler:'Scroller'}, initComponent:function() {
  var me = this, cls = ['x-menu'], bodyCls = me.bodyCls ? [me.bodyCls] : [], isFloating = me.floating !== false, listeners = {element:'el', click:me.onClick, mouseover:me.onMouseOver, scope:me};
  if (Ext.supports.Touch) {
    listeners.pointerdown = me.onMouseOver;
  }
  me.on(listeners);
  me.on({beforeshow:me.onBeforeShow, scope:me});
  if (me.plain) {
    cls.push('x-menu-plain');
  }
  me.cls = cls.join(' ');
  bodyCls.push('x-menu-body', Ext.dom.Element.unselectableCls);
  me.bodyCls = bodyCls.join(' ');
  if (isFloating) {
    if (me.minWidth === undefined) {
      me.minWidth = me.defaultMinWidth;
    }
  } else {
    me.hidden = !!me.initialConfig.hidden;
    me.constrain = false;
  }
  Ext.panel.Panel.prototype.initComponent.call(this);
  Ext.override(me.getLayout(), {configureItem:me.configureItem});
  me.itemOverTask = new Ext.util.DelayedTask(me.handleItemOver, me);
}, initFloatConstrain:Ext.emptyFn, getInherited:function() {
  var result = Ext.panel.Panel.prototype.getInherited.call(this);
  if (this.floating) {
    result.hidden = this.hidden;
  }
  return result;
}, beforeRender:function() {
  var me = this;
  Ext.panel.Panel.prototype.beforeRender.call(this);
  if (!me.getSizeModel().width.shrinkWrap) {
    me.layout.align = 'stretch';
  }
  if (me.floating) {
    me.ariaRenderAttributes = me.ariaRenderAttributes || {};
    me.ariaRenderAttributes['aria-expanded'] = !!me.autoShow;
  }
}, onBoxReady:function(width, height) {
  var me = this, iconSeparatorCls = me._iconSeparatorCls, keyNav = me.focusableKeyNav;
  if (keyNav) {
    keyNav.map.addBinding([{key:Ext.event.Event.ESC, handler:me.onEscapeKey, scope:me}, {key:/[\w]/, handler:me.onShortcutKey, scope:me, shift:false, ctrl:false, alt:false}]);
  } else {
    me.escapeKeyNav = new Ext.util.KeyNav({target:me.el, eventName:'keydown', scope:me, esc:me.onEscapeKey});
  }
  Ext.panel.Panel.prototype.onBoxReady.call(this, width, height);
  if (me.showSeparator) {
    me.iconSepEl = me.body.insertFirst({role:'presentation', cls:iconSeparatorCls + ' ' + iconSeparatorCls + '-' + me.ui, html:'\x26#160;'});
  }
  if (Ext.supports.Touch || Ext.supports.MSPointerEvents || Ext.supports.PointerEvents) {
    me.el.on({scope:me, click:me.preventClick, translate:false});
  }
  me.mouseMonitor = me.el.monitorMouseLeave(me.mouseLeaveDelay, me.onMouseLeave, me);
}, onFocusEnter:function(e) {
  var me = this, hierarchyState;
  Ext.panel.Panel.prototype.onFocusEnter.call(this, e);
  me.mixins.focusablecontainer.onFocusEnter.call(me, e);
  if (me.floating) {
    hierarchyState = me.getInherited();
    if (!hierarchyState.topmostFocusEvent) {
      hierarchyState.topmostFocusEvent = e;
    }
  }
}, onFocusLeave:function(e) {
  var me = this;
  Ext.panel.Panel.prototype.onFocusLeave.call(this, e);
  me.lastFocusedChild = null;
  me.mixins.focusablecontainer.onFocusLeave.call(me, e);
  if (me.floating) {
    me.hide();
  }
}, handleItemOver:function(e, item) {
  if (!item.containsFocus && (e.pointerType === 'mouse' || item.isMenuItem)) {
    item.focus();
  }
  if (item.expandMenu) {
    item.expandMenu(e);
  }
}, canActivateItem:function(item) {
  return item && item.isFocusable();
}, deactivateActiveItem:function() {
  var me = this, activeItem = me.lastFocusedChild;
  if (activeItem) {
    activeItem.blur();
  }
}, getItemFromEvent:function(e) {
  var me = this, renderTarget = me.layout.getRenderTarget().dom, toEl = e.getTarget();
  while (toEl.parentNode !== renderTarget) {
    toEl = toEl.parentNode;
    if (!toEl) {
      return;
    }
  }
  return Ext.getCmp(toEl.id);
}, lookupComponent:function(cmp) {
  var me = this;
  if (typeof cmp === 'string') {
    if (cmp[0] === '@') {
      cmp = Ext.panel.Panel.prototype.lookupComponent.call(this, cmp);
    } else {
      cmp = me.lookupItemFromString(cmp);
    }
  } else {
    if (Ext.isObject(cmp)) {
      cmp = me.lookupItemFromObject(cmp);
    }
  }
  if (!cmp.dock) {
    cmp.minWidth = cmp.minWidth || me.minWidth;
  }
  return cmp;
}, lookupItemFromObject:function(cmp) {
  var type = this.defaultType;
  if (!cmp.isComponent) {
    if (!cmp.xtype && Ext.isBoolean(cmp.checked)) {
      type = 'menucheckitem';
    }
    cmp = Ext.ComponentManager.create(cmp, type);
  }
  if (cmp.isMenuItem) {
    cmp.parentMenu = this;
  }
  return cmp;
}, lookupItemFromString:function(cmp) {
  return cmp === 'separator' || cmp === '-' ? new Ext.menu.Separator : new Ext.menu.Item({canActivate:false, hideOnClick:false, plain:true, text:cmp});
}, configureItem:function(cmp) {
  var me = this.owner, prefix = 'x-', ui = me.ui, cls, cmpCls;
  if (cmp.isMenuItem) {
    cmp.setUI(ui);
  } else {
    if (me.items.getCount() > 1 && !cmp.rendered && !cmp.dock) {
      cmpCls = me._itemCmpCls;
      cls = [cmpCls, cmpCls + '-' + ui];
      if (!me.plain && (cmp.indent !== false || cmp.iconCls === 'no-icon')) {
        cls.push(prefix + 'menu-item-indent-' + ui);
      }
      if (cmp.rendered) {
        cmp.el.addCls(cls);
      } else {
        cmp.cls = (cmp.cls || '') + ' ' + cls.join(' ');
      }
      cmp.$extraMenuCls = cls;
    }
  }
  this.callParent(arguments);
}, onRemove:function(cmp) {
  Ext.panel.Panel.prototype.onRemove.call(this, cmp);
  if (!cmp.destroyed && cmp.$extraMenuCls) {
    cmp.el.removeCls(cmp.$extraMenuCls);
  }
}, onClick:function(e) {
  var me = this, type = e.type, item, clickResult, iskeyEvent = type === 'keydown';
  if (me.disabled) {
    e.stopEvent();
    return;
  }
  item = me.getItemFromEvent(e);
  if (item && item.isMenuItem) {
    if (!item.menu || !me.ignoreParentClicks) {
      clickResult = item.onClick(e);
    } else {
      e.stopEvent();
    }
    if (me.destroyed) {
      return;
    }
    if (item.menu && clickResult !== false && iskeyEvent) {
      item.expandMenu(e, 0);
    }
  }
  if (!item || item.disabled) {
    item = undefined;
  }
  me.fireEvent('click', me, item, e);
}, doDestroy:function() {
  var me = this;
  if (me.escapeKeyNav) {
    me.escapeKeyNav.destroy();
  }
  me.itemOverTask.cancel();
  me.parentMenu = me.ownerCmp = me.escapeKeyNav = null;
  if (me.rendered) {
    me.el.un(me.mouseMonitor);
    Ext.destroy(me.iconSepEl);
  }
  Ext.menu.Manager.onHide(me);
  Ext.panel.Panel.prototype.doDestroy.call(this);
}, onMouseLeave:function(e) {
  var me = this;
  if (me.itemOverTask) {
    me.itemOverTask.cancel();
  }
  if (me.disabled) {
    return;
  }
  me.fireEvent('mouseleave', me, e);
}, onMouseOver:function(e) {
  var me = this, fromEl = e.getRelatedTarget(), mouseEnter = !me.el.contains(fromEl), item = me.getItemFromEvent(e), parentMenu = me.parentMenu, ownerCmp = me.ownerCmp;
  if (mouseEnter && parentMenu) {
    parentMenu.setActiveItem(ownerCmp);
    ownerCmp.cancelDeferHide();
    parentMenu.mouseMonitor.mouseenter();
    parentMenu.itemOverTask.cancel();
  }
  if (me.disabled) {
    return;
  }
  if (item) {
    if (e.pointerType === 'touch') {
      me.handleItemOver(e, item);
    } else {
      me.itemOverTask.delay(me.expanded ? me.mouseLeaveDelay : 0, null, null, [e, item]);
    }
  }
  if (mouseEnter) {
    me.fireEvent('mouseenter', me, e);
  }
  me.fireEvent('mouseover', me, item, e);
}, setActiveItem:function(item) {
  var me = this;
  if (item && item !== me.lastFocusedChild) {
    me.focusChild(item, 1);
  }
}, onEscapeKey:function() {
  if (this.floating) {
    this.hide();
  }
}, onShortcutKey:function(keyCode, e) {
  var shortcutChar = String.fromCharCode(e.getCharCode()), items = this.query('\x3e[text]'), len = items.length, item = this.lastFocusedChild, focusIndex = Ext.Array.indexOf(items, item), i = focusIndex;
  if (len === 0) {
    return;
  }
  for (;;) {
    if (++i === len) {
      i = 0;
    }
    item = items[i];
    if (i === focusIndex) {
      return;
    }
    if (item.text && item.text[0].toUpperCase() === shortcutChar) {
      item.focus();
      return;
    }
  }
}, onBeforeShow:function() {
  if (Ext.Date.getElapsed(this.lastHide) < this.menuClickBuffer) {
    return false;
  }
}, beforeShow:function() {
  var me = this, parent;
  if (me.floating) {
    parent = me.hasFloatMenuParent();
    if (!parent && !me.allowOtherMenus) {
      Ext.menu.Manager.hideAll();
    }
  }
  Ext.panel.Panel.prototype.beforeShow.call(this);
}, afterShow:function(animateTarget, callback, scope) {
  var me = this, ariaDom = me.ariaEl.dom;
  Ext.panel.Panel.prototype.afterShow.call(this, animateTarget, callback, scope);
  Ext.menu.Manager.onShow(me);
  if (me.parentMenu) {
    me.parentMenu.expanded = true;
  }
  if (me.floating && ariaDom) {
    ariaDom.setAttribute('aria-expanded', true);
  }
  if (me.floating) {
    me.maxHeight = me.savedMaxHeight;
  }
  if (me.autoFocus) {
    me.focus();
  }
}, onHide:function(animateTarget, cb, scope) {
  var me = this, ariaDom = me.ariaEl.dom;
  Ext.panel.Panel.prototype.onHide.call(this, animateTarget, cb, scope);
  me.lastHide = Ext.Date.now();
  Ext.menu.Manager.onHide(me);
  if (me.parentMenu) {
    me.parentMenu.expanded = false;
  }
  if (me.floating && ariaDom) {
    ariaDom.setAttribute('aria-expanded', false);
  }
}, afterHide:function(cb, scope) {
  Ext.panel.Panel.prototype.afterHide.call(this, cb, scope);
  delete this.getInherited().topmostFocusEvent;
}, preventClick:function(e) {
  var item = this.getItemFromEvent(e);
  if (item && item.isMenuItem && !item.href) {
    e.preventDefault();
  }
}, privates:{applyDefaults:function(config) {
  if (!Ext.isString(config)) {
    config = Ext.panel.Panel.prototype.applyDefaults.call(this, config);
  }
  return config;
}, initFocusableElement:function() {
  var me = this, tabIndex = me.tabIndex, el = me.el;
  if (me.floating && tabIndex != null && el && el.dom) {
    el.dom.setAttribute('tabIndex', tabIndex);
    el.dom.setAttribute('data-componentid', me.id);
  }
}, processFocusableContainerKeyEvent:function(e) {
  if (e.keyCode === e.ESC) {
    e.target = this.el.dom;
  } else {
    if (e.keyCode === e.TAB && Ext.fly(e.target).is('input[type\x3dtext],textarea')) {
      e.preventDefault();
      e.target = this.getItemFromEvent(e).el.dom;
      if (e.shiftKey) {
        e.shiftKey = false;
        e.keyCode = e.UP;
      } else {
        e.keyCode = e.DOWN;
      }
    } else {
      return Ext.panel.Panel.prototype.processFocusableContainerKeyEvent.call(this, e);
    }
  }
  return e;
}, onFocusableContainerTabKey:function(e) {
  var me = this;
  if (me.floating) {
    if (e.shiftKey) {
      e.preventDefault();
    } else {
      me.focusEnterEvent = me.getInherited().topmostFocusEvent;
    }
    me.hide();
  }
}, onFocusableContainerEnterKey:function(e) {
  this.onClick(e);
}, onFocusableContainerSpaceKey:function(e) {
  this.onClick(e);
}, onFocusableContainerLeftKey:function(e) {
  e.preventDefault();
  if (this.parentMenu) {
    this.ownerCmp.focus();
    this.hide();
  }
}, onFocusableContainerRightKey:function(e) {
  var me = this, focusItem = me.lastFocusedChild;
  e.preventDefault();
  if (focusItem && focusItem.expandMenu) {
    focusItem.expandMenu(e, 0);
  }
}, hasFloatMenuParent:function() {
  return this.parentMenu || this.up('menu[floating\x3dtrue]');
}, setOwnerCmp:function(comp, instanced) {
  var me = this;
  me.parentMenu = comp.isMenuItem ? comp : null;
  me.ownerCmp = comp;
  me.registerWithOwnerCt();
  delete me.hierarchicallyHidden;
  me.onInheritedAdd(comp, instanced);
  me.containerOnAdded(comp, instanced);
}}}, 0, ['menu'], ['component', 'box', 'container', 'panel', 'menu'], {'component':true, 'box':true, 'container':true, 'panel':true, 'menu':true}, ['widget.menu'], 0, [Ext.menu, 'Menu'], 0);
Ext.define('Ext.theme.neptune.menu.Menu', {override:'Ext.menu.Menu', showSeparator:false});
Ext.define('Ext.theme.triton.menu.Menu', {override:'Ext.menu.Menu', compatibility:Ext.isIE8, afterShow:function() {
  var me = this, items, item, i, len;
  (arguments.callee.$previous || Ext.panel.Panel.prototype.afterShow).apply(this, arguments);
  items = me.items.getRange();
  for (i = 0, len = items.length; i < len; i++) {
    item = items[i];
    if (item && item.repaintIcons) {
      item.repaintIcons();
    }
  }
}});
Ext.cmd.derive('Ext.grid.locking.HeaderContainer', Ext.grid.header.Container, {headerCtRelayEvents:['blur', 'focus', 'move', 'resize', 'destroy', 'beforedestroy', 'boxready', 'afterrender', 'render', 'beforerender', 'removed', 'hide', 'beforehide', 'show', 'beforeshow', 'enable', 'disable', 'added', 'deactivate', 'beforedeactivate', 'activate', 'beforeactivate', 'remove', 'add', 'beforeremove', 'beforeadd', 'afterlayout', 'menucreate', 'sortchange', 'columnschanged', 'columnshow', 'columnhide', 'columnmove', 
'headertriggerclick', 'headercontextmenu', 'headerclick', 'columnresize', 'statesave', 'beforestatesave', 'staterestore', 'beforestaterestore'], constructor:function(lockable) {
  var me = this, lockedGrid = lockable.lockedGrid, normalGrid = lockable.normalGrid;
  me.lockable = lockable;
  Ext.grid.header.Container.prototype.constructor.call(this);
  lockedGrid.visibleColumnManager.rootColumns = normalGrid.visibleColumnManager.rootColumns = lockable.visibleColumnManager = me.visibleColumnManager = new Ext.grid.ColumnManager(true, lockedGrid.headerCt, normalGrid.headerCt);
  lockedGrid.columnManager.rootColumns = normalGrid.columnManager.rootColumns = lockable.columnManager = me.columnManager = new Ext.grid.ColumnManager(false, lockedGrid.headerCt, normalGrid.headerCt);
  me.lockedEventRelayers = me.relayEvents(lockedGrid.headerCt, me.headerCtRelayEvents);
  me.normalEventRelayers = me.relayEvents(normalGrid.headerCt, me.headerCtRelayEvents);
}, getRefItems:function() {
  return this.lockable.lockedGrid.headerCt.getRefItems().concat(this.lockable.normalGrid.headerCt.getRefItems());
}, getGridColumns:function() {
  return this.lockable.lockedGrid.headerCt.getGridColumns().concat(this.lockable.normalGrid.headerCt.getGridColumns());
}, getColumnsState:function() {
  var me = this, locked = me.lockable.lockedGrid.headerCt.getColumnsState(), normal = me.lockable.normalGrid.headerCt.getColumnsState();
  return locked.concat(normal);
}, applyColumnsState:function(columnsState, storeState) {
  var me = this, lockedGrid = me.lockable.lockedGrid, normalGrid = me.lockable.normalGrid, lockedHeaderCt = lockedGrid.headerCt, normalHeaderCt = me.lockable.normalGrid.headerCt, columns = lockedHeaderCt.items.items.concat(normalHeaderCt.items.items), length = columns.length, i, colState, column, lockedCount, switchSides;
  for (i = 0; i < length; i++) {
    column = columns[i];
    colState = columnsState[column.getStateId()];
    if (colState) {
      switchSides = colState.locked != null && !!column.locked !== colState.locked;
      if (column.applyColumnState) {
        column.applyColumnState(colState, storeState);
      }
      if (switchSides) {
        (column.locked ? lockedHeaderCt : normalHeaderCt).add(column);
      }
    }
  }
  lockedCount = lockedHeaderCt.items.items.length;
  for (i = 0; i < length; i++) {
    column = columns[i];
    colState = columnsState[column.getStateId()];
    if (colState && !column.locked) {
      colState.index -= lockedCount;
    }
  }
  lockedHeaderCt.applyColumnsState(columnsState, storeState);
  normalHeaderCt.applyColumnsState(columnsState, storeState);
  if (!lockedGrid.getVisibleColumnManager().getColumns().length) {
    lockedGrid.hide();
  }
  if (!normalGrid.getVisibleColumnManager().getColumns().length) {
    normalGrid.hide();
  }
}, disable:function() {
  var topGrid = this.lockable;
  topGrid.lockedGrid.headerCt.disable();
  topGrid.normalGrid.headerCt.disable();
}, enable:function() {
  var topGrid = this.lockable;
  topGrid.lockedGrid.headerCt.enable();
  topGrid.normalGrid.headerCt.enable();
}}, 1, 0, ['component', 'box', 'container', 'headercontainer'], {'component':true, 'box':true, 'container':true, 'headercontainer':true}, 0, 0, [Ext.grid.locking, 'HeaderContainer'], 0);
Ext.cmd.derive('Ext.grid.locking.View', Ext.Base, {alternateClassName:'Ext.grid.LockingView', isLockingView:true, loadMask:true, eventRelayRe:/^(beforeitem|beforecontainer|item|container|cell|refresh)/, constructor:function(config) {
  var ext = Ext, me = this, lockedView, normalView;
  me.ownerGrid = config.ownerGrid;
  me.ownerGrid.view = me;
  me.navigationModel = config.locked.xtype === 'treepanel' ? new ext.tree.NavigationModel(me) : new ext.grid.NavigationModel(me);
  config.locked.viewConfig.bindStore = ext.emptyFn;
  config.normal.viewConfig.bindStore = me.subViewBindStore;
  config.normal.viewConfig.isNormalView = config.locked.viewConfig.isLockedView = true;
  config.locked.viewConfig.navigationModel = config.normal.viewConfig.navigationModel = me.navigationModel;
  me.lockedGrid = me.ownerGrid.lockedGrid = ext.ComponentManager.create(config.locked);
  me.lockedView = lockedView = me.lockedGrid.getView();
  me.selModel = config.normal.viewConfig.selModel = lockedView.getSelectionModel();
  if (me.lockedGrid.isTree) {
    me.lockedView.animate = false;
    config.normal.store = lockedView.store;
    config.normal.viewConfig.stripeRows = me.lockedView.stripeRows;
    config.normal.rowLines = me.lockedGrid.rowLines;
  }
  me.normalGrid = me.ownerGrid.normalGrid = ext.ComponentManager.create(config.normal);
  lockedView.lockingPartner = normalView = me.normalView = me.normalGrid.getView();
  normalView.lockingPartner = lockedView;
  Ext.override(me.normalGrid, {beforeRender:me.beforeNormalGridRender});
  me.loadMask = config.loadMask !== undefined ? config.loadMask : me.loadMask;
  me.mixins.observable.constructor.call(me);
  me.lockedViewEventRelayers = me.relayEvents(lockedView, ext.view.Table.events);
  me.normalViewEventRelayers = me.relayEvents(normalView, ext.view.Table.events.concat(ext.view.Table.normalSideEvents));
  normalView.on({scope:me, itemmouseleave:me.onItemMouseLeave, itemmouseenter:me.onItemMouseEnter});
  lockedView.on({scope:me, itemmouseleave:me.onItemMouseLeave, itemmouseenter:me.onItemMouseEnter});
  me.loadingText = normalView.loadingText;
  me.loadingCls = normalView.loadingCls;
  me.loadingUseMsg = normalView.loadingUseMsg;
  me.itemSelector = me.getItemSelector();
  me.all = normalView.all;
  me.bindStore(normalView.dataSource, true, 'dataSource');
}, subViewBindStore:function(store, initial) {
  var me = this, grid = me.ownerGrid, selModel;
  if (me.destroying || me.destroyed || grid.destroying || grid.destroyed) {
    return;
  }
  selModel = me.getSelectionModel();
  selModel.bindStore(store, initial);
  selModel.bindComponent(me);
}, beforeNormalGridRender:function() {
  if (this.ownerGrid.lockedGrid.getHeader() && !this.title) {
    this.title = ' ';
  }
  this.callParent();
}, onPanelRender:function(el) {
  var me = this, mask = me.loadMask, cfg = {target:me.ownerGrid, msg:me.loadingText, msgCls:me.loadingCls, useMsg:me.loadingUseMsg, store:me.ownerGrid.store};
  me.el = el;
  me.rendered = true;
  me.fireEvent('render', me);
  me.ownerGrid.maskElement = 'scrollBody';
  if (mask) {
    if (Ext.isObject(mask)) {
      cfg = Ext.apply(cfg, mask);
    }
    me.loadMask = new Ext.LoadMask(cfg);
  }
}, getRefOwner:function() {
  return this.ownerGrid;
}, getVisibleColumnManager:function() {
  return this.ownerGrid.getVisibleColumnManager();
}, getTopLevelVisibleColumnManager:function() {
  return this.ownerGrid.getVisibleColumnManager();
}, getGridColumns:function() {
  return this.getVisibleColumnManager().getColumns();
}, getEl:function(column) {
  return column.getView().getEl();
}, getCellSelector:function() {
  return this.normalView.getCellSelector();
}, getItemSelector:function() {
  return this.normalView.getItemSelector();
}, onItemMouseEnter:function(view, record) {
  var me = this, locked = me.lockedView, other = me.normalView, item;
  if (view.trackOver) {
    if (view !== locked) {
      other = locked;
    }
    item = other.getNode(record);
    other.highlightItem(item);
  }
}, onItemMouseLeave:function(view, record) {
  var me = this, locked = me.lockedView, other = me.normalView;
  if (view.trackOver) {
    if (view !== locked) {
      other = locked;
    }
    other.clearHighlight();
  }
}, relayFn:function(name, args) {
  args = args || [];
  var me = this, view = me.lockedView;
  me.relayingOperation = true;
  view[name].apply(view, args);
  view = me.normalView;
  view[name].apply(view, args);
  me.relayingOperation = false;
}, getSelectionModel:function() {
  return this.normalView.getSelectionModel();
}, getNavigationModel:function() {
  return this.navigationModel;
}, getStore:function() {
  return this.ownerGrid.store;
}, onBindStore:function(store) {
  var me = this, lockedView = me.lockedView, normalView = me.normalView;
  if (normalView.componentLayoutCounter && !(lockedView.blockRefresh && normalView.blockRefresh)) {
    Ext.suspendLayouts();
    lockedView.doFirstRefresh(store);
    normalView.doFirstRefresh(store);
    Ext.resumeLayouts(true);
  }
}, getStoreListeners:function() {
  var me = this;
  return {priority:1000, refresh:me.onDataRefresh, replace:me.onReplace, add:me.onAdd, remove:me.onRemove, update:me.onUpdate, clear:me.onDataRefresh, beginupdate:me.onBeginUpdate, endupdate:me.onEndUpdate};
}, onOwnerGridHide:function() {
  Ext.suspendLayouts();
  this.relayFn('onOwnerGridHide', arguments);
  Ext.resumeLayouts(true);
}, onOwnerGridShow:function() {
  Ext.suspendLayouts();
  this.relayFn('onOwnerGridShow', arguments);
  Ext.resumeLayouts(true);
}, onBeginUpdate:function() {
  Ext.suspendLayouts();
  this.relayFn('onBeginUpdate', arguments);
  Ext.resumeLayouts(true);
}, onEndUpdate:function() {
  Ext.suspendLayouts();
  this.relayFn('onEndUpdate', arguments);
  Ext.resumeLayouts(true);
}, onDataRefresh:function() {
  Ext.suspendLayouts();
  this.relayFn('onDataRefresh', arguments);
  Ext.resumeLayouts(true);
}, onReplace:function() {
  Ext.suspendLayouts();
  this.relayFn('onReplace', arguments);
  Ext.resumeLayouts(true);
}, onAdd:function() {
  Ext.suspendLayouts();
  this.relayFn('onAdd', arguments);
  Ext.resumeLayouts(true);
}, onRemove:function() {
  Ext.suspendLayouts();
  this.relayFn('onRemove', arguments);
  Ext.resumeLayouts(true);
}, setActionableMode:function(enabled, position) {
  var result, targetView;
  if (enabled) {
    if (!position) {
      position = this.getNavigationModel().getPosition();
    }
    if (position) {
      position = position.clone();
      position.view = targetView = position.column.getView();
      result = targetView.setActionableMode(enabled, position);
      if (result !== false && targetView.lockingPartner.grid.isVisible()) {
        targetView.lockingPartner.setActionableMode(enabled, position);
        if (!targetView.lockingPartner.actionableMode) {
          targetView.setActionableMode(false);
          result = false;
        }
      }
      return result;
    } else {
      return false;
    }
  } else {
    this.relayFn('setActionableMode', [false, position]);
  }
}, onUpdate:function() {
  Ext.suspendLayouts();
  this.relayFn('onUpdate', arguments);
  Ext.resumeLayouts(true);
}, refresh:function() {
  var lockedView = this.lockedView, normalView = this.normalView;
  Ext.suspendLayouts();
  lockedView.clearViewEl(true);
  normalView.clearViewEl(true);
  normalView.refresh();
  lockedView.refresh();
  Ext.resumeLayouts(true);
}, refreshView:function() {
  var lockedView = this.lockedView, normalView = this.normalView, startIndex = normalView.all.startIndex;
  Ext.suspendLayouts();
  lockedView.clearViewEl(true);
  normalView.clearViewEl(true);
  normalView.refreshView(startIndex);
  lockedView.refreshView(startIndex);
  Ext.resumeLayouts(true);
}, setScrollable:function(scrollable) {
  Ext.suspendLayouts();
  this.lockedView.setScrollable(scrollable);
  if (scrollable.isScroller) {
    scrollable = new Ext.scroll.Scroller(scrollable.initialConfig);
  }
  this.normalView.setScrollable(scrollable);
  Ext.resumeLayouts(true);
}, getNode:function(nodeInfo) {
  return this.normalView.getNode(nodeInfo);
}, getRow:function(nodeInfo) {
  return this.normalView.getRow(nodeInfo);
}, getCell:function(record, column, returnElement) {
  var row = column.getView().getRow(record), cell = row.querySelector(column.getCellSelector());
  return returnElement ? Ext.get(cell) : cell;
}, indexOf:function(record) {
  var result = this.lockedView.indexOf(record);
  if (!result) {
    result = this.normalView.indexOf(record);
  }
  return result;
}, focus:function() {
  var target = this.ownerGrid.down('\x3etablepanel:not(hidden)\x3etableview');
  if (target) {
    target.focus();
  }
}, focusRow:function(row) {
  var view, lastFocused = this.getNavigationModel().lastFocused;
  view = lastFocused ? lastFocused.view : this.normalView;
  view.focusRow(row);
}, focusCell:function(position) {
  position.view.focusCell(position);
}, onRowFocus:function() {
  this.relayFn('onRowFocus', arguments);
}, cancelFocusTask:function() {
  this.lockedView.cancelFocusTask();
  this.normalView.cancelFocusTask();
}, isVisible:function(deep) {
  return this.ownerGrid.isVisible(deep);
}, getCellInclusive:function(pos, returnDom) {
  var col = pos.column, lockedSize = this.lockedGrid.getColumnManager().getColumns().length;
  if (col >= lockedSize) {
    pos = Ext.apply({}, pos);
    pos.column -= lockedSize;
    return this.normalView.getCellInclusive(pos, returnDom);
  } else {
    return this.lockedView.getCellInclusive(pos, returnDom);
  }
}, getHeaderByCell:function(cell) {
  if (cell) {
    return this.getVisibleColumnManager().getHeaderById(cell.getAttribute('data-columnId'));
  }
  return false;
}, onRowSelect:function() {
  this.relayFn('onRowSelect', arguments);
}, onRowDeselect:function() {
  this.relayFn('onRowDeselect', arguments);
}, onCellSelect:function(cellContext) {
  cellContext.column.getView().onCellSelect({record:cellContext.record, column:cellContext.column});
}, onCellDeselect:function(cellContext) {
  cellContext.column.getView().onCellDeselect({record:cellContext.record, column:cellContext.column});
}, getCellByPosition:function(pos, returnDom) {
  var me = this, view = pos.view, col = pos.column;
  if (view === me) {
    pos = (new Ext.grid.CellContext(col.getView())).setPosition(pos.record, pos.column);
  }
  return view.getCellByPosition(pos, returnDom);
}, getRecord:function(node) {
  var result = this.lockedView.getRecord(node);
  if (!result) {
    result = this.normalView.getRecord(node);
  }
  return result;
}, scrollBy:function() {
  var scroller = this.ownerGrid.getScrollable();
  scroller.scrollBy.apply(scroller, arguments);
}, ensureVisible:function() {
  var normal = this.normalView;
  normal.ensureVisible.apply(normal, arguments);
}, disable:function() {
  this.relayFn('disable', arguments);
}, enable:function() {
  this.relayFn('enable', arguments);
}, addElListener:function() {
  this.relayFn('addElListener', arguments);
}, refreshNode:function() {
  this.relayFn('refreshNode', arguments);
}, addRowCls:function() {
  this.relayFn('addRowCls', arguments);
}, removeRowCls:function() {
  this.relayFn('removeRowCls', arguments);
}, destroy:function() {
  var me = this;
  me.rendered = false;
  me.bindStore(null, false, 'dataSource');
  Ext.destroy(me.selModel, me.navigationModel, me.loadMask);
  me.lockedView.lockingPartner = me.normalView.lockingPartner = null;
  me.callParent();
}}, 1, 0, 0, 0, 0, [[Ext.util.Observable.prototype.mixinId || Ext.util.Observable.$className, Ext.util.Observable], [Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder], [Ext.mixin.Focusable.prototype.mixinId || Ext.mixin.Focusable.$className, Ext.mixin.Focusable]], [Ext.grid.locking, 'View', Ext.grid, 'LockingView'], function() {
  this.borrow(Ext.Component, ['up']);
  this.borrow(Ext.view.AbstractView, ['doFirstRefresh', 'applyFirstRefresh']);
  this.borrow(Ext.view.Table, ['cellSelector', 'selectedCellCls', 'selectedItemCls']);
});
Ext.cmd.derive('Ext.scroll.LockingScroller', Ext.scroll.Scroller, {config:{lockedScroller:null, normalScroller:null}, scrollTo:function(x, y, animate) {
  var lockedX, lockedPromise, ret;
  if (Ext.isObject(x)) {
    lockedX = x.lockedX;
    if (lockedX) {
      lockedPromise = this.getLockedScroller().scrollTo(lockedX, null, animate);
    }
  }
  ret = Ext.scroll.Scroller.prototype.scrollTo.call(this, x, y, animate);
  if (lockedPromise) {
    ret = Ext.Promise.all([ret, lockedPromise]);
  }
  return ret;
}, updateLockedScroller:function(lockedScroller) {
  lockedScroller.on('scroll', 'onLockedScroll', this);
  lockedScroller.setLockingScroller(this);
}, updateNormalScroller:function(normalScroller) {
  normalScroller.on('scroll', 'onNormalScroll', this);
  normalScroller.setLockingScroller(this);
}, updateTouchAction:function(touchAction, oldTouchAction) {
  Ext.scroll.Scroller.prototype.updateTouchAction.call(this, touchAction, oldTouchAction);
  this.getLockedScroller().setTouchAction(touchAction);
  this.getNormalScroller().setTouchAction(touchAction);
}, getPosition:function() {
  var position = Ext.scroll.Scroller.prototype.getPosition.call(this);
  position.x = this.getNormalScroller().getPosition().x;
  position.lockedX = this.getLockedScroller().getPosition().x;
  return position;
}, privates:{updateSpacerXY:function(pos) {
  var me = this, lockedScroller = me.getLockedScroller(), normalScroller = me.getNormalScroller(), lockedView = lockedScroller.component, normalView = normalScroller.component, height = pos.y + (normalView.headerCt.tooNarrow || lockedView.headerCt.tooNarrow ? Ext.getScrollbarSize().height : 0);
  normalView.stretchHeight(height);
  lockedView.stretchHeight(height);
  Ext.scroll.Scroller.prototype.updateSpacerXY.call(this, pos);
}, doScrollTo:function(x, y, animate) {
  var ret, normalPromise;
  if (x != null) {
    normalPromise = this.getNormalScroller().scrollTo(x, null, animate);
    x = null;
  }
  ret = Ext.scroll.Scroller.prototype.doScrollTo.call(this, x, y, animate);
  if (normalPromise) {
    ret = Ext.Promise.all([ret, normalPromise]);
  }
  return ret;
}, onLockedScroll:function(lockedScroller, x, y) {
  this.position.lockedX = x;
}, onNormalScroll:function(normalScroller, x, y) {
  this.position.x = x;
}, readPosition:function(position) {
  var me = this;
  position = Ext.scroll.Scroller.prototype.readPosition.call(this, position);
  position = position || {};
  position.x = me.getNormalScroller().getPosition().x;
  return position;
}}}, 0, 0, 0, 0, ['scroller.locking'], 0, [Ext.scroll, 'LockingScroller'], 0);
Ext.cmd.derive('Ext.grid.locking.Lockable', Ext.Base, {alternateClassName:'Ext.grid.Lockable', syncRowHeight:true, headerCounter:0, lockedGridCls:'x-grid-inner-locked', normalGridCls:'x-grid-inner-normal', lockingBodyCls:'x-grid-locking-body', scrollContainerCls:'x-grid-scroll-container', scrollBodyCls:'x-grid-scroll-body', scrollbarClipperCls:'x-grid-scrollbar-clipper', scrollbarCls:'x-grid-scrollbar', scrollbarVisibleCls:'x-grid-scrollbar-visible', lockText:'Lock', unlockText:'Unlock', bothCfgCopy:['hideHeaders', 
'enableColumnHide', 'enableColumnMove', 'enableColumnResize', 'sortableColumns', 'multiColumnSort', 'columnLines', 'rowLines', 'variableRowHeight', 'numFromEdge', 'trailingBufferZone', 'leadingBufferZone', 'scrollToLoadBuffer', 'syncRowHeight'], normalCfgCopy:['scroll'], lockedCfgCopy:[], determineXTypeToCreate:function(lockedSide) {
  var me = this;
  if (me.subGridXType) {
    return me.subGridXType;
  } else {
    if (!lockedSide) {
      return 'gridpanel';
    }
  }
  return me.isXType('treepanel') ? 'treepanel' : 'gridpanel';
}, injectLockable:function() {
  this.focusable = false;
  this.lockable = true;
  this.hasView = true;
  var me = this, store = me.store = Ext.StoreManager.lookup(me.store), lockedViewConfig = me.lockedViewConfig, normalViewConfig = me.normalViewConfig, Obj = Ext.Object, allFeatures, allPlugins, lockedGrid, normalGrid, i, columns, lockedHeaderCt, normalHeaderCt, viewConfig = me.viewConfig, loadMaskCfg = viewConfig && viewConfig.loadMask, loadMask = loadMaskCfg !== undefined ? loadMaskCfg : me.loadMask, bufferedRenderer = me.bufferedRenderer, setWidth;
  allFeatures = me.constructLockableFeatures();
  me.scrollable = new Ext.scroll.LockingScroller({component:me, x:false, y:true});
  me.features = null;
  allPlugins = me.constructLockablePlugins();
  me.plugins = allPlugins.topPlugins;
  lockedGrid = {id:me.id + '-locked', $initParent:me, isLocked:true, bufferedRenderer:bufferedRenderer, ownerGrid:me, ownerLockable:me, xtype:me.determineXTypeToCreate(true), store:store, scrollerOwner:false, animate:false, border:false, cls:me.lockedGridCls, isLayoutRoot:function() {
    return this.floatedFromCollapse || this.ownerGrid.normalGrid.floatedFromCollapse;
  }, features:allFeatures.lockedFeatures, plugins:allPlugins.lockedPlugins};
  normalGrid = {id:me.id + '-normal', $initParent:me, isLocked:false, bufferedRenderer:bufferedRenderer, ownerGrid:me, ownerLockable:me, xtype:me.determineXTypeToCreate(), store:store, reserveScrollbar:me.reserveScrollbar, scrollerOwner:false, border:false, cls:me.normalGridCls, isLayoutRoot:function() {
    return this.floatedFromCollapse || this.ownerGrid.lockedGrid.floatedFromCollapse;
  }, features:allFeatures.normalFeatures, plugins:allPlugins.normalPlugins};
  me.addCls('x-grid-locked');
  Ext.copy(normalGrid, me, me.bothCfgCopy, true);
  Ext.copy(lockedGrid, me, me.bothCfgCopy, true);
  Ext.copy(normalGrid, me, me.normalCfgCopy, true);
  Ext.copy(lockedGrid, me, me.lockedCfgCopy, true);
  Ext.apply(normalGrid, me.normalGridConfig);
  Ext.apply(lockedGrid, me.lockedGridConfig);
  for (i = 0; i < me.normalCfgCopy.length; i++) {
    delete me[me.normalCfgCopy[i]];
  }
  for (i = 0; i < me.lockedCfgCopy.length; i++) {
    delete me[me.lockedCfgCopy[i]];
  }
  me.addStateEvents(['lockcolumn', 'unlockcolumn']);
  columns = me.processColumns(me.columns || [], lockedGrid);
  lockedGrid.columns = columns.locked;
  if (!lockedGrid.columns.items.length) {
    lockedGrid.hidden = true;
  }
  normalGrid.columns = columns.normal;
  if (!normalGrid.columns.items.length) {
    normalGrid.hidden = true;
  }
  normalGrid.flex = 1;
  lockedGrid.viewConfig = lockedViewConfig = lockedViewConfig ? Obj.chain(lockedViewConfig) : {};
  normalGrid.viewConfig = normalViewConfig = normalViewConfig ? Obj.chain(normalViewConfig) : {};
  lockedViewConfig.loadingUseMsg = false;
  lockedViewConfig.loadMask = false;
  normalViewConfig.loadMask = false;
  Ext.applyIf(lockedViewConfig, viewConfig);
  Ext.applyIf(normalViewConfig, viewConfig);
  if (me.layout === Ext.panel.Table.prototype.layout) {
    me.layout = {type:'hbox', align:'stretch'};
  }
  me.getLayout();
  if (me.layout.type === 'border') {
    if (me.split) {
      lockedGrid.split = me.split;
    }
    if (!lockedGrid.region) {
      lockedGrid.region = 'west';
    }
    if (!normalGrid.region) {
      normalGrid.region = 'center';
    }
    me.addCls('x-grid-locked-split');
  }
  if (!(me.layout instanceof Ext.layout.container.Box)) {
    me.split = false;
  }
  me.view = new Ext.grid.locking.View({loadMask:loadMask, locked:lockedGrid, normal:normalGrid, ownerGrid:me});
  lockedGrid = me.lockedGrid;
  normalGrid = me.normalGrid;
  lockedGrid.on({beginfloat:me.onBeginLockedFloat, endfloat:me.onEndLockedFloat, scope:me});
  setWidth = lockedGrid.setWidth;
  lockedGrid.setWidth = function() {
    lockedGrid.shrinkWrapColumns = false;
    setWidth.apply(lockedGrid, arguments);
  };
  if (!lockedGrid.getVisibleColumnManager().getColumns().length) {
    lockedGrid.hide();
  }
  if (!normalGrid.getVisibleColumnManager().getColumns().length) {
    normalGrid.hide();
  }
  lockedHeaderCt = lockedGrid.headerCt;
  normalHeaderCt = normalGrid.headerCt;
  me.headerCt = me.view.headerCt = new Ext.grid.locking.HeaderContainer(me);
  lockedHeaderCt.lockedCt = true;
  lockedHeaderCt.lockableInjected = true;
  normalHeaderCt.lockableInjected = true;
  lockedHeaderCt.on({add:me.delaySyncLockedWidth, remove:me.delaySyncLockedWidth, columnshow:me.delaySyncLockedWidth, columnhide:me.delaySyncLockedWidth, sortchange:me.onLockedHeaderSortChange, columnresize:me.delaySyncLockedWidth, scope:me});
  normalHeaderCt.on({add:me.delaySyncLockedWidth, remove:me.delaySyncLockedWidth, columnshow:me.delaySyncLockedWidth, columnhide:me.delaySyncLockedWidth, sortchange:me.onNormalHeaderSortChange, scope:me});
  me.modifyHeaderCt();
  me.items = [lockedGrid];
  if (me.split) {
    me.addCls('x-grid-locked-split');
    me.items[1] = Ext.apply({xtype:'splitter'}, me.split);
  }
  me.items.push(normalGrid);
  me.relayHeaderCtEvents(lockedHeaderCt);
  me.relayHeaderCtEvents(normalHeaderCt);
  me.storeRelayers = me.relayEvents(store, ['filterchange', 'groupchange', 'beforeload', 'load']);
  me.gridRelayers = me.relayEvents(normalGrid, ['viewready']);
}, afterInjectLockable:function() {
  var me = this;
  delete me.lockedGrid.$initParent;
  delete me.normalGrid.$initParent;
}, syncLockableHeaderVisibility:function() {
  var me = this, hideHeaders = me.hideHeaders, locked = this.lockedGrid, normal = this.normalGrid;
  if (hideHeaders === null) {
    hideHeaders = locked.shouldAutoHideHeaders() && normal.shouldAutoHideHeaders();
  }
  locked.hideHeaders = normal.hideHeaders = hideHeaders;
  locked.syncHeaderVisibility();
  normal.syncHeaderVisibility();
}, getLockingViewConfig:function() {
  return {xclass:'Ext.grid.locking.View', locked:this.lockedGrid, normal:this.normalGrid, panel:this};
}, onBeginLockedFloat:function(locked) {
  var el = locked.getContentTarget().dom, lockedHeaderCt = this.lockedGrid.headerCt, normalHeaderCt = this.normalGrid.headerCt, headerCtHeight = Math.max(normalHeaderCt.getHeight(), lockedHeaderCt.getHeight());
  lockedHeaderCt.minHeight = headerCtHeight;
  normalHeaderCt.minHeight = headerCtHeight;
  locked.el.addCls(Ext.panel.Panel.floatCls);
  if (el.firstChild !== locked.view.el.dom) {
    el.appendChild(locked.view.el.dom);
  }
  locked.body.dom.scrollTop = this.getScrollable().getPosition().y;
}, onEndLockedFloat:function() {
  var locked = this.lockedGrid;
  if (locked.collapsed) {
    locked.el.removeCls(Ext.panel.Panel.floatCls);
  } else {
    this.lockedGrid.headerCt.minHeight = this.normalGrid.headerCt.minHeight = null;
  }
  this.lockedScrollbarClipper.appendChild(locked.view.el.dom);
  this.doSyncLockableLayout();
}, beforeLayout:function() {
  var me = this, lockedGrid = me.lockedGrid, normalGrid = me.normalGrid, totalColumnWidth;
  if (lockedGrid && normalGrid) {
    if (lockedGrid.getSizeModel().width.shrinkWrap) {
      lockedGrid.gridPanelBorderWidth = lockedGrid.el.getBorderWidth('lr');
      lockedGrid.shrinkWrapColumns = true;
    }
    if (lockedGrid.shrinkWrapColumns) {
      totalColumnWidth = lockedGrid.headerCt.getTableWidth();
      lockedGrid.setWidth(totalColumnWidth + lockedGrid.gridPanelBorderWidth);
      lockedGrid.shrinkWrapColumns = true;
    }
    if (!me.scrollContainer) {
      me.initScrollContainer();
    }
    me.lastScrollPos = me.getScrollable().getPosition();
    lockedGrid.view.el.setStyle('margin-bottom', '');
    normalGrid.view.el.setStyle('margin-bottom', '');
  }
}, syncLockableLayout:function() {
  var me = this;
  if (!me.afterLayoutListener) {
    me.afterLayoutListener = Ext.on({afterlayout:me.doSyncLockableLayout, scope:me, single:true});
  }
}, doSyncLockableLayout:function() {
  var me = this, collapseExpand = me.isCollapsingOrExpanding, lockedGrid = me.lockedGrid, normalGrid = me.normalGrid, lockedViewEl, normalViewEl, lockedViewRegion, normalViewRegion, scrollbarSize, scrollbarWidth, scrollbarHeight, normalViewWidth, normalViewX, hasVerticalScrollbar, hasHorizontalScrollbar, scrollContainerHeight, scrollBodyHeight, lockedScrollbar, normalScrollbar, scrollbarVisibleCls, scrollHeight, lockedGridVisible, normalGridVisible, scrollBodyDom, viewRegion, scrollerElHeight, scrollable;
  me.afterLayoutListener = null;
  if (collapseExpand) {
    if (collapseExpand === 2) {
      me.on('expand', 'doSyncLockableLayout', me, {single:true});
    }
    return;
  }
  if (lockedGrid && normalGrid) {
    lockedGridVisible = lockedGrid.isVisible(true) && !lockedGrid.collapsed;
    normalGridVisible = normalGrid.isVisible(true);
    lockedViewEl = lockedGrid.view.el;
    normalViewEl = normalGrid.view.el;
    scrollBodyDom = me.scrollBody.dom;
    lockedViewRegion = lockedGridVisible ? lockedGrid.body.getRegion(true) : new Ext.util.Region(0, 0, 0, 0);
    normalViewRegion = normalGridVisible ? normalGrid.body.getRegion(true) : new Ext.util.Region(0, 0, 0, 0);
    scrollbarSize = Ext.getScrollbarSize();
    scrollbarWidth = scrollbarSize.width;
    scrollbarHeight = scrollerElHeight = scrollbarSize.height;
    normalViewWidth = normalGridVisible ? normalViewRegion.width : 0;
    normalViewX = lockedGridVisible ? normalGridVisible ? normalViewRegion.x - lockedViewRegion.x : lockedViewRegion.width : 0;
    hasHorizontalScrollbar = normalGrid.headerCt.tooNarrow || lockedGrid.headerCt.tooNarrow ? scrollbarHeight : 0;
    scrollContainerHeight = normalViewRegion.height || lockedViewRegion.height;
    scrollBodyHeight = scrollContainerHeight;
    lockedScrollbar = me.lockedScrollbar;
    normalScrollbar = me.normalScrollbar;
    scrollbarVisibleCls = me.scrollbarVisibleCls;
    scrollable = me.getScrollable();
    if (Ext.supports.CannotScrollExactHeight) {
      scrollerElHeight += 1;
    }
    if (hasHorizontalScrollbar) {
      lockedViewEl.setStyle('margin-bottom', -scrollbarHeight + 'px');
      normalViewEl.setStyle('margin-bottom', -scrollbarHeight + 'px');
      scrollBodyHeight -= scrollbarHeight;
      if (lockedGridVisible && lockedGrid.view.body.dom) {
        me.lockedScrollbarScroller.setSize({x:lockedGrid.headerCt.getTableWidth()});
      }
      if (normalGrid.view.body.dom) {
        me.normalScrollbarScroller.setSize({x:normalGrid.headerCt.getTableWidth()});
      }
    }
    me.scrollBody.setHeight(scrollBodyHeight);
    lockedViewEl.dom.style.height = normalViewEl.dom.style.height = '';
    scrollHeight = me.scrollable.getSize().y + hasHorizontalScrollbar;
    normalGrid.view.stretchHeight(scrollHeight);
    lockedGrid.view.stretchHeight(scrollHeight);
    hasVerticalScrollbar = scrollbarWidth && scrollBodyDom.scrollHeight > scrollBodyDom.clientHeight;
    if (hasVerticalScrollbar && normalViewWidth) {
      normalViewWidth -= scrollbarWidth;
      normalViewEl.setStyle('width', normalViewWidth + 'px');
    }
    lockedScrollbar.toggleCls(scrollbarVisibleCls, lockedGridVisible && !!hasHorizontalScrollbar);
    normalScrollbar.toggleCls(scrollbarVisibleCls, !!hasHorizontalScrollbar);
    me.normalScrollbarClipper.toggleCls(me.scrollbarClipperCls + '-floated', !!me.normalGrid.floatedFromCollapse);
    me.normalScrollbar.toggleCls(me.scrollbarCls + '-floated', !!me.normalGrid.floatedFromCollapse);
    me.lockedScrollbarClipper.toggleCls(me.scrollbarClipperCls + '-floated', !!me.lockedGrid.floatedFromCollapse);
    me.lockedScrollbar.toggleCls(me.scrollbarCls + '-floated', !!me.lockedGrid.floatedFromCollapse);
    lockedScrollbar.setSize(me.lockedScrollbarClipper.dom.offsetWidth, scrollerElHeight);
    normalScrollbar.setSize(normalViewWidth, scrollerElHeight);
    me.setNormalScrollerX(normalViewX);
    if (lockedGridVisible && normalGridVisible) {
      viewRegion = lockedViewRegion.union(normalViewRegion);
    } else {
      if (lockedGridVisible) {
        viewRegion = lockedViewRegion;
      } else {
        viewRegion = normalViewRegion;
      }
    }
    me.scrollContainer.setBox(viewRegion);
    me.onSyncLockableLayout(hasVerticalScrollbar, viewRegion.width);
    if (!Ext.Object.equals(scrollable.position, me.lastScrollPos)) {
      scrollable.scrollTo(me.lastScrollPos);
    }
  }
}, onSyncLockableLayout:Ext.emptyFn, setNormalScrollerX:function(x) {
  this.normalScrollbar.setLocalX(x);
  this.normalScrollbarClipper.setLocalX(x);
}, getScrollExtraCls:function() {
  return '';
}, initScrollContainer:function() {
  var me = this, extraCls = me.getScrollExtraCls(), scrollContainer = me.scrollContainer = me.body.insertFirst({cls:[me.scrollContainerCls, extraCls]}), scrollBody = me.scrollBody = scrollContainer.appendChild({cls:me.scrollBodyCls}), lockedScrollbar = me.lockedScrollbar = scrollContainer.appendChild({cls:[me.scrollbarCls, me.scrollbarCls + '-locked', extraCls]}), normalScrollbar = me.normalScrollbar = scrollContainer.appendChild({cls:[me.scrollbarCls, extraCls]}), lockedView = me.lockedGrid.view, 
  normalView = me.normalGrid.view, lockedScroller = lockedView.getScrollable(), normalScroller = normalView.getScrollable(), Scroller = Ext.scroll.Scroller, lockedScrollbarScroller, normalScrollbarScroller, lockedScrollbarClipper, normalScrollbarClipper;
  lockedView.stretchHeight(0);
  normalView.stretchHeight(0);
  me.scrollable.setConfig({element:scrollBody, lockedScroller:lockedScroller, normalScroller:normalScroller});
  lockedScrollbarClipper = me.lockedScrollbarClipper = scrollBody.appendChild({cls:[me.scrollbarClipperCls, me.scrollbarClipperCls + '-locked', extraCls]});
  normalScrollbarClipper = me.normalScrollbarClipper = scrollBody.appendChild({cls:[me.scrollbarClipperCls, extraCls]});
  lockedScrollbarClipper.appendChild(lockedView.el);
  normalScrollbarClipper.appendChild(normalView.el);
  lockedView.ignoreDomPosition = true;
  normalView.ignoreDomPosition = true;
  lockedScrollbarScroller = me.lockedScrollbarScroller = new Scroller({element:lockedScrollbar, x:'scroll', y:false, rtl:lockedScroller.getRtl && lockedScroller.getRtl()});
  normalScrollbarScroller = me.normalScrollbarScroller = new Scroller({element:normalScrollbar, x:'scroll', y:false, rtl:normalScroller.getRtl && normalScroller.getRtl()});
  me.initScrollers();
  lockedScrollbarScroller.addPartner(lockedScroller, 'x');
  normalScrollbarScroller.addPartner(normalScroller, 'x');
  me.view.onPanelRender(scrollBody);
}, initScrollers:Ext.emptyFn, processColumns:function(columns, lockedGrid) {
  var me = this, i, len, column, cp = new Ext.grid.header.Container({'$initParent':me}), lockedHeaders = [], normalHeaders = [], lockedHeaderCt = {itemId:'lockedHeaderCt', stretchMaxPartner:'^^\x3e\x3e#normalHeaderCt', items:lockedHeaders}, normalHeaderCt = {itemId:'normalHeaderCt', stretchMaxPartner:'^^\x3e\x3e#lockedHeaderCt', items:normalHeaders}, result = {locked:lockedHeaderCt, normal:normalHeaderCt}, copy;
  if (Ext.isObject(columns)) {
    Ext.applyIf(lockedHeaderCt, columns);
    Ext.applyIf(normalHeaderCt, columns);
    copy = Ext.apply({}, columns);
    delete copy.items;
    Ext.apply(cp, copy);
    columns = columns.items;
  }
  cp.constructing = true;
  for (i = 0, len = columns.length; i < len; ++i) {
    column = columns[i];
    if (!column.isComponent) {
      column = cp.applyDefaults(column);
      column.$initParent = cp;
      column = cp.lookupComponent(column);
      delete column.$initParent;
    }
    column.processed = true;
    if (column.locked || column.autoLock) {
      lockedHeaders.push(column);
    } else {
      normalHeaders.push(column);
    }
  }
  me.fireEvent('processcolumns', me, lockedHeaders, normalHeaders);
  cp.destroy();
  return result;
}, ensureLockedVisible:function(record, options) {
  var column = options && options.column, lockedGrid = this.lockedGrid, grid = column ? column.getView().ownerCt : lockedGrid.isVisible() ? lockedGrid : this.normalGrid;
  grid.ensureVisible.apply(grid, arguments);
}, syncRowHeights:function() {
  if (!this.destroyed) {
    var me = this, normalView = me.normalGrid.getView(), lockedView = me.lockedGrid.getView(), normalSync = normalView.syncRowHeightBegin(), lockedSync = lockedView.syncRowHeightBegin(), scrollTop;
    normalView.syncRowHeightMeasure(normalSync);
    lockedView.syncRowHeightMeasure(lockedSync);
    normalView.syncRowHeightFinish(normalSync, lockedSync);
    lockedView.syncRowHeightFinish(lockedSync, normalSync);
    scrollTop = normalView.getScrollY();
    lockedView.setScrollY(scrollTop);
    me.syncRowHeightOnNextLayout = false;
  }
}, modifyHeaderCt:function() {
  var me = this;
  me.lockedGrid.headerCt.getMenuItems = me.getMenuItems(me.lockedGrid.headerCt.getMenuItems, true);
  me.normalGrid.headerCt.getMenuItems = me.getMenuItems(me.normalGrid.headerCt.getMenuItems, false);
  me.lockedGrid.headerCt.showMenuBy = Ext.Function.createInterceptor(me.lockedGrid.headerCt.showMenuBy, me.showMenuBy);
  me.normalGrid.headerCt.showMenuBy = Ext.Function.createInterceptor(me.normalGrid.headerCt.showMenuBy, me.showMenuBy);
}, onUnlockMenuClick:function() {
  this.unlock();
}, onLockMenuClick:function() {
  this.lock();
}, showMenuBy:function(clickEvent, t, header) {
  var menu = this.getMenu(), unlockItem = menu.down('#unlockItem'), lockItem = menu.down('#lockItem'), sep = unlockItem.prev();
  if (header.lockable === false) {
    sep.hide();
    unlockItem.hide();
    lockItem.hide();
  } else {
    sep.show();
    unlockItem.show();
    lockItem.show();
    if (!unlockItem.initialConfig.disabled) {
      unlockItem.setDisabled(header.lockable === false);
    }
    if (!lockItem.initialConfig.disabled) {
      lockItem.setDisabled(!header.isLockable());
    }
  }
}, getMenuItems:function(getMenuItems, locked) {
  var me = this, unlockText = me.unlockText, lockText = me.lockText, unlockCls = 'x-hmenu-unlock', lockCls = 'x-hmenu-lock', unlockHandler = me.onUnlockMenuClick.bind(me), lockHandler = me.onLockMenuClick.bind(me);
  return function() {
    var o = getMenuItems.call(this);
    o.push('-', {itemId:'unlockItem', iconCls:unlockCls, text:unlockText, handler:unlockHandler, disabled:!locked});
    o.push({itemId:'lockItem', iconCls:lockCls, text:lockText, handler:lockHandler, disabled:locked});
    return o;
  };
}, delaySyncLockedWidth:function() {
  var me = this, task = me.syncLockedWidthTask || (me.syncLockedWidthTask = new Ext.util.DelayedTask(me.syncLockedWidth, me));
  if (me.reconfiguring) {
    return;
  }
  if (!Ext.Component.layoutSuspendCount || me.syncTaskDelay === 0) {
    me.syncLockedWidth();
  } else {
    task.delay(1);
  }
}, syncLockedWidth:function() {
  var me = this, rendered = me.rendered, locked = me.lockedGrid, normal = me.normalGrid, lockedColCount = locked.getVisibleColumnManager().getColumns().length, normalColCount = normal.getVisibleColumnManager().getColumns().length, task = me.syncLockedWidthTask;
  if (task) {
    task.cancel();
  }
  if (me.reconfiguring) {
    return;
  }
  Ext.suspendLayouts();
  if (normalColCount) {
    normal.show();
    if (lockedColCount) {
      if (me.layout.type === 'border') {
        locked.region = locked.initialConfig.region;
      }
      if (rendered && locked.shrinkWrapColumns && !locked.headerCt.forceFit) {
        delete locked.flex;
        locked.width = locked.headerCt.getTableWidth() + locked.gridPanelBorderWidth;
        locked.updateLayout();
      }
      locked.addCls(me.lockedGridCls);
      locked.show();
      if (locked.split) {
        me.child('splitter').show();
        me.addCls('x-grid-locked-split');
      }
    } else {
      locked.hide();
      if (rendered) {
        locked.getView().clearViewEl(true);
      }
      if (locked.split) {
        me.child('splitter').hide();
        me.removeCls('x-grid-locked-split');
      }
    }
  } else {
    normal.hide();
    delete locked.width;
    if (me.layout.type === 'border') {
      locked.region = 'center';
      normal.region = 'west';
    } else {
      locked.flex = 1;
    }
    locked.removeCls(me.lockedGridCls);
    locked.show();
  }
  Ext.resumeLayouts(true);
  return {locked:!!lockedColCount, normal:!!normalColCount};
}, onLockedHeaderSortChange:Ext.emptyFn, onNormalHeaderSortChange:Ext.emptyFn, lock:function(activeHd, toIdx, toCt) {
  var me = this, normalGrid = me.normalGrid, lockedGrid = me.lockedGrid, normalView = normalGrid.view, lockedView = lockedGrid.view, normalScroller = normalView.getScrollable(), lockedScroller = lockedView.getScrollable(), normalHCt = normalGrid.headerCt, refreshFlags, ownerCt, lbr;
  activeHd = activeHd || normalHCt.getMenu().activeHeader;
  activeHd.unlockedWidth = activeHd.width;
  if (activeHd.flex) {
    if (activeHd.lockedWidth) {
      activeHd.width = activeHd.lockedWidth;
      activeHd.lockedWidth = null;
    } else {
      activeHd.width = activeHd.lastBox.width;
    }
    activeHd.flex = null;
  }
  toCt = toCt || lockedGrid.headerCt;
  ownerCt = activeHd.ownerCt;
  if (ownerCt && !activeHd.isLockable()) {
    return;
  }
  Ext.suspendLayouts();
  if (normalScroller) {
    normalScroller.suspendPartnerSync();
    lockedScroller.suspendPartnerSync();
  }
  if (lockedGrid.hidden) {
    if (!lockedGrid.componentLayoutCounter) {
      lockedGrid.height = normalGrid.lastBox.height;
      lbr = lockedView.bufferedRenderer;
      if (lbr) {
        lbr.rowHeight = normalView.bufferedRenderer.rowHeight;
        lbr.onViewResize(lockedView, 0, normalGrid.body.lastBox.height);
      }
    }
    lockedGrid.show();
  }
  lockedGrid.reconfiguring = normalGrid.reconfiguring = true;
  activeHd.ownerCmp = activeHd.ownerCt;
  activeHd.locked = true;
  if (Ext.isDefined(toIdx)) {
    toCt.insert(toIdx, activeHd);
  } else {
    toCt.add(activeHd);
  }
  lockedGrid.reconfiguring = normalGrid.reconfiguring = false;
  activeHd.ownerCmp = null;
  activeHd.rootHeaderCt = null;
  activeHd.view = lockedView;
  refreshFlags = me.syncLockedWidth();
  if (refreshFlags.locked) {
    lockedView.clearViewEl(true);
  }
  if (refreshFlags.normal) {
    normalView.clearViewEl(true);
  }
  normalGrid.getView().refreshNeeded = refreshFlags.normal;
  lockedGrid.getView().refreshNeeded = refreshFlags.locked;
  activeHd.onLock(activeHd);
  me.fireEvent('lockcolumn', me, activeHd);
  Ext.resumeLayouts(true);
  if (normalScroller) {
    normalScroller.resumePartnerSync(true);
    lockedScroller.resumePartnerSync();
  }
}, unlock:function(activeHd, toIdx, toCt) {
  var me = this, normalGrid = me.normalGrid, lockedGrid = me.lockedGrid, normalView = normalGrid.view, lockedView = lockedGrid.view, startIndex = normalView.all.startIndex, lockedHCt = lockedGrid.headerCt, refreshFlags;
  if (!Ext.isDefined(toIdx)) {
    toIdx = 0;
  }
  activeHd = activeHd || lockedHCt.getMenu().activeHeader;
  activeHd.lockedWidth = activeHd.width;
  if (activeHd.flex) {
    if (activeHd.unlockedWidth) {
      activeHd.width = activeHd.unlockedWidth;
      activeHd.unlockedWidth = null;
    } else {
      activeHd.width = activeHd.lastBox.width;
    }
    activeHd.flex = null;
  }
  toCt = toCt || normalGrid.headerCt;
  Ext.suspendLayouts();
  lockedGrid.reconfiguring = normalGrid.reconfiguring = true;
  activeHd.ownerCmp = activeHd.ownerCt;
  if (activeHd.ownerCt) {
    activeHd.ownerCt.remove(activeHd, false);
  }
  activeHd.locked = false;
  toCt.insert(toIdx, activeHd);
  lockedGrid.reconfiguring = normalGrid.reconfiguring = false;
  activeHd.ownerCmp = null;
  activeHd.rootHeaderCt = null;
  activeHd.view = normalView;
  refreshFlags = me.syncLockedWidth();
  if (refreshFlags.locked) {
    lockedView.clearViewEl(true);
  }
  if (refreshFlags.normal) {
    normalView.clearViewEl(true);
  }
  if (refreshFlags.normal) {
    normalGrid.getView().refreshView(startIndex);
  }
  if (refreshFlags.locked) {
    lockedGrid.getView().refreshView(startIndex);
  }
  activeHd.onUnlock(activeHd);
  me.fireEvent('unlockcolumn', me, activeHd);
  Ext.resumeLayouts(true);
}, reconfigureLockable:function(store, columns, allowUnbind) {
  var me = this, oldStore = me.store, lockedGrid = me.lockedGrid, normalGrid = me.normalGrid, view, loadMask;
  if (!store && allowUnbind) {
    store = Ext.StoreManager.lookup('ext-empty-store');
  }
  if (store && store !== oldStore) {
    store = Ext.data.StoreManager.lookup(store);
    me.store = store;
    lockedGrid.view.blockRefresh = normalGrid.view.blockRefresh = true;
    lockedGrid.bindStore(store);
    view = lockedGrid.view;
    view.store = store;
    if (!view.dataSource.isFeatureStore) {
      view.dataSource = store;
    }
    if (view.bufferedRenderer) {
      view.bufferedRenderer.bindStore(store);
    }
    normalGrid.bindStore(store);
    view = normalGrid.view;
    view.store = store;
    if (!view.dataSource.isFeatureStore) {
      view.dataSource = store;
    }
    if (view.bufferedRenderer) {
      view.bufferedRenderer.bindStore(store);
    }
    me.view.store = store;
    loadMask = me.view.loadMask;
    if (loadMask && loadMask.isLoadMask) {
      loadMask.bindStore(store);
    }
    me.view.bindStore(normalGrid.view.dataSource, false, 'dataSource');
    lockedGrid.view.blockRefresh = normalGrid.view.blockRefresh = false;
  }
  if (columns) {
    lockedGrid.reconfiguring = normalGrid.reconfiguring = true;
    lockedGrid.headerCt.removeAll();
    normalGrid.headerCt.removeAll();
    columns = me.processColumns(columns, lockedGrid);
    lockedGrid.headerCt.add(columns.locked.items);
    normalGrid.headerCt.add(columns.normal.items);
    lockedGrid.reconfiguring = normalGrid.reconfiguring = false;
    me.syncLockedWidth();
  }
  me.refreshCounter = normalGrid.view.refreshCounter;
}, afterReconfigureLockable:function() {
  this.syncLockedWidth();
  if (this.refreshCounter === this.normalGrid.getView().refreshCounter) {
    this.view.refreshView();
  }
}, constructLockableFeatures:function() {
  var features = this.features, feature, featureClone, lockedFeatures, normalFeatures, i = 0, len;
  if (features) {
    if (!Ext.isArray(features)) {
      features = [features];
    }
    lockedFeatures = [];
    normalFeatures = [];
    len = features.length;
    for (; i < len; i++) {
      feature = features[i];
      if (!feature.isFeature) {
        feature = Ext.create('feature.' + feature.ftype, feature);
      }
      switch(feature.lockableScope) {
        case 'locked':
          lockedFeatures.push(feature);
          break;
        case 'normal':
          normalFeatures.push(feature);
          break;
        default:
          feature.lockableScope = 'both';
          lockedFeatures.push(feature);
          normalFeatures.push(featureClone = feature.clone());
          featureClone.lockingPartner = feature;
          feature.lockingPartner = featureClone;
      }
    }
  }
  return {normalFeatures:normalFeatures, lockedFeatures:lockedFeatures};
}, constructLockablePlugins:function() {
  var plugins = this.plugins, plugin, normalPlugin, lockedPlugin, topPlugins, lockedPlugins, normalPlugins, i = 0, len, lockableScope, pluginCls;
  if (plugins) {
    if (!Ext.isArray(plugins)) {
      plugins = [plugins];
    }
    topPlugins = [];
    lockedPlugins = [];
    normalPlugins = [];
    len = plugins.length;
    for (; i < len; i++) {
      plugin = plugins[i];
      if (plugin.init) {
        lockableScope = plugin.lockableScope;
      } else {
        pluginCls = plugin.ptype ? Ext.ClassManager.getByAlias('plugin.' + plugin.ptype) : Ext.ClassManager.get(plugin.xclass);
        lockableScope = pluginCls.prototype.lockableScope;
      }
      switch(lockableScope) {
        case 'both':
          lockedPlugins.push(lockedPlugin = plugin.clonePlugin());
          normalPlugins.push(normalPlugin = plugin.clonePlugin());
          lockedPlugin.lockingPartner = normalPlugin;
          normalPlugin.lockingPartner = lockedPlugin;
          Ext.destroy(plugin);
          break;
        case 'locked':
          lockedPlugins.push(plugin);
          break;
        case 'normal':
          normalPlugins.push(plugin);
          break;
        default:
          topPlugins.push(plugin);
      }
    }
  }
  return {topPlugins:topPlugins, normalPlugins:normalPlugins, lockedPlugins:lockedPlugins};
}, destroyLockable:function() {
  var me = this, task = me.syncLockedWidthTask;
  if (task) {
    task.cancel();
    me.syncLockedWidthTask = null;
  }
  if (me.lockedGrid && me.lockedGrid.headerCt) {
    me.lockedGrid.headerCt.showMenuBy = null;
  }
  if (me.normalGrid && me.normalGrid.headerCt) {
    me.normalGrid.headerCt.showMenuBy = null;
  }
  Ext.destroy(me.normalScrollbarClipper, me.lockedScrollbarClipper, me.normalScrollbar, me.lockedScrollbar, me.scrollBody, me.scrollContainer, me.normalScrollbarScroller, me.lockedScrollbarScroller, me.view, me.headerCt);
}}, 0, 0, 0, 0, 0, 0, [Ext.grid.locking, 'Lockable', Ext.grid, 'Lockable'], function() {
  this.borrow(Ext.Component, ['constructPlugin']);
});
Ext.cmd.derive('Ext.grid.plugin.BufferedRenderer', Ext.plugin.Abstract, {isBufferedRenderer:true, lockableScope:'both', numFromEdge:2, trailingBufferZone:10, leadingBufferZone:20, synchronousRender:true, scrollToLoadBuffer:200, viewSize:100, rowHeight:21, position:0, scrollTop:0, lastScrollDirection:1, bodyTop:0, scrollHeight:0, loadId:0, init:function(grid) {
  var me = this, view = grid.view, viewListeners = {refresh:me.onViewRefresh, columnschanged:me.checkVariableRowHeight, scope:me, destroyable:true}, scrollerListeners = {scroll:me.onViewScroll, scope:me}, initialConfig = view.initialConfig;
  me.scroller = view.lockingPartner ? view.ownerGrid.scrollable : view.getScrollable();
  if (grid.isTree || grid.ownerLockable && grid.ownerLockable.isTree) {
    view.blockRefresh = false;
    if (initialConfig && initialConfig.loadMask === undefined) {
      view.loadMask = true;
    }
  }
  if (view.positionBody) {
    viewListeners.refresh = me.onViewRefresh;
  }
  me.grid = grid;
  me.view = view;
  me.isRTL = view.getInherited().rtl;
  view.bufferedRenderer = me;
  view.preserveScrollOnRefresh = true;
  view.animate = false;
  me.bindStore(view.dataSource);
  if (view.hasOwnProperty('rowHeight')) {
    me.rowHeight = view.rowHeight;
  }
  me.position = 0;
  me.viewListeners = view.on(viewListeners);
  if (me.scroller) {
    me.scrollListeners = me.scroller.on(scrollerListeners);
  }
}, checkVariableRowHeight:function() {
  var hadVariableRowHeight = this.variableRowHeight;
  this.variableRowHeight = this.view.hasVariableRowHeight();
  if (!!this.variableRowHeight !== !!hadVariableRowHeight) {
    delete this.rowHeight;
  }
}, bindStore:function(newStore) {
  var me = this, currentStore = me.store;
  if (currentStore && currentStore.isFeatureStore) {
    return;
  }
  if (currentStore) {
    me.unbindStore();
  }
  me.storeListeners = newStore.on({scope:me, groupchange:me.onStoreGroupChange, clear:me.onStoreClear, beforeload:me.onBeforeStoreLoad, load:me.onStoreLoad, destroyable:true});
  me.store = newStore;
  me.setBodyTop(me.position = me.scrollTop = 0);
  delete me.viewSize;
  delete me.rowHeight;
  if (newStore.isBufferedStore) {
    newStore.setViewSize(me.viewSize);
  }
}, unbindStore:function() {
  this.storeListeners.destroy();
  this.storeListeners = this.store = null;
}, onBeforeStoreLoad:function(store) {
  var me = this, view = me.view;
  if (view && view.refreshCounter) {
    if (store.isTreeStore || view.preserveScrollOnReload) {
      me.nextRefreshStartIndex = view.all.startIndex;
    } else {
      if (me.scrollTop !== 0) {
        me.setBodyTop(me.bodyTop = me.scrollTop = me.position = me.scrollHeight = me.nextRefreshStartIndex = 0);
        me.scroller.scrollTo(null, 0);
      }
    }
    me.lastScrollDirection = me.scrollOffset = null;
  }
  me.disable();
}, onStoreLoad:function() {
  this.isStoreLoading = true;
  this.enable();
}, onStoreClear:function() {
  var me = this, view = me.view;
  if (view.rendered && !me.store.destroyed) {
    if (me.scrollTop !== 0) {
      me.bodyTop = me.scrollTop = me.position = me.scrollHeight = 0;
      me.nextRefreshStartIndex = null;
      me.scroller.scrollTo(null, 0);
    }
    view.refresh();
    me.lastScrollDirection = me.scrollOffset = null;
  }
}, onStoreGroupChange:function(store) {
  this.refreshSize();
}, onViewRefresh:function(view, records) {
  var me = this, rows = view.all, height;
  me.checkVariableRowHeight();
  if (!view.componentLayoutCounter && (view.headerCt.down('{flex}') || me.variableRowHeight)) {
    view.on({boxready:Ext.Function.pass(me.onViewRefresh, [view, records], me), single:true});
    me.skipNextRefreshSize = true;
    return;
  }
  me.skipNextRefreshSize = false;
  if (me.refreshing) {
    return;
  }
  me.refreshSize();
  if (me.scroller) {
    if (me.scrollTop !== me.scroller.getPosition().y) {
      me.onViewScroll();
    } else {
      if (!me.hasOwnProperty('bodyTop')) {
        me.bodyTop = rows.startIndex * me.rowHeight;
        me.scroller.scrollTo(null, me.bodyTop);
      }
      me.setBodyTop(me.bodyTop);
      height = view.lastBox && view.lastBox.height;
      if (height && rows.getCount()) {
        me.onViewResize(view, null, height);
        if (records && rows.getCount() !== records.length) {
          records.length = 0;
          records.push.apply(records, me.store.getRange(rows.startIndex, rows.endIndex));
        }
      }
    }
  }
}, beforeTableLayout:function(ownerContext) {
  var dom = this.view.body.dom, size;
  if (dom) {
    size = this.grid.getElementSize(dom);
    ownerContext.bodyHeight = size.height;
    ownerContext.bodyWidth = size.width;
  }
}, afterTableLayout:function(ownerContext) {
  var me = this, view = me.view, renderedBlockHeight;
  if (ownerContext.bodyHeight && view.body.dom) {
    delete me.rowHeight;
    me.refreshSize();
    renderedBlockHeight = me.grid.getElementHeight(view.body.dom);
    if (renderedBlockHeight !== ownerContext.bodyHeight) {
      me.onViewResize(view, null, view.el.lastBox.height);
      renderedBlockHeight = me.bodyHeight;
      if (renderedBlockHeight < ownerContext.bodyHeight) {
        if (me.viewSize >= me.store.getCount()) {
          me.setBodyTop(0);
        } else {
          if (me.bodyTop > me.scrollTop || me.bodyTop + renderedBlockHeight < me.scrollTop + me.viewClientHeight) {
            me.setBodyTop(me.scrollTop - me.trailingBufferZone * me.rowHeight);
          }
        }
      }
      if (view.all.endIndex === view.dataSource.getCount() - 1) {
        me.stretchView(view, me.scrollHeight = me.bodyTop + renderedBlockHeight - 1);
      }
    }
  }
}, refreshSize:function() {
  var me = this, view = me.view, skipNextRefreshSize = me.skipNextRefreshSize || Ext.Component.pendingLayouts && Ext.Component.layoutSuspendCount || !view.body.dom;
  me.skipNextRefreshSize = false;
  if (skipNextRefreshSize) {
    return;
  }
  me.bodyHeight = me.grid.getElementHeight(view.body.dom);
  me.scrollHeight = me.getScrollHeight();
  me.stretchView(view, me.scrollHeight);
}, onViewResize:function(view, width, height, oldWidth, oldHeight) {
  var me = this, newViewSize;
  me.refreshSize();
  if (!oldHeight || height !== oldHeight) {
    Ext.suspendLayouts();
    me.viewClientHeight = view.lockingPartner ? me.scroller && me.scroller.getClientSize().y || height : view.el.dom.clientHeight;
    newViewSize = Math.ceil(height / Math.min(me.getThemeRowHeight(), me.rowHeight)) + me.trailingBufferZone + me.leadingBufferZone;
    me.viewSize = me.setViewSize(newViewSize);
    Ext.resumeLayouts(true);
  }
}, stretchView:function(view, scrollRange) {
  var me = this, newY;
  if (me.scrollTop > scrollRange) {
    newY = me.nextRefreshStartIndex == null ? me.bodyHeight : scrollRange - me.bodyHeight;
    me.position = me.scrollTop = Math.max(newY, 0);
    me.scroller.scrollTo(null, me.scrollTop);
  }
  if (me.bodyTop > scrollRange) {
    view.body.translate(null, me.bodyTop = me.position);
  }
  if (view.getScrollable()) {
    me.refreshScroller(view, scrollRange);
  }
}, refreshScroller:function(view, scrollRange) {
  var scroller = view.getScrollable();
  if (scroller) {
    if (scroller.setElementSize) {
      scroller.setElementSize();
    }
    scroller.setSize({x:view.headerCt.getTableWidth(), y:view.lockingPartner ? null : scrollRange});
    if (view.lockingPartner) {
      this.scroller.setSize({x:0, y:scrollRange});
    }
  }
}, setViewSize:function(viewSize, fromLockingPartner) {
  var me = this, store = me.store, view = me.view, ownerGrid, rows = view.all, elCount = rows.getCount(), storeCount = store.getCount(), start, end, lockingPartner = me.view.lockingPartner && me.view.lockingPartner.bufferedRenderer, diff = elCount - viewSize, oldTop = 0, maxIndex = Math.max(0, storeCount - 1), pointyEnd = Ext.Number.sign(me.getFirstVisibleRowIndex() - rows.startIndex - (rows.endIndex - me.getLastVisibleRowIndex()));
  if (lockingPartner && !fromLockingPartner) {
    lockingPartner.setViewSize(viewSize, true);
  }
  diff = elCount - viewSize;
  if (diff) {
    me.scrollTop = me.scroller ? me.scroller.getPosition().y : 0;
    me.viewSize = viewSize;
    if (store.isBufferedStore) {
      store.setViewSize(viewSize);
    }
    if (elCount) {
      start = Math.max(0, Math.min(rows.startIndex, storeCount - viewSize));
      end = Math.min(start + viewSize - 1, maxIndex);
      if (start === rows.startIndex && end === rows.endIndex) {
        if (diff < 0) {
          me.handleViewScroll(pointyEnd);
        }
      } else {
        if (lockingPartner) {
          lockingPartner.disable();
        }
        if (diff < 0) {
          if (storeCount > viewSize && storeCount > elCount) {
            store.getRange(start, end, {callback:function(newRecords, start, end) {
              ownerGrid = view.ownerGrid;
              if (end > rows.endIndex) {
                rows.scroll(Ext.Array.slice(newRecords, rows.endIndex + 1, Infinity), 1, 0);
              }
              if (start < rows.startIndex) {
                oldTop = rows.first(true);
                rows.scroll(Ext.Array.slice(newRecords, 0, rows.startIndex - start), -1, 0);
                me.bodyTop -= oldTop.offsetTop;
              }
              me.setBodyTop(me.bodyTop);
              if (lockingPartner && !fromLockingPartner && (ownerGrid.syncRowHeight || ownerGrid.syncRowHeightOnNextLayout)) {
                lockingPartner.setViewSize(viewSize, true);
                ownerGrid.syncRowHeights();
              }
            }});
          } else {
            me.refreshView(0);
          }
        } else {
          if (pointyEnd === 1) {
            oldTop = rows.item(rows.startIndex + diff, true).offsetTop;
          }
          rows.clip(pointyEnd, diff);
          me.setBodyTop(me.bodyTop + oldTop);
        }
        if (lockingPartner) {
          lockingPartner.enable();
        }
      }
    }
    me.refreshSize();
  }
  return viewSize;
}, getViewRange:function() {
  var me = this, view = me.view, rows = view.all, rowCount = rows.getCount(), lockingPartnerRows = view.lockingPartner && view.lockingPartner.all, store = me.store, startIndex = 0, endIndex;
  if (!me.hasOwnProperty('viewSize') && me.ownerCt && me.ownerCt.height) {
    me.viewSize = Math.ceil(me.ownerCt.height / me.rowHeight);
  }
  if (!store.data.getCount()) {
    return [];
  }
  if (!rowCount && lockingPartnerRows && lockingPartnerRows.getCount()) {
    startIndex = lockingPartnerRows.startIndex;
    endIndex = Math.min(lockingPartnerRows.endIndex, startIndex + me.viewSize - 1, store.getCount() - 1);
  } else {
    if (rowCount) {
      startIndex = rows.startIndex;
    } else {
      if (store.isBufferedStore) {
        if (!store.currentPage) {
          store.currentPage = 1;
        }
        startIndex = rows.startIndex = (store.currentPage - 1) * (store.pageSize || 1);
        store.currentPage = 1;
      }
    }
    endIndex = startIndex + (me.viewSize || store.defaultViewSize) - 1;
  }
  return store.getRange(startIndex, endIndex);
}, onReplace:function(store, startIndex, oldRecords, newRecords) {
  var me = this, scroller = me.scroller, view = me.view, rows = view.all, oldStartIndex, renderedSize = rows.getCount(), lastAffectedIndex = startIndex + oldRecords.length - 1, recordIncrement = newRecords.length - oldRecords.length, scrollIncrement = recordIncrement * me.rowHeight, preserveScrollOnRefresh;
  if (startIndex >= rows.startIndex + me.viewSize) {
    me.refreshSize();
    return;
  }
  if (renderedSize && lastAffectedIndex < rows.startIndex && rows.getCount() >= me.viewSize) {
    rows.moveBlock(recordIncrement);
    me.refreshSize();
    oldStartIndex = rows.startIndex;
    if (recordIncrement > 0) {
      me.doNotMirror = true;
      me.handleViewScroll(-1);
      me.doNotMirror = false;
    }
    if (rows.startIndex === oldStartIndex) {
      if (rows.startIndex) {
        me.setBodyTop(me.bodyTop += scrollIncrement);
        view.suspendEvent('scroll');
        view.scrollBy(0, scrollIncrement);
        view.resumeEvent('scroll');
        me.position = me.scrollTop = me.scroller.getPosition().y;
      }
    } else {
      view.suspendEvent('scroll');
      view.scrollBy(0, (oldStartIndex - rows.startIndex) * me.rowHeight);
      view.resumeEvent('scroll');
    }
    view.refreshSize(rows.getCount() !== renderedSize);
    return;
  }
  if (renderedSize && startIndex > rows.endIndex) {
    me.refreshSize();
    if (recordIncrement > 0) {
      me.onRangeFetched(null, rows.startIndex, Math.min(store.getCount(), rows.startIndex + me.viewSize) - 1);
    }
    view.refreshSize(rows.getCount() !== renderedSize);
    return;
  }
  if (startIndex < rows.startIndex && lastAffectedIndex <= rows.endIndex) {
    preserveScrollOnRefresh = view.preserveScrollOnRefresh;
    view.preserveScrollOnRefresh = false;
    me.refreshView(rows.startIndex - oldRecords.length + newRecords.length);
    view.preserveScrollOnRefresh = preserveScrollOnRefresh;
    return;
  }
  if (startIndex < rows.startIndex && lastAffectedIndex <= rows.endIndex && scrollIncrement) {
    me.doVerticalScroll(scroller, me.scrollTop += scrollIncrement, true);
  }
  me.refreshView(rows.startIndex, scrollIncrement);
}, doVerticalScroll:function(scroller, pos, supressEvents) {
  var me = this;
  if (!scroller) {
    return;
  }
  if (supressEvents) {
    scroller.suspendEvent('scroll');
  }
  scroller.scrollTo(null, me.position = pos);
  if (supressEvents) {
    scroller.resumeEvent('scroll');
  }
}, scrollTo:function(recordIdx, options) {
  var args = arguments, me = this, view = me.view, lockingPartner = view.lockingPartner && view.lockingPartner.grid.isVisible() && view.lockingPartner.bufferedRenderer, store = me.store, total = store.getCount(), startIdx, endIdx, targetRow, tableTop, groupingFeature, metaGroup, record, direction;
  if (options !== undefined && !(options instanceof Object)) {
    options = {select:args[1], callback:args[2], scope:args[3]};
  }
  if ((groupingFeature = view.dataSource.groupingFeature) && groupingFeature.collapsible) {
    if (recordIdx.isEntity) {
      record = recordIdx;
    } else {
      record = view.store.getAt(Math.min(Math.max(recordIdx, 0), view.store.getCount() - 1));
    }
    metaGroup = groupingFeature.getMetaGroup(record);
    if (metaGroup && metaGroup.isCollapsed) {
      if (!groupingFeature.isExpandingOrCollapsing && record !== metaGroup.placeholder) {
        groupingFeature.expand(groupingFeature.getGroup(record).getGroupKey());
        total = store.getCount();
        recordIdx = groupingFeature.indexOf(record);
      } else {
        record = metaGroup.placeholder;
        recordIdx = groupingFeature.indexOfPlaceholder(record);
      }
    } else {
      recordIdx = groupingFeature.indexOf(record);
    }
  } else {
    if (recordIdx.isEntity) {
      record = recordIdx;
      recordIdx = store.indexOf(record);
      if (recordIdx === -1) {
        return;
      }
    } else {
      recordIdx = Math.min(Math.max(recordIdx, 0), total - 1);
      record = store.getAt(recordIdx);
    }
  }
  if (record && (targetRow = view.getNode(record))) {
    view.grid.ensureVisible(record, options);
    me.onViewScroll();
    return;
  }
  if (recordIdx < view.all.startIndex) {
    direction = -1;
    startIdx = Math.max(Math.min(recordIdx - Math.floor((me.leadingBufferZone + me.trailingBufferZone) / 2), total - me.viewSize + 1), 0);
    endIdx = Math.min(startIdx + me.viewSize - 1, total - 1);
  } else {
    direction = 1;
    endIdx = Math.min(recordIdx + Math.floor((me.leadingBufferZone + me.trailingBufferZone) / 2), total - 1);
    startIdx = Math.max(endIdx - (me.viewSize - 1), 0);
  }
  tableTop = Math.max(startIdx * me.rowHeight, 0);
  store.getRange(startIdx, endIdx, {callback:function(range, start, end) {
    me.renderRange(start, end, true);
    record = store.data.getRange(recordIdx, recordIdx + 1)[0];
    targetRow = view.getNode(record);
    view.body.translate(null, me.bodyTop = tableTop);
    if (direction === 1 && view.hasVariableRowHeight()) {
      me.refreshSize();
    }
    if (lockingPartner) {
      lockingPartner.renderRange(start, end, true);
      me.syncRowHeights();
      lockingPartner.view.body.translate(null, lockingPartner.bodyTop = tableTop);
      if (direction === 1) {
        lockingPartner.refreshSize();
      }
    }
    if (!targetRow) {
      return;
    }
    view.grid.ensureVisible(record, options);
    me.scrollTop = me.position = me.scroller.getPosition().y;
    if (lockingPartner) {
      lockingPartner.position = lockingPartner.scrollTop = me.scrollTop;
    }
  }});
}, onViewScroll:function(scroller, x, scrollTop) {
  var me = this, bodyDom = me.view.body.dom, store = me.store, totalCount = store.getCount(), vscrollDistance, scrollDirection;
  me.scrollTop = scrollTop == null ? scrollTop = me.scroller.getPosition().y : scrollTop;
  if (bodyDom) {
    if (!(me.disabled || totalCount < me.viewSize)) {
      vscrollDistance = scrollTop - me.position;
      scrollDirection = vscrollDistance > 0 ? 1 : -1;
      if (Math.abs(vscrollDistance) >= 20 || scrollDirection !== me.lastScrollDirection) {
        me.lastScrollDirection = scrollDirection;
        me.handleViewScroll(me.lastScrollDirection, vscrollDistance);
      }
    }
  }
}, handleViewScroll:function(direction, vscrollDistance) {
  var me = this, rows = me.view.all, store = me.store, storeCount = store.getCount(), viewSize = me.viewSize, lastItemIndex = storeCount - 1, maxRequestStart = Math.max(0, storeCount - viewSize), requestStart, requestEnd;
  if (direction === -1) {
    if (rows.startIndex) {
      if (me.topOfViewCloseToEdge()) {
        requestStart = Math.max(0, me.getLastVisibleRowIndex() + me.trailingBufferZone - viewSize);
        if (requestStart > rows.startIndex) {
          requestStart = Math.max(0, rows.startIndex + Math.floor(vscrollDistance / me.rowHeight));
        }
      }
    }
  } else {
    if (rows.endIndex < lastItemIndex) {
      if (me.bottomOfViewCloseToEdge()) {
        requestStart = Math.max(0, Math.min(me.getFirstVisibleRowIndex() - me.trailingBufferZone, maxRequestStart));
      }
    }
  }
  if (requestStart == null) {
    me.position = me.scrollTop;
    me.loadId++;
  } else {
    requestEnd = Math.min(requestStart + viewSize - 1, lastItemIndex);
    if (me.variableRowHeight && requestEnd === rows.endIndex && requestEnd < lastItemIndex) {
      requestEnd++;
      requestStart++;
    }
    if (requestStart !== rows.startIndex || requestEnd !== rows.endIndex) {
      me.scroller.trackingScrollTop = me.scrollTop;
      me.renderRange(requestStart, requestEnd);
      return true;
    }
  }
}, bottomOfViewCloseToEdge:function() {
  var me = this;
  if (me.variableRowHeight) {
    return me.bodyTop + me.bodyHeight < me.scrollTop + me.view.lastBox.height + me.numFromEdge * me.rowHeight;
  } else {
    return me.view.all.endIndex - me.getLastVisibleRowIndex() < me.numFromEdge;
  }
}, topOfViewCloseToEdge:function() {
  var me = this;
  if (me.variableRowHeight) {
    return me.bodyTop > me.scrollTop - me.numFromEdge * me.rowHeight;
  } else {
    return me.getFirstVisibleRowIndex() - me.view.all.startIndex < me.numFromEdge;
  }
}, refreshView:function(startIndex, scrollIncrement) {
  var me = this, viewSize = me.viewSize, view = me.view, rows = view.all, store = me.store, storeCount = store.getCount(), maxIndex = Math.max(0, storeCount - 1), lockingPartnerRows = view.lockingPartner && view.lockingPartner.all, preserveScroll = me.bodyTop && view.preserveScrollOnRefresh || scrollIncrement, endIndex;
  if (!storeCount) {
    return me.doRefreshView([], 0, 0);
  } else {
    if (storeCount < viewSize) {
      startIndex = 0;
      endIndex = maxIndex;
      me.nextRefreshStartIndex = preserveScroll ? null : 0;
    } else {
      if (startIndex == null && !rows.getCount() && lockingPartnerRows && lockingPartnerRows.getCount()) {
        startIndex = lockingPartnerRows.startIndex;
        endIndex = Math.min(lockingPartnerRows.endIndex, startIndex + viewSize - 1, maxIndex);
      } else {
        if (startIndex == null) {
          if (me.nextRefreshStartIndex != null && !preserveScroll) {
            startIndex = me.nextRefreshStartIndex;
          } else {
            startIndex = rows.startIndex;
          }
          me.nextRefreshStartIndex = null;
        }
        startIndex = Math.max(0, Math.min(startIndex, maxIndex - viewSize + 1));
        endIndex = Math.min(startIndex + viewSize - 1, maxIndex);
        if (endIndex - startIndex + 1 > viewSize) {
          startIndex = endIndex - viewSize + 1;
        }
      }
    }
  }
  if (startIndex === 0 && endIndex === -1) {
    me.doRefreshView([], 0, 0);
  } else {
    store.getRange(startIndex, endIndex, {callback:me.doRefreshView, scope:me});
  }
}, doRefreshView:function(range, startIndex, endIndex) {
  var me = this, view = me.view, scroller = me.scroller, rows = view.all, previousStartIndex = rows.startIndex, previousEndIndex = rows.endIndex, prevRowCount = rows.getCount(), viewMoved = startIndex !== rows.startIndex && !me.isStoreLoading, calculatedTop = -1, previousFirstItem, previousLastItem, scrollIncrement, restoreFocus;
  me.isStoreLoading = false;
  view.refreshing = me.refreshing = true;
  if (view.refreshCounter) {
    if (view.hasListeners.beforerefresh && view.fireEvent('beforerefresh', view) === false) {
      return view.refreshNeeded = view.refreshing = me.refreshing = false;
    }
    restoreFocus = view.saveFocusState();
    view.clearViewEl(true);
    view.refreshCounter++;
    if (range.length) {
      view.doAdd(range, startIndex);
      if (viewMoved) {
        previousFirstItem = rows.item(previousStartIndex, true);
        previousLastItem = rows.item(previousEndIndex, true);
        if (previousFirstItem) {
          scrollIncrement = -previousFirstItem.offsetTop;
        } else {
          if (previousLastItem) {
            scrollIncrement = rows.last(true).offsetTop - previousLastItem.offsetTop;
          }
        }
        if (scrollIncrement) {
          calculatedTop = Math.max(me.bodyTop + scrollIncrement, 0);
          me.scrollTop = calculatedTop ? me.scrollTop + scrollIncrement : 0;
        } else {
          calculatedTop = startIndex * me.rowHeight;
          me.scrollTop = Math.max(calculatedTop + me.rowHeight * (calculatedTop < me.bodyTop ? me.leadingBufferZone : me.trailingBufferZone), 0);
        }
      }
    } else {
      me.scrollTop = calculatedTop = me.position = 0;
      view.addEmptyText();
    }
    if (calculatedTop !== -1) {
      me.setBodyTop(calculatedTop);
      me.doVerticalScroll(scroller, me.scrollTop, true);
    }
    me.refreshSize();
    view.refreshSize(rows.getCount() !== prevRowCount);
    view.fireItemMutationEvent('refresh', view, range);
    restoreFocus();
    if (view.preserveScrollOnRefresh && restoreFocus !== Ext.emptyFn) {
      me.doVerticalScroll(scroller, me.scrollTop, true);
    }
    view.headerCt.setSortState();
  } else {
    view.refresh();
  }
  view.refreshNeeded = view.refreshing = me.refreshing = false;
}, renderRange:function(start, end, forceSynchronous) {
  var me = this, rows = me.view.all, store = me.store;
  if (rows.startIndex === start && rows.endIndex === end) {
    return;
  }
  if (!(start === rows.startIndex && end === rows.endIndex)) {
    if (store.rangeCached(start, end)) {
      me.cancelLoad();
      if (me.synchronousRender || forceSynchronous) {
        me.onRangeFetched(null, start, end);
      } else {
        if (!me.renderTask) {
          me.renderTask = new Ext.util.DelayedTask(me.onRangeFetched, me);
        }
        me.renderTask.delay(-1, null, null, [null, start, end]);
      }
    } else {
      me.attemptLoad(start, end, me.scrollTop);
    }
  }
}, onRangeFetched:function(range, start, end) {
  var me = this, view = me.view, scroller = me.scroller, viewEl = view.el, rows = view.all, increment = 0, calculatedTop, partnerView = !me.doNotMirror && view.lockingPartner, lockingPartner = partnerView && partnerView.bufferedRenderer, partnerRows = partnerView && partnerView.all, variableRowHeight = me.variableRowHeight, doSyncRowHeight = partnerView && partnerView.ownerCt.isVisible() && (view.ownerGrid.syncRowHeight || view.ownerGrid.syncRowHeightOnNextLayout || lockingPartner.variableRowHeight !== 
  variableRowHeight), activeEl, focusedView, i, newRows, newTop, noOverlap, oldStart, partnerNewRows, pos, removeCount, topAdditionSize, topBufferZone, records;
  if (view.destroyed) {
    return;
  }
  if (range) {
    me.scrollTop = scroller.getPosition().y;
  } else {
    range = me.store.getRange(start, end);
    if (!range) {
      return;
    }
  }
  activeEl = Ext.fly(Ext.Element.getActiveElement());
  if (viewEl.contains(activeEl)) {
    focusedView = view;
  } else {
    if (partnerView && partnerView.el.contains(activeEl)) {
      focusedView = partnerView;
    }
  }
  if (focusedView) {
    activeEl.suspendFocusEvents();
  }
  calculatedTop = start * me.rowHeight;
  if (start < rows.startIndex && end > rows.endIndex) {
    topAdditionSize = rows.startIndex - start;
    view.clearViewEl(true);
    newRows = view.doAdd(range, start);
    view.fireItemMutationEvent('itemadd', range, start, newRows, view);
    if (lockingPartner) {
      partnerView.clearViewEl(true);
      partnerNewRows = partnerView.doAdd(range, start);
      partnerView.fireItemMutationEvent('itemadd', range, start, partnerNewRows, partnerView);
      if (doSyncRowHeight) {
        me.syncRowHeights(newRows, partnerNewRows);
        doSyncRowHeight = false;
      }
    }
    for (i = 0; i < topAdditionSize; i++) {
      increment -= me.grid.getElementHeight(newRows[i]);
    }
    newTop = me.bodyTop + increment;
  } else {
    noOverlap = me.teleported || start > rows.endIndex || end < rows.startIndex;
    if (noOverlap) {
      view.clearViewEl(true);
      me.teleported = false;
    }
    if (!rows.getCount()) {
      newRows = view.doAdd(range, start);
      view.fireItemMutationEvent('itemadd', range, start, newRows, view);
      if (lockingPartner) {
        partnerView.clearViewEl(true);
        partnerNewRows = lockingPartner.view.doAdd(range, start);
        partnerView.fireItemMutationEvent('itemadd', range, start, partnerNewRows, partnerView);
      }
      newTop = calculatedTop;
      if (noOverlap && variableRowHeight) {
        topBufferZone = me.scrollTop < me.position ? me.leadingBufferZone : me.trailingBufferZone;
        if (start > topBufferZone) {
          newTop = Math.max(me.scrollTop - rows.item(rows.startIndex + topBufferZone - 1, true).offsetTop, 0);
        }
      }
    } else {
      if (end > rows.endIndex) {
        removeCount = Math.max(start - rows.startIndex, 0);
        if (variableRowHeight) {
          increment = rows.item(rows.startIndex + removeCount, true).offsetTop;
        }
        records = Ext.Array.slice(range, rows.endIndex + 1 - start);
        newRows = rows.scroll(records, 1, removeCount);
        if (lockingPartner) {
          partnerNewRows = partnerRows.scroll(records, 1, removeCount);
        }
        if (variableRowHeight) {
          newTop = me.bodyTop + increment;
        } else {
          newTop = calculatedTop;
        }
      } else {
        removeCount = Math.max(rows.endIndex - end, 0);
        oldStart = rows.startIndex;
        records = Ext.Array.slice(range, 0, rows.startIndex - start);
        newRows = rows.scroll(records, -1, removeCount);
        if (lockingPartner) {
          partnerNewRows = partnerRows.scroll(records, -1, removeCount);
        }
        if (doSyncRowHeight) {
          me.syncRowHeights(newRows, partnerNewRows);
          doSyncRowHeight = false;
          newTop = me.bodyTop - rows.item(oldStart, true).offsetTop;
          if (!rows.startIndex) {
            if (newTop) {
              me.doVerticalScroll(scroller, me.scrollTop -= newTop);
              newTop = 0;
            }
          } else {
            if (newTop < 0) {
              increment = rows.startIndex * me.rowHeight;
              me.doVerticalScroll(scroller, me.scrollTop += increment);
              newTop = me.bodyTop + increment;
            }
          }
        } else {
          newTop = calculatedTop;
        }
      }
    }
    me.position = me.scrollTop;
  }
  if (focusedView) {
    activeEl.resumeFocusEvents();
    if (!focusedView.el.contains(activeEl)) {
      pos = focusedView.actionableMode ? focusedView.actionPosition : focusedView.lastFocused;
      if (pos && pos.column) {
        focusedView.renderingRows = true;
        focusedView.onFocusLeave({});
        focusedView.renderingRows = false;
        me.getNewFocusTarget(pos).focus();
      }
    }
  }
  newTop = Math.max(Math.floor(newTop), 0);
  if (view.positionBody) {
    me.setBodyTop(newTop, true);
  }
  if (lockingPartner) {
    lockingPartner.scrollTop = me.scrollTop;
    if (lockingPartner.bodyTop !== newTop) {
      lockingPartner.setBodyTop(newTop, true);
    }
    if (doSyncRowHeight) {
      me.syncRowHeights(newRows, partnerNewRows);
    }
  } else {
    if (variableRowHeight) {
      delete me.rowHeight;
      me.refreshSize();
    }
  }
  return newRows;
}, getNewFocusTarget:function(pos) {
  var view = pos.view, grid = view.grid, column = pos.column, hiddenHeaders = column.isHidden() || grid.hideHeaders, tabbableItems;
  if (column.focusable && !hiddenHeaders) {
    return column;
  }
  tabbableItems = column.el.findTabbableElements();
  if (tabbableItems && tabbableItems.length) {
    return tabbableItems[0];
  }
  return grid.findFocusTarget() || view.el;
}, syncRowHeights:function(itemEls, partnerItemEls) {
  var me = this, ln = 0, otherLn = 1, mySynchronizer = [], otherSynchronizer = [], RowSynchronizer = Ext.grid.locking.RowSynchronizer, i, rowSync;
  if (itemEls && partnerItemEls) {
    ln = itemEls.length;
    otherLn = partnerItemEls.length;
  }
  if (ln !== otherLn) {
    itemEls = me.view.all.slice();
    partnerItemEls = me.view.lockingPartner.all.slice();
    ln = otherLn = itemEls.length;
  }
  for (i = 0; i < ln; i++) {
    mySynchronizer[i] = rowSync = new RowSynchronizer(me.view, itemEls[i]);
    rowSync.measure();
  }
  for (i = 0; i < otherLn; i++) {
    otherSynchronizer[i] = rowSync = new RowSynchronizer(me.view.lockingPartner, partnerItemEls[i]);
    rowSync.measure();
  }
  for (i = 0; i < ln; i++) {
    mySynchronizer[i].finish(otherSynchronizer[i]);
    otherSynchronizer[i].finish(mySynchronizer[i]);
  }
  me.syncRowHeightsFinish();
}, syncRowHeightsFinish:function() {
  var me = this, view = me.view, lockingPartner = view.lockingPartner.bufferedRenderer, ownerGrid = view.ownerGrid, scrollable = view.getScrollable();
  ownerGrid.syncRowHeightOnNextLayout = false;
  if (view.componentLayoutCounter) {
    delete me.rowHeight;
    me.refreshSize();
    delete lockingPartner.rowHeight;
    lockingPartner.refreshSize();
  }
  if (scrollable) {
    scrollable.restoreState();
  }
}, setBodyTop:function(bodyTop, skipStretchView) {
  var me = this, view = me.view, rows = view.all, store = me.store, body = view.body;
  if (!body.dom) {
    return;
  }
  me.translateBody(body, bodyTop);
  if (me.variableRowHeight) {
    me.bodyHeight = me.grid.getElementHeight(body.dom);
    if (rows.endIndex === store.getCount() - 1) {
      me.scrollHeight = bodyTop + me.bodyHeight - 1;
    } else {
      me.scrollHeight = me.getScrollHeight();
    }
    if (!skipStretchView) {
      me.stretchView(view, me.scrollHeight);
    }
  } else {
    me.bodyHeight = rows.getCount() * me.rowHeight;
  }
}, translateBody:function(body, bodyTop) {
  body.translate(null, this.bodyTop = bodyTop);
}, getFirstVisibleRowIndex:function(startRow, endRow, viewportTop, viewportBottom) {
  var me = this, view = me.view, rows = view.all, elements = rows.elements, clientHeight = me.viewClientHeight, target, targetTop, bodyTop = me.bodyTop;
  if (rows.getCount() && me.variableRowHeight) {
    if (!arguments.length) {
      startRow = rows.startIndex;
      endRow = rows.endIndex;
      viewportTop = me.scrollTop;
      viewportBottom = viewportTop + clientHeight;
      if (bodyTop > viewportBottom || bodyTop + me.bodyHeight < viewportTop) {
        me.teleported = true;
        return Math.floor(me.scrollTop / me.rowHeight);
      }
      target = startRow + Math.min(me.numFromEdge + (me.lastScrollDirection === -1 ? me.leadingBufferZone : me.trailingBufferZone), Math.floor((endRow - startRow) / 2));
    } else {
      if (startRow === endRow) {
        return endRow;
      }
      target = startRow + Math.floor((endRow - startRow) / 2);
    }
    targetTop = bodyTop + elements[target].offsetTop;
    if (targetTop + me.grid.getElementHeight(elements[target]) <= viewportTop) {
      return me.getFirstVisibleRowIndex(target + 1, endRow, viewportTop, viewportBottom);
    }
    if (targetTop <= viewportTop) {
      return target;
    } else {
      if (target !== startRow) {
        return me.getFirstVisibleRowIndex(startRow, target - 1, viewportTop, viewportBottom);
      }
    }
  }
  return Math.floor(me.scrollTop / me.rowHeight);
}, getLastVisibleRowIndex:function(startRow, endRow, viewportTop, viewportBottom) {
  var me = this, view = me.view, rows = view.all, elements = rows.elements, clientHeight = me.viewClientHeight, target, targetTop, targetBottom, bodyTop = me.bodyTop;
  if (rows.getCount() && me.variableRowHeight) {
    if (!arguments.length) {
      startRow = rows.startIndex;
      endRow = rows.endIndex;
      viewportTop = me.scrollTop;
      viewportBottom = viewportTop + clientHeight;
      if (bodyTop > viewportBottom || bodyTop + me.bodyHeight < viewportTop) {
        me.teleported = true;
        return Math.floor(me.scrollTop / me.rowHeight) + Math.ceil(clientHeight / me.rowHeight);
      }
      target = endRow - Math.min(me.numFromEdge + (me.lastScrollDirection === 1 ? me.leadingBufferZone : me.trailingBufferZone), Math.floor((endRow - startRow) / 2));
    } else {
      if (startRow === endRow) {
        return endRow;
      }
      target = startRow + Math.floor((endRow - startRow) / 2);
    }
    targetTop = bodyTop + elements[target].offsetTop;
    if (targetTop > viewportBottom) {
      return me.getLastVisibleRowIndex(startRow, target - 1, viewportTop, viewportBottom);
    }
    targetBottom = targetTop + me.grid.getElementHeight(elements[target]);
    if (targetBottom >= viewportBottom) {
      return target;
    } else {
      if (target !== endRow) {
        return me.getLastVisibleRowIndex(target + 1, endRow, viewportTop, viewportBottom);
      }
    }
  }
  return Math.min(me.getFirstVisibleRowIndex() + Math.ceil(clientHeight / me.rowHeight), rows.endIndex);
}, getScrollHeight:function() {
  var me = this, view = me.view, rows = view.all, store = me.store, recCount = store.getCount(), rowCount = rows.getCount(), row, rowHeight, borderWidth, scrollHeight;
  if (!recCount) {
    return 0;
  }
  if (!me.hasOwnProperty('rowHeight')) {
    if (rowCount) {
      if (me.variableRowHeight) {
        me.rowHeight = Math.floor(me.bodyHeight / rowCount);
      } else {
        row = rows.first();
        rowHeight = row.getHeight();
        if (Ext.isIE8) {
          borderWidth = row.getBorderWidth('b');
          if (borderWidth > 0) {
            rowHeight -= borderWidth;
          }
        }
        me.rowHeight = rowHeight;
      }
    } else {
      delete me.rowHeight;
    }
  }
  if (me.variableRowHeight) {
    if (rows.endIndex === recCount - 1) {
      scrollHeight = me.bodyTop + me.bodyHeight - 1;
    } else {
      scrollHeight = Math.floor((recCount - rowCount) * me.rowHeight) + me.bodyHeight;
      scrollHeight += me.bodyTop - rows.startIndex * me.rowHeight;
    }
  } else {
    scrollHeight = Math.floor(recCount * me.rowHeight);
  }
  return me.scrollHeight = scrollHeight;
}, getThemeRowHeight:function() {
  var me = this, testEl;
  if (!me.themeRowHeight) {
    testEl = Ext.getBody().createChild({cls:'x-theme-row-height-el'});
    me.self.prototype.themeRowHeight = testEl.dom.offsetHeight;
    testEl.destroy();
  }
  return me.themeRowHeight;
}, attemptLoad:function(start, end, loadScrollPosition) {
  var me = this;
  if (me.scrollToLoadBuffer) {
    if (!me.loadTask) {
      me.loadTask = new Ext.util.DelayedTask;
    }
    me.loadTask.delay(me.scrollToLoadBuffer, me.doAttemptLoad, me, [start, end, loadScrollPosition]);
  } else {
    me.doAttemptLoad(start, end, loadScrollPosition);
  }
}, cancelLoad:function() {
  if (this.loadTask) {
    this.loadTask.cancel();
  }
}, doAttemptLoad:function(start, end, loadScrollPosition) {
  var me = this;
  if (!me.destroyed) {
    me.store.getRange(start, end, {loadId:++me.loadId, callback:function(range, start, end, options) {
      if (options.loadId === me.loadId && me.scrollTop === loadScrollPosition) {
        me.onRangeFetched(range, start, end);
      }
    }, fireEvent:false});
  }
}, destroy:function() {
  var me = this;
  me.cancelLoad();
  if (me.store) {
    me.unbindStore();
  }
  Ext.destroy(me.viewListeners, me.stretcher, me.gridListeners, me.scrollListeners);
  Ext.plugin.Abstract.prototype.destroy.call(this);
}}, 0, 0, 0, 0, ['plugin.bufferedrenderer'], 0, [Ext.grid.plugin, 'BufferedRenderer'], 0);
Ext.cmd.derive('Ext.grid.plugin.Editing', Ext.plugin.Abstract, {clicksToEdit:2, triggerEvent:undefined, relayedEvents:['beforeedit', 'edit', 'validateedit', 'canceledit'], defaultFieldUI:'default', defaultFieldXType:'textfield', editStyle:'', constructor:function(config) {
  var me = this;
  Ext.plugin.Abstract.prototype.constructor.call(this, config);
  me.mixins.observable.constructor.call(me);
  me.on('edit', function(editor, e) {
    me.fireEvent('afteredit', editor, e);
  });
}, init:function(grid) {
  var me = this, ownerLockable = grid.ownerLockable;
  me.grid = grid;
  me.view = grid.view;
  me.initEvents();
  if (grid.rendered) {
    me.setup();
  } else {
    me.mon(grid, {beforereconfigure:me.onBeforeReconfigure, reconfigure:me.onReconfigure, scope:me, beforerender:{fn:me.onBeforeRender, single:true, scope:me}});
  }
  grid.editorEventRelayers = grid.relayEvents(me, me.relayedEvents);
  if (ownerLockable) {
    ownerLockable.editorEventRelayers = ownerLockable.relayEvents(me, me.relayedEvents);
  }
  grid.isEditable = true;
  grid.editingPlugin = grid.view.editingPlugin = me;
}, onBeforeReconfigure:function() {
  this.reconfiguring = true;
}, onReconfigure:function() {
  this.setup();
  delete this.reconfiguring;
}, onBeforeRender:function() {
  this.setup();
}, setup:function() {
  this.initFieldAccessors(this.grid.getTopLevelColumnManager().getColumns());
}, destroy:function() {
  var me = this, grid = me.grid;
  Ext.destroy(me.keyNav);
  me.clearListeners();
  if (grid) {
    if (grid.ownerLockable) {
      Ext.destroy(grid.ownerLockable.editorEventRelayers);
      grid.ownerLockable.editorEventRelayers = null;
    }
    Ext.destroy(grid.editorEventRelayers);
    grid.editorEventRelayers = null;
    grid.editingPlugin = grid.view.editingPlugin = null;
  }
  Ext.plugin.Abstract.prototype.destroy.call(this);
}, getEditStyle:function() {
  return this.editStyle;
}, initFieldAccessors:function(columns) {
  if (columns.isGroupHeader) {
    columns = columns.getGridColumns();
  } else {
    if (!Ext.isArray(columns)) {
      columns = [columns];
    }
  }
  var me = this, c, cLen = columns.length, getEditor = function(record, defaultField) {
    return me.getColumnField(this, defaultField);
  }, hasEditor = function() {
    return me.hasColumnField(this);
  }, setEditor = function(field) {
    me.setColumnField(this, field);
  }, column;
  for (c = 0; c < cLen; c++) {
    column = columns[c];
    if (!column.getEditor) {
      column.getEditor = getEditor;
    }
    if (!column.hasEditor) {
      column.hasEditor = hasEditor;
    }
    if (!column.setEditor) {
      column.setEditor = setEditor;
    }
  }
}, removeFieldAccessors:function(columns) {
  if (columns.isGroupHeader) {
    columns = columns.getGridColumns();
  } else {
    if (!Ext.isArray(columns)) {
      columns = [columns];
    }
  }
  var c, cLen = columns.length, column;
  for (c = 0; c < cLen; c++) {
    column = columns[c];
    column.getEditor = column.hasEditor = column.setEditor = column.field = column.editor = null;
  }
}, getColumnField:function(columnHeader, defaultField) {
  var me = this, field = columnHeader.field;
  if (!(field && field.isFormField)) {
    field = columnHeader.field = me.createColumnField(columnHeader, defaultField);
  }
  if (field && field.ui === 'default' && !field.hasOwnProperty('ui')) {
    field.ui = me.defaultFieldUI;
  }
  return field;
}, hasColumnField:function(columnHeader) {
  return !!(columnHeader.field && columnHeader.field.isComponent);
}, setColumnField:function(columnHeader, field) {
  columnHeader.field = field;
  columnHeader.field = this.createColumnField(columnHeader);
}, createColumnField:function(column, defaultField) {
  var field = column.field, dataIndex;
  if (!field && column.editor) {
    field = column.editor = Ext.clone(column.editor);
    if (field.field) {
      field = field.field;
      field.editorCfg = column.editor;
      delete field.editorCfg.field;
    }
    column.editor = null;
  }
  if (!field && defaultField) {
    field = defaultField;
  }
  if (field) {
    dataIndex = column.dataIndex;
    if (field.isComponent) {
      field.column = column;
    } else {
      if (Ext.isString(field)) {
        field = {name:dataIndex, xtype:field, column:column};
      } else {
        field = Ext.apply({name:dataIndex, column:column}, field);
      }
      field = Ext.ComponentManager.create(field, this.defaultFieldXType);
    }
    field.dataIndex = dataIndex;
    field.isEditorComponent = true;
    column.field = field;
  }
  return field;
}, initEvents:function() {
  var me = this;
  me.initEditTriggers();
  me.initCancelTriggers();
}, initCancelTriggers:Ext.emptyFn, initEditTriggers:function() {
  var me = this, view = me.view;
  if (me.triggerEvent === 'cellfocus') {
    me.mon(view, 'cellfocus', me.onCellFocus, me);
  } else {
    if (me.triggerEvent === 'rowfocus') {
      me.mon(view, 'rowfocus', me.onRowFocus, me);
    } else {
      if (view.getSelectionModel().isCellModel) {
        view.onCellFocus = me.beforeViewCellFocus.bind(me);
      }
      me.mon(view, me.triggerEvent || 'cell' + (me.clicksToEdit === 1 ? 'click' : 'dblclick'), me.onCellClick, me);
    }
  }
  me.initAddRemoveHeaderEvents();
  me.view.getNavigationModel().addKeyBindings({esc:me.onEscKey, scope:me});
}, beforeViewCellFocus:function(position) {
  if (this.view.selModel.keyNavigation || !this.editing || !this.isCellEditable || !this.isCellEditable(position.row, position.columnHeader)) {
    this.view.focusCell.apply(this.view, arguments);
  }
}, onRowFocus:function(record, row, rowIdx) {
  this.startEdit(row, 0);
}, onCellFocus:function(record, cell, position) {
  this.startEdit(position.row, position.column);
}, onCellClick:function(view, cell, colIdx, record, row, rowIdx, e) {
  var ownerGrid = view.ownerGrid, expanderSelector = view.expanderSelector, columnHeader = view.ownerCt.getColumnManager().getHeaderAtIndex(colIdx), editor = columnHeader.getEditor(record), targetCmp;
  if (this.shouldStartEdit(editor) && (!expanderSelector || !e.getTarget(expanderSelector))) {
    ownerGrid.setActionableMode(true, e.position);
  } else {
    if (ownerGrid.actionableMode && view.owns(e.target) && (targetCmp = Ext.Component.from(e, cell)) && targetCmp.focusable) {
      return;
    } else {
      if (ownerGrid.actionableMode) {
        ownerGrid.setActionableMode(false);
      }
    }
  }
}, initAddRemoveHeaderEvents:function() {
  var me = this, headerCt = me.grid.headerCt;
  me.mon(headerCt, {scope:me, add:me.onColumnAdd, columnmove:me.onColumnMove, beforedestroy:me.beforeGridHeaderDestroy});
}, onColumnAdd:function(ct, column) {
  this.initFieldAccessors(column);
}, onColumnMove:Ext.emptyFn, onEscKey:function(e) {
  if (this.editing) {
    var targetComponent = Ext.getCmp(e.getTarget().getAttribute('componentId'));
    if (!(targetComponent && targetComponent.isPickerField && targetComponent.isExpanded)) {
      return this.cancelEdit();
    }
  }
}, beforeEdit:Ext.emptyFn, shouldStartEdit:function(editor) {
  return !!editor;
}, getEditingContext:function(record, columnHeader, horizontalScroll) {
  var me = this, grid = me.grid, colMgr = grid.visibleColumnManager, layoutView = me.grid.lockable ? me.grid : me.view, view, gridRow, rowIdx, colIdx, result;
  if (!layoutView.componentLayoutCounter) {
    layoutView.on({boxready:Ext.Function.bind(me.startEdit, me, [record, columnHeader]), single:true});
    return;
  }
  if (me.disabled || me.grid.collapsed || !me.grid.view.isVisible(true)) {
    return;
  }
  if (Ext.isNumber(columnHeader)) {
    columnHeader = colMgr.getHeaderAtIndex(Math.min(columnHeader, colMgr.getColumns().length));
  }
  if (!columnHeader) {
    return;
  }
  if (columnHeader.hidden) {
    columnHeader = columnHeader.next(':not([hidden])') || columnHeader.prev(':not([hidden])');
  }
  view = columnHeader.getView();
  grid = view.ownerCt;
  if (Ext.isNumber(record)) {
    rowIdx = Math.min(record, view.dataSource.getCount() - 1);
    record = view.dataSource.getAt(rowIdx);
  } else {
    rowIdx = view.dataSource.indexOf(record);
  }
  grid.ensureVisible(record, {column:horizontalScroll ? columnHeader : null});
  gridRow = view.getRow(record);
  if (!gridRow) {
    return;
  }
  colIdx = view.getVisibleColumnManager().indexOf(columnHeader);
  if (!record) {
    return;
  }
  result = (new Ext.grid.CellContext(view)).setAll(view, rowIdx, colIdx, record, columnHeader);
  result.grid = grid;
  result.store = view.dataSource;
  result.field = columnHeader.dataIndex;
  result.value = result.originalValue = record.get(columnHeader.dataIndex);
  result.row = gridRow;
  result.node = view.getNode(record);
  result.cell = result.getCell(true);
  return result;
}, cancelEdit:function() {
  var me = this;
  me.editing = false;
  me.fireEvent('canceledit', me, me.context);
}, completeEdit:function() {
  var me = this;
  if (me.editing && me.validateEdit()) {
    me.fireEvent('edit', me, me.context);
  }
  me.context = null;
  me.editing = false;
}, validateEdit:function(context) {
  var me = this;
  return me.fireEvent('validateedit', me, context) !== false && !context.cancel;
}}, 1, 0, 0, 0, ['editing.editing'], [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.grid.plugin, 'Editing'], 0);
Ext.cmd.derive('Ext.grid.plugin.CellEditing', Ext.grid.plugin.Editing, {init:function(grid) {
  var me = this;
  grid.registerActionable(me);
  Ext.grid.plugin.Editing.prototype.init.apply(this, arguments);
  me.editors = new Ext.util.MixedCollection(false, function(editor) {
    return editor.editorId;
  });
}, beforeGridHeaderDestroy:function(headerCt) {
  var me = this, columns = me.grid.getColumnManager().getColumns(), len = columns.length, i, column, editor;
  for (i = 0; i < len; i++) {
    column = columns[i];
    editor = me.editors.getByKey(column.getItemId());
    if (!editor) {
      editor = column.editor || column.field;
    }
    Ext.destroy(editor);
    me.removeFieldAccessors(column);
  }
}, onReconfigure:function(grid, store, columns) {
  if (columns) {
    this.editors.clear();
  }
  Ext.grid.plugin.Editing.prototype.onReconfigure.call(this);
}, destroy:function() {
  var me = this;
  if (me.editors) {
    me.editors.each(Ext.destroy, Ext);
    me.editors.clear();
  }
  Ext.grid.plugin.Editing.prototype.destroy.call(this);
}, initCancelTriggers:function() {
  var me = this, grid = me.grid;
  me.mon(grid, {columnresize:me.cancelEdit, columnmove:me.cancelEdit, scope:me});
}, isCellEditable:function(record, columnHeader) {
  var me = this, context = me.getEditingContext(record, columnHeader);
  if (context.view.isVisible(true) && context) {
    columnHeader = context.column;
    record = context.record;
    if (columnHeader && me.getEditor(record, columnHeader)) {
      return true;
    }
  }
}, activateCell:function(position, skipBeforeCheck, doFocus) {
  var me = this, record = position.record, column = position.column, prevEditor = me.getActiveEditor(), view = me.view, context, contextGeneration, cell, editor, p, editValue, abortEdit;
  context = me.getEditingContext(record, column);
  if (!context || !column.getEditor(record)) {
    return;
  }
  if (prevEditor && prevEditor.editing) {
    view.actionPosition = null;
    contextGeneration = context.generation;
    if (prevEditor.completeEdit() === false) {
      return;
    }
    if (context.generation === contextGeneration) {
      context.refresh();
    }
  }
  if (!skipBeforeCheck) {
    contextGeneration = context.generation;
    if (view.actionableMode) {
      view.skipSaveFocusState = true;
    }
    abortEdit = me.beforeEdit(context) === false || me.fireEvent('beforeedit', me, context) === false || context.cancel;
    view.skipSaveFocusState = false;
    if (abortEdit) {
      return;
    }
    if (context.generation === contextGeneration) {
      context.refresh();
    }
  }
  editor = me.getEditor(record, column);
  if (context.cell !== context.getCell(true)) {
    context = me.getEditingContext(context.rowIdx, context.colIdx);
    position.setPosition(context);
  }
  if (editor) {
    cell = Ext.get(context.cell);
    if (!editor.rendered) {
      editor.hidden = true;
      editor.render(cell);
    } else {
      p = editor.el.dom.parentNode;
      if (p !== cell.dom) {
        try {
          p.removeChild(editor.el.dom);
        } catch (e$40) {
        }
        if (editor.container && editor.container.dom !== cell.dom) {
          editor.container.collect();
        }
        editor.container = cell;
        cell.dom.appendChild(editor.el.dom, cell.dom.firstChild);
      }
    }
    editValue = context.record.get(context.column.dataIndex);
    if (editValue !== context.originalValue) {
      context.value = context.originalValue = editValue;
    }
    me.setEditingContext(context);
    editor.startEdit(cell, context.value, doFocus || false);
    if (editor.editing) {
      me.setActiveEditor(editor);
      me.setActiveRecord(context.record);
      me.setActiveColumn(context.column);
      me.editing = true;
      me.scroll = position.view.el.getScroll();
    }
    return editor.editing;
  }
}, activateRow:Ext.emptyFn, deactivate:function() {
  var me = this, context = me.context, editors = me.editors.items, len = editors.length, editor, i;
  for (i = 0; i < len; i++) {
    editor = editors[i];
    if (context.view.renderingRows) {
      if (editor.editing) {
        me.cancelEdit();
      }
      editor.cacheElement();
    }
  }
}, suspend:function() {
  var me = this, editor = me.activeEditor;
  if (editor && editor.editing) {
    me.suspendedEditor = editor;
    me.suspendEvents();
    editor.suspendEvents();
    editor.cancelEdit(true);
    editor.resumeEvents();
    me.resumeEvents();
  }
}, resume:function(position) {
  var me = this, editor = me.activeEditor = me.suspendedEditor, result;
  if (editor) {
    me.suspendEvents();
    editor.suspendEvents();
    result = me.activateCell(position, true, true);
    editor.resumeEvents();
    me.resumeEvents();
  }
  return result;
}, startEdit:function(record, columnHeader) {
  this.startEditByPosition((new Ext.grid.CellContext(this.view)).setPosition(record, columnHeader));
}, completeEdit:function(remainVisible) {
  var activeEd = this.getActiveEditor();
  if (activeEd) {
    activeEd.completeEdit(remainVisible);
  }
}, setEditingContext:function(context) {
  this.context = context;
}, setActiveEditor:function(ed) {
  this.activeEditor = ed;
}, getActiveEditor:function() {
  return this.activeEditor;
}, setActiveColumn:function(column) {
  this.activeColumn = column;
}, getActiveColumn:function() {
  return this.activeColumn;
}, setActiveRecord:function(record) {
  this.activeRecord = record;
}, getActiveRecord:function() {
  return this.activeRecord;
}, getEditor:function(record, column) {
  return this.getCachedEditor(column.getItemId(), record, column);
}, getCachedEditor:function(editorId, record, column) {
  var me = this, editors = me.editors, editor = editors.getByKey(editorId);
  if (!editor) {
    editor = column.getEditor(record);
    if (!editor) {
      return false;
    }
    if (!(editor instanceof Ext.grid.CellEditor)) {
      editor = Ext.widget(Ext.apply({xtype:'celleditor', floating:true, editorId:editorId, field:editor}, editor.editorCfg));
    }
    editor.field.excludeForm = true;
    if (editor.column !== column) {
      editor.column = column;
      column.on('removed', me.onColumnRemoved, me);
    }
    editors.add(editor);
  }
  editor.ownerCmp = me.grid.ownerGrid;
  if (column.isTreeColumn) {
    editor.isForTree = column.isTreeColumn;
    editor.addCls('x-tree-cell-editor');
  }
  editor.setGrid(me.grid);
  editor.editingPlugin = me;
  editor.collectContainerElement = true;
  return editor;
}, onColumnRemoved:function(column) {
  var me = this, context = me.context;
  if (context && context.column === column) {
    me.cancelEdit();
  }
  column.un('removed', me.onColumnRemoved, me);
}, setColumnField:function(column, field) {
  var ed = this.editors.getByKey(column.getItemId());
  Ext.destroy(ed, column.field);
  this.editors.removeAtKey(column.getItemId());
  Ext.grid.plugin.Editing.prototype.setColumnField.apply(this, arguments);
}, getCell:function(record, column, returnElement) {
  return this.grid.getView().getCell(record, column, returnElement);
}, onEditComplete:function(ed, value, startValue) {
  var me = this, context = ed.context, view, record;
  view = context.view;
  record = context.record;
  context.value = value;
  if (!record.isEqual(value, startValue)) {
    record.set(context.column.dataIndex, value);
    context.rowIdx = view.indexOf(record);
  }
  if (me.context === context) {
    me.setActiveEditor(null);
    me.setActiveColumn(null);
    me.setActiveRecord(null);
    me.editing = false;
  }
  me.fireEvent('edit', me, context);
}, cancelEdit:function(activeEd) {
  var me = this, context = me.context;
  if (activeEd && activeEd.isCellEditor) {
    me.context.value = 'editedValue' in activeEd ? activeEd.editedValue : activeEd.getValue();
    Ext.grid.plugin.Editing.prototype.cancelEdit.apply(this, arguments);
    if (activeEd.context === context) {
      me.setActiveEditor(null);
      me.setActiveColumn(null);
      me.setActiveRecord(null);
    } else {
      me.editing = true;
    }
  } else {
    activeEd = me.getActiveEditor();
    if (activeEd && activeEd.field) {
      activeEd.cancelEdit();
    }
  }
}, startEditByPosition:function(position) {
  var me = this, cm = me.grid.getColumnManager(), index, activeEditor = me.getActiveEditor();
  if (!position.isCellContext) {
    position = (new Ext.grid.CellContext(me.view)).setPosition(position.row, me.grid.getColumnManager().getColumns()[position.column]);
  }
  index = cm.getHeaderIndex(position.column);
  position.column = cm.getVisibleHeaderClosestToIndex(index);
  if (me.grid.actionableMode) {
    if (me.editing && position.isEqual(me.context)) {
      return;
    }
    if (activeEditor) {
      activeEditor.completeEdit();
    }
  }
  if (me.grid.actionableMode) {
    if (me.activateCell(position)) {
      me.activateRow(me.view.all.item(position.rowIdx, true));
      activeEditor = me.getEditor(position.record, position.column);
      if (activeEditor) {
        activeEditor.field.focus();
      }
    }
  } else {
    return me.grid.setActionableMode(true, position);
  }
}}, 0, 0, 0, 0, ['plugin.cellediting'], 0, [Ext.grid.plugin, 'CellEditing'], 0);
Ext.cmd.derive('Ext.util.Queue', Ext.Base, {constructor:function() {
  this.clear();
}, add:function(obj, replace) {
  var me = this, key = me.getKey(obj), prevEntry;
  if (!(prevEntry = me.map[key])) {
    ++me.length;
    me.items.push(obj);
    me.map[key] = obj;
  } else {
    if (replace) {
      me.map[key] = obj;
      me.items[Ext.Array.indexOf(me.items, prevEntry)] = obj;
    }
  }
  return obj;
}, clear:function() {
  var me = this, items = me.items;
  me.items = [];
  me.map = {};
  me.length = 0;
  return items;
}, contains:function(obj) {
  var key = this.getKey(obj);
  return this.map.hasOwnProperty(key);
}, getCount:function() {
  return this.length;
}, getKey:function(obj) {
  return obj.id;
}, remove:function(obj) {
  var me = this, key = me.getKey(obj), items = me.items, index;
  if (me.map[key]) {
    index = Ext.Array.indexOf(items, obj);
    Ext.Array.erase(items, index, 1);
    delete me.map[key];
    --me.length;
  }
  return obj;
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Queue'], 0);
Ext.cmd.derive('Ext.layout.ContextItem', Ext.Base, {heightModel:null, widthModel:null, sizeModel:null, optOut:false, ownerSizePolicy:null, boxChildren:null, boxParent:null, children:[], dirty:null, dirtyCount:0, hasRawContent:true, isContextItem:true, isTopLevel:false, consumersContentHeight:0, consumersContentWidth:0, consumersContainerHeight:0, consumersContainerWidth:0, consumersHeight:0, consumersWidth:0, ownerCtContext:null, remainingChildDimensions:0, props:null, state:null, wrapsComponent:false, 
constructor:function(config) {
  var me = this, sizeModels = Ext.layout.SizeModel.sizeModels, configured = sizeModels.configured, shrinkWrap = sizeModels.shrinkWrap, el, lastBox, ownerCt, ownerCtContext, props, sizeModel, target, lastWidth, lastHeight, sameWidth, sameHeight, widthModel, heightModel, optOut;
  Ext.apply(me, config);
  target = me.target;
  el = me.el;
  me.id = target.id;
  me.flushedProps = {};
  me.props = props = {};
  me.styles = {};
  if (!target.isComponent) {
    lastBox = el.lastBox;
  } else {
    me.wrapsComponent = true;
    me.framing = target.frameSize || null;
    me.isComponentChild = target.ownerLayout && target.ownerLayout.isComponentLayout;
    lastBox = target.lastBox;
    ownerCt = target.ownerCt;
    if (ownerCt && (ownerCtContext = ownerCt.el && me.context.items[ownerCt.el.id])) {
      me.ownerCtContext = ownerCtContext;
    }
    me.sizeModel = sizeModel = target.getSizeModel(ownerCtContext && ownerCtContext.widthModel.pairsByHeightOrdinal[ownerCtContext.heightModel.ordinal]);
    me.widthModel = widthModel = sizeModel.width;
    me.heightModel = heightModel = sizeModel.height;
    if (lastBox && lastBox.invalid === false) {
      sameWidth = target.width === (lastWidth = lastBox.width);
      sameHeight = target.height === (lastHeight = lastBox.height);
      if (widthModel === shrinkWrap && heightModel === shrinkWrap) {
        optOut = true;
      } else {
        if (widthModel === configured && sameWidth) {
          optOut = heightModel === shrinkWrap || heightModel === configured && sameHeight;
        }
      }
      if (optOut) {
        me.optOut = true;
        props.width = lastWidth;
        props.height = lastHeight;
      }
    }
  }
  me.lastBox = lastBox;
}, init:function(full, options) {
  var me = this, oldProps = me.props, oldDirty = me.dirty, ownerCtContext = me.ownerCtContext, ownerLayout = me.target.ownerLayout, firstTime = !me.state, ret = full || firstTime, children, i, n, ownerCt, sizeModel, target, oldHeightModel = me.heightModel, oldWidthModel = me.widthModel, newHeightModel, newWidthModel, remainingCount = 0;
  me.dirty = me.invalid = false;
  me.props = {};
  me.remainingChildDimensions = 0;
  if (me.boxChildren) {
    me.boxChildren.length = 0;
  }
  if (!firstTime) {
    me.clearAllBlocks('blocks');
    me.clearAllBlocks('domBlocks');
  }
  if (!me.wrapsComponent) {
    return ret;
  }
  target = me.target;
  me.state = {};
  if (firstTime) {
    if (target.beforeLayout && target.beforeLayout !== Ext.emptyFn) {
      target.beforeLayout();
    }
    if (!ownerCtContext && (ownerCt = target.ownerCt)) {
      ownerCtContext = me.context.items[ownerCt.el.id];
    }
    if (ownerCtContext) {
      me.ownerCtContext = ownerCtContext;
      me.isBoxParent = ownerLayout && ownerLayout.isItemBoxParent(me);
    } else {
      me.isTopLevel = true;
    }
    me.frameBodyContext = me.getEl('frameBody');
  } else {
    ownerCtContext = me.ownerCtContext;
    me.isTopLevel = !ownerCtContext;
    children = me.children;
    for (i = 0, n = children.length; i < n; ++i) {
      children[i].init(true);
    }
  }
  me.hasRawContent = !(target.isContainer && target.items.items.length > 0);
  if (full) {
    me.widthModel = me.heightModel = null;
    sizeModel = target.getSizeModel(ownerCtContext && ownerCtContext.widthModel.pairsByHeightOrdinal[ownerCtContext.heightModel.ordinal]);
    if (firstTime) {
      me.sizeModel = sizeModel;
    }
    me.widthModel = sizeModel.width;
    me.heightModel = sizeModel.height;
    if (ownerCtContext && !me.isComponentChild) {
      if (ownerLayout.needsItemSize || !target.liquidLayout) {
        ownerCtContext.remainingChildDimensions += 2;
      } else {
        if (me.widthModel.calculated) {
          ++ownerCtContext.remainingChildDimensions;
        }
        if (me.heightModel.calculated) {
          ++ownerCtContext.remainingChildDimensions;
        }
      }
    }
  } else {
    if (oldProps) {
      me.recoverProp('x', oldProps, oldDirty);
      me.recoverProp('y', oldProps, oldDirty);
      if (me.widthModel.calculated) {
        me.recoverProp('width', oldProps, oldDirty);
      } else {
        if ('width' in oldProps) {
          ++remainingCount;
        }
      }
      if (me.heightModel.calculated) {
        me.recoverProp('height', oldProps, oldDirty);
      } else {
        if ('height' in oldProps) {
          ++remainingCount;
        }
      }
      if (ownerCtContext && !me.isComponentChild) {
        ownerCtContext.remainingChildDimensions += remainingCount;
      }
    }
  }
  if (oldProps && ownerLayout && ownerLayout.manageMargins) {
    me.recoverProp('margin-top', oldProps, oldDirty);
    me.recoverProp('margin-right', oldProps, oldDirty);
    me.recoverProp('margin-bottom', oldProps, oldDirty);
    me.recoverProp('margin-left', oldProps, oldDirty);
  }
  if (options) {
    newHeightModel = options.heightModel;
    newWidthModel = options.widthModel;
    if (newWidthModel && newHeightModel && oldWidthModel && oldHeightModel) {
      if (oldWidthModel.shrinkWrap && oldHeightModel.shrinkWrap) {
        if (newWidthModel.constrainedMax && newHeightModel.constrainedMin) {
          newHeightModel = null;
        }
      }
    }
    if (newWidthModel) {
      me.widthModel = newWidthModel;
    }
    if (newHeightModel) {
      me.heightModel = newHeightModel;
    }
    if (options.state) {
      Ext.apply(me.state, options.state);
    }
  }
  return ret;
}, initContinue:function(full) {
  var me = this, ownerCtContext = me.ownerCtContext, comp = me.target, widthModel = me.widthModel, inheritedState = comp.getInherited(), boxParent;
  if (widthModel.fixed) {
    inheritedState.inShrinkWrapTable = false;
  } else {
    delete inheritedState.inShrinkWrapTable;
  }
  if (full) {
    if (ownerCtContext && widthModel.shrinkWrap) {
      boxParent = ownerCtContext.isBoxParent ? ownerCtContext : ownerCtContext.boxParent;
      if (boxParent) {
        boxParent.addBoxChild(me);
      }
    } else {
      if (widthModel.natural) {
        me.boxParent = ownerCtContext;
      }
    }
  }
  return full;
}, initDone:function(containerLayoutDone) {
  var me = this, props = me.props, state = me.state;
  if (me.remainingChildDimensions === 0) {
    props.containerChildrenSizeDone = true;
  }
  if (containerLayoutDone) {
    props.containerLayoutDone = true;
  }
  if (me.boxChildren && me.boxChildren.length && me.widthModel.shrinkWrap) {
    me.el.setWidth(10000);
    state.blocks = (state.blocks || 0) + 1;
  }
}, initAnimation:function() {
  var me = this, target = me.target, ownerCtContext = me.ownerCtContext;
  if (ownerCtContext && ownerCtContext.isTopLevel) {
    me.animatePolicy = target.ownerLayout.getAnimatePolicy(me);
  } else {
    if (!ownerCtContext && target.isCollapsingOrExpanding && target.animCollapse) {
      me.animatePolicy = target.componentLayout.getAnimatePolicy(me);
    }
  }
  if (me.animatePolicy) {
    me.context.queueAnimation(me);
  }
}, addBlock:function(name, layout, propName) {
  var me = this, collection = me[name] || (me[name] = {}), blockedLayouts = collection[propName] || (collection[propName] = {});
  if (!blockedLayouts[layout.id]) {
    blockedLayouts[layout.id] = layout;
    ++layout.blockCount;
    ++me.context.blockCount;
  }
}, addBoxChild:function(boxChildItem) {
  var me = this, children, widthModel = boxChildItem.widthModel;
  boxChildItem.boxParent = this;
  boxChildItem.measuresBox = widthModel.shrinkWrap ? boxChildItem.hasRawContent : widthModel.natural;
  if (boxChildItem.measuresBox) {
    children = me.boxChildren;
    if (children) {
      children.push(boxChildItem);
    } else {
      me.boxChildren = [boxChildItem];
    }
  }
}, addPositionStyles:function(styles, props) {
  var x = props.x, y = props.y, count = 0;
  if (x !== undefined) {
    styles[this.translateProps.x] = x + 'px';
    ++count;
  }
  if (y !== undefined) {
    styles.top = y + 'px';
    ++count;
  }
  return count;
}, addTrigger:function(propName, inDom) {
  var me = this, name = inDom ? 'domTriggers' : 'triggers', collection = me[name] || (me[name] = {}), context = me.context, layout = context.currentLayout, triggers = collection[propName] || (collection[propName] = {});
  if (!triggers[layout.id]) {
    triggers[layout.id] = layout;
    ++layout.triggerCount;
    triggers = context.triggers[inDom ? 'dom' : 'data'];
    (triggers[layout.id] || (triggers[layout.id] = [])).push({item:this, prop:propName});
    if (me.props[propName] !== undefined) {
      if (!inDom || !(me.dirty && propName in me.dirty)) {
        ++layout.firedTriggers;
      }
    }
  }
}, boxChildMeasured:function() {
  var me = this, state = me.state, count = state.boxesMeasured = (state.boxesMeasured || 0) + 1;
  if (count === me.boxChildren.length) {
    state.clearBoxWidth = 1;
    ++me.context.progressCount;
    me.markDirty();
  }
}, borderNames:['border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'], marginNames:['margin-top', 'margin-right', 'margin-bottom', 'margin-left'], paddingNames:['padding-top', 'padding-right', 'padding-bottom', 'padding-left'], trblNames:['top', 'right', 'bottom', 'left'], cacheMissHandlers:{borderInfo:function(me) {
  var info = me.getStyles(me.borderNames, me.trblNames);
  info.width = info.left + info.right;
  info.height = info.top + info.bottom;
  return info;
}, marginInfo:function(me) {
  var info = me.getStyles(me.marginNames, me.trblNames);
  info.width = info.left + info.right;
  info.height = info.top + info.bottom;
  return info;
}, paddingInfo:function(me) {
  var item = me.frameBodyContext || me, info = item.getStyles(me.paddingNames, me.trblNames);
  info.width = info.left + info.right;
  info.height = info.top + info.bottom;
  return info;
}}, checkCache:function(entry) {
  return this.cacheMissHandlers[entry](this);
}, clearAllBlocks:function(name) {
  var collection = this[name], propName;
  if (collection) {
    for (propName in collection) {
      this.clearBlocks(name, propName);
    }
  }
}, clearBlocks:function(name, propName) {
  var collection = this[name], blockedLayouts = collection && collection[propName], context, layout, layoutId;
  if (blockedLayouts) {
    delete collection[propName];
    context = this.context;
    for (layoutId in blockedLayouts) {
      layout = blockedLayouts[layoutId];
      --context.blockCount;
      if (!--layout.blockCount && !layout.pending && !layout.done) {
        context.queueLayout(layout);
      }
    }
  }
}, block:function(layout, propName) {
  this.addBlock('blocks', layout, propName);
}, domBlock:function(layout, propName) {
  this.addBlock('domBlocks', layout, propName);
}, fireTriggers:function(name, propName) {
  var collection = this[name], triggers = collection && collection[propName], context = this.context, layout, layoutId;
  if (triggers) {
    for (layoutId in triggers) {
      layout = triggers[layoutId];
      ++layout.firedTriggers;
      if (!layout.done && !layout.blockCount && !layout.pending) {
        context.queueLayout(layout);
      }
    }
  }
}, flush:function() {
  var me = this, dirty = me.dirty, state = me.state, targetEl = me.el;
  me.dirtyCount = 0;
  if ('attributes' in me) {
    targetEl.set(me.attributes);
    delete me.attributes;
  }
  if ('innerHTML' in me) {
    targetEl.innerHTML = me.innerHTML;
    delete me.innerHTML;
  }
  if (state && state.clearBoxWidth) {
    state.clearBoxWidth = 0;
    me.el.setStyle('width', null);
    if (!--state.blocks) {
      me.context.queueItemLayouts(me);
    }
  }
  if (dirty) {
    delete me.dirty;
    me.writeProps(dirty, true);
  }
}, flushAnimations:function() {
  var me = this, animateFrom = me.previousSize, target, animQueue, targetAnim, duration, animateProps, anim, changeCount, j, propsLen, propName, oldValue, newValue, flag;
  if (animateFrom) {
    target = me.target;
    targetAnim = target.getAnimationProps();
    duration = targetAnim.duration;
    animateProps = Ext.Object.getKeys(me.animatePolicy);
    anim = Ext.apply({}, {from:{}, to:{}, duration:duration || Ext.fx.Anim.prototype.duration}, targetAnim);
    for (changeCount = 0, j = 0, propsLen = animateProps.length; j < propsLen; j++) {
      propName = animateProps[j];
      oldValue = animateFrom[propName];
      newValue = me.peek(propName);
      if (oldValue !== newValue && newValue != null) {
        propName = me.translateProps[propName] || propName;
        anim.from[propName] = oldValue;
        anim.to[propName] = newValue;
        ++changeCount;
      }
    }
    if (changeCount) {
      if (me.isCollapsingOrExpanding === 1) {
        target.componentLayout.undoLayout(me);
      } else {
        me.writeProps(anim.from);
      }
      me.el.animate(anim);
      animQueue = Ext.fx.Manager.getFxQueue(me.el.id);
      anim = animQueue[animQueue.length - 1];
      target.$layoutAnim = anim;
      anim.on({afteranimate:function() {
        delete target.$layoutAnim;
        if (target.destroying || target.destroyed) {
          return;
        }
        var flag = me.isCollapsingOrExpanding;
        if (flag === 1) {
          target.componentLayout.redoLayout(me);
          target.afterCollapse(true);
        } else {
          if (flag === 2) {
            target.afterExpand(true);
          }
        }
        if (target.hasListeners.afterlayoutanimation) {
          target.fireEvent('afterlayoutanimation', target);
        }
      }});
    } else {
      flag = me.isCollapsingOrExpanding;
      if (flag === 1) {
        target.afterCollapse(true);
      } else {
        if (flag === 2) {
          target.afterExpand(true);
        }
      }
    }
  }
}, getBorderInfo:function() {
  var me = this, info = me.borderInfo;
  if (!info) {
    me.borderInfo = info = me.checkCache('borderInfo');
  }
  return info;
}, getEl:function(nameOrEl, owner) {
  var me = this, src, el, elContext;
  if (nameOrEl) {
    if (nameOrEl.dom) {
      el = nameOrEl;
    } else {
      src = me.target;
      if (owner) {
        src = owner;
      }
      el = src[nameOrEl];
      if (typeof el === 'function') {
        el = el.call(src);
        if (el === me.el) {
          return this;
        }
      }
    }
    if (el) {
      elContext = me.context.getEl(me, el);
    }
  }
  return elContext || null;
}, getFrameInfo:function() {
  var me = this, info = me.frameInfo, framing, border;
  if (!info) {
    framing = me.framing;
    border = me.getBorderInfo();
    me.frameInfo = info = framing ? {top:framing.top + border.top, right:framing.right + border.right, bottom:framing.bottom + border.bottom, left:framing.left + border.left, width:framing.width + border.width, height:framing.height + border.height} : border;
  }
  return info;
}, getMarginInfo:function() {
  var me = this, info = me.marginInfo, comp, manageMargins, ownerLayout, ownerLayoutId;
  if (!info) {
    if (!me.wrapsComponent) {
      info = me.checkCache('marginInfo');
    } else {
      comp = me.target;
      ownerLayout = comp.ownerLayout;
      ownerLayoutId = ownerLayout ? ownerLayout.id : null;
      manageMargins = ownerLayout && ownerLayout.manageMargins;
      info = comp.margin$;
      if (info && info.ownerId !== ownerLayoutId) {
        info = null;
      }
      if (!info) {
        info = me.parseMargins(comp, comp.margin) || me.checkCache('marginInfo');
        if (manageMargins) {
          me.setProp('margin-top', 0);
          me.setProp('margin-right', 0);
          me.setProp('margin-bottom', 0);
          me.setProp('margin-left', 0);
        }
        info.ownerId = ownerLayoutId;
        comp.margin$ = info;
      }
      info.width = info.left + info.right;
      info.height = info.top + info.bottom;
    }
    me.marginInfo = info;
  }
  return info;
}, clearMarginCache:function() {
  delete this.marginInfo;
  delete this.target.margin$;
}, getPaddingInfo:function() {
  var me = this, info = me.paddingInfo;
  if (!info) {
    me.paddingInfo = info = me.checkCache('paddingInfo');
  }
  return info;
}, getProp:function(propName) {
  var me = this, result = me.props[propName];
  me.addTrigger(propName);
  return result;
}, getDomProp:function(propName) {
  var me = this, result = me.dirty && propName in me.dirty ? undefined : me.props[propName];
  me.addTrigger(propName, true);
  return result;
}, getStyle:function(styleName) {
  var me = this, styles = me.styles, info, value;
  if (styleName in styles) {
    value = styles[styleName];
  } else {
    info = me.styleInfo[styleName];
    value = me.el.getStyle(styleName);
    if (info && info.parseInt) {
      value = parseInt(value, 10) || 0;
    }
    styles[styleName] = value;
  }
  return value;
}, getStyles:function(styleNames, altNames) {
  var me = this, styleCache = me.styles, values = {}, hits = 0, n = styleNames.length, i, missing, missingAltNames, name, info, styleInfo, styles, value;
  altNames = altNames || styleNames;
  for (i = 0; i < n; ++i) {
    name = styleNames[i];
    if (name in styleCache) {
      values[altNames[i]] = styleCache[name];
      ++hits;
      if (i && hits === 1) {
        missing = styleNames.slice(0, i);
        missingAltNames = altNames.slice(0, i);
      }
    } else {
      if (hits) {
        (missing || (missing = [])).push(name);
        (missingAltNames || (missingAltNames = [])).push(altNames[i]);
      }
    }
  }
  if (hits < n) {
    missing = missing || styleNames;
    missingAltNames = missingAltNames || altNames;
    styleInfo = me.styleInfo;
    styles = me.el.getStyle(missing);
    for (i = missing.length; i--;) {
      name = missing[i];
      info = styleInfo[name];
      value = styles[name];
      if (info && info.parseInt) {
        value = parseInt(value, 10) || 0;
      }
      values[missingAltNames[i]] = value;
      styleCache[name] = value;
    }
  }
  return values;
}, hasProp:function(propName) {
  return this.getProp(propName) != null;
}, hasDomProp:function(propName) {
  return this.getDomProp(propName) != null;
}, invalidate:function(options) {
  this.context.queueInvalidate(this, options);
}, markDirty:function() {
  if (++this.dirtyCount === 1) {
    this.context.queueFlush(this);
  }
}, onBoxMeasured:function() {
  var boxParent = this.boxParent, state = this.state;
  if (boxParent && boxParent.widthModel.shrinkWrap && !state.boxMeasured && this.measuresBox) {
    state.boxMeasured = 1;
    boxParent.boxChildMeasured();
  }
}, parseMargins:function(comp, margins) {
  if (margins === true) {
    margins = 5;
  }
  var type = typeof margins, ret;
  if (type === 'string' || type === 'number') {
    ret = comp.parseBox(margins);
  } else {
    if (margins) {
      ret = {top:0, right:0, bottom:0, left:0};
      if (margins) {
        margins = Ext.apply(ret, comp.parseBox(margins));
      }
    }
  }
  return ret;
}, peek:function(propName) {
  return this.props[propName];
}, recalculateSizeModel:function() {
  var me = this, target = me.target, componentLayout = target.componentLayout, ownerCtContext = me.ownerCtContext, oldContext = componentLayout.ownerContext, sizeModel;
  componentLayout.ownerContext = null;
  me.sizeModel = sizeModel = target.getSizeModel(ownerCtContext && ownerCtContext.widthModel.pairsByHeightOrdinal[ownerCtContext.heightModel.ordinal]);
  me.widthModel = sizeModel.width;
  me.heightModel = sizeModel.height;
  if (oldContext) {
    componentLayout.ownerContext = me;
  }
}, recoverProp:function(propName, oldProps, oldDirty) {
  var me = this, props = me.props, dirty;
  if (propName in oldProps) {
    props[propName] = oldProps[propName];
    if (oldDirty && propName in oldDirty) {
      dirty = me.dirty || (me.dirty = {});
      dirty[propName] = oldDirty[propName];
    }
  }
}, redo:function(deep) {
  var me = this, items, len, i;
  me.revertProps(me.props);
  if (deep && me.wrapsComponent) {
    if (me.childItems) {
      for (i = 0, items = me.childItems, len = items.length; i < len; i++) {
        items[i].redo(deep);
      }
    }
    for (i = 0, items = me.children, len = items.length; i < len; i++) {
      items[i].redo();
    }
  }
}, removeEl:function(nameOrEl, owner) {
  var me = this, src, el;
  if (nameOrEl) {
    if (nameOrEl.dom) {
      el = nameOrEl;
    } else {
      src = me.target;
      if (owner) {
        src = owner;
      }
      el = src[nameOrEl];
      if (typeof el === 'function') {
        el = el.call(src);
        if (el === me.el) {
          return this;
        }
      }
    }
    if (el) {
      me.context.removeEl(el, me);
    }
  }
}, revertProps:function(props) {
  var name, flushed = this.flushedProps, reverted = {};
  for (name in props) {
    if (flushed.hasOwnProperty(name)) {
      reverted[name] = props[name];
    }
  }
  this.writeProps(reverted);
}, setAttribute:function(name, value) {
  var me = this;
  if (!me.attributes) {
    me.attributes = {};
  }
  me.attributes[name] = value;
  me.markDirty();
}, setBox:function(box) {
  var me = this;
  if ('left' in box) {
    me.setProp('x', box.left);
  }
  if ('top' in box) {
    me.setProp('y', box.top);
  }
  me.setSize(box.width, box.height);
}, setContentHeight:function(height, measured) {
  if (!measured && this.hasRawContent) {
    return 1;
  }
  return this.setProp('contentHeight', height);
}, setContentWidth:function(width, measured) {
  if (!measured && this.hasRawContent) {
    return 1;
  }
  return this.setProp('contentWidth', width);
}, setContentSize:function(width, height, measured) {
  return this.setContentWidth(width, measured) + this.setContentHeight(height, measured) === 2;
}, setProp:function(propName, value, dirty) {
  var me = this, valueType = typeof value, info;
  if (valueType === 'undefined' || valueType === 'number' && isNaN(value)) {
    return 0;
  }
  if (me.props[propName] === value) {
    return 1;
  }
  me.props[propName] = value;
  ++me.context.progressCount;
  if (dirty === false) {
    me.fireTriggers('domTriggers', propName);
    me.clearBlocks('domBlocks', propName);
  } else {
    info = me.styleInfo[propName];
    if (info) {
      if (!me.dirty) {
        me.dirty = {};
      }
      me.dirty[propName] = value;
      me.markDirty();
    }
  }
  me.fireTriggers('triggers', propName);
  me.clearBlocks('blocks', propName);
  return 1;
}, setHeight:function(height, dirty) {
  var me = this, comp = me.target, ownerCtContext = me.ownerCtContext, frameBody, frameInfo, min, oldHeight, rem;
  if (height < 0) {
    height = 0;
  }
  if (!me.wrapsComponent) {
    if (!me.setProp('height', height, dirty)) {
      return NaN;
    }
  } else {
    min = me.collapsedVert ? 0 : comp.minHeight || 0;
    height = Ext.Number.constrain(height, min, comp.maxHeight);
    oldHeight = me.props.height;
    if (!me.setProp('height', height, dirty)) {
      return NaN;
    }
    if (ownerCtContext && !me.isComponentChild && isNaN(oldHeight)) {
      rem = --ownerCtContext.remainingChildDimensions;
      if (!rem) {
        ownerCtContext.setProp('containerChildrenSizeDone', true);
      }
    }
    frameBody = me.frameBodyContext;
    if (frameBody) {
      frameInfo = me.getFrameInfo();
      frameBody[me.el.vertical ? 'setWidth' : 'setHeight'](height - frameInfo.height, dirty);
    }
  }
  return height;
}, setWidth:function(width, dirty) {
  var me = this, comp = me.target, ownerCtContext = me.ownerCtContext, frameBody, frameInfo, min, oldWidth, rem;
  if (width < 0) {
    width = 0;
  }
  if (!me.wrapsComponent) {
    if (!me.setProp('width', width, dirty)) {
      return NaN;
    }
  } else {
    min = me.collapsedHorz ? 0 : comp.minWidth || 0;
    width = Ext.Number.constrain(width, min, comp.maxWidth);
    oldWidth = me.props.width;
    if (!me.setProp('width', width, dirty)) {
      return NaN;
    }
    if (ownerCtContext && !me.isComponentChild && isNaN(oldWidth)) {
      rem = --ownerCtContext.remainingChildDimensions;
      if (!rem) {
        ownerCtContext.setProp('containerChildrenSizeDone', true);
      }
    }
    frameBody = me.frameBodyContext;
    if (frameBody) {
      frameInfo = me.getFrameInfo();
      frameBody.setWidth(width - frameInfo.width, dirty);
    }
  }
  return width;
}, setSize:function(width, height, dirty) {
  this.setWidth(width, dirty);
  this.setHeight(height, dirty);
}, translateProps:{x:'left', y:'top'}, undo:function(deep) {
  var me = this, items, len, i;
  me.revertProps(me.lastBox);
  if (deep && me.wrapsComponent) {
    if (me.childItems) {
      for (i = 0, items = me.childItems, len = items.length; i < len; i++) {
        items[i].undo(deep);
      }
    }
    for (i = 0, items = me.children, len = items.length; i < len; i++) {
      items[i].undo();
    }
  }
}, unsetProp:function(propName) {
  var dirty = this.dirty;
  delete this.props[propName];
  if (dirty) {
    delete dirty[propName];
  }
}, writeProps:function(dirtyProps, flushing) {
  if (!(dirtyProps && typeof dirtyProps === 'object')) {
    return;
  }
  var me = this, el = me.el, styles = {}, styleCount = 0, styleInfo = me.styleInfo, info, propName, numericValue, width = dirtyProps.width, height = dirtyProps.height, target = me.target, hasWidth, hasHeight, isAbsolute, scrollbarSize, style, targetEl, scroller;
  if ('displayed' in dirtyProps) {
    el.setDisplayed(dirtyProps.displayed);
  }
  for (propName in dirtyProps) {
    if (flushing) {
      me.fireTriggers('domTriggers', propName);
      me.clearBlocks('domBlocks', propName);
      me.flushedProps[propName] = 1;
    }
    info = styleInfo[propName];
    if (info && info.dom) {
      if (info.suffix && (numericValue = parseInt(dirtyProps[propName], 10))) {
        styles[propName] = numericValue + info.suffix;
      } else {
        styles[propName] = dirtyProps[propName];
      }
      ++styleCount;
    }
  }
  if ('x' in dirtyProps || 'y' in dirtyProps) {
    if (target.isComponent) {
      target.setPosition(dirtyProps.x, dirtyProps.y);
    } else {
      styleCount += me.addPositionStyles(styles, dirtyProps);
    }
  }
  if ('overflowX' in dirtyProps) {
    scroller = target.getScrollable();
    if (scroller) {
      scroller.setX(dirtyProps.overflowX);
    }
  }
  if ('overflowY' in dirtyProps) {
    if (scroller || (scroller = target.getScrollable())) {
      scroller.setY(dirtyProps.overflowY);
    }
  }
  if (me.wrapsComponent && Ext.isIE9) {
    if ((hasWidth = width !== undefined && me.hasOverflowY) || (hasHeight = height !== undefined && me.hasOverflowX)) {
      isAbsolute = me.isAbsolute;
      if (isAbsolute === undefined) {
        isAbsolute = false;
        targetEl = me.target.getTargetEl();
        style = targetEl.getStyle('position');
        me.isAbsolute = isAbsolute = style === 'absolute';
      }
      if (isAbsolute) {
        scrollbarSize = Ext.getScrollbarSize();
        if (hasWidth) {
          width = parseInt(width, 10) + scrollbarSize.width;
          styles.width = width + 'px';
          ++styleCount;
        }
        if (hasHeight) {
          height = parseInt(height, 10) + scrollbarSize.height;
          styles.height = height + 'px';
          ++styleCount;
        }
      }
    }
  }
  if (styleCount) {
    el.setStyle(styles);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.layout, 'ContextItem'], function() {
  var px = {dom:true, parseInt:true, suffix:'px'}, isDom = {dom:true}, faux = {dom:false};
  this.prototype.styleInfo = {containerChildrenSizeDone:faux, containerLayoutDone:faux, displayed:faux, done:faux, x:faux, y:faux, columnsChanged:faux, rowHeights:faux, viewOverflowY:faux, overflowX:faux, overflowY:faux, left:px, top:px, right:px, bottom:px, width:px, height:px, 'border-top-width':px, 'border-right-width':px, 'border-bottom-width':px, 'border-left-width':px, 'margin-top':px, 'margin-right':px, 'margin-bottom':px, 'margin-left':px, 'padding-top':px, 'padding-right':px, 'padding-bottom':px, 
  'padding-left':px, 'line-height':isDom, display:isDom, clear:isDom};
});
Ext.cmd.derive('Ext.layout.Context', Ext.Base, {remainingLayouts:0, state:0, cycleWatchDog:200, constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  me.items = {};
  me.layouts = {};
  me.blockCount = 0;
  me.cycleCount = 0;
  me.flushCount = 0;
  me.calcCount = 0;
  me.animateQueue = me.newQueue();
  me.completionQueue = me.newQueue();
  me.finalizeQueue = me.newQueue();
  me.finishQueue = me.newQueue();
  me.flushQueue = me.newQueue();
  me.invalidateData = {};
  me.layoutQueue = me.newQueue();
  me.invalidQueue = [];
  me.triggers = {data:{}, dom:{}};
}, callLayout:function(layout, methodName) {
  this.currentLayout = layout;
  layout[methodName](this.getCmp(layout.owner));
}, cancelComponent:function(comp, isChild, isDestroying) {
  var me = this, components = comp, isArray = !comp.isComponent, length = isArray ? components.length : 1, i, k, klen, items, layout, newQueue, oldQueue, entry, temp, ownerCtContext;
  for (i = 0; i < length; ++i) {
    if (isArray) {
      comp = components[i];
    }
    if (isDestroying) {
      if (comp.ownerCt) {
        ownerCtContext = this.items[comp.ownerCt.el.id];
        if (ownerCtContext) {
          Ext.Array.remove(ownerCtContext.childItems, me.getCmp(comp));
        }
      } else {
        if (comp.rendered) {
          me.removeEl(comp.el);
        }
      }
    }
    if (!isChild) {
      oldQueue = me.invalidQueue;
      klen = oldQueue.length;
      if (klen) {
        me.invalidQueue = newQueue = [];
        for (k = 0; k < klen; ++k) {
          entry = oldQueue[k];
          temp = entry.item.target;
          if (temp !== comp && !temp.up(comp)) {
            newQueue.push(entry);
          }
        }
      }
    }
    layout = comp.componentLayout;
    me.cancelLayout(layout);
    if (!comp.destroying) {
      if (layout.getLayoutItems) {
        items = layout.getLayoutItems();
        if (items.length) {
          me.cancelComponent(items, true);
        }
      }
      if (comp.isContainer && !comp.collapsed) {
        layout = comp.layout;
        me.cancelLayout(layout);
        items = layout.getVisibleItems();
        if (items.length) {
          me.cancelComponent(items, true);
        }
      }
    }
  }
}, cancelLayout:function(layout) {
  var me = this;
  me.completionQueue.remove(layout);
  me.finalizeQueue.remove(layout);
  me.finishQueue.remove(layout);
  me.layoutQueue.remove(layout);
  if (layout.running) {
    me.layoutDone(layout);
  }
  layout.ownerContext = null;
}, clearTriggers:function(layout, inDom) {
  var id = layout.id, collection = this.triggers[inDom ? 'dom' : 'data'], triggers = collection && collection[id], length = triggers && triggers.length || 0, i, item, trigger;
  for (i = 0; i < length; ++i) {
    trigger = triggers[i];
    item = trigger.item;
    collection = inDom ? item.domTriggers : item.triggers;
    delete collection[trigger.prop][id];
  }
}, flush:function() {
  var me = this, items = me.flushQueue.clear(), length = items.length, i;
  if (length) {
    ++me.flushCount;
    for (i = 0; i < length; ++i) {
      items[i].flush();
    }
  }
}, flushAnimations:function() {
  var me = this, items = me.animateQueue.clear(), len = items.length, i;
  if (len) {
    for (i = 0; i < len; i++) {
      if (items[i].target.animate !== false) {
        items[i].flushAnimations();
      }
    }
    Ext.fx.Manager.runner();
  }
}, flushInvalidates:function() {
  var me = this, queue = me.invalidQueue, length = queue && queue.length, comp, components, entry, i;
  me.invalidQueue = [];
  if (length) {
    components = [];
    for (i = 0; i < length; ++i) {
      comp = (entry = queue[i]).item.target;
      if (!comp.container.isDetachedBody) {
        components.push(comp);
        if (entry.options) {
          me.invalidateData[comp.id] = entry.options;
        }
      }
    }
    me.invalidate(components, null);
  }
}, flushLayouts:function(queueName, methodName, dontClear) {
  var me = this, layouts = dontClear ? me[queueName].items : me[queueName].clear(), length = layouts.length, i, layout;
  if (length) {
    for (i = 0; i < length; ++i) {
      layout = layouts[i];
      if (!layout.running) {
        me.callLayout(layout, methodName);
      }
    }
    me.currentLayout = null;
  }
}, getCmp:function(cmp) {
  return this.getItem(cmp, cmp.el);
}, getEl:function(parent, el) {
  var item = this.getItem(el, el, parent);
  if (!item.parent) {
    item.parent = parent;
    if (parent.children.length) {
      parent.children.push(item);
    } else {
      parent.children = [item];
    }
  }
  return item;
}, getItem:function(target, el, componentContext) {
  var id = el.id, items = this.items, item = items[id] || (items[id] = new Ext.layout.ContextItem({context:this, target:target, el:el, componentContext:componentContext}));
  return item;
}, handleFailure:function() {
  var layouts = this.layouts, layout, key;
  Ext.failedLayouts = (Ext.failedLayouts || 0) + 1;
  for (key in layouts) {
    layout = layouts[key];
    if (layouts.hasOwnProperty(key)) {
      layout.running = false;
      layout.ownerContext = null;
    }
  }
}, invalidate:function(components, full) {
  var me = this, isArray = !components.isComponent, containerLayoutDone, ownerLayout, firstTime, i, comp, item, items, length, componentLayout, layout, invalidateOptions, token, skipLayout;
  for (i = 0, length = isArray ? components.length : 1; i < length; ++i) {
    comp = isArray ? components[i] : components;
    if (comp.rendered && !comp.hidden) {
      ownerLayout = comp.ownerLayout;
      componentLayout = comp.componentLayout;
      skipLayout = false;
      if ((!ownerLayout || !ownerLayout.needsItemSize) && comp.liquidLayout) {
        skipLayout = true;
      }
      if (!skipLayout || ownerLayout && ownerLayout.setsItemSize) {
        item = me.getCmp(comp);
        firstTime = !item.state;
        layout = comp.isContainer && !comp.collapsed ? comp.layout : null;
        invalidateOptions = me.invalidateData[item.id];
        delete me.invalidateData[item.id];
        token = item.init(full, invalidateOptions);
      }
      if (skipLayout) {
        continue;
      }
      if (invalidateOptions) {
        me.processInvalidate(invalidateOptions, item, 'before');
      }
      if (componentLayout.beforeLayoutCycle) {
        componentLayout.beforeLayoutCycle(item);
      }
      if (layout && layout.beforeLayoutCycle) {
        layout.beforeLayoutCycle(item);
      }
      token = item.initContinue(token);
      containerLayoutDone = true;
      if (componentLayout.getLayoutItems) {
        componentLayout.renderChildren();
        items = componentLayout.getLayoutItems();
        if (items.length) {
          me.invalidate(items, true);
        }
      }
      if (layout) {
        containerLayoutDone = false;
        layout.renderChildren();
        if (layout.needsItemSize || layout.activeItemCount) {
          items = layout.getVisibleItems();
          if (items.length) {
            me.invalidate(items, true);
          }
        }
      }
      item.initDone(containerLayoutDone);
      me.resetLayout(componentLayout, item, firstTime);
      if (layout) {
        me.resetLayout(layout, item, firstTime);
      }
      item.initAnimation();
      if (invalidateOptions) {
        me.processInvalidate(invalidateOptions, item, 'after');
      }
    }
  }
  me.currentLayout = null;
}, isDescendant:function(ancestor, descendant) {
  if (ancestor.isContainer) {
    for (var c = descendant.ownerCt; c; c = c.ownerCt) {
      if (c === ancestor) {
        return true;
      }
    }
  }
  return false;
}, layoutDone:function(layout) {
  var ownerContext = layout.ownerContext;
  layout.running = false;
  if (layout.isComponentLayout) {
    if (ownerContext.measuresBox) {
      ownerContext.onBoxMeasured();
    }
    ownerContext.setProp('done', true);
  } else {
    ownerContext.setProp('containerLayoutDone', true);
  }
  --this.remainingLayouts;
  ++this.progressCount;
}, newQueue:function() {
  return new Ext.util.Queue;
}, processInvalidate:function(options, item, name) {
  if (options[name]) {
    var me = this, currentLayout = me.currentLayout;
    me.currentLayout = options.layout || null;
    options[name](item, options);
    me.currentLayout = currentLayout;
  }
}, queueAnimation:function(item) {
  this.animateQueue.add(item);
}, queueCompletion:function(layout) {
  this.completionQueue.add(layout);
}, queueFinalize:function(layout) {
  this.finalizeQueue.add(layout);
}, queueFlush:function(item, replace) {
  this.flushQueue.add(item, replace);
}, chainFns:function(oldOptions, newOptions, funcName) {
  var me = this, oldLayout = oldOptions.layout, newLayout = newOptions.layout, oldFn = oldOptions[funcName], newFn = newOptions[funcName];
  return function(contextItem) {
    var prev = me.currentLayout;
    if (oldFn) {
      me.currentLayout = oldLayout;
      oldFn.call(oldOptions.scope || oldOptions, contextItem, oldOptions);
    }
    me.currentLayout = newLayout;
    newFn.call(newOptions.scope || newOptions, contextItem, newOptions);
    me.currentLayout = prev;
  };
}, purgeInvalidates:function() {
  var me = this, newQueue = [], oldQueue = me.invalidQueue, oldLength = oldQueue.length, oldIndex, newIndex, newEntry, newComp, oldEntry, oldComp, keep;
  for (oldIndex = 0; oldIndex < oldLength; ++oldIndex) {
    oldEntry = oldQueue[oldIndex];
    oldComp = oldEntry.item.target;
    keep = true;
    for (newIndex = newQueue.length; newIndex--;) {
      newEntry = newQueue[newIndex];
      newComp = newEntry.item.target;
      if (oldComp.isLayoutChild(newComp)) {
        keep = false;
        break;
      }
      if (newComp.isLayoutChild(oldComp)) {
        Ext.Array.erase(newQueue, newIndex, 1);
      }
    }
    if (keep) {
      newQueue.push(oldEntry);
    }
  }
  me.invalidQueue = newQueue;
}, queueInvalidate:function(item, options) {
  var me = this, newQueue = [], oldQueue = me.invalidQueue, index = oldQueue.length, comp, old, oldComp, oldOptions, oldState;
  if (item.isComponent) {
    comp = item;
    item = me.items[comp.el.id];
    if (item) {
      item.recalculateSizeModel();
    } else {
      item = me.getCmp(comp);
    }
  } else {
    comp = item.target;
  }
  item.invalid = true;
  while (index--) {
    old = oldQueue[index];
    oldComp = old.item.target;
    if (!comp.isFloating && comp.up(oldComp)) {
      return;
    }
    if (oldComp === comp) {
      if (!(oldOptions = old.options)) {
        old.options = options;
      } else {
        if (options) {
          if (options.widthModel) {
            oldOptions.widthModel = options.widthModel;
          }
          if (options.heightModel) {
            oldOptions.heightModel = options.heightModel;
          }
          if (!(oldState = oldOptions.state)) {
            oldOptions.state = options.state;
          } else {
            if (options.state) {
              Ext.apply(oldState, options.state);
            }
          }
          if (options.before) {
            oldOptions.before = me.chainFns(oldOptions, options, 'before');
          }
          if (options.after) {
            oldOptions.after = me.chainFns(oldOptions, options, 'after');
          }
        }
      }
      return;
    }
    if (!oldComp.isLayoutChild(comp)) {
      newQueue.push(old);
    }
  }
  newQueue.push({item:item, options:options});
  me.invalidQueue = newQueue;
}, queueItemLayouts:function(item) {
  var comp = item.isComponent ? item : item.target, layout = comp.componentLayout;
  if (!layout.pending && !layout.invalid && !layout.done) {
    this.queueLayout(layout);
  }
  layout = comp.layout;
  if (layout && !layout.pending && !layout.invalid && !layout.done && !comp.collapsed) {
    this.queueLayout(layout);
  }
}, queueLayout:function(layout) {
  this.layoutQueue.add(layout);
  layout.pending = true;
}, removeEl:function(el, parent) {
  var id = el.id, children = parent ? parent.children : null, items = this.items;
  if (children) {
    Ext.Array.remove(children, items[id]);
  }
  delete items[id];
}, resetLayout:function(layout, ownerContext, firstTime) {
  var me = this;
  me.currentLayout = layout;
  layout.done = false;
  layout.pending = true;
  layout.firedTriggers = 0;
  me.layoutQueue.add(layout);
  if (firstTime) {
    me.layouts[layout.id] = layout;
    layout.running = true;
    if (layout.finishedLayout) {
      me.finishQueue.add(layout);
    }
    ++me.remainingLayouts;
    ++layout.layoutCount;
    layout.ownerContext = ownerContext;
    layout.beginCount = 0;
    layout.blockCount = 0;
    layout.calcCount = 0;
    layout.triggerCount = 0;
    if (!layout.initialized) {
      layout.initLayout();
    }
    layout.beginLayout(ownerContext);
  } else {
    ++layout.beginCount;
    if (!layout.running) {
      ++me.remainingLayouts;
      layout.running = true;
      layout.ownerContext = ownerContext;
      if (layout.isComponentLayout) {
        ownerContext.unsetProp('done');
      }
      me.completionQueue.remove(layout);
      me.finalizeQueue.remove(layout);
    }
  }
  layout.beginLayoutCycle(ownerContext, firstTime);
}, run:function() {
  var me = this, flushed = false, watchDog = me.cycleWatchDog;
  me.purgeInvalidates();
  me.flushInvalidates();
  me.state = 1;
  me.totalCount = me.layoutQueue.getCount();
  me.flush();
  while ((me.remainingLayouts || me.invalidQueue.length) && watchDog--) {
    if (me.invalidQueue.length) {
      me.flushInvalidates();
    }
    if (me.runCycle()) {
      flushed = false;
    } else {
      if (!flushed) {
        me.flush();
        flushed = true;
        me.flushLayouts('completionQueue', 'completeLayout');
      } else {
        if (!me.invalidQueue.length) {
          me.state = 2;
          break;
        }
      }
    }
    if (!(me.remainingLayouts || me.invalidQueue.length)) {
      me.flush();
      me.flushLayouts('completionQueue', 'completeLayout');
      me.flushLayouts('finalizeQueue', 'finalizeLayout');
    }
  }
  return me.runComplete();
}, runComplete:function() {
  var me = this;
  me.state = 2;
  if (me.remainingLayouts) {
    me.handleFailure();
    return false;
  }
  me.flush();
  me.flushLayouts('finishQueue', 'finishedLayout', true);
  me.flushLayouts('finishQueue', 'notifyOwner');
  me.flush();
  me.flushAnimations();
  return true;
}, runCycle:function() {
  var me = this, layouts = me.layoutQueue.clear(), length = layouts.length, i;
  ++me.cycleCount;
  me.progressCount = 0;
  for (i = 0; i < length; ++i) {
    me.runLayout(me.currentLayout = layouts[i]);
  }
  me.currentLayout = null;
  return me.progressCount > 0;
}, runLayout:function(layout) {
  var me = this, ownerContext = me.getCmp(layout.owner);
  layout.pending = false;
  if (ownerContext.state.blocks) {
    return;
  }
  layout.done = true;
  ++layout.calcCount;
  ++me.calcCount;
  layout.calculate(ownerContext);
  if (layout.done) {
    me.layoutDone(layout);
    if (layout.completeLayout) {
      me.queueCompletion(layout);
    }
    if (layout.finalizeLayout) {
      me.queueFinalize(layout);
    }
  } else {
    if (!layout.pending && !layout.invalid && !(layout.blockCount + layout.triggerCount - layout.firedTriggers)) {
      me.queueLayout(layout);
    }
  }
}, setItemSize:function(item, width, height) {
  var items = item, len = 1, contextItem, i;
  if (item.isComposite) {
    items = item.elements;
    len = items.length;
    item = items[0];
  } else {
    if (!item.dom && !item.el) {
      len = items.length;
      item = items[0];
    }
  }
  for (i = 0; i < len;) {
    contextItem = this.get(item);
    contextItem.setSize(width, height);
    item = items[++i];
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.layout, 'Context'], 0);
Ext.cmd.derive('Ext.layout.component.Body', Ext.layout.component.Auto, {type:'body', beginLayout:function(ownerContext) {
  Ext.layout.component.Auto.prototype.beginLayout.apply(this, arguments);
  ownerContext.bodyContext = ownerContext.getEl('body');
}, beginLayoutCycle:function(ownerContext, firstCycle) {
  var me = this, lastWidthModel = me.lastWidthModel, lastHeightModel = me.lastHeightModel, body = me.owner.body;
  Ext.layout.component.Auto.prototype.beginLayoutCycle.apply(this, arguments);
  if (lastWidthModel && lastWidthModel.fixed && ownerContext.widthModel.shrinkWrap) {
    body.setWidth(null);
  }
  if (lastHeightModel && lastHeightModel.fixed && ownerContext.heightModel.shrinkWrap) {
    body.setHeight(null);
  }
}, calculateOwnerHeightFromContentHeight:function(ownerContext, contentHeight) {
  var height = Ext.layout.component.Auto.prototype.calculateOwnerHeightFromContentHeight.apply(this, arguments);
  if (ownerContext.targetContext !== ownerContext) {
    height += ownerContext.getPaddingInfo().height;
  }
  return height;
}, calculateOwnerWidthFromContentWidth:function(ownerContext, contentWidth) {
  var width = Ext.layout.component.Auto.prototype.calculateOwnerWidthFromContentWidth.apply(this, arguments);
  if (ownerContext.targetContext !== ownerContext) {
    width += ownerContext.getPaddingInfo().width;
  }
  return width;
}, measureContentWidth:function(ownerContext) {
  return ownerContext.bodyContext.setWidth(ownerContext.bodyContext.el.dom.offsetWidth, false);
}, measureContentHeight:function(ownerContext) {
  return ownerContext.bodyContext.setHeight(ownerContext.bodyContext.el.dom.offsetHeight, false);
}, publishInnerHeight:function(ownerContext, height) {
  var innerHeight = height - ownerContext.getFrameInfo().height, targetContext = ownerContext.targetContext;
  if (targetContext !== ownerContext) {
    innerHeight -= ownerContext.getPaddingInfo().height;
  }
  return ownerContext.bodyContext.setHeight(innerHeight, !ownerContext.heightModel.natural);
}, publishInnerWidth:function(ownerContext, width) {
  var innerWidth = width - ownerContext.getFrameInfo().width, targetContext = ownerContext.targetContext;
  if (targetContext !== ownerContext) {
    innerWidth -= ownerContext.getPaddingInfo().width;
  }
  ownerContext.bodyContext.setWidth(innerWidth, !ownerContext.widthModel.natural);
}}, 0, 0, 0, 0, ['layout.body'], 0, [Ext.layout.component, 'Body'], 0);
Ext.cmd.derive('Ext.resizer.BorderSplitter', Ext.resizer.Splitter, {collapseTarget:null, getTrackerConfig:function() {
  var trackerConfig = Ext.resizer.Splitter.prototype.getTrackerConfig.call(this);
  trackerConfig.xclass = 'Ext.resizer.BorderSplitterTracker';
  return trackerConfig;
}, onTargetCollapse:function(target) {
  Ext.resizer.Splitter.prototype.onTargetCollapse.call(this, target);
  if (this.performCollapse !== false && target.collapseMode == 'mini') {
    target.addCls(target.baseCls + '-' + target.collapsedCls + '-mini');
  }
}, onTargetExpand:function(target) {
  Ext.resizer.Splitter.prototype.onTargetExpand.call(this, target);
  if (this.performCollapse !== false && target.collapseMode == 'mini') {
    target.removeCls(target.baseCls + '-' + target.collapsedCls + '-mini');
  }
}}, 0, ['bordersplitter'], ['component', 'box', 'splitter', 'bordersplitter'], {'component':true, 'box':true, 'splitter':true, 'bordersplitter':true}, ['widget.bordersplitter'], 0, [Ext.resizer, 'BorderSplitter'], 0);
Ext.cmd.derive('Ext.layout.container.Border', Ext.layout.container.Container, {alternateClassName:'Ext.layout.BorderLayout', targetCls:'x-border-layout-ct', itemCls:['x-border-item', 'x-box-item'], type:'border', isBorderLayout:true, padding:undefined, percentageRe:/(\d+)%/, horzPositionProp:'left', padOnContainerProp:'left', padNotOnContainerProp:'right', axisProps:{horz:{borderBegin:'west', borderEnd:'east', horizontal:true, posProp:'x', sizeProp:'width', sizePropCap:'Width'}, vert:{borderBegin:'north', 
borderEnd:'south', horizontal:false, posProp:'y', sizeProp:'height', sizePropCap:'Height'}}, centerRegion:null, manageMargins:true, panelCollapseAnimate:true, panelCollapseMode:'placeholder', regionWeights:{north:20, south:10, center:0, west:-10, east:-20}, beginAxis:function(ownerContext, regions, name) {
  var me = this, props = me.axisProps[name], isVert = !props.horizontal, sizeProp = props.sizeProp, totalFlex = 0, childItems = ownerContext.childItems, length = childItems.length, center, i, childContext, centerFlex, comp, region, match, size, type, target, placeholder;
  for (i = 0; i < length; ++i) {
    childContext = childItems[i];
    comp = childContext.target;
    childContext.layoutPos = {};
    if (comp.region) {
      childContext.region = region = comp.region;
      childContext.isCenter = comp.isCenter;
      childContext.isHorz = comp.isHorz;
      childContext.isVert = comp.isVert;
      childContext.weight = comp.weight || me.regionWeights[region] || 0;
      comp.weight = childContext.weight;
      regions[comp.id] = childContext;
      if (comp.isCenter) {
        center = childContext;
        centerFlex = comp.flex;
        ownerContext.centerRegion = center;
        continue;
      }
      if (isVert !== childContext.isVert) {
        continue;
      }
      childContext.reverseWeighting = region === props.borderEnd;
      size = comp[sizeProp];
      type = typeof size;
      if (!comp.collapsed) {
        if (type === 'string' && (match = me.percentageRe.exec(size))) {
          childContext.percentage = parseInt(match[1], 10);
        } else {
          if (comp.flex) {
            totalFlex += childContext.flex = comp.flex;
          }
        }
      }
    }
  }
  if (center) {
    target = center.target;
    if (placeholder = target.placeholderFor) {
      if (!centerFlex && isVert === placeholder.collapsedVertical()) {
        centerFlex = 0;
        center.collapseAxis = name;
      }
    } else {
      if (target.collapsed && isVert === target.collapsedVertical()) {
        centerFlex = 0;
        center.collapseAxis = name;
      }
    }
  }
  if (centerFlex == null) {
    centerFlex = 1;
  }
  totalFlex += centerFlex;
  return Ext.apply({before:isVert ? 'top' : 'left', totalFlex:totalFlex}, props);
}, beginLayout:function(ownerContext) {
  var me = this, items = me.getLayoutItems(), pad = me.padding, type = typeof pad, padOnContainer = false, childContext, item, length, i, regions, collapseTarget, doShow, hidden, region;
  if (pad) {
    if (type === 'string' || type === 'number') {
      pad = Ext.util.Format.parseBox(pad);
    }
  } else {
    pad = ownerContext.getEl('getTargetEl').getPaddingInfo();
    padOnContainer = true;
  }
  ownerContext.outerPad = pad;
  ownerContext.padOnContainer = padOnContainer;
  for (i = 0, length = items.length; i < length; ++i) {
    item = items[i];
    collapseTarget = me.getSplitterTarget(item);
    if (collapseTarget) {
      doShow = undefined;
      hidden = !!item.hidden;
      if (!collapseTarget.split) {
        if (collapseTarget.isCollapsingOrExpanding) {
          doShow = !!collapseTarget.collapsed;
        }
      } else {
        if (hidden !== collapseTarget.hidden) {
          doShow = !collapseTarget.hidden;
        }
      }
      if (doShow) {
        item.show();
      } else {
        if (doShow === false) {
          item.hide();
        }
      }
    }
  }
  Ext.layout.container.Container.prototype.beginLayout.apply(this, arguments);
  items = ownerContext.childItems;
  length = items.length;
  regions = {};
  ownerContext.borderAxisHorz = me.beginAxis(ownerContext, regions, 'horz');
  ownerContext.borderAxisVert = me.beginAxis(ownerContext, regions, 'vert');
  for (i = 0; i < length; ++i) {
    childContext = items[i];
    collapseTarget = me.getSplitterTarget(childContext.target);
    if (collapseTarget) {
      region = regions[collapseTarget.id];
      if (!region) {
        region = ownerContext.getEl(collapseTarget.el, me);
        region.region = collapseTarget.region;
      }
      childContext.collapseTarget = collapseTarget = region;
      childContext.weight = collapseTarget.weight;
      childContext.reverseWeighting = collapseTarget.reverseWeighting;
      collapseTarget.splitter = childContext;
      childContext.isHorz = collapseTarget.isHorz;
      childContext.isVert = collapseTarget.isVert;
    }
  }
  me.sortWeightedItems(items, 'reverseWeighting');
  me.setupSplitterNeighbors(items);
}, calculate:function(ownerContext) {
  var me = this, containerSize = me.getContainerSize(ownerContext), childItems = ownerContext.childItems, length = childItems.length, horz = ownerContext.borderAxisHorz, vert = ownerContext.borderAxisVert, pad = ownerContext.outerPad, padOnContainer = ownerContext.padOnContainer, i, childContext, childMargins, size, horzPercentTotal, vertPercentTotal;
  horz.begin = pad[me.padOnContainerProp];
  vert.begin = pad.top;
  horzPercentTotal = horz.end = horz.flexSpace = containerSize.width + (padOnContainer ? pad[me.padOnContainerProp] : -pad[me.padNotOnContainerProp]);
  vertPercentTotal = vert.end = vert.flexSpace = containerSize.height + (padOnContainer ? pad.top : -pad.bottom);
  for (i = 0; i < length; ++i) {
    childContext = childItems[i];
    childMargins = childContext.getMarginInfo();
    if (childContext.isHorz || childContext.isCenter) {
      horz.addUnflexed(childMargins.width);
      horzPercentTotal -= childMargins.width;
    }
    if (childContext.isVert || childContext.isCenter) {
      vert.addUnflexed(childMargins.height);
      vertPercentTotal -= childMargins.height;
    }
    if (!childContext.flex && !childContext.percentage) {
      if (childContext.isHorz || childContext.isCenter && childContext.collapseAxis === 'horz') {
        size = childContext.getProp('width');
        horz.addUnflexed(size);
        if (childContext.collapseTarget) {
          horzPercentTotal -= size;
        }
      } else {
        if (childContext.isVert || childContext.isCenter && childContext.collapseAxis === 'vert') {
          size = childContext.getProp('height');
          vert.addUnflexed(size);
          if (childContext.collapseTarget) {
            vertPercentTotal -= size;
          }
        }
      }
    }
  }
  for (i = 0; i < length; ++i) {
    childContext = childItems[i];
    childMargins = childContext.getMarginInfo();
    if (childContext.percentage) {
      if (childContext.isHorz) {
        size = Math.ceil(horzPercentTotal * childContext.percentage / 100);
        size = childContext.setWidth(size);
        horz.addUnflexed(size);
      } else {
        if (childContext.isVert) {
          size = Math.ceil(vertPercentTotal * childContext.percentage / 100);
          size = childContext.setHeight(size);
          vert.addUnflexed(size);
        }
      }
    }
  }
  for (i = 0; i < length; ++i) {
    childContext = childItems[i];
    if (!childContext.isCenter) {
      me.calculateChildAxis(childContext, horz);
      me.calculateChildAxis(childContext, vert);
    }
  }
  if (me.finishAxis(ownerContext, vert) + me.finishAxis(ownerContext, horz) < 2) {
    me.done = false;
  } else {
    me.finishPositions(childItems);
  }
}, calculateChildAxis:function(childContext, axis) {
  var collapseTarget = childContext.collapseTarget, setSizeMethod = 'set' + axis.sizePropCap, sizeProp = axis.sizeProp, childMarginSize = childContext.getMarginInfo()[sizeProp], region, isBegin, flex, pos, size;
  if (collapseTarget) {
    region = collapseTarget.region;
  } else {
    region = childContext.region;
    flex = childContext.flex;
  }
  isBegin = region === axis.borderBegin;
  if (!isBegin && region !== axis.borderEnd) {
    childContext[setSizeMethod](axis.end - axis.begin - childMarginSize);
    pos = axis.begin;
  } else {
    if (flex) {
      size = Math.ceil(axis.flexSpace * (flex / axis.totalFlex));
      size = childContext[setSizeMethod](size);
    } else {
      if (childContext.percentage) {
        size = childContext.peek(sizeProp);
      } else {
        size = childContext.getProp(sizeProp);
      }
    }
    size += childMarginSize;
    if (isBegin) {
      pos = axis.begin;
      axis.begin += size;
    } else {
      axis.end = pos = axis.end - size;
    }
  }
  childContext.layoutPos[axis.posProp] = pos;
}, eachItem:function(region, fn, scope) {
  var me = this, items = me.getLayoutItems(), i = 0, item;
  if (Ext.isFunction(region)) {
    fn = region;
    scope = fn;
  }
  for (i; i < items.length; i++) {
    item = items[i];
    if (!region || item.region === region) {
      if (fn.call(scope, item) === false) {
        break;
      }
    }
  }
}, finishAxis:function(ownerContext, axis) {
  var size = axis.end - axis.begin, center = ownerContext.centerRegion;
  if (center) {
    center['set' + axis.sizePropCap](size - center.getMarginInfo()[axis.sizeProp]);
    center.layoutPos[axis.posProp] = axis.begin;
  }
  return Ext.isNumber(size) ? 1 : 0;
}, finishPositions:function(childItems) {
  var length = childItems.length, index, childContext, marginProp = this.horzPositionProp;
  for (index = 0; index < length; ++index) {
    childContext = childItems[index];
    childContext.setProp('x', childContext.layoutPos.x + childContext.marginInfo[marginProp]);
    childContext.setProp('y', childContext.layoutPos.y + childContext.marginInfo.top);
  }
}, getLayoutItems:function() {
  var owner = this.owner, ownerItems = owner && owner.items && owner.items.items || [], length = ownerItems.length, items = [], i = 0, ownerItem, placeholderFor;
  for (; i < length; i++) {
    ownerItem = ownerItems[i];
    placeholderFor = ownerItem.placeholderFor;
    if (ownerItem.hidden || (!ownerItem.floated || ownerItem.isCollapsingOrExpanding === 2) && !(placeholderFor && placeholderFor.isCollapsingOrExpanding === 2)) {
      items.push(ownerItem);
    }
  }
  return items;
}, getPlaceholder:function(comp) {
  return comp.getPlaceholder && comp.getPlaceholder();
}, getMaxWeight:function(region) {
  return this.getMinMaxWeight(region);
}, getMinWeight:function(region) {
  return this.getMinMaxWeight(region, true);
}, getMinMaxWeight:function(region, min) {
  var me = this, weight = null;
  me.eachItem(region, function(item) {
    if (item.hasOwnProperty('weight')) {
      if (weight === null) {
        weight = item.weight;
        return;
      }
      if (min && item.weight < weight || item.weight > weight) {
        weight = item.weight;
      }
    }
  }, this);
  return weight;
}, getSplitterTarget:function(splitter) {
  var collapseTarget = splitter.collapseTarget;
  if (collapseTarget && collapseTarget.collapsed) {
    return collapseTarget.placeholder || collapseTarget;
  }
  return collapseTarget;
}, isItemBoxParent:function(itemContext) {
  return true;
}, isItemShrinkWrap:function(item) {
  return true;
}, insertSplitter:function(item, index, hidden, splitterCfg) {
  var region = item.region, splitter = Ext.apply({xtype:'bordersplitter', collapseTarget:item, id:item.id + '-splitter', hidden:hidden, canResize:item.splitterResize !== false, splitterFor:item, synthetic:true}, splitterCfg), at = index + (region === 'south' || region === 'east' ? 0 : 1);
  if (item.collapseMode === 'mini') {
    splitter.collapsedCls = item.collapsedCls;
  }
  item.splitter = this.owner.add(at, splitter);
}, getMoveAfterIndex:function(after) {
  var index = Ext.layout.container.Container.prototype.getMoveAfterIndex.apply(this, arguments);
  if (after.splitter) {
    index++;
  }
  return index;
}, moveItemBefore:function(item, before) {
  var beforeRegion;
  if (before && before.splitter) {
    beforeRegion = before.region;
    if (beforeRegion === 'south' || beforeRegion === 'east') {
      before = before.splitter;
    }
  }
  return Ext.layout.container.Container.prototype.moveItemBefore.call(this, item, before);
}, onAdd:function(item, index) {
  var me = this, placeholderFor = item.placeholderFor, region = item.region, isCenter, split, hidden, cfg;
  Ext.layout.container.Container.prototype.onAdd.apply(this, arguments);
  if (region) {
    Ext.apply(item, me.regionFlags[region]);
    if (me.owner.isViewport) {
      item.isViewportBorderChild = true;
    }
    if (item.initBorderRegion) {
      item.initBorderRegion();
    }
    isCenter = region === 'center';
    if (isCenter) {
      me.centerRegion = item;
    } else {
      split = item.split;
      hidden = !!item.hidden;
      if (typeof split === 'object') {
        cfg = split;
        split = true;
      }
      if ((item.isHorz || item.isVert) && (split || item.collapseMode === 'mini')) {
        if (item.collapseMode === 'mini' && item.collapsed) {
          hidden = false;
        } else {
          if (!split) {
            hidden = true;
          }
        }
        me.insertSplitter(item, index, hidden, cfg);
      }
    }
    if (!isCenter && !item.hasOwnProperty('collapseMode')) {
      item.collapseMode = me.panelCollapseMode;
    }
    if (!item.hasOwnProperty('animCollapse')) {
      if (item.collapseMode !== 'placeholder') {
        item.animCollapse = false;
      } else {
        item.animCollapse = me.panelCollapseAnimate;
      }
    }
    if (hidden && item.placeholder && item.placeholder.isVisible()) {
      me.owner.insert(index, item.placeholder);
    }
  } else {
    if (placeholderFor) {
      Ext.apply(item, me.regionFlags[placeholderFor.region]);
      item.region = placeholderFor.region;
      item.weight = placeholderFor.weight;
    }
  }
}, onDestroy:function() {
  this.centerRegion = null;
  Ext.layout.container.Container.prototype.onDestroy.call(this);
}, onRemove:function(comp, isDestroying) {
  var me = this, region = comp.region, splitter = comp.splitter, owner = me.owner, destroying = owner.destroying, el;
  if (region) {
    if (comp.isCenter) {
      me.centerRegion = null;
    }
    delete comp.isCenter;
    delete comp.isHorz;
    delete comp.isVert;
    if (splitter && !owner.destroying) {
      owner.doRemove(splitter, true);
    }
    delete comp.splitter;
  }
  Ext.layout.container.Container.prototype.onRemove.apply(this, arguments);
  if (!destroying && !isDestroying && comp.rendered) {
    el = comp.getEl();
    if (el) {
      el.setStyle('top', '');
      el.setStyle(me.horzPositionProp, '');
    }
  }
}, regionMeta:{center:{splitterDelta:0}, north:{splitterDelta:1}, south:{splitterDelta:-1}, west:{splitterDelta:1}, east:{splitterDelta:-1}}, regionFlags:{center:{isCenter:true, isHorz:false, isVert:false}, north:{isCenter:false, isHorz:false, isVert:true, collapseDirection:'top'}, south:{isCenter:false, isHorz:false, isVert:true, collapseDirection:'bottom'}, west:{isCenter:false, isHorz:true, isVert:false, collapseDirection:'left'}, east:{isCenter:false, isHorz:true, isVert:false, collapseDirection:'right'}}, 
setupSplitterNeighbors:function(items) {
  var edgeRegions = {}, length = items.length, touchedRegions = this.touchedRegions, i, j, center, count, edge, comp, region, splitter, touched;
  for (i = 0; i < length; ++i) {
    comp = items[i].target;
    region = comp.region;
    if (comp.isCenter) {
      center = comp;
    } else {
      if (region) {
        touched = touchedRegions[region];
        for (j = 0, count = touched.length; j < count; ++j) {
          edge = edgeRegions[touched[j]];
          if (edge) {
            edge.neighbors.push(comp);
          }
        }
        if (comp.placeholderFor) {
          splitter = comp.placeholderFor.splitter;
        } else {
          splitter = comp.splitter;
        }
        if (splitter) {
          splitter.neighbors = [];
        }
        edgeRegions[region] = splitter;
      }
    }
  }
  if (center) {
    touched = touchedRegions.center;
    for (j = 0, count = touched.length; j < count; ++j) {
      edge = edgeRegions[touched[j]];
      if (edge) {
        edge.neighbors.push(center);
      }
    }
  }
}, touchedRegions:{center:['north', 'south', 'east', 'west'], north:['north', 'east', 'west'], south:['south', 'east', 'west'], east:['east', 'north', 'south'], west:['west', 'north', 'south']}, sizePolicies:{vert:{readsWidth:0, readsHeight:1, setsWidth:1, setsHeight:0}, horz:{readsWidth:1, readsHeight:0, setsWidth:0, setsHeight:1}, flexAll:{readsWidth:0, readsHeight:0, setsWidth:1, setsHeight:1}}, getItemSizePolicy:function(item) {
  var me = this, policies = this.sizePolicies, collapseTarget, size, policy, placeholderFor;
  if (item.isCenter) {
    placeholderFor = item.placeholderFor;
    if (placeholderFor) {
      if (placeholderFor.collapsedVertical()) {
        return policies.vert;
      }
      return policies.horz;
    }
    if (item.collapsed) {
      if (item.collapsedVertical()) {
        return policies.vert;
      }
      return policies.horz;
    }
    return policies.flexAll;
  }
  collapseTarget = item.collapseTarget;
  if (collapseTarget) {
    return collapseTarget.isVert ? policies.vert : policies.horz;
  }
  if (item.region) {
    if (item.isVert) {
      size = item.height;
      policy = policies.vert;
    } else {
      size = item.width;
      policy = policies.horz;
    }
    if (item.flex || typeof size === 'string' && me.percentageRe.test(size)) {
      return policies.flexAll;
    }
    return policy;
  }
  return me.autoSizePolicy;
}}, 0, 0, 0, 0, ['layout.border'], 0, [Ext.layout.container, 'Border', Ext.layout, 'BorderLayout'], function() {
  var methods = {addUnflexed:function(px) {
    this.flexSpace = Math.max(this.flexSpace - px, 0);
  }}, props = this.prototype.axisProps;
  Ext.apply(props.horz, methods);
  Ext.apply(props.vert, methods);
});
Ext.cmd.derive('Ext.layout.container.Card', Ext.layout.container.Fit, {alternateClassName:'Ext.layout.CardLayout', type:'card', hideInactive:true, deferredRender:false, getRenderTree:function() {
  var me = this, activeItem = me.getActiveItem();
  if (activeItem) {
    if (activeItem.hasListeners.beforeactivate && activeItem.fireEvent('beforeactivate', activeItem) === false) {
      activeItem = me.activeItem = me.owner.activeItem = null;
    } else {
      if (activeItem.hasListeners.activate) {
        activeItem.on({boxready:function() {
          activeItem.fireEvent('activate', activeItem);
        }, single:true});
      }
    }
    if (me.deferredRender) {
      if (activeItem) {
        return me.getItemsRenderTree([activeItem]);
      }
    } else {
      return Ext.layout.container.Fit.prototype.getRenderTree.apply(this, arguments);
    }
  }
}, renderChildren:function() {
  var me = this, active = me.getActiveItem();
  if (!me.deferredRender) {
    Ext.layout.container.Fit.prototype.renderChildren.call(this);
  } else {
    if (active) {
      me.renderItems([active], me.getRenderTarget());
    }
  }
}, isValidParent:function(item, target, position) {
  var itemEl = item.el ? item.el.dom : Ext.getDom(item);
  return itemEl && itemEl.parentNode === (target.dom || target) || false;
}, getActiveItem:function() {
  var me = this, item = me.activeItem === undefined ? me.owner && me.owner.activeItem : me.activeItem, result = me.parseActiveItem(item);
  if (result && me.owner.items.indexOf(result) !== -1) {
    me.activeItem = result;
  }
  return result == null ? null : me.activeItem || me.owner.activeItem;
}, parseActiveItem:function(item) {
  var activeItem;
  if (item && item.isComponent) {
    activeItem = item;
  } else {
    if (typeof item === 'number' || item === undefined) {
      activeItem = this.getLayoutItems()[item || 0];
    } else {
      if (item === null) {
        activeItem = null;
      } else {
        activeItem = this.owner.getComponent(item);
      }
    }
  }
  return activeItem;
}, configureItem:function(item) {
  item.setHiddenState(item !== this.getActiveItem());
  Ext.layout.container.Fit.prototype.configureItem.apply(this, arguments);
}, onAdd:function(item, pos) {
  Ext.layout.container.Fit.prototype.onAdd.call(this, item, pos);
  this.setItemHideMode(item);
}, onRemove:function(component) {
  var me = this;
  Ext.layout.container.Fit.prototype.onRemove.call(this, component);
  me.resetItemHideMode(component);
  if (component === me.activeItem) {
    me.activeItem = undefined;
  }
}, getAnimation:function(newCard, owner) {
  var newAnim = (newCard || {}).cardSwitchAnimation;
  if (newAnim === false) {
    return false;
  }
  return newAnim || owner.cardSwitchAnimation;
}, getNext:function() {
  var wrap = arguments[0], items = this.getLayoutItems(), index = Ext.Array.indexOf(items, this.activeItem);
  return items[index + 1] || (wrap ? items[0] : false);
}, next:function() {
  var anim = arguments[0], wrap = arguments[1];
  return this.setActiveItem(this.getNext(wrap), anim);
}, getPrev:function() {
  var wrap = arguments[0], items = this.getLayoutItems(), index = Ext.Array.indexOf(items, this.activeItem);
  return items[index - 1] || (wrap ? items[items.length - 1] : false);
}, prev:function() {
  var anim = arguments[0], wrap = arguments[1];
  return this.setActiveItem(this.getPrev(wrap), anim);
}, setActiveItem:function(newCard) {
  var me = this, owner = me.owner, oldCard = me.activeItem, rendered = owner.rendered, newIndex, focusNewCard;
  newCard = me.parseActiveItem(newCard);
  newIndex = owner.items.indexOf(newCard);
  if (newIndex === -1) {
    newIndex = owner.items.items.length;
    Ext.suspendLayouts();
    newCard = owner.add(newCard);
    Ext.resumeLayouts();
  }
  if (newCard && oldCard !== newCard) {
    if (newCard.fireEvent('beforeactivate', newCard, oldCard) === false) {
      return false;
    }
    if (oldCard && oldCard.fireEvent('beforedeactivate', oldCard, newCard) === false) {
      return false;
    }
    if (rendered) {
      Ext.suspendLayouts();
      if (!newCard.rendered) {
        me.renderItem(newCard, me.getRenderTarget(), owner.items.length);
      }
      if (oldCard) {
        if (me.hideInactive) {
          focusNewCard = oldCard.el.contains(Ext.Element.getActiveElement());
          oldCard.hide();
          if (oldCard.hidden) {
            oldCard.hiddenByLayout = true;
            oldCard.fireEvent('deactivate', oldCard, newCard);
          } else {
            return false;
          }
        }
      }
      if (newCard.hidden) {
        newCard.show();
      }
      if (newCard.hidden) {
        me.activeItem = newCard = null;
      } else {
        me.activeItem = newCard;
        if (focusNewCard) {
          if (!newCard.defaultFocus) {
            newCard.defaultFocus = ':focusable';
          }
          newCard.focus();
        }
      }
      Ext.resumeLayouts(true);
    } else {
      me.activeItem = newCard;
    }
    newCard.fireEvent('activate', newCard, oldCard);
    return me.activeItem;
  }
  return false;
}, resetItemHideMode:function(item) {
  item.hideMode = item.originalHideMode;
  delete item.originalHideMode;
}, setItemHideMode:function(item) {
  item.originalHideMode = item.hideMode;
  item.hideMode = 'offsets';
}}, 0, 0, 0, 0, ['layout.card'], 0, [Ext.layout.container, 'Card', Ext.layout, 'CardLayout'], 0);
Ext.cmd.derive('Ext.menu.DatePicker', Ext.menu.Menu, {ariaRole:'dialog', ariaLabel:'Date picker', hideOnClick:true, pickerId:null, focusableContainer:false, initComponent:function() {
  var me = this, cfg, pickerConfig;
  if (me.pickerCfg) {
    pickerConfig = Ext.apply({cls:'x-menu-date-item', margin:0, border:false, xtype:'datepicker'}, me.pickerCfg);
  } else {
    cfg = Ext.apply({}, me.initialConfig);
    delete cfg.listeners;
    pickerConfig = Ext.applyIf({cls:'x-menu-date-item', margin:0, border:false, xtype:'datepicker'}, cfg);
  }
  if (me.pickerId != null && pickerConfig.id == null) {
    pickerConfig.id = me.pickerId;
  }
  delete pickerConfig.ownerCmp;
  Ext.apply(me, {showSeparator:false, plain:true, bodyPadding:0, items:[pickerConfig]});
  Ext.menu.Menu.prototype.initComponent.call(this);
  me.picker = me.down('datepicker');
  me.relayEvents(me.picker, ['select']);
  if (me.hideOnClick) {
    me.on('select', me.hidePickerOnSelect, me);
  }
}, onEscapeKey:function(e) {
  var me = this;
  if (me.floating && me.ownerCmp && me.ownerCmp.focus) {
    me.ownerCmp.focus();
    me.hide();
  }
}, hidePickerOnSelect:function() {
  Ext.menu.Manager.hideAll();
}}, 0, ['datemenu'], ['component', 'box', 'container', 'panel', 'menu', 'datemenu'], {'component':true, 'box':true, 'container':true, 'panel':true, 'menu':true, 'datemenu':true}, ['widget.datemenu'], 0, [Ext.menu, 'DatePicker'], 0);
Ext.cmd.derive('Ext.resizer.BorderSplitterTracker', Ext.resizer.SplitterTracker, {getPrevCmp:null, getNextCmp:null, calculateConstrainRegion:function() {
  var me = this, splitter = me.splitter, collapseTarget = splitter.collapseTarget, defaultSplitMin = splitter.defaultSplitMin, sizePropCap = splitter.vertical ? 'Width' : 'Height', minSizeProp = 'min' + sizePropCap, maxSizeProp = 'max' + sizePropCap, getSizeMethod = 'get' + sizePropCap, neighbors = splitter.neighbors, length = neighbors.length, box = collapseTarget.el.getBox(), left = box.x, top = box.y, right = box.right, bottom = box.bottom, size = splitter.vertical ? right - left : bottom - top, 
  i, neighbor, neighborMaxSize, minRange, maxRange, maxGrowth, maxShrink, targetSize;
  minRange = (collapseTarget[minSizeProp] || Math.min(size, defaultSplitMin)) - size;
  maxRange = collapseTarget[maxSizeProp];
  if (!maxRange) {
    maxRange = 1000000000;
  } else {
    maxRange -= size;
  }
  targetSize = size;
  for (i = 0; i < length; ++i) {
    neighbor = neighbors[i];
    size = neighbor[getSizeMethod]();
    neighborMaxSize = neighbor[maxSizeProp];
    if (neighborMaxSize === null) {
      neighborMaxSize = undefined;
    }
    maxGrowth = size - neighborMaxSize;
    maxShrink = size - (neighbor[minSizeProp] || Math.min(size, defaultSplitMin));
    if (!isNaN(maxGrowth)) {
      if (minRange < maxGrowth) {
        minRange = maxGrowth;
      }
    }
    if (maxRange > maxShrink) {
      maxRange = maxShrink;
    }
  }
  if (maxRange - minRange < 2) {
    return null;
  }
  box = new Ext.util.Region(top, right, bottom, left);
  me.constraintAdjusters[me.getCollapseDirection()](box, minRange, maxRange, splitter);
  me.dragInfo = {minRange:minRange, maxRange:maxRange, targetSize:targetSize};
  return box;
}, constraintAdjusters:{left:function(box, minRange, maxRange, splitter) {
  box[0] = box.x = box.left = box.right + minRange;
  box.right += maxRange + splitter.getWidth();
}, top:function(box, minRange, maxRange, splitter) {
  box[1] = box.y = box.top = box.bottom + minRange;
  box.bottom += maxRange + splitter.getHeight();
}, bottom:function(box, minRange, maxRange, splitter) {
  box.bottom = box.top - minRange;
  box.top -= maxRange + splitter.getHeight();
}, right:function(box, minRange, maxRange, splitter) {
  box.right = box.left - minRange;
  box[0] = box.x = box.left = box.x - maxRange + splitter.getWidth();
}}, onBeforeStart:function(e) {
  var me = this, splitter = me.splitter, collapseTarget = splitter.collapseTarget, neighbors = splitter.neighbors, length = neighbors.length, i, neighbor;
  if (collapseTarget.collapsed) {
    return false;
  }
  for (i = 0; i < length; ++i) {
    neighbor = neighbors[i];
    if (neighbor.collapsed && neighbor.isHorz === collapseTarget.isHorz) {
      return false;
    }
  }
  if (!(me.constrainTo = me.calculateConstrainRegion())) {
    return false;
  }
  return true;
}, performResize:function(e, offset) {
  var me = this, splitter = me.splitter, collapseDirection = splitter.getCollapseDirection(), collapseTarget = splitter.collapseTarget, adjusters = me.splitAdjusters[splitter.vertical ? 'horz' : 'vert'], delta = offset[adjusters.index], dragInfo = me.dragInfo, owner;
  if (collapseDirection === 'right' || collapseDirection === 'bottom') {
    delta = -delta;
  }
  delta = Math.min(Math.max(dragInfo.minRange, delta), dragInfo.maxRange);
  if (delta) {
    (owner = splitter.ownerCt).suspendLayouts();
    adjusters.adjustTarget(collapseTarget, dragInfo.targetSize, delta);
    owner.resumeLayouts(true);
  }
}, splitAdjusters:{horz:{index:0, adjustTarget:function(target, size, delta) {
  target.flex = null;
  target.setSize(size + delta);
}}, vert:{index:1, adjustTarget:function(target, targetSize, delta) {
  target.flex = null;
  target.setSize(undefined, targetSize + delta);
}}}, getCollapseDirection:function() {
  return this.splitter.getCollapseDirection();
}}, 0, 0, 0, 0, 0, 0, [Ext.resizer, 'BorderSplitterTracker'], 0);
Ext.cmd.derive('Ext.resizer.ResizeTracker', Ext.dd.DragTracker, {dynamic:true, preserveRatio:false, preventDefault:false, constrainTo:null, proxyCls:'x-resizable-proxy', constructor:function(config) {
  var me = this, widthRatio, heightRatio, throttledResizeFn;
  if (!config.el) {
    if (config.target.isComponent) {
      me.el = config.target.getEl();
    } else {
      me.el = config.target;
    }
  }
  Ext.dd.DragTracker.prototype.constructor.apply(this, arguments);
  if (me.preserveRatio && me.minWidth && me.minHeight) {
    widthRatio = me.minWidth / me.el.getWidth();
    heightRatio = me.minHeight / me.el.getHeight();
    if (heightRatio > widthRatio) {
      me.minWidth = me.el.getWidth() * heightRatio;
    } else {
      me.minHeight = me.el.getHeight() * widthRatio;
    }
  }
  if (me.throttle) {
    throttledResizeFn = Ext.Function.createThrottled(function() {
      Ext.resizer.ResizeTracker.prototype.resize.apply(me, arguments);
    }, me.throttle);
    me.resize = function(box, direction, atEnd) {
      if (atEnd) {
        Ext.resizer.ResizeTracker.prototype.resize.apply(me, arguments);
      } else {
        throttledResizeFn.apply(null, arguments);
      }
    };
  }
}, onBeforeStart:function(e) {
  this.startBox = this.target.getBox();
}, getProxy:function() {
  var me = this;
  if (!me.dynamic && !me.proxy) {
    me.proxy = me.createProxy(me.target || me.el);
    me.hideProxy = true;
  }
  if (me.proxy) {
    me.proxy.show();
    return me.proxy;
  }
}, createProxy:function(target) {
  var proxy, cls = this.proxyCls;
  if (target.isComponent) {
    proxy = target.getProxy().addCls(cls);
  } else {
    proxy = target.createProxy({tag:'div', role:'presentation', cls:cls, id:target.id + '-rzproxy'}, Ext.getBody());
  }
  proxy.removeCls('x-proxy-el');
  return proxy;
}, onStart:function(e) {
  this.activeResizeHandle = Ext.get(this.getDragTarget().id);
  if (!this.dynamic) {
    this.resize(this.startBox);
  }
}, onMouseDown:function(e, target) {
  Ext.dd.DragTracker.prototype.onMouseDown.call(this, e, target);
  Ext.dom.Element.maskIframes();
}, onMouseUp:function(e) {
  Ext.dd.DragTracker.prototype.onMouseUp.call(this, e);
  Ext.dom.Element.unmaskIframes();
}, onDrag:function(e) {
  if (this.dynamic || this.proxy) {
    this.updateDimensions(e);
  }
}, updateDimensions:function(e, atEnd) {
  var me = this, region = me.activeResizeHandle.region, offset = me.getOffset(me.constrainTo ? 'dragTarget' : null), box = me.startBox, ratio, widthAdjust = 0, heightAdjust = 0, snappedWidth, snappedHeight, adjustX = 0, adjustY = 0, dragRatio, oppositeCorner, axis, newBox, newHeight, newWidth;
  region = me.convertRegionName(region);
  switch(region) {
    case 'south':
      heightAdjust = offset[1];
      axis = 2;
      break;
    case 'north':
      heightAdjust = -offset[1];
      adjustY = -heightAdjust;
      axis = 2;
      break;
    case 'east':
      widthAdjust = offset[0];
      axis = 1;
      break;
    case 'west':
      widthAdjust = -offset[0];
      adjustX = -widthAdjust;
      axis = 1;
      break;
    case 'northeast':
      heightAdjust = -offset[1];
      adjustY = -heightAdjust;
      widthAdjust = offset[0];
      oppositeCorner = [box.x, box.y + box.height];
      axis = 3;
      break;
    case 'southeast':
      heightAdjust = offset[1];
      widthAdjust = offset[0];
      oppositeCorner = [box.x, box.y];
      axis = 3;
      break;
    case 'southwest':
      widthAdjust = -offset[0];
      adjustX = -widthAdjust;
      heightAdjust = offset[1];
      oppositeCorner = [box.x + box.width, box.y];
      axis = 3;
      break;
    case 'northwest':
      heightAdjust = -offset[1];
      adjustY = -heightAdjust;
      widthAdjust = -offset[0];
      adjustX = -widthAdjust;
      oppositeCorner = [box.x + box.width, box.y + box.height];
      axis = 3;
      break;
  }
  newBox = {width:box.width + widthAdjust, height:box.height + heightAdjust, x:box.x + adjustX, y:box.y + adjustY};
  snappedWidth = Ext.Number.snap(newBox.width, me.widthIncrement);
  snappedHeight = Ext.Number.snap(newBox.height, me.heightIncrement);
  if (snappedWidth !== newBox.width || snappedHeight !== newBox.height) {
    switch(region) {
      case 'northeast':
        newBox.y -= snappedHeight - newBox.height;
        break;
      case 'north':
        newBox.y -= snappedHeight - newBox.height;
        break;
      case 'southwest':
        newBox.x -= snappedWidth - newBox.width;
        break;
      case 'west':
        newBox.x -= snappedWidth - newBox.width;
        break;
      case 'northwest':
        newBox.x -= snappedWidth - newBox.width;
        newBox.y -= snappedHeight - newBox.height;
    }
    newBox.width = snappedWidth;
    newBox.height = snappedHeight;
  }
  if (newBox.width < me.minWidth || newBox.width > me.maxWidth) {
    newBox.width = Ext.Number.constrain(newBox.width, me.minWidth, me.maxWidth);
    if (adjustX) {
      newBox.x = box.x + (box.width - newBox.width);
    }
  } else {
    me.lastX = newBox.x;
  }
  if (newBox.height < me.minHeight || newBox.height > me.maxHeight) {
    newBox.height = Ext.Number.constrain(newBox.height, me.minHeight, me.maxHeight);
    if (adjustY) {
      newBox.y = box.y + (box.height - newBox.height);
    }
  } else {
    me.lastY = newBox.y;
  }
  if (me.preserveRatio || e.shiftKey) {
    ratio = me.startBox.width / me.startBox.height;
    newHeight = Math.min(Math.max(me.minHeight, newBox.width / ratio), me.maxHeight);
    newWidth = Math.min(Math.max(me.minWidth, newBox.height * ratio), me.maxWidth);
    if (axis === 1) {
      newBox.height = newHeight;
    } else {
      if (axis === 2) {
        newBox.width = newWidth;
      } else {
        dragRatio = Math.abs(oppositeCorner[0] - this.lastXY[0]) / Math.abs(oppositeCorner[1] - this.lastXY[1]);
        if (dragRatio > ratio) {
          newBox.height = newHeight;
        } else {
          newBox.width = newWidth;
        }
        if (region === 'northeast') {
          newBox.y = box.y - (newBox.height - box.height);
        } else {
          if (region === 'northwest') {
            newBox.y = box.y - (newBox.height - box.height);
            newBox.x = box.x - (newBox.width - box.width);
          } else {
            if (region === 'southwest') {
              newBox.x = box.x - (newBox.width - box.width);
            }
          }
        }
      }
    }
  }
  me.setPosition = newBox.x !== me.startBox.x || newBox.y !== me.startBox.y;
  me.resize(newBox, atEnd);
}, resize:function(box, atEnd) {
  var me = this, target, setPosition = me.setPosition;
  if (me.dynamic || !me.dynamic && atEnd) {
    if (setPosition) {
      me.target.setBox(box);
    } else {
      me.target.setSize(box.width, box.height);
    }
  }
  if (!atEnd) {
    target = me.getProxy();
    if (target && target !== me.target) {
      if (setPosition || me.hideProxy) {
        target.setBox(box);
      } else {
        target.setSize(box.width, box.height);
      }
    }
  }
}, onEnd:function(e) {
  this.updateDimensions(e, true);
  if (this.proxy && this.hideProxy) {
    this.proxy.hide();
  }
}, convertRegionName:function(name) {
  return name;
}}, 1, 0, 0, 0, 0, 0, [Ext.resizer, 'ResizeTracker'], 0);
Ext.cmd.derive('Ext.resizer.Resizer', Ext.Base, {alternateClassName:'Ext.Resizable', handleCls:'x-resizable-handle', overCls:'x-resizable-handle-over', pinnedCls:'x-resizable-pinned', wrapCls:'x-resizable-wrap', wrappedCls:'x-resizable-wrapped', delimiterRe:/(?:\s*[,;]\s*)|\s+/, dynamic:true, handles:'s e se', height:null, width:null, heightIncrement:0, widthIncrement:0, minHeight:20, minWidth:20, maxHeight:10000, maxWidth:10000, pinned:false, preserveRatio:false, transparent:false, possiblePositions:{n:'north', 
s:'south', e:'east', w:'west', se:'southeast', sw:'southwest', nw:'northwest', ne:'northeast'}, touchActionMap:{n:{panY:false}, s:{panY:false}, e:{panX:false}, w:{panX:false}, se:{panX:false, panY:false}, sw:{panX:false, panY:false}, nw:{panX:false, panY:false}, ne:{panX:false, panY:false}}, ariaRole:'presentation', constructor:function(config) {
  var me = this, unselectableCls = Ext.dom.Element.unselectableCls, handleEls = [], resizeTarget, handleCls, possibles, tag, len, i, pos, box, handle, handles, handleEl, wrapTarget, positioning, targetBaseCls;
  if (Ext.isString(config) || Ext.isElement(config) || config.dom) {
    resizeTarget = config;
    config = arguments[1] || {};
    config.target = resizeTarget;
  }
  me.mixins.observable.constructor.call(me, config);
  resizeTarget = me.target;
  if (resizeTarget) {
    if (resizeTarget.isComponent) {
      resizeTarget.addClsWithUI('resizable');
      if (resizeTarget.minWidth) {
        me.minWidth = resizeTarget.minWidth;
      }
      if (resizeTarget.minHeight) {
        me.minHeight = resizeTarget.minHeight;
      }
      if (resizeTarget.maxWidth) {
        me.maxWidth = resizeTarget.maxWidth;
      }
      if (resizeTarget.maxHeight) {
        me.maxHeight = resizeTarget.maxHeight;
      }
      if (resizeTarget.floating) {
        if (!me.hasOwnProperty('handles')) {
          me.handles = 'n ne e se s sw w nw';
        }
      }
      me.el = resizeTarget.getEl();
    } else {
      resizeTarget = me.el = me.target = Ext.get(resizeTarget);
    }
  } else {
    resizeTarget = me.target = me.el = Ext.get(me.el);
  }
  me.el.addCls(Ext.Component.prototype.borderBoxCls);
  if (Ext.isNumber(me.width)) {
    me.width = Ext.Number.constrain(me.width, me.minWidth, me.maxWidth);
  }
  if (Ext.isNumber(me.height)) {
    me.height = Ext.Number.constrain(me.height, me.minHeight, me.maxHeight);
  }
  if (me.width !== null || me.height !== null) {
    me.target.setSize(me.width, me.height);
  }
  tag = me.el.dom.tagName.toUpperCase();
  if (tag === 'TEXTAREA' || tag === 'IMG' || tag === 'TABLE') {
    me.originalTarget = me.target;
    wrapTarget = resizeTarget.isComponent ? resizeTarget.getEl() : resizeTarget;
    me.el.addCls(me.wrappedCls);
    me.target = me.el = me.el.wrap({role:'presentation', cls:me.wrapCls, id:me.el.id + '-rzwrap', style:wrapTarget.getStyle(['margin-top', 'margin-bottom'])});
    positioning = wrapTarget.getPositioning();
    me.el.setPositioning(positioning);
    wrapTarget.clearPositioning();
    box = wrapTarget.getBox();
    if (positioning.position !== 'absolute') {
      box.x = 0;
      box.y = 0;
    }
    me.el.setBox(box);
    wrapTarget.setStyle('position', 'absolute');
    me.isTargetWrapped = true;
  }
  me.el.position();
  if (me.pinned) {
    me.el.addCls(me.pinnedCls);
  }
  me.resizeTracker = new Ext.resizer.ResizeTracker({disabled:me.disabled, target:resizeTarget, el:me.el, constrainTo:me.constrainTo, handleCls:me.handleCls, overCls:me.overCls, throttle:me.throttle, proxy:me.originalTarget ? me.el : null, dynamic:me.originalTarget ? true : me.dynamic, originalTarget:me.originalTarget, delegate:'.' + me.handleCls, preserveRatio:me.preserveRatio, heightIncrement:me.heightIncrement, widthIncrement:me.widthIncrement, minHeight:me.minHeight, maxHeight:me.maxHeight, minWidth:me.minWidth, 
  maxWidth:me.maxWidth});
  me.resizeTracker.on({mousedown:me.onBeforeResize, drag:me.onResize, dragend:me.onResizeEnd, scope:me});
  if (me.handles === 'all') {
    me.handles = 'n s e w ne nw se sw';
  }
  handles = me.handles = me.handles.split(me.delimiterRe);
  possibles = me.possiblePositions;
  len = handles.length;
  handleCls = me.handleCls + ' ' + me.handleCls + '-{0}';
  if (me.target.isComponent) {
    targetBaseCls = me.target.baseCls;
    handleCls += ' ' + targetBaseCls + '-handle ' + targetBaseCls + '-handle-{0}';
    if (Ext.supports.CSS3BorderRadius) {
      handleCls += ' ' + targetBaseCls + '-handle-{0}-br';
    }
  }
  for (i = 0; i < len; i++) {
    handle = handles[i];
    if (handle && possibles[handle]) {
      pos = possibles[handle];
      handleEl = me[pos] = me.el.createChild({id:me.el.id + '-' + pos + '-handle', cls:Ext.String.format(handleCls, pos) + ' ' + unselectableCls, unselectable:'on', role:'presentation'});
      handleEl.region = pos;
      if (me.transparent) {
        handleEl.setOpacity(0);
      }
      handleEl.setTouchAction(me.touchActionMap[handle]);
      handleEls.push(handleEl);
    }
  }
  me.resizeTracker.handleEls = handleEls;
}, disable:function() {
  this.disabled = true;
  this.resizeTracker.disable();
}, enable:function() {
  this.disabled = false;
  this.resizeTracker.enable();
}, onBeforeResize:function(tracker, e) {
  return this.fireResizeEvent('beforeresize', tracker, e);
}, onResize:function(tracker, e) {
  return this.fireResizeEvent('resizedrag', tracker, e);
}, onResizeEnd:function(tracker, e) {
  return this.fireResizeEvent('resize', tracker, e);
}, fireResizeEvent:function(name, tracker, e) {
  var me = this, box;
  if (me.hasListeners[name]) {
    box = me.el.getBox();
    return me.fireEvent(name, me, box.width, box.height, e);
  }
}, resizeTo:function(width, height) {
  var me = this;
  me.target.setSize(width, height);
  me.fireEvent('resize', me, width, height, null);
}, getEl:function() {
  return this.el;
}, getTarget:function() {
  return this.target;
}, destroy:function() {
  var me = this, handles = me.handles, len = handles.length, positions = me.possiblePositions, handle, pos, i;
  me.resizeTracker.destroy();
  if (me.isTargetWrapped) {
    me.target.destroy();
  }
  for (i = 0; i < len; i++) {
    pos = positions[handles[i]];
    if (handle = me[pos]) {
      handle.destroy();
      me[pos] = null;
    }
  }
  me.callParent();
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.resizer, 'Resizer', Ext, 'Resizable'], 0);
Ext.cmd.derive('Ext.selection.CellModel', Ext.selection.DataViewModel, {isCellModel:true, deselectOnContainerClick:false, enableKeyNav:true, preventWrap:false, bindComponent:function(view) {
  var me = this, grid;
  if (me.view && me.gridListeners) {
    me.gridListeners.destroy();
  }
  Ext.selection.DataViewModel.prototype.bindComponent.call(this, view);
  if (view) {
    grid = view.grid || view.ownerCt;
    if (grid.optimizedColumnMove !== false) {
      me.gridListeners = grid.on({columnmove:me.onColumnMove, scope:me, destroyable:true});
    }
  }
}, getViewListeners:function() {
  var result = Ext.selection.DataViewModel.prototype.getViewListeners.call(this);
  result.refresh = this.onViewRefresh;
  return result;
}, getHeaderCt:function() {
  var selection = this.navigationModel.getPosition(), view = selection ? selection.view : this.primaryView;
  return view.headerCt;
}, onNavigate:function(e) {
  if (!e.record || e.keyEvent.stopSelection) {
    return;
  }
  this.setPosition(e.position);
}, selectWithEvent:function(record, e) {
  this.select(record);
}, select:function(pos, keepExisting, suppressEvent) {
  var me = this, row, oldPos = me.getPosition(), store = me.view.store;
  if (pos || pos === 0) {
    if (pos.isModel) {
      row = store.indexOf(pos);
      if (row !== -1) {
        pos = {row:row, column:oldPos ? oldPos.column : 0};
      } else {
        pos = null;
      }
    } else {
      if (typeof pos === 'number') {
        pos = {row:pos, column:0};
      }
    }
  }
  if (pos) {
    me.selectByPosition(pos, suppressEvent);
  } else {
    me.deselect();
  }
}, getCurrentPosition:function() {
  var position = this.selecting ? this.nextSelection : this.selection;
  return position ? {view:position.view, record:position.record, row:position.rowIdx, columnHeader:position.column, column:position.view.getColumnManager().indexOf(position.column)} : position;
}, getPosition:function() {
  return (this.selecting ? this.nextSelection : this.selection) || null;
}, setCurrentPosition:function(pos, suppressEvent, preventCheck) {
  if (pos && !pos.isCellContext) {
    pos = (new Ext.grid.CellContext(this.view)).setPosition({row:pos.row, column:typeof pos.column === 'number' ? this.view.getColumnManager().getColumns()[pos.column] : pos.column});
  }
  return this.setPosition(pos, suppressEvent, preventCheck);
}, setPosition:function(pos, suppressEvent, preventCheck) {
  var me = this, last = me.selection;
  if (pos) {
    pos = pos.isCellContext ? pos.clone() : (new Ext.grid.CellContext(me.view)).setPosition(pos);
  }
  if (!preventCheck && last) {
    if (pos && (pos.record === last.record && pos.column === last.column && pos.view === last.view)) {
      pos = null;
    } else {
      me.onCellDeselect(me.selection, suppressEvent);
    }
  }
  if (pos) {
    me.nextSelection = pos;
    me.selecting = true;
    me.onCellSelect(me.nextSelection, suppressEvent);
    me.selecting = false;
    return me.selection = pos;
  }
}, isCellSelected:function(view, row, column) {
  var me = this, testPos, pos = me.getPosition();
  if (pos && pos.view === view) {
    testPos = (new Ext.grid.CellContext(view)).setPosition({row:row, column:typeof column === 'number' ? view.getColumnManager().getColumns()[column] : column});
    return testPos.record === pos.record && testPos.column === pos.column;
  }
}, onStoreRemove:function(store, records, indices) {
  var me = this, pos = me.getPosition();
  Ext.selection.DataViewModel.prototype.onStoreRemove.apply(this, arguments);
  if (pos && store.isMoving(pos.record)) {
    return;
  }
  if (pos && store.getCount() && store.indexOf(pos.record) !== -1) {
    pos.setRow(pos.record);
  } else {
    me.selection = null;
  }
}, onStoreClear:function() {
  Ext.selection.DataViewModel.prototype.onStoreClear.apply(this, arguments);
  this.selection = null;
}, onStoreAdd:function() {
  var me = this, pos = me.getPosition();
  Ext.selection.DataViewModel.prototype.onStoreAdd.apply(this, arguments);
  if (pos) {
    pos.setRow(pos.record);
  } else {
    me.selection = null;
  }
}, updateSelectedInstances:function(selected) {
  var pos = this.getPosition(), selRec = selected.getAt(0);
  if (selRec && pos && pos.record.id === selRec.id) {
    pos.setRow(selRec);
  }
  Ext.selection.DataViewModel.prototype.updateSelectedInstances.call(this, selected);
  if (selected.length === 0 && selRec) {
    this.selection = null;
  }
}, onCellClick:function(view, cell, cellIndex, record, row, recordIndex, e) {
  if (recordIndex !== -1) {
    this.setPosition(e.position);
  }
}, onCellSelect:function(position, supressEvent) {
  if (position && position.rowIdx !== undefined && position.rowIdx > -1) {
    this.doSelect(position.record, false, supressEvent);
  }
}, onCellDeselect:function(position, supressEvent) {
  if (position && position.rowIdx !== undefined) {
    this.doDeselect(position.record, supressEvent);
  }
}, onSelectChange:function(record, isSelected, suppressEvent, commitFn) {
  var me = this, pos, eventName, view;
  if (isSelected) {
    pos = me.nextSelection;
    eventName = 'select';
  } else {
    pos = me.selection;
    eventName = 'deselect';
  }
  view = pos.view || me.primaryView;
  if ((suppressEvent || me.fireEvent('before' + eventName, me, record, pos.rowIdx, pos.colIdx)) !== false && commitFn() !== false) {
    if (isSelected) {
      view.onCellSelect(pos);
    } else {
      view.onCellDeselect(pos);
      delete me.selection;
    }
    if (!suppressEvent) {
      me.fireEvent(eventName, me, record, pos.rowIdx, pos.colIdx);
    }
  }
}, refresh:function() {
  var pos = this.getPosition(), selRowIdx;
  if (pos && (selRowIdx = this.store.indexOf(this.selected.last())) !== -1) {
    pos.rowIdx = selRowIdx;
  }
}, onColumnMove:function(headerCt, header, fromIdx, toIdx) {
  var grid = headerCt.up('tablepanel');
  if (grid) {
    this.onViewRefresh(grid.view);
  }
}, onUpdate:function(record) {
  var me = this, pos;
  if (me.isSelected(record)) {
    pos = me.selecting ? me.nextSelection : me.selection;
    me.view.onCellSelect(pos);
  }
}, onViewRefresh:function(view) {
  var me = this, pos = me.getPosition(), newPos, headerCt = view.headerCt, record, column;
  if (pos && pos.view === view) {
    record = pos.record;
    column = view.getColumnByPosition(pos);
    if (column && !column.isDescendantOf(headerCt)) {
      column = headerCt.queryById(column.id) || headerCt.down('[text\x3d"' + column.text + '"]') || headerCt.down('[dataIndex\x3d"' + column.dataIndex + '"]');
    }
    if (column && record) {
      if (view.store.indexOfId(record.getId()) !== -1) {
        newPos = (new Ext.grid.CellContext(view)).setPosition({row:record, column:column});
        me.setPosition(newPos);
      }
    } else {
      me.selection = null;
    }
  }
}, selectByPosition:function(position, suppressEvent) {
  this.setPosition(position, suppressEvent);
}}, 0, 0, 0, 0, ['selection.cellmodel'], 0, [Ext.selection, 'CellModel'], 0);
Ext.cmd.derive('Ext.selection.RowModel', Ext.selection.DataViewModel, {enableKeyNav:true, isRowModel:true, deselectOnContainerClick:false, onUpdate:function(record) {
  var me = this, view = me.view, index;
  if (view && me.isSelected(record)) {
    index = view.indexOf(record);
    view.onRowSelect(index);
    if (record === me.lastFocused) {
      view.onRowFocus(index, true);
    }
  }
}, onSelectChange:function(record, isSelected, suppressEvent, commitFn) {
  var me = this, views = me.views || [me.view], viewsLn = views.length, recordIndex = me.store.indexOf(record), eventName = isSelected ? 'select' : 'deselect', i, view;
  if ((suppressEvent || me.fireEvent('before' + eventName, me, record, recordIndex)) !== false && commitFn() !== false) {
    for (i = 0; i < viewsLn; i++) {
      view = views[i];
      recordIndex = view.indexOf(record);
      if (view.indexOf(record) !== -1) {
        if (isSelected) {
          view.onRowSelect(recordIndex, suppressEvent);
        } else {
          view.onRowDeselect(recordIndex, suppressEvent);
        }
      }
    }
    if (!suppressEvent) {
      me.fireEvent(eventName, me, record, recordIndex);
    }
  }
}, getCurrentPosition:function() {
  var firstSelection = this.selected.getAt(0);
  if (firstSelection) {
    return (new Ext.grid.CellContext(this.view)).setPosition(this.store.indexOf(firstSelection), 0);
  }
}, selectByPosition:function(position, keepExisting) {
  if (!position.isCellContext) {
    position = (new Ext.grid.CellContext(this.view)).setPosition(position.row, position.column);
  }
  this.select(position.record, keepExisting);
}, selectNext:function(keepExisting, suppressEvent) {
  var me = this, store = me.store, selection = me.getSelection(), record = selection[selection.length - 1], index = me.view.indexOf(record) + 1, success;
  if (index === store.getCount() || index === 0) {
    success = false;
  } else {
    me.doSelect(index, keepExisting, suppressEvent);
    success = true;
  }
  return success;
}, selectPrevious:function(keepExisting, suppressEvent) {
  var me = this, selection = me.getSelection(), record = selection[0], index = me.view.indexOf(record) - 1, success;
  if (index < 0) {
    success = false;
  } else {
    me.doSelect(index, keepExisting, suppressEvent);
    success = true;
  }
  return success;
}, isRowSelected:function(record) {
  return this.isSelected(record);
}, isCellSelected:function(view, record, columnHeader) {
  return this.isSelected(record);
}, vetoSelection:function(e) {
  var navModel = this.view.getNavigationModel(), key = e.getKey(), isLeftRight = key === e.RIGHT || key === e.LEFT;
  return isLeftRight && navModel.previousRecord === navModel.record || Ext.selection.DataViewModel.prototype.vetoSelection.call(this, e);
}}, 0, 0, 0, 0, ['selection.rowmodel'], 0, [Ext.selection, 'RowModel'], 0);
Ext.cmd.derive('Ext.selection.CheckboxModel', Ext.selection.RowModel, {mode:'MULTI', injectCheckbox:0, checkOnly:false, locked:false, showHeaderCheckbox:undefined, headerText:undefined, headerAriaLabel:'Row selector', headerSelectText:'Press Space to select all rows', headerDeselectText:'Press Space to deselect all rows', rowSelectText:'Press Space to select this row', rowDeselectText:'Press Space to deselect this row', allowDeselect:true, headerWidth:24, checkerOnCls:'x-grid-hd-checker-on', tdCls:'x-grid-cell-special x-selmodel-column', 
constructor:function() {
  var me = this;
  Ext.selection.RowModel.prototype.constructor.apply(this, arguments);
  if (me.mode === 'SINGLE') {
    me.showHeaderCheckbox = false;
  }
}, beforeViewRender:function(view) {
  var me = this, ownerLockable = view.grid.ownerLockable, isLocked = me.locked || me.config && me.config.locked;
  Ext.selection.RowModel.prototype.beforeViewRender.apply(this, arguments);
  if (me.injectCheckbox !== false) {
    if (ownerLockable && !me.lockListeners) {
      me.lockListeners = ownerLockable.mon(ownerLockable, {lockcolumn:me.onColumnLock, unlockcolumn:me.onColumnUnlock, scope:me, destroyable:true});
    }
    if (!ownerLockable || view.isLockedView && (me.hasLockedHeader() || isLocked) || view.isNormalView && !me.column) {
      me.addCheckbox(view);
      me.mon(view.ownerGrid, {beforereconfigure:me.onBeforeReconfigure, reconfigure:me.onReconfigure, scope:me});
    }
  }
}, onColumnUnlock:function(lockable, column) {
  var me = this, checkbox = me.injectCheckbox, lockedColumns = lockable.lockedGrid.visibleColumnManager.getColumns();
  if (lockedColumns.length === 1 && lockedColumns[0] === me.column) {
    if (checkbox === 'first') {
      checkbox = 0;
    } else {
      if (checkbox === 'last') {
        checkbox = lockable.normalGrid.visibleColumnManager.getColumns().length;
      }
    }
    lockable.unlock(me.column, checkbox);
  }
}, onColumnLock:function(lockable, column) {
  var me = this, checkbox = me.injectCheckbox, lockedColumns = lockable.lockedGrid.visibleColumnManager.getColumns();
  if (lockedColumns.length === 1) {
    if (checkbox === 'first') {
      checkbox = 0;
    } else {
      if (checkbox === 'last') {
        checkbox = lockable.lockedGrid.visibleColumnManager.getColumns().length;
      }
    }
    lockable.lock(me.column, checkbox);
  }
}, bindComponent:function(view) {
  this.sortable = false;
  Ext.selection.RowModel.prototype.bindComponent.apply(this, arguments);
}, hasLockedHeader:function() {
  var columns = this.view.ownerGrid.getVisibleColumnManager().getColumns(), len = columns.length, i;
  for (i = 0; i < len; i++) {
    if (columns[i].locked) {
      return true;
    }
  }
  return false;
}, addCheckbox:function(view) {
  var me = this, checkboxIndex = me.injectCheckbox, headerCt = view.headerCt;
  if (checkboxIndex !== false) {
    if (checkboxIndex === 'first') {
      checkboxIndex = 0;
    } else {
      if (checkboxIndex === 'last') {
        checkboxIndex = headerCt.getColumnCount();
      }
    }
    Ext.suspendLayouts();
    if (view.getStore().isBufferedStore) {
      me.showHeaderCheckbox = false;
    }
    me.column = headerCt.add(checkboxIndex, me.column || me.getHeaderConfig());
    Ext.resumeLayouts();
  }
}, onBeforeReconfigure:function(grid, store, columns, oldStore, oldColumns) {
  var column = this.column, headerCt = column.ownerCt;
  if (columns && headerCt) {
    headerCt.remove(column, false);
  }
}, onReconfigure:function(grid, store, columns) {
  var me = this;
  if (columns) {
    if (grid.lockable) {
      if (grid.lockedGrid.isVisible()) {
        grid.lock(me.column, 0);
      } else {
        grid.unlock(me.column, 0);
      }
    } else {
      me.addCheckbox(me.view);
    }
    grid.view.refreshView();
  }
}, onHeaderClick:function(headerCt, header, e) {
  var me = this, store = me.store, isChecked, records, i, len, selections, selection;
  if (me.showHeaderCheckbox !== false && header === me.column && me.mode !== 'SINGLE') {
    e.stopEvent();
    isChecked = header.el.hasCls('x-grid-hd-checker-on');
    if (isChecked) {
      records = [];
      selections = this.getSelection();
      for (i = 0, len = selections.length; i < len; ++i) {
        selection = selections[i];
        if (store.indexOf(selection) > -1) {
          records.push(selection);
        }
      }
      if (records.length > 0) {
        me.deselect(records);
      }
    } else {
      me.selectAll();
    }
  }
}, getHeaderConfig:function() {
  var me = this, showCheck = me.showHeaderCheckbox !== false, htmlEncode = Ext.String.htmlEncode, config;
  config = {xtype:'checkcolumn', headerCheckbox:showCheck, isCheckerHd:showCheck, ignoreExport:true, text:me.headerText, width:me.headerWidth, sortable:false, draggable:false, resizable:false, hideable:false, menuDisabled:true, checkOnly:me.checkOnly, checkboxAriaRole:'presentation', tdCls:'x-selmodel-checkbox ' + me.tdCls, cls:'x-selmodel-column', editRenderer:me.editRenderer || me.renderEmpty, locked:me.hasLockedHeader(), processEvent:Ext.emptyFn, toggleAll:Ext.emptyFn, setRecordCheck:Ext.emptyFn, 
  isRecordChecked:me.isRowSelected.bind(me)};
  if (!me.checkOnly) {
    config.tabIndex = undefined;
    config.ariaRole = 'presentation';
    config.focusable = false;
  } else {
    config.useAriaElements = true;
    config.ariaLabel = htmlEncode(me.headerAriaLabel);
    config.headerSelectText = htmlEncode(me.headerSelectText);
    config.headerDeselectText = htmlEncode(me.headerDeselectText);
    config.rowSelectText = htmlEncode(me.rowSelectText);
    config.rowDeselectText = htmlEncode(me.rowDeselectText);
  }
  return config;
}, toggleRecord:function(record, recordIndex, checked, cell) {
  this[checked ? 'select' : 'deselect']([record], this.mode !== 'SINGLE');
}, renderEmpty:function() {
  return '\x26#160;';
}, refresh:function() {
  Ext.selection.RowModel.prototype.refresh.apply(this, arguments);
  this.updateHeaderState();
}, selectByPosition:function(position, keepExisting) {
  if (!position.isCellContext) {
    position = (new Ext.grid.CellContext(this.view)).setPosition(position.row, position.column);
  }
  if (!this.checkOnly || position.column === this.column) {
    Ext.selection.RowModel.prototype.selectByPosition.call(this, position, keepExisting);
  }
}, onSelectChange:function(record, isSelected) {
  var me = this;
  Ext.selection.RowModel.prototype.onSelectChange.apply(this, arguments);
  if (me.column) {
    me.column.updateCellAriaDescription(record, isSelected);
  }
  if (!me.suspendChange) {
    me.updateHeaderState();
  }
}, onStoreLoad:function() {
  Ext.selection.RowModel.prototype.onStoreLoad.apply(this, arguments);
  this.updateHeaderState();
}, onStoreAdd:function() {
  Ext.selection.RowModel.prototype.onStoreAdd.apply(this, arguments);
  this.updateHeaderState();
}, onStoreRemove:function() {
  Ext.selection.RowModel.prototype.onStoreRemove.apply(this, arguments);
  this.updateHeaderState();
}, onStoreRefresh:function() {
  Ext.selection.RowModel.prototype.onStoreRefresh.apply(this, arguments);
  this.updateHeaderState();
}, maybeFireSelectionChange:function(fireEvent) {
  if (fireEvent && !this.suspendChange) {
    this.updateHeaderState();
  }
  Ext.selection.RowModel.prototype.maybeFireSelectionChange.apply(this, arguments);
}, resumeChanges:function() {
  Ext.selection.RowModel.prototype.resumeChanges.call(this);
  if (!this.suspendChange) {
    this.updateHeaderState();
  }
}, updateHeaderState:function() {
  var me = this, store = me.store, storeCount = store.getCount(), views = me.views, hdSelectStatus = false, selectedCount = 0, selected, len, i;
  if (!store.isBufferedStore && storeCount > 0) {
    selected = me.selected;
    hdSelectStatus = true;
    for (i = 0, len = selected.getCount(); i < len; ++i) {
      if (store.indexOfId(selected.getAt(i).id) > -1) {
        ++selectedCount;
      }
    }
    hdSelectStatus = storeCount === selectedCount;
  }
  if (views && views.length) {
    me.column.setHeaderStatus(hdSelectStatus);
  }
}, vetoSelection:function(e) {
  var me = this, column = me.column, veto, isClick, isSpace;
  if (me.checkOnly) {
    isClick = e.type === column.triggerEvent && e.getTarget(me.column.getCellSelector());
    isSpace = e.getKey() === e.SPACE && e.position.column === column;
    veto = !(isClick || isSpace);
  }
  return veto || Ext.selection.RowModel.prototype.vetoSelection.call(this, e);
}, privates:{onBeforeNavigate:function(metaEvent) {
  var e = metaEvent.keyEvent;
  if (this.selectionMode !== 'SINGLE') {
    metaEvent.ctrlKey = metaEvent.ctrlKey || e.ctrlKey || e.type === this.column.triggerEvent && !e.shiftKey || e.getKey() === e.SPACE;
  }
}, selectWithEventMulti:function(record, e, isSelected) {
  var me = this;
  if (!e.shiftKey && !e.ctrlKey && e.getTarget(me.column.getCellSelector())) {
    if (isSelected) {
      me.doDeselect(record);
    } else {
      me.doSelect(record, true);
    }
  } else {
    Ext.selection.RowModel.prototype.selectWithEventMulti.call(this, record, e, isSelected);
  }
}}}, 1, 0, 0, 0, ['selection.checkboxmodel'], 0, [Ext.selection, 'CheckboxModel'], function(CheckboxModel) {
  CheckboxModel.prototype.checkSelector = '.' + Ext.grid.column.Check.prototype.checkboxCls;
});
Ext.define('Ext.theme.triton.selection.CheckboxModel', {override:'Ext.selection.CheckboxModel', headerWidth:32, onHeaderClick:function(headerCt, header, e) {
  (arguments.callee.$previous || Ext.selection.RowModel.prototype.onHeaderClick).call(this, headerCt, header, e);
  if (Ext.isIE8) {
    header.getView().ownerGrid.el.syncRepaint();
  }
}});
Ext.cmd.derive('Ext.selection.TreeModel', Ext.selection.RowModel, {selectOnExpanderClick:false, constructor:function(config) {
  var me = this;
  Ext.selection.RowModel.prototype.constructor.call(this, config);
  if (me.pruneRemoved) {
    me.pruneRemoved = false;
    me.pruneRemovedNodes = true;
  }
}, getStoreListeners:function() {
  var me = this, result = Ext.selection.RowModel.prototype.getStoreListeners.call(this);
  result.noderemove = me.onNodeRemove;
  return result;
}, onNodeRemove:function(parent, node, isMove) {
  if (!isMove) {
    var toDeselect = [];
    this.gatherSelected(node, toDeselect);
    if (toDeselect.length) {
      this.deselect(toDeselect);
    }
  }
}, pruneRemovedOnRefresh:function() {
  return this.pruneRemovedNodes;
}, vetoSelection:function(e) {
  var view = this.view, select = this.selectOnExpanderClick, veto = !select && e.type === 'click' && e.getTarget(view.expanderSelector || view.lockingPartner && view.lockingPartner.expanderSelector);
  return veto || Ext.selection.RowModel.prototype.vetoSelection.call(this, e);
}, privates:{gatherSelected:function(node, toDeselect) {
  var childNodes = node.childNodes, i, len, child;
  if (this.selected.containsKey(node.id)) {
    toDeselect.push(node);
  }
  if (childNodes) {
    for (i = 0, len = childNodes.length; i < len; ++i) {
      child = childNodes[i];
      this.gatherSelected(child, toDeselect);
    }
  }
}}}, 1, 0, 0, 0, ['selection.treemodel'], 0, [Ext.selection, 'TreeModel'], 0);
Ext.cmd.derive('Ext.slider.Thumb', Ext.Base, {overCls:'x-slider-thumb-over', constructor:function(config) {
  var me = this;
  Ext.apply(me, config || {}, {cls:'x-slider-thumb', constrain:false});
  me.callParent([config]);
}, render:function() {
  var me = this;
  me.el = me.slider.innerEl.insertFirst(me.getElConfig());
  me.onRender();
}, onRender:function() {
  var me = this, panDisable = me.slider.vertical ? 'panY' : 'panX', touchAction = {};
  touchAction[panDisable] = false;
  me.el.setTouchAction(touchAction);
  if (me.disabled) {
    me.disable();
  }
  me.initEvents();
}, getElConfig:function() {
  var me = this, slider = me.slider, style = {};
  style[slider.vertical ? 'bottom' : slider.horizontalProp] = slider.calculateThumbPosition(slider.normalizeValue(me.value)) + '%';
  return {style:style, id:me.id, cls:me.cls, role:'presentation'};
}, move:function(v, animate) {
  var me = this, el = me.el, slider = me.slider, styleProp = slider.vertical ? 'bottom' : slider.horizontalProp, to, from, animCfg;
  v += '%';
  if (!animate) {
    el.dom.style[styleProp] = v;
  } else {
    to = {};
    to[styleProp] = v;
    if (!Ext.supports.GetPositionPercentage) {
      from = {};
      from[styleProp] = el.dom.style[styleProp];
    }
    animCfg = {target:el, duration:350, from:from, to:to, scope:me, callback:me.onAnimComplete};
    if (animate !== true) {
      Ext.apply(animCfg, animate);
    }
    me.anim = new Ext.fx.Anim(animCfg);
  }
}, onAnimComplete:function() {
  this.anim = null;
}, enable:function() {
  var el = this.el;
  this.disabled = false;
  if (el) {
    el.removeCls(this.slider.disabledCls);
  }
}, disable:function() {
  var el = this.el;
  this.disabled = true;
  if (el) {
    el.addCls(this.slider.disabledCls);
  }
}, initEvents:function() {
  var me = this;
  me.tracker = new Ext.dd.DragTracker({el:me.el, onBeforeStart:me.onBeforeDragStart.bind(me), onStart:me.onDragStart.bind(me), onDrag:me.onDrag.bind(me), onEnd:me.onDragEnd.bind(me), tolerance:3, autoStart:300});
  me.el.hover(me.addOverCls, me.removeOverCls, me);
}, addOverCls:function() {
  var me = this;
  if (!me.disabled) {
    me.el.addCls(me.overCls);
  }
}, removeOverCls:function() {
  this.el.removeCls(this.overCls);
}, onBeforeDragStart:function(e) {
  var me = this, el = me.el, trackerXY = me.tracker.getXY(), delta = me.pointerOffset = el.getXY();
  if (me.disabled) {
    return false;
  } else {
    delta[0] += Math.floor(el.getWidth() / 2) - trackerXY[0];
    delta[1] += Math.floor(el.getHeight() / 2) - trackerXY[1];
    me.slider.promoteThumb(me);
    return true;
  }
}, onDragStart:function(e) {
  var me = this, slider = me.slider;
  slider.onDragStart(me, e);
  me.el.addCls('x-slider-thumb-drag');
  me.dragging = me.slider.dragging = true;
  me.dragStartValue = me.value;
  slider.fireEvent('dragstart', slider, e, me);
}, onDrag:function(e) {
  var me = this, slider = me.slider, index = me.index, newValue = me.getValueFromTracker(), above, below;
  if (newValue !== undefined) {
    if (me.constrain) {
      above = slider.thumbs[index + 1];
      below = slider.thumbs[index - 1];
      if (below !== undefined && newValue <= below.value) {
        newValue = below.value;
      }
      if (above !== undefined && newValue >= above.value) {
        newValue = above.value;
      }
    }
    slider.setValue(index, newValue, false);
    slider.fireEvent('drag', slider, e, me);
  }
}, getValueFromTracker:function() {
  var slider = this.slider, trackerXY = this.tracker.getXY(), trackPoint;
  trackerXY[0] += this.pointerOffset[0];
  trackerXY[1] += this.pointerOffset[1];
  trackPoint = slider.getTrackpoint(trackerXY);
  if (trackPoint != null) {
    return slider.reversePixelValue(trackPoint);
  }
}, onDragEnd:function(e) {
  var me = this, slider = me.slider, value = me.value;
  slider.onDragEnd(me, e);
  me.el.removeCls('x-slider-thumb-drag');
  me.dragging = slider.dragging = false;
  slider.fireEvent('dragend', slider, e);
  if (me.dragStartValue !== value) {
    slider.fireEvent('changecomplete', slider, value, me);
  }
}, destroy:function() {
  var me = this, anim = this.anim;
  if (anim) {
    anim.end();
  }
  me.el = me.tracker = me.anim = Ext.destroy(me.el, me.tracker);
  me.callParent();
}}, 1, 0, 0, 0, 0, 0, [Ext.slider, 'Thumb'], 0);
Ext.cmd.derive('Ext.slider.Tip', Ext.tip.Tip, {minWidth:10, offsets:null, align:null, position:'', defaultVerticalPosition:'left', defaultHorizontalPosition:'top', isSliderTip:true, init:function(slider) {
  var me = this, align, offsets;
  if (!me.position) {
    me.position = slider.vertical ? me.defaultVerticalPosition : me.defaultHorizontalPosition;
  }
  switch(me.position) {
    case 'top':
      offsets = [0, -10];
      align = 'b-t?';
      break;
    case 'bottom':
      offsets = [0, 10];
      align = 't-b?';
      break;
    case 'left':
      offsets = [-10, 0];
      align = 'r-l?';
      break;
    case 'right':
      offsets = [10, 0];
      align = 'l-r?';
  }
  if (!me.align) {
    me.align = align;
  }
  if (!me.offsets) {
    me.offsets = offsets;
  }
  slider.on({scope:me, dragstart:me.onSlide, drag:me.onSlide, dragend:me.hide, destroy:me.destroy});
}, onSlide:function(slider, e, thumb) {
  var me = this;
  me.update(me.getText(thumb));
  me.show();
  me.el.alignTo(thumb.el, me.align, me.offsets);
}, getText:function(thumb) {
  return String(thumb.value);
}}, 0, ['slidertip'], ['component', 'box', 'container', 'panel', 'tip', 'slidertip'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tip':true, 'slidertip':true}, ['widget.slidertip'], 0, [Ext.slider, 'Tip'], 0);
Ext.cmd.derive('Ext.slider.Multi', Ext.form.field.Base, {alternateClassName:'Ext.slider.MultiSlider', vertical:false, minValue:0, maxValue:100, decimalPrecision:0, keyIncrement:1, pageSize:10, increment:0, clickRange:[5, 15], clickToChange:true, animate:true, dragging:false, constrainThumbs:true, useTips:true, tipText:null, defaultBindProperty:'value', publishes:['value'], thumbPerValue:false, ariaRole:'slider', focusable:true, needArrowKeys:true, tabIndex:0, skipLabelForAttribute:true, focusCls:'slider-focus', 
childEls:['endEl', 'innerEl'], fieldSubTpl:['\x3cdiv id\x3d"{id}" data-ref\x3d"inputEl" {inputAttrTpl}', ' class\x3d"', 'x-', 'slider {fieldCls} {vertical}', '{childElCls}"', '\x3ctpl if\x3d"tabIdx !\x3d null"\x3e tabindex\x3d"{tabIdx}"\x3c/tpl\x3e', '\x3ctpl foreach\x3d"ariaElAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e', '\x3ctpl foreach\x3d"inputElAriaAttributes"\x3e {$}\x3d"{.}"\x3c/tpl\x3e', '\x3e', '\x3cdiv id\x3d"{cmpId}-endEl" data-ref\x3d"endEl" class\x3d"x-slider-end" role\x3d"presentation"\x3e', 
'\x3cdiv id\x3d"{cmpId}-innerEl" data-ref\x3d"innerEl" class\x3d"x-slider-inner" role\x3d"presentation"\x3e', '{%this.renderThumbs(out, values)%}', '\x3c/div\x3e', '\x3c/div\x3e', '\x3c/div\x3e', {renderThumbs:function(out, values) {
  var me = values.$comp, i = 0, thumbs = me.thumbs, len = thumbs.length, thumb, thumbConfig;
  for (; i < len; i++) {
    thumb = thumbs[i];
    thumbConfig = thumb.getElConfig();
    thumbConfig.id = me.id + '-thumb-' + i;
    Ext.DomHelper.generateMarkup(thumbConfig, out);
  }
}, disableFormats:true}], horizontalProp:'left', initValue:function() {
  var me = this, extValueFrom = Ext.valueFrom, values = extValueFrom(me.values, [extValueFrom(me.value, extValueFrom(me.minValue, 0))]), thumbPerValue = me.thumbPerValue;
  me.originalValue = values;
  me.initializingValues = true;
  me.updateValues(values);
  me.initializingValues = false;
  me.thumbPerValue = thumbPerValue;
}, initComponent:function() {
  var me = this, tipText = me.tipText, tipPlug, hasTip, p, pLen, plugins;
  me.thumbs = [];
  me.keyIncrement = Math.max(me.increment, me.keyIncrement);
  me.extraFieldBodyCls = 'x-slider-ct-' + (me.vertical ? 'vert' : 'horz');
  Ext.form.field.Base.prototype.initComponent.call(this);
  if (me.useTips) {
    tipPlug = {};
    if (Ext.isObject(me.useTips)) {
      Ext.apply(tipPlug, me.useTips);
    } else {
      if (tipText) {
        tipPlug.getText = tipText;
      }
    }
    if (typeof(tipText = tipPlug.getText) === 'string') {
      tipPlug.getText = function(thumb) {
        return Ext.callback(tipText, null, [thumb], 0, me, me);
      };
    }
    plugins = me.plugins = me.plugins || [];
    pLen = plugins.length;
    for (p = 0; p < pLen; p++) {
      if (plugins[p].isSliderTip) {
        hasTip = true;
        break;
      }
    }
    if (!hasTip) {
      me.plugins.push(new Ext.slider.Tip(tipPlug));
    }
  }
}, addThumb:function(value) {
  var me = this, thumb = new Ext.slider.Thumb({ownerCt:me, value:value, slider:me, index:me.thumbs.length, constrain:me.constrainThumbs, disabled:!!me.readOnly});
  me.thumbs.push(thumb);
  if (me.rendered) {
    thumb.render();
  }
  return thumb;
}, promoteThumb:function(topThumb) {
  var thumbs = this.thumbStack || (this.thumbStack = Ext.Array.slice(this.thumbs)), ln = thumbs.length, zIndex = 10000, i;
  if (thumbs[0] !== topThumb) {
    Ext.Array.remove(thumbs, topThumb);
    thumbs.unshift(topThumb);
  }
  for (i = 0; i < ln; i++) {
    thumbs[i].el.setStyle('zIndex', zIndex);
    zIndex -= 1000;
  }
}, getSubTplData:function(fieldData) {
  var me = this, data, ariaAttr;
  data = Ext.apply(Ext.form.field.Base.prototype.getSubTplData.call(this, fieldData), {$comp:me, vertical:me.vertical ? 'x-slider-vert' : 'x-slider-horz', minValue:me.minValue, maxValue:me.maxValue, value:me.value, tabIdx:me.tabIndex, childElCls:''});
  ariaAttr = data.inputElAriaAttributes;
  if (ariaAttr) {
    if (!ariaAttr['aria-labelledby']) {
      ariaAttr['aria-labelledby'] = me.id + '-labelEl';
    }
    ariaAttr['aria-orientation'] = me.vertical ? 'vertical' : 'horizontal';
    ariaAttr['aria-valuemin'] = me.minValue;
    ariaAttr['aria-valuemax'] = me.maxValue;
    ariaAttr['aria-valuenow'] = me.value;
  }
  return data;
}, onRender:function() {
  var me = this, thumbs = me.thumbs, len = thumbs.length, i = 0, thumb;
  (arguments.callee.$previous || Ext.form.field.Base.prototype.onRender).apply(this, arguments);
  for (i = 0; i < len; i++) {
    thumb = thumbs[i];
    thumb.el = me.el.getById(me.id + '-thumb-' + i);
    thumb.onRender();
  }
}, initEvents:function() {
  var me = this;
  Ext.form.field.Base.prototype.initEvents.call(this);
  me.mon(me.el, {scope:me, mousedown:me.onMouseDown, keydown:me.onKeyDown});
}, onDragStart:Ext.emptyFn, onDragEnd:Ext.emptyFn, getTrackpoint:function(xy) {
  var me = this, vertical = me.vertical, sliderTrack = me.innerEl, trackLength, result, positionProperty;
  if (vertical) {
    positionProperty = 'top';
    trackLength = sliderTrack.getHeight();
  } else {
    positionProperty = me.horizontalProp;
    trackLength = sliderTrack.getWidth();
  }
  xy = me.transformTrackPoints(sliderTrack.translatePoints(xy));
  result = Ext.Number.constrain(xy[positionProperty], 0, trackLength);
  return vertical ? trackLength - result : result;
}, transformTrackPoints:Ext.identityFn, checkChange:Ext.emptyFn, onMouseDown:function(e) {
  var me = this, thumbClicked = false, i = 0, thumbs = me.thumbs, len = thumbs.length, trackPoint;
  if (me.disabled) {
    return;
  }
  for (; !thumbClicked && i < len; i++) {
    thumbClicked = thumbClicked || e.target === thumbs[i].el.dom;
  }
  me.focus();
  if (me.clickToChange && !thumbClicked) {
    trackPoint = me.getTrackpoint(e.getXY());
    if (trackPoint !== undefined) {
      me.onClickChange(trackPoint);
    }
  }
}, onClickChange:function(trackPoint) {
  var me = this, thumb, index;
  thumb = me.getNearest(trackPoint);
  if (!thumb.disabled) {
    index = thumb.index;
    me.setValue(index, Ext.util.Format.round(me.reversePixelValue(trackPoint), me.decimalPrecision), undefined, true);
  }
}, getNearest:function(trackPoint) {
  var me = this, clickValue = me.reversePixelValue(trackPoint), nearestDistance = me.getRange() + 5, nearest = null, thumbs = me.thumbs, i = 0, len = thumbs.length, thumb, value, dist;
  for (; i < len; i++) {
    thumb = me.thumbs[i];
    value = thumb.value;
    dist = Math.abs(value - clickValue);
    if (Math.abs(dist) <= nearestDistance) {
      if (nearest && nearest.value == value && value > clickValue && thumb.index > nearest.index) {
        continue;
      }
      nearest = thumb;
      nearestDistance = dist;
    }
  }
  return nearest;
}, onKeyDown:function(e) {
  var me = this, ariaDom = me.ariaEl.dom, k, val;
  k = e.getKey();
  if (me.disabled || me.thumbs.length !== 1) {
    if (k !== e.TAB) {
      e.preventDefault();
    }
    return;
  }
  switch(k) {
    case e.UP:
    case e.RIGHT:
      val = e.ctrlKey ? me.maxValue : me.getValue(0) + me.keyIncrement;
      break;
    case e.DOWN:
    case e.LEFT:
      val = e.ctrlKey ? me.minValue : me.getValue(0) - me.keyIncrement;
      break;
    case e.HOME:
      val = me.minValue;
      break;
    case e.END:
      val = me.maxValue;
      break;
    case e.PAGE_UP:
      val = me.getValue(0) + me.pageSize;
      break;
    case e.PAGE_DOWN:
      val = me.getValue(0) - me.pageSize;
      break;
  }
  if (val !== undefined) {
    e.stopEvent();
    val = me.normalizeValue(val);
    me.setValue(0, val, undefined, true);
    if (ariaDom) {
      ariaDom.setAttribute('aria-valuenow', val);
    }
  }
}, normalizeValue:function(value) {
  var me = this, snapFn = me.zeroBasedSnapping ? 'snap' : 'snapInRange';
  value = Ext.Number[snapFn](value, me.increment, me.minValue, me.maxValue);
  value = Ext.util.Format.round(value, me.decimalPrecision);
  value = Ext.Number.constrain(value, me.minValue, me.maxValue);
  return value;
}, setMinValue:function(val) {
  var me = this, thumbs = me.thumbs, len = thumbs.length, ariaDom = me.ariaEl.dom, thumb, i;
  me.minValue = val;
  for (i = 0; i < len; ++i) {
    thumb = thumbs[i];
    if (thumb.value < val) {
      me.setValue(i, val, false);
    }
  }
  if (ariaDom) {
    ariaDom.setAttribute('aria-valuemin', val);
  }
  me.syncThumbs();
}, setMaxValue:function(val) {
  var me = this, thumbs = me.thumbs, len = thumbs.length, ariaDom = me.ariaEl.dom, thumb, i;
  me.maxValue = val;
  for (i = 0; i < len; ++i) {
    thumb = thumbs[i];
    if (thumb.value > val) {
      me.setValue(i, val, false);
    }
  }
  if (ariaDom) {
    ariaDom.setAttribute('aria-valuemax', val);
  }
  me.syncThumbs();
}, setValue:function(index, value, animate, changeComplete) {
  var me = this, ariaDom = me.ariaEl.dom, thumb;
  if (Ext.isArray(index)) {
    me.updateValues(index, value);
    return me;
  }
  thumb = me.thumbs[index];
  value = me.normalizeValue(value);
  if (value !== thumb.value && me.fireEvent('beforechange', me, value, thumb.value, thumb, 'update') !== false) {
    thumb.value = value;
    if (me.rendered) {
      if (Ext.isDefined(animate)) {
        animate = animate === false ? false : animate;
      } else {
        animate = me.animate;
      }
      thumb.move(me.calculateThumbPosition(value), animate);
      if (index === 0 && ariaDom) {
        ariaDom.setAttribute('aria-valuenow', value);
      }
      me.fireEvent('change', me, value, thumb, 'update');
      me.checkDirty();
      if (changeComplete) {
        me.fireEvent('changecomplete', me, value, thumb);
      }
    }
  }
  return me;
}, calculateThumbPosition:function(v) {
  var me = this, minValue = me.minValue, pos = (v - minValue) / me.getRange() * 100;
  if (isNaN(pos)) {
    pos = 0;
  }
  return pos;
}, getRatio:function() {
  var me = this, innerEl = me.innerEl, trackLength = me.vertical ? innerEl.getHeight() : innerEl.getWidth(), valueRange = me.getRange();
  return valueRange === 0 ? trackLength : trackLength / valueRange;
}, getRange:function() {
  return this.maxValue - this.minValue;
}, reversePixelValue:function(pos) {
  return this.minValue + pos / this.getRatio();
}, reversePercentageValue:function(pos) {
  return this.minValue + this.getRange() * (pos / 100);
}, onDisable:function() {
  var me = this, i = 0, thumbs = me.thumbs, len = thumbs.length, thumb, el, xy;
  Ext.form.field.Base.prototype.onDisable.call(this);
  for (; i < len; i++) {
    thumb = thumbs[i];
    el = thumb.el;
    thumb.disable();
    if (Ext.isIE) {
      xy = el.getXY();
      el.hide();
      me.innerEl.addCls(me.disabledCls).dom.disabled = true;
      if (!me.thumbHolder) {
        me.thumbHolder = me.endEl.createChild({role:'presentation', cls:'x-slider-thumb ' + me.disabledCls});
      }
      me.thumbHolder.show().setXY(xy);
    }
  }
}, onEnable:function() {
  var me = this, i = 0, thumbs = me.thumbs, len = thumbs.length, thumb, el;
  Ext.form.field.Base.prototype.onEnable.call(this);
  for (; i < len; i++) {
    thumb = thumbs[i];
    el = thumb.el;
    thumb.enable();
    if (Ext.isIE) {
      me.innerEl.removeCls(me.disabledCls).dom.disabled = false;
      if (me.thumbHolder) {
        me.thumbHolder.hide();
      }
      el.show();
      me.syncThumbs();
    }
  }
}, syncThumbs:function() {
  if (this.rendered) {
    var thumbs = this.thumbs, length = thumbs.length, i = 0;
    for (; i < length; i++) {
      thumbs[i].move(this.calculateThumbPosition(thumbs[i].value));
    }
  }
}, getValue:function(index) {
  return Ext.isNumber(index) ? this.thumbs[index].value : this.getValues();
}, getValues:function() {
  var values = [], i = 0, thumbs = this.thumbs, len = thumbs.length;
  for (; i < len; i++) {
    values.push(thumbs[i].value);
  }
  return values;
}, getSubmitValue:function() {
  var me = this;
  return me.disabled || !me.submitValue ? null : me.getValue();
}, reset:function() {
  var me = this, arr = [].concat(me.originalValue);
  me.updateValues(arr);
  me.clearInvalid();
  delete me.wasValid;
}, updateValues:function(values, animate, supressEvents) {
  var me = this, len = values.length, thumbs = me.thumbs, thumbLen = thumbs.length, newValues = [], skipEvents = me.initializingValues || supressEvents, i, thumb, value, addLen, removeLen;
  for (i = 0; i < len; i++) {
    thumb = thumbs[i];
    value = values[i];
    if (thumb) {
      me.setValue(i, value, animate);
    } else {
      newValues.push(value);
    }
  }
  if (me.thumbPerValue || me.initializingValues) {
    addLen = newValues.length;
    removeLen = thumbLen - len;
    for (i = 0; i < addLen; i++) {
      value = newValues[i];
      if (skipEvents || me.fireEvent('beforechange', me, value, null, null, 'add') !== false) {
        thumb = me.addThumb(me.normalizeValue(value));
        if (!skipEvents) {
          me.fireEvent('change', me, value, thumb, 'add');
        }
        me.checkDirty();
      }
    }
    for (i = 0; i < removeLen; i++) {
      thumb = thumbs[thumbs.length - 1];
      if (skipEvents || me.fireEvent('beforechange', me, null, thumb.value, thumb, 'remove') !== false) {
        me.removeThumb(thumb);
        if (!skipEvents) {
          me.fireEvent('change', me, null, null, 'remove');
        }
        me.checkDirty();
      }
    }
  }
  return me;
}, removeThumb:function(thumb) {
  var me = this, thumbs = me.thumbs, index;
  if (Ext.isNumber(thumb)) {
    index = thumb;
    thumb = thumbs[index];
  } else {
    index = me.findThumbIndex(thumb);
  }
  if (thumb && Ext.isNumber(index)) {
    thumbs.splice(index, 1);
    me.thumbStack = Ext.Array.slice(me.thumbs);
    Ext.destroy(thumb);
  }
}, findThumbIndex:function(thumb) {
  var thumbs = this.thumbs, len = thumbs.length, index = null, i;
  for (i = 0; i < len; i++) {
    if (thumbs[i] === thumb) {
      index = i;
      break;
    }
  }
  return index;
}, setReadOnly:function(readOnly) {
  var me = this, thumbs = me.thumbs, len = thumbs.length, i = 0;
  Ext.form.field.Base.prototype.setReadOnly.apply(this, arguments);
  readOnly = me.readOnly;
  for (; i < len; ++i) {
    if (readOnly) {
      thumbs[i].disable();
    } else {
      thumbs[i].enable();
    }
  }
}, doDestroy:function() {
  var me = this;
  if (me.rendered) {
    Ext.destroy(me.thumbs);
  }
  if (me.thumbHolder) {
    me.thumbHolder.destroy();
    me.thumbHolder = null;
  }
  Ext.form.field.Base.prototype.doDestroy.call(this);
}}, 0, ['multislider'], ['component', 'box', 'field', 'multislider'], {'component':true, 'box':true, 'field':true, 'multislider':true}, ['widget.multislider'], 0, [Ext.slider, 'Multi', Ext.slider, 'MultiSlider'], 0);
Ext.cmd.derive('Ext.slider.Single', Ext.slider.Multi, {alternateClassName:['Ext.Slider', 'Ext.form.SliderField', 'Ext.slider.SingleSlider', 'Ext.slider.Slider'], initComponent:function() {
  if (this.publishOnComplete) {
    this.valuePublishEvent = 'changecomplete';
  }
  Ext.slider.Multi.prototype.initComponent.call(this);
}, publishOnComplete:true, getValue:function() {
  return Ext.slider.Multi.prototype.getValue.call(this, 0);
}, setValue:function(value, animate) {
  var args = arguments, len = args.length;
  if (len === 1 || len <= 3 && typeof args[1] !== 'number') {
    args = Ext.toArray(args);
    args.unshift(0);
  }
  return Ext.slider.Multi.prototype.setValue.apply(this, args);
}, getNearest:function() {
  return this.thumbs[0];
}}, 0, ['slider', 'sliderfield'], ['component', 'box', 'field', 'multislider', 'slider', 'sliderfield'], {'component':true, 'box':true, 'field':true, 'multislider':true, 'slider':true, 'sliderfield':true}, ['widget.slider', 'widget.sliderfield'], 0, [Ext.slider, 'Single', Ext, 'Slider', Ext.form, 'SliderField', Ext.slider, 'SingleSlider', Ext.slider, 'Slider'], 0);
Ext.cmd.derive('Ext.tab.Tab', Ext.button.Button, {isTab:true, baseCls:'x-tab', closeElOverCls:'x-tab-close-btn-over', closeElPressedCls:'x-tab-close-btn-pressed', config:{rotation:'default', tabPosition:'top'}, closable:true, closeText:'removable', active:false, childEls:['closeEl'], scale:false, ariaRole:'tab', tabIndex:-1, keyMap:{scope:'this', DELETE:'onDeleteKey'}, _btnWrapCls:'x-tab-wrap', _btnCls:'x-tab-button', _baseIconCls:'x-tab-icon-el', _glyphCls:'x-tab-glyph', _innerCls:'x-tab-inner', 
_textCls:'x-tab-text', _noTextCls:'x-tab-no-text', _hasIconCls:'x-tab-icon', _activeCls:'x-tab-active', _closableCls:'x-tab-closable', overCls:'x-tab-over', _pressedCls:'x-tab-pressed', _disabledCls:'x-tab-disabled', _rotateClasses:{1:'x-tab-rotate-right', 2:'x-tab-rotate-left'}, _positions:{top:{'default':'top', 0:'top', 1:'left', 2:'right'}, right:{'default':'top', 0:'right', 1:'top', 2:'bottom'}, bottom:{'default':'bottom', 0:'bottom', 1:'right', 2:'left'}, left:{'default':'top', 0:'left', 1:'bottom', 
2:'top'}}, _defaultRotations:{top:0, right:1, bottom:0, left:2}, initComponent:function() {
  var me = this;
  if (me.card) {
    me.setCard(me.card);
  }
  Ext.button.Button.prototype.initComponent.apply(this, arguments);
}, getActualRotation:function() {
  var rotation = this.getRotation();
  return rotation !== 'default' ? rotation : this._defaultRotations[this.getTabPosition()];
}, updateRotation:function() {
  this.syncRotationAndPosition();
}, updateTabPosition:function() {
  this.syncRotationAndPosition();
}, syncRotationAndPosition:function() {
  var me = this, rotateClasses = me._rotateClasses, position = me.getTabPosition(), rotation = me.getActualRotation(), oldRotateCls = me._rotateCls, rotateCls = me._rotateCls = rotateClasses[rotation], oldPositionCls = me._positionCls, positionCls = me._positionCls = me._positions[position][rotation];
  if (oldRotateCls !== rotateCls) {
    if (oldRotateCls) {
      me.removeCls(oldRotateCls);
    }
    if (rotateCls) {
      me.addCls(rotateCls);
    }
  }
  if (oldPositionCls !== positionCls) {
    if (oldPositionCls) {
      me.removeClsWithUI(oldPositionCls);
    }
    if (positionCls) {
      me.addClsWithUI(positionCls);
    }
    if (me.rendered) {
      me.updateFrame();
    }
  }
  if (me.rendered) {
    me.setElOrientation();
  }
}, onAdded:function(container, pos, instanced) {
  Ext.button.Button.prototype.onAdded.call(this, container, pos, instanced);
  this.syncRotationAndPosition();
}, getTemplateArgs:function() {
  var me = this, result = Ext.button.Button.prototype.getTemplateArgs.call(this);
  result.closable = me.closable;
  result.closeText = me.closeText;
  return result;
}, beforeRender:function() {
  var me = this, tabBar = me.up('tabbar'), tabPanel = me.up('tabpanel');
  Ext.button.Button.prototype.beforeRender.call(this);
  me.ariaRenderAttributes = me.ariaRenderAttributes || {};
  if (me.active) {
    me.ariaRenderAttributes['aria-selected'] = true;
    me.addCls(me._activeCls);
  } else {
    me.ariaRenderAttributes['aria-selected'] = false;
  }
  me.syncClosableCls();
  if (!me.minWidth) {
    me.minWidth = tabBar ? tabBar.minTabWidth : me.minWidth;
    if (!me.minWidth && tabPanel) {
      me.minWidth = tabPanel.minTabWidth;
    }
    if (me.minWidth && me.iconCls) {
      me.minWidth += 25;
    }
  }
  if (!me.maxWidth) {
    me.maxWidth = tabBar ? tabBar.maxTabWidth : me.maxWidth;
    if (!me.maxWidth && tabPanel) {
      me.maxWidth = tabPanel.maxTabWidth;
    }
  }
}, onRender:function() {
  var me = this;
  me.setElOrientation();
  Ext.button.Button.prototype.onRender.apply(this, arguments);
  if (me.closable) {
    me.closeEl.addClsOnOver(me.closeElOverCls);
    me.closeEl.addClsOnClick(me.closeElPressedCls);
  }
}, setElOrientation:function() {
  var me = this, rotation = me.getActualRotation(), el = me.el;
  if (rotation) {
    el.setVertical(rotation === 1 ? 90 : 270);
  } else {
    el.setHorizontal();
  }
}, enable:function(silent) {
  var me = this;
  Ext.button.Button.prototype.enable.apply(this, arguments);
  me.removeCls(me._disabledCls);
  return me;
}, disable:function(silent) {
  var me = this;
  Ext.button.Button.prototype.disable.apply(this, arguments);
  me.addCls(me._disabledCls);
  return me;
}, setClosable:function(closable) {
  var me = this;
  closable = !arguments.length || !!closable;
  if (me.closable !== closable) {
    me.closable = closable;
    if (me.card) {
      me.card.closable = closable;
    }
    me.syncClosableCls();
    if (me.rendered) {
      me.syncClosableElements();
      me.updateLayout();
    }
  }
}, syncClosableElements:function() {
  var me = this, closeEl = me.closeEl;
  if (me.closable) {
    if (!closeEl) {
      closeEl = me.closeEl = me.btnWrap.insertSibling({tag:'span', id:me.id + '-closeEl', cls:me.baseCls + '-close-btn', html:me.closeText}, 'after');
    }
    closeEl.addClsOnOver(me.closeElOverCls);
    closeEl.addClsOnClick(me.closeElPressedCls);
  } else {
    if (closeEl) {
      closeEl.destroy();
      delete me.closeEl;
    }
  }
}, syncClosableCls:function() {
  var me = this, closableCls = me._closableCls;
  if (me.closable) {
    me.addCls(closableCls);
  } else {
    me.removeCls(closableCls);
  }
}, setCard:function(card) {
  var me = this;
  me.card = card;
  if (card.iconAlign) {
    me.setIconAlign(card.iconAlign);
  }
  if (card.textAlign) {
    me.setTextAlign(card.textAlign);
  }
  me.setText(me.title || card.title);
  me.setIconCls(me.iconCls || card.iconCls);
  me.setIcon(me.icon || card.icon);
  me.setGlyph(me.glyph || card.glyph);
}, onCloseClick:function() {
  var me = this;
  if (me.fireEvent('beforeclose', me) !== false) {
    if (me.tabBar) {
      if (me.tabBar.closeTab(me) === false) {
        return;
      }
    } else {
      me.fireClose();
    }
  }
}, fireClose:function() {
  this.fireEvent('close', this);
}, onEnterKey:function(e) {
  var me = this;
  if (me.tabBar) {
    me.tabBar.onClick(e, me.el);
    e.stopEvent();
    return false;
  }
}, onDeleteKey:function(e) {
  if (this.closable) {
    this.onCloseClick();
    e.stopEvent();
    return false;
  }
}, beforeClick:function(isCloseClick) {
  if (!isCloseClick) {
    this.focus();
  }
}, activate:function(supressEvent) {
  var me = this, card = me.card, ariaDom = me.ariaEl.dom;
  me.active = true;
  me.addCls(me._activeCls);
  if (ariaDom) {
    ariaDom.setAttribute('aria-selected', true);
  } else {
    me.ariaRenderAttributes = me.ariaRenderAttributes || {};
    me.ariaRenderAttributes['aria-selected'] = true;
  }
  if (card) {
    if (card.ariaEl.dom) {
      card.ariaEl.dom.setAttribute('aria-expanded', true);
    } else {
      card.ariaRenderAttributes = card.ariaRenderAttributes || {};
      card.ariaRenderAttributes['aria-expanded'] = true;
    }
  }
  if (supressEvent !== true) {
    me.fireEvent('activate', me);
  }
}, deactivate:function(supressEvent) {
  var me = this, card = me.card, ariaDom = me.ariaEl.dom;
  me.active = false;
  me.removeCls(me._activeCls);
  if (ariaDom) {
    ariaDom.setAttribute('aria-selected', false);
  } else {
    me.ariaRenderAttributes = me.ariaRenderAttributes || {};
    me.ariaRenderAttributes['aria-selected'] = false;
  }
  if (card) {
    if (card.ariaEl.dom) {
      card.ariaEl.dom.setAttribute('aria-expanded', false);
    } else {
      card.ariaRenderAttributes = card.ariaRenderAttributes || {};
      card.ariaRenderAttributes['aria-expanded'] = false;
    }
  }
  if (supressEvent !== true) {
    me.fireEvent('deactivate', me);
  }
}, privates:{getFramingInfoCls:function() {
  return this.baseCls + '-' + this.ui + '-' + this._positionCls;
}, wrapPrimaryEl:function(dom) {
  Ext.Button.superclass.wrapPrimaryEl.call(this, dom);
}}}, 0, ['tab'], ['component', 'box', 'button', 'tab'], {'component':true, 'box':true, 'button':true, 'tab':true}, ['widget.tab'], 0, [Ext.tab, 'Tab'], 0);
Ext.cmd.derive('Ext.tab.Bar', Ext.panel.Bar, {baseCls:'x-tab-bar', componentLayout:'body', isTabBar:true, config:{tabRotation:'default', tabStretchMax:true, activateOnFocus:true}, defaultType:'tab', plain:false, ensureActiveVisibleOnChange:true, ariaRole:'tablist', focusableContainer:true, childEls:['body', 'strip'], _stripCls:'x-tab-bar-strip', _baseBodyCls:'x-tab-bar-body', renderTpl:'\x3ctpl if\x3d"hasTabGuard"\x3e{% this.renderTabGuard(out, values, \'before\'); %}\x3c/tpl\x3e\x3cdiv id\x3d"{id}-body" data-ref\x3d"body" role\x3d"presentation" class\x3d"{baseBodyCls} {baseBodyCls}-{ui} {bodyCls} {bodyTargetCls}{childElCls}"\x3ctpl if\x3d"bodyStyle"\x3e style\x3d"{bodyStyle}"\x3c/tpl\x3e\x3e{%this.renderContainer(out,values)%}\x3c/div\x3e\x3ctpl if\x3d"hasTabGuard"\x3e{% this.renderTabGuard(out, values, \'after\'); %}\x3c/tpl\x3e\x3cdiv id\x3d"{id}-strip" data-ref\x3d"strip" role\x3d"presentation" class\x3d"{stripCls} {stripCls}-{ui}{childElCls}"\x3e\x3c/div\x3e', 
_reverseDockNames:{left:'right', right:'left'}, _layoutAlign:{top:'end', right:'begin', bottom:'begin', left:'end'}, initComponent:function() {
  var me = this, initialLayout = me.initialConfig.layout, initialAlign = initialLayout && initialLayout.align, initialOverflowHandler = initialLayout && initialLayout.overflowHandler;
  if (me.plain) {
    me.addCls(me.baseCls + '-plain');
  }
  me.layout = Ext.apply({align:initialAlign || (me.getTabStretchMax() ? 'stretchmax' : me._layoutAlign[me.dock]), overflowHandler:initialOverflowHandler || 'scroller'}, me.layout);
  Ext.panel.Bar.prototype.initComponent.call(this);
  me.on({click:me.onClick, element:'el', scope:me});
}, ensureTabVisible:function(tab) {
  var me = this, tabPanel = me.tabPanel, overflowHandler = me.layout.overflowHandler;
  if (me.rendered && overflowHandler && me.tooNarrow && overflowHandler.scrollToItem) {
    if (tab || tab === 0) {
      if (!tab.isTab) {
        if (Ext.isNumber(tab)) {
          tab = this.items.getAt(tab);
        } else {
          if (tab.isComponent && tabPanel && tabPanel.items.contains(tab)) {
            tab = tab.tab;
          }
        }
      }
    }
    if (!tab) {
      tab = me.activeTab;
    }
    if (tab) {
      overflowHandler.scrollToItem(tab);
    }
  }
}, initRenderData:function() {
  var me = this;
  return Ext.apply(Ext.panel.Bar.prototype.initRenderData.call(this), {bodyCls:me.bodyCls, baseBodyCls:me._baseBodyCls, bodyTargetCls:me.bodyTargetCls, stripCls:me._stripCls, dock:me.dock});
}, setDock:function(dock) {
  var me = this, items = me.items, ownerCt = me.ownerCt, item, i, ln;
  items = items && items.items;
  if (items) {
    for (i = 0, ln = items.length; i < ln; i++) {
      item = items[i];
      if (item.isTab) {
        item.setTabPosition(dock);
      }
    }
  }
  if (me.rendered) {
    me.resetItemMargins();
    if (ownerCt && ownerCt.isHeader) {
      ownerCt.resetItemMargins();
    }
    me.needsScroll = true;
  }
  Ext.panel.Bar.prototype.setDock.call(this, dock);
}, updateTabRotation:function(tabRotation) {
  var me = this, items = me.items, i, ln, item;
  items = items && items.items;
  if (items) {
    for (i = 0, ln = items.length; i < ln; i++) {
      item = items[i];
      if (item.isTab) {
        item.setRotation(tabRotation);
      }
    }
  }
  if (me.rendered) {
    me.resetItemMargins();
    me.needsScroll = true;
    me.updateLayout();
  }
}, onRender:function() {
  var me = this, overflowHandler = this.layout.overflowHandler;
  Ext.panel.Bar.prototype.onRender.call(this);
  if (Ext.isIE8 && me.vertical) {
    me.el.on({mousemove:me.onMouseMove, scope:me});
  }
  if (overflowHandler && overflowHandler.type === 'menu') {
    overflowHandler.menu.on('click', 'onOverflowMenuItemClick', me);
  }
}, afterLayout:function() {
  this.adjustTabPositions();
  Ext.panel.Bar.prototype.afterLayout.apply(this, arguments);
}, onAdd:function(tab, pos) {
  var fn = this.onTabContentChange;
  if (this.ensureActiveVisibleOnChange) {
    tab.barListeners = tab.on({scope:this, destroyable:true, glyphchange:fn, iconchange:fn, textchange:fn});
  }
  Ext.panel.Bar.prototype.onAdd.call(this, tab, pos);
}, onAdded:function(container, pos, instanced) {
  if (container.isHeader) {
    this.addCls(container.baseCls + '-' + container.ui + '-tab-bar');
  }
  Ext.panel.Bar.prototype.onAdded.call(this, container, pos, instanced);
}, onRemove:function(tab, destroying) {
  var me = this;
  if (me.ensureActiveVisibleOnChange) {
    if (!destroying) {
      tab.barListeners.destroy();
    }
    tab.barListeners = null;
  }
  if (tab === me.previousTab) {
    me.previousTab = null;
  }
  Ext.panel.Bar.prototype.onRemove.call(this, tab, destroying);
}, onRemoved:function(destroying) {
  var ownerCt = this.ownerCt;
  if (ownerCt.isHeader) {
    this.removeCls(ownerCt.baseCls + '-' + ownerCt.ui + '-tab-bar');
  }
  Ext.panel.Bar.prototype.onRemoved.call(this, destroying);
}, onTabContentChange:function(tab) {
  if (tab === this.activeTab) {
    this.ensureTabVisible(tab);
  }
}, afterComponentLayout:function(width) {
  var me = this, needsScroll = me.needsScroll, overflowHandler = me.layout.overflowHandler;
  Ext.panel.Bar.prototype.afterComponentLayout.apply(this, arguments);
  if (overflowHandler && needsScroll && me.tooNarrow && overflowHandler.scrollToItem) {
    overflowHandler.scrollToItem(me.activeTab);
  }
  delete me.needsScroll;
}, onMouseMove:function(e) {
  var me = this, overTab = me._overTab, tabInfo, tab;
  if (e.getTarget('.x-box-scroller')) {
    return;
  }
  tabInfo = me.getTabInfoFromPoint(e.getXY());
  tab = tabInfo.tab;
  if (tab !== overTab) {
    if (overTab && overTab.rendered) {
      overTab.onMouseLeave(e);
      me._overTab = null;
    }
    if (tab) {
      tab.onMouseEnter(e);
      me._overTab = tab;
      if (!tab.disabled) {
        me.el.setStyle('cursor', 'pointer');
      }
    } else {
      me.el.setStyle('cursor', 'default');
    }
  }
}, onMouseLeave:function(e) {
  var overTab = this._overTab;
  if (overTab && overTab.rendered) {
    overTab.onMouseLeave(e);
  }
}, getTabInfoFromPoint:function(xy) {
  var me = this, tabs = me.items.items, length = tabs.length, innerCt = me.layout.innerCt, innerCtXY = innerCt.getXY(), point = new Ext.util.Point(xy[0], xy[1]), i = 0, lastBox, tabRegion, closeEl, close, closeXY, closeX, closeY, closeWidth, closeHeight, tabX, tabY, tabWidth, tabHeight, closeRegion, isTabReversed, direction, tab;
  for (; i < length; i++) {
    tab = tabs[i];
    lastBox = tab.lastBox;
    if (!lastBox || !tab.isTab) {
      continue;
    }
    tabX = innerCtXY[0] + lastBox.x;
    tabY = innerCtXY[1] - innerCt.dom.scrollTop + lastBox.y;
    tabWidth = lastBox.width;
    tabHeight = lastBox.height;
    tabRegion = new Ext.util.Region(tabY, tabX + tabWidth, tabY + tabHeight, tabX);
    if (tabRegion.contains(point)) {
      closeEl = tab.closeEl;
      if (closeEl) {
        if (me._isTabReversed === undefined) {
          me._isTabReversed = isTabReversed = tab.btnWrap.dom.currentStyle.filter.indexOf('rotation\x3d2') !== -1;
        }
        direction = isTabReversed ? this._reverseDockNames[me.dock] : me.dock;
        closeWidth = closeEl.getWidth();
        closeHeight = closeEl.getHeight();
        closeXY = me.getCloseXY(closeEl, tabX, tabY, tabWidth, tabHeight, closeWidth, closeHeight, direction);
        closeX = closeXY[0];
        closeY = closeXY[1];
        closeRegion = new Ext.util.Region(closeY, closeX + closeWidth, closeY + closeHeight, closeX);
        close = closeRegion.contains(point);
      }
      break;
    }
  }
  return {tab:tab, close:close};
}, getCloseXY:function(closeEl, tabX, tabY, tabWidth, tabHeight, closeWidth, closeHeight, direction) {
  var closeXY = closeEl.getXY(), closeX, closeY;
  if (direction === 'right') {
    closeX = tabX + tabWidth - (closeXY[1] - tabY + closeHeight);
    closeY = tabY + (closeXY[0] - tabX);
  } else {
    closeX = tabX + (closeXY[1] - tabY);
    closeY = tabY + tabX + tabHeight - closeXY[0] - closeWidth;
  }
  return [closeX, closeY];
}, closeTab:function(toClose) {
  var me = this, card = toClose.card, tabPanel = me.tabPanel, toActivate;
  if (card && card.fireEvent('beforeclose', card) === false) {
    return false;
  }
  toActivate = me.findNextActivatable(toClose);
  Ext.suspendLayouts();
  if (toActivate) {
    if (tabPanel) {
      tabPanel.setActiveTab(toActivate.card);
    } else {
      me.setActiveTab(toActivate);
    }
    toActivate.focus();
  }
  if (tabPanel && card) {
    delete toClose.ownerCt;
    card.fireEvent('close', card);
    tabPanel.remove(card);
    if (card.ownerCt !== tabPanel) {
      toClose.fireClose();
      me.remove(toClose);
    } else {
      toClose.ownerCt = me;
      Ext.resumeLayouts(true);
      return false;
    }
  }
  Ext.resumeLayouts(true);
}, findNextActivatable:function(toClose) {
  var me = this, previousTab = me.previousTab, nextTab;
  if (toClose.active && me.items.getCount() > 1) {
    if (previousTab && previousTab !== toClose && !previousTab.disabled) {
      nextTab = previousTab;
    } else {
      nextTab = toClose.next('tab[disabled\x3dfalse]') || toClose.prev('tab[disabled\x3dfalse]');
    }
  }
  return nextTab || me.activeTab;
}, setActiveTab:function(tab, initial) {
  var me = this;
  if (!tab.disabled && tab !== me.activeTab) {
    if (me.activeTab) {
      if (me.activeTab.destroyed) {
        me.previousTab = null;
      } else {
        me.previousTab = me.activeTab;
        me.activeTab.deactivate();
        me.deactivateFocusable(me.activeTab);
      }
    }
    tab.activate();
    me.activateFocusable(tab);
    me.activeTab = tab;
    me.needsScroll = true;
    if (!initial) {
      me.fireEvent('change', me, tab, tab.card);
      me.updateLayout();
    }
  }
}, privates:{adjustTabPositions:function() {
  var me = this, items = me.items.items, i = items.length, tab, lastBox, el, rotation, prop;
  if (!Ext.isIE8) {
    prop = me._getTabAdjustProp();
    while (i--) {
      tab = items[i];
      el = tab.el;
      lastBox = tab.lastBox;
      rotation = tab.isTab ? tab.getActualRotation() : 0;
      if (rotation === 1 && tab.isVisible()) {
        el.setStyle(prop, lastBox.x + lastBox.width + 'px');
      } else {
        if (rotation === 2 && tab.isVisible()) {
          el.setStyle(prop, lastBox.x - lastBox.height + 'px');
        }
      }
    }
  }
}, applyTargetCls:function(targetCls) {
  this.bodyTargetCls = targetCls;
}, _getTabAdjustProp:function() {
  return 'left';
}, getTargetEl:function() {
  return this.body || this.frameBody || this.el;
}, onClick:function(e, target) {
  var me = this, tabEl, tab, isCloseClick, tabInfo;
  if (e.getTarget('.x-box-scroller')) {
    return;
  }
  if (Ext.isIE8 && me.vertical) {
    tabInfo = me.getTabInfoFromPoint(e.getXY());
    tab = tabInfo.tab;
    isCloseClick = tabInfo.close;
  } else {
    tabEl = e.getTarget('.' + Ext.tab.Tab.prototype.baseCls);
    tab = tabEl && Ext.getCmp(tabEl.id);
    isCloseClick = tab && tab.closeEl && target === tab.closeEl.dom;
  }
  if (isCloseClick) {
    e.preventDefault();
  }
  if (tab && tab.isDisabled && !tab.isDisabled()) {
    tab.beforeClick(isCloseClick);
    if (tab.closable && isCloseClick) {
      tab.onCloseClick();
    } else {
      me.doActivateTab(tab);
    }
  }
}, onOverflowMenuItemClick:function(menu, item, e, eOpts) {
  var tab = item && item.masterComponent, overflowHandler = this.layout.overflowHandler;
  if (tab && !tab.isDisabled()) {
    this.doActivateTab(tab);
    if (overflowHandler.menuTrigger) {
      overflowHandler.menuTrigger.focus();
    }
  }
}, doActivateTab:function(tab) {
  var tabPanel = this.tabPanel;
  if (tabPanel) {
    if (!tab.disabled) {
      tabPanel.setActiveTab(tab.card);
    }
  } else {
    this.setActiveTab(tab);
  }
}, onFocusableContainerFocus:function(e) {
  var me = this, mixin = me.mixins.focusablecontainer, child;
  child = mixin.onFocusableContainerFocus.call(me, e);
  if (child && child.isTab) {
    me.doActivateTab(child);
  }
}, onFocusableContainerFocusEnter:function(e) {
  var me = this, mixin = me.mixins.focusablecontainer, child;
  child = mixin.onFocusableContainerFocusEnter.call(me, e);
  if (child && child.isTab) {
    me.doActivateTab(child);
  }
}, focusChild:function(child, forward) {
  var me = this, mixin = me.mixins.focusablecontainer, nextChild;
  nextChild = mixin.focusChild.call(me, child, forward);
  if (me.activateOnFocus && nextChild && nextChild.isTab) {
    me.doActivateTab(nextChild);
  }
}}}, 0, ['tabbar'], ['component', 'box', 'container', 'tabbar'], {'component':true, 'box':true, 'container':true, 'tabbar':true}, ['widget.tabbar'], 0, [Ext.tab, 'Bar'], 0);
Ext.cmd.derive('Ext.tab.Panel', Ext.panel.Panel, {alternateClassName:['Ext.TabPanel'], config:{tabBar:undefined, tabPosition:'top', tabRotation:'default', tabStretchMax:true}, removePanelHeader:true, plain:false, itemCls:'x-tabpanel-child', minTabWidth:undefined, maxTabWidth:undefined, deferredRender:true, _defaultTabRotation:{top:0, right:1, bottom:0, left:2}, initComponent:function() {
  var me = this, activeTab = me.activeTab !== null ? me.activeTab || 0 : null, dockedItems = me.dockedItems, header = me.header, tabBarHeaderPosition = me.tabBarHeaderPosition, tabBar = me.getTabBar(), headerItems;
  me.layout = Ext.apply({type:'card', deferredRender:me.deferredRender, itemCls:me.itemCls, activeItem:activeTab}, me.layout);
  if (tabBarHeaderPosition != null) {
    header = me.header = Ext.apply({}, header);
    headerItems = header.items = header.items ? header.items.slice() : [];
    header.itemPosition = tabBarHeaderPosition;
    headerItems.push(tabBar);
    header.hasTabBar = true;
  } else {
    dockedItems = [].concat(me.dockedItems || []);
    dockedItems.push(tabBar);
    me.dockedItems = dockedItems;
  }
  Ext.panel.Panel.prototype.initComponent.apply(this, arguments);
  activeTab = me.activeTab = me.getComponent(activeTab);
  if (activeTab) {
    tabBar.setActiveTab(activeTab.tab, true);
  }
}, onRender:function() {
  var items = this.items.items, len = items.length, i;
  Ext.panel.Panel.prototype.onRender.apply(this, arguments);
  for (i = 0; i < len; ++i) {
    items[i].getBind();
  }
}, setActiveTab:function(card) {
  var me = this, previous;
  if (!Ext.isObject(card) || card.isComponent) {
    card = me.getComponent(card);
  }
  previous = me.getActiveTab();
  if (card) {
    Ext.suspendLayouts();
    if (!card.isComponent) {
      card = me.add(card);
    }
    if (previous === card || me.fireEvent('beforetabchange', me, card, previous) === false) {
      Ext.resumeLayouts(true);
      return previous;
    }
    me.activeTab = card;
    me.layout.setActiveItem(card);
    card = me.activeTab = me.layout.getActiveItem();
    if (card && card !== previous) {
      me.tabBar.setActiveTab(card.tab);
      Ext.resumeLayouts(true);
      if (previous !== card) {
        me.fireEvent('tabchange', me, card, previous);
      }
    } else {
      Ext.resumeLayouts(true);
    }
    return card;
  }
  return previous;
}, setActiveItem:function(item) {
  return this.setActiveTab(item);
}, getActiveTab:function() {
  var me = this, result = me.getComponent(me.activeTab);
  if (result && me.items.indexOf(result) !== -1) {
    me.activeTab = result;
  } else {
    me.activeTab = undefined;
  }
  return me.activeTab;
}, applyTabBar:function(tabBar) {
  var me = this, dock = me.tabBarHeaderPosition != null ? me.getHeaderPosition() : me.getTabPosition();
  return new Ext.tab.Bar(Ext.apply({ui:me.ui, dock:dock, tabRotation:me.getTabRotation(), vertical:dock === 'left' || dock === 'right', plain:me.plain, tabStretchMax:me.getTabStretchMax(), tabPanel:me}, tabBar));
}, updateHeaderPosition:function(headerPosition, oldHeaderPosition) {
  var tabBar = this.getTabBar();
  if (tabBar && this.tabBarHeaderPosition != null) {
    tabBar.setDock(headerPosition);
  }
  Ext.panel.Panel.prototype.updateHeaderPosition.call(this, headerPosition, oldHeaderPosition);
}, updateTabPosition:function(tabPosition) {
  var tabBar = this.getTabBar();
  if (tabBar && this.tabBarHeaderPosition == null) {
    tabBar.setDock(tabPosition);
  }
}, updateTabRotation:function(tabRotation) {
  var tabBar = this.getTabBar();
  if (tabBar) {
    tabBar.setTabRotation(tabRotation);
  }
}, onAdd:function(item, index) {
  var me = this, cfg = Ext.apply({}, item.tabConfig), tabBar = me.getTabBar(), ariaDom, defaultConfig = {xtype:'tab', title:item.title, icon:item.icon, iconCls:item.iconCls, glyph:item.glyph, ui:tabBar.ui, card:item, disabled:item.disabled, closable:item.closable, hidden:item.hidden && !item.hiddenByLayout, tooltip:item.tooltip, tabBar:tabBar, tabPosition:tabBar.dock, rotation:tabBar.getTabRotation()};
  if (item.closeText !== undefined) {
    defaultConfig.closeText = item.closeText;
  }
  cfg = Ext.applyIf(cfg, defaultConfig);
  item.tab = me.tabBar.insert(index, cfg);
  item.ariaRole = 'tabpanel';
  ariaDom = item.ariaEl.dom;
  if (ariaDom) {
    ariaDom.setAttribute('aria-labelledby', item.tab.id);
  } else {
    item.ariaRenderAttributes = item.ariaRenderAttributes || {};
    item.ariaRenderAttributes['aria-labelledby'] = item.tab.id;
  }
  item.on({scope:me, enable:me.onItemEnable, disable:me.onItemDisable, beforeshow:me.onItemBeforeShow, iconchange:me.onItemIconChange, iconclschange:me.onItemIconClsChange, glyphchange:me.onItemGlyphChange, titlechange:me.onItemTitleChange});
  if (item.isPanel) {
    if (me.removePanelHeader) {
      if (item.rendered) {
        if (item.header) {
          item.header.hide();
        }
      } else {
        item.header = false;
      }
    }
    if (item.isPanel && me.border) {
      item.setBorder(false);
    }
  }
  if (me.rendered) {
    item.getBind();
  }
  if (me.rendered && me.loader && me.activeTab === undefined && me.layout.activeItem !== null) {
    me.setActiveTab(0);
  }
}, onMove:function(item, fromIdx, toIdx) {
  var tabBar = this.getTabBar();
  Ext.panel.Panel.prototype.onMove.call(this, item, fromIdx, toIdx);
  if (tabBar.items.indexOf(item.tab) !== toIdx) {
    tabBar.move(item.tab, toIdx);
  }
}, onItemEnable:function(item) {
  item.tab.enable();
}, onItemDisable:function(item) {
  item.tab.disable();
}, onItemBeforeShow:function(item) {
  if (item !== this.activeTab) {
    this.setActiveTab(item);
    return false;
  }
}, onItemGlyphChange:function(item, newGlyph) {
  item.tab.setGlyph(newGlyph);
}, onItemIconChange:function(item, newIcon) {
  item.tab.setIcon(newIcon);
}, onItemIconClsChange:function(item, newIconCls) {
  item.tab.setIconCls(newIconCls);
}, onItemTitleChange:function(item, newTitle) {
  item.tab.setText(newTitle);
}, onRemove:function(item, destroying) {
  var me = this;
  item.un({scope:me, enable:me.onItemEnable, disable:me.onItemDisable, beforeshow:me.onItemBeforeShow, iconchange:me.onItemIconChange, iconclschange:me.onItemIconClsChange, glyphchange:me.onItemGlyphChange, titlechange:me.onItemTitleChange});
  if (item.tab && !me.destroying && item.tab.ownerCt === me.tabBar) {
    me.tabBar.remove(item.tab);
  }
}, enable:function() {
  var me = this, activeTab = me.activeTab !== null ? me.activeTab || 0 : null, wasDisabled = me.disabled;
  Ext.panel.Panel.prototype.enable.apply(this, arguments);
  if (wasDisabled) {
    activeTab = activeTab.isComponent ? activeTab : me.getComponent(activeTab);
    if (activeTab) {
      me.getTabBar().setActiveTab(activeTab.tab);
    }
  }
  return me;
}, privates:{doRemove:function(item, autoDestroy) {
  var me = this, toActivate;
  Ext.suspendLayouts();
  if (me.removingAll || me.destroying || me.items.getCount() === 1) {
    me.activeTab = null;
  } else {
    if (item.tab && (toActivate = me.tabBar.items.indexOf(me.tabBar.findNextActivatable(item.tab))) !== -1) {
      me.setActiveTab(toActivate);
    }
  }
  Ext.panel.Panel.prototype.doRemove.call(this, item, autoDestroy);
  Ext.resumeLayouts();
  if (item.tab) {
    delete item.tab.card;
    delete item.tab;
  }
}}}, 0, ['tabpanel'], ['component', 'box', 'container', 'panel', 'tabpanel'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tabpanel':true}, ['widget.tabpanel'], 0, [Ext.tab, 'Panel', Ext, 'TabPanel'], 0);
Ext.cmd.derive('Ext.toolbar.Fill', Ext.Component, {alternateClassName:'Ext.Toolbar.Fill', ariaRole:'presentation', isFill:true, flex:1}, 0, ['tbfill'], ['component', 'box', 'tbfill'], {'component':true, 'box':true, 'tbfill':true}, ['widget.tbfill'], 0, [Ext.toolbar, 'Fill', Ext.Toolbar, 'Fill'], 0);
Ext.cmd.derive('Ext.toolbar.Spacer', Ext.Component, {alternateClassName:'Ext.Toolbar.Spacer', baseCls:'x-toolbar-spacer', ariaRole:'presentation'}, 0, ['tbspacer'], ['component', 'box', 'tbspacer'], {'component':true, 'box':true, 'tbspacer':true}, ['widget.tbspacer'], 0, [Ext.toolbar, 'Spacer', Ext.Toolbar, 'Spacer'], 0);
Ext.cmd.derive('Ext.tree.Column', Ext.grid.column.Column, {tdCls:'x-grid-cell-treecolumn', autoLock:true, lockable:false, draggable:false, hideable:false, iconCls:'x-tree-icon', checkboxCls:'x-tree-checkbox', elbowCls:'x-tree-elbow', expanderCls:'x-tree-expander', textCls:'x-tree-node-text', innerCls:'x-grid-cell-inner-treecolumn', customIconCls:'x-tree-icon-custom', isTreeColumn:true, cellTpl:['\x3ctpl for\x3d"lines"\x3e', '\x3cdiv class\x3d"{parent.childCls} {parent.elbowCls}-img ', '{parent.elbowCls}-\x3ctpl if\x3d"."\x3eline\x3ctpl else\x3eempty\x3c/tpl\x3e" role\x3d"presentation"\x3e\x3c/div\x3e', 
'\x3c/tpl\x3e', '\x3cdiv class\x3d"{childCls} {elbowCls}-img {elbowCls}', '\x3ctpl if\x3d"isLast"\x3e-end\x3c/tpl\x3e\x3ctpl if\x3d"expandable"\x3e-plus {expanderCls}\x3c/tpl\x3e" role\x3d"presentation"\x3e\x3c/div\x3e', '\x3ctpl if\x3d"checked !\x3d\x3d null"\x3e', '\x3cdiv role\x3d"button" {ariaCellCheckboxAttr}', ' class\x3d"{childCls} {checkboxCls}\x3ctpl if\x3d"checked"\x3e {checkboxCls}-checked\x3c/tpl\x3e"\x3e\x3c/div\x3e', '\x3c/tpl\x3e', '\x3ctpl if\x3d"glyph"\x3e', '\x3cspan class\x3d"{baseIconCls}" ', 
'\x3ctpl if\x3d"glyphFontFamily"\x3e', 'style\x3d"font-family:{glyphFontFamily}"', '\x3c/tpl\x3e', '\x3e{glyph}\x3c/span\x3e', '\x3ctpl else\x3e', '\x3ctpl if\x3d"icon"\x3e', '\x3cimg src\x3d"{blankUrl}"', '\x3ctpl else\x3e', '\x3cdiv', '\x3c/tpl\x3e', ' role\x3d"presentation" class\x3d"{childCls} {baseIconCls} {customIconCls} ', '{baseIconCls}-\x3ctpl if\x3d"leaf"\x3eleaf\x3ctpl else\x3e\x3ctpl if\x3d"expanded"\x3eparent-expanded\x3ctpl else\x3eparent\x3c/tpl\x3e\x3c/tpl\x3e {iconCls}" ', '\x3ctpl if\x3d"icon"\x3estyle\x3d"background-image:url({icon})"/\x3e\x3ctpl else\x3e\x3e\x3c/div\x3e\x3c/tpl\x3e', 
'\x3c/tpl\x3e', '\x3ctpl if\x3d"href"\x3e', '\x3ca href\x3d"{href}" role\x3d"link" target\x3d"{hrefTarget}" class\x3d"{textCls} {childCls}"\x3e{value}\x3c/a\x3e', '\x3ctpl else\x3e', '\x3cspan class\x3d"{textCls} {childCls}"\x3e{value}\x3c/span\x3e', '\x3c/tpl\x3e'], uiFields:{checked:1, icon:1, iconCls:1}, rowFields:{expanded:1, loaded:1, expandable:1, leaf:1, loading:1, qtip:1, qtitle:1, cls:1}, initComponent:function() {
  var me = this;
  me.rendererScope = me.scope;
  me.setupRenderer();
  me.innerRenderer = me.renderer;
  me.renderer = me.treeRenderer;
  Ext.grid.column.Column.prototype.initComponent.call(this);
  me.scope = me;
  me.hasCustomRenderer = me.innerRenderer && me.innerRenderer.length > 1;
}, treeRenderer:function(value, metaData, record, rowIdx, colIdx, store, view) {
  var me = this, cls = record.get('cls'), rendererData;
  if (metaData && cls) {
    metaData.tdCls += ' ' + cls;
  }
  rendererData = me.initTemplateRendererData(value, metaData, record, rowIdx, colIdx, store, view);
  return me.lookupTpl('cellTpl').apply(rendererData);
}, initTemplateRendererData:function(value, metaData, record, rowIdx, colIdx, store, view) {
  var me = this, innerRenderer = me.innerRenderer, data = record.data, parent = record.parentNode, rootVisible = view.rootVisible, lines = [], parentData, glyph, glyphFontFamily;
  while (parent && (rootVisible || parent.data.depth > 0)) {
    parentData = parent.data;
    lines[rootVisible ? parentData.depth : parentData.depth - 1] = parent.isLastVisible() ? 0 : 1;
    parent = parent.parentNode;
  }
  if (metaData) {
    metaData.iconCls = metaData.icon = metaData.glyph = null;
  } else {
    metaData = {};
  }
  value = innerRenderer ? innerRenderer.apply(me.rendererScope, arguments) : value;
  glyph = metaData.glyph || data.glyph;
  if (glyph) {
    glyph = Ext.Glyph.fly(glyph);
    glyphFontFamily = glyph.fontFamily;
    glyph = glyph.character;
  }
  return {record:record, baseIconCls:me.iconCls, customIconCls:data.icon || data.iconCls ? me.customIconCls : '', glyph:glyph, glyphFontFamily:glyphFontFamily, iconCls:metaData.iconCls || data.iconCls, icon:metaData.icon || data.icon, checkboxCls:me.checkboxCls, checked:data.checked, elbowCls:me.elbowCls, expanderCls:me.expanderCls, textCls:me.textCls, leaf:data.leaf, expandable:record.isExpandable(), expanded:data.expanded, isLast:record.isLastVisible(), blankUrl:Ext.BLANK_IMAGE_URL, href:data.href, 
  hrefTarget:data.hrefTarget, lines:lines, metaData:metaData, childCls:me.getChildCls ? me.getChildCls() + ' ' : '', value:value || store.defaultRootText};
}, shouldUpdateCell:function(record, changedFieldNames) {
  var me = this, i = 0, len, field;
  if (me.hasCustomRenderer) {
    return 1;
  }
  if (changedFieldNames) {
    len = changedFieldNames.length;
    for (; i < len; ++i) {
      field = changedFieldNames[i];
      if (me.rowFields[field]) {
        return 1;
      }
      if (me.uiFields[field]) {
        return 2;
      }
    }
  }
  return Ext.grid.column.Column.prototype.shouldUpdateCell.call(this, record, changedFieldNames);
}}, 0, ['treecolumn'], ['component', 'box', 'container', 'headercontainer', 'gridcolumn', 'treecolumn'], {'component':true, 'box':true, 'container':true, 'headercontainer':true, 'gridcolumn':true, 'treecolumn':true}, ['widget.treecolumn'], 0, [Ext.tree, 'Column'], 0);
Ext.cmd.derive('Ext.tree.NavigationModel', Ext.grid.NavigationModel, {initKeyNav:function(view) {
  var me = this, columns = me.view.ownerGrid.columns;
  me.isTreeGrid = columns && columns.length > 1;
  Ext.grid.NavigationModel.prototype.initKeyNav.call(this, view);
  me.view.grid.on({columnschanged:me.onColumnsChanged, scope:me});
}, onKeyNavCreate:function(keyNav) {
  var fn = this.onAsterisk;
  keyNav.map.addBinding([{key:'8', shift:true, handler:fn, scope:this}, {key:Ext.event.Event.NUM_MULTIPLY, handler:fn, scope:this}]);
}, onColumnsChanged:function() {
  this.isTreeGrid = this.view.ownerGrid.getVisibleColumnManager().getColumns().length > 1;
}, onCellClick:function(view, cell, cellIndex, record, row, recordIndex, clickEvent) {
  Ext.grid.NavigationModel.prototype.onCellClick.call(this, view, cell, cellIndex, record, row, recordIndex, clickEvent);
  return !clickEvent.nodeToggled;
}, onKeyLeft:function(keyEvent) {
  var me = this, view = keyEvent.view, record = me.record;
  if (me.isTreeGrid && !keyEvent.ctrlKey) {
    return Ext.grid.NavigationModel.prototype.onKeyLeft.call(this, keyEvent);
  }
  if (keyEvent.position.column.isTreeColumn && record.isExpanded()) {
    view.collapse(record);
  } else {
    record = record.parentNode;
    if (record && !(record.isRoot() && !view.rootVisible)) {
      me.setPosition(record, null, keyEvent);
    }
  }
}, onKeyRight:function(keyEvent) {
  var me = this, record = me.record;
  if (me.isTreeGrid && !keyEvent.ctrlKey) {
    return Ext.grid.NavigationModel.prototype.onKeyRight.call(this, keyEvent);
  }
  if (!record.isLeaf()) {
    if (keyEvent.position.column.isTreeColumn && !record.isExpanded()) {
      keyEvent.view.expand(record);
    } else {
      if (record.isExpanded()) {
        record = record.childNodes[0];
        if (record) {
          me.setPosition(record);
        }
      }
    }
  }
}, onKeyEnter:function(keyEvent) {
  if (this.record.data.checked != null) {
    this.toggleCheck(keyEvent);
  } else {
    Ext.grid.NavigationModel.prototype.onKeyEnter.call(this, keyEvent);
  }
}, onKeySpace:function(keyEvent) {
  if (this.record.data.checked != null) {
    this.toggleCheck(keyEvent);
  } else {
    Ext.grid.NavigationModel.prototype.onKeySpace.call(this, keyEvent);
  }
}, toggleCheck:function(keyEvent) {
  this.view.onCheckChange(keyEvent);
}, onAsterisk:function(keyEvent) {
  this.view.ownerGrid.expandAll();
}}, 0, 0, 0, 0, ['view.navigation.tree'], 0, [Ext.tree, 'NavigationModel'], 0);
Ext.cmd.derive('Ext.tree.View', Ext.view.Table, {config:{selectionModel:{type:'treemodel'}}, isTreeView:true, loadingCls:'x-grid-tree-loading', expandedCls:'x-grid-tree-node-expanded', leafCls:'x-grid-tree-node-leaf', expanderSelector:'.x-tree-expander', checkboxSelector:'.x-tree-checkbox', expanderIconOverCls:'x-tree-expander-over', nodeAnimWrapCls:'x-tree-animator-wrap', ariaRole:'treegrid', loadMask:false, rootVisible:true, expandDuration:250, collapseDuration:250, toggleOnDblClick:true, stripeRows:false, 
treeRowTpl:['{%', 'this.processRowValues(values);', 'this.nextTpl.applyOut(values, out, parent);', '%}', {priority:10, processRowValues:function(rowValues) {
  var record = rowValues.record, view = rowValues.view;
  rowValues.rowAttr['data-qtip'] = record.get('qtip') || '';
  rowValues.rowAttr['data-qtitle'] = record.get('qtitle') || '';
  rowValues.rowAttr['aria-level'] = record.getDepth() + 1;
  if (record.isLeaf()) {
    rowValues.rowClasses.push(view.leafCls);
  } else {
    if (record.isExpanded()) {
      rowValues.rowClasses.push(view.expandedCls);
      rowValues.rowAttr['aria-expanded'] = true;
    } else {
      rowValues.rowAttr['aria-expanded'] = false;
    }
  }
  if (record.isLoading()) {
    rowValues.rowClasses.push(view.loadingCls);
  }
}}], initComponent:function() {
  var me = this;
  if (me.bufferedRenderer) {
    me.animate = false;
  } else {
    if (me.initialConfig.animate === undefined) {
      me.animate = Ext.enableFx;
    }
  }
  me.store = me.panel.getStore();
  me.onRootChange(me.store.getRoot());
  me.animQueue = {};
  me.animWraps = {};
  Ext.view.Table.prototype.initComponent.call(this);
  me.store.setRootVisible(me.rootVisible);
  me.addRowTpl(me.lookupTpl('treeRowTpl'));
}, onFillComplete:function(treeStore, fillRoot, newNodes) {
  var me = this, store = me.store, start = store.indexOf(newNodes[0]);
  fillRoot.triggerUIUpdate();
  if (!newNodes.length || start === -1) {
    return;
  }
  me.onAdd(me.store, newNodes, start);
  me.refreshPartner();
}, refreshPartner:function() {
  var partner = this.lockingPartner;
  if (partner) {
    partner.refresh();
  }
}, afterRender:function() {
  var me = this;
  Ext.view.Table.prototype.afterRender.call(this);
  me.el.on({scope:me, delegate:me.expanderSelector, mouseover:me.onExpanderMouseOver, mouseout:me.onExpanderMouseOut});
}, processUIEvent:function(e) {
  if (e.getTarget('.' + this.nodeAnimWrapCls, this.el)) {
    return false;
  }
  return Ext.view.Table.prototype.processUIEvent.call(this, e);
}, setRootNode:function(node) {
  this.node = node;
}, getChecked:function() {
  var checked = [];
  this.node.cascade(function(rec) {
    if (rec.get('checked')) {
      checked.push(rec);
    }
  });
  return checked;
}, isItemChecked:function(rec) {
  return rec.get('checked');
}, createAnimWrap:function(record, index) {
  var me = this, node = me.getNode(record), tmpEl;
  tmpEl = Ext.fly(node).insertSibling({role:'presentation', tag:'div', cls:me.nodeAnimWrapCls}, 'after');
  return {record:record, node:node, el:tmpEl, expanding:false, collapsing:false, animateEl:tmpEl, targetEl:tmpEl};
}, getAnimWrap:function(parent, bubble) {
  if (!this.animate) {
    return null;
  }
  var wraps = this.animWraps, wrap = wraps[parent.internalId];
  if (bubble !== false) {
    while (!wrap && parent) {
      parent = parent.parentNode;
      if (parent) {
        wrap = wraps[parent.internalId];
      }
    }
  }
  return wrap;
}, doAdd:function(records, index) {
  var me = this, record = records[0], parent = record.parentNode, all = me.all, relativeIndex, animWrap = me.getAnimWrap(parent), targetEl, childNodes, len, result, children;
  if (!animWrap || !animWrap.expanding) {
    return Ext.view.Table.prototype.doAdd.call(this, records, index);
  }
  result = me.bufferRender(records, index, true);
  children = result.children;
  parent = animWrap.record;
  targetEl = animWrap.targetEl;
  childNodes = targetEl.dom.childNodes;
  len = childNodes.length;
  relativeIndex = index - me.indexInStore(parent) - 1;
  if (!len || relativeIndex >= len) {
    targetEl.appendChild(result.fragment, true);
  } else {
    Ext.fly(childNodes[relativeIndex]).insertSibling(children, 'before', true);
  }
  all.insert(index, children);
  return children;
}, onRemove:function(ds, records, index) {
  var me = this, empty, i, oldItems;
  if (me.viewReady) {
    empty = me.store.getCount() === 0;
    if (me.bufferedRenderer) {
      return Ext.view.Table.prototype.onRemove.call(this, ds, records, index);
    }
    oldItems = this.all.slice(index, index + records.length);
    if (empty) {
      me.refresh();
    } else {
      for (i = records.length - 1, index += i; i >= 0; --i, --index) {
        me.doRemove(records[i], index);
      }
      me.refreshSizePending = true;
    }
    me.fireItemMutationEvent('itemremove', records, index, oldItems, me);
  }
}, doRemove:function(record, index) {
  var me = this, all = me.all, animWrap = me.getAnimWrap(record), item = all.item(index), node = item ? item.dom : null;
  if (!node || !animWrap || !animWrap.collapsing) {
    return Ext.view.Table.prototype.doRemove.call(this, record, index);
  }
  animWrap.targetEl.dom.insertBefore(node, animWrap.targetEl.dom.firstChild);
  all.removeElement(index);
}, onBeforeExpand:function(parent, records, index) {
  var me = this, animWrap;
  if (me.rendered && me.all.getCount() && me.animate) {
    if (me.getNode(parent)) {
      animWrap = me.getAnimWrap(parent, false);
      if (!animWrap) {
        animWrap = me.animWraps[parent.internalId] = me.createAnimWrap(parent);
        animWrap.animateEl.setHeight(0);
      } else {
        if (animWrap.collapsing) {
          animWrap.targetEl.select(me.itemSelector).destroy();
        }
      }
      animWrap.expanding = true;
      animWrap.collapsing = false;
    }
  }
}, onExpand:function(parent) {
  var me = this, queue = me.animQueue, id = parent.getId(), node = me.getNode(parent), index = node ? me.indexOf(node) : -1, animWrap, animateEl, targetEl;
  if (me.singleExpand) {
    me.ensureSingleExpand(parent);
  }
  if (index === -1) {
    return;
  }
  animWrap = me.getAnimWrap(parent, false);
  if (!animWrap) {
    parent.isExpandingOrCollapsing = false;
    me.fireEvent('afteritemexpand', parent, index, node);
    return;
  }
  animateEl = animWrap.animateEl;
  targetEl = animWrap.targetEl;
  animateEl.stopAnimation();
  queue[id] = true;
  Ext.on('idle', function() {
    animateEl.dom.style.height = '0px';
  }, null, {single:true});
  animateEl.animate({from:{height:0}, to:{height:targetEl.dom.scrollHeight}, duration:me.expandDuration, listeners:{afteranimate:function() {
    var items = targetEl.dom.childNodes, activeEl = Ext.Element.getActiveElement();
    if (items.length) {
      if (!targetEl.contains(activeEl)) {
        activeEl = null;
      }
      animWrap.el.insertSibling(items, 'before', true);
      if (activeEl) {
        Ext.fly(activeEl).focus();
      }
    }
    animWrap.el.destroy();
    queue[id] = null;
    if (!me.destroyed) {
      me.animWraps[animWrap.record.internalId] = null;
    }
  }}, callback:function() {
    parent.isExpandingOrCollapsing = false;
    if (!me.destroyed) {
      me.refreshSize(true);
    }
    me.fireEvent('afteritemexpand', parent, index, node);
  }});
}, onBeforeCollapse:function(parent, records, index, callback, scope) {
  var me = this, animWrap;
  if (me.rendered && me.all.getCount()) {
    if (me.animate) {
      if (parent.getTreeStore().isVisible(parent)) {
        animWrap = me.getAnimWrap(parent);
        if (!animWrap) {
          animWrap = me.animWraps[parent.internalId] = me.createAnimWrap(parent, index);
        } else {
          if (animWrap.expanding) {
            animWrap.targetEl.select(this.itemSelector).destroy();
          }
        }
        animWrap.expanding = false;
        animWrap.collapsing = true;
        animWrap.callback = callback;
        animWrap.scope = scope;
      }
    } else {
      me.onCollapseCallback = callback;
      me.onCollapseScope = scope;
    }
  }
}, onCollapse:function(parent) {
  var me = this, queue = me.animQueue, id = parent.getId(), node = me.getNode(parent), index = node ? me.indexOf(node) : -1, animWrap = me.getAnimWrap(parent), animateEl;
  if (!me.all.getCount() || !parent.isVisible()) {
    return;
  }
  if (!animWrap) {
    parent.isExpandingOrCollapsing = false;
    me.fireEvent('afteritemcollapse', parent, index, node);
    Ext.callback(me.onCollapseCallback, me.onCollapseScope);
    me.onCollapseCallback = me.onCollapseScope = null;
    return;
  }
  animateEl = animWrap.animateEl;
  queue[id] = true;
  animateEl.stopAnimation();
  animateEl.animate({to:{height:0}, duration:me.collapseDuration, listeners:{afteranimate:function() {
    animWrap.el.destroy();
    queue[id] = null;
    if (!me.destroyed) {
      me.animWraps[animWrap.record.internalId] = null;
    }
  }}, callback:function() {
    parent.isExpandingOrCollapsing = false;
    if (!me.destroyed) {
      me.refreshSize(true);
    }
    me.fireEvent('afteritemcollapse', parent, index, node);
    Ext.callback(animWrap.callback, animWrap.scope);
    animWrap.callback = animWrap.scope = null;
  }});
}, isAnimating:function(node) {
  return !!this.animQueue[node.getId()];
}, expand:function(record, deep, callback, scope) {
  var me = this, doAnimate = !!me.animate, result;
  if (!doAnimate || !record.isExpandingOrCollapsing) {
    if (!record.isLeaf()) {
      record.isExpandingOrCollapsing = doAnimate;
    }
    Ext.suspendLayouts();
    result = record.expand(deep, callback, scope);
    Ext.resumeLayouts(true);
    return result;
  }
}, collapse:function(record, deep, callback, scope) {
  var me = this, doAnimate = !!me.animate;
  if (!doAnimate || !record.isExpandingOrCollapsing) {
    if (!record.isLeaf()) {
      record.isExpandingOrCollapsing = doAnimate;
    }
    return record.collapse(deep, callback, scope);
  }
}, toggle:function(record, deep, callback, scope) {
  if (record.isExpanded()) {
    this.collapse(record, deep, callback, scope);
  } else {
    this.expand(record, deep, callback, scope);
  }
}, onItemDblClick:function(record, item, index, e) {
  var me = this, editingPlugin = me.editingPlugin;
  Ext.view.Table.prototype.onItemDblClick.call(this, record, item, index, e);
  if (me.toggleOnDblClick && record.isExpandable() && !(editingPlugin && editingPlugin.clicksToEdit === 2)) {
    me.toggle(record);
  }
}, onCellClick:function(cell, cellIndex, record, row, rowIndex, e) {
  var me = this, column = e.position.column;
  if (column.isTreeColumn) {
    if (e.getTarget(me.checkboxSelector, cell) && record.get('checked') != null) {
      me.onCheckChange(e);
      if (column.stopSelection) {
        e.stopSelection = true;
      }
    } else {
      if (e.getTarget(me.expanderSelector, cell) && record.isExpandable()) {
        me.getNavigationModel().setPosition(e.position);
        me.toggle(record, e.ctrlKey);
        e.nodeToggled = true;
      }
    }
    return Ext.view.Table.prototype.onCellClick.call(this, cell, cellIndex, record, row, rowIndex, e);
  }
}, onCheckChange:function(e) {
  var me = this, record = e.record, wasChecked = record.get('checked'), checked;
  if (wasChecked === 1) {
    checked = true;
  } else {
    checked = !wasChecked;
  }
  me.setChecked(record, checked, e);
}, setChecked:function(record, meChecked, e, options) {
  var me = this, checkPropagation = me.checkPropagationFlags[me.ownerGrid.checkPropagation.toLowerCase()], wasChecked = record.data.checked, halfCheckedValue = me.ownerGrid.triStateCheckbox ? 1 : false, progagateCheck = (!options || options.propagateCheck !== false) && checkPropagation & 1, checkParent = (!options || options.checkParent !== false) && checkPropagation & 2, parentNode, parentChecked, foundCheck, foundClear, childNodes, matchedChildCount = 0, len, i;
  if (me.fireEvent('beforecheckchange', record, wasChecked, e) === false) {
    return;
  }
  if (meChecked !== 1 && progagateCheck) {
    childNodes = record.childNodes;
    len = childNodes.length;
    for (i = 0; i < len; i++) {
      me.setChecked(childNodes[i], meChecked, e, {checkParent:false});
      if (childNodes[i].get('checked') === meChecked) {
        matchedChildCount++;
      }
    }
    if (matchedChildCount !== len) {
      meChecked = matchedChildCount ? halfCheckedValue : false;
    }
  }
  if (record.get('checked') !== meChecked) {
    record.set('checked', meChecked, options);
    me.fireEvent('checkchange', record, meChecked, e);
    if (checkParent && (parentNode = record.parentNode) && (parentChecked = parentNode.data.checked) != null) {
      childNodes = parentNode.childNodes;
      len = childNodes.length;
      if (meChecked === halfCheckedValue) {
        parentChecked = halfCheckedValue;
      } else {
        if (len === 1) {
          parentChecked = meChecked;
        } else {
          foundCheck = foundClear = false;
          for (i = 0; !(foundCheck && foundClear) & i < len; i++) {
            if (childNodes[i].data.checked === 1) {
              foundCheck = foundClear = true;
            } else {
              if (!childNodes[i].data.checked) {
                foundClear = true;
              } else {
                foundCheck = true;
              }
            }
          }
          parentChecked = foundCheck && foundClear ? halfCheckedValue : foundCheck ? true : false;
        }
      }
      if (parentNode.get('checked') !== parentChecked) {
        me.setChecked(parentNode, parentChecked, e, {propagateCheck:false});
      }
    }
  }
}, onExpanderMouseOver:function(e) {
  Ext.fly(e.getTarget(this.cellSelector, 10)).addCls(this.expanderIconOverCls);
}, onExpanderMouseOut:function(e) {
  Ext.fly(e.getTarget(this.cellSelector, 10)).removeCls(this.expanderIconOverCls);
}, getStoreListeners:function() {
  return Ext.apply(Ext.view.Table.prototype.getStoreListeners.call(this), {rootchange:this.onRootChange, fillcomplete:this.onFillComplete});
}, onBindStore:function(store, initial, propName, oldStore) {
  var oldRoot = oldStore && oldStore.getRootNode(), newRoot = store && store.getRootNode();
  Ext.view.Table.prototype.onBindStore.call(this, store, initial, propName, oldStore);
  if (newRoot !== oldRoot) {
    this.onRootChange(newRoot, oldRoot);
  }
}, onRootChange:function(newRoot, oldRoot) {
  var me = this, grid = me.grid;
  if (oldRoot) {
    me.rootListeners.destroy();
    me.rootListeners = null;
  }
  if (newRoot) {
    me.rootListeners = newRoot.on({beforeexpand:me.onBeforeExpand, expand:me.onExpand, beforecollapse:me.onBeforeCollapse, collapse:me.onCollapse, destroyable:true, scope:me});
    grid.addRelayers(newRoot);
  }
}, ensureSingleExpand:function(node) {
  var parent = node.parentNode;
  if (parent) {
    parent.eachChild(function(child) {
      if (child !== node && child.isExpanded()) {
        child.collapse();
      }
    });
  }
}, privates:{checkPropagationFlags:{none:0, down:1, up:2, both:3}, deferRefreshForLoad:function(store) {
  var ret = Ext.view.Table.prototype.deferRefreshForLoad.call(this, store), options, node;
  if (ret) {
    options = store.lastOptions;
    node = options && options.node;
    if (node && node !== store.getRoot()) {
      ret = false;
    }
  }
  return ret;
}}}, 0, ['treeview'], ['component', 'box', 'dataview', 'tableview', 'gridview', 'treeview'], {'component':true, 'box':true, 'dataview':true, 'tableview':true, 'gridview':true, 'treeview':true}, ['widget.treeview'], 0, [Ext.tree, 'View'], 0);
Ext.cmd.derive('Ext.tree.Panel', Ext.panel.Table, {alternateClassName:['Ext.tree.TreePanel', 'Ext.TreePanel'], viewType:'treeview', treeCls:'x-tree-panel', rowLines:false, lines:true, useArrows:false, singleExpand:false, ddConfig:{enableDrag:true, enableDrop:true}, rootVisible:true, displayField:'text', root:null, checkPropagation:'none', normalCfgCopy:['displayField', 'root', 'singleExpand', 'useArrows', 'lines', 'rootVisible', 'scroll'], lockedCfgCopy:['displayField', 'root', 'singleExpand', 'useArrows', 
'lines', 'rootVisible'], isTree:true, arrowCls:'x-tree-arrows', linesCls:'x-tree-lines', noLinesCls:'x-tree-no-lines', autoWidthCls:'x-autowidth-table', constructor:function(config) {
  config = config || {};
  if (config.animate === undefined) {
    config.animate = Ext.isBoolean(this.animate) ? this.animate : Ext.enableFx;
  }
  this.enableAnimations = config.animate;
  delete config.animate;
  Ext.panel.Table.prototype.constructor.call(this, config);
}, initComponent:function() {
  var me = this, cls = [me.treeCls], store, autoTree, view;
  if (me.useArrows) {
    cls.push(me.arrowCls);
    me.lines = false;
  }
  if (me.lines) {
    cls.push(me.linesCls);
  } else {
    if (!me.useArrows) {
      cls.push(me.noLinesCls);
    }
  }
  store = me.applyStore(me.store);
  if (!store.getRoot()) {
    store.setRoot({});
  }
  store.setRootVisible(me.rootVisible);
  if (!me.columns) {
    me.isAutoTree = autoTree = true;
  }
  me.viewConfig = Ext.apply({rootVisible:me.rootVisible, animate:me.enableAnimations, singleExpand:me.singleExpand, node:store.getRoot(), navigationModel:'tree', isAutoTree:autoTree}, me.viewConfig);
  if (autoTree) {
    me.addCls(me.autoWidthCls);
    me.columns = [{xtype:'treecolumn', text:me.hideHeaders === true ? 'Name' : null, flex:1, dataIndex:me.displayField}];
  }
  if (me.cls) {
    cls.push(me.cls);
  }
  me.cls = cls.join(' ');
  Ext.panel.Table.prototype.initComponent.call(this);
  view = me.getView();
  me.relayEvents(view, ['beforecheckchange', 'checkchange', 'afteritemexpand', 'afteritemcollapse']);
}, applyStore:function(store) {
  var me = this;
  if (Ext.isString(store)) {
    store = me.store = Ext.StoreMgr.lookup(store);
  } else {
    if (!store || !store.isStore) {
      store = Ext.apply({type:'tree', proxy:'memory'}, store);
      if (me.root) {
        store.root = me.root;
      }
      if (me.fields) {
        store.fields = me.fields;
      } else {
        if (me.model) {
          store.model = me.model;
        }
      }
      if (me.folderSort) {
        store.folderSort = me.folderSort;
      }
      store = me.store = Ext.StoreMgr.lookup(store);
    } else {
      if (me.root) {
        store = me.store = Ext.data.StoreManager.lookup(store);
        store.setRoot(me.root);
        if (me.folderSort !== undefined) {
          store.folderSort = me.folderSort;
          store.sort();
        }
      }
    }
  }
  return store;
}, setRoot:function(root) {
  this.store.setRoot(root);
}, setStore:function(store) {
  var me = this;
  store = me.applyStore(store);
  if (!store.getRoot()) {
    store.setRoot({});
  }
  store.setRootVisible(me.rootVisible);
  if (me.enableLocking) {
    me.reconfigure(store);
  } else {
    if (me.view) {
      me.view.setRootNode(store.getRootNode());
    }
    me.bindStore(store);
  }
}, bindStore:function(store, initial) {
  var me = this, root = store.getRoot();
  Ext.panel.Table.prototype.bindStore.apply(this, arguments);
  store.singleExpand = me.singleExpand;
  me.storeListeners = me.mon(store, {destroyable:true, rootchange:me.onRootChange, scope:me});
  me.storeRelayers = me.relayEvents(store, ['beforeload', 'load']);
  if (!me.rootVisible && !store.autoLoad && !(root.isExpanded() || root.isLoading())) {
    if (root.isLoaded()) {
      root.data.expanded = true;
      store.onNodeExpand(root, root.childNodes);
    } else {
      if (store.autoLoad !== false && !store.hasPendingLoad()) {
        root.data.expanded = false;
        root.expand();
      }
    }
  }
  store.ownerTree = me;
  if (!initial) {
    me.view.setRootNode(root);
  }
}, addRelayers:function(newRoot) {
  var me = this;
  if (me.rootRelayers) {
    me.rootRelayers.destroy();
    me.rootRelayers = null;
  }
  me.rootRelayers = me.mon(newRoot, {destroyable:true, append:me.createRelayer('itemappend'), remove:me.createRelayer('itemremove'), move:me.createRelayer('itemmove', [0, 4]), insert:me.createRelayer('iteminsert'), beforeappend:me.createRelayer('beforeitemappend'), beforeremove:me.createRelayer('beforeitemremove'), beforemove:me.createRelayer('beforeitemmove'), beforeinsert:me.createRelayer('beforeiteminsert'), expand:me.createRelayer('itemexpand', [0, 1]), collapse:me.createRelayer('itemcollapse', 
  [0, 1]), beforeexpand:me.createRelayer('beforeitemexpand', [0, 1]), beforecollapse:me.createRelayer('beforeitemcollapse', [0, 1]), scope:me});
}, unbindStore:function() {
  var me = this, store = me.store;
  if (store) {
    Ext.panel.Table.prototype.unbindStore.call(this);
    Ext.destroy(me.storeListeners, me.storeRelayers, me.rootRelayers);
    delete store.ownerTree;
    store.singleExpand = null;
  }
}, setRootNode:function() {
  return this.store.setRoot.apply(this.store, arguments);
}, getRootNode:function() {
  return this.store.getRoot();
}, onRootChange:function(root) {
  this.view.setRootNode(root);
}, getChecked:function() {
  return this.getView().getChecked();
}, isItemChecked:function(rec) {
  return rec.get('checked');
}, expandNode:function(record, deep, callback, scope) {
  return this.getView().expand(record, deep, callback, scope || this);
}, collapseNode:function(record, deep, callback, scope) {
  return this.getView().collapse(record, deep, callback, scope || this);
}, expandAll:function(callback, scope) {
  var me = this, root = me.getRootNode();
  if (root) {
    Ext.suspendLayouts();
    root.expand(true, callback, scope || me);
    Ext.resumeLayouts(true);
  }
}, collapseAll:function(callback, scope) {
  var me = this, root = me.getRootNode(), view = me.getView();
  if (root) {
    Ext.suspendLayouts();
    scope = scope || me;
    if (view.rootVisible) {
      root.collapse(true, callback, scope);
    } else {
      root.collapseChildren(true, callback, scope);
    }
    Ext.resumeLayouts(true);
  }
}, expandPath:function(path, options) {
  var args = arguments, me = this, view = me.view, field = options && options.field || me.store.model.idProperty, select, doFocus, separator = options && options.separator || '/', callback, scope, current, index, keys, rooted, expander;
  if (options && typeof options === 'object') {
    field = options.field || me.store.model.idProperty;
    separator = options.separator || '/';
    callback = options.callback;
    scope = options.scope;
    select = options.select;
    doFocus = options.focus;
  } else {
    field = args[1] || me.store.model.idProperty;
    separator = args[2] || '/';
    callback = args[3];
    scope = args[4];
  }
  if (Ext.isEmpty(path)) {
    return Ext.callback(callback, scope || me, [false, null]);
  }
  keys = path.split(separator);
  rooted = !keys[0];
  if (rooted) {
    current = me.getRootNode();
    index = 1;
  } else {
    current = me.store.findNode(field, keys[0]);
    index = 0;
  }
  if (!current || rooted && current.get(field) + '' !== keys[1]) {
    return Ext.callback(callback, scope || me, [false, current]);
  }
  expander = function(newChildren) {
    var node = this, len, i, value;
    if (++index === keys.length) {
      if (select) {
        view.getSelectionModel().select(node);
      }
      if (doFocus) {
        view.getNavigationModel().setPosition(node, 0);
      }
      return Ext.callback(callback, scope || me, [true, node, view.getNode(node)]);
    }
    for (i = 0, len = newChildren ? newChildren.length : 0; i < len; i++) {
      node = newChildren[i];
      value = node.get(field);
      if (value || value === 0) {
        value = value.toString();
      }
      if (value === keys[index]) {
        return node.expand(false, expander);
      }
    }
    node = this;
    Ext.callback(callback, scope || me, [false, node, view.getNode(node)]);
  };
  current.expand(false, expander);
}, ensureVisible:function(path, options) {
  if (path.isEntity || typeof path === 'number') {
    return Ext.panel.Table.prototype.ensureVisible.call(this, path, options);
  }
  var me = this, field = options && options.field || me.store.model.idProperty, separator = options && options.separator || '/', callback, scope, keys, rooted, last, node, parentNode, onLastExpanded = function(success, lastExpanded, lastExpandedHtmlNode, targetNode) {
    if (!targetNode && success && lastExpanded) {
      targetNode = lastExpanded.findChild(field, last);
    }
    if (targetNode) {
      me.doEnsureVisible(targetNode, options);
    } else {
      Ext.callback(callback, scope || me, [false, lastExpanded]);
    }
  };
  if (options) {
    callback = options.callback;
    scope = options.scope;
  }
  keys = path.split(separator);
  rooted = !keys[0];
  last = keys.pop();
  if (keys.length && !(rooted && keys.length === 1)) {
    me.expandPath(keys.join(separator), field, separator, onLastExpanded);
  } else {
    node = me.store.findNode(field, last);
    if (node) {
      parentNode = node.parentNode;
      if (parentNode && !parentNode.isExpanded()) {
        parentNode.expand();
      }
      onLastExpanded(true, null, null, node);
    } else {
      Ext.callback(callback, scope || me, [false, null]);
    }
  }
}, selectPath:function(path, field, separator, callback, scope) {
  this.ensureVisible(path, {field:field, separator:separator, select:true, callback:callback, scope:scope});
}}, 1, ['treepanel'], ['component', 'box', 'container', 'panel', 'tablepanel', 'treepanel'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'treepanel':true}, ['widget.treepanel'], 0, [Ext.tree, 'Panel', Ext.tree, 'TreePanel', Ext, 'TreePanel'], 0);
Ext.cmd.derive('Ext.window.Toast', Ext.window.Window, {isToast:true, cls:'x-toast', bodyPadding:10, autoClose:true, plain:false, draggable:false, resizable:false, shadow:false, focus:Ext.emptyFn, anchor:null, useXAxis:false, align:'t', alwaysOnTop:true, spacing:6, paddingX:30, paddingY:10, slideInAnimation:'easeIn', slideBackAnimation:'bounceOut', slideInDuration:500, slideBackDuration:500, hideDuration:500, autoCloseDelay:3000, stickOnClick:false, stickWhileHover:true, closeOnMouseDown:false, closable:false, 
minHeight:1, focusable:false, isHiding:false, isFading:false, destroyAfterHide:false, closeOnMouseOut:false, xPos:0, yPos:0, constructor:function(config) {
  config = config || {};
  if (config.animate === undefined) {
    config.animate = Ext.isBoolean(this.animate) ? this.animate : Ext.enableFx;
  }
  this.enableAnimations = config.animate;
  delete config.animate;
  Ext.window.Window.prototype.constructor.call(this, config);
}, initComponent:function() {
  var me = this;
  if (me.autoClose && me.closable == null) {
    me.closable = false;
  }
  me.updateAlignment(me.align);
  me.setAnchor(me.anchor);
  Ext.window.Window.prototype.initComponent.call(this);
}, onRender:function() {
  var me = this;
  Ext.window.Window.prototype.onRender.apply(this, arguments);
  me.el.hover(me.onMouseEnter, me.onMouseLeave, me);
  if (me.closeOnMouseDown) {
    Ext.getDoc().on('mousedown', me.onDocumentMousedown, me);
  }
}, alignmentProps:{br:{paddingFactorX:-1, paddingFactorY:-1, siblingAlignment:'br-br', anchorAlign:'tr-br'}, bl:{paddingFactorX:1, paddingFactorY:-1, siblingAlignment:'bl-bl', anchorAlign:'tl-bl'}, tr:{paddingFactorX:-1, paddingFactorY:1, siblingAlignment:'tr-tr', anchorAlign:'br-tr'}, tl:{paddingFactorX:1, paddingFactorY:1, siblingAlignment:'tl-tl', anchorAlign:'bl-tl'}, b:{paddingFactorX:0, paddingFactorY:-1, siblingAlignment:'b-b', useXAxis:0, anchorAlign:'t-b'}, t:{paddingFactorX:0, paddingFactorY:1, 
siblingAlignment:'t-t', useXAxis:0, anchorAlign:'b-t'}, l:{paddingFactorX:1, paddingFactorY:0, siblingAlignment:'l-l', useXAxis:1, anchorAlign:'r-l'}, r:{paddingFactorX:-1, paddingFactorY:0, siblingAlignment:'r-r', useXAxis:1, anchorAlign:'l-r'}, x:{br:{anchorAlign:'bl-br'}, bl:{anchorAlign:'br-bl'}, tr:{anchorAlign:'tl-tr'}, tl:{anchorAlign:'tr-tl'}}}, updateAlignment:function(align) {
  var me = this, alignmentProps = me.alignmentProps, props = alignmentProps[align], xprops = alignmentProps.x[align];
  if (xprops && me.useXAxis) {
    Ext.applyIf(me, xprops);
  }
  Ext.applyIf(me, props);
}, getXposAlignedToAnchor:function() {
  var me = this, align = me.align, anchor = me.anchor, anchorEl = anchor && anchor.el, el = me.el, xPos = 0;
  if (anchorEl && anchorEl.dom) {
    if (!me.useXAxis) {
      xPos = el.getLeft();
    } else {
      if (align === 'br' || align === 'tr' || align === 'r') {
        xPos += anchorEl.getAnchorXY('r')[0];
        xPos -= el.getWidth() + me.paddingX;
      } else {
        xPos += anchorEl.getAnchorXY('l')[0];
        xPos += me.paddingX;
      }
    }
  }
  return xPos;
}, getYposAlignedToAnchor:function() {
  var me = this, align = me.align, anchor = me.anchor, anchorEl = anchor && anchor.el, el = me.el, yPos = 0;
  if (anchorEl && anchorEl.dom) {
    if (me.useXAxis) {
      yPos = el.getTop();
    } else {
      if (align === 'br' || align === 'bl' || align === 'b') {
        yPos += anchorEl.getAnchorXY('b')[1];
        yPos -= el.getHeight() + me.paddingY;
      } else {
        yPos += anchorEl.getAnchorXY('t')[1];
        yPos += me.paddingY;
      }
    }
  }
  return yPos;
}, getXposAlignedToSibling:function(sibling) {
  var me = this, align = me.align, el = me.el, xPos;
  if (!me.useXAxis) {
    xPos = el.getLeft();
  } else {
    if (align === 'tl' || align === 'bl' || align === 'l') {
      xPos = sibling.xPos + sibling.el.getWidth() + sibling.spacing;
    } else {
      xPos = sibling.xPos - el.getWidth() - me.spacing;
    }
  }
  return xPos;
}, getYposAlignedToSibling:function(sibling) {
  var me = this, align = me.align, el = me.el, yPos;
  if (me.useXAxis) {
    yPos = el.getTop();
  } else {
    if (align === 'tr' || align === 'tl' || align === 't') {
      yPos = sibling.yPos + sibling.el.getHeight() + sibling.spacing;
    } else {
      yPos = sibling.yPos - el.getHeight() - sibling.spacing;
    }
  }
  return yPos;
}, getToasts:function() {
  var anchor = this.anchor, alignment = this.anchorAlign, activeToasts = anchor.activeToasts || (anchor.activeToasts = {});
  return activeToasts[alignment] || (activeToasts[alignment] = []);
}, setAnchor:function(anchor) {
  var me = this, Toast;
  me.anchor = anchor = typeof anchor === 'string' ? Ext.getCmp(anchor) : anchor;
  if (!anchor) {
    Toast = Ext.window.Toast;
    me.anchor = Toast.bodyAnchor || (Toast.bodyAnchor = {el:Ext.getBody()});
  }
}, beforeShow:function() {
  var me = this;
  if (me.stickOnClick) {
    me.body.on('click', function() {
      me.cancelAutoClose();
    });
  }
  if (me.autoClose) {
    if (!me.closeTask) {
      me.closeTask = new Ext.util.DelayedTask(me.doAutoClose, me);
    }
  }
  me.el.setX(-10000);
  me.el.setOpacity(1);
}, afterShow:function() {
  var me = this, el = me.el, activeToasts, sibling, length, xy;
  Ext.window.Window.prototype.afterShow.apply(this, arguments);
  activeToasts = me.getToasts();
  length = activeToasts.length;
  sibling = length && activeToasts[length - 1];
  if (sibling) {
    el.alignTo(sibling.el, me.siblingAlignment, [0, 0]);
    me.xPos = me.getXposAlignedToSibling(sibling);
    me.yPos = me.getYposAlignedToSibling(sibling);
  } else {
    el.alignTo(me.anchor.el, me.anchorAlign, [me.paddingX * me.paddingFactorX, me.paddingY * me.paddingFactorY], false);
    me.xPos = me.getXposAlignedToAnchor();
    me.yPos = me.getYposAlignedToAnchor();
  }
  Ext.Array.include(activeToasts, me);
  if (me.enableAnimations) {
    xy = el.getXY();
    el.animate({from:{x:xy[0], y:xy[1]}, to:{x:me.xPos, y:me.yPos, opacity:1}, easing:me.slideInAnimation, duration:me.slideInDuration, dynamic:true, callback:me.afterPositioned, scope:me});
  } else {
    me.setLocalXY(me.xPos, me.yPos);
    me.afterPositioned();
  }
}, afterPositioned:function() {
  var me = this;
  if (!me.destroying && !me.destroyed && me.autoClose) {
    me.closeTask.delay(me.autoCloseDelay);
  }
}, onDocumentMousedown:function(e) {
  if (this.isVisible() && !this.owns(e.getTarget())) {
    this.hide();
  }
}, slideBack:function() {
  var me = this, anchor = me.anchor, anchorEl = anchor && anchor.el, el = me.el, activeToasts = me.getToasts(), index = Ext.Array.indexOf(activeToasts, me);
  if (!me.isHiding && el && el.dom && anchorEl && anchorEl.isVisible()) {
    if (index) {
      me.xPos = me.getXposAlignedToSibling(activeToasts[index - 1]);
      me.yPos = me.getYposAlignedToSibling(activeToasts[index - 1]);
    } else {
      me.xPos = me.getXposAlignedToAnchor();
      me.yPos = me.getYposAlignedToAnchor();
    }
    me.stopAnimation();
    if (me.enableAnimations) {
      el.animate({to:{x:me.xPos, y:me.yPos}, easing:me.slideBackAnimation, duration:me.slideBackDuration, dynamic:true});
    }
  }
}, update:function() {
  var me = this;
  if (me.isVisible()) {
    me.isHiding = true;
    me.hide();
  }
  Ext.window.Window.prototype.update.apply(this, arguments);
  me.show();
}, cancelAutoClose:function() {
  var closeTask = this.closeTask;
  if (closeTask) {
    closeTask.cancel();
  }
}, doAutoClose:function() {
  var me = this;
  if (!(me.stickWhileHover && me.mouseIsOver)) {
    me.close();
  } else {
    me.closeOnMouseOut = true;
  }
}, doDestroy:function() {
  this.removeFromAnchor();
  this.cancelAutoClose();
  Ext.window.Window.prototype.doDestroy.call(this);
}, onMouseEnter:function() {
  this.mouseIsOver = true;
}, onMouseLeave:function() {
  var me = this;
  me.mouseIsOver = false;
  if (me.closeOnMouseOut) {
    me.closeOnMouseOut = false;
    me.close();
  }
}, removeFromAnchor:function() {
  var me = this, activeToasts, index;
  if (me.anchor) {
    activeToasts = me.getToasts();
    index = Ext.Array.indexOf(activeToasts, me);
    if (index !== -1) {
      Ext.Array.erase(activeToasts, index, 1);
      for (; index < activeToasts.length; index++) {
        activeToasts[index].slideBack();
      }
    }
  }
}, getFocusEl:Ext.emptyFn, hide:function() {
  var me = this, el = me.el;
  me.cancelAutoClose();
  if (me.isHiding) {
    if (!me.isFading) {
      Ext.window.Window.prototype.hide.apply(this, arguments);
      me.isHiding = false;
    }
  } else {
    me.isHiding = true;
    me.isFading = true;
    me.cancelAutoClose();
    if (el) {
      if (me.enableAnimations && !me.destroying && !me.destroyed) {
        el.fadeOut({opacity:0, easing:'easeIn', duration:me.hideDuration, listeners:{scope:me, afteranimate:function() {
          var me = this;
          me.isFading = false;
          if (!me.destroying && !me.destroyed) {
            me.hide(me.animateTarget, me.doClose, me);
          }
        }}});
      } else {
        me.isFading = false;
        me.hide(me.animateTarget, me.doClose, me);
      }
    }
  }
  return me;
}}, 1, ['toast'], ['component', 'box', 'container', 'panel', 'window', 'toast'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'toast':true}, ['widget.toast'], 0, [Ext.window, 'Toast'], function(Toast) {
  Ext.toast = function(message, title, align, iconCls) {
    var config = message, toast;
    if (Ext.isString(message)) {
      config = {title:title, html:message, iconCls:iconCls};
      if (align) {
        config.align = align;
      }
    }
    toast = new Toast(config);
    toast.show();
    return toast;
  };
});
Ext.cmd.derive('Robo.data.Model', Ext.Mixin, {modelName:null, editMementoFix:null, mixinConfig:{before:{endEdit:'onBeforeEndEdit'}, after:{endEdit:'onAfterEndEdit'}}, onBeforeEndEdit:function(silent, modifiedFieldNames) {
  var editMemento = this.editMemento;
  if (editMemento) {
    this.editMementoFix = editMemento;
    if (!modifiedFieldNames) {
      modifiedFieldNames = this.getModifiedFieldNames(editMemento.data);
    }
    if (!editMemento.previousValues) {
      editMemento.previousValues = {};
    }
    Ext.Array.each(modifiedFieldNames, function(fieldName) {
      editMemento.previousValues[fieldName] = editMemento.data[fieldName];
    });
  }
}, onAfterEndEdit:function(silent, modifiedFieldNames) {
  delete this.editMementoFix;
}, getTitle:function() {
  return '';
}}, 0, 0, 0, 0, 0, 0, [Robo.data, 'Model'], 0);
Ext.cmd.derive('Robo.data.Store', Ext.Mixin, {undoRedoPostponed:null, inUndoRedoTransaction:false, undoRedoEventBus:null, mixinConfig:{before:{constructor:'constructor', destroy:'destroy', fireEventArgs:'fireEventArgs', setRoot:'beforeSetRoot', fillNode:'beforeFillNode'}, after:{setRoot:'afterSetRoot', fillNode:'afterFillNode'}}, constructor:function() {
  var me = this;
  me.undoRedoEventBus = new Ext.util.Observable;
}, destroy:function() {
  Ext.destroy(this.undoRedoEventBus);
}, fireEventArgs:function(eventName, args) {
  var me = this;
  if (!args.hasOwnProperty('$undoRedoEventBusFired')) {
    args.$undoRedoEventBusFired = {};
  }
  if (!args.$undoRedoEventBusFired[eventName]) {
    args.$undoRedoEventBusFired[eventName] = true;
    me.undoRedoEventBus.hasListener(eventName) && me.undoRedoEventBus.fireEventArgs(eventName, args);
  }
}, isInUndoRedoTransaction:function() {
  return this.inUndoRedoTransaction;
}, onUndoRedoTransactionStart:function(manager, transaction) {
  this.inUndoRedoTransaction = true;
}, onUndoRedoTransactionEnd:function(manager, transaction) {
  this.inUndoRedoTransaction = false;
}, isUndoingOrRedoing:function() {
  return !!this.undoRedoPostponed;
}, beforeUndoRedo:function(manager) {
  this.undoRedoPostponed = [];
}, afterUndoRedo:function(manager) {
  var me = this;
  if (me.undoRedoPostponed) {
    Ext.Array.forEach(me.undoRedoPostponed, function(fn) {
      fn();
    });
  }
  me.undoRedoPostponed = null;
}, postponeAfterUndoRedo:function(fn) {
  this.undoRedoPostponed.push(fn);
}, beforeSetRoot:function() {
  this.__isSettingRoot = true;
}, afterSetRoot:function() {
  this.__isSettingRoot = false;
  if (!this.getRoot()) {
    this.fireEvent('clear', this);
  }
}, beforeFillNode:function(node) {
  if (node.isRoot()) {
    this.beforeSetRoot();
  }
}, afterFillNode:function(node) {
  if (node.isRoot()) {
    this.afterSetRoot();
  }
}, isRootSettingOrLoading:function() {
  return this.isLoading() || this.isTreeStore && this.__isSettingRoot;
}}, 1, 0, 0, 0, 0, 0, [Robo.data, 'Store'], 0);
Ext.cmd.derive('Sch.crud.AbstractManager', Ext.Base, {isCrudManager:true, revision:null, stores:null, storeIdProperty:'storeId', filterParam:'filter', storesIndex:null, activeRequests:null, delayedSyncs:null, transport:null, trackResponseType:false, phantomIdField:'$PhantomId', autoLoad:false, autoSyncTimeout:100, autoSync:false, resetIdsBeforeSync:true, syncApplySequence:null, writeAllFields:false, destroyed:false, ignoreUpdates:0, loaded:false, createMissingRecords:false, autoSyncTimerId:null, 
applyingLoadResponse:false, applyingSyncResponse:false, constructor:function(config) {
  config = config || {};
  this.mixins.observable.constructor.call(this, config);
  this.activeRequests = {};
  this.delayedSyncs = [];
  this.transport = config.transport || this.transport || {};
  var stores = config.stores || this.stores;
  this.stores = [];
  this.addStore(stores);
  var syncApplySequence = config.syncApplySequence || this.syncApplySequence;
  if (syncApplySequence) {
    this.syncApplySequence = null;
    this.addStoreToApplySequence(syncApplySequence);
  }
  if (this.autoLoad) {
    this.load();
  }
}, updateStoreIndex:function() {
  var storesIndex = {};
  for (var i = 0, l = this.stores.length; i < l; i++) {
    var store = this.stores[i];
    if (store.storeId) {
      storesIndex[store.storeId] = this.stores[i];
    }
  }
  this.storesIndex = storesIndex;
}, getStoreDescriptor:function(storeId) {
  if (!storeId) {
    return;
  }
  if (storeId.isStore) {
    for (var i = 0, l = this.stores.length; i < l; i++) {
      if (this.stores[i].store === storeId) {
        return this.stores[i];
      }
    }
  } else {
    if (typeof storeId == 'object') {
      return this.storesIndex[storeId.storeId];
    } else {
      return this.storesIndex[storeId] || this.getStoreDescriptor(Ext.data.StoreManager.get(storeId));
    }
  }
}, getStore:function(storeId) {
  var storeInfo = this.getStoreDescriptor(storeId);
  return storeInfo && storeInfo.store;
}, forEachStore:function(fn, scope) {
  if (!fn) {
    return;
  }
  var stores = this.stores;
  for (var i = 0, l = stores.length; i < l; i++) {
    if (fn.call(scope || this, stores[i].store, stores[i].storeId, stores[i]) === false) {
      break;
    }
  }
}, addStore:function(store, position, fromStore) {
  if (!store) {
    return;
  }
  if (!Ext.isArray(store)) {
    store = [store];
  }
  var data = [];
  for (var i = 0, l = store.length; i < l; i++) {
    var storeInfo = store[i];
    if (storeInfo.isStore) {
      storeInfo = {store:storeInfo};
    } else {
      if (typeof storeInfo == 'object') {
        if (storeInfo.stores) {
          if (!Ext.isArray(storeInfo.stores)) {
            storeInfo.stores = [storeInfo.stores];
          }
          for (var j = 0, n = storeInfo.stores.length; j < n; j++) {
            var subStore = storeInfo.stores[j], subStoreInfo = subStore;
            if ('string' === typeof subStore) {
              subStoreInfo = {storeId:subStore};
            }
            subStoreInfo.masterStoreInfo = storeInfo;
            storeInfo.stores[j] = subStoreInfo;
          }
        }
      } else {
        storeInfo = {store:Ext.data.StoreManager.get(storeInfo)};
      }
    }
    data.push(this.fillStoreDescriptor(storeInfo));
    if (storeInfo.store.setCrudManager) {
      storeInfo.store.setCrudManager(this);
    } else {
      storeInfo.store.crudManager = this;
    }
    if (storeInfo.store.isTreeStore) {
      storeInfo.store.setProxy({type:'memory'});
    }
    storeInfo.store.setAsynchronousLoad(false);
    this.bindStoreListeners(storeInfo.store);
  }
  if (typeof position === 'undefined') {
    this.stores.push.apply(this.stores, data);
  } else {
    var pos = position;
    if (fromStore) {
      if (fromStore.isStore || typeof fromStore !== 'object') {
        fromStore = this.getStoreDescriptor(fromStore);
      }
      pos += Ext.Array.indexOf(this.stores, fromStore);
    }
    this.stores.splice.apply(this.stores, [].concat([pos, 0], data));
  }
  this.updateStoreIndex();
}, bindStoreListeners:function(store, un) {
  var listeners = {update:this.onStoreUpdate, clear:this.onStoreChange, scope:this};
  if (store.isTreeStore) {
    Ext.apply(listeners, {nodeappend:this.onTreeStoreInsertOrAppend, nodeinsert:this.onTreeStoreInsertOrAppend, noderemove:this.onNodeRemove});
  } else {
    Ext.apply(listeners, {add:this.onStoreChange, remove:this.onStoreChange});
  }
  if (un) {
    this.mun(store, listeners);
  } else {
    this.mon(store, listeners);
  }
}, unbindStoreListeners:function(store) {
  this.bindStoreListeners(store, true);
}, fillStoreDescriptor:function(descriptor) {
  var store = descriptor.store, storeIdProperty = store.storeIdProperty || this.storeIdProperty, model = store.getModel && store.getModel() || store.model;
  model = model && model.prototype;
  Ext.applyIf(descriptor, {storeId:store[storeIdProperty], phantomIdField:model && model.phantomIdField, idProperty:model && model.idProperty, writeAllFields:store.writeAllFields});
  return descriptor;
}, removeStore:function(store) {
  for (var i = 0, l = this.stores.length; i < l; i++) {
    var s = this.stores[i];
    if (s === store || s.store === store || s.storeId === store) {
      this.unbindStoreListeners(s.store);
      delete this.storesIndex[s.storeId];
      this.stores.splice(i, 1);
      if (this.syncApplySequence) {
        this.removeStoreFromApplySequence(store);
      }
      break;
    }
  }
}, addStoreToApplySequence:function(store, position, fromStore) {
  if (!store) {
    return;
  }
  if (!Ext.isArray(store)) {
    store = [store];
  }
  var data = [];
  for (var i = 0, l = store.length; i < l; i++) {
    var s = this.getStoreDescriptor(store[i]);
    if (s) {
      data.push(s);
    }
  }
  if (!this.syncApplySequence) {
    this.syncApplySequence = [];
  }
  if (typeof position === 'undefined') {
    this.syncApplySequence.push.apply(this.syncApplySequence, data);
  } else {
    var pos = position;
    if (fromStore) {
      if (fromStore.isStore || typeof fromStore !== 'object') {
        fromStore = this.getStoreDescriptor(fromStore);
      }
      pos += Ext.Array.indexOf(this.syncApplySequence, fromStore);
    }
    this.syncApplySequence.splice.apply(this.syncApplySequence, [].concat([pos, 0], data));
  }
}, removeStoreFromApplySequence:function(store) {
  for (var i = 0, l = this.syncApplySequence.length; i < l; i++) {
    var s = this.syncApplySequence[i];
    if (s === store || s.store === store || s.storeId === store) {
      this.syncApplySequence.splice(i, 1);
      break;
    }
  }
}, onNodeRemove:function(oldParent) {
  var treeStore = oldParent && oldParent.getTreeStore();
  treeStore && treeStore.on('endupdate', this.onStoreChange, this, {single:true});
}, onStoreUpdate:function(store, record, operation, fields) {
  if (!store.isTreeStore || record !== store.getRoot()) {
    var isSingleNonPersistField = fields && fields.length === 1 && record.getField(fields[0]) && !record.getField(fields[0]).persist;
    if (!isSingleNonPersistField) {
      this.onStoreChange();
    }
  }
}, onTreeStoreInsertOrAppend:function(parent, child) {
  if (!child.isRoot()) {
    this.onStoreChange();
  }
}, suspendChangesTracking:function() {
  this.ignoreUpdates++;
}, resumeChangesTracking:function(triggerCheck) {
  this.ignoreUpdates--;
  triggerCheck && this.onStoreChange();
}, onStoreChange:function() {
  if (this.ignoreUpdates) {
    return;
  }
  var me = this;
  if (this.hasChanges()) {
    this.fireEvent('haschanges', this);
    if (this.autoSync) {
      if (!this.autoSyncTimerId) {
        this.autoSyncTimerId = setTimeout(function() {
          me.autoSyncTimerId = null;
          me.sync();
        }, this.autoSyncTimeout);
      }
    }
  } else {
    this.fireEvent('nochanges', this);
  }
}, hasChanges:function(storeId) {
  var store;
  if (storeId) {
    store = this.getStore(storeId);
    if (!store) {
      return false;
    }
    return this.isStoreDirty(store);
  }
  for (var i = 0, l = this.stores.length; i < l; i++) {
    if (this.isStoreDirty(this.stores[i].store)) {
      return true;
    }
  }
  return false;
}, isStoreDirty:function(store) {
  if (store.getRemovedRecords().length) {
    return true;
  }
  if (store.isTreeStore) {
    for (var o in store.byIdMap) {
      var record = store.byIdMap[o];
      if (record.dirty === true && !record.get('root') && (Ext.Object.getKeys(record.modified).length !== 1 || !('expanded' in record.modified) && !('lastParentId' in record.modified))) {
        return true;
      } else {
        if (!record.get('root') && record.phantom && record.isValid()) {
          return true;
        }
      }
    }
  } else {
    var records = store.getData().items;
    for (var i = 0, l = records.length; i < l; i++) {
      if (records[i].dirty || records[i].phantom) {
        return true;
      }
    }
  }
  return false;
}, getLoadPackage:function(options) {
  var pack = {type:'load', requestId:this.getRequestId(), stores:[]};
  var stores = this.stores, packStores = pack.stores;
  for (var i = 0, l = stores.length; i < l; i++) {
    var store = stores[i], filterParam = store.filterParam || store.store.filterParam || this.filterParam, opts = options && options[store.storeId], pageSize = store.pageSize || store.store.pageSize;
    if (store.store.remoteFilter && filterParam) {
      opts = opts || {};
      var filters = [];
      store.store.getFilters().each(function(f) {
        filters.push(f.serialize());
      });
      opts[filterParam] = filters;
    }
    if (opts || pageSize) {
      var params = Ext.apply({storeId:store.storeId, page:1, pageSize:pageSize}, opts);
      stores[i].currentPage = params.page;
      packStores.push(params);
    } else {
      packStores.push(store.storeId);
    }
  }
  return pack;
}, prepareAdded:function(records, phantomIdField, stores) {
  var result = [];
  for (var i = 0, l = records.length; i < l; i++) {
    var record = records[i], data = record.getData({serialize:true, persist:true}), criticalData = record.getData({serialize:true, persist:true, critical:true, changes:true});
    data = Ext.applyIf(data, criticalData);
    if (!data.hasOwnProperty(phantomIdField)) {
      data[phantomIdField] = record.getId();
    }
    if (this.resetIdsBeforeSync) {
      delete data[record.idProperty];
    }
    if (stores) {
      this.processSubStores(record, data, stores);
    }
    result.push(data);
  }
  return result;
}, prepareUpdated:function(records, stores, storeInfo) {
  var result = [], writeAllFields = storeInfo.writeAllFields || storeInfo.writeAllFields !== false && this.writeAllFields;
  for (var i = 0, l = records.length; i < l; i++) {
    var record = records[i], data = record.getData({serialize:true, persist:true, critical:!writeAllFields, changes:!writeAllFields});
    data[record.idProperty] = record.getId();
    for (var fieldName in data) {
      var field = record.getField(fieldName);
      var toDelete = !field || (writeAllFields ? !field.persist && !field.critical : !field.persist);
      if (toDelete) {
        delete data[fieldName];
      }
    }
    if (stores) {
      this.processSubStores(record, data, stores);
    }
    result.push(data);
  }
  return result;
}, prepareRemoved:function(records) {
  var result = [];
  for (var i = 0, l = records.length; i < l; i++) {
    var record = records[i], data = {};
    data[record.idProperty] = record.getId();
    result.push(data);
  }
  return result;
}, processSubStores:function(record, data, stores) {
  for (var j = 0, n = stores.length; j < n; j++) {
    var id = stores[j].storeId, store = record.get(id);
    if (store) {
      var changes = this.getStoreChanges(Ext.apply({store:store}, stores[j]));
      if (changes) {
        data[id] = Ext.apply(changes, {$store:true});
      } else {
        delete data[id];
      }
    } else {
      delete data[id];
    }
  }
}, getStoreChanges:function(store, phantomIdField) {
  phantomIdField = phantomIdField || store.phantomIdField || this.phantomIdField;
  var s = store.store, added = s.getNewRecords(), updated = s.getUpdatedRecords(), removed = s.getRemovedRecords(), stores = store.stores;
  var result;
  if (added.length) {
    added = this.prepareAdded(added, phantomIdField, stores);
  }
  if (updated.length) {
    updated = this.prepareUpdated(updated, stores, store);
  }
  if (removed.length) {
    removed = this.prepareRemoved(removed);
  }
  if (added.length || updated.length || removed.length) {
    result = {};
    if (added.length) {
      result.added = added;
    }
    if (updated.length) {
      result.updated = updated;
    }
    if (removed.length) {
      result.removed = removed;
    }
  }
  return result;
}, getChangeSetPackage:function() {
  var pack = {type:'sync', requestId:this.getRequestId(), revision:this.revision};
  var stores = this.stores, found = 0;
  for (var i = 0, l = stores.length; i < l; i++) {
    var store = stores[i], phantomIdField = store.phantomIdField || this.phantomIdField, storeId = store.storeId;
    var changes = this.getStoreChanges(store, phantomIdField);
    if (changes) {
      found++;
      pack[storeId] = changes;
    }
  }
  return found ? pack : null;
}, getSubStoresData:function(rows, subStores, idProperty, isTree) {
  if (!rows) {
    return;
  }
  var result = [];
  var processRow = function(row, subStores) {
    for (var j = 0, m = subStores.length; j < m; j++) {
      var storeId = subStores[j].storeId;
      if (row[storeId]) {
        result.push({id:row[idProperty], storeDesc:subStores[j], data:row[storeId]});
        delete row[storeId];
      }
    }
  };
  var i = 0, l = rows.length;
  if (isTree) {
    for (; i < l; i++) {
      processRow(rows[i], subStores);
      var childrenSubData = this.getSubStoresData(rows[i].children, subStores, idProperty, true);
      if (childrenSubData) {
        result = result.concat(childrenSubData);
      }
    }
  } else {
    for (; i < l; i++) {
      processRow(rows[i], subStores);
    }
  }
  return result;
}, loadDataToTreeStore:function(store, data, options, storeDesc) {
  var rows = data && data.rows || [];
  var root = store.getRoot();
  if (root) {
    root.modified = null;
    root.reject();
  }
  store.proxy.data = rows;
  store.load();
}, loadDataToFlatStore:function(store, data, options, storeDesc) {
  var rows = data && data.rows || [];
  store.totalCount = data.total;
  store.currentPage = storeDesc.currentPage;
  var records = Ext.Array.map(rows, function(recordData) {
    return new store.model(recordData);
  });
  store.loadData(records, options && options.append || data.append);
  store.fireEvent('load', store, records, true);
}, loadDataToStore:function(storeDesc, data, options) {
  var store = storeDesc.store, model = store.getModel(), subStores = storeDesc.stores, idProperty = storeDesc.idProperty || model && model.prototype && model.prototype.idProperty || 'id', isTree = store.isTreeStore, subData;
  store.__loading = true;
  if ('metaData' in data) {
    var metaData = data && data.metaData;
    if (store.applyMetaData) {
      store.applyMetaData(metaData);
    } else {
      store.metaData = metaData;
    }
  }
  var rows = data && data.rows || [];
  if (rows) {
    if (subStores) {
      subData = this.getSubStoresData(rows, subStores, idProperty, isTree);
    }
    var loadMethod = isTree ? this.loadDataToTreeStore : this.loadDataToFlatStore;
    loadMethod.call(this, store, data, options, storeDesc);
    if (subData) {
      for (var i = 0, l = subData.length; i < l; i++) {
        var subDatum = subData[i];
        this.loadDataToStore(Ext.apply({store:store[isTree ? 'getNodeById' : 'getById'](subDatum.id).get(subDatum.storeDesc.storeId)}, subDatum.storeDesc), subDatum.data);
      }
    }
  }
  store.__loading = false;
}, loadData:function(response, options) {
  options = options || {};
  this.suspendChangesTracking();
  for (var i = 0, l = this.stores.length; i < l; i++) {
    var storeDesc = this.stores[i], storeId = storeDesc.storeId, data = response[storeId];
    if (data) {
      this.loadDataToStore(storeDesc, data, options[storeId]);
    }
  }
  this.resumeChangesTracking();
}, applyChangesToRecord:function(record, changes, stores, store) {
  var data = record.data, done = {}, editStarted = false, name;
  if (stores) {
    for (var j = 0, n = stores.length; j < n; j++) {
      name = stores[j].storeId;
      if (changes.hasOwnProperty(name)) {
        done[name] = true;
        var subStore = record.get(name);
        if (subStore) {
          this.applyChangesToStore(Ext.apply({store:subStore}, stores[j]), changes[name]);
        } else {
          Ext.log("Can't find store for the response sub-package");
        }
      }
    }
  }
  for (name in changes) {
    if (changes.hasOwnProperty(name) && !done[name]) {
      var value = changes[name];
      if (!record.isEqual(data[name], value)) {
        if (!editStarted) {
          editStarted = true;
          record.beginEdit();
        }
        if (name === record.idProperty) {
          record.setId(value);
        } else {
          if (name == 'parentId' && store.isTreeStore) {
            var parent = value && store.getNodeById(value) || store.getRoot();
            parent.appendChild(record);
          } else {
            if (record.getField(name)) {
              record.set(name, value);
            }
          }
        }
      }
    }
  }
  if (editStarted) {
    record.endEdit();
  }
  record.commit();
}, applyRemovals:function(store, removed, context) {
  var idProperty = context.idProperty, removedStash = store.isTreeStore ? store.removedNodes : store.removed, findByIdFn = context.findByIdFn, removeRecordFn = context.removeRecordFn, nbrRemoved = 0;
  for (var j = 0, k = removed.length; j < k; j++) {
    var done = false;
    var id = removed[j][idProperty];
    for (var jj = 0, kk = removedStash.length; jj < kk; jj++) {
      if (removedStash[jj].getId() == id) {
        removedStash.splice(jj, 1);
        done = true;
        nbrRemoved++;
        break;
      }
    }
    if (!done) {
      var record = findByIdFn(id);
      if (record) {
        this.suspendChangesTracking();
        removeRecordFn(record);
        Ext.Array.remove(removedStash, record);
        nbrRemoved++;
        this.resumeChangesTracking();
      } else {
        Ext.log("Can't find record to remove from the response package");
      }
    }
  }
  return nbrRemoved;
}, getApplyChangesToStoreHelpers:function(store) {
  if (store.isTreeStore) {
    var findNode = function(id) {
      return store.getNodeById(id);
    };
    return {findByPhantomFn:findNode, findByIdFn:findNode, addRecordFn:function(data) {
      var parent = data.parentId && store.getNodeById(data.parentId) || store.getRoot();
      return parent.appendChild(data);
    }, removeRecordFn:function(record) {
      return record.parentNode.removeChild(record);
    }};
  } else {
    return {findByPhantomFn:function(id) {
      return store.data.getByKey(id);
    }, findByIdFn:function(id) {
      return store.getById(id);
    }, addRecordFn:function(data) {
      return store.add(data)[0];
    }, removeRecordFn:function(record) {
      return store.remove(record);
    }};
  }
}, applyChangesToStore:function(storeDesc, storeResponse) {
  var me = this, phantomIdField = storeDesc.phantomIdField || me.phantomIdField, idProperty = storeDesc.idProperty, store = storeDesc.store;
  if (!idProperty) {
    var model = store.getModel && store.getModel() || store.model;
    model = model && model.prototype;
    idProperty = model && model.idProperty || 'id';
  }
  var helpers = me.getApplyChangesToStoreHelpers(store), findByPhantomFn = helpers.findByPhantomFn, findByIdFn = helpers.findByIdFn, addRecordFn = helpers.addRecordFn, removeRecordFn = helpers.removeRecordFn, rows = storeResponse.rows, removedRecords = storeResponse.removed, nbrRemoved = 0, record;
  if (removedRecords) {
    nbrRemoved = me.applyRemovals(store, removedRecords, {idProperty:idProperty, findByIdFn:findByIdFn, removeRecordFn:removeRecordFn});
  }
  if (rows) {
    var data, id, phantomId, stores = storeDesc.stores;
    for (var j = 0, k = rows.length; j < k; j++) {
      data = rows[j];
      phantomId = data[phantomIdField];
      id = data[idProperty];
      record = null;
      if (phantomId != null && phantomId !== '') {
        record = findByPhantomFn(phantomId);
      } else {
        if (id != null && id !== '') {
          record = findByIdFn(id);
        }
      }
      if (record) {
        me.applyChangesToRecord(record, data, stores, store);
      } else {
        record = addRecordFn(data);
        record.commit();
      }
    }
  }
  if (nbrRemoved > 0) {
    store.fireEvent('datachanged', store);
    store.fireEvent('commit', store);
  }
}, applySyncResponse:function(response) {
  this.applyingSyncResponse = true;
  this.suspendChangesTracking();
  var stores = this.syncApplySequence || this.stores;
  for (var i = 0, l = stores.length; i < l; i++) {
    var storeResponse = response[stores[i].storeId];
    if (storeResponse) {
      this.applyChangesToStore(stores[i], storeResponse);
    }
  }
  this.applyingSyncResponse = false;
  this.resumeChangesTracking();
}, applyLoadResponse:function(response, options) {
  this.applyingLoadResponse = true;
  this.loadData(response, options);
  this.applyingLoadResponse = false;
}, applyResponse:function(requestType, response, options) {
  if (this.trackResponseType) {
    requestType = response.type || requestType;
  }
  switch(requestType) {
    case 'load':
      this.applyLoadResponse(response, options);
      break;
    case 'sync':
      this.applySyncResponse(response);
      break;
  }
}, getRequestId:function() {
  return Ext.Date.now();
}, onResponse:function(requestType, rawResponse, responseOptions, options) {
  this.activeRequests[requestType] = null;
  var response = this.decode(rawResponse);
  if (!response || !response.success) {
    this.fireEvent('requestfail', this, requestType, response, responseOptions);
    this.fireEvent(requestType + 'fail', this, response, responseOptions, options);
    if ('string' != typeof rawResponse) {
      rawResponse = '' + rawResponse;
    }
    this.warn('CrudManager: ' + requestType + ' failed, please inspect the server response', rawResponse.length < 1024 * 1024 && rawResponse || '');
  } else {
    this.fireEvent('requestsuccess', this, requestType, response, responseOptions);
    this.fireEvent(requestType + 'success', this, response, responseOptions, options);
    if (this.fireEvent('beforeresponseapply', this, requestType, response) !== false && this.fireEvent('before' + requestType + 'apply', this, response, options) !== false) {
      this.revision = response.revision;
      this.applyResponse(requestType, response, options);
      this.fireEvent('requestdone', this, requestType, response, responseOptions);
      this.fireEvent(requestType, this, response, responseOptions, options);
      if (requestType === 'load' || !this.hasChanges()) {
        this.fireEvent('nochanges', this);
      }
    }
  }
  return response;
}, onLoad:function(rawResponse, responseOptions, options) {
  this.loaded = true;
  return this.onResponse('load', rawResponse, responseOptions, options);
}, onSync:function(rawResponse, responseOptions, options) {
  return this.onResponse('sync', rawResponse, responseOptions, options);
}, load:function(callback, errback, scope) {
  var options;
  if (typeof callback === 'object') {
    options = callback;
    callback = errback;
    errback = scope;
    scope = arguments[3];
  }
  var pack = this.getLoadPackage(options);
  if (this.fireEvent('beforeload', this, pack) !== false) {
    scope = scope || this;
    if (this.activeRequests.load) {
      this.cancelRequest(this.activeRequests.load.desc);
      this.fireEvent('loadcanceled', this, pack);
    }
    this.activeRequests.load = {id:pack.requestId};
    this.activeRequests.load.desc = this.sendRequest({data:this.encode(pack), type:'load', success:function(rawResponse, responseOptions) {
      var response = this.onLoad(rawResponse, responseOptions, options);
      if (errback && (!response || !response.success)) {
        errback.call(scope, response, rawResponse, options);
      } else {
        if (callback) {
          callback.call(scope, response, rawResponse, options);
        }
      }
    }, failure:function(rawResponse, responseOptions) {
      this.onLoad(rawResponse, responseOptions);
      if (errback) {
        errback.apply(scope, arguments);
      }
    }, scope:this});
  } else {
    this.fireEvent('loadcanceled', this, pack);
  }
}, sync:function(callback, errback, scope) {
  if (this.activeRequests.sync) {
    this.delayedSyncs.push(arguments);
    this.fireEvent('syncdelayed', this, arguments);
    return;
  }
  var pack = this.getChangeSetPackage();
  scope = scope || this;
  if (!pack) {
    if (callback) {
      callback.call(scope, null, null);
    }
    return;
  }
  if (this.fireEvent('beforesync', this, pack) === false) {
    this.fireEvent('synccanceled', this, pack);
    return;
  }
  this.activeRequests.sync = {id:pack.requestId};
  this.activeRequests.sync.desc = this.sendRequest({data:this.encode(pack), type:'sync', success:function(rawResponse, options) {
    var request = this.activeRequests.sync;
    var response = this.onSync(rawResponse, options);
    if (errback && (!response || !response.success)) {
      errback.call(scope, response, rawResponse, request);
    } else {
      if (callback) {
        callback.call(scope, response, rawResponse, request);
      }
    }
    this.runDelayedSync();
  }, failure:function(rawResponse, options) {
    this.onSync(rawResponse, options);
    if (errback) {
      errback.apply(scope, arguments);
    }
    this.runDelayedSync();
  }, scope:this});
}, runDelayedSync:function() {
  var args = this.delayedSyncs.shift();
  if (!args) {
    return;
  }
  this.sync.apply(this, args);
}, commit:function() {
  for (var i = 0, l = this.stores.length; i < l; i++) {
    var store = this.stores[i].store;
    store.suspendEvents(true);
    store.commitChanges();
    store.resumeEvents();
  }
}, reject:function() {
  for (var i = 0, l = this.stores.length; i < l; i++) {
    this.stores[i].store.rejectChanges();
  }
}, warn:function() {
  if ('console' in window) {
    var c = console;
    c.log && c.log.apply && c.log.apply(c, arguments);
  }
}, isLoading:function() {
  return Boolean(this.activeRequests.load || this.applyingLoadResponse);
}, destroy:function() {
  var me = this;
  if (me.destroyed) {
    return;
  }
  me.activeRequests.load && me.cancelRequest(me.activeRequests.load.desc);
  me.activeRequests.sync && me.cancelRequest(me.activeRequests.sync.desc);
  while (me.stores.length > 0) {
    me.removeStore(me.stores[0]);
  }
  clearTimeout(me.autoSyncTimerId);
  me.destroyed = true;
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Sch.crud, 'AbstractManager'], 0);
Ext.cmd.derive('Sch.column.Day', Ext.grid.column.Column, {align:'center', start:null, end:null, draggable:false, groupable:false, hideable:false, sortable:false, menuDisabled:true, enableLocking:false, lockable:false, flex:1, resizable:false, cellFocusable:false, tdCls:'sch-timetd', initComponent:function() {
  var now = new Date;
  this.addCls('sch-daycolumn-header');
  if (this.isWeekend()) {
    this.addCls('sch-daycolumn-header-weekend');
    this.tdCls = (this.tdCls || '') + ' sch-daycolumn-weekend';
  }
  if (this.start.getDate() === now.getDate() && this.start.getMonth() === now.getMonth() && this.start.getYear() === now.getYear()) {
    this.addCls('sch-daycolumn-header-today');
    this.tdCls = (this.tdCls || '') + ' sch-daycolumn-today';
  }
  Ext.grid.column.Column.prototype.initComponent.apply(this, arguments);
}, isWeekend:function() {
  var day = this.start.getDay();
  return day === 6 || day === 0;
}}, 0, ['weekview-day'], ['component', 'box', 'container', 'headercontainer', 'gridcolumn', 'weekview-day'], {'component':true, 'box':true, 'container':true, 'headercontainer':true, 'gridcolumn':true, 'weekview-day':true}, ['widget.weekview-day'], 0, [Sch.column, 'Day'], 0);
Ext.cmd.derive('Sch.column.Resource', Ext.grid.Column, {align:'center', menuDisabled:true, hideable:false, sortable:false, locked:false, lockable:false, draggable:false, enableLocking:false, cellFocusable:false, model:null, initComponent:function() {
  this.tdCls = (this.tdCls || '') + ' sch-timetd';
  this.cls = (this.cls || '') + ' sch-resourcecolumn-header';
  Ext.grid.column.Column.prototype.initComponent.apply(this, arguments);
}}, 0, ['resourcecolumn'], ['component', 'box', 'container', 'headercontainer', 'gridcolumn', 'resourcecolumn'], {'component':true, 'box':true, 'container':true, 'headercontainer':true, 'gridcolumn':true, 'resourcecolumn':true}, ['widget.resourcecolumn'], 0, [Sch.column, 'Resource'], 0);
Ext.cmd.derive('Sch.locale.Locale', Ext.Base, {l10n:null, legacyMode:true, localeName:null, namespaceId:null, constructor:function() {
  if (!Sch.locale.Active) {
    Sch.locale.Active = {};
    this.bindRequire();
  }
  var name = this.self.getName().split('.');
  var localeName = this.localeName = name.pop();
  this.namespaceId = name.join('.');
  var currentLocale = Sch.locale.Active[this.namespaceId];
  if (!(localeName == 'En' && currentLocale && currentLocale.localeName != 'En')) {
    this.apply();
  }
}, bindRequire:function() {
  var _triggerCreated = Ext.ClassManager.triggerCreated;
  Ext.ClassManager.triggerCreated = function(className) {
    _triggerCreated.apply(this, arguments);
    if (className) {
      var cls = Ext.ClassManager.get(className);
      for (var namespaceId in Sch.locale.Active) {
        Sch.locale.Active[namespaceId].apply(cls);
      }
    }
  };
}, applyToClass:function(className, cls) {
  var me = this, localeId = me.self.getName();
  cls = cls || Ext.ClassManager.get(className);
  if (cls && cls.activeLocaleId !== localeId) {
    var locale = me.l10n[className];
    if (typeof locale === 'function') {
      locale(className);
    } else {
      if (cls.singleton) {
        cls.l10n = Ext.apply({}, locale, cls.prototype && cls.prototype.l10n);
      } else {
        Ext.override(cls, {l10n:locale});
      }
    }
    if (me.legacyMode) {
      var target;
      if (cls.prototype) {
        target = cls.prototype;
      } else {
        if (cls.singleton) {
          target = cls;
        }
      }
      if (target && target.legacyMode) {
        if (target.legacyHolderProp) {
          if (!target[target.legacyHolderProp]) {
            target[target.legacyHolderProp] = {};
          }
          target = target[target.legacyHolderProp];
        }
        for (var p in locale) {
          if (typeof target[p] !== 'function') {
            target[p] = locale[p];
          }
        }
      }
    }
    cls.activeLocaleId = localeId;
    if (cls.onLocalized) {
      cls.onLocalized();
    }
  }
}, apply:function(classNames) {
  if (this.l10n) {
    var me = this;
    if (classNames) {
      if (!Ext.isArray(classNames)) {
        classNames = [classNames];
      }
      var name, cls;
      for (var i = 0, l = classNames.length; i < l; i++) {
        if (Ext.isObject(classNames[i])) {
          if (classNames[i].singleton) {
            cls = classNames[i];
            name = Ext.getClassName(Ext.getClass(cls));
          } else {
            cls = Ext.getClass(classNames[i]);
            name = Ext.getClassName(cls);
          }
        } else {
          cls = null;
          name = 'string' === typeof classNames[i] ? classNames[i] : Ext.getClassName(classNames[i]);
        }
        if (name) {
          if (name in this.l10n) {
            me.applyToClass(name, cls);
          }
        }
      }
    } else {
      Sch.locale.Active[this.namespaceId] = this;
      for (var className in this.l10n) {
        me.applyToClass(className);
      }
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Sch.locale, 'Locale'], 0);
Ext.cmd.derive('Sch.locale.En', Sch.locale.Locale, {singleton:true, l10n:{'Sch.util.Date':{unitNames:{YEAR:{single:'year', plural:'years', abbrev:'yr'}, QUARTER:{single:'quarter', plural:'quarters', abbrev:'q'}, MONTH:{single:'month', plural:'months', abbrev:'mon'}, WEEK:{single:'week', plural:'weeks', abbrev:'w'}, DAY:{single:'day', plural:'days', abbrev:'d'}, HOUR:{single:'hour', plural:'hours', abbrev:'h'}, MINUTE:{single:'minute', plural:'minutes', abbrev:'min'}, SECOND:{single:'second', plural:'seconds', 
abbrev:'s'}, MILLI:{single:'ms', plural:'ms', abbrev:'ms'}}}, 'Sch.panel.TimelineGridPanel':{weekStartDay:1, loadingText:'Loading, please wait...', savingText:'Saving changes, please wait...'}, 'Sch.panel.TimelineTreePanel':{weekStartDay:1, loadingText:'Loading, please wait...', savingText:'Saving changes, please wait...'}, 'Sch.mixin.SchedulerView':{loadingText:'Loading events...'}, 'Sch.plugin.CurrentTimeLine':{tooltipText:'Current time'}, 'Sch.widget.EventEditor':{saveText:'Save', deleteText:'Delete', 
cancelText:'Cancel', nameText:'Name', allDayText:'All day', startDateText:'Start', endDateText:'End', resourceText:'Resource'}, 'Sch.plugin.SimpleEditor':{newEventText:'New booking...'}, 'Sch.widget.ExportDialogForm':{formatFieldLabel:'Paper format', orientationFieldLabel:'Orientation', rangeFieldLabel:'Schedule range', showHeaderLabel:'Show header', showFooterLabel:'Show footer', orientationPortraitText:'Portrait', orientationLandscapeText:'Landscape', completeViewText:'Complete schedule', currentViewText:'Visible schedule', 
dateRangeText:'Date range', dateRangeFromText:'Export from', dateRangeToText:'Export to', exportersFieldLabel:'Control pagination', adjustCols:'Adjust column width', adjustColsAndRows:'Adjust column width and row height', specifyDateRange:'Specify date range', columnPickerLabel:'Select columns', completeDataText:'Complete schedule (for all events)', dpiFieldLabel:'DPI (dots per inch)', rowsRangeLabel:'Rows range', allRowsLabel:'All rows', visibleRowsLabel:'Visible rows', columnEmptyText:'[no title]'}, 
'Sch.widget.ExportDialog':{title:'Export Settings', exportButtonText:'Export', cancelButtonText:'Cancel', progressBarText:'Exporting...'}, 'Sch.plugin.Export':{generalError:'An error occurred', fetchingRows:'Fetching row {0} of {1}', builtPage:'Built page {0} of {1}', requestingPrintServer:'Please wait...'}, 'Sch.plugin.Printable':{dialogTitle:'Print settings', exportButtonText:'Print', disablePopupBlocking:'Please disable pop-up blocker since the print-plugin needs to be able to open new tabs', 
popupBlockerDetected:'Browser pop-up blocker detected'}, 'Sch.plugin.exporter.AbstractExporter':{name:'Exporter'}, 'Sch.plugin.exporter.SinglePage':{name:'Single page'}, 'Sch.plugin.exporter.MultiPageVertical':{name:'Multiple pages (vertically)'}, 'Sch.plugin.exporter.MultiPage':{name:'Multiple pages'}, 'Sch.column.ResourceName':{name:'Name'}, 'Sch.template.DependencyInfo':{fromText:'From', toText:'To'}, 'Sch.preset.Manager':{hourAndDay:{displayDateFormat:'G:i', middleDateFormat:'G:i', topDateFormat:'D d/m'}, 
secondAndMinute:{displayDateFormat:'g:i:s', topDateFormat:'D, d g:iA'}, dayAndWeek:{displayDateFormat:'m/d h:i A', middleDateFormat:'D d M'}, weekAndDay:{displayDateFormat:'m/d', bottomDateFormat:'d M', middleDateFormat:'Y F d'}, weekAndMonth:{displayDateFormat:'m/d/Y', middleDateFormat:'m/d', topDateFormat:'m/d/Y'}, weekAndDayLetter:{displayDateFormat:'m/d/Y', middleDateFormat:'D d M Y'}, weekDateAndMonth:{displayDateFormat:'m/d/Y', middleDateFormat:'d', topDateFormat:'Y F'}, monthAndYear:{displayDateFormat:'m/d/Y', 
middleDateFormat:'M Y', topDateFormat:'Y'}, year:{displayDateFormat:'m/d/Y', middleDateFormat:'Y'}, manyYears:{displayDateFormat:'m/d/Y', middleDateFormat:'Y'}}}}, 0, 0, 0, 0, 0, 0, [Sch.locale, 'En'], 0);
Ext.cmd.derive('Sch.mixin.Localizable', Ext.Base, {legacyMode:false, activeLocaleId:'', l10n:null, inTextLocaleRegExp:/L\{([^}]+)\}/g, isLocaleApplied:function() {
  var activeLocaleId = this.singleton && this.activeLocaleId || this.self.activeLocaleId;
  if (!activeLocaleId) {
    return false;
  }
  for (var ns in Sch.locale.Active) {
    if (activeLocaleId === Sch.locale.Active[ns].self.getName()) {
      return true;
    }
  }
  return false;
}, applyLocale:function() {
  for (var ns in Sch.locale.Active) {
    Sch.locale.Active[ns].apply(this.singleton ? this : this.self.getName());
  }
}, L:function() {
  return this.localize.apply(this, arguments);
}, localize:function(id, legacyHolderProp, skipLocalizedCheck) {
  var result = this.getLocale(id, legacyHolderProp, skipLocalizedCheck);
  if (result === null || result === undefined) {
    throw 'Cannot find locale: ' + id + ' [' + this.self.getName() + ']';
  }
  return result;
}, getLocale:function(id, legacyHolderProp, skipLocalizedCheck) {
  if (!this.isLocaleApplied() && !skipLocalizedCheck) {
    this.applyLocale();
  }
  if (this.hasOwnProperty('l10n') && this.l10n.hasOwnProperty(id) && 'function' != typeof this.l10n[id]) {
    return this.l10n[id];
  }
  var clsProto = this.self && this.self.prototype;
  if (this.legacyMode) {
    var prop = legacyHolderProp || this.legacyHolderProp;
    var instHolder = prop ? this[prop] : this;
    if (instHolder && instHolder.hasOwnProperty(id) && 'function' != typeof instHolder[id]) {
      return instHolder[id];
    }
    if (clsProto) {
      var clsHolder = prop ? clsProto[prop] : clsProto;
      if (clsHolder && clsHolder.hasOwnProperty(id) && 'function' != typeof clsHolder[id]) {
        return clsHolder[id];
      }
    }
  }
  var result = clsProto.l10n && clsProto.l10n[id];
  if (result === null || result === undefined) {
    var superClass = clsProto && clsProto.superclass;
    if (superClass && superClass.localize) {
      result = superClass.localize(id, legacyHolderProp, skipLocalizedCheck);
    }
  }
  return result;
}, localizeText:function(text) {
  var match, locale, regExp = this.inTextLocaleRegExp;
  while (match = regExp.exec(text)) {
    if (locale = this.getLocale(match[1])) {
      text = text.replace(match[0], locale);
    }
  }
  return text;
}}, 0, 0, 0, 0, 0, 0, [Sch.mixin, 'Localizable'], 0);
Ext.cmd.derive('Sch.column.ResourceName', Ext.grid.Column, {initComponent:function() {
  Ext.apply(this, {text:this.L('name')});
  Ext.grid.column.Column.prototype.initComponent.apply(this, arguments);
}, renderer:function(value, meta, resource) {
  return resource.getName();
}}, 0, ['scheduler_resourcenamecolumn'], ['component', 'box', 'container', 'headercontainer', 'gridcolumn', 'scheduler_resourcenamecolumn'], {'component':true, 'box':true, 'container':true, 'headercontainer':true, 'gridcolumn':true, 'scheduler_resourcenamecolumn':true}, ['widget.scheduler_resourcenamecolumn'], [[Sch.mixin.Localizable.prototype.mixinId || Sch.mixin.Localizable.$className, Sch.mixin.Localizable]], [Sch.column, 'ResourceName'], 0);
Ext.cmd.derive('Sch.view.HorizontalTimeAxis', Ext.util.Observable, {trackHeaderOver:true, compactCellWidthThreshold:15, baseCls:'sch-column-header', tableCls:'sch-header-row', enableTickResizing:false, headerHtmlRowTpl:'\x3ctable border\x3d"0" cellspacing\x3d"0" cellpadding\x3d"0" style\x3d"width: {totalWidth}px; {tstyle}" class\x3d"{{tableCls}} sch-header-row-{position} {cls}"\x3e\x3ctbody\x3e\x3ctr\x3e\x3ctpl for\x3d"cells"\x3e\x3ctd class\x3d"{{baseCls}} {headerCls} sch-header-cell-{align}" data-date\x3d"{[fm.date(values.start, \'Ymd_His\')]}" style\x3d"text-align: {align}; width: {width}px; {style}" tabIndex\x3d"0"headerPosition\x3d"{parent.position}" headerIndex\x3d"{[xindex-1]}"\x3e\x3cdiv class\x3d"sch-simple-timeheader"\x3e{header}\x3c/div\x3e{{resizeHandle}}\x3c/td\x3e\x3c/tpl\x3e\x3c/tr\x3e\x3c/tbody\x3e\x3c/table\x3e', 
model:null, hoverCls:'', containerEl:null, height:null, constructor:function(config) {
  var me = this;
  var isTouch = !!Ext.versions.touch;
  Ext.apply(this, config);
  Ext.util.Observable.prototype.constructor.apply(this, arguments);
  me.model.on('update', me.onModelUpdate, this, {priority:5});
  me.containerEl = Ext.get(me.containerEl);
  if (!(me.headerHtmlRowTpl instanceof Ext.Template)) {
    if (Ext.isString(me.headerHtmlRowTpl)) {
      me.headerHtmlRowTpl = me.headerHtmlRowTpl.replace('{{baseCls}}', this.baseCls).replace('{{tableCls}}', this.tableCls).replace('{{resizeHandle}}', this.enableTickResizing ? '\x3cdiv class\x3d"sch-header-cell-resizehandle"\x3e\x3c/div\x3e' : '');
    }
    me.headerHtmlRowTpl = new Ext.XTemplate(me.headerHtmlRowTpl);
  }
  if (me.trackHeaderOver && me.hoverCls) {
    me.containerEl.on({mousemove:me.highlightCell, delegate:'.' + this.baseCls, scope:me});
    me.containerEl.on({mouseleave:me.clearHighlight, scope:me});
  }
  var listenerCfg = {scope:this, delegate:'.' + this.baseCls};
  if (isTouch) {
    listenerCfg.tap = this.onElClick('tap');
    listenerCfg.doubletap = this.onElClick('doubletap');
  } else {
    listenerCfg.click = this.onElClick('click');
    listenerCfg.dblclick = this.onElClick('dblclick');
    listenerCfg.contextmenu = this.onElClick('contextmenu');
  }
  me._listenerCfg = listenerCfg;
  if (me.containerEl) {
    me.containerEl.on(listenerCfg);
  }
}, destroy:function() {
  var me = this;
  if (me.containerEl) {
    me.containerEl.un(me._listenerCfg);
    me.containerEl.un({mousemove:me.highlightCell, delegate:'.sch-simple-timeheader', scope:me});
    me.containerEl.un({mouseleave:me.clearHighlight, scope:me});
  }
  me.model.un('update', me.onModelUpdate, this, {priority:5});
}, onModelUpdate:function() {
  this.height = null;
  this.render();
}, getHTML:function() {
  var columnConfig = this.model.getColumnConfig();
  var totalWidth = this.model.getTotalWidth();
  var nbrRows = Ext.Object.getKeys(columnConfig).length;
  var html = '';
  if (columnConfig.top) {
    this.embedCellWidths(columnConfig.top);
    html += this.headerHtmlRowTpl.apply({totalWidth:totalWidth, cells:columnConfig.top, position:'top', tstyle:'border-top : 0;'});
  }
  if (columnConfig.middle) {
    this.embedCellWidths(columnConfig.middle);
    html += this.headerHtmlRowTpl.apply({totalWidth:totalWidth, cells:columnConfig.middle, position:'middle', tstyle:columnConfig.top ? '' : 'border-top : 0;', cls:!columnConfig.bottom && this.model.getTickWidth() <= this.compactCellWidthThreshold ? 'sch-header-row-compact' : ''});
  }
  if (columnConfig.bottom) {
    this.embedCellWidths(columnConfig.bottom);
    html += this.headerHtmlRowTpl.apply({totalWidth:totalWidth, cells:columnConfig.bottom, position:'bottom', cls:this.model.getTickWidth() <= this.compactCellWidthThreshold ? 'sch-header-row-compact' : ''});
  }
  return html;
}, deleteTimeAxisRows:function() {
  var innerCt = this.containerEl, ctDom = innerCt.dom;
  Ext.fly(ctDom).select('table').remove();
}, render:function() {
  if (!this.containerEl) {
    return;
  }
  var innerCt = this.containerEl, ctDom = innerCt.dom, oldDisplay = ctDom.style.display, columnConfig = this.model.getColumnConfig(), parent = ctDom.parentNode;
  ctDom.style.display = 'none';
  parent.removeChild(ctDom);
  this.deleteTimeAxisRows();
  ctDom.insertAdjacentHTML('afterbegin', this.getHTML());
  if (!columnConfig.top && !columnConfig.middle) {
    this.containerEl.addCls('sch-header-single-row');
  } else {
    this.containerEl.removeCls('sch-header-single-row');
  }
  parent && parent.appendChild(ctDom);
  ctDom.style.display = oldDisplay;
  this.fireEvent('refresh', this);
}, embedCellWidths:function(cells, isLowestRow) {
  for (var i = 0; i < cells.length; i++) {
    var cell = cells[i];
    var width = this.model.getDistanceBetweenDates(cell.start, cell.end);
    if (width) {
      cell.width = width;
    } else {
      cell.width = 0;
      cell.style = 'display: none';
    }
  }
}, onElClick:function(eventName) {
  return function(event, target) {
    target = event.delegatedTarget || target;
    var position = Ext.fly(target).getAttribute('headerPosition'), index = Ext.fly(target).getAttribute('headerIndex'), headerConfig = this.model.getColumnConfig()[position][index];
    this.fireEvent('timeheader' + eventName, this, headerConfig.start, headerConfig.end, event);
  };
}, highlightCell:function(e, cell) {
  var me = this;
  if (cell !== me.highlightedCell) {
    me.clearHighlight();
    me.highlightedCell = cell;
    Ext.fly(cell).addCls(me.hoverCls);
  }
}, clearHighlight:function() {
  var me = this, highlighted = me.highlightedCell;
  if (highlighted) {
    Ext.fly(highlighted).removeCls(me.hoverCls);
    delete me.highlightedCell;
  }
}}, 1, 0, 0, 0, 0, 0, [Sch.view, 'HorizontalTimeAxis'], 0);
Ext.cmd.derive('Sch.feature.HeaderResize', Ext.AbstractPlugin, {selector:null, currentCell:null, originalCellWidth:null, startClientX:null, timeAxisViewModel:null, minCellWidth:15, init:function(column) {
  column.on('render', this.onColumnRender, this);
}, onColumnRender:function(column) {
  column.getEl().on('mousedown', this.onMouseDown, this, {delegate:this.selector});
}, getClientX:function(e) {
  return Ext.isNumber(e.clientX) ? e.clientX : e.browserEvent.clientX;
}, onMouseDown:function(e, t) {
  var me = this, cellEl = t.parentElement;
  me.originalCellWidth = Ext.fly(cellEl).getWidth();
  me.startClientX = me.getClientX(e);
  me.currentCell = cellEl;
  me.getCmp().mon(Ext.getBody(), 'mousemove', me.onMouseMove, me);
  me.getCmp().mon(Ext.getBody(), 'mouseup', me.onMouseUp, me, {capture:true, single:true});
}, onMouseMove:function(e, t) {
  var me = this, cellEl = me.currentCell, nextCellEl = cellEl.nextSibling, delta = me.startClientX - me.getClientX(e), originalWidth = me.originalCellWidth, newWidth = Math.max(me.minCellWidth, originalWidth - delta);
  if (nextCellEl && newWidth < originalWidth) {
    var nextWidth = Math.min(originalWidth * 2 - me.minCellWidth, originalWidth + delta);
    nextCellEl.style.width = nextWidth + 'px';
  }
  cellEl.style.width = newWidth + 'px';
}, onMouseUp:function(e, t) {
  var me = this, timelinePanel = me.getCmp().up('timelinegrid,timelinetree'), date = timelinePanel.getSchedulingView().getDateFromCoordinate(Ext.fly(me.currentCell).getLeft()), scrollOffset = Ext.fly(me.currentCell).getX() - timelinePanel.getSchedulingView().getX(), deltaX = me.getClientX(e) - me.startClientX, ratio = me.originalCellWidth / me.timeAxisViewModel.getTickWidth(), newTickWidth = Math.max(me.minCellWidth, me.timeAxisViewModel.getTickWidth() + deltaX / ratio);
  me.timeAxisViewModel.setTickWidth(Math.round(newTickWidth));
  timelinePanel.scrollToDate(date, false, scrollOffset);
  me.getCmp().mun(Ext.getBody(), 'mousemove', me.onMouseMove, me);
  this.currentCell = this.offset = null;
}}, 0, 0, 0, 0, 0, 0, [Sch.feature, 'HeaderResize'], 0);
Ext.cmd.derive('Sch.column.timeAxis.Horizontal', Ext.grid.column.Column, {draggable:false, groupable:false, hideable:false, sortable:false, resizable:false, menuDisabled:true, cls:'sch-simple-timeaxis', tdCls:'sch-timetd', enableLocking:false, locked:false, lockable:false, enableTickResizing:false, cellFocusable:false, timeAxisViewModel:null, headerView:null, hoverCls:'', ownHoverCls:'sch-column-header-over', trackHeaderOver:true, compactCellWidthThreshold:Ext.theme && Ext.theme.name.toLowerCase() === 
'classic' ? 15 : 35, initComponent:function() {
  if (this.enableTickResizing) {
    this.addPlugin(new Sch.feature.HeaderResize({selector:'.sch-header-cell-resizehandle', timeAxisViewModel:this.timeAxisViewModel}));
  }
  Ext.grid.column.Column.prototype.initComponent.apply(this, arguments);
}, afterRender:function() {
  var me = this;
  var ct = me.titleEl.createChild({cls:'sch-horizontaltimeaxis-ct'});
  if (!(me.headerView instanceof Sch.view.HorizontalTimeAxis)) {
    me.headerView = Ext.create(Ext.applyIf(me.headerView || {}, {xclass:'Sch.view.HorizontalTimeAxis', model:me.timeAxisViewModel, containerEl:ct, hoverCls:me.ownHoverCls, trackHeaderOver:me.trackHeaderOver, enableTickResizing:this.enableTickResizing, compactCellWidthThreshold:me.compactCellWidthThreshold}));
  }
  me.headerView.on('refresh', me.onTimeAxisViewRefresh, me);
  me.headerView.render();
  me.ownerCt.on('afterlayout', function() {
    if (!me.ownerCt) {
      return;
    }
    me.mon(me.ownerCt, 'resize', me.onHeaderContainerResize, me);
    if (this.getWidth() > 0) {
      if (me.getAvailableWidthForSchedule() !== me.timeAxisViewModel.getAvailableWidth()) {
        me.timeAxisViewModel.update(me.getAvailableWidthForSchedule());
      }
      me.setWidth(me.timeAxisViewModel.getTotalWidth());
    }
  }, null, {single:true});
  this.enableBubble('timeheaderclick', 'timeheaderdblclick', 'timeheadercontextmenu', 'horizontaltimeaxiscolumnrender');
  me.relayEvents(me.headerView, ['timeheaderclick', 'timeheaderdblclick', 'timeheadercontextmenu']);
  Ext.grid.column.Column.prototype.afterRender.apply(this, arguments);
  me.focusable = false;
  this.fireEvent('horizontaltimeaxiscolumnrender', this);
}, initRenderData:function() {
  var me = this;
  me.renderData.headerCls = me.renderData.headerCls || me.headerCls;
  return Ext.grid.column.Column.prototype.initRenderData.apply(this, arguments);
}, destroy:function() {
  if (this.headerView) {
    this.headerView.destroy();
    this.headerView = null;
  }
  Ext.grid.column.Column.prototype.destroy.apply(this, arguments);
}, onTimeAxisViewRefresh:function() {
  this.headerView.un('refresh', this.onTimeAxisViewRefresh, this);
  var newWidth = this.timeAxisViewModel.getTotalWidth();
  if (this.getWidth() !== newWidth) {
    this.setWidth(newWidth);
  } else {
    this.updateLayout();
  }
  this.ensureSizing();
  this.headerView.on('refresh', this.onTimeAxisViewRefresh, this);
}, getAvailableWidthForSchedule:function() {
  if (!this.ownerCt) {
    return 0;
  }
  var available = this.ownerCt.isVisible(true) ? this.ownerCt.getWidth() : this.ownerCt.lastBox && this.ownerCt.lastBox.width || 0, items = this.ownerCt.items, item;
  for (var i = 1; i < items.length; i++) {
    item = items.get(i);
    if (!item.hidden) {
      available -= item.isVisible(true) ? item.getWidth() : item.lastBox && item.lastBox.width || 0;
    }
  }
  return Math.max(0, available - Ext.getScrollbarSize().width - 1);
}, onResize:function() {
  Ext.grid.column.Column.prototype.onResize.apply(this, arguments);
  this.timeAxisViewModel.setAvailableWidth(this.getAvailableWidthForSchedule());
}, onHeaderContainerResize:function(header, width, height, oldWidth, oldHeight) {
  this.timeAxisViewModel.setAvailableWidth(this.getAvailableWidthForSchedule());
  if (height !== oldHeight) {
    this.headerView.render();
  }
}, ensureSizing:function() {
  var viewContainerEl = this.headerView.containerEl;
  var availableHeight = this.ownerCt.getHeight();
  var renderedTimeAxisHeight = viewContainerEl.getHeight();
  var heightDiff = availableHeight - renderedTimeAxisHeight;
  if (heightDiff > 0) {
    var lastRow = viewContainerEl.down('table:last-of-type tr');
    if (lastRow) {
      viewContainerEl.select('table tr').setHeight(availableHeight / this.timeAxisViewModel.getHeaders().length);
    }
  }
}, refresh:function() {
  if (this.rendered) {
    this.timeAxisViewModel.update(null, true);
    this.headerView.render();
  }
}}, 0, ['timeaxiscolumn'], ['component', 'box', 'container', 'headercontainer', 'gridcolumn', 'timeaxiscolumn'], {'component':true, 'box':true, 'container':true, 'headercontainer':true, 'gridcolumn':true, 'timeaxiscolumn':true}, ['widget.timeaxiscolumn'], 0, [Sch.column.timeAxis, 'Horizontal'], 0);
Ext.cmd.derive('Sch.column.timeAxis.Vertical', Ext.grid.column.Column, {align:'right', draggable:false, groupable:false, hideable:false, sortable:false, menuDisabled:true, timeAxis:null, timeAxisViewModel:null, enableLocking:false, locked:true, lockable:false, dataIndex:'start', initComponent:function() {
  Ext.grid.column.Column.prototype.initComponent.apply(this, arguments);
  this.tdCls = (this.tdCls || '') + ' sch-verticaltimeaxis-cell';
  this.scope = this;
  this.addCls('sch-verticaltimeaxis-header');
}, renderer:function(val, meta, record, rowIndex) {
  var viewModel = this.timeAxisViewModel;
  if (!viewModel.columnConfig.middle) {
    return;
  }
  meta.style = 'height:' + (viewModel.getTickWidth() - 1) + 'px';
  var header;
  if (!viewModel.isWeek() && val && viewModel.isMajorTick(val)) {
    header = viewModel.headerConfig[viewModel.getMajorHeaderName()];
    meta.tdCls += ' sch-column-line-solid';
  } else {
    header = viewModel.getBottomHeader();
  }
  if (header.renderer) {
    return header.renderer.call(header.scope || this, record.data.start, record.data.end, meta, rowIndex);
  } else {
    return Ext.Date.format(val, header.dateFormat);
  }
}}, 0, ['verticaltimeaxis'], ['component', 'box', 'container', 'headercontainer', 'gridcolumn', 'verticaltimeaxis'], {'component':true, 'box':true, 'container':true, 'headercontainer':true, 'gridcolumn':true, 'verticaltimeaxis':true}, ['widget.verticaltimeaxis'], 0, [Sch.column.timeAxis, 'Vertical'], 0);
Ext.cmd.derive('Sch.util.Cache', Ext.Base, {cache:null, constructor:function() {
  var me = this;
  me.cache = {};
}, key:function(v) {
  var result;
  if (v && v.isModel) {
    result = v.getId().toString();
  } else {
    if (v === undefined || v === null) {
      result = '[ undefined / null ]';
    } else {
      result = v.toString();
    }
  }
  return result;
}, has:function(k) {
  var me = this;
  k = me.key(k);
  return me.cache.hasOwnProperty(k);
}, get:function(k, fn) {
  var me = this, result;
  k = me.key(k);
  result = me.cache.hasOwnProperty(k) && me.cache[k];
  if (!result && fn) {
    result = fn();
  } else {
    if (!result) {
      result = [];
    }
  }
  me.cache[k] = result;
  return result;
}, add:function(k, v) {
  var me = this, kAdopted = me.key(k);
  if (!me.cache.hasOwnProperty(kAdopted)) {
    me.cache[kAdopted] = me.get(k);
  }
  arguments.length > 1 && Ext.Array.include(me.cache[kAdopted], v);
  return me;
}, set:function(k, vals) {
  var me = this, kAdopted = me.key(k);
  me.cache[kAdopted] = vals;
  return me;
}, remove:function(k, v) {
  var me = this;
  k = me.key(k);
  if (me.cache.hasOwnProperty(k)) {
    Ext.Array.remove(me.cache[k], v);
  }
  return me;
}, move:function(oldKey, newKey, v) {
  var me = this;
  oldKey = me.key(oldKey);
  newKey = me.key(newKey);
  if (oldKey != newKey && arguments.length >= 3) {
    me.remove(oldKey, v);
    me.add(newKey, v);
  } else {
    if (oldKey != newKey && me.cache.hasOwnProperty(oldKey) && me.cache.hasOwnProperty(newKey)) {
      me.cache[newKey] = Ext.Array.union(me.cache[newKey], me.cache[oldKey]);
      me.cache[oldKey] = [];
    } else {
      if (oldKey != newKey && me.cache.hasOwnProperty(oldKey)) {
        me.cache[newKey] = me.cache[oldKey];
        me.cache[oldKey] = [];
      }
    }
  }
  return me;
}, clear:function(k) {
  var me = this;
  if (!arguments.length) {
    me.cache = {};
  } else {
    k = me.key(k);
    if (me.cache.hasOwnProperty(k)) {
      delete me.cache[k];
    }
  }
  return me;
}, uncache:function(v) {
  var me = this, k;
  for (k in me.cache) {
    if (me.cache.hasOwnProperty(k)) {
      me.cache[k] = Ext.Array.remove(me.cache[k], v);
    }
  }
  return me;
}, inheritableStatics:{}}, 1, 0, 0, 0, 0, 0, [Sch.util, 'Cache'], 0);
Ext.cmd.derive('Sch.data.mixin.UniversalModelGetter', Ext.Base, {onClassMixedIn:function(targetClass) {
  var overrides = {};
  if (targetClass.prototype.isTreeStore) {
    overrides.getModelById = targetClass.prototype.getNodeById;
  } else {
    overrides.getModelById = targetClass.prototype.getById;
  }
  if (targetClass.prototype.isTreeStore) {
    overrides.getModelByInternalId = function(id) {
      return this.byInternalIdMap[id] || null;
    };
  } else {
    overrides.getModelByInternalId = targetClass.prototype.getByInternalId;
  }
  Ext.override(targetClass, overrides);
}}, 0, 0, 0, 0, 0, 0, [Sch.data.mixin, 'UniversalModelGetter'], 0);
Ext.cmd.derive('Sch.data.mixin.CacheHintHelper', Ext.Mixin, {mixinConfig:{before:{loadRecords:'loadRecords', removeAll:'removeAll'}}, loadRecords:function() {
  this.fireEvent('cacheresethint', this);
}, removeAll:function(silent) {
  if (silent) {
    this.fireEvent('cacheresethint', this);
  }
}}, 0, 0, 0, 0, 0, 0, [Sch.data.mixin, 'CacheHintHelper'], 0);
Ext.cmd.derive('Sch.model.Customizable', Ext.data.Model, function(thisClass) {
  return {isCustomizableModel:true, customizableFields:null, previous:null, __editing:null, __editCounter:0, constructor:function() {
    var retVal = Ext.data.Model.prototype.constructor.apply(this, arguments);
    return retVal;
  }, storePreviousFlex:Ext.Function.flexSetter(function(fieldName, value) {
    var me = this, currentValue = me.get(fieldName);
    if (currentValue instanceof Date && !(value instanceof Date)) {
      value = me.getField(fieldName).convert(value, me);
    }
    if (currentValue instanceof Date && currentValue - value || !(currentValue instanceof Date) && currentValue !== value) {
      me.previous[fieldName] = currentValue;
    }
  }), deletePreviousFlex:Ext.Function.flexSetter(function(fieldName, value) {
    delete this.previous[fieldName];
  }), set:function(fieldName, value) {
    var me = this, ownPrevious = false, result = null;
    if (!me.previous) {
      ownPrevious = true;
      me.previous = {};
    }
    me.storePreviousFlex(fieldName, value);
    result = Ext.data.Model.prototype.set.apply(this, arguments);
    if (!me.__editing) {
      if (ownPrevious) {
        delete me.previous;
      } else {
        me.deletePreviousFlex(fieldName, value);
      }
    }
    return result;
  }, reject:function() {
    var me = this, modified = me.modified || {}, field;
    me.__editing = true;
    me.previous = me.previous || {};
    for (field in modified) {
      if (modified.hasOwnProperty(field)) {
        if (typeof modified[field] != 'function') {
          me.previous[field] = me.get(field);
        }
      }
    }
    Ext.data.Model.prototype.reject.apply(this, arguments);
    delete me.previous;
    me.__editing = false;
  }, beginEdit:function() {
    this.__editCounter++;
    this.__editing = true;
    Ext.data.Model.prototype.beginEdit.apply(this, arguments);
  }, cancelEdit:function() {
    this.__editCounter = 0;
    this.__editing = false;
    Ext.data.Model.prototype.cancelEdit.apply(this, arguments);
    delete this.previous;
  }, endEdit:function(silent, modifiedFieldNames) {
    if (--this.__editCounter === 0) {
      if (!silent && this.getModifiedFieldNames) {
        var editMemento = this.editMemento;
        if (!modifiedFieldNames) {
          modifiedFieldNames = this.getModifiedFieldNames(editMemento.data);
        }
        if (modifiedFieldNames && modifiedFieldNames.length === 0) {
          silent = true;
        }
      }
      Ext.data.Model.prototype.endEdit.apply(this, [silent].concat(Array.prototype.slice.call(arguments, 1)));
      this.__editing = false;
      delete this.previous;
    }
  }};
}, 1, 0, 0, 0, 0, [['robo', Robo.data.Model]], [Sch.model, 'Customizable'], function(thisClass) {
  thisClass.$onExtended.unshift({fn:function(cls, data) {
    if (data) {
      if (Ext.isArray(data)) {
        cls.fieldsInitialValue = data.slice();
      } else {
        if (data.fields) {
          if (!Ext.isArray(data.fields)) {
            cls.fieldsInitialValue = [data.fields];
          } else {
            cls.fieldsInitialValue = data.fields.slice();
          }
        }
      }
    }
  }});
  thisClass.onExtended(function(cls, data, hooks) {
    var classManager = Ext.ClassManager, triggerCreatedOriginal = classManager.triggerCreated;
    classManager.triggerCreated = function(className) {
      var proto = cls.prototype;
      if (data.customizableFields) {
        proto.allCustomizableFields = (cls.superclass.allCustomizableFields || []).concat(data.customizableFields);
      } else {
        proto.allCustomizableFields = cls.superclass.allCustomizableFields || [];
      }
      var customizableFieldsByName = {};
      Ext.Array.each(proto.allCustomizableFields, function(field) {
        if (typeof field == 'string') {
          field = {name:field};
        }
        customizableFieldsByName[field.name] = field;
      });
      var fields = proto.fields;
      var toAdd = [];
      var toRemove = [];
      Ext.Array.each(fields, function(field) {
        if (field.isCustomizableField) {
          toRemove.push(field.getName());
        }
      });
      if (proto.idProperty !== 'id' && proto.getField('id')) {
        if (!proto.getField('id').hasOwnProperty('name')) {
          toRemove.push('id');
        }
      }
      if (proto.idProperty !== 'Id' && proto.getField('Id')) {
        if (!proto.getField('Id').hasOwnProperty('name')) {
          toRemove.push('Id');
        }
      }
      cls.removeFields(toRemove);
      function applyFieldConfig(result, fields, fieldName) {
        if (!fields) {
          return;
        }
        if (!Ext.isArray(fields)) {
          fields = [fields];
        }
        var fieldConfig;
        for (var i = fields.length - 1; i >= 0; i--) {
          if (fields[i].name == fieldName) {
            fieldConfig = fields[i];
            break;
          }
        }
        Ext.applyIf(result, fieldConfig);
      }
      function getFieldConfig(stableFieldName) {
        var c = cls, proto = c.prototype, fieldProperty = stableFieldName === 'Id' ? 'idProperty' : stableFieldName.charAt(0).toLowerCase() + stableFieldName.substr(1) + 'Field', result = {name:proto[fieldProperty] || stableFieldName, isCustomizableField:true}, fieldName;
        while (proto && proto.isCustomizableModel) {
          fieldName = proto[fieldProperty] || stableFieldName;
          proto.hasOwnProperty('customizableFields') && applyFieldConfig(result, proto.customizableFields, stableFieldName);
          applyFieldConfig(result, c.fieldsInitialValue, fieldName);
          proto = c.superclass;
          c = proto && proto.self;
        }
        return result;
      }
      toRemove = [];
      Ext.Object.each(customizableFieldsByName, function(name, customizableField) {
        var stableFieldName = customizableField.name || customizableField.getName();
        var fieldProperty = stableFieldName === 'Id' ? 'idProperty' : stableFieldName.charAt(0).toLowerCase() + stableFieldName.substr(1) + 'Field';
        var realFieldName = proto[fieldProperty] || stableFieldName;
        proto.getField(realFieldName) && toRemove.push(realFieldName);
        var field = getFieldConfig(stableFieldName);
        toAdd.push(Ext.create('data.field.' + (field.type || 'auto'), field));
        var capitalizedStableName = Ext.String.capitalize(stableFieldName);
        if (capitalizedStableName != 'Id') {
          var getter = 'get' + capitalizedStableName;
          var setter = 'set' + capitalizedStableName;
          if (!proto[getter] || proto[getter].__getterFor__ && proto[getter].__getterFor__ != realFieldName) {
            proto[getter] = function() {
              return this.get(this[fieldProperty] || realFieldName);
            };
            proto[getter].__getterFor__ = realFieldName;
          }
          if (!proto[setter] || proto[setter].__setterFor__ && proto[setter].__setterFor__ != realFieldName) {
            proto[setter] = function(value) {
              return this.set(this[fieldProperty] || realFieldName, value);
            };
            proto[setter].__setterFor__ = realFieldName;
          }
        }
      });
      cls.replaceFields(toAdd, toRemove);
      triggerCreatedOriginal.apply(this, arguments);
      classManager.triggerCreated = triggerCreatedOriginal;
    };
  });
});
Ext.cmd.derive('Sch.model.Assignment', Sch.model.Customizable, {idProperty:'Id', isAssignmentModel:true, customizableFields:[{name:'ResourceId'}, {name:'EventId'}], resourceIdField:'ResourceId', eventIdField:'EventId', getInternalId:function() {
  return this.internalId;
}, getAssignmentStore:function() {
  return this.joined && this.joined[0];
}, getEventStore:function() {
  var assignmentStore = this.getAssignmentStore();
  return assignmentStore && assignmentStore.getEventStore();
}, getResourceStore:function() {
  var eventStore = this.getEventStore();
  return eventStore && eventStore.getResourceStore();
}, getEvent:function(eventStore) {
  var me = this;
  eventStore = eventStore || me.getEventStore();
  return eventStore && eventStore.getModelById(me.getEventId());
}, getResource:function(resourceStore) {
  var me = this;
  resourceStore = resourceStore || me.getResourceStore();
  return resourceStore && resourceStore.getModelById(me.getResourceId());
}, getEventName:function(eventStore) {
  var evnt = this.getEvent(eventStore);
  return evnt && evnt.getName() || '';
}, getResourceName:function(resourceStore) {
  var resource = this.getResource(resourceStore);
  return resource && resource.getName() || '';
}, isPersistable:function() {
  var me = this, event = me.getEvent(), resource = me.getResource();
  return event && !event.phantom && resource && !resource.phantom;
}, fullCopy:function() {
  return this.copy.apply(this, arguments);
}, getEventResourceCompositeKey:function() {
  var me = this;
  return me.self.makeAssignmentEventResourceCompositeKey(me.getEventId(), me.getResourceId());
}, inheritableStatics:{makeAssignmentEventResourceCompositeKey:function() {
  var arr = [];
  return function(eventId, resourceId) {
    arr.length = 0;
    arr.push('event(', eventId, ')-resource(', resourceId, ')');
    return arr.join('');
  };
}()}}, 0, 0, 0, 0, 0, 0, [Sch.model, 'Assignment'], 0);
Ext.cmd.derive('Sch.model.CalendarDay', Sch.model.Customizable, {idProperty:'Id', isCalendarDayModel:true, customizableFields:[{name:'Date', type:'date', dateFormat:'c', persist:true, convert:function(value, record) {
  if (!value) {
    return;
  }
  var converted = Ext.data.Types.DATE.convert.call(this, value);
  if (converted) {
    Ext.Date.clearTime(converted);
  }
  return converted;
}}, {name:'Weekday', type:'int'}, {name:'OverrideStartDate', type:'date', dateFormat:'c'}, {name:'OverrideEndDate', type:'date', dateFormat:'c'}, {name:'Type', defaultValue:'DAY'}, {name:'IsWorkingDay', type:'boolean', defaultValue:false}, {name:'Cls', defaultValue:'sch-nonworkingtime'}, 'Name', {name:'Availability', persist:true, convert:function(value, record) {
  if (value) {
    return typeof value === 'string' ? [value] : value;
  } else {
    return [];
  }
}}], availabilityCache:null, weekdayField:'Weekday', overrideStartDateField:'OverrideStartDate', overrideEndDateField:'OverrideEndDate', typeField:'Type', dateField:'Date', isWorkingDayField:'IsWorkingDay', clsField:'Cls', nameField:'Name', availabilityField:'Availability', setDate:function(date) {
  if (date) {
    date = Ext.Date.clearTime(date, true);
  }
  this.set(this.dateField, date);
}, clearDate:function() {
  this.set(this.dateField, null);
}, getAvailability:function(asString) {
  var me = this;
  if (asString) {
    return this.get(this.availabilityField);
  }
  if (this.availabilityCache) {
    return this.availabilityCache;
  }
  var parsed = Ext.Array.map(this.get(this.availabilityField), function(value) {
    return typeof value === 'string' ? me.parseInterval(value) : value;
  });
  this.verifyAvailability(parsed);
  return this.availabilityCache = parsed;
}, setAvailability:function(intervals) {
  this.availabilityCache = null;
  this.set(this.availabilityField, this.stringifyIntervals(intervals));
  this.getAvailability();
}, verifyAvailability:function(intervals) {
  var me = this;
  intervals.sort(function(a, b) {
    return a.startTime - b.startTime;
  });
  Ext.Array.each(intervals, function(interval, i) {
    if (interval.startTime > interval.endTime) {
      throw new Error('Start time ' + Ext.Date.format(interval.startTime, 'H:i') + ' is greater than end time ' + Ext.Date.format(interval.endTime, 'H:i'));
    }
    if (i > 0 && intervals[i - 1].endTime > interval.startTime) {
      throw new Error('Availability intervals should not intersect: [' + me.stringifyInterval(intervals[i - 1]) + '] and [' + me.stringifyInterval(interval) + ']');
    }
  });
}, prependZero:function(value) {
  return value < 10 ? '0' + value : value;
}, stringifyInterval:function(interval) {
  var startTime = interval.startTime;
  var endTime = interval.endTime;
  return this.prependZero(startTime.getHours()) + ':' + this.prependZero(startTime.getMinutes()) + '-' + (endTime.getDate() == 1 ? 24 : this.prependZero(endTime.getHours())) + ':' + this.prependZero(endTime.getMinutes());
}, stringifyIntervals:function(intervals) {
  var me = this;
  return Ext.Array.map(intervals, function(interval) {
    if (typeof interval === 'string') {
      return interval;
    }
    return me.stringifyInterval(interval);
  });
}, parseInterval:function(string) {
  var match = /(\d\d):(\d\d)-(\d\d):(\d\d)/.exec(string);
  if (!match) {
    throw new Error('Invalid format for availability string: ' + string + '. It should have exact format: hh:mm-hh:mm');
  }
  return {startTime:new Date(2016, 11, 0, match[1], match[2]), endTime:new Date(2016, 11, 0, match[3], match[4])};
}, getTotalHours:function() {
  return this.getTotalMS() / 1000 / 60 / 60;
}, getTotalMS:function() {
  var totalMS = 0;
  Ext.Array.each(this.getAvailability(), function(interval) {
    totalMS += interval.endTime - interval.startTime;
  });
  return totalMS;
}, addAvailabilityInterval:function(startTime, endTime) {
  var interval;
  function prepareDate(date) {
    return new Date(2016, 11, date.getDate() == 1 ? 1 : 0, date.getHours(), date.getMinutes());
  }
  if (startTime instanceof Date) {
    interval = {startTime:prepareDate(startTime), endTime:prepareDate(endTime)};
  } else {
    interval = this.parseInterval(startTime + (endTime ? '-' + endTime : ''));
  }
  var intervals = this.getAvailability().concat(interval);
  this.verifyAvailability(intervals);
  this.setAvailability(intervals);
}, removeAvailabilityInterval:function(index) {
  var intervals = this.getAvailability();
  intervals.splice(index, 1);
  this.setAvailability(intervals);
}, getAvailabilityIntervalsFor:function(timeDate) {
  timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
  var year = timeDate.getFullYear();
  var month = timeDate.getMonth();
  var date = timeDate.getDate();
  return Ext.Array.map(this.getAvailability(), function(interval) {
    var endDate = interval.endTime.getDate();
    return {startDate:new Date(year, month, date, interval.startTime.getHours(), interval.startTime.getMinutes()), endDate:new Date(year, month, date + (endDate == 1 ? 1 : 0), interval.endTime.getHours(), interval.endTime.getMinutes())};
  });
}, getAvailabilityStartFor:function(timeDate) {
  var intervals = this.getAvailabilityIntervalsFor(timeDate);
  if (!intervals.length) {
    return null;
  }
  return intervals[0].startDate;
}, getAvailabilityEndFor:function(timeDate) {
  var intervals = this.getAvailabilityIntervalsFor(timeDate);
  if (!intervals.length) {
    return null;
  }
  return intervals[intervals.length - 1].endDate;
}}, 0, 0, 0, 0, 0, 0, [Sch.model, 'CalendarDay'], 0);
Ext.cmd.derive('Sch.util.Date', Ext.Base, {singleton:true, stripEscapeRe:/(\\.)/g, hourInfoRe:/([gGhHisucUOPZ]|MS)/, unitHash:null, unitsByName:{}, MIN_VALUE:new Date(-8.64E15), MAX_VALUE:new Date(8.64E15), constructor:function() {
  var ED = Ext.Date;
  var unitHash = this.unitHash = {MILLI:ED.MILLI, SECOND:ED.SECOND, MINUTE:ED.MINUTE, HOUR:ED.HOUR, DAY:ED.DAY, WEEK:'w', MONTH:ED.MONTH, QUARTER:'q', YEAR:ED.YEAR};
  Ext.apply(this, unitHash);
  var me = this;
  this.units = [me.MILLI, me.SECOND, me.MINUTE, me.HOUR, me.DAY, me.WEEK, me.MONTH, me.QUARTER, me.YEAR];
}, onLocalized:function() {
  this.setUnitNames(this.L('unitNames'));
}, setUnitNames:function(unitNames) {
  var unitsByName = this.unitsByName = {};
  this.l10n.unitNames = unitNames;
  this._unitNames = Ext.apply({}, unitNames);
  var unitHash = this.unitHash;
  for (var name in unitHash) {
    if (unitHash.hasOwnProperty(name)) {
      var unitValue = unitHash[name];
      this._unitNames[unitValue] = this._unitNames[name];
      unitsByName[name] = unitValue;
      unitsByName[unitValue] = unitValue;
    }
  }
}, betweenLesser:function(date, start, end) {
  return start <= date && date < end;
}, betweenLesserEqual:function(date, start, end) {
  return start <= date && date <= end;
}, constrain:function(date, min, max) {
  return this.min(this.max(date, min), max);
}, compareUnits:function(u1, u2) {
  var ind1 = Ext.Array.indexOf(this.units, u1), ind2 = Ext.Array.indexOf(this.units, u2);
  return ind1 > ind2 ? 1 : ind1 < ind2 ? -1 : 0;
}, isUnitGreater:function(u1, u2) {
  return this.compareUnits(u1, u2) > 0;
}, copyTimeValues:function(targetDate, sourceDate) {
  targetDate.setHours(sourceDate.getHours());
  targetDate.setMinutes(sourceDate.getMinutes());
  targetDate.setSeconds(sourceDate.getSeconds());
  targetDate.setMilliseconds(sourceDate.getMilliseconds());
}, add:function(date, unit, value) {
  var d = Ext.Date.clone(date);
  if (!unit || value === 0) {
    return d;
  }
  switch(unit.toLowerCase()) {
    case this.MILLI:
      d = new Date(date.getTime() + value);
      break;
    case this.SECOND:
      d = new Date(date.getTime() + value * 1000);
      break;
    case this.MINUTE:
      d = new Date(date.getTime() + value * 60000);
      break;
    case this.HOUR:
      d = new Date(date.getTime() + value * 3600000);
      break;
    case this.DAY:
      d.setDate(date.getDate() + value);
      if (d.getHours() === 23 && date.getHours() === 0) {
        d = Ext.Date.add(d, Ext.Date.HOUR, 1);
      }
      break;
    case this.WEEK:
      d.setDate(date.getDate() + value * 7);
      break;
    case this.MONTH:
      var day = date.getDate();
      if (day > 28) {
        day = Math.min(day, Ext.Date.getLastDateOfMonth(this.add(Ext.Date.getFirstDateOfMonth(date), this.MONTH, value)).getDate());
      }
      d.setDate(day);
      d.setMonth(d.getMonth() + value);
      break;
    case this.QUARTER:
      d = this.add(date, this.MONTH, value * 3);
      break;
    case this.YEAR:
      d.setFullYear(date.getFullYear() + value);
      break;
  }
  return d;
}, getUnitDurationInMs:function(unit) {
  return this.add(new Date(1, 0, 1), unit, 1) - new Date(1, 0, 1);
}, getMeasuringUnit:function(unit) {
  if (unit === this.WEEK) {
    return this.DAY;
  }
  return unit;
}, getDurationInUnit:function(start, end, unit, doNotRound) {
  var units;
  switch(unit) {
    case this.YEAR:
      units = this.getDurationInYears(start, end);
      break;
    case this.QUARTER:
      units = this.getDurationInMonths(start, end) / 3;
      break;
    case this.MONTH:
      units = this.getDurationInMonths(start, end);
      break;
    case this.WEEK:
      units = this.getDurationInDays(start, end) / 7;
      break;
    case this.DAY:
      units = this.getDurationInDays(start, end);
      break;
    case this.HOUR:
      units = this.getDurationInHours(start, end);
      break;
    case this.MINUTE:
      units = this.getDurationInMinutes(start, end);
      break;
    case this.SECOND:
      units = this.getDurationInSeconds(start, end);
      break;
    case this.MILLI:
      units = this.getDurationInMilliseconds(start, end);
      break;
  }
  return doNotRound ? units : Math.round(units);
}, getUnitToBaseUnitRatio:function(baseUnit, unit) {
  if (baseUnit === unit) {
    return 1;
  }
  switch(baseUnit) {
    case this.YEAR:
      switch(unit) {
        case this.QUARTER:
          return 1 / 4;
        case this.MONTH:
          return 1 / 12;
      }break;
    case this.QUARTER:
      switch(unit) {
        case this.YEAR:
          return 4;
        case this.MONTH:
          return 1 / 3;
      }break;
    case this.MONTH:
      switch(unit) {
        case this.YEAR:
          return 12;
        case this.QUARTER:
          return 3;
      }break;
    case this.WEEK:
      switch(unit) {
        case this.DAY:
          return 1 / 7;
        case this.HOUR:
          return 1 / 168;
      }break;
    case this.DAY:
      switch(unit) {
        case this.WEEK:
          return 7;
        case this.HOUR:
          return 1 / 24;
        case this.MINUTE:
          return 1 / 1440;
      }break;
    case this.HOUR:
      switch(unit) {
        case this.DAY:
          return 24;
        case this.MINUTE:
          return 1 / 60;
      }break;
    case this.MINUTE:
      switch(unit) {
        case this.HOUR:
          return 60;
        case this.SECOND:
          return 1 / 60;
        case this.MILLI:
          return 1 / 60000;
      }break;
    case this.SECOND:
      switch(unit) {
        case this.MILLI:
          return 1 / 1000;
      }break;
    case this.MILLI:
      switch(unit) {
        case this.SECOND:
          return 1000;
      }break;
  }
  return -1;
}, isUnitDivisibleIntoSubunit:function(unit, subunit) {
  var indivisible = unit === this.MONTH && subunit === this.WEEK;
  return !indivisible;
}, getDurationInMilliseconds:function(start, end) {
  return end - start;
}, getDurationInSeconds:function(start, end) {
  return (end - start) / 1000;
}, getDurationInMinutes:function(start, end) {
  return (end - start) / 60000;
}, getDurationInHours:function(start, end) {
  return (end - start) / 3600000;
}, getDurationInDays:function(start, end) {
  var dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();
  return (end - start + dstDiff * 60 * 1000) / 86400000;
}, getDurationInMonths:function(start, end) {
  return (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
}, getDurationInYears:function(start, end) {
  return this.getDurationInMonths(start, end) / 12;
}, min:function(d1, d2) {
  return (d1 && d1.valueOf() || d1) < (d2 && d2.valueOf() || d2) ? d1 : d2;
}, max:function(d1, d2) {
  return (d1 && d1.valueOf() || d1) > (d2 && d2.valueOf() || d2) ? d1 : d2;
}, intersectSpans:function(date1Start, date1End, date2Start, date2End) {
  return this.betweenLesser(date1Start, date2Start, date2End) || this.betweenLesser(date2Start, date1Start, date1End);
}, getNameOfUnit:function(unit) {
  unit = this.getUnitByName(unit);
  switch(unit.toLowerCase()) {
    case this.YEAR:
      return 'YEAR';
    case this.QUARTER:
      return 'QUARTER';
    case this.MONTH:
      return 'MONTH';
    case this.WEEK:
      return 'WEEK';
    case this.DAY:
      return 'DAY';
    case this.HOUR:
      return 'HOUR';
    case this.MINUTE:
      return 'MINUTE';
    case this.SECOND:
      return 'SECOND';
    case this.MILLI:
      return 'MILLI';
  }
  throw 'Incorrect UnitName';
}, getReadableNameOfUnit:function(unit, plural) {
  if (!this.isLocaleApplied()) {
    this.applyLocale();
  }
  return this._unitNames[unit][plural ? 'plural' : 'single'];
}, getShortNameOfUnit:function(unit) {
  if (!this.isLocaleApplied()) {
    this.applyLocale();
  }
  return this._unitNames[unit].abbrev;
}, getUnitByName:function(name) {
  if (!this.isLocaleApplied()) {
    this.applyLocale();
  }
  if (!this.unitsByName[name]) {
    Ext.Error.raise('Unknown unit name: ' + name);
  }
  return this.unitsByName[name];
}, getNext:function(date, unit, increment, weekStartDay) {
  var dt = Ext.Date.clone(date);
  weekStartDay = arguments.length < 4 ? 1 : weekStartDay;
  increment = increment == null ? 1 : increment;
  switch(unit) {
    case this.MILLI:
      dt = this.add(date, unit, increment);
      break;
    case this.SECOND:
      dt = this.add(date, unit, increment);
      if (dt.getMilliseconds() > 0) {
        dt.setMilliseconds(0);
      }
      break;
    case this.MINUTE:
      dt = this.add(date, unit, increment);
      if (dt.getSeconds() > 0) {
        dt.setSeconds(0);
      }
      if (dt.getMilliseconds() > 0) {
        dt.setMilliseconds(0);
      }
      break;
    case this.HOUR:
      dt = this.add(date, unit, increment);
      if (dt.getMinutes() > 0) {
        dt.setMinutes(0);
      }
      if (dt.getSeconds() > 0) {
        dt.setSeconds(0);
      }
      if (dt.getMilliseconds() > 0) {
        dt.setMilliseconds(0);
      }
      break;
    case this.DAY:
      var midnightNotInTimeScale = date.getHours() === 23 && this.add(dt, this.HOUR, 1).getHours() === 1;
      if (midnightNotInTimeScale) {
        dt = this.add(dt, this.DAY, 2);
        this.clearTime(dt);
        return dt;
      }
      this.clearTime(dt);
      dt = this.add(dt, this.DAY, increment);
      if (dt.getHours() === 1) {
        this.clearTime(dt);
      }
      break;
    case this.WEEK:
      this.clearTime(dt);
      var day = dt.getDay();
      dt = this.add(dt, this.DAY, weekStartDay - day + 7 * (increment - (weekStartDay <= day ? 0 : 1)));
      if (dt.getDay() !== weekStartDay) {
        dt = this.add(dt, this.HOUR, 1);
      } else {
        this.clearTime(dt);
      }
      break;
    case this.MONTH:
      dt = this.add(dt, this.MONTH, increment);
      dt.setDate(1);
      this.clearTime(dt);
      break;
    case this.QUARTER:
      dt = this.add(dt, this.MONTH, (increment - 1) * 3 + (3 - dt.getMonth() % 3));
      this.clearTime(dt);
      dt.setDate(1);
      break;
    case this.YEAR:
      dt = new Date(dt.getFullYear() + increment, 0, 1);
      break;
    default:
      throw new Error('Invalid date unit' + unit);
  }
  return dt;
}, getNumberOfMsFromTheStartOfDay:function(date) {
  return date - this.clearTime(date, true) || 86400000;
}, getNumberOfMsTillTheEndOfDay:function(date) {
  return this.getStartOfNextDay(date, true) - date;
}, getStartOfNextDay:function(date, clone, noNeedToClearTime) {
  var nextDay = this.add(noNeedToClearTime ? date : this.clearTime(date, clone), this.DAY, 1);
  if (nextDay.getDate() == date.getDate()) {
    var offsetNextDay = this.add(this.clearTime(date, clone), this.DAY, 2).getTimezoneOffset();
    var offsetDate = date.getTimezoneOffset();
    nextDay = this.add(nextDay, this.MINUTE, offsetDate - offsetNextDay);
  }
  return nextDay;
}, getEndOfPreviousDay:function(date, noNeedToClearTime) {
  var dateOnly = noNeedToClearTime ? date : this.clearTime(date, true);
  if (dateOnly - date) {
    return dateOnly;
  } else {
    return this.add(dateOnly, this.DAY, -1);
  }
}, timeSpanContains:function(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
  return otherSpanStart - spanStart >= 0 && spanEnd - otherSpanEnd >= 0;
}, compareWithPrecision:function(date1, date2, precisionUnit) {
  var D = Sch.util.Date, ED = Ext.Date, result;
  switch(precisionUnit) {
    case D.DAY:
      date1 = Number(ED.format(date1, 'Ymd'));
      date2 = Number(ED.format(date2, 'Ymd'));
      break;
    case D.WEEK:
      date1 = Number(ED.format(date1, 'YmW'));
      date2 = Number(ED.format(date2, 'YmW'));
      break;
    case D.MONTH:
      date1 = Number(ED.format(date1, 'Ym'));
      date2 = Number(ED.format(date2, 'Ym'));
      break;
    case D.QUARTER:
      date1 = date1.getFullYear() * 4 + Math.floor(date1.getMonth() / 3);
      date2 = date2.getFullYear() * 4 + Math.floor(date2.getMonth() / 3);
      break;
    case D.YEAR:
      date1 = date1.getFullYear();
      date2 = date2.getFullYear();
      break;
    default:
    case D.MILLI:
    case D.SECOND:
    case D.MINUTE:
    case D.HOUR:
      precisionUnit = precisionUnit && this.getUnitDurationInMs(precisionUnit) || 1;
      date1 = Math.floor(date1.valueOf() / precisionUnit);
      date2 = Math.floor(date2.valueOf() / precisionUnit);
      break;
  }
  date1 < date2 && (result = -1) || date1 > date2 && (result = +1) || (result = 0);
  return result;
}, getValueInUnits:function(date, unit) {
  switch(unit) {
    case this.YEAR:
      return date.getFullYear();
    case this.QUARTER:
      return Math.floor(date.getMonth() / 3) + 1;
    case this.MONTH:
      return date.getMonth();
    case this.WEEK:
      return Ext.Date.getWeekOfYear(date);
    case this.DAY:
      return date.getDate();
    case this.HOUR:
      return date.getHours();
    case this.MINUTE:
      return date.getMinutes();
    case this.SECOND:
      return date.getSeconds();
  }
}, setValueInUnits:function(date, unit, value) {
  var result = Ext.Date.clone(date), f;
  switch(unit) {
    case this.YEAR:
      f = 'setFullYear';
      break;
    case this.MONTH:
      f = 'setMonth';
      break;
    case this.DAY:
      f = 'setDate';
      break;
    case this.HOUR:
      f = 'setHours';
      break;
    case this.MINUTE:
      f = 'setMinutes';
      break;
    case this.SECOND:
      f = 'setSeconds';
      break;
    case this.MILLI:
      f = 'setMilliseconds';
      break;
  }
  result[f](value);
  return result;
}, getSubUnit:function(unit) {
  switch(unit) {
    case this.YEAR:
      return this.MONTH;
    case this.MONTH:
      return this.DAY;
    case this.DAY:
      return this.HOUR;
    case this.HOUR:
      return this.MINUTE;
    case this.MINUTE:
      return this.SECOND;
    case this.SECOND:
      return this.MILLI;
  }
}, setValueInSubUnits:function(date, unit, value) {
  unit = this.getSubUnit(unit);
  return this.setValueInUnits(date, unit, value);
}, mergeDates:function(target, source, unit) {
  var copy = Ext.Date.clone(target);
  switch(unit) {
    case this.YEAR:
      copy.setFullYear(source.getFullYear());
    case this.MONTH:
      copy.setMonth(source.getMonth());
    case this.WEEK:
    case this.DAY:
      if (unit === this.WEEK) {
        copy = this.add(copy, this.DAY, source.getDay() - copy.getDay());
      } else {
        copy.setDate(source.getDate());
      }
    case this.HOUR:
      copy.setHours(source.getHours());
    case this.MINUTE:
      copy.setMinutes(source.getMinutes());
    case this.SECOND:
      copy.setSeconds(source.getSeconds());
    case this.MILLI:
      copy.setMilliseconds(source.getMilliseconds());
  }
  return copy;
}, splitToSubUnits:function(start, unit, increment, weekStartDay) {
  increment = increment || 1;
  weekStartDay = arguments.length < 4 ? 1 : weekStartDay;
  switch(unit) {
    case this.MONTH:
      return this.splitMonth(start, increment, weekStartDay);
    case this.WEEK:
    case this.DAY:
      return this.splitDay(start, increment);
    default:
      break;
  }
}, splitYear:function(start, increment) {
  var newStart = this.clearTime(start, true);
  newStart.setMonth(0);
  newStart.setDate(1);
  var result = [];
  for (var i = 0; i <= 12; i = i + increment) {
    result.push(this.add(newStart, this.MONTH, i));
  }
  return result;
}, splitMonth:function(start, increment, weekStartDay) {
  var newStart = this.clearTime(start, true);
  newStart.setDate(1);
  newStart = this.add(newStart, this.DAY, weekStartDay - newStart.getDay());
  var currentDate = Ext.Date.clone(newStart);
  var monthEnd = this.add(newStart, this.MONTH, 1);
  var result = [];
  for (var i = 0; currentDate.getTime() < monthEnd.getTime(); i = i + increment) {
    currentDate = this.add(newStart, this.WEEK, i);
    result.push(currentDate);
  }
  return result;
}, splitWeek:function(start, increment, weekStartDay) {
  var newStart = this.add(start, this.DAY, weekStartDay - start.getDay());
  newStart = this.clearTime(newStart);
  var result = [];
  for (var i = 0; i <= 7; i = i + increment) {
    result.push(this.add(newStart, this.DAY, i));
  }
  return result;
}, splitDay:function(start, increment) {
  var copy = this.clearTime(start, true);
  var result = [];
  for (var i = 0; i <= 24; i = i + increment) {
    result.push(this.add(copy, this.HOUR, i));
  }
  return result;
}, splitHour:function(start, increment) {
  var copy = new Date(start.getTime());
  copy.setMinutes(0);
  copy.setSeconds(0);
  copy.setMilliseconds(0);
  var result = [];
  for (var i = 0; i <= 60; i = i + increment) {
    result.push(this.add(copy, this.MINUTE, i));
  }
  return result;
}, splitMinute:function(start, increment) {
  var copy = Ext.Date.clone(start);
  copy.setSeconds(0);
  copy.setMilliseconds(0);
  var result = [];
  for (var i = 0; i <= 60; i = i + increment) {
    result.push(this.add(copy, this.SECOND, i));
  }
  return result;
}, clearTime:function(dt, clone) {
  if (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0) {
    return Ext.Date.clearTime(dt, clone);
  }
  return clone ? Ext.Date.clone(dt) : dt;
}, getWeekNumber:function(date) {
  var target = new Date(date.valueOf());
  var dayNr = (date.getDay() + 6) % 7;
  target.setDate(target.getDate() - dayNr + 3);
  var firstThursday = target.valueOf();
  target.setMonth(0, 1);
  if (target.getDay() != 4) {
    target.setMonth(0, 1 + (4 - target.getDay() + 7) % 7);
  }
  return 1 + Math.ceil((firstThursday - target) / 604800000);
}, getWeekStartDate:function(date, weekStartDay) {
  var midday = this.setDateToMidday(date, true);
  weekStartDay = typeof weekStartDay !== 'number' ? 1 : weekStartDay;
  while (midday.getDay() !== weekStartDay) {
    midday = Sch.util.Date.add(midday, Sch.util.Date.DAY, -1);
  }
  return midday;
}, getWeekEndDate:function(date, weekEndDay) {
  var midday = this.setDateToMidday(date, true);
  weekEndDay = typeof weekEndDay !== 'number' ? 0 : weekEndDay;
  while (midday.getDay() !== weekEndDay) {
    midday = Sch.util.Date.add(midday, Sch.util.Date.DAY, 1);
  }
  return midday;
}, setDateToHours:function(date, clone, hours) {
  if (clone) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), hours);
  }
  date.setHours(hours);
  date.setMinutes(0);
  date.setSeconds(0);
  date.setMilliseconds(0);
  return date;
}, setDateToMidnight:function(date, clone) {
  return this.setDateToHours(date, clone, 0);
}, setDateToMidday:function(date, clone) {
  return this.setDateToHours(date, clone, 12);
}, isLaterDate:function(date, compareDate) {
  return !this.isSameDate(date, compareDate) && date > compareDate;
}, isSameDate:function(date, compareDate) {
  return date.getFullYear() === compareDate.getFullYear() && date.getMonth() === compareDate.getMonth() && date.getDate() === compareDate.getDate();
}, isEarlierDate:function(date, compareDate) {
  return !this.isSameDate(date, compareDate) && date < compareDate;
}}, 1, 0, 0, 0, 0, [[Sch.mixin.Localizable.prototype.mixinId || Sch.mixin.Localizable.$className, Sch.mixin.Localizable]], [Sch.util, 'Date'], 0);
Ext.cmd.derive('Sch.model.Range', Sch.model.Customizable, {idProperty:'Id', isRangeModel:true, startDateField:'StartDate', endDateField:'EndDate', nameField:'Name', clsField:'Cls', customizableFields:[{name:'StartDate', type:'date', dateFormat:'c'}, {name:'EndDate', type:'date', dateFormat:'c'}, {name:'Cls', type:'string'}, {name:'Name', type:'string'}], setStartDate:function(date, keepDuration) {
  var endDate = this.getEndDate();
  var oldStart = this.getStartDate();
  this.beginEdit();
  this.set(this.startDateField, date);
  if (keepDuration === true && endDate && oldStart) {
    this.setEndDate(Sch.util.Date.add(date, Sch.util.Date.MILLI, endDate - oldStart));
  }
  this.endEdit();
}, setEndDate:function(date, keepDuration) {
  var startDate = this.getStartDate();
  var oldEnd = this.getEndDate();
  this.beginEdit();
  this.set(this.endDateField, date);
  if (keepDuration === true && startDate && oldEnd) {
    this.setStartDate(Sch.util.Date.add(date, Sch.util.Date.MILLI, -(oldEnd - startDate)));
  }
  this.endEdit();
}, setStartEndDate:function(start, end) {
  this.beginEdit();
  this.set(this.startDateField, start);
  this.set(this.endDateField, end);
  this.endEdit();
}, getDates:function() {
  var dates = [], endDate = this.getEndDate();
  if (this.isScheduled()) {
    var startFloored = Ext.Date.clearTime(this.getStartDate(), true);
    if (endDate - this.getStartDate() === 0) {
      dates.push(startFloored);
    } else {
      for (var date = startFloored; date < endDate; date = Sch.util.Date.add(date, Sch.util.Date.DAY, 1)) {
        dates.push(date);
      }
    }
  }
  return dates;
}, forEachDate:function(func, scope) {
  return Ext.Array.each(this.getDates(), func, scope);
}, isScheduled:function() {
  var me = this;
  return Boolean(me.getStartDate() && me.getEndDate() && me.areDatesValid());
}, isValid:function() {
  var me = this, result = Sch.model.Customizable.prototype.isValid.call(this), start, end;
  if (result) {
    start = me.getStartDate(), end = me.getEndDate();
    result = !start || !end || end - start >= 0;
  }
  return result;
}, areDatesValid:function() {
  var me = this, start = me.getStartDate(), end = me.getEndDate();
  return !start || !end || end - start >= 0;
}, shift:function(unit, amount) {
  this.setStartEndDate(Sch.util.Date.add(this.getStartDate(), unit, amount), Sch.util.Date.add(this.getEndDate(), unit, amount));
}, fullCopy:function() {
  return this.copy.apply(this, arguments);
}, intersectsRange:function(start, end) {
  var myStart = this.getStartDate();
  var myEnd = this.getEndDate();
  return myStart && myEnd && Sch.util.Date.intersectSpans(myStart, myEnd, start, end);
}}, 0, 0, 0, 0, 0, 0, [Sch.model, 'Range'], 0);
Ext.cmd.derive('Sch.data.Calendar', Ext.data.Store, {model:'Sch.model.CalendarDay', daysPerMonth:30, daysPerWeek:7, hoursPerDay:24, unitsInMs:null, defaultNonWorkingTimeCssCls:'sch-nonworkingtime', weekendsAreWorkdays:false, weekendFirstDay:6, weekendSecondDay:0, holidaysCache:null, availabilityIntervalsCache:null, daysIndex:null, weekAvailability:null, defaultWeekAvailability:null, nonStandardWeeksByStartDate:null, nonStandardWeeksStartDates:null, calendarId:null, parent:null, defaultAvailability:['00:00-24:00'], 
name:null, suspendCacheUpdate:0, availabilitySearchLimit:1825, inheritableStatics:{getCalendar:function(id) {
  if (id instanceof Sch.data.Calendar) {
    return id;
  }
  return Ext.data.StoreManager.lookup('GNT_CALENDAR:' + id);
}, getAllCalendars:function() {
  var result = [];
  Ext.data.StoreManager.each(function(store) {
    if (store instanceof Sch.data.Calendar) {
      result.push(store);
    }
  });
  return result;
}, removeAll:function() {
  var sm = Ext.data.StoreManager;
  sm.each(function(store) {
    if (store instanceof Sch.data.Calendar) {
      sm.unregister(store);
      Ext.destroy(store);
    }
  });
}}, constructor:function(config) {
  config = config || {};
  var parent = config.parent;
  delete config.parent;
  var calendarId = config.calendarId;
  delete config.calendarId;
  Ext.data.Store.prototype.constructor.apply(this, arguments);
  this.setParent(parent);
  this.setCalendarId(calendarId);
  this.unitsInMs = {MILLI:1, SECOND:1000, MINUTE:60 * 1000, HOUR:60 * 60 * 1000, DAY:this.hoursPerDay * 60 * 60 * 1000, WEEK:this.daysPerWeek * this.hoursPerDay * 60 * 60 * 1000, MONTH:this.daysPerMonth * this.hoursPerDay * 60 * 60 * 1000, QUARTER:3 * this.daysPerMonth * 24 * 60 * 60 * 1000, YEAR:4 * 3 * this.daysPerMonth * 24 * 60 * 60 * 1000};
  this.defaultWeekAvailability = this.getDefaultWeekAvailability();
  this.on({update:this.onCalendarDataChange, add:this.onCalendarDataChange, remove:this.onCalendarDataChange, filter:this.onCalendarDataChange, sort:this.onCalendarDataChange, clear:this.onCalendarDataChange, refresh:this.onCalendarDataChange, write:this.onCalendarDataChange, scope:this});
  this.clearCache();
}, onCalendarDataChange:function() {
  this.clearCache();
}, getCalendarId:function() {
  return this.calendarId;
}, setCalendarId:function(id) {
  if (this.calendarId != null) {
    Ext.data.StoreManager.unregister(this);
  }
  this.calendarId = id;
  if (id != null) {
    this.storeId = 'GNT_CALENDAR:' + id;
    Ext.data.StoreManager.register(this);
  } else {
    this.storeId = null;
  }
  var proxy = this.proxy;
  if (proxy && proxy.extraParams) {
    proxy.extraParams.calendarId = id;
  }
}, getDefaultWeekAvailability:function() {
  var availability = this.defaultAvailability;
  var weekendFirstDay = this.weekendFirstDay;
  var weekendSecondDay = this.weekendSecondDay;
  var res = [];
  for (var i = 0; i < 7; i++) {
    res.push(this.weekendsAreWorkdays || i != weekendFirstDay && i != weekendSecondDay ? new this.model({Type:'WEEKDAY', Weekday:i, Availability:availability && availability.slice() || [], IsWorkingDay:true}) : new this.model({Type:'WEEKDAY', Weekday:i, Availability:[]}));
  }
  return res;
}, resetCache:function() {
  if (this.suspendCacheUpdate > 0) {
    return;
  }
  this.holidaysCache = {};
  this.availabilityIntervalsCache = {};
  var daysIndex = this.daysIndex = {};
  var weekAvailability = this.weekAvailability = [];
  var nonStandardWeeksStartDates = this.nonStandardWeeksStartDates = [];
  var nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate = {};
  this.each(function(calendarDay) {
    var id = calendarDay.getId();
    var overrideMatch = /^(\d)-(\d\d\d\d\/\d\d\/\d\d)-(\d\d\d\d\/\d\d\/\d\d)$/.exec(id);
    var weekDayMatch = /^WEEKDAY:(\d+)$/.exec(id);
    var type = calendarDay.getType();
    var weekDay = calendarDay.getWeekday();
    if (type == 'WEEKDAYOVERRIDE' || overrideMatch) {
      var startDate, endDate;
      if (type == 'WEEKDAYOVERRIDE') {
        startDate = calendarDay.getOverrideStartDate();
        endDate = calendarDay.getOverrideEndDate();
      }
      if (overrideMatch) {
        startDate = Ext.Date.parse(overrideMatch[2], 'Y/m/d');
        endDate = Ext.Date.parse(overrideMatch[3], 'Y/m/d');
        weekDay = overrideMatch[1];
      }
      if (startDate && endDate && weekDay != null) {
        var startDateNum = startDate - 0;
        if (!nonStandardWeeksByStartDate[startDateNum]) {
          nonStandardWeeksByStartDate[startDateNum] = {startDate:new Date(startDate), endDate:new Date(endDate), name:calendarDay.getName(), weekAvailability:[], mainDay:null};
          nonStandardWeeksStartDates.push(startDateNum);
        }
        if (weekDay >= 0) {
          nonStandardWeeksByStartDate[startDateNum].weekAvailability[weekDay] = calendarDay;
        } else {
          nonStandardWeeksByStartDate[startDateNum].mainDay = calendarDay;
        }
      }
    } else {
      if (type == 'WEEKDAY' || weekDayMatch) {
        if (weekDayMatch) {
          weekDay = weekDayMatch[1];
        }
        if (weekDay != null) {
          if (weekDay < 0 || weekDay > 6) {
            throw new Error('Incorrect week day index');
          }
          weekAvailability[weekDay] = calendarDay;
        }
      } else {
        var date = calendarDay.getDate();
        if (date) {
          daysIndex[date - 0] = calendarDay;
        }
      }
    }
  });
  nonStandardWeeksStartDates.sort(function(a, b) {
    return a - b;
  });
}, clearCache:function() {
  if (this.suspendCacheUpdate > 0) {
    return;
  }
  this.resetCache();
  this.fireEvent('calendarchange', this);
}, intersectsWithCurrentWeeks:function(startDate, endDate) {
  var result = false;
  this.forEachNonStandardWeek(function(week) {
    var weekStartDate = week.startDate;
    var weekEndDate = week.endDate;
    if (weekStartDate <= startDate && startDate < weekEndDate || weekStartDate < endDate && endDate <= weekEndDate) {
      result = true;
      return false;
    }
  });
  return result;
}, addNonStandardWeek:function(startDate, endDate, weekAvailability, name) {
  startDate = Ext.Date.clearTime(new Date(startDate));
  endDate = Ext.Date.clearTime(new Date(endDate));
  if (this.intersectsWithCurrentWeeks(startDate, endDate)) {
    throw new Error('Can not add intersecting week');
  }
  var DayModel = this.model;
  var days = [];
  Ext.Array.each(weekAvailability, function(day, index) {
    if (day && day.isCalendarDayModel) {
      day.setType('WEEKDAYOVERRIDE');
      day.setOverrideStartDate(startDate);
      day.setOverrideEndDate(endDate);
      day.setWeekday(index);
      day.setName(name || 'Week override');
      days.push(day);
    } else {
      if (Ext.isArray(day)) {
        var newDay = new DayModel;
        newDay.setType('WEEKDAYOVERRIDE');
        newDay.setOverrideStartDate(startDate);
        newDay.setOverrideEndDate(endDate);
        newDay.setWeekday(index);
        newDay.setName(name || 'Week override');
        newDay.setAvailability(day);
        days.push(newDay);
      }
    }
  });
  var mainDay = new DayModel;
  mainDay.setType('WEEKDAYOVERRIDE');
  mainDay.setOverrideStartDate(startDate);
  mainDay.setOverrideEndDate(endDate);
  mainDay.setWeekday(-1);
  mainDay.setName(name || 'Week override');
  days.push(mainDay);
  this.add(days);
}, getNonStandardWeekByStartDate:function(startDate) {
  return this.nonStandardWeeksByStartDate[Ext.Date.clearTime(new Date(startDate)) - 0] || null;
}, getNonStandardWeekByDate:function(timeDate) {
  timeDate = Ext.Date.clearTime(new Date(timeDate)) - 0;
  var nonStandardWeeksStartDates = this.nonStandardWeeksStartDates;
  var nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate;
  for (var i = 0; i < nonStandardWeeksStartDates.length; i++) {
    var week = nonStandardWeeksByStartDate[nonStandardWeeksStartDates[i]];
    if (week.startDate > timeDate) {
      break;
    }
    if (week.startDate <= timeDate && timeDate <= week.endDate) {
      return week;
    }
  }
  return null;
}, removeNonStandardWeek:function(startDate) {
  startDate = Ext.Date.clearTime(new Date(startDate)) - 0;
  var week = this.getNonStandardWeekByStartDate(startDate);
  if (!week) {
    return;
  }
  this.remove(Ext.Array.clean(week.weekAvailability).concat(week.mainDay));
}, forEachNonStandardWeek:function(func, scope) {
  var me = this;
  var nonStandardWeeksStartDates = this.nonStandardWeeksStartDates;
  var nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate;
  for (var i = 0; i < nonStandardWeeksStartDates.length; i++) {
    if (func.call(scope || me, nonStandardWeeksByStartDate[nonStandardWeeksStartDates[i]]) === false) {
      return false;
    }
  }
}, setWeekendsAreWorkDays:function(value) {
  if (value !== this.weekendsAreWorkdays) {
    this.weekendsAreWorkdays = value;
    this.defaultWeekAvailability = this.getDefaultWeekAvailability();
    this.clearCache();
  }
}, areWeekendsWorkDays:function() {
  return this.weekendsAreWorkdays;
}, getCalendarDay:function(timeDate) {
  timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
  return this.getOverrideDay(timeDate) || this.getWeekDay(timeDate.getDay(), timeDate) || this.getDefaultCalendarDay(timeDate.getDay());
}, getOverrideDay:function(timeDate) {
  return this.getOwnCalendarDay(timeDate) || this.parent && this.parent.getOverrideDay(timeDate) || null;
}, getOwnCalendarDay:function(timeDate) {
  timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
  return this.daysIndex[Ext.Date.clearTime(timeDate, true) - 0];
}, getWeekDay:function(weekDayIndex, timeDate) {
  if (timeDate) {
    var week = this.getNonStandardWeekByDate(timeDate);
    if (week && week.weekAvailability[weekDayIndex]) {
      return week.weekAvailability[weekDayIndex];
    }
  }
  return this.weekAvailability[weekDayIndex] || this.parent && this.parent.getWeekDay(weekDayIndex, timeDate) || null;
}, getDefaultCalendarDay:function(weekDayIndex) {
  if (!this.hasOwnProperty('defaultAvailability') && !this.hasOwnProperty('weekendsAreWorkdays') && this.parent) {
    return this.parent.getDefaultCalendarDay(weekDayIndex);
  }
  return this.defaultWeekAvailability[weekDayIndex];
}, isHoliday:function(timeDate) {
  var secondsSinceEpoch = timeDate - 0;
  var holidaysCache = this.holidaysCache;
  if (holidaysCache[secondsSinceEpoch] != null) {
    return holidaysCache[secondsSinceEpoch];
  }
  timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
  var day = this.getCalendarDay(timeDate);
  if (!day) {
    throw new Error("Can't find day for " + timeDate);
  }
  return holidaysCache[secondsSinceEpoch] = !day.getIsWorkingDay();
}, isWeekend:function(timeDate) {
  var dayIndex = timeDate.getDay();
  return dayIndex === this.weekendFirstDay || dayIndex === this.weekendSecondDay;
}, isWorkingDay:function(date) {
  return !this.isHoliday(date);
}, convertMSDurationToUnit:function(durationInMs, unit) {
  return durationInMs / this.unitsInMs[Sch.util.Date.getNameOfUnit(unit)];
}, convertDurationToMs:function(duration, unit) {
  return duration * this.unitsInMs[Sch.util.Date.getNameOfUnit(unit)];
}, convertDuration:function(duration, fromUnit, toUnit) {
  var me = this, result = duration;
  if (fromUnit != toUnit) {
    result = me.convertMSDurationToUnit(me.convertDurationToMs(duration, fromUnit), toUnit);
  }
  return result;
}, getHolidaysRanges:function(startDate, endDate, includeWeekends) {
  if (startDate > endDate) {
    Ext.Error.raise("startDate can't be bigger than endDate");
  }
  startDate = Ext.Date.clearTime(startDate, true);
  endDate = endDate - Ext.Date.clearTime(endDate, true) > 0 ? Sch.util.Date.getStartOfNextDay(endDate, true, true) : endDate;
  var ranges = [], currentRange, date;
  for (date = startDate; date < endDate; date = Sch.util.Date.getNext(date, Sch.util.Date.DAY, 1)) {
    if (this.isHoliday(date) || this.weekendsAreWorkdays && includeWeekends && this.isWeekend(date)) {
      var day = this.getCalendarDay(date);
      var cssClass = day && day.getCls() || this.defaultNonWorkingTimeCssCls;
      var nextDate = Sch.util.Date.getNext(date, Sch.util.Date.DAY, 1);
      if (!currentRange) {
        currentRange = new Sch.model.Range({StartDate:date, EndDate:nextDate, Cls:cssClass});
      } else {
        if (currentRange.getCls() == cssClass) {
          currentRange.setEndDate(nextDate);
        } else {
          ranges.push(currentRange);
          currentRange = new Sch.model.Range({StartDate:date, EndDate:nextDate, Cls:cssClass});
        }
      }
    } else {
      if (currentRange) {
        ranges.push(currentRange);
        currentRange = null;
      }
    }
  }
  if (currentRange) {
    ranges.push(currentRange);
  }
  return ranges;
}, forEachAvailabilityInterval:function(options, func, scope) {
  scope = scope || this;
  var me = this;
  var startDate = options.startDate;
  var endDate = options.endDate;
  var isForward = options.isForward !== false;
  if (isForward ? !startDate : !endDate) {
    throw new Error('At least `startDate` or `endDate` is required, depending from the `isForward` option');
  }
  var cursorDate = new Date(isForward ? startDate : endDate);
  var DATE = Sch.util.Date;
  if (isForward) {
    if (!endDate) {
      endDate = DATE.add(startDate, DATE.DAY, options.availabilitySearchLimit || this.availabilitySearchLimit || 5 * 365);
    }
  } else {
    if (!startDate) {
      startDate = DATE.add(endDate, DATE.DAY, -(options.availabilitySearchLimit || this.availabilitySearchLimit || 5 * 365));
    }
  }
  var noNeedToClearTime = false;
  while (isForward ? cursorDate < endDate : cursorDate > startDate) {
    var intervals = this.getAvailabilityIntervalsFor(cursorDate - (isForward ? 0 : 1), isForward ? noNeedToClearTime : false);
    for (var i = isForward ? 0 : intervals.length - 1; isForward ? i < intervals.length : i >= 0; isForward ? i++ : i--) {
      var interval = intervals[i];
      var intervalStartDate = interval.startDate;
      var intervalEndDate = interval.endDate;
      if (intervalStartDate >= endDate || intervalEndDate <= startDate) {
        continue;
      }
      var countingFrom = intervalStartDate < startDate ? startDate : intervalStartDate;
      var countingTill = intervalEndDate > endDate ? endDate : intervalEndDate;
      if (func.call(scope, countingFrom, countingTill) === false) {
        return false;
      }
    }
    cursorDate = isForward ? DATE.getStartOfNextDay(cursorDate, false, noNeedToClearTime) : DATE.getEndOfPreviousDay(cursorDate, noNeedToClearTime);
    noNeedToClearTime = true;
  }
}, calculateDuration:function(startDate, endDate, unit) {
  var duration = 0;
  this.forEachAvailabilityInterval({startDate:startDate, endDate:endDate}, function(intervalStartDate, intervalEndDate) {
    var dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
    duration += intervalEndDate - intervalStartDate + dstDiff * 60 * 1000;
  });
  return this.convertMSDurationToUnit(duration, unit);
}, calculateEndDate:function(startDate, duration, unit) {
  if (!duration) {
    return new Date(startDate);
  }
  var DATE = Sch.util.Date, endDate;
  duration = this.convertDurationToMs(duration, unit);
  var startFrom = duration === 0 && Ext.Date.clearTime(startDate, true) - startDate === 0 ? DATE.add(startDate, Sch.util.Date.DAY, -1) : startDate;
  this.forEachAvailabilityInterval({startDate:startFrom}, function(intervalStartDate, intervalEndDate) {
    var diff = intervalEndDate - intervalStartDate;
    var dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
    if (diff >= duration) {
      endDate = new Date(intervalStartDate - 0 + duration);
      return false;
    } else {
      duration -= diff + dstDiff * 60 * 1000;
    }
  });
  return endDate;
}, calculateStartDate:function(endDate, duration, unit) {
  if (!duration) {
    return new Date(endDate);
  }
  var startDate;
  duration = this.convertDurationToMs(duration, unit);
  this.forEachAvailabilityInterval({endDate:endDate, isForward:false}, function(intervalStartDate, intervalEndDate) {
    var diff = intervalEndDate - intervalStartDate;
    if (diff >= duration) {
      startDate = new Date(intervalEndDate - duration);
      return false;
    } else {
      duration -= diff;
    }
  });
  return startDate;
}, skipNonWorkingTime:function(date, isForward) {
  var found = false;
  this.forEachAvailabilityInterval(isForward ? {startDate:date} : {endDate:date, isForward:false}, function(intervalStartDate, intervalEndDate) {
    date = isForward ? intervalStartDate : intervalEndDate;
    found = true;
    return false;
  });
  if (!found) {
    throw new Error('skipNonWorkingTime: Cannot skip non-working time, please ensure that this calendar has any working period of time specified');
  }
  return new Date(date);
}, skipWorkingTime:function(date, duration, unit) {
  return duration >= 0 ? this.calculateEndDate(date, duration, unit) : this.calculateStartDate(date, -duration, unit);
}, getAvailabilityIntervalsFor:function(timeDate, noNeedToClearTime) {
  if (noNeedToClearTime) {
    timeDate = timeDate.valueOf();
  } else {
    if (timeDate instanceof Date) {
      timeDate = (new Date(timeDate.getFullYear(), timeDate.getMonth(), timeDate.getDate())).valueOf();
    } else {
      timeDate = Ext.Date.clearTime(new Date(timeDate)).valueOf();
    }
  }
  return this.availabilityIntervalsCache[timeDate] = this.availabilityIntervalsCache[timeDate] || this.getCalendarDay(timeDate).getAvailabilityIntervalsFor(timeDate);
}, isChildOf:function(calendar) {
  var parent = this, found = false;
  while (parent && !found) {
    found = parent === calendar;
    parent = parent.parent;
  }
  return found;
}, getParentableCalendars:function() {
  var me = this, result = [], calendars = Sch.data.Calendar.getAllCalendars();
  Ext.Array.each(calendars, function(calendar) {
    if (calendar !== me && !calendar.isChildOf(me)) {
      result.push({Id:calendar.calendarId, Name:calendar.name || calendar.calendarId});
    }
  });
  return result;
}, setParent:function(parentOrId) {
  var parent = Sch.data.Calendar.getCalendar(parentOrId);
  if (parentOrId && !parent) {
    throw new Error('Invalid parent specified for the calendar');
  }
  if (this.parent != parent) {
    var proxy = this.proxy;
    var listeners = {calendarchange:this.onParentCalendarChange, destroy:this.onParentDestroy, scope:this};
    var oldParent = this.parent;
    if (oldParent) {
      oldParent.un(listeners);
    }
    this.parent = parent;
    if (parent) {
      parent.on(listeners);
    }
    if (proxy && proxy.extraParams) {
      proxy.extraParams.parentId = parent ? parent.calendarId : null;
    }
    this.clearCache();
    this.fireEvent('parentchange', this, parent, oldParent);
  }
}, onParentCalendarChange:function() {
  this.clearCache();
}, onParentDestroy:function() {
  this.setParent(null);
}, isAvailabilityIntersected:function(withCalendar, startDate, endDate) {
  var ownWeekDay, ownAvailability, testWeekDay, testAvailability;
  for (var i = 0; i < 7; i++) {
    ownWeekDay = this.getWeekDay(i) || this.getDefaultCalendarDay(i);
    testWeekDay = withCalendar.getWeekDay(i) || withCalendar.getDefaultCalendarDay(i);
    if (!ownWeekDay || !testWeekDay) {
      continue;
    }
    ownAvailability = ownWeekDay.getAvailability();
    testAvailability = testWeekDay.getAvailability();
    for (var j = 0, l = ownAvailability.length; j < l; j++) {
      for (var k = 0, ll = testAvailability.length; k < ll; k++) {
        if (testAvailability[k].startTime < ownAvailability[j].endTime && testAvailability[k].endTime > ownAvailability[j].startTime) {
          return true;
        }
      }
    }
  }
  var result = false;
  this.forEachNonStandardWeek(function(week) {
    if (week.startDate >= endDate) {
      return false;
    }
    if (startDate < week.endDate) {
      result = true;
      return false;
    }
  });
  return result;
}}, 1, 0, 0, 0, ['store.calendar'], [[Sch.data.mixin.UniversalModelGetter.prototype.mixinId || Sch.data.mixin.UniversalModelGetter.$className, Sch.data.mixin.UniversalModelGetter], [Robo.data.Store.prototype.mixinId || Robo.data.Store.$className, Robo.data.Store]], [Sch.data, 'Calendar'], 0);
Ext.cmd.derive('Sch.model.DependencyBase', Sch.model.Customizable, {isDependencyModel:true, inheritableStatics:{Type:{StartToStart:0, StartToEnd:1, EndToStart:2, EndToEnd:3}}, idProperty:'Id', customizableFields:[{name:'From'}, {name:'To'}, {name:'Type', type:'int', defaultValue:2}, {name:'Cls', defaultValue:''}, {name:'Bidirectional', type:'boolean'}, {name:'FromSide', type:'string'}, {name:'ToSide', type:'string'}, {name:'Highlighted', type:'string', persist:false, defaultValue:''}], fromField:'From', 
toField:'To', typeField:'Type', clsField:'Cls', bidirectionalField:'Bidirectional', highlightedField:'Highlighted', constructor:function(config) {
  var me = this;
  Sch.model.Customizable.prototype.constructor.apply(this, arguments);
  if (config) {
    if (config[me.fromField] && config[me.fromField].isRangeModel) {
      me.setSourceEvent(config[me.fromField]);
      delete config.fromField;
    }
    if (config[me.toField] && config[me.toField].isRangeModel) {
      me.setTargetEvent(config[me.toField]);
      delete config.toField;
    }
  }
}, getEventStore:function() {
  return this.store.getEventStore();
}, getSourceEvent:function(eventStore) {
  var me = this;
  return (eventStore || me.getEventStore()).getModelById(me.getSourceId());
}, setSourceEvent:function(event) {
  this.setSourceId(event.getId());
}, getTargetEvent:function(eventStore) {
  var me = this;
  return (eventStore || me.getEventStore()).getModelById(me.getTargetId());
}, setTargetEvent:function(event) {
  this.setTargetId(event.getId());
}, getSourceId:function() {
  return this.getFrom();
}, setSourceId:function(id) {
  return this.setFrom(id);
}, getTargetId:function() {
  return this.getTo();
}, setTargetId:function(id) {
  return this.setTo(id);
}, isPersistable:function() {
  var me = this, source = me.getSourceEvent(), target = me.getTargetEvent();
  return source && !source.phantom && target && !target.phantom;
}, getDateRange:function() {
  var sourceTask = this.getSourceEvent();
  var targetTask = this.getTargetEvent();
  if (sourceTask && targetTask && sourceTask.isScheduled() && targetTask.isScheduled()) {
    var Type = this.self.Type;
    var sourceDate, targetDate;
    switch(this.getType()) {
      case Type.StartToStart:
        sourceDate = sourceTask.getStartDate();
        targetDate = targetTask.getStartDate();
        break;
      case Type.StartToEnd:
        sourceDate = sourceTask.getStartDate();
        targetDate = targetTask.getEndDate();
        break;
      case Type.EndToEnd:
        sourceDate = sourceTask.getEndDate();
        targetDate = targetTask.getEndDate();
        break;
      case Type.EndToStart:
        sourceDate = sourceTask.getEndDate();
        targetDate = targetTask.getStartDate();
        break;
    }
    return {start:Sch.util.Date.min(sourceDate, targetDate), end:Sch.util.Date.max(sourceDate, targetDate)};
  }
  return null;
}, highlight:function(cls) {
  var me = this, h = me.getHighlighted().split(' ');
  !Ext.Array.contains(h, cls) && me.setHighlighted(h.concat(cls).join(' '));
}, unhighlight:function(cls) {
  var me = this, h = me.getHighlighted().split(' ');
  Ext.Array.contains(h, cls) && me.setHighlighted(Ext.Array.remove(h, cls).join(' '));
}, isHighlightedWith:function(cls) {
  var me = this, h = me.getHighlighted().split(' ');
  return Ext.Array.contains(h, cls);
}}, 1, 0, 0, 0, 0, 0, [Sch.model, 'DependencyBase'], 0);
Ext.cmd.derive('Sch.model.Dependency', Sch.model.DependencyBase, {isValid:function(taskStore) {
  var me = this, valid = Sch.model.DependencyBase.prototype.isValid.apply(this, arguments), sourceId = me.getSourceId(), targetId = me.getTargetId(), type = me.getType();
  return Ext.isNumber(type) && !Ext.isEmpty(sourceId) && !Ext.isEmpty(targetId) && sourceId != targetId;
}, getTypeFromSides:function(fromSide, toSide, rtl) {
  var types = this.self.Type, startSide = rtl ? 'right' : 'left', endSide = rtl ? 'left' : 'right';
  if (fromSide === startSide) {
    return toSide === startSide ? types.StartToStart : types.StartToEnd;
  }
  return toSide === endSide ? types.EndToEnd : types.EndToStart;
}}, 0, 0, 0, 0, 0, 0, [Sch.model, 'Dependency'], 0);
Ext.cmd.derive('Sch.data.util.IdConsistencyManager', Ext.Base, {config:{eventStore:null, resourceStore:null, assignmentStore:null, dependencyStore:null}, eventStoreDetacher:null, resourceStoreDetacher:null, constructor:function(config) {
  this.initConfig(config);
}, updateEventStore:function(newEventStore, oldEventStore) {
  var me = this;
  Ext.destroyMembers(me, 'eventStoreDetacher');
  if (newEventStore) {
    me.eventStoreDetacher = newEventStore.on({idchanged:me.onEventIdChanged, scope:me, destroyable:true, priority:200});
  }
}, updateResourceStore:function(newResourceStore, oldResourceStore) {
  var me = this;
  Ext.destroyMembers(me, 'resourceStoreDetacher');
  if (newResourceStore) {
    me.resourceStoreDetacher = newResourceStore.on({idchanged:me.onResourceIdChanged, scope:me, destroyable:true, priority:200});
  }
}, onEventIdChanged:function(eventStore, event, oldId, newId) {
  var me = this, assignmentStore = me.getAssignmentStore(), dependencyStore = me.getDependencyStore(), assignmentsUpdater, dependenciesUpdater;
  if (assignmentStore) {
    assignmentsUpdater = me.getUpdateAssignmentEventIdFieldFn(assignmentStore, oldId, newId);
  }
  if (dependencyStore) {
    dependenciesUpdater = me.getUpdateDependencySourceTargedIdFieldFn(dependencyStore, oldId, newId);
  }
  if (assignmentsUpdater || dependenciesUpdater) {
    eventStore.on('update', function() {
      assignmentsUpdater && assignmentsUpdater();
      dependenciesUpdater && dependenciesUpdater();
    }, null, {single:true, priority:200});
  }
}, onResourceIdChanged:function(resourceStore, resource, oldId, newId) {
  var me = this, eventStore = me.getEventStore(), assignmentStore = me.getAssignmentStore(), eventsUpdater, assignmentsUpdater;
  if (eventStore && !assignmentStore) {
    eventsUpdater = me.getUpdateEventResourceIdFieldFn(eventStore, oldId, newId);
  }
  if (assignmentStore) {
    assignmentsUpdater = me.getUpdateAssignmentResourceIdFieldFn(assignmentStore, oldId, newId);
  }
  if (eventsUpdater || assignmentStore) {
    resourceStore.on('update', function() {
      eventsUpdater && eventsUpdater();
      assignmentsUpdater && assignmentsUpdater();
    }, null, {single:true, priority:200});
  }
}, getUpdateEventResourceIdFieldFn:function(eventStore, oldId, newId) {
  var events = eventStore.getRange();
  return function() {
    Ext.Array.each(events, function(event) {
      event.getResourceId() == oldId && event.setResourceId(newId);
    });
  };
}, getUpdateAssignmentEventIdFieldFn:function(assignmentStore, oldId, newId) {
  var assignments = assignmentStore.getAssignmentsForEvent(oldId);
  return function() {
    Ext.Array.each(assignments, function(assignment) {
      assignment.getEventId() == oldId && assignment.setEventId(newId);
    });
  };
}, getUpdateAssignmentResourceIdFieldFn:function(assignmentStore, oldId, newId) {
  var assignments = assignmentStore.getAssignmentsForResource(oldId);
  return function() {
    Ext.Array.each(assignments, function(assignment) {
      assignment.getResourceId() == oldId && assignment.setResourceId(newId);
    });
  };
}, getUpdateDependencySourceTargedIdFieldFn:function(dependencyStore, oldId, newId) {
  var dependencies = dependencyStore.getEventDependencies(oldId);
  return function() {
    Ext.Array.each(dependencies, function(dependency) {
      dependency.getSourceId() == oldId && dependency.setSourceId(newId);
      dependency.getTargetId() == oldId && dependency.setTargetId(newId);
    });
  };
}}, 1, 0, 0, 0, 0, 0, [Sch.data.util, 'IdConsistencyManager'], 0);
Ext.cmd.derive('Sch.data.util.ModelPersistencyManager', Ext.Base, {config:{eventStore:null, resourceStore:null, assignmentStore:null, dependencyStore:null}, eventStoreDetacher:null, resourceStoreDetacher:null, assignmentStoreDetacher:null, dependencyStoreDetacher:null, constructor:function(config) {
  this.initConfig(config);
}, updateEventStore:function(newEventStore, oldEventStore) {
  var me = this;
  Ext.destroyMembers(me, 'eventStoreDetacher');
  if (newEventStore && newEventStore.autoSync) {
    me.eventStoreDetacher = newEventStore.on({beforesync:me.onEventStoreBeforeSync, scope:me, destroyable:true, priority:100});
  }
}, updateResourceStore:function(newResourceStore, oldResourceStore) {
  var me = this;
  Ext.destroyMembers(me, 'resourceStoreDetacher');
  if (newResourceStore && newResourceStore.autoSync) {
    me.resourceStoreDetacher = newResourceStore.on({beforesync:me.onResourceStoreBeforeSync, scope:me, destroyable:true, priority:100});
  }
}, updateAssignmentStore:function(newAssignmentStore, oldAssignmentStore) {
  var me = this;
  Ext.destroyMembers(me, 'assignmentStoreDetacher');
  if (newAssignmentStore && newAssignmentStore.autoSync) {
    me.assignmentStoreDetacher = newAssignmentStore.on({beforesync:me.onAssignmentStoreBeforeSync, scope:me, destroyable:true, priority:100});
  }
}, updateDependencyStore:function(newDependencyStore, oldDependencyStore) {
  var me = this;
  Ext.destroyMembers(me, 'dependencyStoreDetacher');
  if (newDependencyStore && newDependencyStore.autoSync) {
    me.dependencyStoreDetacher = newDependencyStore.on({beforesync:me.onDependencyStoreBeforeSync, scope:me, destroyable:true, priority:100});
  }
}, onEventStoreBeforeSync:function(options) {
  var me = this;
  me.removeNonPersistableRecordsToCreate(options);
  return me.shallContinueSync(options);
}, onResourceStoreBeforeSync:function(options) {
  var me = this;
  me.removeNonPersistableRecordsToCreate(options);
  return me.shallContinueSync(options);
}, onAssignmentStoreBeforeSync:function(options) {
  var me = this;
  me.removeNonPersistableRecordsToCreate(options);
  return me.shallContinueSync(options);
}, onDependencyStoreBeforeSync:function(options) {
  var me = this;
  me.removeNonPersistableRecordsToCreate(options);
  return me.shallContinueSync(options);
}, removeNonPersistableRecordsToCreate:function(options) {
  var recordsToCreate = options.create || [], r, i;
  for (i = recordsToCreate.length - 1; i >= 0; --i) {
    r = recordsToCreate[i];
    if (!r.isPersistable()) {
      Ext.Array.remove(recordsToCreate, r);
    }
  }
  if (recordsToCreate.length === 0) {
    delete options.create;
  }
}, shallContinueSync:function(options) {
  return Boolean(options.create && options.create.length > 0 || options.update && options.update.length > 0 || options.destroy && options.destroy.length > 0);
}}, 1, 0, 0, 0, 0, 0, [Sch.data.util, 'ModelPersistencyManager'], 0);
Ext.cmd.derive('Sch.data.util.ResourceEventsCache', Sch.util.Cache, {eventStore:null, eventStoreDetacher:null, resourceStoreDetacher:null, constructor:function(eventStore) {
  var me = this, resourceStore = eventStore.getResourceStore();
  Sch.util.Cache.prototype.constructor.call(this);
  function onEventAdd(eventStore, events) {
    Ext.Array.each(events, function(event) {
      me.add(event.getResourceId(), event);
    });
  }
  function onEventRemove(eventStore, events) {
    Ext.Array.each(events, function(event) {
      me.remove(event.getResourceId(), event);
    });
  }
  function onEventUpdate(eventStore, event, operation, modifiedFieldNames) {
    var resourceIdField = event.resourceIdField, resourceIdChanged = event.previous && resourceIdField in event.previous, previousResourceId = resourceIdChanged && event.previous[resourceIdField];
    if (resourceIdChanged) {
      me.move(previousResourceId, event.getResourceId(), event);
    }
  }
  function onEventStoreClearOrReset() {
    me.clear();
  }
  function onEventStoreResourceStoreChange(eventStore, newResourceStore, oldResourceStore) {
    me.clear();
    attachToResourceStore(newResourceStore);
  }
  function onResourceIdChanged(resourceStore, resource, oldId, newId) {
    me.move(oldId, newId);
  }
  function onResourceRemove(resourceStore, resources) {
    Ext.Array.each(resources, function(resource) {
      me.clear(resource);
    });
  }
  function onResourceStoreClearOrReset() {
    me.clear();
  }
  function attachToResourceStore(resourceStore) {
    Ext.destroy(me.resourceStoreDetacher);
    me.resourceStoreDetacher = resourceStore && resourceStore.on({idchanged:onResourceIdChanged, remove:onResourceRemove, clear:onResourceStoreClearOrReset, cacheresethint:onResourceStoreClearOrReset, rootchange:onResourceStoreClearOrReset, priority:100, destroyable:true});
  }
  me.eventStoreDetacher = eventStore.on({add:onEventAdd, remove:onEventRemove, update:onEventUpdate, clear:onEventStoreClearOrReset, cacheresethint:onEventStoreClearOrReset, rootchange:onEventStoreClearOrReset, resourcestorechange:onEventStoreResourceStoreChange, priority:100, destroyable:true});
  me.eventStoreFiltersDetacher = eventStore.getFilters().on('endupdate', onEventStoreClearOrReset, this, {priority:1002, destroyable:true});
  attachToResourceStore(resourceStore);
  me.eventStore = eventStore;
}, destroy:function() {
  var me = this;
  Ext.destroyMembers(me, 'eventStoreDetacher', 'eventStoreFiltersDetacher', 'resourceStoreDetacher');
  me.eventStore = null;
}, get:function(k, fn) {
  var me = this;
  k = me.key(k);
  fn = fn || function() {
    return Ext.Array.filter(me.eventStore.getRange(), function(event) {
      return event.getResourceId() == k;
    });
  };
  return Sch.util.Cache.prototype.get.call(this, k, fn);
}}, 1, 0, 0, 0, 0, 0, [Sch.data.util, 'ResourceEventsCache'], 0);
Ext.cmd.derive('Sch.data.mixin.EventStore', Ext.Mixin, {isEventStore:true, resourceStore:null, resourceStoreDetacher:null, assignmentStore:null, resourceEventsCache:null, idConsistencyManager:null, modelPersistencyManager:null, mixinConfig:{after:{constructor:'constructor', destroy:'destroy'}}, constructor:function() {
  var me = this;
  me.resourceEventsCache = me.createResourceEventsCache();
  me.idConsistencyManager = me.createIdConsistencyManager();
  me.modelPersistencyManager = me.createModelPersistencyManager();
}, destroy:function() {
  var me = this;
  Ext.destroyMembers(me, 'resourceEventsCache', 'idConsistencyManager', 'modelPersistencyManager');
}, createResourceEventsCache:function() {
  return new Sch.data.util.ResourceEventsCache(this);
}, createIdConsistencyManager:function() {
  var me = this;
  return new Sch.data.util.IdConsistencyManager({eventStore:me, resourceStore:me.getResourceStore(), assignmentStore:me.getAssignmentStore(), dependencyStore:me.getDependencyStore()});
}, createModelPersistencyManager:function() {
  var me = this;
  return new Sch.data.util.ModelPersistencyManager({eventStore:me, resourceStore:me.getResourceStore(), assignmentStore:me.getAssignmentStore(), dependencyStore:me.getDependencyStore()});
}, getResourceStore:function() {
  return this.resourceStore;
}, setResourceStore:function(resourceStore) {
  var me = this, oldStore = me.resourceStore;
  if (me.resourceStore) {
    me.resourceStore.setEventStore(null);
    me.idConsistencyManager && me.idConsistencyManager.setResourceStore(null);
    me.modelPersistencyManager && me.modelPersistencyManager.setResourceStore(null);
  }
  me.resourceStore = resourceStore && Ext.StoreMgr.lookup(resourceStore) || null;
  if (me.resourceStore) {
    me.modelPersistencyManager && me.modelPersistencyManager.setResourceStore(me.resourceStore);
    me.idConsistencyManager && me.idConsistencyManager.setResourceStore(me.resourceStore);
    resourceStore.setEventStore(me);
  }
  if ((oldStore || resourceStore) && oldStore !== resourceStore) {
    me.fireEvent('resourcestorechange', me, resourceStore, oldStore);
  }
}, getAssignmentStore:function() {
  return this.assignmentStore;
}, setAssignmentStore:function(assignmentStore) {
  var me = this, oldStore = me.assignmentStore;
  if (me.assignmentStore) {
    me.assignmentStore.setEventStore(null);
    me.idConsistencyManager && me.idConsistencyManager.setAssignmentStore(null);
    me.modelPersistencyManager && me.modelPersistencyManager.setAssignmentStore(null);
  }
  me.assignmentStore = assignmentStore && Ext.StoreMgr.lookup(assignmentStore) || null;
  if (me.assignmentStore) {
    me.modelPersistencyManager && me.modelPersistencyManager.setAssignmentStore(me.assignmentStore);
    me.idConsistencyManager && me.idConsistencyManager.setAssignmentStore(me.assignmentStore);
    me.assignmentStore.setEventStore(me);
    Ext.destroy(me.resourceEventsCache);
  } else {
    me.resourceEventsCache = me.createResourceEventsCache();
  }
  if ((oldStore || assignmentStore) && oldStore !== assignmentStore) {
    me.fireEvent('assignmentstorechange', me, assignmentStore, oldStore);
  }
}, getDependencyStore:function() {
  return this.dependencyStore;
}, setDependencyStore:function(dependencyStore) {
  var me = this, oldStore = me.DependencyStore;
  if (me.dependencyStore) {
    me.dependencyStore.setEventStore(null);
    me.idConsistencyManager && me.idConsistencyManager.setDependencyStore(null);
    me.modelPersistencyManager && me.modelPersistencyManager.setDependencyStore(null);
  }
  me.dependencyStore = dependencyStore && Ext.StoreMgr.lookup(dependencyStore) || null;
  if (me.dependencyStore) {
    me.modelPersistencyManager && me.modelPersistencyManager.setDependencyStore(me.dependencyStore);
    me.idConsistencyManager && me.idConsistencyManager.setDependencyStore(me.dependencyStore);
    me.dependencyStore.setEventStore(me);
  }
  if ((oldStore || dependencyStore) && oldStore !== dependencyStore) {
    me.fireEvent('dependencystorechange', me, dependencyStore, oldStore);
  }
}, isDateRangeAvailable:function(start, end, excludeEvent, resource) {
  var DATE = Sch.util.Date, events = this.getEventsForResource(resource), available = true;
  if (Sch.model.Assignment && excludeEvent instanceof Sch.model.Assignment) {
    excludeEvent = excludeEvent.getEvent(this);
  }
  Ext.each(events, function(ev) {
    available = excludeEvent === ev || !DATE.intersectSpans(start, end, ev.getStartDate(), ev.getEndDate());
    return available;
  });
  return available;
}, getEventsInTimeSpan:function(start, end, allowPartial) {
  var coll = new Ext.util.MixedCollection;
  var events = [];
  if (allowPartial !== false) {
    var DATE = Sch.util.Date;
    this.forEachScheduledEvent(function(event, eventStart, eventEnd) {
      if (DATE.intersectSpans(eventStart, eventEnd, start, end)) {
        events.push(event);
      }
    });
  } else {
    this.forEachScheduledEvent(function(event, eventStart, eventEnd) {
      if (eventStart - start >= 0 && end - eventEnd >= 0) {
        events.push(event);
      }
    });
  }
  coll.addAll(events);
  return coll;
}, getEventsByStartDate:function(start) {
  var DATE = Sch.util.Date;
  var events = [];
  this.forEachScheduledEvent(function(event, eventStart, eventEnd) {
    if (DATE.compareWithPrecision(eventStart, start, DATE.DAY) === 0) {
      events.push(event);
    }
  });
  return events;
}, forEachScheduledEvent:function(fn, scope) {
  this.each(function(event) {
    var eventStart = event.getStartDate(), eventEnd = event.getEndDate();
    if (eventStart && eventEnd) {
      return fn.call(scope || this, event, eventStart, eventEnd);
    }
  }, this);
}, getTotalTimeSpan:function() {
  var earliest = Sch.util.Date.MAX_VALUE, latest = Sch.util.Date.MIN_VALUE, D = Sch.util.Date;
  this.each(function(r) {
    if (r.getStartDate()) {
      earliest = D.min(r.getStartDate(), earliest);
    }
    if (r.getEndDate()) {
      latest = D.max(r.getEndDate(), latest);
    }
  });
  earliest = earliest < Sch.util.Date.MAX_VALUE ? earliest : null;
  latest = latest > Sch.util.Date.MIN_VALUE ? latest : null;
  this.lastTotalTimeSpan = {start:earliest || null, end:latest || earliest || null};
  return this.lastTotalTimeSpan;
}, filterEventsForResource:function(resource, fn, scope) {
  var events = resource.getEvents(this);
  return Ext.Array.filter(events, fn, scope || this);
}, append:function(record) {
  throw 'Must be implemented by consuming class';
}, getResourcesForEvent:function(event) {
  var me = this, assignmentStore = me.getAssignmentStore(), resourceStore = me.getResourceStore(), result;
  if (assignmentStore) {
    result = assignmentStore.getResourcesForEvent(event);
  } else {
    if (resourceStore) {
      event = event instanceof Sch.model.Event && event || me.getModelById(event);
      result = event && resourceStore.getModelById(event.getResourceId());
      result = result && [result] || [];
    } else {
      result = [];
    }
  }
  return result;
}, getEventsForResource:function(resource) {
  var me = this, assignmentStore = me.getAssignmentStore(), result;
  if (assignmentStore) {
    result = assignmentStore.getEventsForResource(resource);
  } else {
    if (me.resourceEventsCache) {
      result = me.resourceEventsCache.get(resource);
    } else {
      result = [];
    }
  }
  return result;
}, getAssignmentsForEvent:function(event) {
  var me = this, assignmentStore = me.getAssignmentStore();
  return assignmentStore && assignmentStore.getAssignmentsForEvent(event) || [];
}, getAssignmentsForResource:function(resource) {
  var me = this, assignmentStore = me.getAssignmentStore();
  return assignmentStore && assignmentStore.getAssignmentsForResource(resource) || [];
}, assignEventToResource:function(event, resource) {
  var me = this, assignmentStore = me.getAssignmentStore();
  if (assignmentStore) {
    assignmentStore.assignEventToResource(event, resource);
  } else {
    if (Ext.isArray(resource)) {
      resource = resource[0];
    }
    event = event instanceof Sch.model.Event && event || me.getModelById(event);
    resource = resource instanceof Sch.model.Resource ? resource.getId() : resource;
    event && event.setResourceId(resource);
  }
}, unassignEventFromResource:function(event, resource) {
  var me = this, assignmentStore = me.getAssignmentStore();
  if (assignmentStore) {
    assignmentStore.unassignEventFromResource(event, resource);
  } else {
    event = event instanceof Sch.model.Event && event || me.getModelById(event);
    resource = resource instanceof Sch.model.Resource ? resource.getId() : resource;
    if (event && (typeof resource == 'undefined' || event.getResourceId() == resource)) {
      event.setResourceId(null);
    }
  }
}, reassignEventFromResourceToResource:function(event, oldResource, newResource) {
  var me = this, assignmentStore = me.getAssignmentStore();
  var newResourceId = newResource instanceof Sch.model.Resource ? newResource.getId() : newResource;
  var oldResourceId = oldResource instanceof Sch.model.Resource ? oldResource.getId() : oldResource;
  if (assignmentStore) {
    var assignment = assignmentStore.getAssignmentForEventAndResource(event, oldResource);
    if (assignment) {
      assignment.setResourceId(newResourceId);
    } else {
      assignmentStore.assignEventToResource(event, newResource);
    }
  } else {
    event = event instanceof Sch.model.Event && event || me.getModelById(event);
    if (event.getResourceId() == oldResourceId) {
      event.setResourceId(newResourceId);
    }
  }
}, isEventAssignedToResource:function(event, resource) {
  var me = this, assignmentStore = me.getAssignmentStore(), result;
  if (assignmentStore) {
    result = assignmentStore.isEventAssignedToResource(event, resource);
  } else {
    event = event instanceof Sch.model.Event && event || me.getModelById(event);
    resource = resource instanceof Sch.model.Resource ? resource.getId() : resource;
    result = event && event.getResourceId() == resource || false;
  }
  return result;
}, removeAssignmentsForEvent:function(event) {
  var me = this, assignmentStore = me.getAssignmentStore();
  if (assignmentStore) {
    assignmentStore.removeAssignmentsForEvent(event);
  } else {
    event = event instanceof Sch.model.Event && event || me.getModelById(event);
    event && event.setResourceId(null);
  }
}, removeAssignmentsForResource:function(resource) {
  var me = this, assignmentStore = me.getAssignmentStore(), resourceStore = me.getResourceStore();
  if (assignmentStore) {
    assignmentStore.removeAssignmentsForResource(resource);
  } else {
    if (resourceStore) {
      resource = resource instanceof Sch.model.Resource && resource || resourceStore.getModelById(resource);
      resource && Ext.Array.each(me.resourceEventsCache.get(resource), function(event) {
        event.setResourceId(null);
      });
    } else {
      resource = resource instanceof Sch.model.Resource ? resource.getId() : resource;
      Ext.Array.each(me.getRange(), function(event) {
        event.getResourceId() == resource && event.setResourceId(null);
      });
    }
  }
}, isEventPersistable:function(event) {
  var me = this, assignmentStore = me.getAssignmentStore(), resources, i, len, result = true;
  if (!assignmentStore) {
    resources = event.getResources();
    for (i = 0, len = resources.length; result && i < len; ++i) {
      result = resources[i].phantom !== true;
    }
  }
  return result;
}}, 1, 0, 0, 0, 0, 0, [Sch.data.mixin, 'EventStore'], 0);
Ext.cmd.derive('Sch.model.Event', Sch.model.Range, {idProperty:'Id', isEventModel:true, customizableFields:[{name:'IconCls'}, {name:'ResourceId'}, {name:'Draggable', type:'boolean', persist:false, defaultValue:true}, {name:'Resizable', persist:false, defaultValue:true}], resourceIdField:'ResourceId', draggableField:'Draggable', resizableField:'Resizable', iconClsField:'IconCls', getInternalId:function() {
  return this.internalId;
}, isHighlighted:false, getEventStore:function() {
  var me = this, result = me.joined && me.joined[0];
  if (result && !result.isEventStore) {
    Ext.Array.sort(me.joined, function(a, b) {
      return (a.isEventStore || false) > (b.isEventStore || false) && -1 || 1;
    });
    result = me.joined[0];
    result = result.isEventStore ? result : null;
  }
  return result;
}, getResourceStore:function() {
  var eventStore = this.getEventStore();
  return eventStore && eventStore.getResourceStore();
}, getAssignmentStore:function() {
  var eventStore = this.getEventStore();
  return eventStore && eventStore.getAssignmentStore();
}, getResources:function(eventStore) {
  var me = this;
  eventStore = eventStore || me.getEventStore();
  return eventStore && eventStore.getResourcesForEvent(me) || [];
}, forEachResource:function(fn, scope) {
  var rs = this.getResources();
  for (var i = 0; i < rs.length; i++) {
    if (fn.call(scope || this, rs[i]) === false) {
      return;
    }
  }
}, getResource:function(resourceId) {
  var me = this, result = null, eventStore = me.getEventStore(), resourceStore = eventStore && eventStore.getResourceStore();
  resourceId = resourceId == null ? me.getResourceId() : resourceId;
  if (eventStore && (resourceId === null || resourceId === undefined)) {
    result = eventStore.getResourcesForEvent(me);
    if (result.length == 1) {
      result = result[0];
    } else {
      if (result.length > 1) {
        Ext.Error.raise('Event::getResource() is not applicable for events with multiple assignments, please use Event::getResources() instead.');
      } else {
        result = null;
      }
    }
  } else {
    if (resourceStore) {
      result = resourceStore.getModelById(resourceId);
    }
  }
  return result;
}, setResource:function(resource) {
  var me = this, eventStore = me.getEventStore();
  eventStore && eventStore.removeAssignmentsForEvent(me);
  me.assign(resource);
}, assign:function(resource) {
  var me = this, eventStore = me.getEventStore();
  if (resource && resource.isResourceModel) {
    resource = resource.getId();
  }
  if (eventStore) {
    eventStore.assignEventToResource(me, resource);
  } else {
    me.setResourceId(resource);
  }
}, unassign:function(resource) {
  var me = this, eventStore = me.getEventStore();
  if (resource && resource.isResourceModel) {
    resource = resource.getId();
  }
  if (eventStore) {
    eventStore.unassignEventFromResource(me, resource);
  } else {
    if (me.getResourceId() == resource) {
      me.setResourceId(null);
    }
  }
}, reassign:function(oldResource, newResource) {
  var me = this, eventStore = me.getEventStore();
  if (oldResource && oldResource.isResourceModel) {
    oldResource = oldResource.getId();
  }
  if (newResource && newResource.isResourceModel) {
    newResource = newResource.getId();
  }
  if (eventStore) {
    eventStore.reassignEventFromResourceToResource(me, oldResource, newResource);
  } else {
    me.setResourceId(newResource);
  }
}, isAssignedTo:function(resource) {
  var me = this, eventStore = me.getEventStore(), result = false;
  if (resource && resource.isResourceModel) {
    resource = resource.getId();
  }
  if (eventStore) {
    result = eventStore.isEventAssignedToResource(me, resource);
  } else {
    result = me.getResourceId() == resource;
  }
  return result;
}, getAssignments:function() {
  var me = this, eventStore = me.getEventStore();
  return eventStore && eventStore.getAssignmentsForEvent(me);
}, isDraggable:function() {
  return this.getDraggable();
}, isResizable:function() {
  return this.getResizable();
}, isPersistable:function() {
  var me = this, eventStore = me.getEventStore();
  return eventStore && eventStore.isEventPersistable(me);
}}, 0, 0, 0, 0, 0, 0, [Sch.model, 'Event'], 0);
Ext.cmd.derive('Sch.data.EventStore', Ext.data.Store, {storeId:'events', model:'Sch.model.Event', config:{model:'Sch.model.Event'}, constructor:function(config) {
  var me = this;
  Ext.data.Store.prototype.constructor.call(this, config);
  me.resourceStore && me.setResourceStore(me.resourceStore);
  me.assignmentStore && me.setAssignmentStore(me.assignmentStore);
  if (me.getModel() !== Sch.model.Event && !(me.getModel().prototype instanceof Sch.model.Event)) {
    throw 'The model for the EventStore must subclass Sch.model.Event';
  }
}, append:function(record) {
  this.add(record);
}}, 1, 0, 0, 0, ['store.eventstore'], [[Sch.data.mixin.UniversalModelGetter.prototype.mixinId || Sch.data.mixin.UniversalModelGetter.$className, Sch.data.mixin.UniversalModelGetter], [Sch.data.mixin.CacheHintHelper.prototype.mixinId || Sch.data.mixin.CacheHintHelper.$className, Sch.data.mixin.CacheHintHelper], [Sch.data.mixin.EventStore.prototype.mixinId || Sch.data.mixin.EventStore.$className, Sch.data.mixin.EventStore], [Robo.data.Store.prototype.mixinId || Robo.data.Store.$className, Robo.data.Store]], 
[Sch.data, 'EventStore'], 0);
Ext.cmd.derive('Sch.data.mixin.ResourceStore', Ext.Base, {eventStore:null, getEventStore:function() {
  return this.eventStore;
}, setEventStore:function(eventStore) {
  var me = this, oldStore;
  if (me.eventStore !== eventStore) {
    oldStore = me.eventStore;
    me.eventStore = eventStore && Ext.StoreMgr.lookup(eventStore) || null;
    me.fireEvent('eventstorechange', me, eventStore, oldStore);
  }
}, getScheduledEventsInTimeSpan:function(start, end, eventStore) {
  var events = [];
  var DATE = Sch.util.Date;
  eventStore = eventStore || this.getEventStore();
  Ext.Array.each(this.getRange(), function(resource) {
    Ext.Array.each(eventStore.getEventsForResource(resource), function(event) {
      if (event.intersectsRange(start, end)) {
        events.push(event);
      }
    });
  });
  return events;
}}, 0, 0, 0, 0, 0, 0, [Sch.data.mixin, 'ResourceStore'], 0);
Ext.cmd.derive('Sch.model.Resource', Sch.model.Customizable, {isResourceModel:true, idProperty:'Id', config:Ext.versions.touch ? {idProperty:'Id'} : null, nameField:'Name', customizableFields:[{name:'Name', type:'string'}], getInternalId:function() {
  return this.internalId;
}, getResourceStore:function() {
  return this.joined && this.joined[0];
}, getEventStore:function() {
  var resourceStore = this.getResourceStore();
  return resourceStore && resourceStore.getEventStore() || this.parentNode && this.parentNode.getEventStore();
}, getAssignmentStore:function() {
  var eventStore = this.getEventStore();
  return eventStore && eventStore.getAssignmentStore();
}, getEvents:function(eventStore) {
  var me = this;
  eventStore = eventStore || me.getEventStore();
  return eventStore && eventStore.getEventsForResource(me) || [];
}, getAssignments:function() {
  var me = this, eventStore = me.getEventStore();
  return eventStore && eventStore.getAssignmentsForResource(me);
}, isPersistable:function() {
  var parent = this.parentNode;
  return !parent || !parent.phantom || parent.isRoot && parent.isRoot();
}, isAbove:function(otherResource) {
  var me = this, store = me.getResourceStore(), result = false, current, myAncestors, otherAncestors, commonAncestorsLength, lastCommonAncestor;
  if (me == otherResource) {
    result = false;
  } else {
    if (store && store.isTreeStore) {
      current = me;
      myAncestors = [];
      while (current) {
        myAncestors.push(current);
        current = current.parentNode;
      }
      current = otherResource;
      otherAncestors = [];
      while (current) {
        otherAncestors.push(current);
        current = current.parentNode;
      }
      commonAncestorsLength = 0;
      while (commonAncestorsLength < myAncestors.length - 1 && commonAncestorsLength < otherAncestors.length - 1 && myAncestors[commonAncestorsLength] == otherAncestors[commonAncestorsLength]) {
        ++commonAncestorsLength;
      }
      lastCommonAncestor = myAncestors[commonAncestorsLength];
      me = myAncestors[commonAncestorsLength + 1];
      otherResource = otherAncestors[commonAncestorsLength + 1];
      result = lastCommonAncestor.indexOf(me) < lastCommonAncestor.indexOf(otherResource);
    } else {
      result = store.indexOf(me) < store.indexOf(otherResource);
    }
  }
  return result;
}}, 0, 0, 0, 0, 0, 0, [Sch.model, 'Resource'], 0);
Ext.cmd.derive('Sch.data.ResourceStore', Ext.data.Store, {model:'Sch.model.Resource', config:{model:'Sch.model.Resource'}, storeId:'resources', constructor:function() {
  Ext.data.Store.prototype.constructor.apply(this, arguments);
  if (this.getModel() !== Sch.model.Resource && !(this.getModel().prototype instanceof Sch.model.Resource)) {
    throw 'The model for the ResourceStore must subclass Sch.model.Resource';
  }
}}, 1, 0, 0, 0, ['store.resourcestore'], [[Sch.data.mixin.UniversalModelGetter.prototype.mixinId || Sch.data.mixin.UniversalModelGetter.$className, Sch.data.mixin.UniversalModelGetter], [Sch.data.mixin.CacheHintHelper.prototype.mixinId || Sch.data.mixin.CacheHintHelper.$className, Sch.data.mixin.CacheHintHelper], [Sch.data.mixin.ResourceStore.prototype.mixinId || Sch.data.mixin.ResourceStore.$className, Sch.data.mixin.ResourceStore], [Robo.data.Store.prototype.mixinId || Robo.data.Store.$className, 
Robo.data.Store]], [Sch.data, 'ResourceStore'], 0);
Ext.cmd.derive('Sch.patches.TreeStore', Sch.util.Patch, {target:'Ext.data.TreeStore', minVersion:'5.1.0', overrides:{remove:function(node) {
  if (node.isModel) {
    node.remove();
  } else {
    if (node instanceof Array && node[0].isModel) {
      for (var i = 0; i < node.length; i++) {
        node[i].remove();
      }
    } else {
      this.callParent(arguments);
    }
  }
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TreeStore'], 0);
Ext.cmd.derive('Sch.patches.TreeStoreInternalIdMap', Sch.util.Patch, {target:'Ext.data.TreeStore', minVersion:'5.1.1', overrides:{registerNode:function(node, includeChildren) {
  var me = this;
  if (!me.byInternalIdMap) {
    me.byInternalIdMap = {};
  }
  me.byInternalIdMap[node.internalId] = node;
  me.callParent(arguments);
}, unregisterNode:function(node, includeChildren) {
  var me = this;
  if (me.byInternalIdMap) {
    delete me.byInternalIdMap[node.internalId];
  }
  me.callParent(arguments);
}, updateRoot:function() {
  this.byInternalIdMap = {};
  this.callParent(arguments);
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TreeStoreInternalIdMap'], 0);
Ext.cmd.derive('Sch.data.mixin.FilterableTreeStore', Ext.Base, {isFilteredFlag:false, isHiddenFlag:false, treeFilter:null, lastTreeFilter:null, lastTreeHiding:null, allowExpandCollapseWhileFiltered:true, keepExpandStateWhileFiltered:false, reApplyFilterOnDataChange:true, suspendIncrementalFilterRefresh:0, filterGeneration:0, currentFilterGeneration:null, dataChangeListeners:null, monitoringDataChange:false, filterUpdateSuspended:false, onClassMixedIn:function(cls) {
  cls.override(Sch.data.mixin.FilterableTreeStore.prototype.inheritables() || {});
}, initTreeFiltering:function() {
  this.treeFilter = new Ext.util.Filter({filterFn:this.isNodeFilteredIn, scope:this});
  this.dataChangeListeners = {nodeappend:this.onNeedToUpdateFilter, nodeinsert:this.onNeedToUpdateFilter, scope:this};
  Ext.apply(this.dataChangeListeners, {beforeload:this.onStoreBeforeLoad, load:this.onStoreLoad});
}, onStoreBeforeLoad:function() {
  this.filterUpdateSuspended = true;
}, onStoreLoad:function() {
  this.filterUpdateSuspended = false;
  this.onNeedToUpdateFilter();
}, startDataChangeMonitoring:function() {
  if (this.monitoringDataChange) {
    return;
  }
  this.monitoringDataChange = true;
  this.on(this.dataChangeListeners);
}, stopDataChangeMonitoring:function() {
  if (!this.monitoringDataChange) {
    return;
  }
  this.monitoringDataChange = false;
  this.un(this.dataChangeListeners);
}, onNeedToUpdateFilter:function() {
  if (this.reApplyFilterOnDataChange && !this.filterUpdateSuspended && !this.suspendIncrementalFilterRefresh) {
    this.reApplyFilter();
  }
}, clearTreeFilter:function() {
  if (!this.isTreeFiltered()) {
    return;
  }
  this.currentFilterGeneration = null;
  this.isFilteredFlag = false;
  this.lastTreeFilter = null;
  if (!this.isTreeFiltered(true)) {
    this.stopDataChangeMonitoring();
  }
  this.refreshNodeStoreContent();
  this.fireEvent('filter-clear', this);
}, reApplyFilter:function() {
  if (this.isHiddenFlag) {
    this.hideNodesBy.apply(this, this.lastTreeHiding.concat(this.isFilteredFlag));
  }
  if (this.isFilteredFlag) {
    this.filterTreeBy(this.lastTreeFilter);
  }
}, refreshNodeStoreContent:function() {
  var me = this, filters = me.getFilters();
  if (filters.indexOf(me.treeFilter) < 0) {
    me.addFilter(me.treeFilter);
  } else {
    this.getFilters().fireEvent('endupdate', this.getFilters());
  }
}, getIndexInTotalDataset:function(record) {
  var root = this.getRootNode(), index = -1;
  var rootVisible = this.rootVisible;
  if (!rootVisible && record == root) {
    return -1;
  }
  var isFiltered = this.isTreeFiltered();
  var currentFilterGeneration = this.currentFilterGeneration;
  var collectNodes = function(node) {
    if (isFiltered && node.__filterGen != currentFilterGeneration || node.hidden) {
      if (node == record) {
        return false;
      }
    }
    if (rootVisible || node != root) {
      index++;
    }
    if (node == record) {
      return false;
    }
    if (!node.isLeaf() && node.isExpanded()) {
      var childNodes = node.childNodes, length = childNodes.length;
      for (var k = 0; k < length; k++) {
        if (collectNodes(childNodes[k]) === false) {
          return false;
        }
      }
    }
  };
  collectNodes(root);
  return index;
}, isTreeFiltered:function(orHasHiddenNodes) {
  return this.isFilteredFlag || orHasHiddenNodes && this.isHiddenFlag;
}, markFilteredNodes:function(top, params) {
  var me = this;
  var filterGen = this.currentFilterGeneration;
  var visibleNodes = {};
  var root = this.getRootNode(), rootVisible = this.rootVisible;
  var includeParentNodesInResults = function(node) {
    var parent = node.parentNode;
    while (parent && !visibleNodes[parent.internalId]) {
      visibleNodes[parent.internalId] = true;
      parent = parent.parentNode;
    }
  };
  var filter = params.filter;
  var scope = params.scope || this;
  var shallowScan = params.shallow;
  var checkParents = params.checkParents || shallowScan;
  var fullMatchingParents = params.fullMatchingParents;
  var onlyParents = params.onlyParents || fullMatchingParents;
  var isNewFilter = !params.isOldFilter;
  if (onlyParents && checkParents) {
    throw new Error("Can't combine `onlyParents` and `checkParents` options");
  }
  if (rootVisible) {
    visibleNodes[root.internalId] = true;
  }
  var collectNodes = function(node) {
    if (node.hidden) {
      return;
    }
    var nodeMatches, childNodes, length, k;
    if (node.isLeaf()) {
      if (filter.call(scope, node, visibleNodes)) {
        visibleNodes[node.internalId] = true;
        includeParentNodesInResults(node);
      }
    } else {
      if (onlyParents) {
        nodeMatches = filter.call(scope, node);
        childNodes = node.childNodes;
        length = childNodes.length;
        if (nodeMatches) {
          visibleNodes[node.internalId] = true;
          includeParentNodesInResults(node);
          if (fullMatchingParents) {
            node.cascadeBy(function(currentNode) {
              visibleNodes[currentNode.internalId] = true;
            });
            return;
          }
        }
        for (k = 0; k < length; k++) {
          if (nodeMatches && childNodes[k].isLeaf()) {
            visibleNodes[childNodes[k].internalId] = true;
          } else {
            if (!childNodes[k].isLeaf()) {
              collectNodes(childNodes[k]);
            }
          }
        }
      } else {
        if (checkParents) {
          nodeMatches = filter.call(scope, node, visibleNodes);
          if (nodeMatches) {
            visibleNodes[node.internalId] = true;
            includeParentNodesInResults(node);
          }
        }
        if (!checkParents || !shallowScan || shallowScan && (nodeMatches || node == root && !rootVisible)) {
          childNodes = node.childNodes;
          length = childNodes.length;
          for (k = 0; k < length; k++) {
            collectNodes(childNodes[k]);
          }
        }
      }
    }
  };
  collectNodes(top);
  root.cascadeBy(function(node) {
    if (isNewFilter) {
      node.addedWhileFiltered = false;
    }
    if (visibleNodes[node.internalId]) {
      node.__filterGen = filterGen;
      if (!me.keepExpandStateWhileFiltered && !node.isLeaf()) {
        node.expand();
      }
    }
  });
}, filterTreeBy:function(params, scope) {
  this.currentFilterGeneration = this.filterGeneration++;
  var filter;
  if (arguments.length == 1 && Ext.isObject(arguments[0])) {
    scope = params.scope;
    filter = params.filter;
  } else {
    filter = params;
    params = {filter:filter, scope:scope};
  }
  this.fireEvent('nodestore-datachange-start', this);
  params = params || {};
  this.markFilteredNodes(this.getRootNode(), params);
  params.isOldFilter = true;
  this.startDataChangeMonitoring();
  this.isFilteredFlag = true;
  this.lastTreeFilter = params;
  this.fireEvent('nodestore-datachange-end', this);
  this.fireEvent('filter-set', this);
  this.refreshNodeStoreContent();
}, isNodeFilteredIn:function(node) {
  var isFiltered = this.isTreeFiltered();
  var currentFilterGeneration = this.currentFilterGeneration;
  return this.loading || node.addedWhileFiltered && node.isVisible() || !Boolean(isFiltered && node.__filterGen != currentFilterGeneration || node.hidden);
}, hasNativeFilters:function() {
  var me = this, filters = me.getFilters(), count = filters.getCount();
  return count && count > 1 || filters.indexOf(me.treeFilter) < 0;
}, hideNodesBy:function(filter, scope, skipNodeStoreRefresh) {
  var me = this;
  if (me.isFiltered() && me.hasNativeFilters()) {
    throw new Error("Can't hide nodes of a filtered tree store");
  }
  scope = scope || me;
  me.getRootNode().cascadeBy(function(node) {
    node.hidden = Boolean(filter.call(scope, node, me));
  });
  me.startDataChangeMonitoring();
  me.isHiddenFlag = true;
  me.lastTreeHiding = [filter, scope];
  if (!skipNodeStoreRefresh) {
    me.refreshNodeStoreContent();
  }
}, showAllNodes:function(skipNodeStoreRefresh) {
  this.getRootNode().cascadeBy(function(node) {
    node.hidden = false;
  });
  this.isHiddenFlag = false;
  this.lastTreeHiding = null;
  if (!this.isTreeFiltered(true)) {
    this.stopDataChangeMonitoring();
  }
  if (!skipNodeStoreRefresh) {
    this.refreshNodeStoreContent();
  }
}, inheritables:function() {
  return {onNodeExpand:function(parent) {
    if (this.isTreeFiltered(true) && parent == this.getRoot()) {
      this.callParent(arguments);
      this.reApplyFilter();
    } else {
      return this.callParent(arguments);
    }
  }, onNodeCollapse:function(parent, records) {
    var me = this;
    var data = me.data;
    var prevContains = data.contains;
    var isFiltered = me.isTreeFiltered();
    var currentFilterGeneration = me.currentFilterGeneration;
    data.contains = function() {
      var node, sibling, lastNodeIndexPlus;
      var collapseIndex = me.indexOf(parent) + 1;
      var found = false;
      for (var i = 0; i < records.length; i++) {
        if (!(records[i].hidden || isFiltered && records[i].__filterGen != currentFilterGeneration) && prevContains.call(this, records[i])) {
          node = parent;
          while (node.parentNode) {
            sibling = node;
            do {
              sibling = sibling.nextSibling;
            } while (sibling && (sibling.hidden || isFiltered && sibling.__filterGen != currentFilterGeneration));
            if (sibling) {
              found = true;
              lastNodeIndexPlus = me.indexOf(sibling);
              break;
            } else {
              node = node.parentNode;
            }
          }
          if (!found) {
            lastNodeIndexPlus = me.getCount();
          }
          me.removeAt(collapseIndex, lastNodeIndexPlus - collapseIndex);
          break;
        }
      }
      return false;
    };
    this.callParent(arguments);
    if (this.isTreeFiltered()) {
      if (me.needsLocalFilter()) {
        records = Ext.Array.filter(records, me.filterVisible);
      }
      if (!records.length && me.indexOf(parent) !== -1) {
        var collapseIndex = me.indexOf(parent) + 1;
        var lastNodeIndexPlus = me.indexOfNextVisibleNode(parent);
        me.removeAt(collapseIndex, lastNodeIndexPlus - collapseIndex);
      }
    }
    data.contains = prevContains;
  }, handleNodeExpand:function(parent, records, toAdd) {
    var me = this;
    var visibleRecords = [];
    var isFiltered = me.isTreeFiltered();
    var currentFilterGeneration = me.currentFilterGeneration;
    for (var i = 0; i < records.length; i++) {
      var record = records[i];
      if (!(isFiltered && record.__filterGen != currentFilterGeneration || record.hidden)) {
        visibleRecords[visibleRecords.length] = record;
      }
    }
    return this.callParent([parent, visibleRecords, toAdd]);
  }, onNodeInsert:function(parent, node, index) {
    var me = this, refNode, sibling, storeReader, nodeProxy, nodeReader, reader, data = node.raw || node.data, removed = me.removedNodes, dataRoot, isVisible, childType, isTreeFiltered = this.isTreeFiltered();
    if (me.filterFn) {
      isVisible = me.filterFn(node);
      node.set('visible', isVisible);
      if (isVisible) {
        parent.set('visible', me.filterFn(parent));
      }
    }
    if (!this.reApplyFilterOnDataChange && isTreeFiltered) {
      node.addedWhileFiltered = true;
    }
    me.registerNode(node, true);
    me.beginUpdate();
    if (me.isVisible(node) || isTreeFiltered && node.addedWhileFiltered) {
      if (index === 0 || !node.previousSibling) {
        refNode = parent;
      } else {
        for (sibling = node.previousSibling; sibling && !sibling.addedWhileFiltered && !sibling.get('visible'); sibling = sibling.previousSibling) {
        }
        if (!sibling) {
          refNode = parent;
        } else {
          while (sibling.isExpanded() && sibling.lastChild) {
            sibling = sibling.lastChild;
          }
          for (; sibling && !sibling.addedWhileFiltered && !sibling.get('visible'); sibling = sibling.previousSibling) {
          }
          refNode = sibling;
        }
      }
      me.insert(me.indexOf(refNode) + 1, node);
      if (!node.isLeaf() && node.isExpanded()) {
        if (node.isLoaded()) {
          me.onNodeExpand(node, node.childNodes);
        } else {
          if (!me.fillCount) {
            node.set('expanded', false);
            node.expand();
          }
        }
      }
    }
    Ext.Array.remove(removed, node);
    me.needsSync = me.needsSync || node.phantom || node.dirty;
    if (!node.isLeaf() && !node.isLoaded() && !me.lazyFill) {
      storeReader = me.getProxy().getReader();
      nodeProxy = node.getProxy();
      nodeReader = nodeProxy ? nodeProxy.getReader() : null;
      reader = nodeReader && nodeReader.initialConfig.rootProperty ? nodeReader : storeReader;
      dataRoot = reader.getRoot(data);
      if (dataRoot) {
        childType = node.childType;
        me.fillNode(node, reader.extractData(dataRoot, childType ? {model:childType} : undefined));
      }
    }
    me.endUpdate();
  }, isFiltered:function() {
    return this.callParent(arguments) || this.isTreeFiltered();
  }, afterEdit:function(node, modifiedFieldNames) {
    var me = this;
    if (Ext.getVersion().isGreaterThan('6.0.2')) {
      if (me.needsLocalFilter()) {
        me.doFilter(node);
      }
      Ext.data.Store.prototype.afterEdit.apply(me, [node, modifiedFieldNames]);
    } else {
      return me.callParent([node, modifiedFieldNames]);
    }
  }};
}}, 0, 0, 0, 0, 0, 0, [Sch.data.mixin, 'FilterableTreeStore'], 0);
Ext.cmd.derive('Sch.data.ResourceTreeStore', Ext.data.TreeStore, {model:'Sch.model.Resource', storeId:'resources', constructor:function() {
  Ext.data.TreeStore.prototype.constructor.apply(this, arguments);
  this.initTreeFiltering();
  if (this.getModel() !== Sch.model.Resource && !(this.getModel().prototype instanceof Sch.model.Resource)) {
    throw 'The model for the ResourceTreeStore must subclass Sch.model.Resource';
  }
}, setRootNode:function() {
  this.isSettingRoot = true;
  var res = Ext.data.TreeStore.prototype.setRootNode.apply(this, arguments);
  this.isSettingRoot = false;
  return res;
}}, 1, 0, 0, 0, ['store.resourcetreestore'], [[Sch.data.mixin.UniversalModelGetter.prototype.mixinId || Sch.data.mixin.UniversalModelGetter.$className, Sch.data.mixin.UniversalModelGetter], [Sch.data.mixin.CacheHintHelper.prototype.mixinId || Sch.data.mixin.CacheHintHelper.$className, Sch.data.mixin.CacheHintHelper], [Sch.data.mixin.ResourceStore.prototype.mixinId || Sch.data.mixin.ResourceStore.$className, Sch.data.mixin.ResourceStore], [Sch.data.mixin.FilterableTreeStore.prototype.mixinId || Sch.data.mixin.FilterableTreeStore.$className, 
Sch.data.mixin.FilterableTreeStore], [Robo.data.Store.prototype.mixinId || Robo.data.Store.$className, Robo.data.Store]], [Sch.data, 'ResourceTreeStore'], 0);
Ext.cmd.derive('Sch.model.TimeAxisTick', Sch.model.Range, {isTimeAxisTickModel:true, startDateField:'start', endDateField:'end'}, 0, 0, 0, 0, 0, 0, [Sch.model, 'TimeAxisTick'], 0);
Ext.cmd.derive('Sch.data.TimeAxis', Ext.data.JsonStore, {model:'Sch.model.TimeAxisTick', continuous:true, originalContinuous:null, autoAdjust:true, unit:null, increment:null, resolutionUnit:null, resolutionIncrement:null, weekStartDay:null, mainUnit:null, shiftUnit:null, shiftIncrement:1, defaultSpan:1, isConfigured:false, adjustedStart:null, adjustedEnd:null, visibleTickStart:null, visibleTickEnd:null, presetName:null, mode:'plain', startTime:0, endTime:24, constructor:function(config) {
  var me = this;
  config = config || {};
  if (me.setModel) {
    me.setModel(me.model);
  }
  me.setMode(config.mode || me.mode);
  me.originalContinuous = me.continuous;
  Ext.data.JsonStore.prototype.constructor.apply(this, arguments);
  me.on(Ext.versions.touch ? 'refresh' : 'datachanged', function() {
    me.fireEvent('reconfigure', me, false);
  });
  me.on('endreconfigure', function(me, suppressRefresh) {
    me.fireEvent('reconfigure', me, suppressRefresh);
  });
  if (config.viewPreset) {
    var preset = Sch.preset.Manager.getPreset(config.viewPreset);
    preset && me.consumeViewPreset(preset);
  }
  if (config.start || me.start) {
    me.reconfigure(config);
  }
}, reconfigure:function(config, suppressRefresh) {
  this.isConfigured = true;
  Ext.apply(this, config);
  var adjusted = this.getAdjustedDates(config.start, config.end, true);
  var normalized = this.getAdjustedDates(config.start, config.end);
  var start = normalized.start;
  var end = normalized.end;
  if (this.fireEvent('beforereconfigure', this, start, end) !== false) {
    this.fireEvent('beginreconfigure', this);
    var unit = this.unit;
    var increment = this.increment || 1;
    var ticks = this.generateTicks(start, end, unit, increment);
    this.removeAll(true);
    this.suspendEvents();
    this.add(ticks);
    if (this.getCount() === 0) {
      Ext.Error.raise('Invalid time axis configuration or filter, please check your input data.');
    }
    this.resumeEvents();
    var DATE = Sch.util.Date;
    var count = ticks.length;
    if (this.isContinuous()) {
      this.adjustedStart = adjusted.start;
      this.adjustedEnd = this.getNext(count > 1 ? ticks[count - 1].start : adjusted.start, unit, increment);
    } else {
      this.adjustedStart = this.getStart();
      this.adjustedEnd = this.getEnd();
    }
    do {
      this.visibleTickStart = (this.getStart() - this.adjustedStart) / (DATE.getUnitDurationInMs(unit) * increment);
      if (this.visibleTickStart >= 1) {
        this.adjustedStart = DATE.getNext(this.adjustedStart, unit, increment);
      }
    } while (this.visibleTickStart >= 1);
    do {
      this.visibleTickEnd = count - (this.adjustedEnd - this.getEnd()) / (DATE.getUnitDurationInMs(unit) * increment);
      if (count - this.visibleTickEnd >= 1) {
        this.adjustedEnd = DATE.getNext(this.adjustedEnd, unit, -1);
      }
    } while (count - this.visibleTickEnd >= 1);
    this.fireEvent('endreconfigure', this, suppressRefresh);
  }
}, isWeek:function() {
  return this.mode !== 'plain';
}, setMode:function(mode) {
  this.mode = mode;
  if (this.isWeek()) {
    this.generateTicksValidatorFn = function(start) {
      if (this.startTime > 0 || this.endTime < 24) {
        return start.getHours() >= this.startTime && start.getHours() < this.endTime;
      } else {
        return true;
      }
    };
  } else {
    this.generateTicksValidatorFn = function() {
      return true;
    };
  }
}, setTimeSpan:function(start, end) {
  var adjusted = this.getAdjustedDates(start, end);
  start = adjusted.start;
  end = adjusted.end;
  if (this.getStart() - start !== 0 || this.getEnd() - end !== 0) {
    this.reconfigure({start:start, end:end});
  }
}, filterBy:function(fn, scope) {
  this.continuous = false;
  scope = scope || this;
  this.clearFilter(true);
  this.suspendEvents(true);
  this.filter([{filterFn:function(t, index) {
    return fn.call(scope, t.data, index);
  }}]);
  if (this.getCount() === 0) {
    this.clearFilter();
    this.resumeEvents();
    Ext.Error.raise('Invalid time axis filter - no ticks passed through the filter. Please check your filter method.');
  }
  this.resumeEvents();
}, isContinuous:function() {
  var result = this.continuous && !this.isFiltered();
  if (this.isWeek()) {
    result = result && this.startTime === 0 && this.endTime === 24;
  }
  return result;
}, clearFilter:function() {
  this.continuous = this.originalContinuous;
  Ext.data.JsonStore.prototype.clearFilter.apply(this, arguments);
}, generateTicks:function(start, end, unit, increment) {
  var ticks = [], intervalEnd, DATE = Sch.util.Date, dstDiff = 0;
  unit = unit || this.unit;
  increment = increment || this.increment;
  var adjusted = this.getAdjustedDates(start, end);
  start = adjusted.start;
  end = adjusted.end;
  while (start < end) {
    intervalEnd = this.getNext(start, unit, increment);
    if (!this.autoAdjust && intervalEnd > end) {
      intervalEnd = end;
    }
    if (unit === DATE.HOUR && increment > 1 && ticks.length > 0 && dstDiff === 0) {
      var prev = ticks[ticks.length - 1];
      dstDiff = (prev.start.getHours() + increment) % 24 - prev.end.getHours();
      if (dstDiff !== 0) {
        intervalEnd = DATE.add(intervalEnd, DATE.HOUR, dstDiff);
      }
    }
    this.generateTicksValidatorFn(start) && ticks.push({start:start, end:intervalEnd});
    start = intervalEnd;
  }
  return ticks;
}, getVisibleTickTimeSpan:function() {
  return this.isContinuous() ? this.visibleTickEnd - this.visibleTickStart : this.getCount();
}, getAdjustedDates:function(start, end, forceAdjust) {
  var DATE = Sch.util.Date;
  start = start || this.getStart();
  end = end || DATE.add(start, this.mainUnit, this.defaultSpan);
  if (this.isWeek()) {
    if (this.shiftUnit === DATE.MONTH) {
      var startWeekEnd = DATE.add(start, DATE.WEEK, 1);
      var endWeekStart = DATE.add(end, DATE.WEEK, -1);
      if (!end) {
        end = this.getNext(start, this.shiftUnit, 1);
        end = this.ceilDate(end, false, this.shiftUnit);
        end = this.ceilDate(end, false, this.mainUnit);
      }
      if (startWeekEnd.getMonth() !== start.getMonth() && endWeekStart.getMonth() !== end.getMonth()) {
        return {start:start, end:end};
      }
    }
    var adjustedStart, adjustedEnd, clone;
    adjustedStart = this.floorDate(start, false, this.shiftUnit, 1);
    adjustedStart = this.floorDate(adjustedStart, false, this.mainUnit, 1);
    if (this.autoAdjust) {
      clone = this.getNext(start, this.shiftUnit, 1);
      adjustedEnd = this.ceilDate(clone, false, this.shiftUnit);
      adjustedEnd = this.ceilDate(adjustedEnd, false, this.mainUnit);
    } else {
      adjustedEnd = this.ceilDate(end, false, this.shiftUnit);
      adjustedEnd = this.ceilDate(adjustedEnd, false, this.mainUnit);
    }
    return {start:adjustedStart, end:adjustedEnd};
  } else {
    return this.autoAdjust || forceAdjust ? {start:this.floorDate(start, false, this.autoAdjust ? this.mainUnit : this.unit, 1), end:this.ceilDate(end, false, this.autoAdjust ? this.mainUnit : this.unit, 1)} : {start:start, end:end};
  }
}, getTickFromDate:function(date) {
  var ticks = this.data.items;
  var lastTickIndex = ticks.length - 1;
  if (date.valueOf() < ticks[0].data.start.valueOf() || date.valueOf() > ticks[lastTickIndex].data.end.valueOf()) {
    return -1;
  }
  var tick, tickStart, tickEnd;
  if (this.isContinuous()) {
    if (date - ticks[0].data.start === 0) {
      return this.visibleTickStart;
    }
    if (date - ticks[lastTickIndex].data.end === 0) {
      return this.visibleTickEnd;
    }
    var adjustedStart = this.adjustedStart;
    var adjustedEnd = this.adjustedEnd;
    var tickIndex = Math.floor(ticks.length * (date - adjustedStart) / (adjustedEnd - adjustedStart));
    if (tickIndex > lastTickIndex) {
      tickIndex = lastTickIndex;
    }
    tickStart = tickIndex === 0 ? adjustedStart : ticks[tickIndex].data.start;
    tickEnd = tickIndex == lastTickIndex ? adjustedEnd : ticks[tickIndex].data.end;
    tick = tickIndex + (date - tickStart) / (tickEnd - tickStart);
    if (tick < this.visibleTickStart || tick > this.visibleTickEnd) {
      return -1;
    }
    return tick;
  } else {
    for (var i = 0; i <= lastTickIndex; i++) {
      tickEnd = ticks[i].data.end;
      if (date <= tickEnd) {
        tickStart = ticks[i].data.start;
        tick = i + (date > tickStart ? (date - tickStart) / (tickEnd - tickStart) : 0);
        return tick;
      }
    }
  }
  return -1;
}, getDateFromTick:function(tick, roundingMethod) {
  if (tick === this.visibleTickEnd) {
    return this.getEnd();
  }
  var wholeTick = Math.floor(tick), fraction = tick - wholeTick, t = this.getAt(wholeTick);
  if (!t) {
    return null;
  }
  var tickData = t.data;
  var start = wholeTick === 0 ? this.adjustedStart : tickData.start;
  var end = wholeTick == this.getCount() - 1 && this.isContinuous() ? this.adjustedEnd : tickData.end;
  var date = Sch.util.Date.add(start, Sch.util.Date.MILLI, fraction * (end - start));
  if (roundingMethod) {
    date = this[roundingMethod + 'Date'](date);
  }
  return date;
}, getTicks:function() {
  var ticks = [];
  this.each(function(r) {
    ticks.push(r.data);
  });
  return ticks;
}, getStart:function() {
  var first = this.first();
  if (first) {
    return new Date(first.data.start);
  }
  return null;
}, getEnd:function() {
  var last = this.last();
  if (last) {
    return new Date(last.data.end);
  }
  return null;
}, floorDate:function(date, relativeToStart, resolutionUnit, incr) {
  relativeToStart = relativeToStart !== false;
  var dt = Ext.Date.clone(date), relativeTo = relativeToStart ? this.getStart() : null, increment = incr || this.resolutionIncrement, unit;
  if (resolutionUnit) {
    unit = resolutionUnit;
  } else {
    unit = relativeToStart ? this.resolutionUnit : this.mainUnit;
  }
  var DATE = Sch.util.Date;
  var snap = function(value, increment) {
    return Math.floor(value / increment) * increment;
  };
  switch(unit) {
    case DATE.MILLI:
      if (relativeToStart) {
        dt = DATE.add(relativeTo, DATE.MILLI, snap(DATE.getDurationInMilliseconds(relativeTo, dt), increment));
      }
      break;
    case DATE.SECOND:
      if (relativeToStart) {
        dt = DATE.add(relativeTo, DATE.MILLI, snap(DATE.getDurationInSeconds(relativeTo, dt), increment) * 1000);
      } else {
        dt.setMilliseconds(0);
        dt.setSeconds(snap(dt.getSeconds(), increment));
      }
      break;
    case DATE.MINUTE:
      if (relativeToStart) {
        dt = DATE.add(relativeTo, DATE.SECOND, snap(DATE.getDurationInMinutes(relativeTo, dt), increment) * 60);
      } else {
        dt.setMinutes(snap(dt.getMinutes(), increment));
        dt.setSeconds(0);
        dt.setMilliseconds(0);
      }
      break;
    case DATE.HOUR:
      if (relativeToStart) {
        dt = DATE.add(relativeTo, DATE.MINUTE, snap(DATE.getDurationInHours(this.getStart(), dt), increment) * 60);
      } else {
        dt.setMinutes(0);
        dt.setSeconds(0);
        dt.setMilliseconds(0);
        dt.setHours(snap(dt.getHours(), increment));
      }
      break;
    case DATE.DAY:
      if (relativeToStart) {
        dt = DATE.add(relativeTo, DATE.DAY, snap(DATE.getDurationInDays(relativeTo, dt), increment));
      } else {
        Sch.util.Date.clearTime(dt);
        dt.setDate(snap(dt.getDate() - 1, increment) + 1);
      }
      break;
    case DATE.WEEK:
      var day = dt.getDay() || 7;
      var startDay = this.weekStartDay || 7;
      Sch.util.Date.clearTime(dt);
      dt = DATE.add(dt, DATE.DAY, day >= startDay ? startDay - day : -(7 - startDay + day));
      if (dt.getDay() !== startDay && dt.getHours() === 23) {
        dt = DATE.add(dt, DATE.HOUR, 1);
      }
      break;
    case DATE.MONTH:
      if (relativeToStart) {
        dt = DATE.add(relativeTo, DATE.MONTH, snap(DATE.getDurationInMonths(relativeTo, dt), increment));
      } else {
        Sch.util.Date.clearTime(dt);
        dt.setDate(1);
        dt.setMonth(snap(dt.getMonth(), increment));
      }
      break;
    case DATE.QUARTER:
      Sch.util.Date.clearTime(dt);
      dt.setDate(1);
      dt = DATE.add(dt, DATE.MONTH, -(dt.getMonth() % 3));
      break;
    case DATE.YEAR:
      if (relativeToStart) {
        dt = DATE.add(relativeTo, DATE.YEAR, snap(DATE.getDurationInYears(relativeTo, dt), increment));
      } else {
        var fullYear = snap(date.getFullYear() - 1, increment) + 1;
        dt = new Date(0, 0, 1);
        dt.setFullYear(fullYear);
      }
      break;
  }
  return dt;
}, roundDate:function(date, relativeTo) {
  var dt = Ext.Date.clone(date), increment = this.resolutionIncrement;
  relativeTo = relativeTo || this.getStart();
  switch(this.resolutionUnit) {
    case Sch.util.Date.MILLI:
      var milliseconds = Sch.util.Date.getDurationInMilliseconds(relativeTo, dt), snappedMilliseconds = Math.round(milliseconds / increment) * increment;
      dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, snappedMilliseconds);
      break;
    case Sch.util.Date.SECOND:
      var seconds = Sch.util.Date.getDurationInSeconds(relativeTo, dt), snappedSeconds = Math.round(seconds / increment) * increment;
      dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, snappedSeconds * 1000);
      break;
    case Sch.util.Date.MINUTE:
      var minutes = Sch.util.Date.getDurationInMinutes(relativeTo, dt), snappedMinutes = Math.round(minutes / increment) * increment;
      dt = Sch.util.Date.add(relativeTo, Sch.util.Date.SECOND, snappedMinutes * 60);
      break;
    case Sch.util.Date.HOUR:
      var nbrHours = Sch.util.Date.getDurationInHours(relativeTo, dt), snappedHours = Math.round(nbrHours / increment) * increment;
      dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MINUTE, snappedHours * 60);
      break;
    case Sch.util.Date.DAY:
      var nbrDays = Sch.util.Date.getDurationInDays(relativeTo, dt), snappedDays = Math.round(nbrDays / increment) * increment;
      dt = Sch.util.Date.add(relativeTo, Sch.util.Date.DAY, snappedDays);
      break;
    case Sch.util.Date.WEEK:
      Sch.util.Date.clearTime(dt);
      var distanceToWeekStartDay = dt.getDay() - this.weekStartDay, toAdd;
      if (distanceToWeekStartDay < 0) {
        distanceToWeekStartDay = 7 + distanceToWeekStartDay;
      }
      if (Math.round(distanceToWeekStartDay / 7) === 1) {
        toAdd = 7 - distanceToWeekStartDay;
      } else {
        toAdd = -distanceToWeekStartDay;
      }
      dt = Sch.util.Date.add(dt, Sch.util.Date.DAY, toAdd);
      break;
    case Sch.util.Date.MONTH:
      var nbrMonths = Sch.util.Date.getDurationInMonths(relativeTo, dt) + dt.getDate() / Ext.Date.getDaysInMonth(dt), snappedMonths = Math.round(nbrMonths / increment) * increment;
      dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MONTH, snappedMonths);
      break;
    case Sch.util.Date.QUARTER:
      Sch.util.Date.clearTime(dt);
      dt.setDate(1);
      dt = Sch.util.Date.add(dt, Sch.util.Date.MONTH, 3 - dt.getMonth() % 3);
      break;
    case Sch.util.Date.YEAR:
      var nbrYears = Sch.util.Date.getDurationInYears(relativeTo, dt), snappedYears = Math.round(nbrYears / increment) * increment;
      dt = Sch.util.Date.add(relativeTo, Sch.util.Date.YEAR, snappedYears);
      break;
  }
  return dt;
}, ceilDate:function(date, relativeToStart, resolutionUnit, increment) {
  var dt = Ext.Date.clone(date);
  relativeToStart = relativeToStart !== false;
  increment = increment || (relativeToStart ? this.resolutionIncrement : 1);
  var doCall = false, unit;
  if (resolutionUnit) {
    unit = resolutionUnit;
  } else {
    unit = relativeToStart ? this.resolutionUnit : this.mainUnit;
  }
  switch(unit) {
    case Sch.util.Date.HOUR:
      if (dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0) {
        doCall = true;
      }
      break;
    case Sch.util.Date.DAY:
      if (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0) {
        doCall = true;
      }
      break;
    case Sch.util.Date.WEEK:
      Sch.util.Date.clearTime(dt);
      if (dt.getDay() !== this.weekStartDay || date.getTime() - dt.getTime() > 0) {
        doCall = true;
      }
      break;
    case Sch.util.Date.MONTH:
      Sch.util.Date.clearTime(dt);
      if (dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
        doCall = true;
      }
      break;
    case Sch.util.Date.QUARTER:
      Sch.util.Date.clearTime(dt);
      if (dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
        doCall = true;
      }
      break;
    case Sch.util.Date.YEAR:
      Sch.util.Date.clearTime(dt);
      if (dt.getMonth() !== 0 || dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
        doCall = true;
      }
      break;
    default:
      break;
  }
  if (doCall) {
    return this.getNext(dt, unit, increment);
  } else {
    return dt;
  }
}, getNext:function(date, unit, increment) {
  return Sch.util.Date.getNext(date, unit, increment, this.weekStartDay);
}, getResolution:function() {
  return {unit:this.resolutionUnit, increment:this.resolutionIncrement};
}, setResolution:function(unit, increment) {
  this.resolutionUnit = unit;
  this.resolutionIncrement = increment || 1;
}, shift:function(amount, unit) {
  this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
}, shiftNext:function(amount) {
  amount = amount || this.getShiftIncrement();
  var unit = this.getShiftUnit();
  this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
}, shiftPrevious:function(amount) {
  amount = -(amount || this.getShiftIncrement());
  var unit = this.getShiftUnit();
  this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
}, getShiftUnit:function() {
  return this.shiftUnit || this.mainUnit;
}, getShiftIncrement:function() {
  return this.shiftIncrement || 1;
}, getUnit:function() {
  return this.unit;
}, getIncrement:function() {
  return this.increment;
}, getRowTicks:function() {
  if (this.isWeek()) {
    var start = this.getStart();
    var end = Sch.util.Date.add(start, this.headerConfig.middle.splitUnit, 1);
    var endIndex = this.findBy(function(record) {
      return record.getStartDate().getTime() >= end.getTime();
    });
    if (endIndex === -1) {
      return this.getRange();
    }
    return this.getRange(0, endIndex - 1);
  }
}, dateInAxis:function(date, inclusiveEnd) {
  var result = false;
  var axisStart = this.getStart();
  var axisEnd = this.getEnd();
  if (this.isContinuous()) {
    result = inclusiveEnd ? Sch.util.Date.betweenLesserEqual(date, axisStart, axisEnd) : Sch.util.Date.betweenLesser(date, axisStart, axisEnd);
  } else {
    var length = this.getCount(), tickStart, tickEnd;
    for (var i = 0; i < length; i++) {
      var tick = this.getAt(i);
      tickStart = tick.data.start;
      tickEnd = tick.data.end;
      if (inclusiveEnd && date <= tickEnd || !inclusiveEnd && date < tickEnd) {
        return date >= tickStart;
      }
    }
  }
  return result;
}, timeSpanInAxis:function(start, end) {
  var axisStart = this.getStart();
  var axisEnd = this.getEnd();
  var duration = end - start;
  if (duration === 0) {
    return this.dateInAxis(start, true);
  }
  if (this.isContinuous()) {
    return Sch.util.Date.intersectSpans(start, end, axisStart, axisEnd);
  } else {
    var coversRange = start < axisStart && end > axisEnd;
    if (coversRange) {
      return true;
    }
    var startTick = this.getTickFromDate(start);
    var endTick = this.getTickFromDate(end);
    return startTick !== endTick && (start < axisEnd && end > axisStart);
  }
}, isRangeInAxis:function(range) {
  var start = range.getStartDate(), end = range.getEndDate();
  if (!start || !end) {
    return false;
  }
  return this.timeSpanInAxis(start, end);
}, forEachAuxInterval:function(unit, increment, iteratorFn, scope) {
  scope = scope || this;
  var end = this.getEnd(), dt = this.getStart(), i = 0, intervalEnd;
  if (dt > end) {
    throw new Error('Invalid time axis configuration');
  }
  while (dt < end) {
    intervalEnd = Sch.util.Date.min(this.getNext(dt, unit, increment || 1), end);
    iteratorFn.call(scope, dt, intervalEnd, i);
    dt = intervalEnd;
    i++;
  }
}, consumeViewPreset:function(preset) {
  Ext.apply(this, {unit:preset.getBottomHeader().unit, increment:preset.getBottomHeader().increment || 1, resolutionUnit:preset.timeResolution.unit, resolutionIncrement:preset.timeResolution.increment, mainUnit:preset.getMainHeader().unit, shiftUnit:preset.shiftUnit, shiftIncrement:preset.shiftIncrement || 1, defaultSpan:preset.defaultSpan || 1, presetName:preset.name, headerConfig:preset.headerConfig});
}}, 1, 0, 0, 0, 0, 0, [Sch.data, 'TimeAxis'], 0);
Ext.cmd.derive('Sch.eventlayout.Horizontal', Ext.Base, {nbrOfBandsByResource:null, bandIndexToPxConvertFn:null, bandIndexToPxConvertScope:null, constructor:function(config) {
  Ext.apply(this, config);
  this.nbrOfBandsByResource = {};
}, clearCache:function(resource) {
  if (resource) {
    delete this.nbrOfBandsByResource[resource.internalId];
  } else {
    this.nbrOfBandsByResource = {};
  }
}, getNumberOfBands:function(resource, resourceEventsOrFn) {
  var nbrOfBandsByResource = this.nbrOfBandsByResource;
  if (nbrOfBandsByResource.hasOwnProperty(resource.internalId)) {
    return nbrOfBandsByResource[resource.internalId];
  }
  var resourceEvents = Ext.isFunction(resourceEventsOrFn) ? resourceEventsOrFn() : resourceEventsOrFn;
  var eventsData = Ext.Array.map(resourceEvents, function(event) {
    return {start:event.getStartDate(), end:event.getEndDate(), event:event};
  });
  return this.applyLayout(eventsData, resource);
}, applyLayout:function(events, resource) {
  var rowEvents = events.slice();
  var me = this;
  rowEvents.sort(function(a, b) {
    return me.sortEvents(a.event, b.event);
  });
  return this.nbrOfBandsByResource[resource.internalId] = this.layoutEventsInBands(rowEvents);
}, sortEvents:function(a, b) {
  var startA = a.getStartDate();
  var startB = b.getStartDate();
  var sameStart = startA - startB === 0;
  if (sameStart) {
    return a.getEndDate() > b.getEndDate() ? -1 : 1;
  } else {
    return startA < startB ? -1 : 1;
  }
}, layoutEventsInBands:function(events) {
  var verticalPosition = 0;
  do {
    var event = events[0];
    while (event) {
      event.top = this.bandIndexToPxConvertFn.call(this.bandIndexToPxConvertScope || this, verticalPosition, event.event);
      Ext.Array.remove(events, event);
      event = this.findClosestSuccessor(event, events);
    }
    verticalPosition++;
  } while (events.length > 0);
  return verticalPosition;
}, findClosestSuccessor:function(event, events) {
  var minGap = Infinity, closest, eventEnd = event.end, gap, isMilestone = event.end - event.start === 0;
  for (var i = 0, l = events.length; i < l; i++) {
    gap = events[i].start - eventEnd;
    if (gap >= 0 && gap < minGap && (gap > 0 || events[i].end - events[i].start > 0 || !isMilestone)) {
      closest = events[i];
      minGap = gap;
    }
  }
  return closest;
}}, 1, 0, 0, 0, 0, 0, [Sch.eventlayout, 'Horizontal'], 0);
Ext.cmd.derive('Sch.eventlayout.Vertical', Ext.Base, {view:null, constructor:function(config) {
  Ext.apply(this, config);
}, applyLayout:function(events, totalAvailableWidth) {
  if (events.length === 0) {
    return;
  }
  var me = this;
  events.sort(function(a, b) {
    return me.sortEvents(a.event, b.event);
  });
  var slot, firstInCluster, j;
  for (var i = 0, l = events.length; i < l; i++) {
    firstInCluster = events[i];
    slot = this.findStartSlot(events, firstInCluster);
    var cluster = this.getCluster(events, i);
    if (cluster.length > 1) {
      firstInCluster.left = slot.start;
      firstInCluster.width = slot.end - slot.start;
      j = 1;
      while (j < cluster.length - 1 && cluster[j + 1].start - firstInCluster.start === 0) {
        j++;
      }
      var nextSlot = this.findStartSlot(events, cluster[j]);
      if (nextSlot && nextSlot.start < 0.8) {
        cluster = cluster.slice(0, j);
      }
    }
    var count = cluster.length, barWidth = (slot.end - slot.start) / count;
    for (j = 0; j < count; j++) {
      cluster[j].width = barWidth;
      cluster[j].left = slot.start + j * barWidth;
    }
    i += count - 1;
  }
  for (i = 0, l = events.length; i < l; i++) {
    events[i].width = events[i].width * totalAvailableWidth;
    events[i].left = this.view.barMargin + events[i].left * totalAvailableWidth;
  }
}, findStartSlot:function(events, event) {
  var priorOverlappers = this.getPriorOverlappingEvents(events, event), i;
  if (priorOverlappers.length === 0) {
    return {start:0, end:1};
  }
  for (i = 0; i < priorOverlappers.length; i++) {
    if (i === 0 && priorOverlappers[0].left > 0) {
      return {start:0, end:priorOverlappers[0].left};
    } else {
      if (priorOverlappers[i].left + priorOverlappers[i].width < (i < priorOverlappers.length - 1 ? priorOverlappers[i + 1].left : 1)) {
        return {start:priorOverlappers[i].left + priorOverlappers[i].width, end:i < priorOverlappers.length - 1 ? priorOverlappers[i + 1].left : 1};
      }
    }
  }
  return false;
}, getPriorOverlappingEvents:function(events, event) {
  var D = Sch.util.Date, start = event.start, end = event.end, overlappers = [];
  for (var i = 0, l = Ext.Array.indexOf(events, event); i < l; i++) {
    if (D.intersectSpans(start, end, events[i].start, events[i].end)) {
      overlappers.push(events[i]);
    }
  }
  overlappers.sort(this.sortOverlappers);
  return overlappers;
}, sortOverlappers:function(e1, e2) {
  return e1.left < e2.left ? -1 : 1;
}, getCluster:function(events, startIndex) {
  if (startIndex >= events.length - 1) {
    return [events[startIndex]];
  }
  var evts = [events[startIndex]], start = events[startIndex].start, end = events[startIndex].end, l = events.length, D = Sch.util.Date, i = startIndex + 1;
  while (i < l && D.intersectSpans(start, end, events[i].start, events[i].end)) {
    evts.push(events[i]);
    start = D.max(start, events[i].start);
    end = D.min(events[i].end, end);
    i++;
  }
  return evts;
}, sortEvents:function(a, b) {
  var startA = a.getStartDate(), endA = a.getEndDate();
  var startB = b.getStartDate(), endB = b.getEndDate();
  var sameStart = startA - startB === 0;
  if (sameStart) {
    return endA > endB ? -1 : 1;
  } else {
    return startA < startB ? -1 : 1;
  }
}}, 1, 0, 0, 0, 0, 0, [Sch.eventlayout, 'Vertical'], 0);
Ext.cmd.derive('Sch.feature.AbstractTimeSpan', Ext.AbstractPlugin, {lockableScope:'top', schedulerView:null, timeAxis:null, expandToFitView:false, disabled:false, cls:null, clsField:'Cls', template:null, store:null, renderElementsBuffered:false, renderDelay:0, refreshSizeOnItemUpdate:true, _renderTimer:null, showHeaderElements:false, headerTemplate:null, innerHeaderTpl:null, headerContainerCls:'sch-header-secondary-canvas', headerContainerEl:null, renderingDoneEvent:null, constructor:function(cfg) {
  this.uniqueCls = this.uniqueCls || 'sch-timespangroup-' + Ext.id();
  Ext.apply(this, cfg);
  this.mixins.observable.constructor.call(this);
  Ext.plugin.Abstract.prototype.constructor.apply(this, arguments);
}, init:function(scheduler) {
  if (Ext.versions.touch && !scheduler.isReady()) {
    scheduler.on('viewready', function() {
      this.init(scheduler);
    }, this);
    return;
  }
  if (typeof this.innerHeaderTpl === 'string') {
    this.innerHeaderTpl = new Ext.XTemplate(this.innerHeaderTpl);
  }
  var innerHeaderTpl = this.innerHeaderTpl;
  if (!this.headerTemplate) {
    this.headerTemplate = new Ext.XTemplate('\x3ctpl for\x3d"."\x3e', '\x3cdiv id\x3d"{id}" class\x3d"{cls}" title\x3d"{[values.Name || values.Text || ""]}" style\x3d"{side}:{position}px;"\x3e' + (innerHeaderTpl ? '{[this.renderInner(values)]}' : '') + '\x3c/div\x3e', '\x3c/tpl\x3e', {renderInner:function(values) {
      return innerHeaderTpl.apply(values);
    }});
  }
  this.schedulerView = scheduler.getSchedulingView();
  this.panel = scheduler;
  this.timeAxis = scheduler.getTimeAxis();
  this.store = Ext.StoreManager.lookup(this.store);
  if (!this.store) {
    Ext.Error.raise('Error: You must define a store for this plugin');
  }
  if (this.showHeaderElements) {
    this.panel.on({horizontaltimeaxiscolumnrender:this.renderHeaderElements, scope:this});
  }
  if (!this.schedulerView.getEl()) {
    this.schedulerView.on({viewready:this.onViewReady, scope:this});
  } else {
    this.onViewReady();
  }
}, setDisabled:function(disabled) {
  if (disabled) {
    this.removeElements();
  }
  this.disabled = disabled;
}, removeElements:function() {
  this.removeBodyElements();
  if (this.showHeaderElements) {
    this.removeHeaderElements();
  }
}, getBodyElements:function() {
  var el = this.getContainerEl();
  if (el) {
    return el.select('.' + this.uniqueCls);
  }
  return null;
}, getHeaderContainerEl:function() {
  var containerEl = this.headerContainerEl, prefix = 'x-', parent;
  if (!containerEl || !containerEl.dom) {
    if (this.schedulerView.isHorizontal()) {
      var timeAxisColumn = this.panel.getHorizontalTimeAxisColumn();
      if (timeAxisColumn.headerView) {
        parent = timeAxisColumn.headerView.containerEl;
      } else {
        return null;
      }
    } else {
      parent = this.panel.lockedGrid.getView().el;
    }
    if (parent) {
      containerEl = parent.down('.' + this.headerContainerCls);
      if (!containerEl) {
        containerEl = parent.appendChild({cls:this.headerContainerCls});
      }
      this.headerContainerEl = containerEl;
    }
  }
  return containerEl;
}, getHeaderElements:function() {
  var containerEl = this.getHeaderContainerEl();
  if (containerEl) {
    return containerEl.select('.' + this.uniqueCls);
  }
  return null;
}, removeBodyElements:function() {
  var els = this.getBodyElements();
  if (els) {
    els.each(function(el) {
      el.destroy();
    });
  }
}, removeHeaderElements:function() {
  var els = this.getHeaderElements();
  if (els) {
    els.each(function(el) {
      el.destroy();
    });
  }
}, getElementId:function(record) {
  return this.uniqueCls + '-' + record.internalId;
}, getHeaderElementId:function(record) {
  return this.uniqueCls + '-header-' + record.internalId;
}, getTemplateData:function(record) {
  return this.prepareTemplateData ? this.prepareTemplateData(record) : record.data;
}, getElementCls:function(record, data) {
  var clsField = record.clsField || this.clsField;
  if (!data) {
    data = this.getTemplateData(record);
  }
  return this.cls + ' ' + this.uniqueCls + ' ' + (data[clsField] || '');
}, getHeaderElementCls:function(record, data) {
  var clsField = record.clsField || this.clsField;
  if (!data) {
    data = this.getTemplateData(record);
  }
  return 'sch-header-indicator ' + this.uniqueCls + ' ' + (data[clsField] || '');
}, getContainerEl:function() {
  return this.schedulerView.getSecondaryCanvasEl();
}, onViewReady:function(scheduler) {
  var view = this.schedulerView;
  this.storeListeners = {load:this.renderElements, datachanged:this.renderElements, clear:this.renderElements, update:this.refreshSingle, scope:this};
  this.store.on(this.storeListeners);
  this.panel.on({beforemodechange:this.onTimelinePanelBeforeModeChange, modechange:this.onTimelinePanelModeChange, scope:this});
  this.viewListeners = {refresh:this.renderElements, scope:this};
  this.headerListeners = {afterlayout:this.renderElements, scope:this};
  if (view.isWeekView()) {
    view.headerCt.on(this.headerListeners);
  } else {
    view.on(this.viewListeners);
    this.renderElements();
  }
}, onTimelinePanelBeforeModeChange:function() {
  var view = this.schedulerView;
  if (view.isWeekView()) {
    view.headerCt.un(this.headerListeners);
  } else {
    this.schedulerView.un(this.viewListeners);
  }
}, onTimelinePanelModeChange:function() {
  var view = this.schedulerView;
  if (view.isWeekView()) {
    view.headerCt.on(this.headerListeners);
  } else {
    view.on(this.viewListeners);
  }
  this.forceNewRenderingTimeout();
}, forceNewRenderingTimeout:function() {
  this.renderElementsBuffered = false;
  clearTimeout(this._renderTimer);
  this.renderElements();
}, renderElements:function() {
  if (this.renderElementsBuffered || this.disabled) {
    return;
  }
  this.renderElementsBuffered = true;
  clearTimeout(this._renderTimer);
  this._renderTimer = Ext.Function.defer(this.renderElementsInternal, this.renderDelay, this);
}, setElementX:function(el, x) {
  if (this.panel.rtl) {
    el.setRight(x);
  } else {
    el.setLeft(x);
  }
}, getHeaderElementPosition:function(date) {
  var viewModel = this.schedulerView.getTimeAxisViewModel();
  return Math.round(viewModel.getPositionFromDate(date));
}, renderBodyElementsInternal:function(records) {
  var start = this.timeAxis.getStart(), end = this.timeAxis.getEnd(), data = this.getElementData(start, end, records);
  if (data) {
    this.template.append(this.getContainerEl(), data);
  }
}, getHeaderElementData:function(records, isPrint) {
  throw 'Abstract method call';
}, renderHeaderElements:function(records) {
  var containerEl = this.getHeaderContainerEl();
  if (containerEl) {
    var data = this.getHeaderElementData(records);
    this.headerTemplate.append(containerEl, data);
  }
}, renderElementsInternal:function() {
  this.renderElementsBuffered = false;
  var view = this.schedulerView;
  if (this.disabled || view.isDestroyed || !this.getContainerEl() || view.store.getCount() === 0) {
    return;
  }
  if (view.isWeekView()) {
    var columns = view.getColumnManager().getColumns();
    if (columns[0] && !columns[0].rendered) {
      return;
    }
  }
  this.removeElements();
  this.renderBodyElementsInternal();
  if (this.showHeaderElements) {
    this.headerContainerEl = null;
    this.renderHeaderElements();
  }
  if (this.renderingDoneEvent) {
    this.fireEvent(this.renderingDoneEvent, this);
  }
}, getElementData:function(viewStart, viewEnd, records, isPrint) {
  throw 'Abstract method call';
}, updateBodyElement:function(record) {
  var el = Ext.get(this.getElementId(record));
  if (el) {
    var start = this.timeAxis.getStart(), end = this.timeAxis.getEnd(), data = this.getElementData(start, end, [record])[0];
    if (data) {
      el.dom.className = data.$cls;
      el.setTop(data.top);
      this.setElementX(el, data.left);
      el.setSize(data.width, data.height);
    } else {
      Ext.destroy(el);
    }
  } else {
    this.renderBodyElementsInternal([record]);
  }
}, updateHeaderElement:function(record) {
  var el = Ext.get(this.getHeaderElementId(record));
  if (el) {
    var data = this.getHeaderElementData([record])[0];
    if (data) {
      el.dom.className = data.cls;
      if (this.schedulerView.isHorizontal()) {
        this.setElementX(el, data.position);
        el.setWidth(data.size);
      } else {
        el.setTop(data.position);
        el.setHeight(data.size);
      }
    } else {
      Ext.destroy(el);
    }
  } else {
    this.renderHeaderElements([record]);
  }
}, destroy:function() {
  clearTimeout(this._renderTimer);
  this.store.un(this.storeListeners);
  if (this.store.autoDestroy) {
    this.store.destroy();
  }
}, refreshSingle:function(store, records) {
  records = records instanceof Array ? records : [records];
  Ext.Array.each(records, function(record) {
    this.updateBodyElement(record);
    if (this.showHeaderElements) {
      this.updateHeaderElement(record);
    }
  }, this);
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Sch.feature, 'AbstractTimeSpan'], 0);
Ext.cmd.derive('Sch.plugin.Lines', Sch.feature.AbstractTimeSpan, {cls:'sch-timeline', showTip:true, innerTpl:null, prepareTemplateData:null, side:null, init:function(scheduler) {
  if (typeof this.innerTpl === 'string') {
    this.innerTpl = new Ext.XTemplate(this.innerTpl);
  }
  this.side = scheduler.rtl ? 'right' : 'left';
  var innerTpl = this.innerTpl;
  if (!this.template) {
    this.template = new Ext.XTemplate('\x3ctpl for\x3d"."\x3e', '\x3cdiv id\x3d"{id}" ' + (this.showTip ? 'title\x3d"{[this.getTipText(values)]}" ' : '') + 'class\x3d"{$cls}" style\x3d"' + this.side + ':{left}px;top:{top}px;width:{width}px"\x3e' + (innerTpl ? '{[this.renderInner(values)]}' : '') + '\x3c/div\x3e', '\x3c/tpl\x3e', {getTipText:function(values) {
      return scheduler.getSchedulingView().getFormattedDate(values.Date) + ' ' + (values.Text || '');
    }, renderInner:function(values) {
      return innerTpl.apply(values);
    }});
  }
  Sch.feature.AbstractTimeSpan.prototype.init.apply(this, arguments);
}, getElementData:function(viewStart, viewEnd, records) {
  var s = this.store, scheduler = this.schedulerView, isHorizontal = scheduler.isHorizontal(), isWeekView = scheduler.isWeekView(), rs = records || s.getRange(), data = [], height, width, record, date, templateData;
  for (var i = 0, l = rs.length; i < l; i++) {
    record = rs[i];
    date = record.get('Date');
    if (date && scheduler.timeAxis.dateInAxis(date)) {
      templateData = Ext.apply({}, this.getTemplateData(record));
      templateData.id = this.getElementId(record);
      templateData.$cls = this.getElementCls(record, templateData);
      if (isWeekView) {
        var region = scheduler.getTimeSpanRegion(viewStart, null, this.expandToFitView);
        region = scheduler.getTimeSpanRegion(date, date);
        templateData.left = region.x;
        templateData.top = region.y;
        templateData.width = region.right - region.left;
      } else {
        var pos = scheduler.getCoordinateFromDate(date);
        if (isHorizontal) {
          templateData.left = pos;
        } else {
          templateData.top = pos;
        }
      }
      data.push(templateData);
    }
  }
  return data;
}, getHeaderElementData:function(records) {
  var startDate = this.timeAxis.getStart(), endDate = this.timeAxis.getEnd(), isHorizontal = this.schedulerView.isHorizontal(), data = [], record, date, position, templateData;
  records = records || this.store.getRange();
  for (var i = 0, l = records.length; i < l; i++) {
    record = records[i];
    date = record.get('Date');
    if (date && Sch.util.Date.betweenLesser(date, startDate, endDate)) {
      position = this.getHeaderElementPosition(date);
      templateData = this.getTemplateData(record);
      templateData = Ext.apply({side:isHorizontal ? this.side : 'top', cls:this.getHeaderElementCls(record, templateData), position:position}, templateData);
      templateData.id = this.getHeaderElementId(record);
      data.push(templateData);
    }
  }
  return data;
}}, 0, 0, 0, 0, ['plugin.scheduler_lines'], 0, [Sch.plugin, 'Lines'], 0);
Ext.cmd.derive('Sch.feature.ColumnLines', Sch.plugin.Lines, {showTip:false, cls:'sch-column-line', timeAxisViewModel:null, renderingDoneEvent:'columnlinessynced', useLowestHeader:null, init:function(panel) {
  this.timeAxis = panel.getTimeAxis();
  this.timeAxisViewModel = panel.timeAxisViewModel;
  this.panel = panel;
  this.store = new Ext.data.JsonStore({fields:['Date']});
  Sch.plugin.Lines.prototype.init.apply(this, arguments);
  panel.on({destroy:this.onHostDestroy, scope:this});
  this.timeAxisViewModel.on('update', this.populate, this);
  this.populate();
}, onHostDestroy:function() {
  this.timeAxisViewModel.un('update', this.populate, this);
}, populate:function() {
  this.store.setData(this.getData());
}, getData:function() {
  var ticks = [];
  var timeAxisViewModel = this.timeAxisViewModel;
  var linesForLevel = this.useLowestHeader ? timeAxisViewModel.getLowestHeader() : timeAxisViewModel.columnLinesFor;
  var hasGenerator = !!(timeAxisViewModel.headerConfig && timeAxisViewModel.headerConfig[linesForLevel].cellGenerator);
  if (hasGenerator) {
    var cells = timeAxisViewModel.getColumnConfig()[linesForLevel];
    for (var i = 1, l = cells.length; i < l; i++) {
      ticks.push({Date:cells[i].start});
    }
  } else {
    timeAxisViewModel.forEachInterval(linesForLevel, function(start, end, i) {
      if (i > 0) {
        ticks.push({Date:start, Cls:timeAxisViewModel.isMajorTick(start) ? 'sch-column-line-solid' : ''});
      }
    });
  }
  return ticks;
}}, 0, 0, 0, 0, 0, 0, [Sch.feature, 'ColumnLines'], 0);
Ext.cmd.derive('Sch.util.ScrollManager', Ext.Base, {singleton:true, vthresh:25, hthresh:25, increment:100, frequency:500, animate:true, animDuration:200, activeCmp:null, activeEl:null, scrollElRegion:null, scrollProcess:{}, pt:null, direction:'both', constructor:function() {
  this.doScroll = Ext.Function.bind(this.doScroll, this);
}, triggerRefresh:function() {
  if (this.activeEl) {
    this.refreshElRegion();
    this.clearScrollInterval();
    this.onMouseMove();
  }
}, doScroll:function() {
  var scrollProcess = this.scrollProcess, scrollProcessCmp = scrollProcess.cmp, rtlWithoutViewport = scrollProcessCmp.rtl && !scrollProcessCmp.up('[isViewport]'), dir = scrollProcess.dir[0], increment = this.increment, scrollLeft = this.activeCmp.getScrollX(), scrollTop = this.activeCmp.getVerticalScroll();
  if (dir === 'r') {
    increment = Math.min(increment, rtlWithoutViewport ? scrollLeft : this.maxPosition.x - scrollLeft);
  } else {
    if (dir === 'd') {
      increment = Math.min(increment, this.maxPosition.y - scrollTop);
    }
  }
  increment = Math.max(increment, 0);
  var deltaX = 0, deltaY = 0;
  if (dir === 'r') {
    deltaX = increment;
  }
  if (dir === 'l') {
    deltaX = -increment;
  }
  if (dir === 'u') {
    deltaY = -increment;
  }
  if (dir === 'd') {
    deltaY = increment;
  }
  if (rtlWithoutViewport) {
    deltaX = -deltaX;
  }
  if (deltaX) {
    scrollProcessCmp.scrollHorizontallyBy(deltaX, {duration:this.animDuration, callback:this.triggerRefresh, scope:this});
  } else {
    if (deltaY) {
      scrollProcessCmp.scrollVerticallyBy(deltaY, {duration:this.animDuration, callback:this.triggerRefresh, scope:this});
    }
  }
}, clearScrollInterval:function() {
  var scrollProcess = this.scrollProcess;
  if (scrollProcess.id) {
    clearTimeout(scrollProcess.id);
  }
  scrollProcess.id = 0;
  scrollProcess.cmp = null;
  scrollProcess.dir = '';
}, isScrollAllowed:function(dir) {
  switch(this.direction) {
    case 'both':
      return true;
    case 'horizontal':
      return dir === 'right' || dir === 'left';
    case 'vertical':
      return dir === 'up' || dir === 'down';
    default:
      throw new Error('Invalid direction: ' + this.direction);
  }
}, startScrollInterval:function(cmp, dir) {
  if (!this.isScrollAllowed(dir)) {
    return;
  }
  this.clearScrollInterval();
  this.scrollProcess.cmp = cmp;
  this.scrollProcess.dir = dir;
  this.scrollProcess.id = setTimeout(this.doScroll, this.frequency);
}, onMouseMove:function(e) {
  var pt = e ? {x:e.getX(), y:e.getY(), right:e.getX(), bottom:e.getY()} : this.pt, x = pt.x, y = pt.y, scrollProcess = this.scrollProcess, cmp = this.activeCmp, scrollLeft = cmp.getScrollX(), scrollTop = cmp.getVerticalScroll(), id, rtlWithoutViewport = cmp.rtl && !cmp.up('[isViewport]'), el = this.activeEl, region = this.scrollElRegion, elDom = el.dom, me = this, isScrollable = cmp.up('timelinegrid,timelinetree').getScrollable().getElement().isScrollable() || el.isScrollable();
  this.pt = pt;
  if (region && region.contains(pt) && isScrollable) {
    if (region.bottom - y <= me.vthresh && scrollTop < this.maxPosition.y) {
      if (scrollProcess.cmp != cmp) {
        this.startScrollInterval(cmp, 'down');
      }
      return;
    } else {
      if (region.right - x <= me.hthresh && (rtlWithoutViewport ? scrollLeft > 0 : scrollLeft < this.maxPosition.x)) {
        if (scrollProcess.cmp != cmp) {
          this.startScrollInterval(cmp, 'right');
        }
        return;
      } else {
        if (y - region.top <= me.vthresh && scrollTop > 0) {
          if (scrollProcess.cmp != cmp) {
            this.startScrollInterval(cmp, 'up');
          }
          return;
        } else {
          if (x - region.left <= me.hthresh && (rtlWithoutViewport ? scrollLeft < this.maxPosition.x : scrollLeft > 0)) {
            if (scrollProcess.cmp != cmp) {
              this.startScrollInterval(cmp, 'left');
            }
            return;
          }
        }
      }
    }
  }
  this.clearScrollInterval();
}, refreshElRegion:function() {
  var region = this.activeEl.getRegion();
  this.scrollElRegion = this.activeCmp.getScrollableContainerRegion();
}, activate:function(cmp, direction) {
  var scrollbarSize = Ext.getScrollbarSize();
  this.direction = direction || 'both';
  this.activeCmp = cmp;
  this.activeEl = cmp.getEl();
  this.maxPosition = cmp.getScrollableMaxPosition();
  this.refreshElRegion();
  this.activeEl.on('mousemove', this.onMouseMove, this);
}, deactivate:function() {
  if (this.activeEl) {
    this.clearScrollInterval();
    this.activeEl.un('mousemove', this.onMouseMove, this);
    this.activeEl = this.activeCmp = this.scrollElRegion = null;
    this.direction = 'both';
  }
}}, 1, 0, 0, 0, 0, 0, [Sch.util, 'ScrollManager'], 0);
Ext.cmd.derive('Sch.util.DragTracker', Ext.dd.DragTracker, {xStep:1, yStep:1, deferredTouchActivation:0, initEl:function(el) {
  var me = this, elCmp, touchScrollable;
  Ext.dd.DragTracker.prototype.initEl.apply(this, arguments);
  if (Ext.supports.Touch) {
    if (Ext.isIE || Ext.isEdge && !window.TouchEvent) {
      me.mun(me.handle, me.handleListeners);
      me.handleListeners.mousedown.translate = true;
      me.mon(me.handle, me.handleListeners);
    }
  }
}, constructor:function() {
  Ext.dd.DragTracker.prototype.constructor.apply(this, arguments);
  this.on('dragstart', this.bindListenersOnDragStart);
  this.moveListener = {pinchstart:this.abortWait, touchend:this.abortWait, mouseup:this.abortWait, mousemove:this.onMoveWhileWaiting, scope:this, capture:true};
}, bindListenersOnDragStart:function() {
  var el = this.el;
  el.on(this.getListeners());
  this.on('dragend', this.unbindListenersOnDragEnd, this, {single:true});
}, unbindListenersOnDragEnd:function() {
  this.el && this.el.un(this.getListeners());
}, getListeners:function() {
  return {scroll:this.onMouseMove, pinchstart:this.onMouseUp, scope:this};
}, destroy:function() {
  clearTimeout(this.deferTimer);
  Ext.dd.DragTracker.prototype.destroy.apply(this, arguments);
}, setXStep:function(step) {
  this.xStep = step;
}, startScroll:null, deferTimer:null, deferTolerance:10, moveListener:null, setYStep:function(step) {
  this.yStep = step;
}, onMoveWhileWaiting:function(e, t) {
  var xy = e.getXY();
  var s = this.startXY;
  if (Math.max(Math.abs(s[0] - xy[0]), Math.abs(s[1] - xy[1])) > this.deferTolerance) {
    this.abortWait();
    this.onMouseUp(e);
  }
}, abortWait:function() {
  clearTimeout(this.deferTimer);
  this.deferTimer = null;
  Ext.getDoc().un(this.moveListener);
}, getCurrentScroll:function() {
  return this.el.getScroll();
}, getRegion:function() {
  var startXY = this.startXY, currentScroll = this.getCurrentScroll();
  if (Ext.isIE && this.rtl) {
    currentScroll.left = this.el.dom.scrollWidth - this.el.getWidth() - currentScroll.left;
  }
  var currentXY = this.getXY(), currentX = currentXY[0], currentY = currentXY[1], scrollLeftDelta = currentScroll.left - this.startScroll.left, scrollTopDelta = currentScroll.top - this.startScroll.top, startX = startXY[0] - scrollLeftDelta, startY = startXY[1] - scrollTopDelta, minX = Math.min(startX, currentX), minY = Math.min(startY, currentY), width = Math.abs(startX - currentX), height = Math.abs(startY - currentY);
  return new Ext.util.Region(minY, minX + width, minY + height, minX);
}, onMouseDown:function(e, target) {
  var touches = e.event.touches || [];
  if (touches.length > 1 || !(e.type === 'mousedown' && e.pointerType === 'mouse' || e.type === 'longpress' && e.pointerType === 'touch' && !(Ext.isIE || Ext.isEdge))) {
    return;
  }
  e.stopPropagation = Ext.emptyFn;
  this.startXY = e.getXY();
  if (this.deferredTouchActivation && touches.length === 1) {
    var me = this;
    Ext.getDoc().on(this.moveListener);
    this.deferTimer = setTimeout(function() {
      var old = me.deferredTouchActivation;
      Ext.getDoc().un(me.moveListener);
      me.deferredTouchActivation = false;
      me.onMouseDown(e, target);
      me.deferredTouchActivation = old;
    }, this.deferredTouchActivation);
    return;
  }
  Ext.dd.DragTracker.prototype.onMouseDown.call(this, e, target);
  this.lastXY = this.startXY;
  this.startScroll = this.getCurrentScroll();
  if (Ext.isIE && this.rtl) {
    this.startScroll.left = this.el.dom.scrollWidth - this.el.getWidth() - this.startScroll.left;
  }
}, onMouseMove:function(e, target) {
  if (this.active && e.type === 'mousemove' && Ext.isIE9m && !e.browserEvent.button) {
    e.preventDefault();
    this.onMouseUp(e);
    return;
  }
  e.preventDefault();
  var xy = e.type === 'scroll' ? this.lastXY : e.getXY(), s = this.startXY;
  if (!this.active) {
    if (Math.max(Math.abs(s[0] - xy[0]), Math.abs(s[1] - xy[1])) > this.tolerance) {
      this.triggerStart(e);
    } else {
      return;
    }
  }
  var x = xy[0], y = xy[1];
  if (this.xStep > 1) {
    x -= this.startXY[0];
    x = Math.round(x / this.xStep) * this.xStep;
    x += this.startXY[0];
  }
  if (this.yStep > 1) {
    y -= this.startXY[1];
    y = Math.round(y / this.yStep) * this.yStep;
    y += this.startXY[1];
  }
  var snapping = this.xStep > 1 || this.yStep > 1;
  if (!snapping || x !== xy[0] || y !== xy[1]) {
    this.lastXY = [x, y];
    if (this.fireEvent('mousemove', this, e) === false) {
      this.onMouseUp(e);
    } else {
      this.onDrag(e);
      this.fireEvent('drag', this, e);
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Sch.util, 'DragTracker'], 0);
Ext.cmd.derive('Sch.tooltip.ClockTemplate', Ext.XTemplate, {minuteHeight:8, minuteTop:2, hourHeight:8, hourTop:2, handLeft:10, mode:'hour', getRotateStyle:function(degrees) {
  return 'transform:rotate(Ddeg);'.replace(/D/g, degrees);
}, getRotateStyleIE:function() {
  var toRad = Math.PI / 180, cos = Math.cos, sin = Math.sin;
  return function(degrees, top, height) {
    var me = this, rad = degrees * toRad, cosV = cos(rad), sinV = sin(rad), y = height * sin((90 - degrees) * toRad), x = height * cos((90 - degrees) * toRad), topAdjust = Math.min(height, height - y), leftAdjust = degrees > 180 ? x : 0, matrixString = "progid:DXImageTransform.Microsoft.Matrix(sizingMethod\x3d'auto expand', M11 \x3d " + cosV + ', M12 \x3d ' + -sinV + ', M21 \x3d ' + sinV + ', M22 \x3d ' + cosV + ')';
    return Ext.String.format('filter:{0};-ms-filter:{0};top:{1}px;left:{2}px;', matrixString, topAdjust + top, leftAdjust + me.handLeft);
  };
}(), constructor:function() {
  var isLegacyIE = Ext.isIE && Ext.isIE8m;
  Ext.XTemplate.prototype.constructor.call(this, '\x3cdiv class\x3d"sch-clockwrap ' + (isLegacyIE ? '' : 'sch-supports-border-radius') + ' sch-clock-{[this.mode]}"\x3e\x3cdiv class\x3d"sch-clock"\x3e\x3cdiv class\x3d"sch-hourIndicator" style\x3d"{[this.getHourStyle((values.date.getHours() % 12) * 30,' + this.hourTop + ', + ' + this.hourHeight + ')]}"\x3e{[Ext.Date.monthNames[values.date.getMonth()].substr(0,3)]}\x3c/div\x3e\x3cdiv class\x3d"sch-minuteIndicator" style\x3d"{[this.getMinuteStyle(values.date.getMinutes() * 6,' + 
  this.minuteTop + ', + ' + this.minuteHeight + ')]}"\x3e{[values.date.getDate()]}\x3c/div\x3e' + (isLegacyIE ? '' : '\x3cdiv class\x3d"sch-clock-dot"\x3e\x3c/div\x3e') + '\x3c/div\x3e\x3cspan class\x3d"sch-clock-text"\x3e{text}\x3c/span\x3e\x3c/div\x3e', {getMinuteStyle:isLegacyIE ? this.getRotateStyleIE : this.getRotateStyle, getHourStyle:isLegacyIE ? this.getRotateStyleIE : this.getRotateStyle});
}}, 1, 0, 0, 0, 0, 0, [Sch.tooltip, 'ClockTemplate'], 0);
Ext.cmd.derive('Sch.tooltip.Tooltip', Ext.tip.ToolTip, {autoHide:false, anchor:'b', padding:'0 3 0 0', showDelay:0, hideDelay:0, quickShowInterval:0, dismissDelay:0, trackMouse:false, anchorOffset:5, shadow:false, frame:false, schedulerView:null, message:null, startDate:null, endDate:null, template:null, valid:true, mode:null, offsetAdjust:[18, 5], constructor:function(config) {
  var clockTpl = new Sch.tooltip.ClockTemplate;
  this.startDate = this.endDate = new Date;
  if (!this.template) {
    this.template = Ext.create('Ext.XTemplate', '\x3cdiv class\x3d"x-fa sch-tip-{[values.valid ? "ok fa-check" : "notok fa-ban"]} "\x3e{[this.renderClock(values.startDate, values.startText, "sch-tooltip-startdate")]}{[this.renderClock(values.endDate, values.endText, "sch-tooltip-enddate")]}\x3cdiv class\x3d"sch-tip-message"\x3e{message}\x3c/div\x3e\x3c/div\x3e', {renderClock:function(date, text, cls) {
      return clockTpl.apply({date:date, text:text, cls:cls});
    }});
  }
  Ext.tip.ToolTip.prototype.constructor.apply(this, arguments);
}, update:function(startDate, endDate, valid, message) {
  if (this.startDate - startDate !== 0 || this.endDate - endDate !== 0 || this.valid !== valid || this.message !== message) {
    this.startDate = startDate;
    this.endDate = endDate;
    this.valid = valid;
    this.message = message;
    var startText = this.schedulerView.getFormattedDate(startDate), endText = this.schedulerView.getFormattedEndDate(endDate, startDate);
    if (this.mode === 'calendar' && endDate.getHours() === 0 && endDate.getMinutes() === 0 && !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) {
      endDate = Sch.util.Date.add(endDate, Sch.util.Date.DAY, -1);
    }
    Ext.tip.ToolTip.prototype.update.call(this, this.template.apply({valid:valid, startDate:startDate, endDate:endDate, startText:startText, endText:endText, message:message}));
  }
  if (this.rendered && this.isVisible()) {
    if (Ext.getVersion().isGreaterThan('6.2.1')) {
      this.realignToTarget();
    } else {
      this.realign();
    }
  }
}, showForElement:function(el, xOffset) {
  if (Sch.util.Date.compareUnits(this.schedulerView.getTimeResolution().unit, Sch.util.Date.DAY) >= 0) {
    this.mode = 'calendar';
    this.addCls('sch-day-resolution');
    this.removeCls('sch-hour-resolution');
  } else {
    this.mode = 'clock';
    this.removeCls('sch-day-resolution');
    this.addCls('sch-hour-resolution');
  }
  xOffset = arguments.length > 1 ? xOffset : this.offsetAdjust[0];
  this.mouseOffsets = [xOffset - this.offsetAdjust[0], -this.offsetAdjust[1]];
  this.setTarget(el);
  this.show();
  this.realign();
}, realign:function() {
  this.alignTo(this.target, 'bl-tl?', this.mouseOffsets);
}, afterRender:function() {
  Ext.tip.ToolTip.prototype.afterRender.apply(this, arguments);
  this.el.on('mouseenter', this.realign, this);
}}, 1, 0, ['component', 'box', 'container', 'panel', 'tip', 'tooltip'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tip':true, 'tooltip':true}, 0, 0, [Sch.tooltip, 'Tooltip'], 0);
Ext.cmd.derive('Sch.tooltip.HoverTip', Ext.tip.ToolTip, {trackMouse:true, bodyCls:'sch-hovertip', messageTpl:'\x3cdiv class\x3d"sch-hovertip-msg"\x3e{message}\x3c/div\x3e', autoHide:false, dismissDelay:1000, showDelay:0, schedulerView:null, clockTpl:null, lastTime:null, lastResource:null, initComponent:function() {
  var me = this;
  var view = me.schedulerView;
  me.clockTpl = new Sch.tooltip.ClockTemplate;
  me.messageTpl = new Ext.XTemplate(me.messageTpl);
  Ext.tip.ToolTip.prototype.initComponent.apply(this, arguments);
  me.on('beforeshow', me.tipOnBeforeShow, me);
  view.mon(view.el, {mouseleave:function() {
    me.hide();
  }, mousemove:me.handleMouseMove, scope:me});
  view.mon(view.el, {click:me.onBodyMouseDown, scope:me, delay:1});
}, onBodyMouseDown:function() {
  this.hide();
}, handleMouseMove:function(e) {
  var me = this;
  var view = me.schedulerView;
  if (me.disabled) {
    return;
  }
  if (e.getTarget('.' + view.itemCls, 5) && !e.getTarget(view.eventSelector) && e.pointerType === 'mouse') {
    var time = view.getDateFromDomEvent(e, 'floor');
    if (time) {
      var resourceRecord = view.resolveResource(e.getTarget());
      if (time - me.lastTime !== 0 || resourceRecord !== me.lastResource) {
        me.lastResource = resourceRecord;
        if (me.hidden) {
          if (Sch.util.Date.compareUnits(this.schedulerView.getTimeResolution().unit, Sch.util.Date.DAY) >= 0) {
            me.clockTpl.mode = 'day';
          } else {
            me.clockTpl.mode = 'hour';
          }
          me.show();
        }
        me.updateHoverTip(time, e);
      }
    } else {
      me.hide();
      me.lastTime = null;
      me.lastResource = null;
    }
  } else {
    me.hide();
    me.lastTime = null;
    me.lastResource = null;
  }
}, getText:function() {
}, updateHoverTip:function(date, e) {
  if (date) {
    var clockHtml = this.clockTpl.apply({date:date, text:this.schedulerView.getFormattedDate(date)});
    var messageHtml = this.messageTpl.apply({message:this.getText(date, e)});
    this.update(clockHtml + messageHtml);
    this.lastTime = date;
  }
}, tipOnBeforeShow:function(tip) {
  return !this.disabled && this.lastTime !== null;
}}, 0, ['scheduler_hovertip'], ['component', 'box', 'container', 'panel', 'tip', 'tooltip', 'scheduler_hovertip'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tip':true, 'tooltip':true, 'scheduler_hovertip':true}, ['widget.scheduler_hovertip'], 0, [Sch.tooltip, 'HoverTip'], 0);
Ext.cmd.derive('Sch.feature.DragCreator', Ext.Base, {disabled:false, showHoverTip:true, showDragTip:true, dragTip:null, dragTolerance:2, hoverTip:null, validatorFn:Ext.emptyFn, validatorFnScope:null, trackerConfig:null, schedulerView:null, template:'\x3cdiv class\x3d"sch-dragcreator-proxy"\x3e\x3cdiv class\x3d"sch-event-inner"\x3e\x26#160;\x3c/div\x3e\x3c/div\x3e', constructor:function(config) {
  Ext.apply(this, config || {});
  this.lastTime = new Date;
  if (!(this.template instanceof Ext.Template)) {
    this.template = new Ext.Template(this.template);
  }
  this.schedulerView.on('destroy', this.onSchedulerDestroy, this);
  if (Ext.supports.Touch) {
    this.schedulerView.on('boxready', this.initDragTracker, this);
  } else {
    this.schedulerView.el.on('mousemove', this.initDragTracker, this, {single:true});
  }
  this.callParent([config]);
}, setDisabled:function(disabled) {
  this.disabled = disabled;
  if (this.hoverTip && this.hoverTip.setDisabled) {
    this.hoverTip.setDisabled(disabled);
  }
  if (this.dragTip && this.dragTip.setDisabled) {
    this.dragTip.setDisabled(disabled);
  }
}, getProxy:function() {
  if (!this.proxy) {
    this.proxy = this.template.append(this.schedulerView.getEl(), {}, true);
    this.proxy.hide = function() {
      this.setStyle({left:0, right:0, top:'-10000px'});
    };
  }
  return this.proxy;
}, onBeforeDragStart:function(tracker, e) {
  var s = this.schedulerView, t = e.getTarget('.' + s.timeCellCls, 5);
  if (t && this.isCreateAllowed(e) && (!e.event.touches || e.event.touches.length === 1)) {
    var resourceRecord = s.resolveResource(t);
    var dateTime = s.getDateFromDomEvent(e);
    if (!this.disabled && t && s.fireEvent('beforedragcreate', s, resourceRecord, dateTime, e) !== false) {
      this.resourceRecord = resourceRecord;
      this.originalStart = dateTime;
      this.resourceRegion = s.getScheduleRegion(this.resourceRecord, this.originalStart);
      this.dateConstraints = s.getDateConstraints(this.resourceRecord, this.originalStart);
      return true;
    }
  }
  return false;
}, isCreateAllowed:function(e) {
  return !e.getTarget(this.schedulerView.eventSelector);
}, disableHoverTip:function() {
  this.hoverTip && this.hoverTip.disable && this.hoverTip.disable();
}, onDragStart:function() {
  var me = this, view = me.schedulerView, dragRegion = me.tracker.getRegion(), proxy = me.getProxy();
  this.dragging = true;
  if (this.hoverTip) {
    this.hoverTip.on('enable', this.disableHoverTip, this);
    this.hoverTip.disable();
  }
  me.start = me.originalStart;
  me.end = me.start;
  me.originalScroll = view.getScroll();
  if (view.isHorizontal()) {
    me.rowBoundaries = {top:me.resourceRegion.top, bottom:me.resourceRegion.bottom};
  } else {
    me.rowBoundaries = {left:me.resourceRegion.left, right:me.resourceRegion.right};
  }
  Ext.apply(dragRegion, me.rowBoundaries);
  if (view.rtl) {
    proxy.setStyle({right:'auto'});
  }
  proxy.setBox(dragRegion);
  proxy.show();
  view.fireEvent('dragcreatestart', view, proxy);
  if (me.showDragTip) {
    me.dragTip.enable();
    me.dragTip.update(me.start, me.end, true);
    me.dragTip.showForElement(proxy);
    me.dragTip.setStyle('visibility', 'visible');
  }
  Sch.util.ScrollManager.activate(view, view.isHorizontal() ? 'horizontal' : 'vertical');
}, onDrag:function() {
  var me = this, view = me.schedulerView, dragRegion = me.tracker.getRegion(), dates = view.getStartEndDatesFromRegion(dragRegion, 'round'), message = '';
  if (!dates) {
    return;
  }
  me.start = dates.start || me.start;
  me.end = dates.end || me.end;
  var dc = me.dateConstraints;
  if (dc) {
    me.end = Sch.util.Date.constrain(me.end, dc.start, dc.end);
    me.start = Sch.util.Date.constrain(me.start, dc.start, dc.end);
  }
  me.valid = this.validatorFn.call(me.validatorFnScope || me, me.resourceRecord, me.start, me.end);
  if (me.valid && typeof me.valid !== 'boolean') {
    message = me.valid.message;
    me.valid = me.valid.valid;
  }
  me.valid = me.valid !== false;
  if (me.showDragTip) {
    me.dragTip.update(me.start, me.end, me.valid, message);
  }
  Ext.apply(dragRegion, me.rowBoundaries);
  var scroll = view.getScroll();
  var proxy = this.getProxy();
  proxy.setBox(dragRegion);
  if (view.isHorizontal()) {
    proxy.setY(me.resourceRegion.top + me.originalScroll.top - scroll.top);
  }
}, eventSwallower:function(e) {
  e.stopPropagation();
  e.preventDefault();
}, onDragEnd:function(tracker, e) {
  var me = this, s = me.schedulerView, doFinalize = true, t = e.getTarget(), el = Ext.get(t);
  el.on('click', this.eventSwallower);
  me.unbindTimer = setTimeout(function() {
    el.un('click', me.eventSwallower);
  }, 100);
  me.dragging = false;
  if (me.showDragTip) {
    me.dragTip.disable();
  }
  if (!me.start || !me.end || me.end - me.start <= 0) {
    me.valid = false;
  }
  var createContext = {start:me.start, end:me.end, resourceRecord:me.resourceRecord, e:e, valid:me.valid, finalize:function(doCreate) {
    me.finalize(doCreate, createContext);
  }};
  if (me.valid) {
    doFinalize = s.fireEvent('beforedragcreatefinalize', s, createContext, e, this.getProxy()) !== false;
  }
  if (doFinalize) {
    me.finalize(me.valid, createContext);
  }
  Sch.util.ScrollManager.deactivate();
}, createEvent:function(context) {
  var schedulerView = this.schedulerView, newEvent = Ext.create(schedulerView.getEventStore().getModel());
  if (newEvent.setCalendar) {
    var calendar = context.resourceRecord.getCalendar && context.resourceRecord.getCalendar() || schedulerView.getEventStore().getCalendar();
    newEvent.setCalendar(calendar);
  }
  newEvent.setStartEndDate(context.start, context.end);
  if (newEvent.setCalendar) {
    newEvent.setCalendar(null);
  }
  return newEvent;
}, finalize:function(doCreate, context) {
  var schedulerView = this.schedulerView;
  if (doCreate) {
    schedulerView.fireEvent('dragcreateend', schedulerView, this.createEvent(context), context.resourceRecord, context.e, this.getProxy());
  }
  this.proxy.hide();
  this.schedulerView.fireEvent('afterdragcreate', schedulerView, this.getProxy());
  if (this.hoverTip) {
    this.hoverTip.un('enable', this.disableHoverTip, this);
    this.hoverTip.enable();
  }
}, dragging:false, initDragTracker:function() {
  var me = this, isTouch = Ext.supports.Touch, view = me.schedulerView;
  var config = Ext.apply({el:view.el, rtl:view.rtl, tolerance:me.dragTolerance, listeners:{mousedown:me.verifyLeftButtonPressed, beforedragstart:me.onBeforeDragStart, dragstart:me.onDragStart, drag:me.onDrag, dragend:me.onDragEnd, scope:me}}, this.trackerConfig);
  this.bindRightClickPreventer();
  if (isTouch && !Ext.platformTags.windows) {
    this.showDragTip = false;
    this.showHoverTip = false;
    this.dragTip = null;
    this.hoverTip = null;
  } else {
    this.setupTooltips();
  }
  me.tracker = new Sch.util.DragTracker(config);
}, bindRightClickPreventer:function() {
  var eventName;
  if (Ext.isIE9m) {
    eventName = 'mousedown';
  } else {
    eventName = 'contextmenu';
  }
  this.schedulerView.el.on(eventName, this.stopDragCreateOnRightClick, this, {priority:999});
}, stopDragCreateOnRightClick:function(e) {
  if (e.button !== 0 && this.dragging) {
    this.tracker.onMouseUp(e);
  }
}, setupTooltips:function() {
  var me = this, sv = me.schedulerView;
  if (this.showDragTip) {
    var dragTip = this.dragTip;
    if (dragTip instanceof Ext.tip.ToolTip) {
      dragTip.schedulerView = sv;
      dragTip.on('beforeshow', function() {
        return me.dragging;
      });
    } else {
      this.dragTip = new Sch.tooltip.Tooltip(Ext.apply({cls:'sch-dragcreate-tip', schedulerView:sv, constrainTo:sv.up('grid').el, listeners:{beforeshow:function() {
        return me.dragging;
      }}}, dragTip));
    }
  }
  if (me.showHoverTip) {
    var hoverTip = me.hoverTip;
    if (hoverTip instanceof Ext.tip.ToolTip) {
      hoverTip.schedulerView = sv;
    } else {
      me.hoverTip = Ext.ComponentManager.create(Ext.applyIf({renderTo:Ext.getBody(), target:sv.el, schedulerView:sv}, hoverTip), 'scheduler_hovertip');
    }
  }
}, verifyLeftButtonPressed:function(dragTracker, e) {
  return e.button === 0;
}, onSchedulerDestroy:function() {
  if (this.hoverTip && this.hoverTip.destroy) {
    this.hoverTip.destroy();
  }
  if (this.dragTip && this.dragTip.destroy) {
    this.dragTip.destroy();
  }
  if (this.tracker) {
    this.tracker.destroy();
  }
  if (this.proxy) {
    Ext.destroy(this.proxy);
    this.proxy = null;
  }
  clearTimeout(this.unbindTimer);
}}, 1, 0, 0, 0, 0, 0, [Sch.feature, 'DragCreator'], 0);
Ext.cmd.derive('Sch.feature.SchedulerDragZone', Ext.dd.DragZone, {repairHighlight:false, repairHighlightColor:'transparent', containerScroll:false, showTooltip:true, tip:null, deltaSetXY:null, schedulerView:null, _onValidDropTimer:null, lastXY:null, showExactDropPosition:false, enableCopy:false, enableCopyKey:'SHIFT', validatorFn:function(dragRecords, targetResourceRecord, date, duration, e) {
  return true;
}, validatorFnScope:null, copyKeyPressed:false, dragDropProxyCls:'sch-dd-ref', invalidCssClasses:['sch-resizable-handle', 'sch-terminal'], constructor:function(el, config) {
  if (Ext.isIE8m && window.top !== window) {
    Ext.dd.DragDropManager.notifyOccluded = true;
  }
  var proxy = this.proxy = this.proxy || new Ext.dd.StatusProxy({shadow:false, dropAllowed:this.dropAllowed, dropNotAllowed:this.dropNotAllowed, ensureAttachedToBody:Ext.emptyFn});
  Ext.dd.DragZone.prototype.constructor.apply(this, arguments);
  this.isTarget = true;
  this.scroll = false;
  this.ignoreSelf = false;
  var schedulerView = this.schedulerView;
  Ext.Array.each(this.invalidCssClasses, this.addInvalidHandleClass, this);
  if (schedulerView.touchScroll) {
    this.showTooltip = false;
  }
  schedulerView.el.appendChild(proxy.el);
  this.bindRightClickPreventer();
  proxy.addCls('sch-dragproxy');
  schedulerView.on({eventdragstart:function() {
    Sch.util.ScrollManager.activate(schedulerView, schedulerView.constrainDragToResource && schedulerView.getMode());
  }, aftereventdrop:function() {
    Sch.util.ScrollManager.deactivate();
  }, scope:this});
  if (this.showTooltip) {
    var tip = this.tip;
    if (tip instanceof Ext.tip.ToolTip) {
      tip.schedulerView = schedulerView;
    } else {
      this.tip = new Sch.tooltip.Tooltip(Ext.apply({schedulerView:schedulerView, constrainTo:schedulerView.up('grid').el, alignOnScroll:false, cls:'sch-dragdrop-tip'}, tip));
    }
  }
}, bindRightClickPreventer:function() {
  var eventName;
  if (Ext.isIE10) {
    eventName = 'contextmenu';
  } else {
    eventName = 'mousedown';
  }
  this.schedulerView.el.on(eventName, this.preventRightClick, this, {priority:999});
}, destroy:function() {
  this.tip && this.tip.destroy();
  clearTimeout(this._onValidDropTimer);
  Ext.dd.DragZone.prototype.destroy.apply(this, arguments);
}, preventRightClick:function(e) {
  if (this.dragging && e.button !== 0) {
    e.stopEvent();
    return false;
  }
}, autoOffset:function() {
  this.setDelta(0, 0);
}, setupConstraints:function(constrainRegion, elRegion, xOffset, yOffset, isHorizontal, tickSize, constrained) {
  this.clearTicks();
  var xTickSize = isHorizontal && !this.showExactDropPosition && tickSize > 1 ? tickSize : 0;
  var yTickSize = !isHorizontal && !this.showExactDropPosition && tickSize > 1 ? tickSize : 0;
  this.resetConstraints();
  this.initPageX = constrainRegion.left + xOffset;
  this.initPageY = constrainRegion.top + yOffset;
  var width = elRegion.right - elRegion.left;
  var height = elRegion.bottom - elRegion.top;
  if (isHorizontal) {
    if (constrained) {
      this.setXConstraint(constrainRegion.left + xOffset, constrainRegion.right - width + xOffset, xTickSize);
    } else {
      this.setXConstraint(constrainRegion.left, constrainRegion.right, xTickSize);
    }
    this.setYConstraint(constrainRegion.top + yOffset, constrainRegion.bottom - height + yOffset, yTickSize);
  } else {
    this.setXConstraint(constrainRegion.left + xOffset, constrainRegion.right - width + xOffset, xTickSize);
    if (constrained) {
      this.setYConstraint(constrainRegion.top + yOffset, constrainRegion.bottom - height + yOffset, yTickSize);
    } else {
      this.setYConstraint(constrainRegion.top, constrainRegion.bottom, yTickSize);
    }
  }
}, setXConstraint:function(iLeft, iRight, iTickSize) {
  this.leftConstraint = iLeft;
  this.rightConstraint = iRight;
  this.minX = iLeft;
  this.maxX = iRight;
  if (iTickSize) {
    this.setXTicks(this.initPageX, iTickSize);
  }
  this.constrainX = true;
}, setYConstraint:function(iUp, iDown, iTickSize) {
  this.topConstraint = iUp;
  this.bottomConstraint = iDown;
  this.minY = iUp;
  this.maxY = iDown;
  if (iTickSize) {
    this.setYTicks(this.initPageY, iTickSize);
  }
  this.constrainY = true;
}, onDragEnter:Ext.emptyFn, onDragOut:Ext.emptyFn, setVisibilityForSourceEvents:function(show) {
  Ext.Array.each(this.dragData.getEventBarElements(), function(el) {
    el && Ext.fly(el)[show ? 'show' : 'hide']();
  });
}, onDragOver:function(e) {
  if (e && e.event.touches && e.event.touches.length > 1) {
    Ext.dd.DragDropManager.handleMouseUp(e);
    return;
  }
  var xy = e ? e.getXY() : this.lastXY;
  if (!xy) {
    return;
  }
  var dd = this.dragData;
  if (!dd.originalHidden) {
    this.setVisibilityForSourceEvents(false);
    dd.originalHidden = true;
    this.onShiftKeyStateChange(e[this.enableCopyKey.toLowerCase() + 'Key']);
  }
  var start = dd.startDate;
  var resource = dd.newResource;
  var view = this.schedulerView;
  this.updateDragContext(e);
  if (this.showExactDropPosition) {
    var isHorizontal = view.isHorizontal();
    var timeDiff = view.getDateFromCoordinate(isHorizontal ? xy[0] : xy[1]) - dd.sourceDate;
    var realStart = new Date(dd.origStart - 0 + timeDiff);
    var offset = view.timeAxisViewModel.getDistanceBetweenDates(realStart, dd.startDate);
    if (dd.startDate > view.timeAxis.getStart()) {
      var proxyEl = this.proxy.el;
      if (offset) {
        if (view.isHorizontal()) {
          proxyEl.setX(xy[0] + (view.shouldAdjustForRtl() ? -offset : offset));
        } else {
          proxyEl.setY(xy[1] + offset);
        }
      }
    }
  }
  if (dd.startDate - start !== 0 || resource !== dd.newResource) {
    view.fireEvent('eventdrag', view, dd.draggedRecords, dd.startDate, dd.newResource, dd);
  }
  if (this.showTooltip) {
    this.tip.update(dd.startDate, dd.endDate, dd.valid, dd.message);
  }
  if (e) {
    this.lastXY = [e.browserEvent.clientX + document.body.scrollLeft, e.getY()];
  }
}, getCoordinate:function(coord) {
  var view = this.schedulerView;
  if (view.isHorizontal()) {
    return coord[0];
  }
  if (view.isVertical()) {
    return coord[1];
  }
  if (view.isWeekView()) {
    return coord;
  }
}, getDragData:function(e) {
  var schedulerView = this.schedulerView, eventNode = e.getTarget(schedulerView.eventSelector);
  if (!eventNode || e.event.touches && e.event.touches.length > 1) {
    return;
  }
  var eventRecord = schedulerView.resolveEventRecord(eventNode), resourceRecord = schedulerView.resolveResource(eventNode), assignmentRecord = schedulerView.resolveAssignmentRecord(eventNode), allowDrag = eventRecord && eventRecord.isDraggable() && !schedulerView.isReadOnly();
  if (!allowDrag || schedulerView.fireEvent('beforeeventdrag', schedulerView, eventRecord, e) === false) {
    return null;
  }
  var xy = e.getXY(), eventXY = Ext.fly(eventNode).getXY(), offsets = [xy[0] - eventXY[0], xy[1] - eventXY[1]], eventRegion = Ext.fly(eventNode).getRegion();
  this.lastXY = null;
  var isHorizontal = schedulerView.isHorizontal();
  schedulerView.constrainDragToResource && !resourceRecord && Ext.Error.raise('Resource could not be resolved for event: ' + eventRecord.getId());
  var dateConstraints = schedulerView.getDateConstraints(schedulerView.constrainDragToResource ? resourceRecord : null, eventRecord);
  this.setupConstraints(schedulerView.getScheduleRegion(schedulerView.constrainDragToResource ? resourceRecord : null, eventRecord), eventRegion, offsets[0], offsets[1], isHorizontal, schedulerView.getSnapPixelAmount(), Boolean(dateConstraints));
  var origStart = eventRecord.getStartDate(), origEnd = eventRecord.getEndDate(), timeAxis = schedulerView.timeAxis, relatedRecords = this.getRelatedRecords(assignmentRecord || eventRecord) || [], eventBarEls = schedulerView.getElementsFromEventRecord(eventRecord, schedulerView.isWeekView() ? null : resourceRecord, null, true);
  Ext.Array.each(relatedRecords, function(r) {
    if (r && r.isAssignmentModel) {
      eventBarEls = eventBarEls.concat(schedulerView.getElementsFromEventRecord(r.getEvent(), r.getResource(), null, true));
    } else {
      eventBarEls = eventBarEls.concat(schedulerView.getElementsFromEventRecord(r, null, null, true));
    }
  });
  eventBarEls = Ext.Array.unique(eventBarEls);
  var dragData = {offsets:offsets, repairXY:eventXY, prevScroll:schedulerView.getScroll(), dateConstraints:dateConstraints, eventBarEls:eventBarEls, getEventBarElements:function() {
    return dragData.eventBarEls = Ext.Array.map(dragData.eventBarEls, function(el) {
      return el && document.getElementById(el.id);
    });
  }, draggedRecords:[assignmentRecord || eventRecord].concat(relatedRecords), resourceRecord:resourceRecord, sourceDate:schedulerView.getDateFromCoordinate(this.getCoordinate(xy)), origStart:origStart, origEnd:origEnd, startDate:origStart, endDate:origEnd, timeDiff:0, startsOutsideView:origStart < timeAxis.getStart(), endsOutsideView:origEnd > timeAxis.getEnd(), duration:origEnd - origStart};
  this.copyKeyPressed = e[this.enableCopyKey.toLowerCase() + 'Key'];
  dragData.ddel = this.getDragElement(eventNode, dragData);
  return dragData;
}, onStartDrag:function() {
  var s = this.schedulerView, dd = this.dragData;
  Ext.Array.each(dd.getEventBarElements(), function(el) {
    Ext.fly(el).removeCls('sch-event-hover');
  });
  s.fireEvent('eventdragstart', s, dd.draggedRecords);
  s.getScrollable().on('scroll', this.onViewScroll, this);
  if (Ext.versions.extjs.isGreaterThan('6.2.0')) {
    s.up('timelinetree,timelinegrid').getScrollable().on('scroll', this.onViewScroll, this);
  }
}, alignElWithMouse:function(el, iPageX, iPageY) {
  Ext.dd.DragZone.prototype.alignElWithMouse.apply(this, arguments);
  if (Ext.isIE && this.schedulerView.rtl && this.schedulerView.up('[isViewport]')) {
    this.deltaSetXY = null;
    Ext.dd.DragZone.prototype.alignElWithMouse.apply(this, arguments);
  }
  var oCoord = this.getTargetCoord(iPageX, iPageY), fly = el.dom ? el : Ext.fly(el, '_dd');
  this.setLocalXY(fly, oCoord.x + this.deltaSetXY[0], oCoord.y + this.deltaSetXY[1]);
}, onViewScroll:function(scrollable) {
  var proxy = this.proxy, s = this.schedulerView, dd = this.dragData, scroll = s.getScroll(), left = scroll.left, top = scroll.top, rtlWithoutViewport = s.rtl && !s.up('[isViewport]');
  this.setVisibilityForSourceEvents(false);
  var xy = proxy.getXY();
  var newXY;
  if (rtlWithoutViewport) {
    newXY = [xy[0] - left + dd.prevScroll.left, xy[1] + top - dd.prevScroll.top];
  } else {
    newXY = [xy[0] + left - dd.prevScroll.left, xy[1] + top - dd.prevScroll.top];
  }
  var deltaSetXY = this.deltaSetXY;
  if (rtlWithoutViewport) {
    this.deltaSetXY = [deltaSetXY[0] - left + dd.prevScroll.left, deltaSetXY[1] + top - dd.prevScroll.top];
  } else {
    this.deltaSetXY = [deltaSetXY[0] + left - dd.prevScroll.left, deltaSetXY[1] + top - dd.prevScroll.top];
  }
  dd.prevScroll = {left:left, top:top};
  proxy.setXY(newXY);
  this.onDragOver();
}, isCopyKeyPressed:function() {
  return this.enableCopy && this.copyKeyPressed;
}, onShiftKeyStateChange:function(pressed) {
  var dd = this.dragData;
  if (pressed) {
    dd.refElements.addCls('sch-event-copy');
  } else {
    dd.refElements.removeCls('sch-event-copy');
  }
  this.setVisibilityForSourceEvents(pressed);
  this.copyKeyPressed = pressed;
}, onKey:function(e) {
  if (this.enableCopy && e.getKey() === e[this.enableCopyKey]) {
    this.onShiftKeyStateChange(e.type === 'keydown');
  }
  if (e.getKey() === e.ESC) {
    this.dragData.ddCallbackArgs = [e.getTarget(), e, this.id];
    this.finalize(false);
    Ext.dd.DragDropManager.stopDrag(e);
    Ext.dd.DragDropManager.stopEvent(e);
  }
}, startDrag:function() {
  Ext.getDoc().on({keydown:this.onKey, keyup:this.onKey, useCapture:true, scope:this});
  var retVal = Ext.dd.DragZone.prototype.startDrag.apply(this, arguments);
  var dragData = this.dragData;
  dragData.refElement = this.proxy.el.down('.' + this.dragDropProxyCls);
  dragData.refElements = this.proxy.el.select('.sch-event');
  dragData.refElement.removeCls('sch-event-hover');
  if (this.showTooltip) {
    this.tip.setStyle('visibility');
    this.tip.update(dragData.origStart, dragData.origEnd, true);
    this.tip.showForElement(dragData.refElement, dragData.offsets[0]);
  }
  if (this.copyKeyPressed) {
    dragData.refElements.addCls('sch-event-copy');
    dragData.originalHidden = true;
  }
  return retVal;
}, endDrag:function() {
  this.schedulerView.getScrollable().un('scroll', this.onViewScroll, this);
  if (Ext.versions.extjs.isGreaterThan('6.2.0')) {
    this.schedulerView.up('timelinetree,timelinegrid').getScrollable().un('scroll', this.onViewScroll, this);
  }
  Ext.getDoc().un({keydown:this.onKey, keyup:this.onKey, useCapture:true, scope:this});
  Ext.dd.DragZone.prototype.endDrag.apply(this, arguments);
}, onMouseUp:function() {
  if (!this.dragging) {
    this.afterDragFinalized();
  }
}, afterDragFinalized:function() {
  this.proxy.el.dom.style.top = this.proxy.el.dom.style.left = 0;
}, updateRecords:function(context) {
  var me = this, schedulerView = me.schedulerView, eventStore = schedulerView.getEventStore(), resourceStore = schedulerView.getResourceStore(), assignmentStore = eventStore.getAssignmentStore(), newResource = context.newResource, draggedRecord = context.draggedRecords[0], relatedDraggedRecords = context.draggedRecords.slice(1), resourceRecord = context.resourceRecord, copyKeyPressed = me.isCopyKeyPressed(), startDate = context.startDate, timeDiff = context.timeDiff, isWeekView = schedulerView.isWeekView(), 
  addedRecords;
  if (assignmentStore && eventStore instanceof Sch.data.EventStore) {
    me.updateRecordsMultipleAssignmentMode(startDate, timeDiff, draggedRecord, relatedDraggedRecords, resourceRecord, newResource, eventStore, resourceStore, assignmentStore, copyKeyPressed, isWeekView);
  } else {
    if (assignmentStore) {
      addedRecords = me.updateRecordsSingleAssignmentMode(startDate, timeDiff, draggedRecord.getEvent(), Ext.Array.map(relatedDraggedRecords, function(r) {
        return r.getEvent();
      }), resourceRecord, newResource, eventStore, resourceStore, copyKeyPressed, isWeekView);
    } else {
      addedRecords = me.updateRecordsSingleAssignmentMode(startDate, timeDiff, draggedRecord, relatedDraggedRecords, resourceRecord, newResource, eventStore, resourceStore, copyKeyPressed, isWeekView);
    }
  }
  if (copyKeyPressed) {
    context.copiedRecords = addedRecords;
  }
  schedulerView.fireEvent('eventdrop', schedulerView, context.copiedRecords || context.draggedRecords, copyKeyPressed);
}, updateRecordsSingleAssignmentMode:function(startDate, timeDiff, draggedEvent, relatedEvents, fromResource, toResource, eventStore, resourceStore, copy, isWeekView) {
  var me = this, toAdd = [];
  if (copy) {
    draggedEvent = draggedEvent.fullCopy(null);
    toAdd.push(draggedEvent);
  }
  draggedEvent.beginEdit();
  if (fromResource && fromResource.isResourceModel && toResource && toResource.isResourceModel && toResource !== fromResource) {
    if (copy) {
      draggedEvent.assign(toResource);
    } else {
      draggedEvent.reassign(fromResource, toResource);
    }
  }
  draggedEvent.setStartDate(startDate, true, eventStore.skipWeekendsDuringDragDrop);
  draggedEvent.endEdit();
  if (!isWeekView) {
    var indexDiff = resourceStore.indexOf(fromResource) - resourceStore.indexOf(toResource);
    Ext.Array.each(relatedEvents, function(related) {
      var relatedResources = related.getResources();
      if (copy) {
        related = related.fullCopy(null);
        toAdd.push(related);
      }
      related.beginEdit();
      related.setStartDate(me.adjustStartDate(related.getStartDate(), timeDiff), true, eventStore.skipWeekendsDuringDragDrop);
      indexDiff !== 0 && relatedResources.length && Ext.Array.each(relatedResources, function(r) {
        var newIndex = resourceStore.indexOf(r) - indexDiff, newResource;
        if (newIndex < 0) {
          newIndex = 0;
        } else {
          if (newIndex >= resourceStore.getCount()) {
            newIndex = resourceStore.getCount() - 1;
          }
        }
        newResource = resourceStore.getAt(newIndex);
        related.reassign(r, newResource);
      });
      related.endEdit();
    });
  }
  if (toAdd.length) {
    eventStore.append(toAdd);
  }
  return toAdd;
}, updateRecordsMultipleAssignmentMode:function(startDate, timeDiff, draggedAssignment, relatedAssignments, fromResource, toResource, eventStore, resourceStore, assignmentStore, copy, isWeekView) {
  var me = this;
  var handledEventsMap = {};
  Ext.Array.each([].concat(draggedAssignment, relatedAssignments), function(assignment) {
    var event = assignment.getEvent();
    if (handledEventsMap[event.getId()]) {
      return;
    }
    handledEventsMap[event.getId()] = true;
    event.setStartDate(me.adjustStartDate(event.getStartDate(), timeDiff), true, eventStore.skipWeekendsDuringDragDrop);
    if (!isWeekView && fromResource !== toResource) {
      if (copy) {
        event.assign(toResource);
      } else {
        if (!event.isAssignedTo(toResource)) {
          event.reassign(assignment.getResource(), toResource);
        } else {
          event.unassign(assignment.getResource());
        }
      }
    }
  });
}, isValidDrop:function(oldResource, newResource, sourceRecord) {
  if (oldResource !== newResource) {
    if (sourceRecord.isAssignmentModel) {
      return !sourceRecord.getEvent().isAssignedTo(newResource);
    } else {
      return !sourceRecord.isAssignedTo(newResource);
    }
  }
  return true;
}, resolveResource:function(xy) {
  var proxyDom = this.proxy.el.dom;
  var bodyScroll = Ext.getBody().getScroll();
  var view = this.schedulerView;
  proxyDom.style.display = 'none';
  var node = document.elementFromPoint(xy[0] - bodyScroll.left, xy[1] - bodyScroll.top);
  if (Ext.isIE8 && window.top.Siesta) {
    node = document.elementFromPoint(xy[0] - bodyScroll.left, xy[1] - bodyScroll.top);
  }
  proxyDom.style.display = 'block';
  if (!node) {
    return null;
  }
  if (Ext.fly(node).up('.x-grid-group-hd', 4, true)) {
    return null;
  }
  if (node.className.match('x-grid-item')) {
    return this.resolveResource([xy[0], xy[1] + 3]);
  }
  if (!node.className.match(view.timeCellCls)) {
    var parent = Ext.fly(node).up('.' + view.timeCellCls);
    if (parent) {
      node = parent.dom;
    } else {
      return null;
    }
  }
  return view.resolveResource(node);
}, adjustStartDate:function(startDate, timeDiff) {
  var s = this.schedulerView;
  return s.timeAxis.roundDate(new Date(startDate - 0 + timeDiff), s.snapRelativeToEventStartDate ? startDate : false);
}, updateDragContext:function(e) {
  var dd = this.dragData, xy = e ? e.getXY() : this.lastXY, clientX, rawXY;
  if (e) {
    if (e.browserEvent.touches && e.browserEvent.touches.length > 0) {
      clientX = e.browserEvent.touches[0].clientX;
    } else {
      clientX = e.browserEvent.clientX != null ? e.browserEvent.clientX : e.clientX;
    }
    rawXY = [clientX + document.body.scrollLeft, e.getY()];
  } else {
    rawXY = this.lastXY;
  }
  if (!dd.refElement) {
    return;
  }
  var s = this.schedulerView, proxyRegion = dd.refElement.getRegion();
  if (s.timeAxis.isContinuous()) {
    if (s.isHorizontal() && this.minX < xy[0] && xy[0] < this.maxX || !s.isHorizontal() && this.minY < xy[1] && xy[1] < this.maxY) {
      var newDate = s.getDateFromCoordinate(this.getCoordinate(xy));
      dd.timeDiff = newDate - dd.sourceDate;
      dd.startDate = this.adjustStartDate(dd.origStart, dd.timeDiff);
      dd.endDate = new Date(dd.startDate - 0 + dd.duration);
    }
  } else {
    var range;
    if (s.isWeekView()) {
      var calendarRange = {bottom:proxyRegion.bottom, top:proxyRegion.top};
      calendarRange.left = calendarRange.right = proxyRegion.left + dd.offsets[0];
      range = this.resolveStartEndDates(calendarRange);
    } else {
      range = this.resolveStartEndDates(proxyRegion);
    }
    dd.startDate = range.startDate;
    dd.endDate = range.endDate;
    dd.timeDiff = dd.startDate - dd.origStart;
  }
  dd.newResource = s.constrainDragToResource ? dd.resourceRecord : this.resolveResource(rawXY);
  if (dd.newResource) {
    var result = !e || this.validatorFn.call(this.validatorFnScope || this, dd.draggedRecords, dd.newResource, dd.startDate, dd.duration, e);
    if (!result || typeof result === 'boolean') {
      dd.valid = result !== false;
      dd.message = '';
    } else {
      dd.valid = result.valid !== false;
      dd.message = result.message;
    }
  } else {
    dd.valid = false;
  }
}, getRelatedRecords:function(eventRecord) {
  var view = this.schedulerView, sm = view.getEventSelectionModel(), result = sm.getDraggableSelections();
  return Ext.Array.filter(result, function(selectedRecord) {
    return eventRecord !== selectedRecord;
  });
}, getDragElement:function(sourceEl, dragData) {
  var eventBarEls = dragData.getEventBarElements();
  var copy;
  var retVal;
  var offsetX = dragData.offsets[0];
  var offsetY = dragData.offsets[1];
  var sourceNode = sourceEl.dom || sourceEl;
  var shouldFixPosition = !this.schedulerView.rtl || this.schedulerView.shouldAdjustForRtl();
  if (eventBarEls.length > 1) {
    var ctEl = Ext.core.DomHelper.createDom({tag:'div', cls:'sch-dd-wrap', style:{overflow:'visible'}});
    Ext.Array.each(eventBarEls, function(node) {
      copy = node.cloneNode(true);
      copy.id = Ext.id();
      if (node === sourceNode) {
        copy.className += ' ' + this.dragDropProxyCls;
        if (Ext.isIE8) {
          Ext.fly(copy).addCls(this.dragDropProxyCls);
        }
      }
      ctEl.appendChild(copy);
      var elOffsets = Ext.fly(node).getOffsetsTo(sourceNode);
      if (shouldFixPosition) {
        copy.style.left = elOffsets[0] - offsetX + 'px';
      } else {
        copy.style.left = offsetX - Ext.fly(node).getWidth() - elOffsets[0] + 'px';
      }
      copy.style.top = elOffsets[1] - offsetY + 'px';
    }, this);
    retVal = ctEl;
  } else {
    copy = sourceNode.cloneNode(true);
    copy.id = Ext.id();
    copy.style.left = (shouldFixPosition ? -offsetX : offsetX - Ext.fly(sourceNode).getWidth()) + 'px';
    copy.style.top = -offsetY + 'px';
    copy.className += ' ' + this.dragDropProxyCls;
    if (Ext.isIE8) {
      Ext.fly(copy).addCls(this.dragDropProxyCls);
    }
    retVal = copy;
  }
  if (!sourceNode.style.height) {
    Ext.fly(retVal).setHeight(Ext.fly(sourceNode).getHeight());
  }
  return retVal;
}, onDragDrop:function(e, id) {
  var me = this;
  me.updateDragContext(e);
  var s = me.schedulerView, target = me.cachedTarget || Ext.dd.DragDropMgr.getDDById(id), dragData = me.dragData, datesProvided = dragData.startDate && dragData.endDate, doFinalize = true;
  if (me.tip) {
    me.tip.hide();
  }
  var modified = dragData.startDate - dragData.origStart !== 0 || dragData.newResource !== dragData.resourceRecord;
  var valid = (modified || me.isCopyKeyPressed()) && dragData.valid && datesProvided && me.isValidDrop(dragData.resourceRecord, dragData.newResource, dragData.draggedRecords[0]);
  Ext.apply(dragData, {ddCallbackArgs:[target, e, id], start:dragData.startDate, end:dragData.endDate, finalize:function() {
    me.finalize.apply(me, arguments);
  }});
  if (valid) {
    doFinalize = s.fireEvent('beforeeventdropfinalize', me, dragData, e) !== false;
  }
  if (doFinalize) {
    me.finalize(valid);
  } else {
    me.proxy.el.addCls('sch-before-drag-finalized');
  }
}, finalize:function(updateRecords) {
  var me = this, view = me.schedulerView, eventStore = view.getEventStore();
  me.proxy.el.removeCls('sch-before-drag-finalized');
  if (updateRecords) {
    var updated, checkerFn = function() {
      updated = true;
    };
    eventStore.on('update', checkerFn, null, {single:true});
    me.updateRecords(me.dragData);
    eventStore.un('update', checkerFn, null, {single:true});
    if (!updated) {
      me.onInvalidDrop.apply(me, me.dragData.ddCallbackArgs);
    } else {
      if (Ext.isIE9) {
        me.proxy.el.setStyle('visibility', 'hidden');
        me._onValidDropTimer = Ext.Function.defer(me.onValidDrop, 10, me, me.dragData.ddCallbackArgs);
      } else {
        me.onValidDrop.apply(me, me.dragData.ddCallbackArgs);
      }
      view.fireEvent('aftereventdrop', view, me.dragData.copiedRecords || me.dragData.draggedRecords);
    }
    me.afterDragFinalized();
  } else {
    me.onInvalidDrop.apply(me, me.dragData.ddCallbackArgs);
  }
}, onInvalidDrop:function(target, e, id) {
  if (!e) {
    e = target;
    target = e.getTarget() || document.body;
  }
  if (this.tip) {
    this.tip.hide();
  }
  this.setVisibilityForSourceEvents(true);
  var s = this.schedulerView, retVal = Ext.dd.DragZone.prototype.onInvalidDrop.call(this, target, e, id);
  s.fireEvent('aftereventdrop', s, this.dragData.copiedRecords || this.dragData.draggedRecords);
  this.afterDragFinalized();
  return retVal;
}, resolveStartEndDates:function(proxyRegion) {
  var dd = this.dragData, startEnd, start = dd.origStart, end = dd.origEnd, DATE = Sch.util.Date;
  if (!dd.startsOutsideView) {
    startEnd = this.schedulerView.getStartEndDatesFromRegion(proxyRegion, 'round');
    if (startEnd) {
      if (startEnd.start && !this.schedulerView.timeAxis.dateInAxis(startEnd.start, false)) {
        var tick = this.schedulerView.timeAxis.getTickFromDate(startEnd.start);
        if (tick) {
          startEnd.start = this.schedulerView.timeAxis.getDateFromTick(tick);
        }
      }
      start = startEnd.start || dd.startDate;
      end = DATE.add(start, DATE.MILLI, dd.duration);
    }
  } else {
    if (!dd.endsOutsideView) {
      startEnd = this.schedulerView.getStartEndDatesFromRegion(proxyRegion, 'round');
      if (startEnd) {
        end = startEnd.end || dd.endDate;
        start = DATE.add(end, DATE.MILLI, -dd.duration);
      }
    }
  }
  return {startDate:start, endDate:end};
}}, 1, 0, 0, 0, 0, 0, [Sch.feature, 'SchedulerDragZone'], 0);
Ext.cmd.derive('Sch.feature.DragDrop', Ext.Base, {validatorFn:function(dragRecords, targetResourceRecord, date, duration, e) {
  return true;
}, validatorFnScope:null, dragConfig:null, constructor:function(schedulerView, config) {
  Ext.apply(this, config);
  this.schedulerView = schedulerView;
  schedulerView.eventDragZone = new Sch.feature.SchedulerDragZone(schedulerView.getEl(), Ext.apply({ddGroup:schedulerView.id, schedulerView:schedulerView, validatorFn:this.validatorFn, validatorFnScope:this.validatorFnScope}, this.dragConfig));
  this.schedulerView.on('destroy', this.cleanUp, this);
  this.callParent([config]);
}, cleanUp:function() {
  var schedulerView = this.schedulerView;
  if (schedulerView.eventDragZone) {
    schedulerView.eventDragZone.destroy();
  }
}}, 1, 0, 0, 0, 0, 0, [Sch.feature, 'DragDrop'], 0);
Ext.cmd.derive('Sch.patches.ScrollerEvents', Sch.util.Patch, {target:'Ext.scroll.Scroller', minVersion:'6.0.2', maxVersion:'6.5.0', reportUrl:'https://www.sencha.com/forum/showthread.php?334486-Please-add-xDelta-yDelta-to-scroller-s-scroll-scrollstart-scrollend-events\x26p\x3d1169887#post1169887', obsoleteTestName:'patches/004_scroller_events.t.js', description:['Modifies scroller event firing routines to include xDelta, yDelta into', 'the scrollstart/scroll/scrollend event signatures'].join(' '), 
overrides:{privates:{fireScrollStart:function(x, y, xDelta, yDelta) {
  var me = this, component = me.component;
  me.invokePartners('onPartnerScrollStart', x, y, xDelta, yDelta);
  if (me.hasListeners.scrollstart) {
    me.fireEvent('scrollstart', me, x, y, xDelta, yDelta);
  }
  if (component && component.onScrollStart) {
    component.onScrollStart(x, y);
  }
  Ext.GlobalEvents.fireEvent('scrollstart', me, x, y, xDelta, yDelta);
}, fireScroll:function(x, y, xDelta, yDelta) {
  var me = this, component = me.component;
  me.invokePartners('onPartnerScroll', x, y, xDelta, yDelta);
  if (me.hasListeners.scroll) {
    me.fireEvent('scroll', me, x, y, xDelta, yDelta);
  }
  if (component && component.onScrollMove) {
    component.onScrollMove(x, y);
  }
  Ext.GlobalEvents.fireEvent('scroll', me, x, y, xDelta, yDelta);
}, fireScrollEnd:function(x, y, xDelta, yDelta) {
  var me = this, component = me.component;
  me.invokePartners('onPartnerScrollEnd', x, y, xDelta, yDelta);
  if (me.hasListeners.scrollend) {
    me.fireEvent('scrollend', me, x, y, xDelta, yDelta);
  }
  if (component && component.onScrollEnd) {
    component.onScrollEnd(x, y);
  }
  Ext.GlobalEvents.fireEvent('scrollend', me, x, y, xDelta, yDelta);
}}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'ScrollerEvents'], 0);
Ext.cmd.derive('Sch.feature.ResizeZone', Ext.util.Observable, {showTooltip:true, showExactResizePosition:false, validatorFn:Ext.emptyFn, validatorFnScope:null, schedulerView:null, origEl:null, handlePos:null, eventRec:null, mouseDownEvent:null, tip:null, tipInstance:null, startScroll:null, constructor:function(config) {
  Ext.apply(this, config);
  var s = this.schedulerView;
  s.on({destroy:this.cleanUp, scope:this});
  s.el.on({mousedown:this.onMouseDown, mouseup:this.onMouseUp, scope:this, delegate:'.sch-resizable-handle'});
  this.bindRightClickPreventer();
  Ext.util.Observable.prototype.constructor.apply(this, arguments);
}, bindRightClickPreventer:function() {
  var eventName;
  if (Ext.isIE9m) {
    eventName = 'mousedown';
  } else {
    eventName = 'contextmenu';
  }
  var listener = {scope:this, priority:999};
  listener[eventName] = this.preventRightClick;
  this.schedulerView.el.on(listener);
}, preventRightClick:function(e) {
  if (e.button !== 0 && this.resizer) {
    e.stopEvent();
    return false;
  }
}, onMouseDown:function(e, t) {
  var s = this.schedulerView;
  var eventRec = this.eventRec = s.resolveEventRecord(t);
  var isResizable = eventRec.isResizable();
  if (e.button !== 0 || (isResizable === false || typeof isResizable === 'string' && !t.className.match(isResizable))) {
    return;
  }
  this.eventRec = eventRec;
  this.handlePos = this.getHandlePosition(t);
  this.origEl = Ext.get(e.getTarget('.sch-event'));
  this.mouseDownEvent = e;
  s.el.on({mousemove:this.onMouseMove, scope:this, single:true});
}, onMouseUp:function(e, t) {
  var s = this.schedulerView;
  s.el.un({mousemove:this.onMouseMove, scope:this, single:true});
  this.mouseDownEvent = null;
}, getTipInstance:function() {
  if (this.tipInstance) {
    return this.tipInstance;
  }
  var s = this.schedulerView;
  var tip = this.tip;
  if (tip instanceof Ext.tip.ToolTip) {
    tip.schedulerView = s;
  } else {
    tip = new Sch.tooltip.Tooltip(Ext.apply({rtl:this.rtl, schedulerView:s, constrainTo:s.up('grid').el, cls:'sch-resize-tip'}, tip));
  }
  return this.tipInstance = tip;
}, onMouseMove:function(e, t) {
  var s = this.schedulerView, eventRec = this.eventRec, handlePos = this.handlePos;
  if (!eventRec || s.fireEvent('beforeeventresize', s, eventRec, e) === false) {
    return;
  }
  delete this.eventRec;
  e.stopEvent();
  this.origEl.addCls('sch-event-resizing');
  this.resizer = this.createResizer(this.origEl, eventRec, handlePos);
  var tracker = this.resizer.resizeTracker;
  tracker.onMouseDown(this.mouseDownEvent, this.resizer[handlePos].dom);
  tracker.onMouseMove(e, this.resizer[handlePos].dom);
  if (this.showTooltip) {
    var tip = this.getTipInstance();
    tip.update(eventRec.getStartDate(), eventRec.getEndDate(), true);
    tip.showForElement(this.origEl, e.getX() - this.origEl.getX());
  }
  s.fireEvent('eventresizestart', s, eventRec);
  s.getScrollable().on('scroll', this.onViewScroll, this);
}, getHandlePosition:function(node) {
  var isStart = node.className.match('start');
  if (this.schedulerView.isHorizontal()) {
    if (this.schedulerView.rtl) {
      return isStart ? 'east' : 'west';
    }
    return isStart ? 'west' : 'east';
  } else {
    return isStart ? 'north' : 'south';
  }
}, createResizer:function(eventEl, eventRecord, handlePos) {
  var s = this.schedulerView, me = this, resourceRecord = s.resolveResource(eventEl), increment = s.getSnapPixelAmount(), constrainRegion = s.getScheduleRegion(resourceRecord, eventRecord), dateConstraints = s.getDateConstraints(resourceRecord, eventRecord), height = eventEl.getHeight(), isStart = s.rtl && handlePos[0] === 'e' || !s.rtl && handlePos[0] === 'w' || handlePos[0] === 'n', isVertical = !s.isHorizontal(), resizerCfg = {otherEdgeX:isStart ? eventEl.getRight() : eventEl.getLeft(), otherEdgeY:isStart ? 
  eventEl.getBottom() : eventEl.getTop(), target:eventEl, isStart:isStart, dateConstraints:dateConstraints, resourceRecord:resourceRecord, eventRecord:eventRecord, handles:handlePos[0], minHeight:height, constrainTo:constrainRegion, listeners:{resizedrag:this.partialResize, resize:this.afterResize, scope:this}};
  if (isVertical) {
    if (increment > 0) {
      var w = eventEl.getWidth();
      Ext.apply(resizerCfg, {minHeight:increment, minWidth:w, maxWidth:w, heightIncrement:increment});
    }
  } else {
    if (increment > 0) {
      Ext.apply(resizerCfg, {minWidth:increment, maxHeight:height, widthIncrement:increment});
    }
  }
  var resizer = new Ext.resizer.Resizer(resizerCfg);
  if (resizer.resizeTracker) {
    resizer.resizeTracker.tolerance = -1;
  }
  eventEl.setStyle('z-index', parseInt(eventEl.getStyle('z-index'), 10) + 1);
  Sch.util.ScrollManager.activate(s, s.isHorizontal() ? 'horizontal' : 'vertical');
  this.startScroll = s.getScroll();
  return resizer;
}, getStartEndDates:function() {
  var r = this.resizer, rEl = r.el, schedulerView = this.schedulerView, isStart = r.isStart, start, end, x, xy;
  if (isStart) {
    if (schedulerView.isHorizontal()) {
      x = schedulerView.rtl && schedulerView.shouldAdjustForRtl() ? rEl.getRight() : rEl.getLeft() + 1;
      xy = [x, 0];
    } else {
      xy = [(rEl.getRight() + rEl.getLeft()) / 2, rEl.getTop()];
    }
    end = r.eventRecord.getEndDate();
    if (schedulerView.snapRelativeToEventStartDate) {
      start = schedulerView.getDateFromXY(xy);
      start = schedulerView.timeAxis.roundDate(start, r.eventRecord.getStartDate());
    } else {
      start = schedulerView.getDateFromXY(xy, 'round');
    }
  } else {
    if (schedulerView.isHorizontal()) {
      x = schedulerView.rtl && schedulerView.shouldAdjustForRtl() ? rEl.getLeft() : rEl.getRight();
      xy = [x, 0];
    } else {
      xy = [(rEl.getRight() + rEl.getLeft()) / 2, rEl.getBottom()];
    }
    start = r.eventRecord.getStartDate();
    if (schedulerView.snapRelativeToEventStartDate) {
      end = schedulerView.getDateFromXY(xy);
      end = schedulerView.timeAxis.roundDate(end, r.eventRecord.getEndDate());
    } else {
      end = schedulerView.getDateFromXY(xy, 'round');
    }
  }
  start = start || r.start;
  end = end || r.end;
  if (r.dateConstraints) {
    start = Sch.util.Date.constrain(start, r.dateConstraints.start, r.dateConstraints.end);
    end = Sch.util.Date.constrain(end, r.dateConstraints.start, r.dateConstraints.end);
  }
  return {start:start, end:end};
}, partialResize:function(r, width, height, e) {
  var s = this.schedulerView, xy = e ? e.getXY() : this.resizer.resizeTracker.lastXY, startEndDates = this.getStartEndDates(xy), start = startEndDates.start, end = startEndDates.end, record = r.eventRecord, isHorizontal = s.isHorizontal();
  if (this.showTooltip) {
    var valid = this.validatorFn.call(this.validatorFnScope || this, r.resourceRecord, record, start, end);
    var message = '';
    if (valid && typeof valid !== 'boolean') {
      message = valid.message;
      valid = valid.valid;
    }
    this.getTipInstance().update(start, end, valid !== false, message);
  }
  if (this.showExactResizePosition) {
    var target = r.target.el, exactWidth, cursorDate, offset;
    if (r.isStart) {
      if (s.isWeekView()) {
        var column = s.weekview.getEventColumns(record)[0];
        exactWidth = s.timeAxisViewModel.getDistanceBetweenDates(start, column.end);
      } else {
        exactWidth = s.timeAxisViewModel.getDistanceBetweenDates(start, record.getEndDate());
      }
      if (isHorizontal) {
        cursorDate = s.getDateFromCoordinate(r.otherEdgeX - Math.min(width, r.maxWidth)) || start;
        offset = s.timeAxisViewModel.getDistanceBetweenDates(cursorDate, start);
        if (target.getWidth() !== exactWidth) {
          target.setWidth(exactWidth);
          target.setX(target.getX() + offset);
        }
      } else {
        cursorDate = s.getDateFromCoordinate(r.otherEdgeY - Math.min(height, r.maxHeight)) || start;
        offset = s.timeAxisViewModel.getDistanceBetweenDates(cursorDate, start);
        if (target.getHeight() !== exactWidth) {
          target.setHeight(exactWidth);
          target.setY(target.getY() + offset);
        }
      }
    } else {
      exactWidth = s.timeAxisViewModel.getDistanceBetweenDates(record.getStartDate(), end);
      if (isHorizontal) {
        target.setWidth(exactWidth);
      } else {
        target.setHeight(exactWidth);
      }
    }
  } else {
    if (!start || !end || r.start - start === 0 && r.end - end === 0) {
      return;
    }
  }
  r.end = end;
  r.start = start;
  s.fireEvent('eventpartialresize', s, record, start, end, r.el);
}, onViewScroll:function(scrollable, x, y, xDelta) {
  if (xDelta !== 0) {
    this.resizer.resizeTracker.onDrag({});
    this.partialResize(this.resizer, 0, 0);
  }
}, afterResize:function(r, w, h, e) {
  var me = this, resourceRecord = r.resourceRecord, eventRecord = r.eventRecord, oldStart = eventRecord.getStartDate(), oldEnd = eventRecord.getEndDate(), start = r.start || oldStart, end = r.end || oldEnd, s = me.schedulerView, isModified = start - oldStart || end - oldEnd, isValid = me.validatorFn.call(me.validatorFnScope || me, resourceRecord, eventRecord, start, end, e);
  Sch.util.ScrollManager.deactivate();
  s.getScrollable().un('scroll', this.onViewScroll, this);
  if (this.showTooltip) {
    this.getTipInstance().hide();
  }
  if (Ext.isObject(isValid)) {
    isValid = isValid.valid;
  }
  isValid = isValid !== false && start && end && end - start > 0;
  var resizeContext = {resourceRecord:r.resourceRecord, eventRecord:eventRecord, start:start, end:end, valid:isValid, modified:isModified, finalize:function(updateRecord) {
    me.finalize(updateRecord, resizeContext);
  }};
  var doFinalize = true;
  if (isValid && isModified) {
    doFinalize = s.fireEvent('beforeeventresizefinalize', s, resizeContext, e) !== false;
  }
  if (doFinalize) {
    me.finalize(isValid && isModified, resizeContext);
  }
}, finalize:function(updateRecord, context) {
  var s = this.schedulerView;
  var wasChanged = false;
  var checker = function() {
    wasChanged = true;
  };
  s.getEventStore().on('update', checker);
  this.resizer.target.destroy();
  if (Ext.isIE) {
    document.body.focus();
  }
  if (updateRecord) {
    if (this.resizer.isStart) {
      context.eventRecord.setStartDate(context.start, false, s.getEventStore().skipWeekendsDuringDragDrop);
    } else {
      context.eventRecord.setEndDate(context.end, false, s.getEventStore().skipWeekendsDuringDragDrop);
    }
    if (!wasChanged) {
      s.repaintEventsForResource(context.resourceRecord);
    }
  } else {
    s.repaintEventsForResource(context.resourceRecord);
  }
  this.resizer.destroy();
  delete this.resizer;
  s.getEventStore().un('update', checker);
  s.fireEvent('eventresizeend', s, context.eventRecord);
  s.fireEvent('aftereventresize', s, context.eventRecord);
}, cleanUp:function() {
  if (this.tipInstance) {
    this.tipInstance.destroy();
  }
  this.mouseDownEvent = null;
}}, 1, 0, 0, 0, 0, 0, [Sch.feature, 'ResizeZone'], 0);
Ext.cmd.derive('Sch.layout.TableLayout', Ext.view.TableLayout, {beginLayout:function(ownerContext) {
  var me = this, owner = me.owner, ownerGrid = owner.ownerGrid, partner = owner.lockingPartner, partnerVisible = partner && partner.grid.isVisible() && !partner.grid.collapsed, context = ownerContext.context;
  ownerContext.doSyncRowHeights = partnerVisible && (ownerGrid.syncRowHeight || ownerGrid.syncRowHeightOnNextLayout);
  if (!me.columnFlusherId) {
    me.columnFlusherId = me.id + '-columns';
    me.rowHeightFlusherId = me.id + '-rows';
  }
  if (me.owner.bufferedRenderer) {
    me.owner.bufferedRenderer.beforeTableLayout(ownerContext);
  }
  me.superclass.superclass.beginLayout.apply(this, [ownerContext]);
  if (partnerVisible && partner.componentLayout.isRunning()) {
    if (!ownerContext.lockingPartnerContext) {
      (ownerContext.lockingPartnerContext = context.getCmp(partner)).lockingPartnerContext = ownerContext;
    }
    if (ownerContext.doSyncRowHeights) {
      ownerContext.rowHeightSynchronizer = me.owner.syncRowHeightBegin();
    }
  }
  (ownerContext.headerContext = context.getCmp(me.headerCt)).viewContext = ownerContext;
}}, 0, 0, 0, 0, ['layout.timeline_tablelayout'], 0, [Sch.layout, 'TableLayout'], 0);
Ext.cmd.derive('Sch.plugin.Zones', Sch.feature.AbstractTimeSpan, {innerTpl:null, cls:'sch-zone', side:null, init:function(scheduler) {
  if (typeof this.innerTpl === 'string') {
    this.innerTpl = new Ext.XTemplate(this.innerTpl);
  }
  this.side = scheduler.rtl ? 'right' : 'left';
  var innerTpl = this.innerTpl;
  if (!this.template) {
    this.template = new Ext.XTemplate('\x3ctpl for\x3d"."\x3e\x3cdiv id\x3d"{id}" class\x3d"{$cls}" style\x3d"' + this.side + ':{left}px;top:{top}px;height:{height}px;width:{width}px;{style}"\x3e' + (innerTpl ? '{[this.renderInner(values)]}' : '') + '\x3c/div\x3e\x3c/tpl\x3e', {renderInner:function(values) {
      return innerTpl.apply(values);
    }});
  }
  if (typeof this.innerHeaderTpl === 'string') {
    this.innerHeaderTpl = new Ext.XTemplate(this.innerHeaderTpl);
  }
  Sch.feature.AbstractTimeSpan.prototype.init.apply(this, arguments);
}, getElementData:function(viewStart, viewEnd, records, isPrint) {
  var schedulerView = this.schedulerView, data = [];
  var region = schedulerView.getTimeSpanRegion(viewStart, viewEnd, this.expandToFitView);
  var record, spanStart, spanEnd, zoneData, width, templateData;
  records = records || this.store.getRange();
  for (var i = 0, l = records.length; i < l; i++) {
    record = records[i];
    spanStart = record.getStartDate();
    spanEnd = record.getEndDate();
    templateData = this.getTemplateData(record);
    if (spanStart && spanEnd && Sch.util.Date.intersectSpans(spanStart, spanEnd, viewStart, viewEnd)) {
      zoneData = Ext.apply({}, templateData);
      zoneData.id = this.getElementId(record);
      zoneData.$cls = this.getElementCls(record, templateData);
      if (schedulerView.isWeekView()) {
        var timeSpanRegion = schedulerView.getTimeSpanRegion(spanStart, spanEnd);
        zoneData.left = timeSpanRegion.left;
        zoneData.top = timeSpanRegion.top;
        zoneData.height = timeSpanRegion.bottom - timeSpanRegion.top;
        zoneData.width = timeSpanRegion.right - timeSpanRegion.left;
      } else {
        var startPos = schedulerView.getCoordinateFromDate(Sch.util.Date.max(spanStart, viewStart));
        var endPos = schedulerView.getCoordinateFromDate(Sch.util.Date.min(spanEnd, viewEnd));
        if (schedulerView.isHorizontal()) {
          zoneData.left = startPos;
          zoneData.top = region.top;
          zoneData.width = isPrint ? 0 : endPos - startPos;
          zoneData.style = isPrint ? 'border-left-width:' + (endPos - startPos) + 'px' : '';
        } else {
          zoneData.left = region.left;
          zoneData.top = startPos;
          zoneData.height = isPrint ? 0 : endPos - startPos;
          zoneData.style = isPrint ? 'border-top-width:' + (endPos - startPos) + 'px' : '';
        }
      }
      data.push(zoneData);
    }
  }
  return data;
}, getHeaderElementId:function(record, isStart) {
  return Sch.feature.AbstractTimeSpan.prototype.getHeaderElementId.call(this, record) + (isStart ? '-start' : '-end');
}, getHeaderElementCls:function(record, data, isStart) {
  var clsField = record.clsField || this.clsField;
  if (!data) {
    data = this.getTemplateData(record);
  }
  return 'sch-header-indicator sch-header-indicator-' + (isStart ? 'start ' : 'end ') + this.uniqueCls + ' ' + (data[clsField] || '');
}, getZoneHeaderElementData:function(startDate, endDate, record, isStart) {
  var date = isStart ? record.getStartDate() : record.getEndDate(), data = null, position, isHorizontal, templateData;
  if (date && Sch.util.Date.betweenLesser(date, startDate, endDate)) {
    position = this.getHeaderElementPosition(date);
    isHorizontal = this.schedulerView.isHorizontal();
    templateData = this.getTemplateData(record);
    data = Ext.apply({id:this.getHeaderElementId(record, isStart), cls:this.getHeaderElementCls(record, templateData, isStart), isStart:isStart, side:isHorizontal ? this.side : 'top', position:position}, templateData);
  }
  return data;
}, getHeaderElementData:function(records) {
  var startDate = this.timeAxis.getStart(), endDate = this.timeAxis.getEnd(), data = [], record, startData, endData;
  records = records || this.store.getRange();
  for (var i = 0, l = records.length; i < l; i++) {
    record = records[i];
    startData = this.getZoneHeaderElementData(startDate, endDate, record, true);
    if (startData) {
      data.push(startData);
    }
    endData = this.getZoneHeaderElementData(startDate, endDate, record, false);
    if (endData) {
      data.push(endData);
    }
  }
  return data;
}, updateZoneHeaderElement:function(el, data) {
  el.dom.className = data.cls;
  if (this.schedulerView.isHorizontal()) {
    this.setElementX(el, data.position);
  } else {
    el.setTop(data.position);
  }
}, updateHeaderElement:function(record) {
  var startDate = this.timeAxis.getStart(), endDate = this.timeAxis.getEnd(), startEl = Ext.get(this.getHeaderElementId(record, true)), endEl = Ext.get(this.getHeaderElementId(record, false)), startData = this.getZoneHeaderElementData(startDate, endDate, record, true), endData = this.getZoneHeaderElementData(startDate, endDate, record, false);
  if (!(startEl && endData) || !(endEl && endData)) {
    Ext.destroy(startEl, endEl);
    this.renderHeaderElements([record]);
  } else {
    if (startEl) {
      if (!startData) {
        Ext.destroy(startEl);
      } else {
        this.updateZoneHeaderElement(startEl, startData);
      }
    }
    if (endEl) {
      if (!endData) {
        Ext.destroy(endEl);
      } else {
        this.updateZoneHeaderElement(endEl, endData);
      }
    }
  }
}}, 0, 0, 0, 0, ['plugin.scheduler_zones'], 0, [Sch.plugin, 'Zones'], 0);
Ext.cmd.derive('Sch.plugin.RowZones', Sch.plugin.Zones, {innerTpl:null, store:null, init:function(scheduler) {
  this.store = Ext.StoreManager.lookup(this.store);
  this.uniqueCls = this.uniqueCls || 'sch-timespangroup-' + Ext.id();
  this.scheduler = scheduler;
  scheduler.registerRenderer(this.renderer, this);
  if (typeof this.innerTpl === 'string') {
    this.innerTpl = new Ext.XTemplate(this.innerTpl);
  }
  var innerTpl = this.innerTpl;
  if (!this.template) {
    this.template = new Ext.XTemplate('\x3ctpl for\x3d"."\x3e\x3cdiv id\x3d"' + this.uniqueCls + '-{id}" class\x3d"' + this.cls + ' ' + this.uniqueCls + ' {Cls}" style\x3d"' + (scheduler.rtl ? 'right' : 'left') + ':{start}px;width:{width}px;top:{start}px;height:{width}px;{style}"\x3e' + (innerTpl ? '{[this.renderInner(values)]}' : '{' + this.store.getModel().prototype.nameField + '}') + '\x3c/div\x3e\x3c/tpl\x3e', {renderInner:function(values) {
      return innerTpl.apply(values);
    }});
  }
  this.storeListeners = {refresh:this.fullRefresh, clear:this.fullRefresh, add:this.onZoneAdd, remove:this.onZoneRemove, update:this.onZoneUpdate, scope:this};
  this.store.on(this.storeListeners);
}, destroy:function() {
  this.store.un(this.storeListeners);
  Sch.plugin.Zones.prototype.destroy.apply(this, arguments);
}, getViewRecordByZone:function(zone) {
  throw 'Abstract method call';
}, getZoneContainerEl:function(zone) {
  var view = this.scheduler.getSchedulingView(), record = this.getViewRecordByZone(zone);
  return record && view.getNode(record).querySelector('.x-grid-cell-inner');
}, onZoneRemove:function(store, zones) {
  Ext.Array.forEach(zones, function(zone) {
    var node = document.getElementById(this.getElementId(zone));
    node && node.parentElement.removeChild(node);
  }, this);
}, onZoneAdd:function(store, zones) {
  Ext.Array.forEach(zones, function(zone) {
    var container = this.getZoneContainerEl(zone);
    container && this.appendZoneElement(zone, container);
  }, this);
}, fullRefresh:function() {
  var me = this, view = this.scheduler.getSchedulingView();
  if (view.el) {
    view.el.select('.' + this.uniqueCls).remove();
    Ext.Array.forEach(view.getNodes(), function(node) {
      me.renderRecordZones(view.getRecord(node), true);
    });
  }
}, renderer:function(val, meta, record, rowIndex) {
  var result = '';
  if (record && (this.scheduler.isHorizontal() || rowIndex === 0)) {
    result = this.renderRecordZones(record);
  }
  return result;
}, getRecordZones:function(record) {
  throw 'Abstract method call';
}, getZoneRenderData:function(zone) {
  var scheduler = this.scheduler, renderData = scheduler.getSchedulingView()[scheduler.getMode()].getEventRenderData(zone), start, width;
  if (scheduler.isHorizontal()) {
    start = scheduler.rtl ? renderData.right : renderData.left;
    width = renderData.width;
  } else {
    start = renderData.top;
    width = renderData.height;
  }
  return Ext.apply({id:zone.internalId, start:start, width:width, Cls:zone.getCls()}, zone.data);
}, renderRecordZones:function(record, targetElement) {
  var scheduler = this.scheduler, viewStart = scheduler.timeAxis.getStart(), viewEnd = scheduler.timeAxis.getEnd(), data = [], zones = this.getRecordZones(record), result = '', spanStartDate, spanEndDate, zone;
  for (var i = 0, len = zones.length; i < len; i++) {
    zone = zones[i];
    spanStartDate = zone.getStartDate();
    spanEndDate = zone.getEndDate();
    if (spanStartDate && spanEndDate && Sch.util.Date.intersectSpans(spanStartDate, spanEndDate, viewStart, viewEnd)) {
      data.push(this.getZoneRenderData(zone));
    }
  }
  if (targetElement) {
    if (zone) {
      if (Ext.isBoolean(targetElement)) {
        targetElement = this.getZoneContainerEl(zone);
      }
      this.template.append(targetElement, data);
    }
  } else {
    result = this.template.apply(data);
  }
  return result;
}, appendZoneElement:function(zone) {
  var scheduler = this.scheduler, viewStart = scheduler.timeAxis.getStart(), viewEnd = scheduler.timeAxis.getEnd(), containerEl = this.getZoneContainerEl(zone), spanStartDate = zone.getStartDate(), spanEndDate = zone.getEndDate();
  if (containerEl && spanStartDate && spanEndDate && Sch.util.Date.intersectSpans(spanStartDate, spanEndDate, viewStart, viewEnd)) {
    this.template.append(containerEl, this.getZoneRenderData(zone));
  }
}, onZoneUpdate:function(store, zone) {
  var node = document.getElementById(this.getElementId(zone));
  if (node) {
    var scheduler = this.scheduler, viewStart = scheduler.timeAxis.getStart(), viewEnd = scheduler.timeAxis.getEnd();
    var start = Sch.util.Date.max(viewStart, zone.getStartDate()), end = Sch.util.Date.min(viewEnd, zone.getEndDate()), cls = zone.getCls();
    var startPos = scheduler.getSchedulingView().getCoordinateFromDate(start);
    var width = scheduler.getSchedulingView().getCoordinateFromDate(end) - startPos;
    node.className = this.cls + ' ' + this.uniqueCls + ' ' + (cls || '');
    node.style.left = startPos + 'px';
    node.style.top = startPos + 'px';
    node.style.height = width + 'px';
    node.style.width = width + 'px';
  }
}}, 0, 0, 0, 0, 0, 0, [Sch.plugin, 'RowZones'], 0);
Ext.cmd.derive('Sch.plugin.ResourceZones', Sch.plugin.RowZones, {cls:'sch-resourcezone', init:function(scheduler) {
  Sch.plugin.RowZones.prototype.init.apply(this, arguments);
  this.store.setResourceStore(scheduler.getResourceStore());
  scheduler.on('resourcestorechange', this.onResourceStoreChange, this);
}, onResourceStoreChange:function(panel, newStore) {
  this.store.setResourceStore(newStore);
}, getRecordZones:function(record) {
  return record.getEvents(this.store);
}, getViewRecordByZone:function(zone) {
  return zone.getResource();
}, getZoneContainerEl:function(zone) {
  var result;
  if (this.scheduler.isHorizontal()) {
    result = Sch.plugin.RowZones.prototype.getZoneContainerEl.apply(this, arguments);
  } else {
    var view = this.scheduler.getSchedulingView(), resourceRecord = zone.getResource();
    if (view.el && resourceRecord) {
      var colIndex = view.resourceStore.indexOf(resourceRecord);
      result = view.getNode(0).querySelector('.x-grid-cell:nth-child(' + (colIndex + 1) + ') .x-grid-cell-inner');
    }
  }
  return result;
}, fullRefresh:function() {
  var me = this, view = this.scheduler.getSchedulingView();
  if (me.scheduler.isHorizontal()) {
    Sch.plugin.RowZones.prototype.fullRefresh.apply(this, arguments);
  } else {
    if (view.el) {
      view.el.select('.' + this.uniqueCls).remove();
      view.resourceStore.each(function(resource) {
        me.renderRecordZones(resource, true);
      });
    }
  }
}}, 0, 0, 0, 0, ['plugin.scheduler_resourcezones'], 0, [Sch.plugin, 'ResourceZones'], 0);
Ext.cmd.derive('Sch.mixin.AbstractSchedulerPanel', Ext.Base, {eventBarIconClsField:'', enableEventDragDrop:true, resourceColumnClass:'Sch.column.Resource', resourceColumnWidth:null, allowOverlap:true, startParamName:'startDate', endParamName:'endDate', passStartEndParameters:false, eventRenderer:null, eventRendererScope:null, eventStore:null, resourceStore:null, onEventCreated:function(newEventRecord, resources) {
}, resourceZones:null, resourceZonesConfig:null, initStores:function() {
  var resourceStore = this.resourceStore || this.store;
  if (this.crudManager) {
    if (!Sch.crud.AbstractManager) {
      throw new Error('Sch.crud.AbstractManager not loaded, did you forget to require crudManager class (e.g. Sch.data.CrudManager)?');
    }
    if (!(this.crudManager instanceof Sch.crud.AbstractManager)) {
      this.crudManager = Ext.create(this.crudManager.xclass || 'Sch.data.CrudManager', Ext.clone(this.crudManager));
    }
  }
  if (!resourceStore) {
    if (this.crudManager) {
      resourceStore = this.resourceStore = this.crudManager.getResourceStore();
    }
    if (!resourceStore) {
      if (this.isTree) {
        resourceStore = new Sch.data.ResourceTreeStore({proxy:'memory'});
      } else {
        resourceStore = new Sch.data.ResourceStore;
      }
    }
  }
  if (!this.dependencyStore) {
    if (this.crudManager) {
      this.dependencyStore = this.crudManager.getDependencyStore();
    }
  }
  if (!this.eventStore) {
    if (this.crudManager) {
      this.eventStore = this.crudManager.getEventStore();
    }
    this.eventStore = this.eventStore || new Sch.data.EventStore;
  }
  this.store = Ext.StoreManager.lookup(resourceStore);
  this.resourceStore = this.store;
  this.setEventStore(this.eventStore);
  if (!this.eventStore || !this.eventStore.isEventStore) {
    Ext.Error.raise('Your eventStore should be a subclass of Sch.data.EventStore (or consume the EventStore mixin)');
  }
  this.resourceStore.eventStore = this.getEventStore();
}, _initializeSchedulerPanel:function() {
  this.initStores();
  if (this.eventBodyTemplate && typeof this.eventBodyTemplate === 'string') {
    this.eventBodyTemplate = new Ext.XTemplate(this.eventBodyTemplate);
  }
  this.on('destroy', function() {
    this.setResourceStore(null);
    this.setEventStore(null);
  });
}, getResourceStore:function() {
  return this.resourceStore;
}, setResourceStore:function(newResourceStore) {
  var oldResourceStore = this.getResourceStore();
  this.resourceStore = newResourceStore = newResourceStore && Ext.StoreManager.lookup(newResourceStore);
  var eventStore = this.getEventStore();
  if (eventStore && newResourceStore) {
    eventStore.setResourceStore(newResourceStore);
  }
  var view = this.getSchedulingView();
  view && view.setResourceStore(newResourceStore);
  if (newResourceStore) {
    this.fireEvent('resourcestorechange', this, newResourceStore, oldResourceStore);
    if (this.isVertical()) {
      this.refreshResourceColumns();
      this.mun(oldResourceStore, this.verticalListeners);
      this.mon(newResourceStore, this.verticalListeners);
    }
    if (this.isWeekView()) {
      this.mun(oldResourceStore, this.calendarResourceStoreListeners);
      this.mon(newResourceStore, this.calendarResourceStoreListeners);
    }
    if (oldResourceStore === this.store) {
      this.reconfigure(newResourceStore);
    } else {
      this.refreshViews(false);
    }
  }
}, getEventStore:function() {
  return this.eventStore;
}, setEventStore:function(newEventStore) {
  var oldEventStore = this.getEventStore();
  newEventStore = newEventStore && Ext.StoreManager.lookup(newEventStore);
  if (this.getEventStore()) {
    this.mun(this.getEventStore(), 'beforeload', this.applyStartEndParameters, this);
  }
  var resourceStore = this.getResourceStore();
  var assignmentStore = this.getAssignmentStore();
  var dependencyStore = this.getDependencyStore();
  this.eventStore = newEventStore;
  if (resourceStore && newEventStore) {
    resourceStore.setEventStore(newEventStore);
  }
  if (assignmentStore && newEventStore && !newEventStore.getAssignmentStore()) {
    newEventStore.setAssignmentStore(assignmentStore);
  }
  if (dependencyStore && newEventStore && !newEventStore.getDependencyStore()) {
    newEventStore.setDependencyStore(dependencyStore);
  }
  var view = this.getSchedulingView();
  view && view.setEventStore(newEventStore);
  if (newEventStore) {
    this.fireEvent('eventstorechange', this, newEventStore, oldEventStore);
    if (this.passStartEndParameters) {
      this.mon(newEventStore, 'beforeload', this.applyStartEndParameters, this);
    }
    this.refreshViews(false);
  }
}, applyStartEndParameters:function(eventStore, options) {
  var proxy = eventStore.getProxy();
  proxy.setExtraParam(this.startParamName, this.getStart());
  proxy.setExtraParam(this.endParamName, this.getEnd());
}, getAssignmentStore:function() {
  var me = this, eventStore = me.getEventStore();
  return eventStore && eventStore.isStore && eventStore.getAssignmentStore() || me.assignmentStore;
}, setAssignmentStore:function(newAssignmentStore) {
  var oldStore = this.getAssignmentStore();
  this.getEventStore().setAssignmentStore(newAssignmentStore);
  if (newAssignmentStore) {
    this.fireEvent('assignmentstorechange', this, newAssignmentStore, oldStore);
    this.refreshViews(false);
  }
}, getDependencyStore:function() {
  var me = this, eventStore = me.getEventStore();
  return eventStore && eventStore.isStore && eventStore.getDependencyStore() || me.dependencyStore;
}, setDependencyStore:function(newDependencyStore) {
  var oldStore = this.getDependencyStore();
  this.getEventStore().setDependencyStore(newDependencyStore);
  if (newDependencyStore) {
    this.fireEvent('dependencystorechange', this, newDependencyStore, oldStore);
    this.refreshViews(false);
  }
}, createResourceColumns:function(colWidth) {
  return Ext.Array.map(this.resourceStore.getRange(), function(resource) {
    return {xclass:this.resourceColumnClass, renderer:this.mainRenderer, scope:this, width:colWidth || 100, text:resource.getName(), model:resource};
  }, this);
}, registerEventEditor:function(editor) {
  this.getSchedulingView().registerEventEditor(editor);
}}, 0, 0, 0, 0, 0, 0, [Sch.mixin, 'AbstractSchedulerPanel'], 0);
Ext.cmd.derive('Sch.template.Event', Ext.XTemplate, {eventPrefix:null, resizeHandles:null, resizeTpl:'\x3cdiv class\x3d"sch-resizable-handle sch-resizable-handle-DIR"\x3e\x3c/div\x3e', terminalSides:null, terminalTpl:'\x3cdiv class\x3d"sch-terminal sch-terminal-SIDE"\x3e\x3c/div\x3e', constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  Ext.XTemplate.prototype.constructor.call(this, this.getOuterMarkup());
}, getOuterMarkup:function() {
  var me = this;
  var terminalMarkup = Ext.Array.map(me.terminalSides || [], function(side) {
    return me.terminalTpl.replace(/SIDE/, side);
  }).join('');
  return ['\x3ctpl for\x3d"."\x3e', '\x3cdiv unselectable\x3d"on" tabindex\x3d"-1" id\x3d"', me.eventPrefix, '{id}" style\x3d"right:{right}px;left:{left}px;top:{top}px;height:{height}px;width:{width}px;{style}" class\x3d"sch-event ', 'x-', 'unselectable {internalCls} {cls}"\x3e', me.resizeHandles === 'start' || me.resizeHandles === 'both' ? me.resizeTpl.replace(/DIR/, 'start') : '', '\x3cdiv unselectable\x3d"on" class\x3d"sch-event-inner {iconCls}"\x3e', this.getInnerMarkup(), '\x3c/div\x3e', me.resizeHandles === 
  'end' || me.resizeHandles === 'both' ? me.resizeTpl.replace(/DIR/, 'end') : '', terminalMarkup, '\x3c/div\x3e', '\x3c/tpl\x3e'].join('');
}, getInnerMarkup:function() {
  return '{body}';
}}, 1, 0, 0, 0, 0, 0, [Sch.template, 'Event'], 0);
Ext.cmd.derive('Sch.view.Vertical', Ext.Base, {view:null, constructor:function(config) {
  Ext.apply(this, config);
}, getElementsFromEventRecord:function(eventRecord, resourceRecord, index, raw) {
  var view = this.view, query;
  raw = raw || false;
  if (resourceRecord) {
    query = '[id^\x3d' + view.eventPrefix + eventRecord.internalId + '-' + resourceRecord.internalId + '-]';
  } else {
    query = '[id^\x3d' + view.eventPrefix + eventRecord.internalId + '-]';
  }
  return view.getEl().query(query, raw);
}, translateToScheduleCoordinate:function(y) {
  var view = this.view;
  return y - view.getViewContainerElementTop() + view.getVerticalScroll();
}, translateToPageCoordinate:function(y) {
  var view = this.view;
  var scroll = view.getVerticalScroll();
  return y + view.getViewContainerElementTop() - scroll;
}, getDateFromXY:function(xy, roundingMethod, local) {
  var coord = xy[1];
  if (!local) {
    coord = this.translateToScheduleCoordinate(coord);
  }
  return this.view.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
}, getEventRenderData:function(event, resource) {
  var M = Math, eventStart = event.getStartDate(), eventEnd = event.getEndDate(), view = this.view, viewStart = view.timeAxis.getStart(), viewEnd = view.timeAxis.getEnd(), startY = M.floor(view.getCoordinateFromDate(Sch.util.Date.max(eventStart, viewStart))), endY = M.floor(view.getCoordinateFromDate(Sch.util.Date.min(eventEnd, viewEnd))), data = {event:event};
  data.top = M.max(0, M.min(startY, endY) - view.eventBorderWidth);
  data.height = M.max(1, M.abs(startY - endY));
  data.start = eventStart;
  data.end = eventEnd;
  data.startsOutsideView = eventStart < viewStart;
  data.endsOutsideView = eventEnd > viewEnd;
  return data;
}, getScheduleRegion:function(resourceRecord, eventRecord) {
  var view = this.view, region = resourceRecord ? Ext.fly(view.getScheduleCell(view.getNodes()[0], view.getResourceStore().indexOf(resourceRecord))).getRegion() : view.getTableRegion(), taStart = view.timeAxis.getStart(), taEnd = view.timeAxis.getEnd(), dateConstraints = view.getDateConstraints(resourceRecord, eventRecord) || {start:taStart, end:taEnd}, startY = this.translateToPageCoordinate(view.getCoordinateFromDate(Sch.util.Date.max(taStart, dateConstraints.start))), endY = this.translateToPageCoordinate(view.getCoordinateFromDate(Sch.util.Date.min(taEnd, 
  dateConstraints.end))), left = region.left + view.barMargin, right = (resourceRecord ? region.left + this.getResourceColumnWidth(resourceRecord) : region.right) - view.barMargin;
  return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
}, getResourceColumnWidth:function(resource) {
  return this.view.timeAxisViewModel.resourceColumnWidth;
}, getResourceColumnLayoutAvailableWidth:function(resourceRecord) {
  var me = this;
  return me.getResourceColumnWidth(resourceRecord) - 2 * me.view.barMargin - me.view.cellBorderWidth;
}, getResourceRegion:function(resourceRecord, startDate, endDate) {
  var view = this.view, cellLeft = view.getResourceStore().indexOf(resourceRecord) * this.getResourceColumnWidth(resourceRecord), taStart = view.timeAxis.getStart(), taEnd = view.timeAxis.getEnd(), start = startDate ? Sch.util.Date.max(taStart, startDate) : taStart, end = endDate ? Sch.util.Date.min(taEnd, endDate) : taEnd, startY = Math.max(0, view.getCoordinateFromDate(start) - view.cellTopBorderWidth), endY = view.getCoordinateFromDate(end) - view.cellTopBorderWidth, left = cellLeft + view.cellBorderWidth, 
  right = cellLeft + this.getResourceColumnWidth(resourceRecord) - view.cellBorderWidth;
  return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
}, columnRenderer:function(val, meta, resourceRecord, rowIndex, colIndex) {
  var view = this.view;
  var retVal = '';
  if (rowIndex === 0) {
    var D = Sch.util.Date, ta = view.timeAxis, columnEvents, resourceEvents, i, l;
    columnEvents = [];
    resourceEvents = view.getEventStore().getEventsForResource(resourceRecord);
    for (i = 0, l = resourceEvents.length; i < l; i++) {
      var event = resourceEvents[i], start = event.getStartDate(), end = event.getEndDate();
      if (start && end && ta.timeSpanInAxis(start, end)) {
        columnEvents.push(view.generateTplData(event, resourceRecord, colIndex));
      }
    }
    view.eventLayout.vertical.applyLayout(columnEvents, this.getResourceColumnLayoutAvailableWidth(resourceRecord));
    retVal = '\x26#160;' + view.eventTpl.apply(columnEvents);
  }
  if (colIndex % 2 === 1) {
    meta.tdCls = (meta.tdCls || '') + ' ' + view.altColCls;
    meta.cellCls = (meta.cellCls || '') + ' ' + view.altColCls;
  }
  return retVal;
}, resolveResource:function(node) {
  var me = this, view = me.view, eventNode, index = -1, result;
  eventNode = Ext.fly(node).is(view.eventSelector) && node || Ext.fly(node).up(view.eventSelector, null, true);
  if (eventNode) {
    result = view.getResourceRecordFromDomId(eventNode.id);
  } else {
    node = Ext.fly(node).is(view.timeCellSelector) ? node : Ext.fly(node).up(view.timeCellSelector, null, true);
    if (node) {
      if (Ext.isIE8m) {
        index = 0;
        node = node.previousSibling;
        while (node) {
          if (node.nodeType === 1) {
            index++;
          }
          node = node.previousSibling;
        }
      } else {
        index = Ext.Array.indexOf(Array.prototype.slice.call(node.parentNode.children), node);
      }
    }
    result = index >= 0 && view.getResourceStore().getAt(index) || null;
  }
  return result;
}, onEventUpdate:function(store, event) {
  var me = this;
  var previous = event.previous || {};
  var view = me.view;
  var timeAxis = view.timeAxis;
  var newStartDate = event.getStartDate();
  var newEndDate = event.getEndDate();
  var startDate = previous.StartDate || newStartDate;
  var endDate = previous.EndDate || newEndDate;
  var eventWasInView = startDate && endDate && timeAxis.timeSpanInAxis(startDate, endDate);
  var resource;
  if (event.resourceIdField in previous && eventWasInView) {
    resource = store.getResourceStore().getById(previous[event.resourceIdField]);
    resource && me.relayoutRenderedEvents(resource);
  }
  if (newStartDate && newEndDate && timeAxis.timeSpanInAxis(newStartDate, newEndDate) || eventWasInView) {
    me.renderSingle(event);
    Ext.Array.each(event.getResources(), function(resource) {
      me.relayoutRenderedEvents(resource);
      view.getEventSelectionModel().isSelected(event) && view.onEventBarSelect(event, true);
    });
  }
}, onEventAdd:function(store, recs) {
  var me = this, view = me.view, event, startDate, endDate;
  if (recs.length === 1) {
    event = recs[0];
    startDate = event.getStartDate();
    endDate = event.getEndDate();
    if (startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate)) {
      me.renderSingle(event);
      Ext.Array.each(store.getResourcesForEvent(event), function(resource) {
        me.relayoutRenderedEvents(resource);
      });
    }
  } else {
    view.repaintAllEvents();
  }
}, onEventRemove:function(s, events) {
  var me = this, view = me.view, event, startDate, endDate, i, len, gotEventInTimeSpan;
  for (gotEventInTimeSpan = false, i = 0, len = events.length; !gotEventInTimeSpan && i < len; i++) {
    event = events[i];
    startDate = event.getStartDate();
    endDate = event.getEndDate();
    gotEventInTimeSpan = startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate);
    gotEventInTimeSpan && Ext.asap(function() {
      view.repaintAllEvents();
    });
  }
}, relayoutRenderedEvents:function(resource) {
  var data = [], view = this.view, events = view.getEventStore().getEventsForResource(resource);
  Ext.Array.each(events, function(event) {
    var nodes = view.getElementsFromEventRecord(event, resource);
    nodes.length && data.push({start:event.getStartDate(), end:event.getEndDate(), event:event, node:nodes[0]});
  });
  view.eventLayout.vertical.applyLayout(data, this.getResourceColumnLayoutAvailableWidth(resource));
  Ext.Array.each(data, function(event) {
    event.node.setStyle({left:event.left + 'px', width:event.width + 'px'});
    view.fireEvent('eventrepaint', view, event.event, event.node);
  });
}, renderSingle:function(event) {
  var view = this.view, startDate = event.getStartDate(), endDate = event.getEndDate();
  Ext.Array.each(view.getElementsFromEventRecord(event), function(el) {
    el.destroy();
  });
  if (startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate)) {
    Ext.Array.each(event.getResources(), function(resource) {
      var rIndex = view.getResourceStore().indexOf(resource), containerCell = Ext.fly(view.getScheduleCell(0, rIndex)), data;
      if (containerCell) {
        data = view.generateTplData(event, resource, rIndex);
        view.eventTpl.append(containerCell.first(), [data]);
      }
    });
  }
}, getTimeSpanRegion:function(startDate, endDate) {
  var view = this.view, startY = view.getCoordinateFromDate(startDate), endY = endDate ? view.getCoordinateFromDate(endDate) : startY, tableRegion = view.getTableRegion(), width = tableRegion ? tableRegion.right - tableRegion.left : view.getEl().dom.clientWidth;
  return new Ext.util.Region(Math.min(startY, endY), width, Math.max(startY, endY), 0);
}, getStartEndDatesFromRegion:function(region, roundingMethod) {
  var topDate = this.view.getDateFromCoordinate(region.top, roundingMethod), bottomDate = this.view.getDateFromCoordinate(region.bottom, roundingMethod);
  if (topDate && bottomDate) {
    return {start:topDate, end:bottomDate};
  } else {
    return null;
  }
}, setColumnWidth:function(width, preventRefresh) {
  var view = this.view;
  view.resourceColumnWidth = width;
  view.getTimeAxisViewModel().setViewColumnWidth(width, preventRefresh);
}, getVisibleDateRange:function() {
  var view = this.view;
  if (!view.rendered) {
    return null;
  }
  var scroll = view.getScroll(), height = view.getViewContainerHeight(), tableRegion = view.getTableRegion(), viewEndDate = view.timeAxis.getEnd();
  if (tableRegion.bottom - tableRegion.top < height) {
    var startDate = view.timeAxis.getStart();
    return {startDate:startDate, endDate:viewEndDate};
  }
  return {startDate:view.getDateFromCoordinate(scroll.top, null, true), endDate:view.getDateFromCoordinate(scroll.top + height, null, true) || viewEndDate};
}, getItemBox:function(eventRecord) {
  var me = this;
  return Ext.Array.map(eventRecord.getResources(), function(resourceRecord) {
    return me.getResourceEventBox(eventRecord, resourceRecord);
  });
}, getResourceEventBox:function(eventRecord, resourceRecord) {
  var SUD = Sch.util.Date, me = this, result = null, view = me.view, viewStartDate = view.timeAxis.getStart(), viewEndDate = view.timeAxis.getEnd(), eventStartDate = eventRecord.getStartDate(), eventEndDate = eventRecord.getEndDate(), eventLayout, eventsLayoutData, eventRecordData, resourceColumnLeft, eventEls, eventEl, eventElOffsets, eventElBox;
  if (eventStartDate && eventEndDate && SUD.intersectSpans(eventStartDate, eventEndDate, viewStartDate, viewEndDate)) {
    if (view.managedEventSizing) {
      eventLayout = view.eventLayout.vertical;
      var resourceEvents = view.getEventStore().filterEventsForResource(resourceRecord, view.timeAxis.isRangeInAxis, view.timeAxis);
      eventsLayoutData = Ext.Array.map(resourceEvents, me.getEventRenderData, me);
      eventLayout.applyLayout(eventsLayoutData, me.getResourceColumnLayoutAvailableWidth(resourceRecord));
      eventRecordData = Ext.Array.findBy(eventsLayoutData, function(eventData) {
        return eventData.event == eventRecord;
      });
      if (eventRecordData) {
        resourceColumnLeft = view.getResourceStore().indexOf(resourceRecord) * me.getResourceColumnWidth(resourceRecord);
        result = {rendered:true, start:eventRecordData.left + resourceColumnLeft, end:eventRecordData.left + eventRecordData.width + resourceColumnLeft, top:eventRecordData.top, bottom:eventRecordData.top + eventRecordData.height};
      }
    } else {
      eventEls = view.getElementsFromEventRecord(eventRecord, eventRecord !== resourceRecord && resourceRecord);
      if (eventEls.length) {
        eventEl = eventEls[0];
        eventElOffsets = eventEl.getOffsetsTo(view.getEl());
        eventElBox = eventEl.getBox();
        result = {rendered:true, start:eventElOffsets[0], end:eventElOffsets[0] + eventElBox.width, top:eventElOffsets[1], bottom:eventElOffsets[1] + eventElBox.height};
      }
    }
    if (result) {
      result = me.adjustItemBox(eventRecord, result);
    }
  }
  return result;
}, adjustItemBox:function(eventRecord, eventRecordBox) {
  return eventRecordBox;
}, getConnectorStartSide:function(eventRecord) {
  return 'top';
}, getConnectorEndSide:function(eventRecord) {
  return 'bottom';
}}, 1, 0, 0, 0, 0, 0, [Sch.view, 'Vertical'], 0);
Ext.cmd.derive('Sch.mixin.AbstractSchedulerView', Ext.Base, {_cmpCls:'sch-schedulerview', scheduledEventName:'event', eventTemplateClass:'Sch.template.Event', eventTpl:null, barMargin:0, constrainDragToResource:false, allowOverlap:null, readOnly:null, altColCls:'sch-col-alt', highlightedEventCls:'sch-event-highlighted', highlightDirtyEvents:false, dynamicRowHeight:true, managedEventSizing:true, eventAnimations:true, horizontalLayoutCls:'Sch.eventlayout.Horizontal', horizontalEventSorterFn:null, verticalLayoutCls:'Sch.eventlayout.Vertical', 
verticalEventSorterFn:null, eventCls:'sch-event', verticalViewClass:'Sch.view.Vertical', eventStore:null, resourceStore:null, eventLayout:null, terminalSides:null, _initializeSchedulerView:function() {
  var horLayoutCls = Ext.ClassManager.get(this.horizontalLayoutCls);
  var vertLayoutCls = Ext.ClassManager.get(this.verticalLayoutCls);
  this.eventSelector = '.' + this.eventCls;
  this.eventLayout = {};
  this.eventTpl = this.eventTpl || Ext.create(this.eventTemplateClass, {eventPrefix:this.eventPrefix, terminalSides:this.terminalSides, resizeHandles:this.eventResizeHandles});
  if (horLayoutCls) {
    this.eventLayout.horizontal = new horLayoutCls(Ext.apply({timeAxisViewModel:this.timeAxisViewModel}, {bandIndexToPxConvertFn:this.horizontal.layoutEventVertically, bandIndexToPxConvertScope:this.horizontal}, this.horizontalEventSorterFn ? {sortEvents:this.horizontalEventSorterFn} : {}));
  }
  if (vertLayoutCls) {
    this.eventLayout.vertical = new vertLayoutCls(Ext.apply({view:this}, this.verticalEventSorterFn ? {sortEvents:this.verticalEventSorterFn} : {}));
  }
  this.store = this.store || this.resourceStore;
  this.resourceStore = this.resourceStore || this.store;
}, generateTplData:function(event, resourceRecord, columnIndex) {
  var renderData = this[this.mode].getEventRenderData(event, resourceRecord, columnIndex), start = event.getStartDate(), end = event.getEndDate(), internalCls = event.getCls() || '';
  internalCls += ' sch-event-resizable-' + event.getResizable();
  if (event.dirty) {
    internalCls += ' sch-dirty ';
  }
  if (renderData.endsOutsideView) {
    internalCls += ' sch-event-endsoutside ';
  }
  if (renderData.startsOutsideView) {
    internalCls += ' sch-event-startsoutside ';
  }
  if (this.eventBarIconClsField) {
    internalCls += ' sch-event-withicon ';
  }
  if (event.isDraggable() === false) {
    internalCls += ' sch-event-fixed ';
  }
  if (end - start === 0) {
    internalCls += ' sch-event-milestone ';
  }
  if (this.getEventSelectionModel().isSelected(event)) {
    internalCls += ' ' + this.selectedEventCls + ' ';
  }
  if (event.isHighlighted || (this.highlightDirtyEvents ? event.dirty : false)) {
    internalCls += ' ' + this.highlightedEventCls + ' ';
  }
  if (this.isWeekView()) {
    renderData.id = event.internalId + '-calendar-' + columnIndex + '-x';
  } else {
    renderData.id = event.internalId + '-' + resourceRecord.internalId + '-x';
  }
  renderData.internalCls = internalCls;
  renderData.start = start;
  renderData.end = end;
  renderData.iconCls = event.data[this.eventBarIconClsField] || event.getIconCls && event.getIconCls() || '';
  renderData.event = event;
  if (this.eventRenderer) {
    var value = this.eventRenderer.call(this.eventRendererScope || this, event, resourceRecord, renderData, columnIndex);
    if (this.eventBodyTemplate) {
      renderData.body = this.eventBodyTemplate.apply(value);
    } else {
      renderData.body = value;
    }
  } else {
    if (this.eventBodyTemplate) {
      renderData.body = this.eventBodyTemplate.apply(event.data);
    } else {
      if (this.eventBarTextField) {
        renderData.body = Ext.htmlEncode(event.data[this.eventBarTextField]) || '';
      }
    }
  }
  return renderData;
}, resolveResource:function(node) {
  var me = this;
  return me[me.mode].resolveResource(node);
}, getResourceRegion:function(resourceRecord, startDate, endDate) {
  return this[this.mode].getResourceRegion(resourceRecord, startDate, endDate);
}, resolveEventRecord:function(el) {
  el = el.dom ? el.dom : el;
  if (!Ext.fly(el).is(this.eventSelector)) {
    el = Ext.fly(el).up(this.eventSelector);
  }
  return el && this.getEventRecordFromDomElement(el);
}, resolveEventRecordFromResourceRow:function(el) {
  var me = this, sm = me.getEventSelectionModel(), resource, event;
  el = el.dom ? el.dom : el;
  resource = me.getRecord(el);
  return sm.getFirstSelectedEventForResource(resource);
}, resolveAssignmentRecord:function(el) {
  var me = this, assignmentStore = me.getEventStore().getAssignmentStore(), assignment = null, event, resource;
  if (assignmentStore) {
    event = me.getEventRecordFromDomElement(el);
    resource = me.getResourceRecordFromDomElement(el);
    if (event && resource) {
      assignment = assignmentStore.getAssignmentForEventAndResource(event, resource);
    }
  }
  return assignment;
}, getEventRecordFromDomId:function(id) {
  id = this.getEventIdFromDomNodeId(id);
  return this.getEventStore().getModelByInternalId(id);
}, getEventRecordFromDomElement:function(el) {
  return this.getEventRecordFromDomId(el.id);
}, getResourceRecordFromDomId:function(id) {
  id = this.getResourceIdFromDomNodeId(id);
  return this.getResourceStore().getByInternalId(id);
}, getResourceRecordFromDomElement:function(el) {
  return this.getResourceRecordFromDomId(el.id);
}, isDateRangeAvailable:function(start, end, excludeEvent, resource) {
  return this.getEventStore().isDateRangeAvailable(start, end, excludeEvent, resource);
}, getEventsInView:function() {
  var viewStart = this.timeAxis.getStart(), viewEnd = this.timeAxis.getEnd();
  return this.getEventStore().getEventsInTimeSpan(viewStart, viewEnd);
}, getEventNodes:function() {
  return this.getEl().select(this.eventSelector);
}, triggerHighlightEvents:function(records, highlight) {
  var me = this;
  var elements = [];
  Ext.Array.each([].concat(records), function(ev) {
    elements.push.apply(elements, me.getElementsFromEventRecord(ev, null, null, true));
  });
  var method = highlight !== false ? 'addCls' : 'removeCls';
  Ext.Array.each(records, function(record) {
    record.isHighlighted = highlight;
  });
  Ext.Array.each([].concat(elements), function(el) {
    Ext.fly(el)[method](me.highlightedEventCls);
  });
}, highlightEvents:function(records) {
  this.triggerHighlightEvents(records, true);
}, unhighlightEvents:function(records) {
  this.triggerHighlightEvents(records, false);
}, highlightEventsBy:function(fn, scope) {
  var events = this.getEventsInView();
  this.highlightEvents(events.filterBy(fn, scope).getRange());
}, clearHighlightedEvents:function() {
  Ext.Array.each(this.getEventStore().getRange(), function(event) {
    event.isHighlighted = false;
  });
  this.getEl().select('.' + this.highlightedEventCls).removeCls(this.highlightedEventCls);
}, onEventCreated:function(newEventRecord, resources) {
}, getEventStore:function() {
  return this.eventStore;
}, registerEventEditor:function(editor) {
  var me = this;
  me.eventEditor = editor;
  me.mon(editor.editor || editor, {'beforeeventadd':function() {
    var newArgs = Ext.Array.toArray(arguments);
    Ext.Array.splice(newArgs, 0, 1, me);
    return me.fireEventArgs.call(me, 'beforeeventadd', newArgs);
  }});
}, getEventEditor:function() {
  return this.eventEditor;
}, onEventUpdate:function(store, model, operation) {
  this[this.mode].onEventUpdate(store, model, operation);
}, onEventAdd:function(s, recs) {
  if (!Ext.isArray(recs)) {
    recs = [recs];
  }
  this[this.mode].onEventAdd(s, recs);
}, onAssignmentAdd:function(store, assignments) {
  var me = this;
  Ext.Array.each(assignments, function(assignment) {
    var resource = assignment.getResource();
    resource && me.repaintEventsForResource(resource);
  });
}, onAssignmentUpdate:function(store, assignment) {
  var me = this, oldResourceId = assignment.previous && assignment.previous[assignment.resourceIdField], newResourceId = assignment.getResourceId(), oldResource, newResource;
  if (oldResourceId) {
    oldResource = me.getResourceStore().getModelById(oldResourceId);
    me.repaintEventsForResource(oldResource);
  }
  if (newResourceId) {
    newResource = me.getResourceStore().getModelById(newResourceId);
    me.repaintEventsForResource(newResource);
  }
}, onAssignmentRemove:function(store, assignments) {
  var me = this;
  Ext.Array.each(assignments, function(assignment) {
    var resourceId = assignment.getResourceId();
    var resource = resourceId && me.getResourceStore().getModelById(resourceId);
    resource && me.repaintEventsForResource(resource);
  });
}, onEventRemove:function(s, recs) {
  this[this.mode].onEventRemove(s, recs);
}, setEventStore:function(eventStore, initial) {
  var me = this;
  var oldStore = me.getEventStore();
  var listenerCfg = {scope:me, refresh:me.onEventDataRefresh, addrecords:me.onEventAdd, updaterecord:me.onEventUpdate, removerecords:me.onEventRemove, update:me.onEventUpdate, nodeinsert:me.onEventAdd, nodeappend:me.onEventAdd};
  if (!(eventStore && eventStore.isTreeStore)) {
    listenerCfg.remove = me.onEventRemove;
    listenerCfg.add = me.onEventAdd;
  }
  var assignmentListenerCfg = {scope:me, refresh:me.onEventDataRefresh, load:me.onEventDataRefresh, update:me.onAssignmentUpdate, add:me.onAssignmentAdd, remove:me.onAssignmentRemove};
  if (!Ext.versions.touch) {
    listenerCfg.clear = me.onEventDataRefresh;
  }
  if (!initial && me.eventStore) {
    if (eventStore) {
      me.eventStore.setResourceStore(null);
    }
    if (eventStore !== me.eventStore && me.eventStore.autoDestroy) {
      me.eventStore.destroy();
    } else {
      if (me.mun) {
        me.mun(me.eventStore, listenerCfg);
        var oldAssignmentStore = me.eventStore.getAssignmentStore();
        if (oldAssignmentStore) {
          me.mun(oldAssignmentStore, assignmentListenerCfg);
        }
      } else {
        me.eventStore.un(listenerCfg);
      }
    }
    if (!eventStore) {
      me.eventStore = null;
    }
  }
  if (eventStore) {
    eventStore = Ext.data.StoreManager.lookup(eventStore);
    if (me.mon) {
      me.mon(eventStore, listenerCfg);
    } else {
      eventStore.on(listenerCfg);
    }
    me.eventStore = eventStore;
    eventStore.setResourceStore(me.getResourceStore());
    var assignmentStore = eventStore.getAssignmentStore();
    if (assignmentStore) {
      me.mon(assignmentStore, assignmentListenerCfg);
    }
  }
  if (eventStore && !initial) {
    this.getTimeAxisViewModel().setEventStore(eventStore);
    this.getEventSelectionModel().bindStore(eventStore);
    this.fireEvent('eventstorechange', this, eventStore, oldStore);
    me.refreshView();
  }
}, onEventDataRefresh:function() {
  this.refreshKeepingScroll();
}, onEventBarSelect:function(record) {
  var me = this, event, resource;
  if (record && record.isAssignmentModel) {
    event = record.getEvent();
    resource = record.getResource();
  } else {
    event = record;
    resource = null;
  }
  Ext.Array.each(me.getElementsFromEventRecord(event, resource, null, true), function(el) {
    Ext.fly(el).addCls(me.selectedEventCls);
  });
}, onEventBarDeselect:function(record) {
  var me = this, event, resource;
  if (record && record.isAssignmentModel) {
    event = record.getEvent();
    resource = record.getResource();
  } else {
    event = record;
    resource = null;
  }
  event && Ext.Array.each(me.getElementsFromEventRecord(event, resource, null, true), function(el) {
    Ext.fly(el).removeCls(me.selectedEventCls);
  });
}, refresh:function() {
  throw 'Abstract method call';
}, repaintEventsForResource:function(record) {
  throw 'Abstract method call';
}, repaintAllEvents:function() {
  this.refreshKeepingScroll();
}, scrollEventIntoView:function(eventRec, highlight, animate, callback, scope) {
  var me = this, resources = eventRec.getResources();
  if (resources.length > 1) {
    Ext.Error.raise('AbstractSchedulerView::scrollEventIntoView() is not applicable for events with multiple assignments, please use AbstractSchedulerView::scrollResourceEventIntoView() instead.');
  }
  resources.length && me.scrollResourceEventIntoView(resources[0], eventRec, null, highlight, animate, callback, scope);
}, getResourceStore:function() {
  return this.resourceStore;
}, setResourceStore:function(store) {
  var oldStore = this.resourceStore;
  this.resourceStore = store;
  if (store) {
    this.fireEvent('resourcestorechange', this, store, oldStore);
  }
}, rowHasDynamicRowHeight:function(resource) {
  return this.dynamicRowHeight;
}}, 0, 0, 0, 0, 0, 0, [Sch.mixin, 'AbstractSchedulerView'], 0);
Ext.cmd.derive('Sch.preset.ViewPreset', Ext.Base, {name:null, rowHeight:24, timeColumnWidth:50, timeRowHeight:null, timeAxisColumnWidth:null, displayDateFormat:'G:i', shiftUnit:'HOUR', shiftIncrement:1, defaultSpan:12, timeResolution:null, headerConfig:null, columnLinesFor:'middle', headers:null, mainHeader:0, ptype:'', constructor:function(cfg) {
  Ext.apply(this, cfg);
  this.normalizeUnits();
}, normalizeUnits:function() {
  var headerConfig = this.headerConfig;
  var DATE = Sch.util.Date;
  for (var o in headerConfig) {
    if (headerConfig.hasOwnProperty(o)) {
      if (DATE[headerConfig[o].unit]) {
        headerConfig[o].unit = DATE[headerConfig[o].unit.toUpperCase()];
      }
      if (DATE[headerConfig[o].splitUnit]) {
        headerConfig[o].splitUnit = DATE[headerConfig[o].splitUnit.toUpperCase()];
      }
    }
  }
  var timeResolution = this.timeResolution;
  if (timeResolution && DATE[timeResolution.unit]) {
    timeResolution.unit = DATE[timeResolution.unit.toUpperCase()];
  }
  var shiftUnit = this.shiftUnit;
  if (shiftUnit && DATE[shiftUnit]) {
    this.shiftUnit = DATE[shiftUnit.toUpperCase()];
  }
}, getHeaders:function() {
  if (this.headers) {
    return this.headers;
  }
  var headerConfig = this.headerConfig;
  this.mainHeader = headerConfig.top ? 1 : 0;
  return this.headers = [].concat(headerConfig.top || [], headerConfig.middle || [], headerConfig.bottom || []);
}, getMainHeader:function() {
  return this.getHeaders()[this.mainHeader];
}, getBottomHeader:function() {
  var headers = this.getHeaders();
  return headers[headers.length - 1];
}, clone:function() {
  var config = {};
  var me = this;
  Ext.Array.each(['rowHeight', 'timeColumnWidth', 'timeRowHeight', 'timeAxisColumnWidth', 'displayDateFormat', 'shiftUnit', 'shiftIncrement', 'defaultSpan', 'timeResolution', 'headerConfig'], function(name) {
    config[name] = me[name];
  });
  return new this.self(Ext.clone(config));
}, isValid:function() {
  var D = Sch.util.Date, valid = true, validUnits = Sch.util.Date.units, ownKeys = {};
  for (var o in this.headerConfig) {
    if (this.headerConfig.hasOwnProperty(o)) {
      ownKeys[o] = true;
      valid = valid && Ext.Array.indexOf(validUnits, this.headerConfig[o].unit) >= 0;
    }
  }
  if (!(this.columnLinesFor in ownKeys)) {
    this.columnLinesFor = 'middle';
  }
  if (this.timeResolution) {
    valid = valid && Ext.Array.indexOf(validUnits, this.timeResolution.unit) >= 0;
  }
  if (this.shiftUnit) {
    valid = valid && Ext.Array.indexOf(validUnits, this.shiftUnit) >= 0;
  }
  return valid;
}}, 1, 0, 0, 0, 0, 0, [Sch.preset, 'ViewPreset'], 0);
Ext.cmd.derive('Sch.preset.Manager', Ext.util.MixedCollection, {singleton:true, defaultPresets:{secondAndMinute:{timeColumnWidth:30, rowHeight:24, resourceColumnWidth:100, displayDateFormat:'G:i:s', shiftIncrement:10, shiftUnit:'MINUTE', defaultSpan:24, timeResolution:{unit:'SECOND', increment:5}, headerConfig:{middle:{unit:'SECOND', increment:10, align:'center', dateFormat:'s'}, top:{unit:'MINUTE', align:'center', dateFormat:'D, d g:iA'}}}, minuteAndHour:{timeColumnWidth:100, rowHeight:24, resourceColumnWidth:100, 
displayDateFormat:'G:i', shiftIncrement:1, shiftUnit:'HOUR', defaultSpan:24, timeResolution:{unit:'MINUTE', increment:30}, headerConfig:{middle:{unit:'MINUTE', increment:'30', align:'center', dateFormat:'i'}, top:{unit:'HOUR', align:'center', dateFormat:'D, gA/d'}}}, hourAndDay:{timeColumnWidth:60, rowHeight:24, resourceColumnWidth:100, displayDateFormat:'G:i', shiftIncrement:1, shiftUnit:'DAY', defaultSpan:24, timeResolution:{unit:'MINUTE', increment:30}, headerConfig:{middle:{unit:'HOUR', align:'center', 
dateFormat:'G:i'}, top:{unit:'DAY', align:'center', dateFormat:'D d/m'}}}, dayAndWeek:{timeColumnWidth:100, rowHeight:24, resourceColumnWidth:100, displayDateFormat:'Y-m-d G:i', shiftUnit:'DAY', shiftIncrement:1, defaultSpan:5, timeResolution:{unit:'HOUR', increment:1}, headerConfig:{middle:{unit:'DAY', align:'center', dateFormat:'D d M'}, top:{unit:'WEEK', align:'center', renderer:function(start, end, cfg) {
  return Sch.util.Date.getShortNameOfUnit('WEEK') + '.' + Ext.Date.format(start, 'W M Y');
}}}}, weekAndDay:{timeColumnWidth:100, rowHeight:24, resourceColumnWidth:100, displayDateFormat:'Y-m-d', shiftUnit:'WEEK', shiftIncrement:1, defaultSpan:1, timeResolution:{unit:'DAY', increment:1}, headerConfig:{bottom:{unit:'DAY', align:'center', increment:1, dateFormat:'d/m'}, middle:{unit:'WEEK', dateFormat:'D d M'}}}, weekAndMonth:{timeColumnWidth:100, rowHeight:24, resourceColumnWidth:100, displayDateFormat:'Y-m-d', shiftUnit:'WEEK', shiftIncrement:5, defaultSpan:6, timeResolution:{unit:'DAY', 
increment:1}, headerConfig:{middle:{unit:'WEEK', align:'center', renderer:function(start, end, cfg) {
  return Ext.Date.format(start, 'd M');
}}, top:{unit:'MONTH', align:'center', dateFormat:'M Y'}}}, monthAndYear:{timeColumnWidth:110, rowHeight:24, resourceColumnWidth:100, displayDateFormat:'Y-m-d', shiftIncrement:3, shiftUnit:'MONTH', defaultSpan:12, timeResolution:{unit:'DAY', increment:1}, headerConfig:{middle:{unit:'MONTH', align:'center', dateFormat:'M Y'}, top:{unit:'YEAR', align:'center', dateFormat:'Y'}}}, year:{timeColumnWidth:100, rowHeight:24, resourceColumnWidth:100, displayDateFormat:'Y-m-d', shiftUnit:'YEAR', shiftIncrement:1, 
defaultSpan:1, timeResolution:{unit:'MONTH', increment:1}, headerConfig:{middle:{unit:'QUARTER', align:'center', renderer:function(start, end, cfg) {
  return Ext.String.format(Sch.util.Date.getShortNameOfUnit('QUARTER').toUpperCase() + '{0}', Math.floor(start.getMonth() / 3) + 1);
}}, top:{unit:'YEAR', align:'center', dateFormat:'Y'}}}, manyYears:{timeColumnWidth:50, rowHeight:24, resourceColumnWidth:100, displayDateFormat:'Y-m-d', shiftUnit:'YEAR', shiftIncrement:1, defaultSpan:1, timeResolution:{unit:'YEAR', increment:1}, headerConfig:{middle:{unit:'YEAR', align:'center', dateFormat:'Y', increment:5}, bottom:{unit:'YEAR', align:'center', dateFormat:'y', increment:1}}}, weekAndDayLetter:{timeColumnWidth:20, rowHeight:24, resourceColumnWidth:100, displayDateFormat:'Y-m-d', 
shiftUnit:'WEEK', shiftIncrement:1, defaultSpan:10, timeResolution:{unit:'DAY', increment:1}, headerConfig:{bottom:{unit:'DAY', align:'center', renderer:function(start) {
  return Ext.Date.dayNames[start.getDay()].substring(0, 1);
}, verticalColumnWidth:25}, middle:{unit:'WEEK', dateFormat:'D d M Y', verticalColumnWidth:115}}}, weekDateAndMonth:{timeColumnWidth:30, rowHeight:24, resourceColumnWidth:100, displayDateFormat:'Y-m-d', shiftUnit:'WEEK', shiftIncrement:1, defaultSpan:10, timeResolution:{unit:'DAY', increment:1}, headerConfig:{middle:{unit:'WEEK', align:'center', dateFormat:'d'}, top:{unit:'MONTH', dateFormat:'Y F'}}}, day:{timeRowHeight:40, displayDateFormat:'G:i', shiftIncrement:1, shiftUnit:'DAY', defaultSpan:1, 
timeResolution:{unit:'MINUTE', increment:30}, columnLinesFor:'bottom', headerConfig:{bottom:{unit:'HOUR', align:'center', renderer:function(value) {
  return Ext.String.format('\x3cdiv class\x3d"sch-calendarcolumn-ct"\x3e\x3cspan class\x3d"sch-calendarcolumn-hours"\x3e{0}\x3c/span\x3e\x3cspan class\x3d"sch-calendarcolumn-minutes"\x3e{1}\x3c/span\x3e\x3c/div\x3e', Ext.Date.format(value, 'H'), Ext.Date.format(value, 'i'));
}}, middle:{unit:'DAY', align:'center', dateFormat:'D d/m', splitUnit:'DAY'}}}, week:{timeRowHeight:40, displayDateFormat:'G:i', shiftIncrement:1, shiftUnit:'WEEK', defaultSpan:24, timeResolution:{unit:'MINUTE', increment:30}, columnLinesFor:'bottom', headerConfig:{bottom:{unit:'HOUR', align:'center', dateFormat:'H:i', renderer:function(value) {
  return Ext.String.format('\x3cdiv class\x3d"sch-calendarcolumn-ct"\x3e\x3cspan class\x3d"sch-calendarcolumn-hours"\x3e{0}\x3c/span\x3e\x3cspan class\x3d"sch-calendarcolumn-minutes"\x3e{1}\x3c/span\x3e\x3c/div\x3e', Ext.Date.format(value, 'H'), Ext.Date.format(value, 'i'));
}}, middle:{unit:'WEEK', align:'center', dateFormat:'D d', splitUnit:'DAY'}}}}, constructor:function() {
  this.callParent(arguments);
  this.registerDefaults();
}, onLocalized:function() {
  var me = this;
  this.eachKey(function(name, preset) {
    if (me.l10n[name]) {
      var locale = me.L(name);
      locale.displayDateFormat && (preset.displayDateFormat = locale.displayDateFormat);
      locale.middleDateFormat && (preset.headerConfig.middle.dateFormat = locale.middleDateFormat);
      locale.topDateFormat && (preset.headerConfig.top.dateFormat = locale.topDateFormat);
      locale.bottomDateFormat && (preset.headerConfig.bottom.dateFormat = locale.bottomDateFormat);
    }
  });
}, registerPreset:function(name, cfg) {
  cfg.name = name;
  var preset = new Sch.preset.ViewPreset(cfg);
  if (preset.isValid()) {
    if (this.containsKey(name)) {
      this.removeAtKey(name);
    }
    this.add(name, preset);
  } else {
    throw 'Invalid preset, please check your configuration';
  }
}, getPreset:function(name) {
  return this.get(name);
}, deletePreset:function(name) {
  this.removeAtKey(name);
}, registerDefaults:function() {
  var pm = this, vp = this.defaultPresets;
  for (var p in vp) {
    pm.registerPreset(p, vp[p]);
  }
}}, 1, 0, 0, 0, 0, [[Sch.mixin.Localizable.prototype.mixinId || Sch.mixin.Localizable.$className, Sch.mixin.Localizable]], [Sch.preset, 'Manager'], 0);
Ext.cmd.derive('Sch.view.model.TimeAxis', Ext.util.Observable, {timeAxis:null, availableWidth:0, tickWidth:100, snapToIncrement:false, forceFit:false, headerConfig:null, headers:null, mainHeader:0, calendar:null, timeAxisColumnWidth:null, resourceColumnWidth:null, weekViewColumnWidth:null, calendarColumnDates:null, headersDatesCache:null, timeColumnWidth:null, rowHeightHorizontal:null, rowHeightVertical:null, mode:'horizontal', suppressFit:false, refCount:0, columnConfig:{}, viewPreset:null, columnLinesFor:'middle', 
eventStore:null, originalTickWidth:null, constructor:function(config) {
  var me = this;
  Ext.apply(this, config);
  me.headersDatesCache = {};
  if (this.viewPreset) {
    if (this.viewPreset instanceof Sch.preset.ViewPreset) {
      this.consumeViewPreset(this.viewPreset);
    } else {
      var preset = Sch.preset.Manager.getPreset(this.viewPreset);
      preset && this.consumeViewPreset(preset);
    }
  }
  me.timeAxis.on('reconfigure', me.onTimeAxisReconfigure, me);
  Ext.util.Observable.prototype.constructor.apply(this, arguments);
}, isHorizontal:function() {
  return this.mode === 'horizontal';
}, isVertical:function() {
  return this.mode === 'vertical';
}, isWeek:function() {
  return this.mode === 'weekview';
}, destroy:function() {
  this.timeAxis.un('reconfigure', this.onTimeAxisReconfigure, this);
}, onTimeAxisReconfigure:function(timeAxis, suppressRefresh) {
  if (!suppressRefresh) {
    this.update();
  }
}, reconfigure:function(config) {
  this.headers = null;
  Ext.apply(this, config);
  var value;
  if (this.isHorizontal()) {
    value = this.timeColumnWidth;
  } else {
    value = this.rowHeightVertical;
  }
  this.setTickWidth(value);
  this.fireEvent('reconfigure', this);
}, getColumnConfig:function() {
  return this.columnConfig;
}, update:function(availableWidth, suppressEvent) {
  var timeAxis = this.timeAxis, headerConfig = this.headerConfig;
  this.availableWidth = Math.max(availableWidth || this.availableWidth, 0);
  if (!Ext.isNumber(this.availableWidth)) {
    throw new Error('Invalid available width provided to Sch.view.model.TimeAxis');
  }
  if (this.forceFit && this.availableWidth <= 0) {
    return;
  }
  this.columnConfig = {};
  for (var pos in headerConfig) {
    if (headerConfig[pos].cellGenerator) {
      this.columnConfig[pos] = headerConfig[pos].cellGenerator.call(this, timeAxis.getStart(), timeAxis.getEnd());
    } else {
      this.columnConfig[pos] = this.createHeaderRow(pos, headerConfig[pos]);
    }
  }
  var tickWidth = this.calculateTickWidth(this.originalTickWidth);
  if (!Ext.isNumber(tickWidth) || tickWidth <= 0) {
    throw new Error('Invalid column width calculated in Sch.view.model.TimeAxis');
  }
  this.updateTickWidth(tickWidth);
  if (!suppressEvent) {
    this.fireEvent('update', this);
  }
}, updateCalendarColumnDates:function(columns) {
  this.calendarColumnDates = [];
  for (var i = 0; i < columns.length; i++) {
    var obj = columns[i];
    this.calendarColumnDates.push([obj.start, obj.end]);
  }
}, getCalendarColumnDates:function() {
  return this.calendarColumnDates;
}, createHeaderRow:function(position, headerConfig) {
  var cells = [], me = this, align = headerConfig.align, today = Ext.Date.clearTime(new Date);
  me.headersDatesCache[position] = {};
  me.forEachInterval(position, function(start, end, i) {
    var colConfig = {align:align, start:start, end:end, headerCls:''};
    me.headersDatesCache[position][start.getTime()] = 1;
    if (headerConfig.renderer) {
      colConfig.header = headerConfig.renderer.call(headerConfig.scope || me, start, end, colConfig, i, me.eventStore);
    } else {
      colConfig.header = Ext.Date.format(start, headerConfig.dateFormat);
    }
    if (headerConfig.unit === Sch.util.Date.DAY && (!headerConfig.increment || headerConfig.increment === 1)) {
      colConfig.headerCls += ' sch-dayheadercell-' + start.getDay();
      if (this.calendar && this.calendar.isWeekend(start)) {
        colConfig.headerCls += ' sch-dayheadercell-nonworking';
      }
      if (Ext.Date.clearTime(start, true) - today === 0) {
        colConfig.headerCls += ' sch-dayheadercell-today';
      }
    }
    cells.push(colConfig);
  });
  return cells;
}, getDistanceBetweenDates:function(start, end) {
  return Math.round(this.getPositionFromDate(end, true) - this.getPositionFromDate(start));
}, getPositionFromDate:function(date, isEnd) {
  var result = -1;
  if (this.isWeek()) {
    var rowHeight = this.rowHeightVertical;
    var headers = this.getHeaders();
    var startDate = this.timeAxis.getStart();
    var UD = Sch.util.Date;
    var verticalDate = UD.mergeDates(startDate, date, headers[1].unit);
    result = UD.getDurationInUnit(startDate, verticalDate, headers[1].unit, true) * rowHeight;
    if (result === 0 && isEnd) {
      result = this.calendarRowsAmount * rowHeight;
    }
  } else {
    var tick = this.timeAxis.getTickFromDate(date);
    if (tick >= 0) {
      result = this.getTickWidth() * (tick - this.timeAxis.visibleTickStart);
    }
  }
  return Math.round(result);
}, getDateFromPosition:function(position, roundingMethod) {
  if (this.isWeek()) {
    var columns = this.getCalendarColumnDates();
    if (!columns) {
      return null;
    }
    var columnIndex = Math.min(Math.floor(Math.max(position[0], 0) / this.weekViewColumnWidth), columns.length - 1), horizontalDate = columns[columnIndex][0], first = this.timeAxis.first(), millisecondsPerPixel = (first.get('end') - first.get('start')) / this.rowHeightVertical, UD = Sch.util.Date, result = UD.add(horizontalDate, UD.MILLI, Math.round(position[1] * millisecondsPerPixel));
    if (roundingMethod) {
      result = this.timeAxis[roundingMethod + 'Date'](result);
    }
    return result;
  } else {
    var tick = position / this.getTickWidth() + this.timeAxis.visibleTickStart, nbrTicks = this.timeAxis.getCount();
    if (tick < 0 || tick > nbrTicks) {
      return null;
    }
    return this.timeAxis.getDateFromTick(tick, roundingMethod);
  }
}, getSingleUnitInPixels:function(unit) {
  return Sch.util.Date.getUnitToBaseUnitRatio(this.timeAxis.getUnit(), unit) * this.getTickWidth() / this.timeAxis.increment;
}, getSnapPixelAmount:function() {
  if (this.snapToIncrement) {
    var resolution = this.timeAxis.getResolution();
    return (resolution.increment || 1) * this.getSingleUnitInPixels(resolution.unit);
  } else {
    return 1;
  }
}, getTickWidth:function() {
  return this.tickWidth;
}, setTickWidth:function(width, suppressEvent) {
  this.originalTickWidth = width;
  this.updateTickWidth(width);
  this.update(null, suppressEvent);
}, updateTickWidth:function(value) {
  this.tickWidth = value;
  this[this.isHorizontal() ? 'timeColumnWidth' : 'rowHeightVertical'] = value;
}, getTotalWidth:function() {
  return Math.round(this.getTickWidth() * this.timeAxis.getVisibleTickTimeSpan());
}, calculateTickWidth:function(proposedWidth) {
  var forceFit = this.forceFit;
  var timeAxis = this.timeAxis;
  var width = 0, timelineUnit = timeAxis.getUnit(), ratio = Number.MAX_VALUE, DATE = Sch.util.Date;
  if (this.snapToIncrement) {
    var resolution = timeAxis.getResolution();
    ratio = DATE.getUnitToBaseUnitRatio(timelineUnit, resolution.unit) * resolution.increment;
  } else {
    var measuringUnit = DATE.getMeasuringUnit(timelineUnit);
    ratio = Math.min(ratio, DATE.getUnitToBaseUnitRatio(timelineUnit, measuringUnit));
  }
  if (!this.suppressFit) {
    var ticks = this.isWeek() ? timeAxis.endTime - timeAxis.startTime : timeAxis.getVisibleTickTimeSpan(), fittingWidth = Math[forceFit ? 'floor' : 'round'](this.getAvailableWidth() / ticks);
    width = forceFit || proposedWidth < fittingWidth ? fittingWidth : proposedWidth;
    if (ratio > 0 && (!forceFit || ratio < 1)) {
      var method = Ext.versions.touch && forceFit ? 'ceil' : forceFit ? 'floor' : 'round';
      width = Math.round(Math.max(1, Math[method](ratio * width)) / ratio);
    }
  } else {
    width = proposedWidth;
  }
  return width;
}, getAvailableWidth:function() {
  return this.availableWidth;
}, setAvailableWidth:function(width) {
  var oldAvailableWidth = this.availableWidth;
  this.availableWidth = Math.max(0, width);
  var newTickWidth = this.calculateTickWidth(this.originalTickWidth);
  var doUpdate = newTickWidth > 0 && (oldAvailableWidth !== width && this.forceFit || newTickWidth !== this.getTickWidth());
  if (doUpdate) {
    this.update();
  }
}, fitToAvailableWidth:function(suppressEvent) {
  var proposedWidth = Math.floor(this.availableWidth / this.timeAxis.getVisibleTickTimeSpan());
  this.setTickWidth(proposedWidth, suppressEvent);
}, setForceFit:function(value) {
  if (value !== this.forceFit) {
    this.forceFit = value;
    this.update();
  }
}, setSnapToIncrement:function(value) {
  if (value !== this.snapToIncrement) {
    this.snapToIncrement = value;
    this.update();
  }
}, getViewRowHeight:function() {
  var val = this.isHorizontal() ? this.rowHeightHorizontal : this.rowHeightVertical;
  if (!val) {
    throw new Error('rowHeight info not available');
  }
  return val;
}, setViewRowHeight:function(value, suppressEvent) {
  var property = 'rowHeight' + Ext.String.capitalize(this.mode);
  if (this[property] != value) {
    this[property] = value;
    if (this.isHorizontal()) {
      if (!suppressEvent) {
        this.fireEvent('update', this);
      }
    } else {
      this.setTickWidth(value, suppressEvent);
    }
  }
}, setViewColumnWidth:function(value, suppressEvent) {
  if (this.isHorizontal()) {
    this.setTickWidth(value, suppressEvent);
  } else {
    if (this.isVertical()) {
      this.resourceColumnWidth = value;
    } else {
      if (this.isWeek()) {
        this.weekViewColumnWidth = value;
      }
    }
  }
  if (!suppressEvent) {
    this.fireEvent('columnwidthchange', this, value);
  }
}, getHeaders:function() {
  if (this.headers) {
    return this.headers;
  }
  var headerConfig = this.headerConfig;
  this.mainHeader = headerConfig.top ? 1 : 0;
  return this.headers = [].concat(headerConfig.top || [], headerConfig.middle || [], headerConfig.bottom || []);
}, getMainHeader:function() {
  return this.getHeaders()[this.mainHeader];
}, getBottomHeader:function() {
  var headers = this.getHeaders();
  return headers[headers.length - 1];
}, getLowestHeader:function() {
  return 'bottom' in this.headerConfig ? 'bottom' : 'middle';
}, getMajorHeaderName:function() {
  var headerConfig = this.headerConfig;
  if (headerConfig.bottom) {
    return 'middle';
  }
  if (headerConfig.top) {
    return 'top';
  }
  return null;
}, isMajorTick:function(date) {
  var nextLevel = this.getMajorHeaderName();
  return nextLevel && this.headersDatesCache[nextLevel] && this.headersDatesCache[nextLevel][date.getTime()] || false;
}, forEachInterval:function(position, iteratorFn, scope) {
  scope = scope || this;
  var headerConfig = this.headerConfig;
  if (!headerConfig) {
    return;
  }
  if (position === 'top' || position === 'middle' && headerConfig.bottom) {
    var header = headerConfig[position];
    this.timeAxis.forEachAuxInterval(header.unit, header.increment, iteratorFn, scope);
  } else {
    this.timeAxis.each(function(r, index) {
      return iteratorFn.call(scope, r.data.start, r.data.end, index);
    });
  }
}, forEachMainInterval:function(iteratorFn, scope) {
  this.forEachInterval('middle', iteratorFn, scope);
}, consumeViewPreset:function(preset) {
  this.headers = null;
  Ext.apply(this, {headerConfig:preset.headerConfig, columnLinesFor:preset.columnLinesFor || 'middle', rowHeightHorizontal:preset.rowHeight, tickWidth:this.isHorizontal() ? preset.timeColumnWidth : preset.timeRowHeight || preset.timeColumnWidth || 60, timeColumnWidth:preset.timeColumnWidth, rowHeightVertical:preset.timeRowHeight || preset.timeColumnWidth || 60, timeAxisColumnWidth:preset.timeAxisColumnWidth, resourceColumnWidth:preset.resourceColumnWidth || 100});
  this.originalTickWidth = this.getTickWidth();
}, setEventStore:function(store) {
  this.eventStore = store;
}, setCalendar:function(cal) {
  if (cal !== this.calendar) {
    this.calendar = cal;
    if (cal) {
      this.update();
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Sch.view.model, 'TimeAxis'], 0);
Ext.cmd.derive('Sch.mixin.Zoomable', Ext.Base, {zoomOnMouseWheel:true, preventScrollZoom:false, zoomLevels:[{width:40, increment:1, resolution:1, preset:'manyYears', resolutionUnit:'YEAR'}, {width:80, increment:1, resolution:1, preset:'manyYears', resolutionUnit:'YEAR'}, {width:30, increment:1, resolution:1, preset:'year', resolutionUnit:'MONTH'}, {width:50, increment:1, resolution:1, preset:'year', resolutionUnit:'MONTH'}, {width:100, increment:1, resolution:1, preset:'year', resolutionUnit:'MONTH'}, 
{width:200, increment:1, resolution:1, preset:'year', resolutionUnit:'MONTH'}, {width:100, increment:1, resolution:7, preset:'monthAndYear', resolutionUnit:'DAY'}, {width:30, increment:1, resolution:1, preset:'weekDateAndMonth', resolutionUnit:'DAY'}, {width:35, increment:1, resolution:1, preset:'weekAndMonth', resolutionUnit:'DAY'}, {width:50, increment:1, resolution:1, preset:'weekAndMonth', resolutionUnit:'DAY'}, {width:20, increment:1, resolution:1, preset:'weekAndDayLetter'}, {width:50, increment:1, 
resolution:1, preset:'weekAndDay', resolutionUnit:'HOUR'}, {width:100, increment:1, resolution:1, preset:'weekAndDay', resolutionUnit:'HOUR'}, {width:50, increment:6, resolution:30, preset:'hourAndDay', resolutionUnit:'MINUTE'}, {width:100, increment:6, resolution:30, preset:'hourAndDay', resolutionUnit:'MINUTE'}, {width:60, increment:2, resolution:30, preset:'hourAndDay', resolutionUnit:'MINUTE'}, {width:60, increment:1, resolution:30, preset:'hourAndDay', resolutionUnit:'MINUTE'}, {width:30, increment:15, 
resolution:5, preset:'minuteAndHour'}, {width:60, increment:15, resolution:5, preset:'minuteAndHour'}, {width:130, increment:15, resolution:5, preset:'minuteAndHour'}, {width:60, increment:5, resolution:5, preset:'minuteAndHour'}, {width:100, increment:5, resolution:5, preset:'minuteAndHour'}, {width:50, increment:2, resolution:1, preset:'minuteAndHour'}, {width:30, increment:10, resolution:5, preset:'secondAndMinute'}, {width:60, increment:10, resolution:5, preset:'secondAndMinute'}, {width:130, 
increment:5, resolution:5, preset:'secondAndMinute'}], minZoomLevel:null, maxZoomLevel:null, visibleZoomFactor:5, zoomKeepsOriginalTimespan:false, initializeZooming:function() {
  this.zoomLevels = this.zoomLevels.slice();
  this.setMinZoomLevel(this.minZoomLevel || 0);
  this.setMaxZoomLevel(this.maxZoomLevel !== null ? this.maxZoomLevel : this.zoomLevels.length - 1);
  this.on('viewready', this.onTimelineReady, this);
}, getZoomLevelUnit:function(zoomLevel) {
  return Sch.preset.Manager.getPreset(zoomLevel.preset).getBottomHeader().unit;
}, getMilliSecondsPerPixelForZoomLevel:function(level, ignoreActualWidth) {
  var DATE = Sch.util.Date;
  return Math.round((DATE.add(new Date(1, 0, 1), this.getZoomLevelUnit(level), level.increment) - new Date(1, 0, 1)) / (ignoreActualWidth ? level.width : level.actualWidth || level.width));
}, presetToZoomLevel:function(presetName) {
  var preset = Sch.preset.Manager.getPreset(presetName);
  return {preset:presetName, increment:preset.getBottomHeader().increment || 1, resolution:preset.timeResolution.increment, resolutionUnit:preset.timeResolution.unit, width:preset.timeColumnWidth};
}, calculateCurrentZoomLevel:function() {
  var zoomLevel = this.presetToZoomLevel(this.viewPreset), min = Number.MAX_VALUE, viewModel = this.timeAxisViewModel, actualWidth = viewModel.timeColumnWidth;
  zoomLevel.width = actualWidth;
  zoomLevel.increment = viewModel.getBottomHeader().increment || 1;
  for (var i = 0, l = this.zoomLevels.length; i < l; i++) {
    var curentLevel = this.zoomLevels[i];
    if (curentLevel.preset !== zoomLevel.preset) {
      continue;
    }
    var delta = Math.abs(curentLevel.width - actualWidth);
    if (delta < min) {
      min = delta;
      zoomLevel.actualWidth = curentLevel.actualWidth;
      zoomLevel.width = curentLevel.width;
    }
  }
  return zoomLevel;
}, getCurrentZoomLevelIndex:function() {
  var currentZoomLevel = this.calculateCurrentZoomLevel();
  var currentFactor = this.getMilliSecondsPerPixelForZoomLevel(currentZoomLevel);
  var zoomLevels = this.zoomLevels;
  for (var i = 0; i < zoomLevels.length; i++) {
    var zoomLevelFactor = this.getMilliSecondsPerPixelForZoomLevel(zoomLevels[i]);
    if (zoomLevelFactor == currentFactor) {
      return i;
    }
    if (i === 0 && currentFactor > zoomLevelFactor) {
      return -0.5;
    }
    if (i == zoomLevels.length - 1 && currentFactor < zoomLevelFactor) {
      return zoomLevels.length - 1 + 0.5;
    }
    var nextLevelFactor = this.getMilliSecondsPerPixelForZoomLevel(zoomLevels[i + 1]);
    if (zoomLevelFactor > currentFactor && currentFactor > nextLevelFactor) {
      return i + 0.5;
    }
  }
  throw new Error("Can't find current zoom level index");
}, setMaxZoomLevel:function(level) {
  if (level < 0 || level >= this.zoomLevels.length) {
    throw new Error('Invalid range for `setMinZoomLevel`');
  }
  this.maxZoomLevel = level;
}, setMinZoomLevel:function(level) {
  if (level < 0 || level >= this.zoomLevels.length) {
    throw new Error('Invalid range for `setMinZoomLevel`');
  }
  this.minZoomLevel = level;
}, zoomToLevel:function(level, span, options) {
  level = Ext.Number.constrain(level, this.minZoomLevel, this.maxZoomLevel);
  options = options || {};
  var currentZoomLevel = this.calculateCurrentZoomLevel();
  var currentFactor = this.getMilliSecondsPerPixelForZoomLevel(currentZoomLevel);
  var nextZoomLevel = this.zoomLevels[level];
  var nextFactor = this.getMilliSecondsPerPixelForZoomLevel(nextZoomLevel);
  if (this.getMode() !== 'horizontal' || currentFactor == nextFactor && !span) {
    return null;
  }
  var me = this;
  me.fireEvent('beforezoomchange', me, level);
  var view = this.getSchedulingView();
  if (!this.rendered) {
    this.on('afterlayout', Ext.Function.bind(this.zoomToLevel, this, [level, span, options]), null, {single:true});
    return;
  }
  var viewEl = view.getOuterEl();
  var isVertical = this.isVertical();
  var centerDate = options.centerDate || (span ? new Date((span.start.getTime() + span.end.getTime()) / 2) : this.getViewportCenterDateCached());
  var panelSize = isVertical ? view.getViewContainerHeight() : viewEl.getWidth();
  var presetCopy = Sch.preset.Manager.getPreset(nextZoomLevel.preset).clone();
  presetCopy.name = nextZoomLevel.preset;
  var bottomHeader = presetCopy.getBottomHeader();
  span = this.calculateOptimalDateRange(centerDate, panelSize, nextZoomLevel, span);
  presetCopy[isVertical ? 'timeRowHeight' : 'timeColumnWidth'] = options.customWidth || nextZoomLevel.width;
  bottomHeader.increment = nextZoomLevel.increment;
  this.isZooming = true;
  presetCopy.increment = nextZoomLevel.increment;
  presetCopy.timeResolution.unit = Sch.util.Date.getUnitByName(nextZoomLevel.resolutionUnit || presetCopy.timeResolution.unit || bottomHeader.unit);
  presetCopy.timeResolution.increment = nextZoomLevel.resolution;
  this.setViewPreset(presetCopy, span.start || this.getStart(), span.end || this.getEnd(), false, {centerDate:centerDate});
  nextZoomLevel.actualWidth = this.timeAxisViewModel.getTickWidth();
  me.isZooming = false;
  me.fireEvent('zoomchange', me, level);
  return level;
}, setZoomLevel:function() {
  this.zoomToLevel.apply(this, arguments);
}, zoomToSpan:function(span, config) {
  var view = this.getSchedulingView();
  config = config || {};
  if (config.leftMargin || config.rightMargin) {
    config.adjustStart = 0;
    config.adjustEnd = 0;
  }
  Ext.applyIf(config, {leftMargin:0, rightMargin:0});
  if (!this.rendered) {
    this.on('afterlayout', Ext.Function.bind(this.zoomToSpan, this, [span, config]), null, {single:true});
    return;
  }
  if (span.start && span.end) {
    var start = span.start, end = span.end, needToAdjust = config.adjustStart >= 0 && config.adjustEnd >= 0;
    if (needToAdjust) {
      start = Sch.util.Date.add(start, this.timeAxis.mainUnit, -config.adjustStart);
      end = Sch.util.Date.add(end, this.timeAxis.mainUnit, config.adjustEnd);
    }
    if (start <= end) {
      var availableWidth = view.getTimeAxisViewModel().getAvailableWidth();
      var currLevel = Math.floor(this.getCurrentZoomLevelIndex());
      if (currLevel == -1) {
        currLevel = 0;
      }
      var zoomLevels = this.zoomLevels;
      var diffMS = end - start || 1, msPerPixel = this.getMilliSecondsPerPixelForZoomLevel(zoomLevels[currLevel], true), inc = diffMS / msPerPixel + config.leftMargin + config.rightMargin > availableWidth ? -1 : 1, candidateLevel = currLevel + inc;
      var zoomLevel, levelToZoom = null;
      while (candidateLevel >= 0 && candidateLevel <= zoomLevels.length - 1) {
        zoomLevel = zoomLevels[candidateLevel];
        msPerPixel = this.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);
        var spanWidth = diffMS / msPerPixel + config.leftMargin + config.rightMargin;
        if (inc == -1) {
          if (spanWidth <= availableWidth) {
            levelToZoom = candidateLevel;
            break;
          }
        } else {
          if (spanWidth <= availableWidth) {
            if (currLevel !== candidateLevel - inc) {
              levelToZoom = candidateLevel;
            }
          } else {
            break;
          }
        }
        candidateLevel += inc;
      }
      levelToZoom = levelToZoom !== null ? levelToZoom : candidateLevel - inc;
      zoomLevel = zoomLevels[levelToZoom];
      var unitToZoom = Sch.preset.Manager.getPreset(zoomLevel.preset).getBottomHeader().unit;
      if (config.leftMargin || config.rightMargin) {
        start = new Date(start.getTime() - msPerPixel * config.leftMargin);
        end = new Date(end.getTime() + msPerPixel * config.rightMargin);
      }
      var columnCount = Sch.util.Date.getDurationInUnit(start, end, unitToZoom, true) / zoomLevel.increment;
      if (columnCount === 0) {
        return;
      }
      var customWidth = Math.floor(availableWidth / columnCount);
      var centerDate = new Date((start.getTime() + end.getTime()) / 2);
      var range;
      if (needToAdjust) {
        range = {start:start, end:end};
      } else {
        range = this.calculateOptimalDateRange(centerDate, availableWidth, zoomLevel);
      }
      return this.zoomToLevel(levelToZoom, range, {customWidth:customWidth, centerDate:centerDate});
    }
  }
  return null;
}, zoomIn:function(levels) {
  levels = levels || 1;
  var currentZoomLevelIndex = this.getCurrentZoomLevelIndex();
  if (currentZoomLevelIndex >= this.zoomLevels.length - 1) {
    return null;
  }
  return this.zoomToLevel(Math.floor(currentZoomLevelIndex) + levels);
}, zoomOut:function(levels) {
  levels = levels || 1;
  var currentZoomLevelIndex = this.getCurrentZoomLevelIndex();
  if (currentZoomLevelIndex <= 0) {
    return null;
  }
  return this.zoomToLevel(Math.ceil(currentZoomLevelIndex) - levels);
}, zoomInFull:function() {
  return this.zoomToLevel(this.maxZoomLevel);
}, zoomOutFull:function() {
  return this.zoomToLevel(this.minZoomLevel);
}, calculateOptimalDateRange:function(centerDate, panelSize, zoomLevel, userProvidedSpan) {
  if (userProvidedSpan) {
    return userProvidedSpan;
  }
  var timeAxis = this.timeAxis;
  if (this.zoomKeepsOriginalTimespan) {
    return {start:timeAxis.getStart(), end:timeAxis.getEnd()};
  }
  var schDate = Sch.util.Date;
  var unit = this.getZoomLevelUnit(zoomLevel);
  var difference = Math.ceil(panelSize / zoomLevel.width * zoomLevel.increment * this.visibleZoomFactor / 2);
  var startDate = schDate.add(centerDate, unit, -difference);
  var endDate = schDate.add(centerDate, unit, difference);
  return {start:timeAxis.floorDate(startDate, false, unit, zoomLevel.increment), end:timeAxis.ceilDate(endDate, false, unit, zoomLevel.increment)};
}, onTimelineReady:function() {
  if (this.zoomOnMouseWheel) {
    this.getSchedulingView().getEl().on('wheel', this.onWheel, this, {capture:true});
    this.on('destroy', function() {
      clearTimeout(this.scrollWheelBlockTimeout);
    });
  }
}, onWheel:function(e) {
  var me = this;
  if (e.ctrlKey) {
    e.preventDefault();
    if (!me.preventScrollZoom) {
      if (e.browserEvent.deltaY > 0) {
        me.zoomOut();
      } else {
        if (e.browserEvent.deltaY < 0) {
          me.zoomIn();
        }
      }
      me.preventScrollZoom = true;
      me.scrollWheelBlockTimeout = setTimeout(function() {
        me.preventScrollZoom = false;
      }, 30);
    }
  }
}}, 0, 0, 0, 0, 0, 0, [Sch.mixin, 'Zoomable'], 0);
Ext.cmd.derive('Sch.mixin.AbstractTimelinePanel', Ext.Base, {snapToIncrement:false, readOnly:false, forceFit:false, eventResizeHandles:'both', timeAxis:null, autoAdjustTimeAxis:true, timeAxisViewModel:null, crudManager:null, viewPreset:'weekAndDay', trackHeaderOver:true, startDate:null, endDate:null, startTime:0, endTime:24, columnLines:true, getDateConstraints:Ext.emptyFn, snapRelativeToEventStartDate:false, trackMouseOver:false, readRowHeightFromPreset:true, eventBorderWidth:1, cachedCenterDate:null, 
cellBorderWidth:1, cellTopBorderWidth:0, cellBottomBorderWidth:0, renderers:null, getMode:function() {
  return this.mode;
}, isHorizontal:function() {
  return this.getMode() === 'horizontal';
}, isVertical:function() {
  return this.getMode() === 'vertical';
}, isWeekView:function() {
  return this.getMode() === 'weekview';
}, _initializeTimelinePanel:function() {
  if (this.mode) {
    if (this.mode === 'calendar') {
      this.mode = 'weekview';
    }
  } else {
    this.mode = 'horizontal';
  }
  this.applyViewPreset(this.viewPreset);
  if (this.isWeekView()) {
    if (!this.viewPreset.headerConfig.middle.splitUnit) {
      this._oldViewPresetArgs = [this.viewPreset];
      this.viewPreset = this.calendarViewPreset || 'week';
    }
  }
  this.initializeZooming();
  this.on('viewchange', this.clearCenterDateCache, this);
  this.on('viewready', this.setupClearCenterDateCache, this);
  this.renderers = [];
  if (this.readRowHeightFromPreset) {
    this.readRowHeightFromPreset = !this.rowHeight;
  }
  if (!(this.timeAxis instanceof Sch.data.TimeAxis)) {
    this.timeAxis = Ext.create(Ext.applyIf(this.timeAxis || {}, {xclass:'Sch.data.TimeAxis', autoAdjust:this.autoAdjustTimeAxis, mode:this.isWeekView() ? 'week' : 'plain'}));
  }
  if (!(this.timeAxisViewModel instanceof Sch.view.model.TimeAxis)) {
    this.timeAxisViewModel = Ext.create(Ext.applyIf(this.timeAxisViewModel || {}, {xclass:'Sch.view.model.TimeAxis', mode:this.mode, snapToIncrement:this.snapToIncrement, forceFit:this.forceFit, timeAxis:this.timeAxis, eventStore:this.getEventStore(), viewPreset:this.viewPreset}));
  }
  if (this.rowHeight) {
    this.setRowHeight(this.rowHeight, true);
    this.rowHeight = null;
  }
  this.timeAxisViewModel.on('update', this.onTimeAxisViewModelUpdate, this);
  this.timeAxisViewModel.refCount++;
  this.on('destroy', this.onPanelDestroyed, this);
  var orientationClasses;
  if (this.isHorizontal()) {
    orientationClasses = ['sch-horizontal'];
  } else {
    if (this.isVertical()) {
      orientationClasses = ['sch-vertical', 'sch-vertical-resource'];
    } else {
      if (this.isWeekView()) {
        orientationClasses = ['sch-vertical', 'sch-calendar'];
      }
    }
  }
  this.addCls([].concat.apply(['sch-timelinepanel'], orientationClasses));
}, applyViewPreset:function(preset) {
  var viewPreset;
  if (Ext.isString(preset)) {
    viewPreset = Sch.preset.Manager.getPreset(preset);
    if (!viewPreset) {
      throw 'You must define a valid view preset object. See Sch.preset.Manager class for reference';
    }
  } else {
    if (Ext.isObject(preset)) {
      var registeredPreset = preset.name && Sch.preset.Manager.getPreset(preset.name);
      if (registeredPreset) {
        viewPreset = new Sch.preset.ViewPreset(Ext.applyIf(preset, registeredPreset));
      } else {
        var name = preset.name || 'preset' + Sch.preset.Manager.getCount();
        Sch.preset.Manager.registerPreset(name, preset);
        viewPreset = Sch.preset.Manager.getPreset(name);
      }
    }
  }
  this.viewPreset = viewPreset;
}, onTimeAxisViewModelUpdate:function() {
  var view = this.getSchedulingView();
  if (view && view.viewReady) {
    view.refreshKeepingScroll();
  }
  this.fireEvent('viewchange', this);
}, onPanelDestroyed:function() {
  var timeAxisViewModel = this.timeAxisViewModel;
  timeAxisViewModel.un('update', this.onTimeAxisViewModelUpdate, this);
  timeAxisViewModel.refCount--;
  if (timeAxisViewModel.refCount <= 0) {
    timeAxisViewModel.destroy();
  }
}, getSchedulingView:function() {
  throw 'Abstract method call';
}, setReadOnly:function(readOnly) {
  this.getSchedulingView().setReadOnly(readOnly);
}, isReadOnly:function() {
  return this.getSchedulingView().isReadOnly();
}, setupClearCenterDateCache:function() {
  this.mon(this.getSchedulingView().getScrollable(), 'scroll', this.clearCenterDateCache, this);
}, getViewportCenterDateCached:function() {
  if (this.cachedCenterDate) {
    return this.cachedCenterDate;
  }
  return this.cachedCenterDate = this.getViewportCenterDate();
}, clearCenterDateCache:function(scrollable, left, top) {
  var isHorizontal = this.isHorizontal(), activeScroll = this.viewPresetActiveScroll;
  var scrollToIgnore = activeScroll && (isHorizontal ? left === activeScroll.left : top == activeScroll.top);
  if (!scrollToIgnore) {
    this.cachedCenterDate = null;
    this.viewPresetActiveScroll = null;
  }
}, switchViewPreset:function() {
  this.setViewPreset.apply(this, arguments);
}, setViewPreset:function(preset, startDate, endDate, initial, options) {
  options = options || {};
  var centerDate = options.centerDate, timeAxis = this.timeAxis, view = this.getSchedulingView();
  if (typeof preset === 'string') {
    preset = Sch.preset.Manager.getPreset(preset);
  }
  if (!preset) {
    throw new Error('View preset not found');
  }
  if (this.fireEvent('beforeviewchange', this, preset, startDate, endDate) !== false) {
    this.viewPreset = preset.name;
    var isHorizontal = this.isHorizontal(), isVertical = this.isVertical();
    view.setDisplayDateFormat(preset.displayDateFormat);
    if (!(initial && timeAxis.isConfigured)) {
      var timeAxisCfg = {weekStartDay:this.weekStartDay !== undefined ? this.weekStartDay : this.L ? this.L('weekStartDay') : 1, startTime:this.startTime, endTime:this.endTime};
      if (initial || !this.rendered) {
        if (timeAxis.getCount() === 0 || startDate) {
          timeAxisCfg.start = startDate || new Date;
          timeAxisCfg.end = endDate;
        }
      } else {
        if (startDate) {
          timeAxisCfg.start = startDate;
          timeAxisCfg.end = endDate;
          if (!centerDate && endDate) {
            if (this.infiniteScroll && view.cachedScrollDate && view.cachedScrollDateIsCentered) {
              centerDate = view.cachedScrollDate;
            } else {
              centerDate = new Date((startDate.getTime() + endDate.getTime()) / 2);
            }
          }
        } else {
          timeAxisCfg.start = timeAxis.getStart();
          timeAxisCfg.end = endDate || timeAxis.getEnd();
          if (!centerDate) {
            if (this.infiniteScroll && view.cachedScrollDate && view.cachedScrollDateIsCentered) {
              centerDate = view.cachedScrollDate;
            } else {
              centerDate = this.getViewportCenterDateCached();
            }
          }
        }
      }
      timeAxis.consumeViewPreset(preset);
      timeAxis.reconfigure(timeAxisCfg, true);
      this.timeAxisViewModel.reconfigure({viewPreset:this.viewPreset, headerConfig:preset.headerConfig, columnLinesFor:preset.columnLinesFor || 'middle', rowHeightHorizontal:this.readRowHeightFromPreset ? preset.rowHeight : this.timeAxisViewModel.getViewRowHeight(), tickWidth:isHorizontal ? preset.timeColumnWidth : preset.timeRowHeight || preset.timeColumnWidth || 60, timeColumnWidth:preset.timeColumnWidth, rowHeightVertical:preset.timeRowHeight || preset.timeColumnWidth || 60, timeAxisColumnWidth:preset.timeAxisColumnWidth, 
      resourceColumnWidth:this.resourceColumnWidth || preset.resourceColumnWidth || 100});
    }
    if (isVertical) {
      view.setColumnWidth(this.resourceColumnWidth || preset.resourceColumnWidth || 100, true);
    }
    var viewEl = view.getOuterEl();
    if (!options.notScroll && viewEl && this.getView().el) {
      if (centerDate) {
        this.cachedCenterDate = centerDate;
        var x = null, y = null;
        if (isVertical) {
          y = Math.max(Math.floor(view.getCoordinateFromDate(centerDate, true) - view.getViewContainerHeight() / 2), 0);
          this.viewPresetActiveScroll = {top:y};
          view.scrollVerticallyTo(y);
        } else {
          x = Math.max(Math.floor(view.getCoordinateFromDate(centerDate, true) - viewEl.getWidth() / 2), 0);
          this.viewPresetActiveScroll = {left:x};
          if (Ext.getVersion().isGreaterThan('6.2.0')) {
            var normalScroller = view.up('timelinegrid,timelinetree').normalScrollbarScroller;
            normalScroller && normalScroller.scrollTo(x);
          }
          view.headerCt.scrollTo(x);
          view.scrollTo(x);
        }
      } else {
        if (isHorizontal) {
          view.scrollHorizontallyTo(0);
        } else {
          view.scrollVerticallyTo(0);
        }
      }
    }
  }
}, getViewPreset:function() {
  return this.viewPreset;
}, getStart:function() {
  return this.getStartDate();
}, getStartDate:function() {
  return this.timeAxis.getStart();
}, getEnd:function() {
  return this.getEndDate();
}, getEndDate:function() {
  return this.timeAxis.getEnd();
}, setTimeColumnWidth:function(width, preventRefresh) {
  this.timeAxisViewModel.setTickWidth(width, preventRefresh);
}, getTimeColumnWidth:function() {
  return this.timeAxisViewModel.getTickWidth();
}, getRowHeight:function() {
  return this.timeAxisViewModel.getViewRowHeight();
}, shiftNext:function(amount) {
  this.suspendLayouts && this.suspendLayouts();
  this.timeAxis.shiftNext(amount);
  this.suspendLayouts && this.resumeLayouts(true);
}, shiftPrevious:function(amount) {
  this.suspendLayouts && this.suspendLayouts();
  this.timeAxis.shiftPrevious(amount);
  this.suspendLayouts && this.resumeLayouts(true);
}, goToNow:function() {
  this.setTimeSpan(new Date);
}, setTimeSpan:function(start, end) {
  if (this.timeAxis) {
    this.timeAxis.setTimeSpan(start, end);
  }
}, setStart:function(date) {
  this.setStartDate(date);
}, setEnd:function(date) {
  this.setEndDate(date);
}, setStartDate:function(date) {
  this.setTimeSpan(date);
}, setEndDate:function(date) {
  this.setTimeSpan(null, date);
}, getTimeAxis:function() {
  return this.timeAxis;
}, scrollToDate:function(date, animate, offset) {
  var view = this.getSchedulingView();
  var coordinate = view.getCoordinateFromDate(date, true);
  this.scrollToCoordinate(coordinate, date, animate, false, offset);
}, scrollToDateCentered:function(date, animate) {
  var view = this.getSchedulingView();
  var delta = 0;
  if (view.isHorizontal()) {
    delta = view.getBox().width / 2;
  } else {
    delta = view.getBox().height / 2;
  }
  var coordinate = Math.round(view.getCoordinateFromDate(date, true) - delta);
  this.scrollToCoordinate(coordinate, date, animate, true);
}, scrollToCoordinate:function(coordinate, date, animate, centered, offsetFromViewportStart) {
  var view = this.getSchedulingView();
  var me = this;
  offsetFromViewportStart = offsetFromViewportStart || 0;
  if (coordinate < 0 && !view.isWeekView()) {
    if (this.infiniteScroll) {
      view.shiftToDate(date, centered);
    } else {
      var halfVisibleSpan = (this.timeAxis.getEnd() - this.timeAxis.getStart()) / 2;
      var newStartDate = new Date(date.getTime() - halfVisibleSpan);
      var newEndDate = new Date(date.getTime() + halfVisibleSpan);
      if (newStartDate - this.getStart() !== 0 && newEndDate - this.getEnd() !== 0) {
        this.setTimeSpan(newStartDate, newEndDate);
        if (centered) {
          me.scrollToDateCentered(date, animate);
        } else {
          me.scrollToDate(date, animate, offsetFromViewportStart);
        }
      }
    }
    return;
  }
  if (this.isHorizontal()) {
    view.scrollHorizontallyTo(coordinate - offsetFromViewportStart, animate);
  } else {
    view.scrollVerticallyTo(coordinate - offsetFromViewportStart, animate);
  }
}, getViewportCenterDate:function() {
  return this.getSchedulingView().getViewportCenterDate();
}, addCls:function() {
  throw 'Abstract method call';
}, removeCls:function() {
  throw 'Abstract method call';
}, registerRenderer:function(fn, scope) {
  this.renderers.push({fn:fn, scope:scope});
}, deregisterRenderer:function(fn, scope) {
  Ext.each(this.renderers, function(rend, i) {
    if (fn === rend) {
      Ext.Array.removeAt(this.renderers, i);
      return false;
    }
  });
}, getCrudManager:function() {
  return this.crudManager;
}, setCrudManager:function(cm) {
  this.crudManager = cm;
}}, 0, 0, 0, 0, 0, [[Sch.mixin.Zoomable.prototype.mixinId || Sch.mixin.Zoomable.$className, Sch.mixin.Zoomable]], [Sch.mixin, 'AbstractTimelinePanel'], 0);
Ext.cmd.derive('Sch.view.Horizontal', Ext.Base, {view:null, constructor:function(config) {
  Ext.apply(this, config);
}, getElementsFromEventRecord:function(eventRecord, resourceRecord, index, raw) {
  var view = this.view, query;
  raw = raw || false;
  if (resourceRecord) {
    query = '[id^\x3d' + view.eventPrefix + eventRecord.internalId + '-' + resourceRecord.internalId + '-]';
  } else {
    query = '[id^\x3d' + view.eventPrefix + eventRecord.internalId + '-]';
  }
  return view.getEl().query(query, raw);
}, translateToScheduleCoordinate:function(x) {
  var view = this.view;
  var pos;
  if (view.shouldAdjustForRtl()) {
    pos = view.getEl().getRight() - x;
  } else {
    pos = x - view.getEl().getX();
  }
  return pos + view.getScroll().left;
}, translateToPageCoordinate:function(x) {
  var view = this.view;
  return x + view.getEl().getX() - view.getScroll().left;
}, getDateFromXY:function(xy, roundingMethod, local) {
  var coord = xy[0];
  if (!local) {
    coord = this.translateToScheduleCoordinate(coord);
  }
  return this.view.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
}, getEventRenderData:function(event) {
  var eventStart = event.getStartDate(), eventEnd = event.getEndDate() || eventStart, view = this.view, viewStart = view.timeAxis.getStart(), viewEnd = view.timeAxis.getEnd(), M = Math, startX = view.getCoordinateFromDate(Sch.util.Date.max(eventStart, viewStart)), endX = view.getCoordinateFromDate(Sch.util.Date.min(eventEnd, viewEnd)), data = {event:event};
  if (this.view.rtl) {
    data.right = M.min(startX, endX);
  } else {
    data.left = M.min(startX, endX);
  }
  data.width = M.max(1, M.abs(endX - startX)) - view.eventBorderWidth;
  if (view.managedEventSizing) {
    data.top = M.max(0, view.barMargin - view.eventBorderWidth + view.cellTopBorderWidth);
    data.height = view.timeAxisViewModel.rowHeightHorizontal - 2 * view.barMargin - view.eventBorderWidth;
  }
  data.start = eventStart;
  data.end = eventEnd;
  data.startsOutsideView = eventStart < viewStart;
  data.endsOutsideView = eventEnd > viewEnd;
  return data;
}, getScheduleRegion:function(resourceRecord, eventRecord) {
  var view = this.view, region;
  if (resourceRecord) {
    var eventEl = eventRecord && view.getElementsFromEventRecord(eventRecord, resourceRecord)[0];
    region = Ext.fly(view.getRowNode(resourceRecord)).getRegion();
    if (eventEl) {
      var eventRegion = eventEl.getRegion();
      region.top = eventRegion.top;
      region.bottom = eventRegion.bottom;
    } else {
      region.top = region.top + view.barMargin;
      region.bottom = region.bottom - view.barMargin - view.eventBorderWidth;
    }
  } else {
    region = view.getTableRegion();
    region.top = region.top + view.barMargin;
    region.bottom = region.bottom - view.barMargin - view.eventBorderWidth;
  }
  var taStart = view.timeAxis.getStart(), taEnd = view.timeAxis.getEnd(), dateConstraints = view.getDateConstraints(resourceRecord, eventRecord) || {start:taStart, end:taEnd}, startX = this.translateToPageCoordinate(view.getCoordinateFromDate(Sch.util.Date.max(taStart, dateConstraints.start))), endX = this.translateToPageCoordinate(view.getCoordinateFromDate(Sch.util.Date.min(taEnd, dateConstraints.end))), top = region.top, bottom = region.bottom;
  return new Ext.util.Region(top, Math.max(startX, endX), bottom, Math.min(startX, endX));
}, getResourceRegion:function(resourceRecord, startDate, endDate) {
  var view = this.view, rowNode = view.getRowNode(resourceRecord), offsets = Ext.fly(rowNode).getOffsetsTo(view.getEl()), taStart = view.timeAxis.getStart(), taEnd = view.timeAxis.getEnd(), start = startDate ? Sch.util.Date.max(taStart, startDate) : taStart, end = endDate ? Sch.util.Date.min(taEnd, endDate) : taEnd, startX = view.getCoordinateFromDate(start), endX = view.getCoordinateFromDate(end), top = offsets[1] + view.cellTopBorderWidth, bottom = offsets[1] + Ext.fly(rowNode).getHeight() - view.cellBottomBorderWidth;
  if (!Ext.versions.touch) {
    var ctElScroll = view.getScroll();
    top += ctElScroll.top;
    bottom += ctElScroll.top;
  }
  return new Ext.util.Region(top, Math.max(startX, endX), bottom, Math.min(startX, endX));
}, columnRenderer:function(val, meta, resourceRecord, rowIndex, colIndex) {
  var view = this.view;
  var resourceEvents = view.getEventStore().filterEventsForResource(resourceRecord, function(event) {
    return view.timeAxis.isRangeInAxis(event);
  });
  if (resourceEvents.length === 0) {
    return;
  }
  var eventsTplData = Ext.Array.map(resourceEvents, function(event) {
    return view.generateTplData(event, resourceRecord, rowIndex);
  });
  if (view.rowHasDynamicRowHeight(resourceRecord)) {
    var layout = view.eventLayout.horizontal;
    var nbrOfBandsRequired = layout.applyLayout(eventsTplData, resourceRecord, this.layoutEventVertically, this);
    meta.rowHeight = nbrOfBandsRequired * view.timeAxisViewModel.rowHeightHorizontal - (nbrOfBandsRequired - 1) * view.barMargin;
  }
  return view.eventTpl.apply(eventsTplData);
}, layoutEventVertically:function(bandIndex, eventRecord) {
  var view = this.view;
  var eventTop = bandIndex === 0 ? view.barMargin : bandIndex * view.timeAxisViewModel.rowHeightHorizontal - (bandIndex - 1) * view.barMargin;
  eventTop += view.cellTopBorderWidth;
  return eventTop;
}, resolveResource:function(node) {
  var me = this, view = me.view, eventNode, result;
  eventNode = Ext.fly(node).is(view.eventSelector) && node || Ext.fly(node).up(view.eventSelector, null, true);
  if (eventNode) {
    result = view.getResourceRecordFromDomId(eventNode.id);
  } else {
    node = view.findRowByChild(node);
    result = node && view.getRecordForRowNode(node) || null;
  }
  return result;
}, getTimeSpanRegion:function(startDate, endDate, useViewSize) {
  var view = this.view, startX = view.getCoordinateFromDate(startDate), endX = endDate ? view.getCoordinateFromDate(endDate) : startX, height, region;
  region = view.getTableRegion();
  if (useViewSize) {
    height = Math.max(region ? region.bottom - region.top : 0, view.getEl().dom.clientHeight);
  } else {
    height = region ? region.bottom - region.top : 0;
  }
  return new Ext.util.Region(0, Math.max(startX, endX), height, Math.min(startX, endX));
}, getStartEndDatesFromRegion:function(region, roundingMethod) {
  var view = this.view;
  var leftDate = view.getDateFromCoordinate(region.left, roundingMethod), rightDate = view.getDateFromCoordinate(region.right, roundingMethod);
  if (leftDate && rightDate) {
    return {start:Sch.util.Date.min(leftDate, rightDate), end:Sch.util.Date.max(leftDate, rightDate)};
  }
  return null;
}, onEventAdd:function(s, events) {
  var view = this.view, affectedResources = {}, event, startDate, endDate, resources, resource, i, l, j, k;
  for (i = 0, l = events.length; i < l; i++) {
    event = events[i];
    startDate = event.getStartDate();
    endDate = event.getEndDate();
    if (startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate)) {
      resources = events[i].getResources(view.getEventStore());
      for (j = 0, k = resources.length; j < k; j++) {
        resource = resources[j];
        affectedResources[resource.getId()] = resource;
      }
    }
  }
  Ext.Object.each(affectedResources, function(id, resource) {
    view.repaintEventsForResource(resource);
  });
}, onEventRemove:function(s, eventRecords) {
  var me = this, view = me.view, eventStore = view.getEventStore(), resources, nodes;
  resources = Ext.Array.unique(Ext.Array.reduce(eventRecords, function(result, r) {
    return result.concat(eventStore.getResourcesForEvent(r));
  }, []));
  nodes = Ext.Array.reduce(eventRecords, function(result, r) {
    return result.concat(view.getElementsFromEventRecord(r, null, null, true));
  }, []);
  nodes = new Ext.CompositeElementLite(nodes);
  nodes.fadeOut({callback:function(resource) {
    Ext.Array.forEach(resources, function(resource) {
      if (view && !view.isDestroyed) {
        view.store.indexOf(resource) >= 0 && view.repaintEventsForResource(resource);
      }
    });
  }});
}, onEventUpdate:function(eventStore, model) {
  var previous = model.previous || {};
  var view = this.view;
  var timeAxis = view.timeAxis;
  var newStartDate = model.getStartDate();
  var newEndDate = model.getEndDate();
  var startDate = previous.StartDate || newStartDate;
  var endDate = previous.EndDate || newEndDate;
  var eventWasInView = startDate && endDate && timeAxis.timeSpanInAxis(startDate, endDate);
  var resource;
  if (model.resourceIdField in previous && eventWasInView) {
    resource = eventStore.getResourceStore().getById(previous[model.resourceIdField]);
    resource && view.repaintEventsForResource(resource, true);
  }
  if (newStartDate && newEndDate && timeAxis.timeSpanInAxis(newStartDate, newEndDate) || eventWasInView) {
    Ext.Array.each(model.getResources(), function(resource) {
      view.repaintEventsForResource(resource, true);
    });
  }
}, setColumnWidth:function(width, preventRefresh) {
  var view = this.view;
  view.getTimeAxisViewModel().setViewColumnWidth(width, preventRefresh);
}, getVisibleDateRange:function() {
  var view = this.view;
  if (!view.getEl()) {
    return null;
  }
  var tableRegion = view.getTableRegion(), startDate = view.timeAxis.getStart(), endDate = view.timeAxis.getEnd(), width = view.getWidth();
  if (tableRegion.right - tableRegion.left < width) {
    return {startDate:startDate, endDate:endDate};
  }
  var scroll = view.getScroll();
  var result = {startDate:view.getDateFromCoordinate(scroll.left, null, true), endDate:view.getDateFromCoordinate(scroll.left + width, null, true) || view.timeAxis.getEnd()};
  if (!result.endDate) {
    result.endDate = view.timeAxis.getEnd();
  }
  return result;
}, getItemBox:function(eventRecord) {
  var me = this;
  return Ext.Array.map(eventRecord.getResources(), function(resourceRecord) {
    return me.getResourceEventBox(eventRecord, resourceRecord);
  });
}, isRowVisible:function(resourceRecord) {
  var hidden = Ext.isFunction(resourceRecord.isVisible) && !resourceRecord.isVisible();
  if (!hidden && this.view.groupingFeature && !this.view.groupingFeature.disabled) {
    var groups = this.view.resourceStore.getGroups();
    if (groups) {
      var group = groups.getByKey(resourceRecord.get(this.view.resourceStore.groupField));
      hidden = group && !this.view.lockingPartner.groupingFeature.isExpanded(group);
    }
  }
  return !hidden;
}, isElementRenderedAndDisplayed:function(resourceRecordOrRowEl) {
  if (resourceRecordOrRowEl && resourceRecordOrRowEl.isResourceModel) {
    resourceRecordOrRowEl = this.view.getRowNode(resourceRecordOrRowEl);
  }
  return !!(resourceRecordOrRowEl && Ext.fly(resourceRecordOrRowEl).getHeight());
}, getResultEventBox:function(renderData, rowTop) {
  return {rendered:true, start:renderData.hasOwnProperty('left') ? renderData.left : renderData.right, end:(renderData.hasOwnProperty('left') ? renderData.left : renderData.right) + renderData.width, top:rowTop + renderData.top, bottom:rowTop + renderData.top + renderData.height};
}, getResourceEventBox:function(eventRecord, resourceRecord) {
  var SUD = Sch.util.Date, me = this, result = null, view = me.view, viewStartDate = view.timeAxis.getStart(), viewEndDate = view.timeAxis.getEnd(), eventStartDate = eventRecord.getStartDate(), eventEndDate = eventRecord.getEndDate(), eventLayout, rowEventsLayoutData, eventRecordData, rowEl, rowIndex, rowTop, rowHeight, rowNbrOfBands, eventEls, eventEl, eventElOffsets, eventElBox, firstRowIndex, firstRowRecord, lastRowIndex, lastRowRecord, lastRowEl;
  if (eventStartDate && eventEndDate && SUD.intersectSpans(eventStartDate, eventEndDate, viewStartDate, viewEndDate) && me.isRowVisible(resourceRecord)) {
    rowEl = view.getRowNode(resourceRecord);
    if (rowEl && me.isElementRenderedAndDisplayed(rowEl)) {
      if (view.managedEventSizing) {
        eventLayout = view.eventLayout.horizontal;
        var resourceEvents = view.getEventStore().filterEventsForResource(resourceRecord, view.timeAxis.isRangeInAxis, view.timeAxis);
        rowEventsLayoutData = Ext.Array.map(resourceEvents, me.getEventRenderData, me);
        eventLayout.applyLayout(rowEventsLayoutData, resourceRecord);
        eventRecordData = Ext.Array.findBy(rowEventsLayoutData, function(eventData) {
          return eventData.event == eventRecord;
        });
        if (eventRecordData) {
          rowTop = Ext.fly(rowEl).getOffsetsTo(view.getNodeContainer())[1];
          result = this.getResultEventBox(eventRecordData, rowTop);
        }
      } else {
        eventEls = view.getElementsFromEventRecord(eventRecord, eventRecord !== resourceRecord && resourceRecord);
        if (eventEls.length) {
          eventEl = eventEls[0];
          eventElOffsets = eventEl.getOffsetsTo(view.getEl());
          eventElBox = eventEl.getBox();
          result = {rendered:true, start:eventElOffsets[0], end:eventElOffsets[0] + eventElBox.width, top:eventElOffsets[1], bottom:eventElOffsets[1] + eventElBox.height};
        }
      }
    } else {
      result = {rendered:false, start:view.getCoordinateFromDate(SUD.max(eventStartDate, viewStartDate)), end:view.getCoordinateFromDate(SUD.min(eventEndDate, viewEndDate))};
      firstRowIndex = view.all.startIndex;
      firstRowRecord = view.getRecord(firstRowIndex);
      lastRowIndex = view.all.endIndex;
      lastRowRecord = view.getRecord(lastRowIndex);
      rowHeight = view.getRowHeight();
      if (resourceRecord.isAbove(firstRowRecord)) {
        result.top = -rowHeight;
        result.bottom = result.top + rowHeight;
        result.relPos = 'before';
      } else {
        if (resourceRecord == lastRowRecord || resourceRecord.isAbove(lastRowRecord)) {
          rowIndex = view.indexOf(resourceRecord);
          result.top = rowIndex * rowHeight;
          result.bottom = result.top + rowHeight;
        } else {
          lastRowEl = view.getNode(lastRowIndex);
          if (me.isElementRenderedAndDisplayed(lastRowEl)) {
            result.top = Ext.fly(lastRowEl).getOffsetsTo(view.getNodeContainer())[1] + Ext.fly(lastRowEl).getHeight();
          } else {
            result.top = (lastRowIndex + 1) * rowHeight;
          }
          result.bottom = result.top + rowHeight;
          result.relPos = 'after';
        }
      }
    }
    if (result) {
      result = me.adjustItemBox(eventRecord, result);
    }
  }
  return result;
}, adjustItemBox:function(eventRecord, eventRecordBox) {
  return eventRecordBox;
}, getConnectorStartSide:function(eventRecord) {
  return 'left';
}, getConnectorEndSide:function(eventRecord) {
  return 'right';
}}, 1, 0, 0, 0, 0, 0, [Sch.view, 'Horizontal'], 0);
Ext.cmd.derive('Sch.mixin.AbstractTimelineView', Ext.Base, {selectedEventCls:'sch-event-selected', readOnly:false, horizontalViewClass:'Sch.view.Horizontal', timeCellCls:'sch-timetd', timeCellSelector:'.sch-timetd', eventBorderWidth:1, timeAxis:null, timeAxisViewModel:null, eventPrefix:null, rowHeight:null, mode:'horizontal', horizontal:null, vertical:null, panel:null, displayDateFormat:null, el:null, _initializeTimelineView:function() {
  if (this.horizontalViewClass) {
    this.horizontal = Ext.create(this.horizontalViewClass, {view:this});
  }
  if (this.verticalViewClass) {
    this.vertical = Ext.create(this.verticalViewClass, {view:this});
  }
  if (this.weekViewClass) {
    this.weekview = Ext.create(this.weekViewClass, {view:this});
  }
  this.eventPrefix = (this.eventPrefix || this.getId()) + '-';
}, getTimeAxisViewModel:function() {
  return this.timeAxisViewModel;
}, getFormattedDate:function(date) {
  return Ext.Date.format(date, this.getDisplayDateFormat());
}, getFormattedEndDate:function(endDate, startDate) {
  var format = this.getDisplayDateFormat();
  if (endDate.getHours() === 0 && endDate.getMinutes() === 0 && (!startDate || !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) && !Sch.util.Date.hourInfoRe.test(format.replace(Sch.util.Date.stripEscapeRe, ''))) {
    endDate = Sch.util.Date.add(endDate, Sch.util.Date.DAY, -1);
  }
  return Ext.Date.format(endDate, format);
}, getDisplayDateFormat:function() {
  return this.displayDateFormat;
}, setDisplayDateFormat:function(format) {
  this.displayDateFormat = format;
}, fitColumns:function(preventRefresh) {
  if (this.isHorizontal()) {
    this.getTimeAxisViewModel().fitToAvailableWidth(preventRefresh);
  } else {
    var w = Math.floor((this.panel.getWidth() - Ext.getScrollbarSize().width - 1) / this.headerCt.getColumnCount());
    this.setColumnWidth(w, preventRefresh);
  }
}, getElementsFromEventRecord:function(eventRecord, resourceRecord, index, raw) {
  return this[this.mode].getElementsFromEventRecord(eventRecord, resourceRecord, index, raw);
}, getStartEndDatesFromRegion:function(region, roundingMethod) {
  return this[this.mode].getStartEndDatesFromRegion(region, roundingMethod);
}, getTimeResolution:function() {
  return this.timeAxis.getResolution();
}, setTimeResolution:function(unit, increment) {
  this.timeAxis.setResolution(unit, increment);
  if (this.getTimeAxisViewModel().snapToIncrement) {
    this.refreshKeepingScroll();
  }
}, getEventIdFromDomNodeId:function(id) {
  return id.substring(this.eventPrefix.length).split('-')[0];
}, getResourceIdFromDomNodeId:function(id) {
  return id.substring(this.eventPrefix.length).split('-')[1];
}, getDateFromDomEvent:function(e, roundingMethod) {
  return this.getDateFromXY(e.getXY(), roundingMethod);
}, getSnapPixelAmount:function() {
  return this.getTimeAxisViewModel().getSnapPixelAmount();
}, setSnapEnabled:function(enabled) {
  this.getTimeAxisViewModel().setSnapToIncrement(enabled);
}, setReadOnly:function(readOnly) {
  this.readOnly = readOnly;
  this[readOnly ? 'addCls' : 'removeCls'](this._cmpCls + '-readonly');
}, isReadOnly:function() {
  return this.readOnly;
}, setMode:function(mode) {
  this.mode = mode;
  this.timeAxisViewModel.mode = mode;
}, getMode:function() {
  return this.mode;
}, isHorizontal:function() {
  return this.getMode() === 'horizontal';
}, isVertical:function() {
  return this.getMode() === 'vertical';
}, isWeekView:function() {
  return this.getMode() === 'weekview';
}, getDateFromXY:function(xy, roundingMethod, local) {
  return this[this.mode].getDateFromXY(xy, roundingMethod, local);
}, getDateFromCoordinate:function(coordinate, roundingMethod, local) {
  if (!local) {
    coordinate = this[this.mode].translateToScheduleCoordinate(coordinate);
  }
  return this.timeAxisViewModel.getDateFromPosition(coordinate, roundingMethod);
}, getDateFromX:function(x, roundingMethod) {
  return this.getDateFromCoordinate(x, roundingMethod);
}, getDateFromY:function(y, roundingMethod) {
  return this.getDateFromCoordinate(y, roundingMethod);
}, getCoordinateFromDate:function(date, local) {
  var pos = this.timeAxisViewModel.getPositionFromDate(date);
  if (local === false) {
    pos = this[this.mode].translateToPageCoordinate(pos);
  }
  return pos;
}, getTimeSpanDistance:function(startDate, endDate) {
  return this.timeAxisViewModel.getDistanceBetweenDates(startDate, endDate);
}, getTimeSpanRegion:function(startDate, endDate) {
  return this[this.mode].getTimeSpanRegion(startDate, endDate);
}, getScheduleRegion:function(resourceRecord, eventRecord) {
  return this[this.mode].getScheduleRegion(resourceRecord, eventRecord);
}, getTableRegion:function() {
  throw 'Abstract method call';
}, getRowNode:function(resourceRecord) {
  throw 'Abstract method call';
}, getRecordForRowNode:function(node) {
  throw 'Abstract method call';
}, getVisibleDateRange:function() {
  return this[this.mode].getVisibleDateRange();
}, setColumnWidth:function(width, preventRefresh) {
  this[this.mode].setColumnWidth(width, preventRefresh);
}, findRowByChild:function(t) {
  throw 'Abstract method call';
}, setBarMargin:function(margin, preventRefresh) {
  this.barMargin = margin;
  if (!preventRefresh) {
    this.refreshKeepingScroll();
  }
}, getRowHeight:function() {
  return this.timeAxisViewModel.getViewRowHeight();
}, setRowHeight:function(height, preventRefresh) {
  this.timeAxisViewModel.setViewRowHeight(height, preventRefresh);
}, refreshKeepingScroll:function() {
  throw 'Abstract method call';
}, scrollVerticallyTo:function(y, animate) {
  throw 'Abstract method call';
}, scrollHorizontallyTo:function(x, animate) {
  throw 'Abstract method call';
}, getVerticalScroll:function() {
  throw 'Abstract method call';
}, getHorizontalScroll:function() {
  throw 'Abstract method call';
}, getEl:Ext.emptyFn, getScroll:function() {
  throw 'Abstract method call';
}, getOuterEl:function() {
  return this.getEl();
}, getRowContainerEl:function() {
  return this.getEl();
}, getScheduleCell:function(row, col) {
  return this.getCellByPosition({row:row, column:col});
}, getScrollEventSource:function() {
  return this.getEl();
}, getViewportHeight:function() {
  return this.getEl().getHeight();
}, getViewportWidth:function() {
  return this.getEl().getWidth();
}, getViewportCenterDate:function() {
  var scroll = this.getScroll(), xy;
  if (this.isVertical()) {
    xy = [0, scroll.top + this.getViewportHeight() / 2];
  } else {
    xy = [scroll.left + this.getViewportWidth() / 2, 0];
  }
  return this.getDateFromXY(xy, null, true);
}, getDateConstraints:Ext.emptyFn, getItemBox:function(eventRecord) {
  return this[this.mode].getItemBox(eventRecord);
}, getConnectorStartSide:function(eventRecord) {
  return this[this.mode].getConnectorStartSide(eventRecord);
}, getConnectorEndSide:function(eventRecord) {
  return this[this.mode].getConnectorEndSide(eventRecord);
}, getViewStartDate:function() {
  return this.timeAxis.getStart();
}, getViewEndDate:function() {
  return this.timeAxis.getEnd();
}}, 0, 0, 0, 0, 0, 0, [Sch.mixin, 'AbstractTimelineView'], 0);
Ext.apply(Sch, {VERSION:'5.1.16'});
Ext.cmd.derive('Sch.mixin.FilterableTreeView', Ext.Base, {prevBlockRefresh:null, initTreeFiltering:function() {
  var doInit = function() {
    var treeStore = this.store;
    this.mon(treeStore, 'nodestore-datachange-start', this.onFilterChangeStart, this);
    this.mon(treeStore, 'nodestore-datachange-end', this.onFilterChangeEnd, this);
    if (!treeStore.allowExpandCollapseWhileFiltered) {
      this.mon(treeStore, 'filter-clear', this.onFilterCleared, this);
      this.mon(treeStore, 'filter-set', this.onFilterSet, this);
    }
  };
  if (this.rendered) {
    doInit.call(this);
  } else {
    this.on('beforerender', doInit, this, {single:true});
  }
}, onFilterChangeStart:function() {
  this.prevBlockRefresh = this.blockRefresh;
  this.blockRefresh = true;
  Ext.suspendLayouts();
}, onFilterChangeEnd:function() {
  Ext.resumeLayouts(true);
  this.blockRefresh = this.prevBlockRefresh;
}, onFilterCleared:function() {
  delete this.toggle;
  var el = this.getEl();
  if (el) {
    el.removeCls('sch-tree-filtered');
  }
}, onFilterSet:function() {
  this.toggle = function() {
  };
  var el = this.getEl();
  if (el) {
    el.addCls('sch-tree-filtered');
  }
}}, 0, 0, 0, 0, 0, 0, [Sch.mixin, 'FilterableTreeView'], 0);
Ext.cmd.derive('Sch.mixin.GridViewCanvas', Ext.Mixin, {mixinConfig:{after:{'onRender':'afterOnRender'}}, secondaryCanvasCls:'sch-secondary-canvas', secondaryCanvasLayerCls:'sch-secondary-canvas-layer', itemsCanvasEl:null, itemsCanvasCls:'sch-item-canvas', itemsCanvasLayerCls:'sch-item-canvas-layer', getSecondaryCanvasEl:function() {
  var el = null;
  if (this.isItemCanvasAvailable()) {
    el = this.getItemCanvasEl(-1, {tag:'div', role:'presentation', cls:this.secondaryCanvasCls});
  }
  return el;
}, isItemCanvasAvailable:function(layer) {
  var me = this;
  return !!(me.rendered && !me.destroyed && (me.getNodeContainer() || me.itemsCanvasEl && (me.itemsCanvasEl._underMixinControl || !Ext.isGarbage(me.itemsCanvasEl.dom))));
}, isItemCanvasPresent:function(layer) {
  var me = this;
  return !!(me.rendered && !me.destroyed && me.itemsCanvasEl && (layer === undefined || me.itemsCanvasEl[layer] && (me.itemsCanvasEl._underMixinControl || !Ext.isGarbage(me.itemsCanvasEl[layer].dom))));
}, getItemCanvasEl:function(layer, layerCreationSpecification) {
  var me = this, canvasEl = me.itemsCanvasEl, layerEl = canvasEl;
  if (!canvasEl || !canvasEl.dom || !canvasEl._underMixinControl && Ext.isGarbage(canvasEl.dom)) {
    layerEl = canvasEl = me.itemsCanvasEl = Ext.fly(me.getNodeContainer()).insertFirst({cls:me.itemsCanvasCls});
  }
  if (arguments.length > 0) {
    layer = layer || 0;
    layerEl = canvasEl[layer] || Ext.dom.Query.selectNode('[data-sch-secondary-canvas-layer\x3d"' + layer + '"]', canvasEl.dom);
    if (!layerEl || !layerEl.dom || !canvasEl._underMixinControl && Ext.isGarbage(layerEl.dom)) {
      layerEl = canvasEl.createChild((Ext.isFunction(layerCreationSpecification) ? layerCreationSpecification() : layerCreationSpecification) || {tag:'div'});
      layerEl.set({'data-sch-secondary-canvas-layer':layer});
      layerEl.setStyle('zIndex', layer);
      layerEl.addCls(me.itemsCanvasLayerCls);
      canvasEl[layer] = layerEl;
    }
  }
  return layerEl;
}, afterOnRender:function() {
  if (this.bufferedRenderer) {
    this.on('viewready', this.onBufferedRendererViewReady, this);
  }
}, onBufferedRendererViewReady:function() {
  var me = this, targetBufferedPlugin = Ext.getVersion().isGreaterThan('6.5.3') ? this.grid.up('tablepanel').lockedGrid.bufferedRenderer : me.bufferedRenderer, oldOnRangeFetched = targetBufferedPlugin.onRangeFetched;
  targetBufferedPlugin.onRangeFetched = function() {
    var itemsCanvas = me.getItemCanvasEl(), nodeContainer = me.getNodeContainer(), retVal;
    itemsCanvas._underMixinControl = true;
    itemsCanvas.dom.parentNode && itemsCanvas.dom.parentNode.removeChild(itemsCanvas.dom);
    retVal = oldOnRangeFetched.apply(this, arguments);
    nodeContainer.insertBefore(itemsCanvas.dom, nodeContainer.firstChild);
    delete itemsCanvas._underMixinControl;
    return retVal;
  };
}}, 0, 0, 0, 0, 0, 0, [Sch.mixin, 'GridViewCanvas'], 0);
Ext.cmd.derive('Sch.mixin.PartnerTimelinePanel', Ext.Mixin, {setupPartnerTimelinePanel:function(panel) {
  var otherPanel = this.partnerTimelinePanel;
  var otherLockedGrid = otherPanel.lockedGrid;
  var ourLockedGrid = this.lockedGrid;
  otherLockedGrid.mon(ourLockedGrid, 'resize', this.onLockedGridResize, otherLockedGrid);
  ourLockedGrid.mon(otherLockedGrid, 'resize', this.onLockedGridResize, ourLockedGrid);
  var lockedWidth = otherPanel.isVisible() ? otherPanel.lockedGrid.getWidth() : otherPanel.lockedGrid.width;
  if (otherLockedGrid.getCollapsed()) {
    this.mon(otherLockedGrid, 'viewready', function(panel) {
      ourLockedGrid.setWidth(panel.getWidth());
    });
  } else {
    ourLockedGrid.setWidth(lockedWidth);
  }
  this.on('afterlayout', function() {
    if (otherLockedGrid.getCollapsed()) {
      ourLockedGrid.collapse();
    } else {
      ourLockedGrid.expand();
      ourLockedGrid.setWidth(lockedWidth);
    }
  }, this, {single:true});
  otherLockedGrid.on({collapse:this.onPartnerCollapseExpand, expand:this.onPartnerCollapseExpand, scope:this});
  ourLockedGrid.on({collapse:this.onPartnerCollapseExpand, expand:this.onPartnerCollapseExpand, scope:otherPanel});
  this.setupScrollSync();
  otherPanel.mon(this, 'beforezoomchange', this.onBeforeZoomChange, this);
  otherPanel.mon(this, 'viewchange', this.onViewChange, this);
  this.mon(otherPanel, 'beforezoomchange', this.onBeforeZoomChange, this);
  this.mon(otherPanel, 'viewchange', this.onViewChange, this);
}, onLockedGridResize:function(cmp, width) {
  this.setWidth(width);
}, onPartnerCollapseExpand:function(panel) {
  if (panel.getCollapsed()) {
    this.lockedGrid.collapse();
  } else {
    this.lockedGrid.expand();
  }
}, setupScrollSync:function() {
  var otherView = this.partnerTimelinePanel.getSchedulingView(), otherScrollSource = this.partnerTimelinePanel.getMode() === 'horizontal' ? otherView.getScrollable() : this.partnerTimelinePanel.getScrollable(), ownView = this.getSchedulingView(), ownScrollSource = this.getMode() === 'horizontal' ? ownView.getScrollable() : this.getScrollable(), asapScrolling;
  function onSyncScrollStart(scrollable) {
    var source = scrollable === ownScrollSource ? ownScrollSource : otherScrollSource, target = scrollable === ownScrollSource ? otherScrollSource : ownScrollSource;
    if (!asapScrolling) {
      source.component.mun(target, 'scrollstart', onSyncScrollStart);
      target.component.mun(source, 'scrollstart', onSyncScrollStart);
      source.component.mon(source, 'scroll', doScrollSync);
      source.component.mon(source, 'scrollend', onSyncScrollEnd);
    }
  }
  function doScrollSync(syncFromScrollable, x, y) {
    var source = syncFromScrollable === ownScrollSource ? ownScrollSource : otherScrollSource, target = syncFromScrollable === ownScrollSource ? otherScrollSource : ownScrollSource;
    var headerScrollable = target.component.headerCt.getScrollable();
    asapScrolling = Ext.asap(function() {
      var delta, position;
      position = target.getPosition();
      if (position && ownView.getMode() === 'horizontal') {
        delta = Math.abs(position.x - x);
        if (delta) {
          headerScrollable && !headerScrollable.destroyed && headerScrollable.scrollTo(x, null);
          !target.destroyed && target.scrollTo(x);
          asapScrolling = false;
        } else {
          asapScrolling = false;
        }
      } else {
        if (position) {
          delta = Math.abs(position.y != y);
          if (delta) {
            !target.destroyed && target.scrollTo(null, y);
          }
          asapScrolling = false;
        }
      }
    });
  }
  function onSyncScrollEnd(scrollable) {
    var source = scrollable === ownScrollSource ? ownScrollSource : otherScrollSource, target = scrollable === ownScrollSource ? otherScrollSource : ownScrollSource;
    source.component.mun(source, 'scroll', doScrollSync);
    source.component.mun(source, 'scrollend', onSyncScrollEnd);
    source.component.mon(target, 'scrollstart', onSyncScrollStart);
    target.component.mon(source, 'scrollstart', onSyncScrollStart);
  }
  function startScrollMonitoring() {
    otherScrollSource.component.mon(ownScrollSource, 'scrollstart', onSyncScrollStart);
    ownScrollSource.component.mon(otherScrollSource, 'scrollstart', onSyncScrollStart);
  }
  function stopScrollMonitoring() {
    otherScrollSource.component.mun(ownScrollSource, 'scrollstart', onSyncScrollStart);
    ownScrollSource.component.mun(otherScrollSource, 'scrollstart', onSyncScrollStart);
  }
  this.partnerTimelinePanel.mon(this, {'show':function() {
    doScrollSync(otherScrollSource, otherScrollSource.getPosition().x, otherScrollSource.getPosition().y);
  }});
  this.mon(this.partnerTimelinePanel, {'show':function() {
    doScrollSync(ownScrollSource, ownScrollSource.getPosition().x, ownScrollSource.getPosition().y);
  }});
  startScrollMonitoring();
}, onViewChange:function(panel) {
  if (panel === this) {
    this.partnerTimelinePanel.viewPreset = this.viewPreset = this.timeAxisViewModel.viewPreset;
  }
}, onBeforeZoomChange:function() {
  var otherPanel = this.partnerTimelinePanel;
  var scrollable = otherPanel.getSchedulingView().getScrollable(), old = scrollable.suspendPartnerSync;
  scrollable.suspendPartnerSync = Ext.emptyFn;
  scrollable.on('scrollend', function() {
    scrollable.suspendPartnerSync = old;
  }, null, {single:true});
}}, 0, 0, 0, 0, 0, 0, [Sch.mixin, 'PartnerTimelinePanel'], 0);
Ext.cmd.derive('Sch.patches.NavigationModel6_0_2', Sch.util.Patch, {target:'Ext.grid.NavigationModel', minVersion:'6.0.2', maxVersion:'6.6.1', applyFn:function() {
  var methodName = Ext.getVersion().isLessThan('6.5.1') ? 'scrollIntoView' : 'ensureVisible';
  Ext.ClassManager.get(this.target).override({focusPosition:function(position) {
    var me = this;
    if (position && position.record && position.column && position.view && position.view._initializeTimelineView) {
      var scroller = position.view.getScrollable();
      if (scroller && scroller.scrollIntoView) {
        var old = scroller[methodName];
        scroller[methodName] = Ext.emptyFn;
        var retVal = this.callParent(arguments);
        scroller[methodName] = old;
        return retVal;
      }
    }
    return this.callParent(arguments);
  }});
}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'NavigationModel6_0_2'], 0);
Ext.cmd.derive('Sch.patches.TouchScroll', Sch.util.Patch, {target:'Ext.scroll.TouchScroller', minVersion:'5.1.0', maxVersion:'6.2.0', overrides:{privates:{onEvent:function(e) {
  var me = this;
  if (!me[me.listenerMap[e.type]]) {
    return;
  }
  return this.callParent(arguments);
}}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TouchScroll'], 0);
Ext.cmd.derive('Sch.patches.View', Sch.util.Patch, {target:'Ext.view.View', minVersion:'5.1.0', overrides:{handleEvent:function(e) {
  var me = this, isKeyEvent = me.keyEventRe.test(e.type), nm = me.getNavigationModel();
  e.view = me;
  if (isKeyEvent) {
    e.item = e.getTarget(me.itemSelector);
    e.record = nm.getRecord(e.item);
  }
  if (!e.item) {
    var editing = me.editingPlugin && me.editingPlugin.getActiveEditor && me.editingPlugin.getActiveEditor();
    if (!(editing && editing.getEl().contains(e.getTarget()))) {
      e.item = e.getTarget(me.itemSelector);
    }
  }
  if (e.item && !e.record) {
    e.record = me.getRecord(e.item);
  }
  if (me.processUIEvent(e) !== false) {
    me.processSpecialEvent(e);
  }
  if (isKeyEvent && !Ext.fly(e.target).isInputField()) {
    if (e.getKey() === e.SPACE || e.isNavKeyPress(true)) {
      e.preventDefault();
    }
  }
  e.view = null;
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'View'], 0);
Ext.cmd.derive('Sch.patches.Scroller', Sch.util.Patch, {target:'Ext.scroll.Scroller', minVersion:'6.0.2', maxVersion:'6.0.3', applyFn:function() {
  var overrides = {destroy:function() {
    clearTimeout(this.restoringTimer);
    this.callParent(arguments);
  }, privates:{restoreState:function() {
    var me = this, el = me.getScrollElement(), dom;
    if (el) {
      dom = el.dom;
      if (me.trackingScrollTop !== undefined) {
        me.restoring = true;
        me.restoringTimer = Ext.defer(function() {
          me.restoring = false;
        }, 50);
        dom.scrollTop = me.trackingScrollTop;
        dom.scrollLeft = me.trackingScrollLeft;
      }
    }
  }}};
  if (Ext.isIE9m) {
    overrides.privates.updateSpacerXY = function(pos) {
      var spacer = this.getSpacer();
      if (this.getRtl && this.getRtl()) {
        spacer.rtlSetLocalXY(pos.x, pos.y);
      } else {
        spacer.setLocalXY(pos.x, pos.y);
      }
    };
  }
  Ext.ClassManager.get(this.target).override(overrides);
}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'Scroller'], 0);
Ext.cmd.derive('Sch.patches.Scroller_6_5', Sch.util.Patch, {target:'Ext.scroll.Scroller', minVersion:'6.5.0', maxVersion:'6.5.1.9999', overrides:{privates:{updateDomScrollPosition:function(silent) {
  var me = this, position = me.position, oldX = position.x, oldY = position.y, x, y, xDelta, yDelta;
  me.readPosition(position);
  x = position.x;
  y = position.y;
  me.positionDirty = false;
  if (!silent) {
    xDelta = x - oldX;
    yDelta = y - oldY;
    if (!me.isScrolling) {
      me.isScrolling = Ext.isScrolling = true;
      me.fireScrollStart(x, y, xDelta, yDelta);
    }
    me.fireScroll(x, y, xDelta, yDelta);
    me.bufferedOnDomScrollEnd(x, y, xDelta, yDelta);
  }
  return position;
}}, getPosition:function() {
  var me = this;
  if (me.positionDirty) {
    me.updateDomScrollPosition(true);
  }
  return me.position;
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'Scroller_6_5'], 0);
Ext.cmd.derive('Sch.patches.Queue', Sch.util.Patch, {target:'Ext.util.Queue', minVersion:'6.0.2', maxVersion:'6.0.3', overrides:{add:function(obj, replace) {
  var me = this, key = me.getKey(obj), prevEntry;
  if (!(prevEntry = me.map[key])) {
    ++me.length;
    me.items.push(obj);
    me.map[key] = obj;
  } else {
    if (replace) {
      me.map[key] = obj;
      me.items[Ext.Array.indexOf(me.items, prevEntry)] = obj;
    }
  }
  return obj;
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'Queue'], 0);
Ext.cmd.derive('Sch.patches.LayoutContext', Sch.util.Patch, {target:'Ext.layout.Context', minVersion:'6.0.2', maxVersion:'6.0.3', overrides:{queueFlush:function(item, replace) {
  this.flushQueue.add(item, replace);
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'LayoutContext'], 0);
Ext.cmd.derive('Sch.patches.LayoutContext_6_5', Sch.util.Patch, {target:'Ext.layout.Context', minVersion:'6.5.0', maxVersion:'6.6.1', overrides:{callLayout:function(layout, methodName) {
  this.currentLayout = layout;
  if (!layout.destroyed) {
    layout[methodName](this.getCmp(layout.owner));
  }
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'LayoutContext_6_5'], 0);
Ext.cmd.derive('Sch.patches.Lockable', Sch.util.Patch, {target:'Ext.grid.locking.Lockable', minVersion:'6.0.2', maxVersion:'6.0.3', applyFn:function() {
  if (Ext.firefoxVersion > 51 && Ext.supports.touchScroll === 2) {
    Ext.supports.Touch = 0;
    Ext.supports.TouchEvents = 0;
    Ext.supports.touchScroll = 0;
  }
}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'Lockable'], 0);
Ext.cmd.derive('Sch.patches.TableLayout', Sch.util.Patch, {target:'Ext.view.TableLayout', minVersion:'6.0.2', maxVersion:'6.0.3', overrides:{calculate:function(ownerContext) {
  var me = this, context = ownerContext.context, lockingPartnerContext = ownerContext.lockingPartnerContext, headerContext = ownerContext.headerContext, ownerCtContext = ownerContext.ownerCtContext, owner = me.owner, columnsChanged = headerContext.getProp('columnsChanged'), state = ownerContext.state, columnFlusher, otherSynchronizer, synchronizer, rowHeightFlusher, bodyDom = owner.body.dom, bodyHeight, ctSize, overflowY, normalView, lockedViewHorizScrollBar, normalViewHorizScrollBar;
  if (!owner.all.getCount() && (!bodyDom || !owner.body.child('table'))) {
    ownerContext.setProp('viewOverflowY', false);
    me.callParent([ownerContext]);
    return;
  }
  if (columnsChanged === undefined) {
    me.done = false;
    return;
  }
  if (columnsChanged) {
    if (!(columnFlusher = state.columnFlusher)) {
      context.queueFlush(state.columnFlusher = columnFlusher = {ownerContext:ownerContext, columnsChanged:columnsChanged, layout:me, id:me.columnFlusherId, flush:me.flushColumnWidths}, true);
    }
    if (!columnFlusher.flushed) {
      me.done = false;
      return;
    }
  }
  if (ownerContext.doSyncRowHeights) {
    if (!(rowHeightFlusher = state.rowHeightFlusher)) {
      if (!(synchronizer = state.rowHeights)) {
        state.rowHeights = synchronizer = ownerContext.rowHeightSynchronizer;
        me.owner.syncRowHeightMeasure(synchronizer);
        ownerContext.setProp('rowHeights', synchronizer);
      }
      if (!(otherSynchronizer = lockingPartnerContext.getProp('rowHeights'))) {
        me.done = false;
        return;
      }
      context.queueFlush(state.rowHeightFlusher = rowHeightFlusher = {ownerContext:ownerContext, synchronizer:synchronizer, otherSynchronizer:otherSynchronizer, layout:me, id:me.rowHeightFlusherId, flush:me.flushRowHeights}, true);
    }
    if (!rowHeightFlusher.flushed) {
      me.done = false;
      return;
    }
  }
  me.callParent([ownerContext]);
  if (!ownerContext.heightModel.shrinkWrap) {
    overflowY = false;
    if (!ownerCtContext.heightModel.shrinkWrap) {
      ctSize = ownerCtContext.target.layout.getContainerSize(ownerCtContext);
      if (!ctSize.gotHeight) {
        me.done = false;
        return;
      }
      bodyHeight = bodyDom.offsetHeight;
      overflowY = bodyHeight > ctSize.height;
    }
    ownerContext.setProp('viewOverflowY', overflowY);
  }
  if (me.done && Ext.getScrollbarSize().height) {
    if (lockingPartnerContext && owner.isLockedView) {
      normalView = owner.lockingPartner;
      lockedViewHorizScrollBar = owner.scrollFlags.x && ownerContext.headerContext.state.boxPlan.tooNarrow;
      normalViewHorizScrollBar = normalView.scrollFlags.x && lockingPartnerContext.headerContext.state.boxPlan.tooNarrow;
      if (lockedViewHorizScrollBar !== normalViewHorizScrollBar) {
        if (normalViewHorizScrollBar) {
          lockingPartnerContext.setProp('overflowX', true);
          ownerContext.setProp('overflowX', 'scroll');
        } else {
          ownerContext.setProp('overflowX', true);
          lockingPartnerContext.setProp('overflowX', 'scroll');
        }
      } else {
        ownerContext.setProp('overflowX', normalViewHorizScrollBar);
        lockingPartnerContext.setProp('overflowX', lockedViewHorizScrollBar);
      }
      ownerContext.setProp('overflowY', 'scroll');
    } else {
      if (!owner.isAutoTree) {
        ownerContext.setProp('overflowX', !!ownerContext.headerContext.state.boxPlan.tooNarrow);
      }
    }
  }
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TableLayout'], 0);
Ext.cmd.derive('Sch.patches.ColumnLayout', Sch.util.Patch, {target:'Ext.grid.ColumnLayout', minVersion:'6.0.2', maxVersion:'6.0.3', overrides:{calculate:function(ownerContext) {
  var me = this, grid = me.owner.grid, viewContext = ownerContext.viewContext, state = ownerContext.state, context = ownerContext.context, lockingPartnerContext, lockingPartnerGrid, ownerGrid, columnsChanged, columns, len, i, column, scrollbarAdjustment, viewOverflowY;
  me.callSuper([ownerContext]);
  if (grid && state.parallelDone) {
    lockingPartnerContext = viewContext.lockingPartnerContext;
    if (lockingPartnerContext) {
      lockingPartnerGrid = lockingPartnerContext.target.ownerCt;
      if (!lockingPartnerGrid.isVisible() || lockingPartnerGrid.collapsed) {
        lockingPartnerContext = null;
      }
    }
    ownerGrid = grid.ownerGrid;
    if (ownerGrid.forceFit && !state.reflexed) {
      if (me.convertWidthsToFlexes(ownerContext)) {
        me.cacheFlexes(ownerContext);
        me.done = false;
        ownerContext.invalidate({state:{reflexed:true, scrollbarAdjustment:me.getScrollbarAdjustment(ownerContext)}});
        return;
      }
    }
    if ((columnsChanged = state.columnsChanged) === undefined) {
      columns = ownerContext.target.getVisibleGridColumns();
      columnsChanged = false;
      for (i = 0, len = columns.length; i < len; i++) {
        column = context.getCmp(columns[i]);
        if (!column.lastBox || column.props.width !== column.lastBox.width) {
          (columnsChanged || (columnsChanged = []))[i] = column;
        }
      }
      state.columnsChanged = columnsChanged;
      ownerContext.setProp('columnsChanged', columnsChanged);
    }
    if (ownerContext.manageScrollbar) {
      scrollbarAdjustment = me.getScrollbarAdjustment(ownerContext);
      if (scrollbarAdjustment) {
        viewOverflowY = viewContext.getProp('viewOverflowY');
        if (viewOverflowY === undefined) {
          me.done = false;
          return;
        }
        if (!viewOverflowY) {
          if (lockingPartnerContext) {
            lockingPartnerContext.invalidate();
            lockingPartnerContext.headerContext.invalidate();
          }
          viewContext.invalidate();
          ownerContext.invalidate({state:{scrollbarAdjustment:0}});
        }
      }
    }
  }
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'ColumnLayout'], 0);
Ext.cmd.derive('Sch.patches.ToolTip', Sch.util.Patch, {target:'Ext.tip.ToolTip', minVersion:'6.0.0', applyFn:function() {
  var overrides = {setTarget:function(target) {
    var me = this;
    if (me.target) {
      var oldTarget = Ext.get(me.target);
      if (oldTarget) {
        me.mun(oldTarget, {mouseover:me.onTargetOver, tap:me.onTargetOver, mouseout:me.onTargetOut, mousemove:me.onMouseMove, scope:me});
      }
    }
    me.target = Ext.get(target);
    if (me.target) {
      me.mon(me.target, {mouseover:me.onTargetOver, tap:me.onTargetOver, mouseout:me.onTargetOut, mousemove:me.onMouseMove, scope:me});
    }
    if (me.anchor) {
      me.anchorTarget = me.target;
    }
  }};
  if (Ext.getVersion().isLessThan('6.0.2')) {
    overrides.afterSetPosition = function(x, y) {
      var me = this;
      me.callParent(arguments);
      if (me.anchor) {
        if (!me.anchorEl.isVisible()) {
          me.anchorEl.show();
        }
        me.syncAnchor();
      } else {
        me.anchorEl.hide();
      }
    };
  }
  Ext.ClassManager.get(this.target).override(overrides);
}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'ToolTip'], 0);
Ext.cmd.derive('Sch.patches.AbstractView', Sch.util.Patch, {target:'Ext.view.AbstractView', minVersion:'6.2.0', obsoleteTestName:'patches/002_abstract_view.t.js', overrides:{setItemsDraggable:function(draggable) {
  var me = this, result;
  result = me.callParent([draggable]);
  if (!draggable && me.viewStyleSheet && me.viewStyleSheet.cssRules.length === 0) {
    me.viewStyleSheet.ownerNode.parentNode.removeChild(me.viewStyleSheet.ownerNode);
    me.viewStyleSheet = Ext.view.AbstractView.prototype.viewStyleSheet = null;
  }
  return result;
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'AbstractView'], 0);
Ext.cmd.derive('Sch.patches.SpreadsheetModel', Sch.util.Patch, {target:'Ext.grid.selection.SpreadsheetModel', minVersion:'6.6.0', maxVersion:'6.6.1', overrides:{privates:{onMouseMove:function(e, target, opts) {
  var me = this, view = opts.view, cell = e.getTarget(view.cellSelector), header = opts.view.getHeaderByCell(cell), selData = me.selected;
  var schedulingView;
  if (view.getSchedulingView) {
    schedulingView = view.getSchedulingView();
  } else {
    if (view.ownerGrid.getSchedulingView) {
      schedulingView = view.ownerGrid.getSchedulingView();
    }
  }
  if (schedulingView && schedulingView._cmpCls && Ext.fly(target).up('.' + schedulingView._cmpCls)) {
    return;
  }
  if (me.checkCellClicked) {
    if (cell === me.checkCellClicked) {
      if (!me.lastOverRecord) {
        me.lastOverRecord = view.getRecord(cell.parentNode);
      }
      return;
    } else {
      me.checkCellClicked = null;
      if (me.lastOverRecord) {
        me.select(me.lastOverRecord);
        selData.setRangeStart(me.store.indexOf(me.lastOverRecord));
      }
    }
  }
  me.isDragging = true;
  if (me.extensible) {
    me.extensible.disable();
  }
  if (header) {
    me.changeSelectionRange(view, cell, header, e);
  } else {
    var el = view.body ? view.body.el : view.ownerGrid.body.el;
    if (!e.within(el)) {
      me.scrollTowardsPointer(e, view);
    }
  }
}}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'SpreadsheetModel'], 0);
Ext.cmd.derive('Sch.patches.TableScroller', Sch.util.Patch, {minVersion:'6.2.1', maxVersion:'6.5.0', target:'Ext.scroll.TableScroller', overrides:{privates:{onDomScroll:function() {
  var me = this, position = me.position, oldX = position.x, oldY = position.y, x, y, xDelta, yDelta;
  position = me.updateDomScrollPosition();
  if (me.restoreTimer) {
    clearTimeout(me.onDomScrollEnd.timer);
    return;
  }
  x = position.x;
  y = position.y;
  xDelta = x - oldX;
  yDelta = y - oldY;
  if (!me.isScrolling) {
    me.isScrolling = Ext.isScrolling = true;
    me.fireScrollStart(x, y, xDelta, yDelta);
  }
  me.fireScroll(x, y, xDelta, yDelta);
  me.bufferedOnDomScrollEnd(x, y, xDelta, yDelta);
}, invokePartners:function(method, x, y, xDelta, yDelta) {
  var me = this, partners = me._partners, partner, id, axes;
  if (!me.suspendSync) {
    me.invokingPartners = true;
    for (id in partners) {
      axes = partners[id].axes;
      partner = partners[id].scroller;
      if (!partner.invokingPartners) {
        partner[method](me, axes.x ? x : null, axes.y ? y : null, xDelta, yDelta);
      }
    }
    me.invokingPartners = false;
  }
}}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TableScroller'], 0);
Ext.cmd.derive('Sch.patches.TableScroller2', Sch.util.Patch, {minVersion:'6.2.1', maxVersion:'6.2.2', target:'Ext.scroll.TableScroller', overrides:{privates:{getScrollIntoViewXY:function(el, hscroll) {
  var lockingScroller = this.getLockingScroller(), position = this.getPosition(), newPosition;
  if (lockingScroller) {
    position.y = lockingScroller.position.y;
  }
  newPosition = Ext.fly(el).getScrollIntoViewXY(this.getElement(), position.x, position.y);
  newPosition.x = hscroll === false ? position.x : newPosition.x;
  if (lockingScroller) {
    newPosition.y = Ext.fly(el).getScrollIntoViewXY(lockingScroller.getElement(), position.x, position.y).y;
  }
  return newPosition;
}}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TableScroller2'], 0);
Ext.cmd.derive('Sch.patches.Ie9FormFieldText', Sch.util.Patch, {target:'Ext.form.field.Text', ieOnly:true, minVersion:'6.0.0', maxVersion:'6.6.0', reportUrl:null, obsoleteTestName:'patches/003_ie9_form_field_text.t.js', description:["Text field being a part of grid cell editor might find itself in a situation when it's detached", 'from the document and requested to select text inside itself, by being focused for example, simultaneously'].join(' '), applyFn:function() {
  Ext.isIE9 && Ext.ClassManager.get(this.target).override({selectTextAsapId:null, selectText:function(start, end) {
    var me = this;
    if (!me.destroying && !me.destroyed && me.inputEl) {
      try {
        Ext.unasap ? Ext.unasap(me.selectTextAsapId) : Ext.asapCancel(me.selectTextAsapId);
        me.selectTextAsapId = null;
        me.callParent([start, end]);
      } catch (e$41) {
        me.selectTextAsapId = Ext.asap(me.selectText, me, [start, end]);
      }
    }
  }});
}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'Ie9FormFieldText'], 0);
Ext.cmd.derive('Sch.tooltip.EventTip', Ext.tip.ToolTip, {config:{view:null}, componentCls:'sch-tooltip-eventtip', anchor:'t', constraintInsets:'7 -7 -7 7', allowOver:true, initComponent:function() {
  var me = this;
  Ext.tip.ToolTip.prototype.initComponent.apply(this, arguments);
  me.on('beforeshow', me.onTipBeforeShow, me);
}, getAlignRegion:function() {
  var me = this, anchorEl = me.anchorEl, align = me.getAnchorAlign(), overlap, alignSpec, target, mouseOffset = me.mouseOffset, constrainTo, constraintInsets;
  if (!me.anchorSize) {
    anchorEl.addCls('x-tip-anchor-top');
    anchorEl.show();
    me.anchorSize = new Ext.util.Offset(anchorEl.getWidth(), anchorEl.getHeight());
    anchorEl.removeCls('x-tip-anchor-top');
    anchorEl.hide();
  }
  if ((me.anchor || me.align) && me.anchorToTarget && !me.trackMouse) {
    target = me.currentTarget.getRegion();
    if (!Ext.isGarbage(me.currentTarget.dom) && me.getView().getMode() === 'horizontal' && me.pointerEvent) {
      target = target.intersect(new Ext.util.Region(target.top, me.pointerEvent.getPoint().x + me.getRegion().width / 2, target.bottom, me.pointerEvent.getPoint().x + -me.getRegion().width / 2)) || target;
    }
  } else {
    target = me.pointerEvent ? me.pointerEvent.getPoint().adjust(-Math.abs(mouseOffset[1]), Math.abs(mouseOffset[0]), Math.abs(mouseOffset[1]), -Math.abs(mouseOffset[0])) : new Ext.util.Point;
    if (!me.anchor) {
      overlap = true;
      if (mouseOffset[0] > 0) {
        if (mouseOffset[1] > 0) {
          align = 'tl-br';
        } else {
          align = 'bl-tr';
        }
      } else {
        if (mouseOffset[1] > 0) {
          align = 'tr-bl';
        } else {
          align = 'br-tl';
        }
      }
    }
  }
  alignSpec = {align:me.convertPositionSpec(align), axisLock:me.axisLock, target:target, overlap:overlap, offset:me.targetOffset};
  if (me.anchor) {
    alignSpec.anchorSize = me.anchorSize;
  }
  if (me.constrainPosition) {
    constrainTo = me.constrainTo || Ext.getBody();
    if (!constrainTo.isRegion) {
      constrainTo = Ext.util.Region.getRegion(constrainTo);
    }
    if (me.constraintInsets) {
      constraintInsets = me.constraintInsets;
      if (!Ext.isObject(constraintInsets)) {
        constraintInsets = Ext.util.Format.parseBox(constraintInsets);
      }
      constrainTo = constrainTo.copy().adjust(constraintInsets.top, constraintInsets.right, constraintInsets.bottom, constraintInsets.left);
    }
    alignSpec.inside = constrainTo;
  }
  return me.getRegion().alignTo(alignSpec);
}, onTipBeforeShow:function(me) {
  if (!me.triggerElement || !me.triggerElement.id) {
    return false;
  }
  var view = me.getView();
  var modalVisibleWindows = Ext.all('window[modal\x3dtrue]{isVisible()}');
  var foundWindow = Ext.Array.findBy(modalVisibleWindows, function(modalWindow) {
    return view !== modalWindow && !view.isDescendantOf(modalWindow);
  });
  if (foundWindow) {
    return false;
  }
  var record = view.resolveEventRecord(me.triggerElement);
  if (!record || view.fireEvent('beforetooltipshow', view, record) === false) {
    return false;
  }
  var dataForMe = view.getDataForTooltipTpl(record, me.triggerElement), tooltipString;
  if (!dataForMe) {
    return false;
  }
  tooltipString = view.tooltipTpl.apply(dataForMe);
  if (!tooltipString) {
    return false;
  }
  me.update(tooltipString);
}, onTargetOut:function(e) {
  if (this.rendered && this.allowOver && this.el.contains(e.relatedTarget)) {
    return;
  }
  return Ext.tip.ToolTip.prototype.onTargetOut.apply(this, arguments);
}}, 0, ['scheduler_eventtip'], ['component', 'box', 'container', 'panel', 'tip', 'tooltip', 'scheduler_eventtip'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tip':true, 'tooltip':true, 'scheduler_eventtip':true}, ['widget.scheduler_eventtip'], 0, [Sch.tooltip, 'EventTip'], function(thisClass) {
  var DEFAULT_ANCHOR = 't';
  function toConstrainRegion(r) {
    var R = Ext.util.Region;
    if (r && !r.isRegion && r.isComponent) {
      r = r.getConstrainRegion();
    } else {
      if (r && !r.isRegion && r.isElement) {
        r = r.getConstrainRegion();
      } else {
        if (r && !r.isRegion && Ext.isElement(r)) {
          r = R.getRegion(r);
        } else {
          if (r && !r.isRegion) {
            r = R.from(r);
          }
        }
      }
    }
    return r;
  }
  function toPoint(p) {
    var P = Ext.util.Point;
    if (p && !p.isPoint && Ext.isArray(p)) {
      p = new P(p[0] || 0, p[1] || 0);
    } else {
      if (p && !p.isPoint) {
        p = P.from(p);
      }
    }
    return p;
  }
  function canContain(container, contained) {
    return container.right - container.left >= contained.right - contained.left && container.bottom - container.top >= contained.bottom - contained.top;
  }
  Ext.versions.extjs.isLessThan('6.2.0') && Ext.override(thisClass, {show:function() {
    var me = this, view = me.getView();
    me.callParent(arguments);
    if (me.triggerElement && view.getMode() === 'horizontal') {
      me.alignTipToEvent(me.triggerElement, me.constrainPosition && me.constrainTo, me.targetXY);
    }
  }, alignTipToEvent:function(eventEl, constrainTo, pointer) {
    var R = Ext.util.Region, P = Ext.util.Point, numConstrain = Ext.Number.constrain, me = this, anchor = window.tipAnchor || me.origAnchor || DEFAULT_ANCHOR, rtl = me.rtl, tipWidth, tipHeight, tipAnchorOffset, eventRegion, constrainRegion, constrainRegionsMap, tipRegionsMap, anchoredTipRegionsMap, regionsQueue, anchorSize, fitRegionName, fitConstrainRegion, fitAnchoredTipRegion, fitTipRegion, constrainVector, xy;
    constrainRegion = toConstrainRegion(constrainTo || Ext.getBody());
    eventRegion = constrainRegion.intersect(toConstrainRegion(eventEl));
    if (eventRegion) {
      tipWidth = me.getWidth(), tipHeight = me.getHeight(), anchorSize = me.anchorEl && me.anchorEl.getSize() || {width:0, height:0};
      anchorSize.width /= 2;
      anchorSize.height /= 2;
      pointer = pointer && toPoint(pointer);
      if (!pointer || !eventRegion.contains(pointer)) {
        pointer = new P((eventRegion.left + eventRegion.right) / 2, (eventRegion.top + eventRegion.bottom) / 2);
      }
      constrainRegionsMap = {'top':new R(constrainRegion.top, constrainRegion.right, eventRegion.top, constrainRegion.left), 'bottom':new R(eventRegion.bottom, constrainRegion.right, constrainRegion.bottom, constrainRegion.left), 'left':new R(constrainRegion.top, eventRegion.left, constrainRegion.bottom, constrainRegion.left), 'right':new R(constrainRegion.top, constrainRegion.right, constrainRegion.bottom, eventRegion.right)};
      tipRegionsMap = {'top':new R(constrainRegionsMap.top.bottom - tipHeight - anchorSize.height, pointer.x + tipWidth / 2, constrainRegionsMap.top.bottom - anchorSize.height, pointer.x - tipWidth / 2), 'bottom':new R(constrainRegionsMap.bottom.top + anchorSize.height, pointer.x + tipWidth / 2, constrainRegionsMap.bottom.top + tipHeight + anchorSize.height, pointer.x - tipWidth / 2), 'left':new R(pointer.y - tipHeight / 2, constrainRegionsMap.left.right - anchorSize.width, pointer.y + tipHeight / 
      2, constrainRegionsMap.left.right - tipWidth - anchorSize.width), 'right':new R(pointer.y - tipHeight / 2, constrainRegionsMap.right.left + tipWidth + anchorSize.width, pointer.y - tipHeight / 2, constrainRegionsMap.right.left + anchorSize.width)};
      anchoredTipRegionsMap = {'top':new R(constrainRegionsMap.top.bottom - tipHeight - anchorSize.height, pointer.x + tipWidth / 2, constrainRegionsMap.top.bottom, pointer.x - tipWidth / 2), 'bottom':new R(constrainRegionsMap.bottom.top, pointer.x + tipWidth / 2, constrainRegionsMap.bottom.top + tipHeight + anchorSize.height, pointer.x - tipWidth / 2), 'left':new R(pointer.y - tipHeight / 2, constrainRegionsMap.left.right, pointer.y + tipHeight / 2, constrainRegionsMap.left.right - tipWidth - anchorSize.width), 
      'right':new R(pointer.y - tipHeight / 2, constrainRegionsMap.right.left + tipWidth + anchorSize.width, pointer.y - tipHeight / 2, constrainRegionsMap.right.left)};
      switch(anchor.charAt(0)) {
        case 't':
          regionsQueue = ['top', 'bottom', rtl ? 'right' : 'left', rtl ? 'left' : 'right'];
          break;
        case 'r':
          regionsQueue = ['right', 'left', 'top', 'bottom'];
          break;
        case 'b':
          regionsQueue = ['bottom', 'top', rtl ? 'right' : 'left', rtl ? 'left' : 'right'];
          break;
        case 'l':
          regionsQueue = ['left', 'right', 'top', 'bottom'];
          break;
        default:
      }
      fitRegionName = Ext.Array.findBy(regionsQueue, function(region) {
        var cr = constrainRegionsMap[region], atr = anchoredTipRegionsMap[region];
        return canContain(cr, atr);
      });
      if (fitRegionName) {
        fitConstrainRegion = constrainRegionsMap[fitRegionName];
        fitAnchoredTipRegion = anchoredTipRegionsMap[fitRegionName];
        fitTipRegion = tipRegionsMap[fitRegionName];
        if (fitConstrainRegion.contains(fitAnchoredTipRegion)) {
          tipAnchorOffset = 0;
          xy = [fitTipRegion.x, fitTipRegion.y];
        } else {
          constrainVector = me.getConstrainVector(fitAnchoredTipRegion);
          xy = me.getXY();
          xy = [xy[0] + constrainVector[0], xy[1] + constrainVector[1]];
          me.setXY(xy);
          constrainVector = me.getConstrainVector(fitConstrainRegion);
          if (fitRegionName == 'left' || fitRegionName == 'right') {
            tipAnchorOffset = -constrainVector[1];
          } else {
            if (fitRegionName == 'top' || fitRegionName == 'bottom') {
              tipAnchorOffset = -constrainVector[0];
            }
          }
          xy = [xy[0] + constrainVector[0], xy[1] + constrainVector[1]];
        }
        switch(fitRegionName) {
          case 'top':
            me.tipAnchor = 'bottom';
            me.anchorOffset = numConstrain(tipWidth / 2 - 20 + tipAnchorOffset, 0, tipWidth - 40);
            break;
          case 'right':
            me.tipAnchor = 'left';
            me.anchorOffset = numConstrain(tipHeight / 2 - 12 + tipAnchorOffset, 0, tipHeight - 24);
            break;
          case 'bottom':
            me.tipAnchor = 'top';
            me.anchorOffset = numConstrain(tipWidth / 2 - 20 + tipAnchorOffset, 0, tipWidth - 40);
            break;
          case 'left':
            me.tipAnchor = 'right';
            me.anchorOffset = numConstrain(tipHeight / 2 - 12 + tipAnchorOffset, 0, tipHeight - 24);
            break;
        }
        me.anchorEl.removeCls(Ext.Array.map(regionsQueue, function(pos) {
          return 'x-tip-anchor-' + pos;
        }));
        me.anchorEl.addCls('x-tip-anchor-' + me.tipAnchor);
        me.syncAnchor();
        me.setXY(xy);
      } else {
      }
    }
  }});
});
Ext.cmd.derive('Sch.mixin.TimelineView', Sch.mixin.AbstractTimelineView, {tip:null, overScheduledEventClass:'sch-event-hover', ScheduleBarEvents:['mousedown', 'mouseup', 'click', 'dblclick', 'longpress', 'contextmenu'], ResourceRowEvents:['keydown', 'keyup'], preventOverCls:false, hoveredEventNode:null, _initializeTimelineView:function() {
  Sch.mixin.AbstractTimelineView.prototype._initializeTimelineView.apply(this, arguments);
  this.on('destroy', this._onDestroy, this);
  this.on('afterrender', this._onAfterRender, this);
  this.setMode(this.mode);
  this.enableBubble('columnwidthchange');
  this.addCls('sch-timelineview');
  if (this.readOnly) {
    this.addCls(this._cmpCls + '-readonly');
  }
  this.addCls(this._cmpCls);
  if (this.eventAnimations) {
    this.addCls('sch-animations-enabled');
  }
}, handleScheduleBarEvent:function(e, eventBarNode) {
  this.fireEvent(this.scheduledEventName + e.type, this, this.resolveEventRecord(eventBarNode), e);
}, handleResourceRowEvent:function(e, resourceRowNode) {
  this.fireEvent(this.scheduledEventName + e.type, this, this.resolveEventRecordFromResourceRow(resourceRowNode), e);
}, _onDestroy:function() {
  if (this.tip) {
    this.tip.destroy();
  }
}, _onAfterRender:function() {
  if (this.overScheduledEventClass) {
    this.setMouseOverEnabled(true);
  }
  if (this.tooltipTpl) {
    if (typeof this.tooltipTpl === 'string') {
      this.tooltipTpl = new Ext.XTemplate(this.tooltipTpl);
    }
    this.el.on('mousemove', this.setupTooltip, this, {single:true});
  }
  var bufferedRenderer = this.bufferedRenderer;
  if (bufferedRenderer) {
    this.patchBufferedRenderingPlugin(bufferedRenderer);
    this.patchBufferedRenderingPlugin(this.lockingPartner.bufferedRenderer);
  }
  this.setupTimeCellEvents();
  var eventBarListeners = {delegate:this.eventSelector, scope:this};
  var resourceRowListeners = {delegate:this.rowSelector, scope:this};
  Ext.Array.each(this.ScheduleBarEvents, function(name) {
    eventBarListeners[name] = this.handleScheduleBarEvent;
  }, this);
  Ext.Array.each(this.ResourceRowEvents, function(name) {
    resourceRowListeners[name] = this.handleResourceRowEvent;
  }, this);
  this.el.on(eventBarListeners);
  this.el.on(resourceRowListeners);
}, patchBufferedRenderingPlugin:function(plugin) {
  var me = this;
  var oldSetBodyTop = plugin.setBodyTop;
  if (typeof oldSetBodyTop !== 'function') {
    throw new Error('oldSetBodyTop method missing');
  }
  plugin.setBodyTop = function(bodyTop, calculatedTop) {
    var val = oldSetBodyTop.apply(this, arguments);
    me.fireEvent('bufferedrefresh', this);
    return val;
  };
}, setMouseOverEnabled:function(enabled) {
  this[enabled ? 'mon' : 'mun'](this.el, {mouseover:this.onEventMouseOver, mouseout:this.onEventMouseOut, delegate:this.eventSelector, scope:this});
  if (!enabled) {
    this.getEl().select('.' + this.overScheduledEventClass).removeCls(this.overScheduledEventClass);
  }
}, onEventMouseOver:function(e, t) {
  if (t !== this.hoveredEventNode && !this.preventOverCls) {
    this.hoveredEventNode = t;
    Ext.fly(t).addCls(this.overScheduledEventClass);
    var eventModel = this.resolveEventRecord(t);
    if (eventModel) {
      this.fireEvent('eventmouseenter', this, eventModel, e);
    }
  }
}, onEventMouseOut:function(e, t) {
  if (this.hoveredEventNode) {
    if (!e.within(this.hoveredEventNode, true, true)) {
      Ext.fly(this.hoveredEventNode).removeCls(this.overScheduledEventClass);
      this.fireEvent('eventmouseleave', this, this.resolveEventRecord(this.hoveredEventNode), e);
      this.hoveredEventNode = null;
    }
  }
}, highlightItem:function(item) {
  if (item) {
    var me = this;
    me.clearHighlight();
    me.highlightedItem = item;
    Ext.fly(item).addCls(me.overItemCls);
  }
}, setupTooltip:function() {
  var me = this, target = me.getEl();
  me.tip = new Sch.tooltip.EventTip(Ext.apply({view:me, delegate:me.eventSelector, target:target, dismissDelay:0, constrainTo:me.grid.getEl(), rtl:me.rtl}, me.tipCfg));
  if (Ext.supports.Touch) {
    me.el.un({touchmove:me.setupTooltip, mousemove:me.setupTooltip, scope:me});
  }
}, getHorizontalTimeAxisColumn:function() {
  if (!this.timeAxisColumn) {
    this.timeAxisColumn = this.headerCt.down('timeaxiscolumn');
    if (this.timeAxisColumn) {
      this.timeAxisColumn.on('destroy', function() {
        this.timeAxisColumn = null;
      }, this);
    }
  }
  return this.timeAxisColumn;
}, getDataForTooltipTpl:function(record, triggerElement) {
  return Ext.apply({_record:record}, record.data);
}, refreshKeepingScroll:function() {
  Ext.suspendLayouts();
  this.blockRestoringInfiniteScrollDate();
  this.refreshView();
  Ext.resumeLayouts(true);
  this.resumeRestoringInfiniteScrollDate();
}, setupTimeCellEvents:function() {
  this.mon(this.el, {click:this.handleScheduleEvent, dblclick:this.handleScheduleEvent, contextmenu:this.handleScheduleEvent, longpress:this.handleScheduleEvent, pinch:this.handleScheduleEvent, pinchstart:this.handleScheduleEvent, pinchend:this.handleScheduleEvent, scope:this});
}, getTableRegion:function() {
  var tableEl = this.el.down('.x-grid-item-container');
  return (tableEl || this.el).getRegion();
}, getRowNode:function(resourceRecord) {
  return this.getNodeByRecord(resourceRecord);
}, findRowByChild:function(t) {
  return this.findItemByChild(t);
}, getRecordForRowNode:function(node) {
  return this.getRecord(node);
}, refreshKeepingResourceScroll:function() {
  var scroll = this.getScroll();
  this.refreshView();
  if (this.isHorizontal()) {
    this.scrollVerticallyTo(scroll.top);
  } else {
    this.scrollHorizontallyTo(scroll.left);
  }
}, scrollHorizontallyTo:function(x, animate) {
  if (this.rendered) {
    this.scrollTo(x, null, animate);
  }
}, scrollVerticallyTo:function(y, animate) {
  if (this.rendered) {
    this.scrollTo(null, y, animate);
  }
}, getVerticalScroll:function() {
  return this.getScrollY();
}, getHorizontalScroll:function() {
  return this.getScrollX();
}, getScroll:function() {
  var me = this;
  return {top:me.getVerticalScroll(), left:me.getHorizontalScroll()};
}, handleScheduleEvent:function() {
}, disableViewScroller:function(disabled) {
  var scroller = this.getScrollable();
  if (scroller) {
    if (scroller.setDisabled) {
      scroller.setDisabled(disabled);
    } else {
      var verticalScroller = this.up('timelinetree,timelinegrid').getScrollable();
      scroller.setConfig({x:!disabled, y:!disabled});
      verticalScroller.setConfig({x:!disabled, y:!disabled});
    }
  }
}, shouldAdjustForRtl:function() {
  return this.rtl && !Ext.rootInheritedState.rtl;
}, getHorizontalPositionSide:function() {
  return this.rtl ? 'right' : 'left';
}, getViewContainerElementTop:function() {
  var el;
  if (Ext.versions.extjs.isGreaterThan('6.2.0')) {
    el = this.up('timelinegrid,timelinetree').getView().el;
  } else {
    el = this.getEl();
  }
  return el.getY();
}, getViewContainerHeight:function() {
  if (Ext.versions.extjs.isGreaterThan('6.2.0')) {
    return this.up('timelinegrid,timelinetree').getView().el.getHeight();
  }
  return this.getHeight();
}, getScrollableMaxPosition:function() {
  return {x:this.getScrollable().getMaxPosition().x, y:this.getVerticalScrollableMaxHeight()};
}, getVerticalScrollableMaxHeight:function() {
  var scrollable;
  if (Ext.getVersion().isGreaterThan('6.2.0')) {
    scrollable = this.up('timelinegrid,timelinetree').getScrollable();
  } else {
    scrollable = this.getScrollable();
  }
  return scrollable.getMaxPosition().y;
}, getScrollableContainerRegion:function() {
  var region = this.getEl().getRegion();
  if (Ext.versions.extjs.isGreaterThan('6.2.0')) {
    region.top = this.up('timelinegrid, timelinetree').getScrollable().getElement().getY();
  }
  return new Ext.util.Region(region.top, region.right, region.top + this.getViewContainerHeight(), region.left);
}, scrollHorizontallyBy:function(deltaX, options) {
  this.scrollBy(deltaX, null, options);
}, scrollVerticallyBy:function(deltaY, options) {
  var scrollable;
  if (Ext.versions.extjs.isGreaterThan('6.2.0')) {
    scrollable = this.up('timelinegrid, timelinetree').getScrollable();
  } else {
    scrollable = this.getScrollable();
  }
  scrollable.scrollBy(0, deltaY, options);
}, scrollElementIntoView:function(el, hscroll, animate, highlight, edgeOffset, callback, scope) {
  var me = this, dom = el.dom, scroll = me.getScroll(), scrollX = scroll.left, scrollY = scroll.top, position = me.getScrollIntoViewXY(el, scrollX, scrollY, edgeOffset), newScrollX = position.x, newScrollY = position.y, x, y;
  x = hscroll !== false ? newScrollX : scrollX;
  y = newScrollY;
  if (x !== scrollX || y !== scrollY) {
    me.on({scrollend:{fn:function() {
      highlight && el.dom && el.highlight();
      callback && callback.call(scope);
    }, scope:me, single:true}});
    me.scrollTo(x, y, animate);
  } else {
    callback && callback.call(scope);
  }
  return me;
}, getScrollIntoViewXY:function(el, scrollX, scrollY, edgeOffset) {
  edgeOffset = Ext.isEmpty(edgeOffset) ? 20 : edgeOffset;
  var me = this, ct = Ext.getVersion().isGreaterThan('6.2.0') ? Ext.getDom(me.ownerCt.getEl()) : Ext.getDom(me.getEl()), dom = el.dom, offsets = el.getOffsetsTo(ct), width = dom.offsetWidth, height = dom.offsetHeight, left = offsets[0] + scrollX, top = offsets[1] + scrollY, bottom = top + height, right = left + width, viewHeight = ct.clientHeight, viewWidth = ct.clientWidth, viewLeft = scrollX, viewTop = scrollY, viewBottom = viewTop + viewHeight, viewRight = viewLeft + viewWidth;
  if (height > viewHeight || top < viewTop) {
    scrollY = top - edgeOffset;
  } else {
    if (bottom > viewBottom) {
      scrollY = bottom - viewHeight + edgeOffset;
    }
  }
  if (width > viewWidth || left < viewLeft) {
    scrollX = left - edgeOffset;
  } else {
    if (right > viewRight) {
      scrollX = right - viewWidth + edgeOffset;
    }
  }
  return {x:scrollX, y:scrollY};
}}, 0, 0, 0, 0, 0, 0, [Sch.mixin, 'TimelineView'], 0);
Ext.cmd.derive('Sch.view.TimelineGridView', Ext.grid.View, {infiniteScroll:false, bufferCoef:5, bufferThreshold:0.2, cachedScrollDate:null, boxIsReady:false, ignoreNextHorizontalScroll:false, constructor:function(config) {
  Ext.view.Table.prototype.constructor.apply(this, arguments);
  if (this.infiniteScroll) {
    this.on('boxready', this.setupInfiniteScroll, this);
  }
  if (this.timeAxisViewModel) {
    this.relayEvents(this.timeAxisViewModel, ['columnwidthchange']);
  }
}, setupInfiniteScroll:function() {
  var planner = this.panel.ownerCt;
  this.cachedScrollDate = planner.startDate || this.timeAxis.getStart();
  if (Ext.getVersion().isLessThan('6.0.1') && Ext.supports.Touch && Ext.os.is.Windows) {
    var headerScroll = this.panel.headerCt.getScrollable();
    var viewScroll = this.getScrollable();
    headerScroll.onIdle && Ext.GlobalEvents.un('idle', headerScroll.onIdle, headerScroll);
    viewScroll.onIdle && Ext.GlobalEvents.un('idle', viewScroll.onIdle, viewScroll);
  }
  var me = this;
  planner.calculateOptimalDateRange = function(centerDate, panelSize, nextZoomLevel, span) {
    if (span) {
      return span;
    }
    var preset = Sch.preset.Manager.getPreset(nextZoomLevel.preset);
    return me.calculateInfiniteScrollingDateRange(centerDate, preset.getBottomHeader().unit, nextZoomLevel.increment, nextZoomLevel.width, true);
  };
  this.bindInfiniteScrollListeners();
}, bindInfiniteScrollListeners:function() {
  this.getScrollable().on('scroll', this.onHorizontalScroll, this);
  this.infiniteScroll = true;
}, unbindInfiniteScrollListeners:function() {
  this.getScrollable().un('scroll', this.onHorizontalScroll, this);
  this.infiniteScroll = false;
}, onHorizontalScroll:function(scrollable, scrollLeft, scrollTop) {
  if (this.ignoreNextHorizontalScroll || this.cachedScrollDate) {
    this.ignoreNextHorizontalScroll = false;
    return;
  }
  var scrollbarSize = Ext.getScrollbarSize(), width = this.getWidth(), limit = width * this.bufferThreshold * this.bufferCoef, scrollWidth = this.getScrollable().getMaxPosition().x;
  scrollWidth -= scrollbarSize.width;
  if (scrollWidth - scrollLeft < limit || scrollLeft < limit) {
    this.shiftToDate(this.getDateFromCoordinate(scrollLeft, null, true));
    if (Ext.getVersion().isGreaterThan('6.2.0')) {
      var translatable = this.getScrollable()._translatable || this.getScrollable().translatable;
      translatable && translatable.stopAnimation();
    } else {
      this.el.stopAnimation();
    }
  }
}, refresh:function() {
  Ext.view.Table.prototype.refresh.apply(this, arguments);
  if (this.infiniteScroll && !this.scrollStateSaved && this.boxIsReady) {
    this.restoreScrollToCachedDate();
  }
}, onResize:function(width, height, oldWidth, oldHeight) {
  this.boxIsReady = true;
  Ext.view.Table.prototype.onResize.apply(this, arguments);
  if (this.infiniteScroll && width > 0 && width !== oldWidth) {
    this.shiftToDate(this.cachedScrollDate || this.getVisibleDateRange().startDate, this.cachedScrollDateIsCentered);
  }
}, restoreScrollToCachedDate:function() {
  if (this.cachedScrollDate && this.boxIsReady) {
    this.ignoreNextHorizontalScroll = true;
    this.scrollToDate(this.cachedScrollDate);
    this.cachedScrollDate = null;
  }
}, scrollToDate:function(toDate) {
  this.cachedScrollDate = toDate;
  if (this.cachedScrollDateIsCentered) {
    this.panel.ownerCt.scrollToDateCentered(toDate);
  } else {
    this.panel.ownerCt.scrollToDate(toDate);
  }
  var scrollLeft = this.getScrollX();
  this.panel.scrollLeftPos = scrollLeft;
  this.headerCt.setScrollX(scrollLeft);
  if (Ext.getVersion().isGreaterThan('6.2.0')) {
    this.up('timelinegrid,timelinetree').lastScrollPos.x = scrollLeft;
  }
}, blockRestoringInfiniteScrollDate:function() {
  this.scrollStateSaved = this.boxIsReady;
}, resumeRestoringInfiniteScrollDate:function() {
  this.scrollStateSaved = false;
  if (this.infiniteScroll && this.cachedScrollDate) {
    this.restoreScrollToCachedDate();
  }
}, calculateInfiniteScrollingDateRange:function(date, unit, increment, tickWidth, centered) {
  var timeAxis = this.timeAxis, viewWidth = this.getWidth(), result;
  tickWidth = tickWidth || this.timeAxisViewModel.getTickWidth();
  increment = increment || timeAxis.increment || 1;
  unit = unit || timeAxis.unit;
  var DATE = Sch.util.Date;
  var bufferedTicks = Math.ceil(viewWidth * this.bufferCoef / tickWidth);
  if (centered) {
    var halfSpan = Math.ceil(viewWidth * (1 + this.bufferCoef) / (2 * tickWidth)) * increment;
    result = {start:timeAxis.floorDate(DATE.add(date, unit, -halfSpan), false, unit, increment), end:timeAxis.ceilDate(DATE.add(date, unit, halfSpan), false, unit, increment)};
  } else {
    result = {start:timeAxis.floorDate(DATE.add(date, unit, -bufferedTicks * increment), false, unit, increment), end:timeAxis.ceilDate(DATE.add(date, unit, Math.ceil((viewWidth / tickWidth + bufferedTicks) * increment)), false, unit, increment)};
  }
  return result;
}, shiftToDate:function(date, centered) {
  var newRange = this.calculateInfiniteScrollingDateRange(date, null, null, null, centered);
  this.cachedScrollDate = date;
  this.cachedScrollDateIsCentered = centered;
  this.timeAxis.setTimeSpan(newRange.start, newRange.end);
}, destroy:function() {
  if (this.infiniteScroll && this.rendered) {
    this.unbindInfiniteScrollListeners();
  }
  Ext.view.Table.prototype.destroy.apply(this, arguments);
}}, 1, 0, ['component', 'box', 'dataview', 'tableview', 'gridview'], {'component':true, 'box':true, 'dataview':true, 'tableview':true, 'gridview':true}, 0, [[Sch.mixin.TimelineView.prototype.mixinId || Sch.mixin.TimelineView.$className, Sch.mixin.TimelineView]], [Sch.view, 'TimelineGridView'], 0);
Ext.cmd.derive('Sch.patches.DragDropManager', Sch.util.Patch, {target:'Ext.dd.DragDropManager', minVersion:'6.0.0', applyFn:function() {
  Ext.override(Ext.dd.DragDropManager, {fireEvents:function(e, isDrop) {
    var me = this, isTouch = Ext.supports.Touch, dragCurrent = me.dragCurrent, mousePoint = me.currentPoint, currentX = mousePoint.x, currentY = mousePoint.y, allTargets = [], oldOvers = [], outEvts = [], overEvts = [], dropEvts = [], enterEvts = [], zoom = isTouch ? document.documentElement.clientWidth / window.innerWidth : 1, dragEl, overTarget, overTargetEl, needsSort, i, len, sGroup, overDragEl;
    if (!dragCurrent || dragCurrent.isLocked()) {
      return;
    }
    overDragEl = !(dragCurrent.deltaX < 0 || dragCurrent.deltaY < 0);
    if (isTouch || !me.notifyOccluded && (!Ext.supports.CSSPointerEvents || Ext.isIE10m || Ext.isOpera) && overDragEl) {
      dragEl = dragCurrent.getDragEl();
      if (overDragEl) {
        dragEl.style.visibility = 'hidden';
      }
      var bodyScroll = Ext.getBody().getScroll();
      e.target = document.elementFromPoint(currentX - bodyScroll.left / zoom, currentY - bodyScroll.top / zoom);
      if (overDragEl) {
        dragEl.style.visibility = 'visible';
      }
    }
    for (i in me.dragOvers) {
      overTarget = me.dragOvers[i];
      delete me.dragOvers[i];
      if (!me.isTypeOfDD(overTarget) || overTarget.destroyed) {
        continue;
      }
      if (me.notifyOccluded) {
        if (!this.isOverTarget(mousePoint, overTarget, me.mode)) {
          outEvts.push(overTarget);
        }
      } else {
        if (!e.within(overTarget.getEl())) {
          outEvts.push(overTarget);
        }
      }
      oldOvers[i] = true;
    }
    for (sGroup in dragCurrent.groups) {
      if ('string' !== typeof sGroup) {
        continue;
      }
      for (i in me.ids[sGroup]) {
        overTarget = me.ids[sGroup][i];
        if (me.isTypeOfDD(overTarget) && (overTargetEl = overTarget.getEl()) && overTarget.isTarget && !overTarget.isLocked() && Ext.fly(overTargetEl).isVisible(true) && (overTarget !== dragCurrent || dragCurrent.ignoreSelf === false)) {
          if (me.notifyOccluded) {
            if ((overTarget.zIndex = me.getZIndex(overTargetEl)) !== -1) {
              needsSort = true;
            }
            allTargets.push(overTarget);
          } else {
            if (e.within(overTarget.getEl())) {
              allTargets.push(overTarget);
              break;
            }
          }
        }
      }
    }
    if (needsSort) {
      Ext.Array.sort(allTargets, me.byZIndex);
    }
    for (i = 0, len = allTargets.length; i < len; i++) {
      overTarget = allTargets[i];
      if (me.isOverTarget(mousePoint, overTarget, me.mode)) {
        if (isDrop) {
          dropEvts.push(overTarget);
        } else {
          if (!oldOvers[overTarget.id]) {
            enterEvts.push(overTarget);
          } else {
            overEvts.push(overTarget);
          }
          me.dragOvers[overTarget.id] = overTarget;
        }
        if (!me.notifyOccluded) {
          break;
        }
      }
    }
    if (me.mode) {
      if (outEvts.length) {
        dragCurrent.b4DragOut(e, outEvts);
        dragCurrent.onDragOut(e, outEvts);
      }
      if (enterEvts.length) {
        dragCurrent.onDragEnter(e, enterEvts);
      }
      if (overEvts.length) {
        dragCurrent.b4DragOver(e, overEvts);
        dragCurrent.onDragOver(e, overEvts);
      }
      if (dropEvts.length) {
        dragCurrent.b4DragDrop(e, dropEvts);
        dragCurrent.onDragDrop(e, dropEvts);
      }
    } else {
      for (i = 0, len = outEvts.length; i < len; ++i) {
        dragCurrent.b4DragOut(e, outEvts[i].id);
        dragCurrent.onDragOut(e, outEvts[i].id);
      }
      for (i = 0, len = enterEvts.length; i < len; ++i) {
        dragCurrent.onDragEnter(e, enterEvts[i].id, enterEvts[i]);
      }
      for (i = 0, len = overEvts.length; i < len; ++i) {
        dragCurrent.b4DragOver(e, overEvts[i].id);
        dragCurrent.onDragOver(e, overEvts[i].id);
      }
      for (i = 0, len = dropEvts.length; i < len; ++i) {
        dragCurrent.b4DragDrop(e, dropEvts[i].id);
        dragCurrent.onDragDrop(e, dropEvts[i].id);
      }
    }
    if (isDrop && !dropEvts.length) {
      dragCurrent.onInvalidDrop(e);
    }
  }});
  Ext.override(Ext.dd.DragSource, {onDragEnter:function(e, id, forceTarget) {
    this.forceCachedTarget = forceTarget;
    return this.callParent([e, id]);
  }, beforeDragEnter:function(target, e, id) {
    if (this.forceCachedTarget) {
      target = this.cachedTarget = this.forceCachedTarget;
      delete this.forceCachedTarget;
    }
    return this.callParent([target, e, id]);
  }});
  var sm = Ext.dd.ScrollManager;
  var ddm = Ext.dd.DragDropManager;
  ddm.fireEvents = Ext.Function.createSequence(ddm.fireEvents, sm.onFire, sm);
  ddm.stopDrag = Ext.Function.createSequence(ddm.stopDrag, sm.onStop, sm);
}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'DragDropManager'], 0);
Ext.cmd.derive('Sch.patches.NavigationModel', Sch.util.Patch, {target:'Ext.grid.NavigationModel', minVersion:'6.0.0', overrides:{setPosition:function(recordIndex, columnIndex, keyEvent, suppressEvent, preventNavigation) {
  var me = this;
  if (Ext.isIE && keyEvent && (keyEvent.getKey() === keyEvent.PAGE_DOWN || keyEvent.getKey() === keyEvent.PAGE_UP)) {
    var lastFocused = me.lastFocused;
    if (keyEvent.view.isLockedView && lastFocused && keyEvent.view.getVisibleColumnManager().indexOf(lastFocused.column) === -1) {
      keyEvent.view = keyEvent.view.lockingPartner;
    }
  }
  if (Ext.getVersion().equals('6.0.1.250')) {
    me.patchedSetPosition.apply(this, arguments);
  } else {
    return me.callParent(arguments);
  }
}, patchedSetPosition:function(recordIndex, columnIndex, keyEvent, suppressEvent, preventNavigation) {
  var me = this, view, scroller, selModel, dataSource, columnManager, newRecordIndex, newColumnIndex, newRecord, newColumn, clearing = recordIndex == null && columnIndex == null, isClear = me.record == null && me.recordIndex == null && me.item == null;
  if (recordIndex && recordIndex.isCellContext) {
    view = recordIndex.view;
  } else {
    if (keyEvent && keyEvent.view) {
      view = keyEvent.view;
    } else {
      if (me.lastFocused) {
        view = me.lastFocused.view;
      } else {
        view = me.view;
      }
    }
  }
  view.getFocusTask().cancel();
  if (view.destroyed || !view.refreshCounter || !view.ownerCt || clearing && isClear || !view.all.getCount()) {
    return;
  }
  selModel = view.getSelectionModel();
  dataSource = view.dataSource;
  columnManager = view.getVisibleColumnManager();
  if (recordIndex && recordIndex.isCellContext) {
    newRecord = recordIndex.record;
    newRecordIndex = recordIndex.rowIdx;
    newColumnIndex = Math.min(recordIndex.colIdx, columnManager.getColumns().length - 1);
    newColumn = columnManager.getColumns()[newColumnIndex];
    if (dataSource.indexOf(newRecord) === -1) {
      scroller = view.getScrollable();
      me.recordIndex = -1;
      if (scroller.getPosition().y >= scroller.getMaxPosition().y - view.all.last(true).offsetHeight) {
        recordIndex.rowIdx--;
      }
      newRecordIndex = Math.min(recordIndex.rowIdx, dataSource.getCount() - 1);
      newRecord = dataSource.getAt(newRecordIndex);
    }
  } else {
    if (clearing) {
      newRecord = newRecordIndex = null;
    } else {
      if (columnIndex == null) {
        columnIndex = me.lastFocused ? me.lastFocused.column : 0;
      }
      if (typeof recordIndex === 'number') {
        newRecordIndex = Math.max(Math.min(recordIndex, dataSource.getCount() - 1), 0);
        newRecord = dataSource.getAt(recordIndex);
      } else {
        if (recordIndex.isEntity) {
          newRecord = recordIndex;
          newRecordIndex = dataSource.indexOf(newRecord);
        } else {
          if (recordIndex.tagName) {
            newRecord = view.getRecord(recordIndex);
            newRecordIndex = dataSource.indexOf(newRecord);
            if (newRecordIndex === -1) {
              newRecord = null;
            }
          } else {
            if (isClear) {
              return;
            }
            clearing = true;
            newRecord = newRecordIndex = null;
          }
        }
      }
    }
    if (newRecord) {
      if (newRecordIndex === -1) {
        me.recordIndex = -1;
        newRecord = dataSource.getAt(0);
        newRecordIndex = 0;
        columnIndex = null;
      }
      if (columnIndex == null) {
        if (!(newColumn = me.column)) {
          newColumnIndex = 0;
          newColumn = columnManager.getColumns()[0];
        }
      } else {
        if (typeof columnIndex === 'number') {
          newColumn = columnManager.getColumns()[columnIndex];
          newColumnIndex = columnIndex;
        } else {
          newColumn = columnIndex;
          newColumnIndex = columnManager.indexOf(columnIndex);
        }
      }
    } else {
      clearing = true;
      newColumn = newColumnIndex = null;
    }
  }
  if (view.actionableMode && !clearing) {
    var newPosition = (new Ext.grid.CellContext(view)).setPosition(newRecord, newColumn);
    me.focusPosition(newPosition);
    return view.ownerGrid.setActionableMode(false, newPosition);
  }
  if (newRecordIndex === me.recordIndex && newColumnIndex === me.columnIndex && view === me.position.view) {
    return me.focusPosition(me.position);
  }
  if (me.cell) {
    me.cell.removeCls(me.focusCls);
  }
  me.previousRecordIndex = me.recordIndex;
  me.previousRecord = me.record;
  me.previousItem = me.item;
  me.previousCell = me.cell;
  me.previousColumn = me.column;
  me.previousColumnIndex = me.columnIndex;
  me.previousPosition = me.position.clone();
  me.selectionStart = selModel.selectionStart;
  me.position.setAll(view, me.recordIndex = newRecordIndex, me.columnIndex = newColumnIndex, me.record = newRecord, me.column = newColumn);
  if (clearing) {
    me.item = me.cell = null;
  } else {
    me.focusPosition(me.position, preventNavigation);
  }
  if (!suppressEvent) {
    selModel.fireEvent('focuschange', selModel, me.previousRecord, me.record);
    view.fireEvent('rowfocus', me.record, me.item, me.recordIndex);
    view.fireEvent('cellfocus', me.record, me.cell, me.position);
  }
  if (keyEvent && !preventNavigation && me.cell !== me.previousCell) {
    me.fireNavigateEvent(keyEvent);
  }
}, onCellClick:function(view, cell, cellIndex, record, row, recordIndex, clickEvent) {
  this.callParent(arguments);
  if (clickEvent.position.column.cellFocusable === false) {
    if (view.isNormalView) {
      if (Ext.isIE11m) {
        view.ownerCt.el.focus();
      } else {
        if (this.lastFocused) {
          this.focusPosition(this.lastFocused, true);
        } else {
          view.el.focus();
        }
      }
    }
  }
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'NavigationModel'], 0);
Ext.cmd.derive('Sch.view.WeekView', Ext.Base, {view:null, constructor:function(config) {
  Ext.apply(this, config);
}, getElementsFromEventRecord:function(eventRecord, resourceRecord, index, raw) {
  var view = this.view, query;
  raw = raw || false;
  if (index !== null && index !== undefined) {
    query = '[id^\x3d' + view.eventPrefix + eventRecord.internalId + '-calendar-' + index + '-]';
  } else {
    query = '[id^\x3d' + view.eventPrefix + eventRecord.internalId + '-calendar-]';
  }
  return view.getEl().query(query, raw);
}, getColumnsBy:function(conditionFn, includeIndex) {
  var columns = this.view.panel.headerCt.getGridColumns();
  var result = [];
  for (var i = 0; i < columns.length; i++) {
    if (conditionFn.call(this, columns[i])) {
      if (includeIndex !== true) {
        result.push(columns[i]);
      } else {
        result.push({column:columns[i], index:i});
      }
    }
  }
  return result;
}, getColumnsForDateRange:function(range, includeIndex) {
  return this.getColumnsBy(function(column) {
    return !(range.getEndDate() <= column.start || range.getStartDate() >= column.end);
  }, includeIndex);
}, getColumnEvents:function(column) {
  var result = [];
  this.view.getEventStore().each(function(record) {
    if (!(record.getEndDate() <= column.start || record.getStartDate() >= column.end)) {
      result.push(record);
    }
  });
  return result;
}, getColumnsByResource:function(resource, includeIndex) {
  return this.getColumnsBy(function(column) {
    return column.start == resource.start;
  }, includeIndex)[0];
}, translateToScheduleCoordinate:function(coord) {
  var view = this.view;
  if (Ext.isArray(coord)) {
    return [coord[0] - view.getEl().getX() + view.getHorizontalScroll(), coord[1] - view.getViewContainerElementTop() + view.getVerticalScroll()];
  } else {
    return coord - view.getViewContainerElementTop() + view.getVerticalScroll();
  }
}, translateToPageCoordinate:function(coord) {
  var view = this.view;
  var el = view.getEl();
  if (Ext.isArray(coord)) {
    return [coord[0] + el.getX() - view.getHorizontalScroll(), coord[1] + view.getViewContainerElementTop() - view.getVerticalScroll()];
  } else {
    return coord + view.getViewContainerElementTop() - view.getVerticalScroll();
  }
}, getDateFromXY:function(xy, roundingMethod, local) {
  var coord = xy;
  if (!local) {
    coord = this.translateToScheduleCoordinate(coord);
  }
  return this.view.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
}, getEventRenderData:function(event, resource, resourceIndex) {
  var eventStart = event.getStartDate(), eventEnd = event.getEndDate(), view = this.view, columns = view.panel.headerCt.getGridColumns(), viewStart = columns[resourceIndex].start, viewEnd = columns[resourceIndex].end, M = Math;
  var startY = Math.floor(view.getCoordinateFromDate(Sch.util.Date.max(eventStart, viewStart)));
  var endY = Math.floor(view.timeAxisViewModel.getPositionFromDate(Sch.util.Date.min(eventEnd, viewEnd), true));
  var data;
  if (endY === 0) {
    endY = view.getStore().getCount() * view.getRowHeight();
  }
  data = {top:M.max(0, M.min(startY, endY) - view.eventBorderWidth), height:M.max(1, M.abs(startY - endY))};
  data.start = eventStart;
  data.end = eventEnd;
  data.startsOutsideView = eventStart < viewStart;
  data.endsOutsideView = eventEnd > viewEnd;
  return data;
}, getScheduleRegion:function(resourceRecord, eventRecord) {
  var view = this.view, region = resourceRecord ? this.getColumnsByResource(resourceRecord).getRegion() : view.getTableRegion(), startY = this.translateToPageCoordinate(0), endY = this.translateToPageCoordinate(view.getStore().getCount() * view.getRowHeight()), left = region.left + view.barMargin, right = region.right - view.barMargin;
  return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
}, getWeekViewColumnWidth:function() {
  return this.view.timeAxisViewModel.weekViewColumnWidth;
}, getResourceRegion:function(resourceRecord, startDate, endDate) {
  var view = this.view, cellLeft = view.getResourceStore().indexOf(resourceRecord) * this.getWeekViewColumnWidth(), taStart = view.timeAxis.getStart(), taEnd = view.timeAxis.getEnd(), start = startDate ? Sch.util.Date.max(taStart, startDate) : taStart, end = endDate ? Sch.util.Date.min(taEnd, endDate) : taEnd, startY = Math.max(0, view.getCoordinateFromDate(start) - view.cellTopBorderWidth), endY = view.getCoordinateFromDate(end) - view.cellTopBorderWidth, left = cellLeft + view.cellBorderWidth, 
  right = cellLeft + this.getWeekViewColumnWidth() - view.cellBorderWidth;
  return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
}, columnRenderer:function(val, meta, resourceRecord, rowIndex, colIndex) {
  var view = this.view;
  var retVal = '';
  if (rowIndex === 0) {
    var columnEvents, resourceEvents, i, l;
    columnEvents = [];
    resourceEvents = this.getColumnEvents(meta.column);
    for (i = 0, l = resourceEvents.length; i < l; i++) {
      var event = resourceEvents[i];
      columnEvents.push(view.generateTplData(event, event.getResources()[0], colIndex));
    }
    if (meta.column.rendered && this.getWeekViewColumnWidth() !== meta.column.getWidth()) {
      this.setColumnWidth(meta.column.getWidth(), true);
    }
    view.eventLayout.vertical.applyLayout(columnEvents, this.getWeekViewColumnWidth() - 2 * view.barMargin - view.cellBorderWidth);
    retVal = '\x26#160;' + view.eventTpl.apply(columnEvents);
  }
  if (colIndex % 2 === 1) {
    meta.tdCls = (meta.tdCls || '') + ' ' + view.altColCls;
    meta.cellCls = (meta.cellCls || '') + ' ' + view.altColCls;
  }
  return retVal;
}, resolveResource:function(el) {
  var view = this.view;
  el = Ext.fly(el).is(view.timeCellSelector) ? el : Ext.fly(el).up(view.timeCellSelector);
  if (el) {
    var node = el.dom ? el.dom : el;
    var index = 0;
    if (Ext.isIE8m) {
      node = node.previousSibling;
      while (node) {
        if (node.nodeType === 1) {
          index++;
        }
        node = node.previousSibling;
      }
    } else {
      index = Ext.Array.indexOf(Array.prototype.slice.call(node.parentNode.children), node);
    }
    if (index >= 0) {
      var column = view.panel.headerCt.getGridColumns()[index];
      return {start:column.start, end:column.end};
    }
  }
}, onEventUpdate:function(store, model) {
  if (!this.view.rendered || !this.view.headerCt.items.get(0).rendered) {
    return;
  }
  this.renderSingle(model);
  var view = this.view;
  var sm = view.getEventSelectionModel();
  sm.forEachEventRelatedSelection(model, function(selectedRecord) {
    view.onEventBarSelect(selectedRecord);
  });
}, onEventAdd:function(s, recs) {
  if (!this.view.rendered || !this.view.headerCt.items.get(0).rendered) {
    return;
  }
  var view = this.view;
  if (recs.length === 1) {
    this.renderSingle(recs[0]);
  } else {
    view.repaintAllEvents();
  }
}, onEventRemove:function(s, recs) {
  if (!this.view.rendered || !this.view.headerCt.items.get(0).rendered) {
    return;
  }
  var view = this.view;
  if (recs.length === 1) {
    Ext.Array.each(view.getElementsFromEventRecord(recs[0], undefined, undefined, true), function(el) {
      Ext.fly(el).destroy();
    });
    this.relayoutRenderedEvents(recs[0]);
  } else {
    view.repaintAllEvents();
  }
}, relayoutRenderedEvents:function(targetEvent) {
  var me = this, columns = me.getColumnsForDateRange(targetEvent, true);
  Ext.Array.each(columns, function(column) {
    me.repaintEventsForColumn(column.column, column.index);
  });
}, renderSingle:function(event) {
  var view = this.view;
  Ext.Array.each(view.getElementsFromEventRecord(event, undefined, undefined, true), function(el) {
    Ext.fly(el).destroy();
  });
  var previous = event.previous || {};
  var UD = Sch.util.Date;
  var timeSpan = new Sch.model.Range({StartDate:UD.min(previous.StartDate || event.getStartDate(), event.getStartDate()), EndDate:UD.max(previous.EndDate || event.getEndDate(), event.getEndDate())});
  var columns = this.getColumnsForDateRange(timeSpan);
  Ext.Array.each(columns, function(column) {
    var columnIndex = column.getIndex();
    var events = this.getColumnEvents(column);
    var eventRenderData = Ext.Array.map(events, function(record) {
      if (record === event) {
        return view.generateTplData(event, event.getResources()[0], columnIndex);
      } else {
        return {start:record.getStartDate() < column.start ? column.start : record.getStartDate(), end:record.getEndDate() > column.end ? column.end : record.getEndDate(), event:record};
      }
    });
    view.eventLayout.vertical.applyLayout(eventRenderData, column.getWidth() - 2 * view.barMargin - view.cellBorderWidth);
    Ext.Array.each(eventRenderData, function(renderData) {
      if (renderData.event === event) {
        var containerCell = view.getScheduleCell(0, columnIndex);
        if (containerCell) {
          if (!Ext.versions.touch) {
            containerCell = Ext.fly(containerCell).first();
          }
          view.eventTpl.append(containerCell, [renderData]);
        }
      } else {
        var eventNode = view.getElementsFromEventRecord(renderData.event, null, columnIndex)[0];
        if (eventNode) {
          eventNode.setStyle({left:renderData.left + 'px', width:Math.max(renderData.width, 0) + 'px'});
        }
      }
    });
  }, this);
}, repaintEventsForColumn:function(column, index) {
  var me = this;
  var events = me.getColumnEvents(column);
  var view = me.view;
  var data = [], i, l, event, node, start, end;
  for (i = 0, l = events.length; i < l; i++) {
    event = events[i];
    node = view.getElementsFromEventRecord(event, undefined, undefined, true)[0];
    if (!node) {
      return;
    }
    var commonId = node.id.split('-');
    commonId.pop();
    start = event.getStartDate();
    end = event.getEndDate();
    data.push({start:start < column.start ? column.start : start, end:end > column.end ? column.end : end, event:event, id:commonId.join('-')});
  }
  view.eventLayout.vertical.applyLayout(data, column.getWidth() - 2 * view.barMargin - view.cellBorderWidth);
  var rowNode = view.getNode(0);
  for (i = 0; i < data.length; i++) {
    event = data[i];
    node = Ext.DomQuery.selectNode('td:nth-child(' + (index + 1) + ') [id^\x3d' + event.id + '-]', rowNode);
    node && Ext.fly(node).setStyle({left:event.left + 'px', width:Math.max(event.width, 0) + 'px'});
  }
}, getTimeSpanRegion:function(startDate, endDate) {
  var view = this.view, startY = view.getCoordinateFromDate(startDate), endY = endDate ? view.timeAxisViewModel.getPositionFromDate(endDate, true) : startY;
  var startColumn = this.getColumnsBy(function(column) {
    return column.start <= startDate && column.end > startDate;
  })[0];
  var endColumn = this.getColumnsBy(function(column) {
    return column.start < endDate && column.end >= endDate;
  })[0];
  if (!startColumn || !endColumn || !startColumn.rendered || !endColumn.rendered) {
    return new Ext.util.Region(-1, 0, -1, 0);
  }
  var pair1 = this.translateToScheduleCoordinate([startColumn.getX(), 0]);
  var pair2 = this.translateToScheduleCoordinate([endColumn ? endColumn.getRegion().right : startColumn.getWidth() + pair1[0], 0]);
  return new Ext.util.Region(Math.min(startY, endY), pair2[0], Math.max(startY, endY), pair1[0]);
}, getStartEndDatesFromRegion:function(region, roundingMethod) {
  var topDate = this.view.getDateFromCoordinate([region.left, region.top], roundingMethod), bottomDate = this.view.getDateFromCoordinate([region.left, region.bottom], roundingMethod);
  if (topDate && bottomDate) {
    return {start:topDate, end:bottomDate};
  } else {
    return null;
  }
}, setColumnWidth:function(width, preventRefresh) {
  var view = this.view;
  view.weekViewColumnWidth = width;
  view.getTimeAxisViewModel().setViewColumnWidth(width, preventRefresh);
}, getVisibleDateRange:function() {
  var view = this.view;
  if (!view.rendered) {
    return null;
  }
  var scroll = view.getScroll(), height = view.getViewContainerHeight(), tableRegion = view.getTableRegion(), viewEndDate = view.timeAxis.getEnd();
  if (tableRegion.bottom - tableRegion.top < height) {
    var startDate = view.timeAxis.getStart();
    return {startDate:startDate, endDate:viewEndDate};
  }
  return {startDate:view.getDateFromCoordinate(scroll.top, null, true), endDate:view.getDateFromCoordinate(scroll.top + height, null, true) || viewEndDate};
}, getItemBox:function(eventRecord) {
  return null;
}, getConnectorStartSide:function(eventRecord) {
  return 'top';
}, getConnectorEndSide:function(eventRecord) {
  return 'bottom';
}}, 1, 0, 0, 0, 0, 0, [Sch.view, 'WeekView'], 0);
Ext.cmd.derive('Sch.mixin.SchedulerView', Sch.mixin.AbstractSchedulerView, {eventResizeHandles:'end', dndValidatorFn:Ext.emptyFn, resizeValidatorFn:Ext.emptyFn, createValidatorFn:Ext.emptyFn, weekViewClass:'Sch.view.WeekView', lockedGridDependsOnSchedule:null, _initializeSchedulerView:function() {
  Sch.mixin.AbstractSchedulerView.prototype._initializeSchedulerView.apply(this, arguments);
  this.on({destroy:this._destroy, afterrender:this._afterRender, itemupdate:this.onRowUpdated, scope:this});
  this.timeAxis.on('beginreconfigure', this.clearRowHeightCache, this);
  if (Ext.getVersion().isGreaterThan('5.1.1')) {
    this.on('itemadd', function(records) {
      var el = this.all.item(this.all.endIndex - records.length);
      if (el) {
        el.dom.style.height = '';
      }
    });
  }
  var me = this;
  if (!this.eventPrefix) {
    throw 'eventPrefix missing';
  }
  this.on({resourcestorechange:this.clearRowHeightCache, assignmentstorechange:this.clearRowHeightCache, eventstorechange:this.clearRowHeightCache, scope:this});
}, inheritables:function() {
  return {loadingText:this.L('loadingText'), overItemCls:'', trackOver:false, selectedItemCls:'', setReadOnly:function(readOnly) {
    if (this.dragCreator) {
      this.dragCreator.setDisabled(readOnly);
    }
    this.callParent(arguments);
  }, repaintEventsForResource:function(resourceRecord, refreshSelections) {
    var me = this, isHorizontal = me.isHorizontal(), index = isHorizontal ? me.indexOf(resourceRecord) : 0;
    if (isHorizontal) {
      me.eventLayout.horizontal.clearCache(resourceRecord);
    }
    if (index >= 0) {
      Ext.suspendLayouts();
      if (isHorizontal) {
        me.refreshNode(resourceRecord);
        if (me.lockedGridDependsOnSchedule) {
          me.lockingPartner.refreshNode(resourceRecord);
        }
      } else {
        me.refreshNode(index);
      }
      Ext.resumeLayouts();
      if (refreshSelections) {
        var sm = me.getEventSelectionModel();
        var events = me.getEventStore().getEventsForResource(resourceRecord);
        Ext.Array.each(events, function(ev) {
          sm.forEachEventRelatedSelection(ev, function(selectedRecord) {
            me.onEventBarSelect(selectedRecord, true);
          });
        });
      }
    }
  }, repaintAllEvents:function() {
    if (this.isHorizontal()) {
      this.refreshView();
    } else {
      this.refreshNode(0);
    }
  }, handleScheduleEvent:function(e) {
    var te = e.getTarget('.' + this.eventCls, 3), t = !te && e.getTarget('.' + this.timeCellCls, 3);
    if (t) {
      var clickedDate = this.getDateFromDomEvent(e, 'floor');
      var resourceNode = this.findRowByChild(t);
      var index = this.indexOf(resourceNode);
      var resource;
      if (this.isHorizontal()) {
        resource = this.getRecordForRowNode(resourceNode);
      } else {
        var cellNode = e.getTarget(this.timeCellSelector, 5);
        if (cellNode) {
          var cellIndex = typeof cellNode.cellIndex == 'number' ? cellNode.cellIndex : cellNode.getAttribute('data-cellIndex');
          var header = this.headerCt.getGridColumns()[cellIndex];
          resource = header && header.model;
        }
      }
      if (e.type.indexOf('pinch') >= 0) {
        this.fireEvent('schedule' + e.type, this, e);
      } else {
        this.fireEvent('schedule' + e.type, this, clickedDate, index, resource, e);
      }
    }
  }, onEventDataRefresh:function() {
    this.clearRowHeightCache();
    this.callParent(arguments);
  }, onUnbindStore:function(store) {
    store.un({refresh:this.clearRowHeightCache, clear:this.clearRowHeightCache, load:this.clearRowHeightCache, scope:this});
    this.callParent(arguments);
  }, bindStore:function(store) {
    store && store.on({refresh:this.clearRowHeightCache, clear:this.clearRowHeightCache, load:this.clearRowHeightCache, scope:this});
    this.callParent(arguments);
  }, refreshKeepingScroll:function() {
    if (this.rendered) {
      this.lockingPartner.refreshView();
      this.callParent(arguments);
    }
  }};
}, getEventSelectionModel:function() {
  var me = this, mode;
  if (me.eventSelModel && me.eventSelModel.isSelectionModel) {
    return me.eventSelModel;
  }
  if (typeof me.eventSelModel === 'string') {
    me.eventSelModel = {type:me.eventSelModel};
  }
  if (me.simpleSelect) {
    mode = 'SIMPLE';
  } else {
    if (me.multiSelect) {
      mode = 'MULTI';
    } else {
      mode = 'SINGLE';
    }
  }
  me.eventSelModel = Ext.Factory.selection(Ext.apply({type:me.eventSelModelType || (me.getEventStore().getAssignmentStore() ? 'assignmentmodel' : 'eventmodel'), mode:mode, allowDeselect:me.allowDeselect || me.multiSelect, locked:me.disableSelection}, me.eventSelModel));
  return me.eventSelModel;
}, _afterRender:function() {
  this.setEventStore(this.eventStore, true);
  this.getEventSelectionModel().bindToView(this);
  this.setupEventListeners();
  this.configureFunctionality();
  var resizer = this.headerCt.resizer;
  if (resizer) {
    resizer.doResize = Ext.Function.createSequence(resizer.doResize, this.afterHeaderResized, this);
  }
  this.on('itemupdate', function() {
    this.hoveredEventNode = null;
  });
}, _destroy:function() {
  this.setEventStore(null);
}, clearRowHeightCache:function() {
  if (this.isHorizontal()) {
    this.eventLayout.horizontal.clearCache();
  }
}, configureFunctionality:function() {
  var vfScope = this.validatorFnScope || this;
  if (this.eventResizeHandles !== 'none' && Sch.feature.ResizeZone) {
    this.resizePlug = new Sch.feature.ResizeZone(Ext.applyIf({schedulerView:this, validatorFn:function(resourceRecord, eventRecord, startDate, endDate) {
      return (this.allowOverlap || this.isDateRangeAvailable(startDate, endDate, eventRecord, resourceRecord)) && this.resizeValidatorFn.apply(vfScope, arguments);
    }, validatorFnScope:this}, this.resizeConfig || {}));
  }
  if (this.enableEventDragDrop !== false && Sch.feature.DragDrop) {
    this.dragdropPlug = new Sch.feature.DragDrop(this, {validatorFn:function(dragRecords, targetResourceRecord, date, duration) {
      return (this.allowOverlap || this.isDateRangeAvailable(date, Sch.util.Date.add(date, Sch.util.Date.MILLI, duration), dragRecords[0], targetResourceRecord)) && this.dndValidatorFn.apply(vfScope, arguments);
    }, validatorFnScope:this, dragConfig:this.dragConfig || {}});
  }
  if (this.enableDragCreation !== false) {
    this.dragCreator = Ext.create(Ext.apply({xclass:'Sch.feature.DragCreator'}, {schedulerView:this, disabled:this.readOnly, validatorFn:function(resourceRecord, startDate, endDate) {
      return (this.allowOverlap || this.isDateRangeAvailable(startDate, endDate, null, resourceRecord)) && this.createValidatorFn.apply(vfScope, arguments);
    }, validatorFnScope:this}, this.createConfig));
  }
}, onDragDropStart:function() {
  if (this.dragCreator) {
    this.dragCreator.setDisabled(true);
  }
  if (this.tip) {
    this.tip.hide();
    this.tip.disable();
  }
  if (this.overScheduledEventClass) {
    this.setMouseOverEnabled(false);
  }
  this.disableViewScroller(true);
  this.hoveredEventNode = null;
}, onDragDropEnd:function() {
  if (this.dragCreator) {
    this.dragCreator.setDisabled(false);
  }
  if (this.tip) {
    this.tip.enable();
  }
  if (this.overScheduledEventClass) {
    this.setMouseOverEnabled(true);
  }
  this.disableViewScroller(false);
}, onBeforeDragCreate:function(s, resourceRecord, date, e) {
  return !this.readOnly && !e.ctrlKey;
}, onDragCreateStart:function() {
  if (this.overScheduledEventClass) {
    this.setMouseOverEnabled(false);
  }
  if (this.tip) {
    this.tip.hide();
    this.tip.disable();
  }
  this.disableViewScroller(true);
}, onDragCreateEnd:function(s, newEventRecord, resourceRecord) {
  if (!this.getEventEditor()) {
    var resources = resourceRecord ? [resourceRecord] : [];
    if (this.fireEvent('beforeeventadd', this, newEventRecord, resources) !== false) {
      this.getEventStore().append(newEventRecord);
      if (!this.isWeekView()) {
        newEventRecord.assign(resourceRecord);
      }
      this.onEventCreated(newEventRecord, resources);
    }
  }
  if (this.overScheduledEventClass) {
    this.setMouseOverEnabled(true);
  }
}, onEventCreated:function(newEventRecord, resources) {
}, onAfterDragCreate:function() {
  if (this.overScheduledEventClass) {
    this.setMouseOverEnabled(true);
  }
  if (this.tip) {
    this.tip.enable();
  }
  this.disableViewScroller(false);
}, onBeforeResize:function() {
  return !this.readOnly;
}, onResizeStart:function() {
  if (this.tip) {
    this.tip.hide();
    this.tip.disable();
  }
  if (this.dragCreator) {
    this.dragCreator.setDisabled(true);
  }
  this.disableViewScroller(true);
}, onResizeEnd:function() {
  if (this.tip) {
    this.tip.enable();
  }
  if (this.dragCreator) {
    this.dragCreator.setDisabled(false);
  }
  this.disableViewScroller(false);
}, setupEventListeners:function() {
  this.on({eventdragstart:this.onDragDropStart, aftereventdrop:this.onDragDropEnd, beforedragcreate:this.onBeforeDragCreate, dragcreatestart:this.onDragCreateStart, dragcreateend:this.onDragCreateEnd, afterdragcreate:this.onAfterDragCreate, beforeeventresize:this.onBeforeResize, eventresizestart:this.onResizeStart, aftereventresize:this.onResizeEnd, scope:this});
}, afterHeaderResized:function() {
  var resizer = this.headerCt.resizer;
  if (resizer && !this.isHorizontal()) {
    if (this.panel.forceFit) {
      this.setColumnWidth(resizer.origWidth);
    } else {
      var w = resizer.dragHd.getWidth();
      this.setColumnWidth(w);
    }
  }
}, columnRenderer:function(val, meta, record, row, col) {
  return this[this.mode].columnRenderer(val, meta, record, row, col);
}, onRowUpdated:function(resourceRecord) {
  var me = this, nodes;
  if (me.isHorizontal() && me.hasListener('eventrepaint')) {
    Ext.Array.each(resourceRecord.getEvents(), function(event) {
      nodes = me.getElementsFromEventRecord(event, resourceRecord, null, true);
      Ext.Array.each(nodes, function(node) {
        me.fireEvent('eventrepaint', me, event, node);
      });
    });
  }
}, scrollResourceEventIntoView:function(resourceRec, eventRec, index, highlight, animate, callback, scope) {
  var me = this, eventStart = eventRec.getStartDate(), eventEnd = eventRec.getEndDate(), currentTimeSpanRange, el;
  var doScroll = function() {
    el = me.getElementsFromEventRecord(eventRec, resourceRec, index);
    el = el.length && el[0] || null;
    me.scrollElementIntoView(el, true, animate, highlight, null, callback, scope);
  };
  if (!me.timeAxis.dateInAxis(eventStart) || !me.timeAxis.dateInAxis(eventEnd)) {
    currentTimeSpanRange = me.timeAxis.getEnd() - me.timeAxis.getStart();
    me.timeAxis.setTimeSpan(new Date(eventStart.valueOf() - currentTimeSpanRange / 2), new Date(eventEnd.getTime() + currentTimeSpanRange / 2));
    me.up('panel').scrollTask.cancel();
  }
  if (this.isHorizontal()) {
    var ownerCmp = me.up('timelinegrid,timelinetree');
    var isTree = ownerCmp.store.isTreeStore;
    ownerCmp.ensureVisible(isTree ? resourceRec.getPath() : resourceRec, {callback:function() {
      if (this.isLocked === false || Ext.getVersion().gt('6.2.2')) {
        doScroll();
      }
    }});
  } else {
    doScroll();
  }
}}, 0, 0, 0, 0, 0, [[Sch.mixin.Localizable.prototype.mixinId || Sch.mixin.Localizable.$className, Sch.mixin.Localizable]], [Sch.mixin, 'SchedulerView'], 0);
Ext.cmd.derive('Sch.view.SchedulerGridView', Sch.view.TimelineGridView, {}, 0, ['schedulergridview'], ['component', 'box', 'dataview', 'tableview', 'gridview', 'schedulergridview'], {'component':true, 'box':true, 'dataview':true, 'tableview':true, 'gridview':true, 'schedulergridview':true}, ['widget.schedulergridview'], [[Sch.mixin.SchedulerView.prototype.mixinId || Sch.mixin.SchedulerView.$className, Sch.mixin.SchedulerView], [Sch.mixin.GridViewCanvas.prototype.mixinId || Sch.mixin.GridViewCanvas.$className, 
Sch.mixin.GridViewCanvas], [Sch.mixin.Localizable.prototype.mixinId || Sch.mixin.Localizable.$className, Sch.mixin.Localizable]], [Sch.view, 'SchedulerGridView'], function() {
  this.override(Sch.mixin.SchedulerView.prototype.inheritables() || {});
});
Ext.cmd.derive('Sch.selection.EventModel', Ext.selection.Model, {deselectOnContainerClick:true, selectedOnMouseDown:null, bindToView:function(view) {
  var me = this;
  me.view = view;
  me.bindStore(me.getSelectionStore(view));
  view.on({eventclick:me.onEventClick, eventmousedown:me.onEventMouseDown, itemmousedown:me.onItemMouseDown, refresh:function() {
    me.refresh();
  }, destroy:function() {
    me.bindStore(null);
  }, scope:me});
}, getSelectionStore:function(view) {
  return view.getEventStore();
}, bindStore:function(store) {
  if (this.getStore()) {
    this.mun(this.getStore(), 'load', this.onSelectionStoreLoad, this);
  }
  if (store) {
    this.mon(store, 'load', this.onSelectionStoreLoad, this);
  }
  Ext.selection.Model.prototype.bindStore.apply(this, arguments);
}, onSelectionStoreLoad:function() {
  this.deselectAll();
}, onEventMouseDown:function(view, record, e) {
  this.selectedOnMouseDown = null;
  if ((!this.ignoreRightMouseSelection || e.button !== 2) && !this.isSelected(record)) {
    this.selectedOnMouseDown = record;
    this.selectWithEvent(record, e);
  }
}, onEventClick:function(view, record, e) {
  if ((!this.ignoreRightMouseSelection || e.button !== 2) && !this.selectedOnMouseDown) {
    this.selectWithEvent(record, e);
  }
}, onItemMouseDown:function(a, b, c, d, eventObj) {
  if (this.deselectOnContainerClick && !eventObj.getTarget(this.view.eventSelector)) {
    this.deselectAll();
  }
}, onSelectChange:function(record, isSelected, suppressEvent, commitFn) {
  var me = this, view = me.view, store = me.store, eventName = isSelected ? 'select' : 'deselect', i = 0;
  if (view && (suppressEvent || me.fireEvent('before' + eventName, me, record)) !== false && commitFn() !== false) {
    if (isSelected) {
      view.onEventBarSelect(record, suppressEvent);
    } else {
      view.onEventBarDeselect(record, suppressEvent);
    }
    if (!suppressEvent) {
      me.fireEvent(eventName, me, record);
    }
  }
}, selectRange:Ext.emptyFn, selectNode:function(node, keepExisting, suppressEvent) {
  var r = this.view.resolveEventRecord(node);
  if (r) {
    this.select(r, keepExisting, suppressEvent);
  }
}, deselectNode:function(node, keepExisting, suppressEvent) {
  var r = this.view.resolveEventRecord(node);
  if (r) {
    this.deselect(r, suppressEvent);
  }
}, getFirstSelectedEventForResource:function(resource) {
  var selections = this.getSelection(), event = null, i, len, r;
  for (i = 0, len = selections.length; !event && i < len; ++i) {
    r = selections[i];
    if (r.isAssignedTo(resource)) {
      event = r;
    }
  }
  return event;
}, getDraggableSelections:function() {
  return Ext.Array.filter(this.getSelection(), function(record) {
    return record.isDraggable();
  });
}, forEachEventRelatedSelection:function(eventRecord, fn) {
  this.isSelected(eventRecord) && fn(eventRecord);
}, refresh:function() {
  var me = this, store = me.store, toBeSelected = [], toBeReAdded = [], oldSelections = me.getSelection(), len = oldSelections.length, selected = me.getSelected(), change, d, storeData, selection, rec, i;
  if (!store || !(selected.isCollection || selected.isBag || selected.isRows) || !selected.getCount()) {
    return;
  }
  storeData = store.getData();
  if (storeData.getSource) {
    d = storeData.getSource();
    if (d) {
      storeData = d;
    }
  }
  me.refreshing = true;
  selected.beginUpdate();
  me.suspendChanges();
  for (i = 0; i < len; i++) {
    selection = oldSelections[i];
    rec = storeData.get(selection.getId());
    if (rec) {
      toBeSelected.push(rec);
    } else {
      if (!me.pruneRemoved) {
        toBeReAdded.push(selection);
      }
    }
    if (me.mode === 'SINGLE' && toBeReAdded.length) {
      break;
    }
  }
  if (selected.getCount() !== toBeSelected.length + toBeReAdded.length) {
    change = true;
  }
  me.clearSelections();
  if (toBeSelected.length) {
    me.doSelect(toBeSelected, false, true);
  }
  if (toBeReAdded.length) {
    selected.add(toBeReAdded);
    if (!me.lastSelected) {
      me.lastSelected = toBeReAdded[toBeReAdded.length - 1];
    }
  }
  me.resumeChanges();
  if (change) {
    selected.endUpdate();
  } else {
    selected.updating--;
  }
  me.refreshing = false;
  me.maybeFireSelectionChange(change);
}}, 0, 0, 0, 0, ['selection.eventmodel'], 0, [Sch.selection, 'EventModel'], 0);
Ext.cmd.derive('Sch.selection.AssignmentModel', Sch.selection.EventModel, {assignmentStoreDetacher:null, getSelectionStore:function(view) {
  return view.getEventStore().assignmentStore;
}, onBindStore:function(assignmentStore) {
  Sch.selection.EventModel.prototype.onBindStore.apply(this, arguments);
  if (assignmentStore) {
    var me = this;
    me.assignmentStoreDetacher && me.assignmentStoreDetacher.destroy();
    me.assignmentStoreDetacher = assignmentStore.on({remove:me.onAssignmentStoreRemove, clear:me.onAssignmentStoreClear, refresh:me.onAssignmentStoreRefresh, scope:me, destroyable:true});
  }
}, onEventMouseDown:function(view, record, e) {
  this.selectedOnMouseDown = null;
  var assignmentRecord = this.resolveAssignmentRecordFromEventNode(e.getTarget());
  if (assignmentRecord && (!this.ignoreRightMouseSelection || e.button !== 2) && !this.isSelected(assignmentRecord)) {
    this.selectedOnMouseDown = assignmentRecord;
    this.selectWithEvent(assignmentRecord, e);
  }
}, onEventClick:function(view, record, e) {
  var assignmentRecord = this.resolveAssignmentRecordFromEventNode(e.getTarget());
  if (assignmentRecord && (!this.ignoreRightMouseSelection || e.button !== 2) && !this.selectedOnMouseDown) {
    this.selectWithEvent(assignmentRecord, e);
  }
}, resolveAssignmentRecordFromEventNode:function(node) {
  var view = this.view, event = view.resolveEventRecord(node), resource = view.resolveResource(node);
  if (event && resource) {
    var assignmentStore = view.getEventStore().getAssignmentStore();
    return assignmentStore.getAssignmentForEventAndResource(event, resource);
  }
}, selectNode:function(node, keepExisting, suppressEvent) {
  var assignmentRecord = this.resolveAssignmentRecordFromEventNode(node);
  if (assignmentRecord) {
    this.select(assignmentRecord, keepExisting, suppressEvent);
  }
}, deselectNode:function(node, keepExisting, suppressEvent) {
  var assignmentRecord = this.resolveAssignmentRecordFromEventNode(node);
  if (assignmentRecord) {
    this.deselect(assignmentRecord, suppressEvent);
  }
}, getFirstSelectedEventForResource:function(resource) {
  var selections = this.getSelection(), event = null, i, len, r;
  for (i = 0, len = selections.length; !event && i < len; ++i) {
    r = selections[i];
    if (r.getEvent().isAssignedTo(resource)) {
      event = r;
      break;
    }
  }
  return event;
}, getDraggableSelections:function() {
  return Ext.Array.filter(this.getSelection(), function(record) {
    return record.getEvent().isDraggable();
  });
}, forEachEventRelatedSelection:function(eventRecord, fn) {
  Ext.Array.each(this.getSelection(), function(selectedRecord) {
    selectedRecord.getEvent() === eventRecord && fn(selectedRecord);
  });
}, onAssignmentStoreRemove:function(assignmentStore, removedRecords) {
  this.deselect(removedRecords, true);
}, onAssignmentStoreClear:function(assignmentStore) {
  this.clearSelections();
}, onAssignmentStoreRefresh:function(assignmentStore) {
  this.clearSelections();
}, destroy:function() {
  var me = this;
  Ext.destroyMembers(me, 'assignmentStoreDetacher');
  Sch.selection.EventModel.prototype.destroy.call(this);
}}, 0, 0, 0, 0, ['selection.assignmentmodel'], 0, [Sch.selection, 'AssignmentModel'], 0);
Ext.cmd.derive('Sch.mixin.SchedulerPanel', Sch.mixin.AbstractSchedulerPanel, {eventSelModelType:null, eventSelModel:null, enableEventDragDrop:true, enableDragCreation:true, dragConfig:null, weekViewColumnClass:'Sch.column.Day', componentCls:'sch-schedulerpanel', lockedGridDependsOnSchedule:true, verticalListeners:null, horizontalLockedWidth:null, verticalColumns:null, calendarColumns:null, horizontalCls:['sch-horizontal'], verticalCls:['sch-vertical-resource', 'sch-vertical'], weekviewCls:['sch-calendar', 
'sch-vertical'], _oldViewPresetArgs:null, inheritables:function() {
  return {variableRowHeight:true, initComponent:function() {
    var me = this, viewConfig = me.normalViewConfig = me.normalViewConfig || {}, dependencyViewConfig = me.getDependencyViewConfig && me.getDependencyViewConfig() || {};
    me._initializeSchedulerPanel();
    me.verticalListeners = {clear:me.refreshResourceColumns, datachanged:me.refreshResourceColumns, update:me.refreshResourceColumns, load:me.refreshResourceColumns, scope:me};
    me.calendarListeners = {reconfigure:me.refreshCalendarColumns, priority:1, scope:me};
    me.calendarNormalGridListeners = {columnresize:me.onCalendarColumnResize, scope:me};
    me.calendarResourceStoreListeners = {load:me.onCalendarResourceStoreChange, add:me.onCalendarResourceStoreChange, remove:me.onCalendarResourceStoreChange, scope:me};
    me.normalViewConfig = me.normalViewConfig || {};
    Ext.apply(me.normalViewConfig, {eventStore:me.eventStore, resourceStore:me.resourceStore, dependencyStore:me.dependencyStore, eventBarTextField:me.eventBarTextField || this.getEventStore().getModel().prototype.nameField});
    if (me.getDependencyStore() && dependencyViewConfig.enableDependencyDragDrop !== false) {
      viewConfig.terminalSides = dependencyViewConfig.terminalSides || ['left', 'right', 'top', 'bottom'];
    }
    Ext.Array.each(['barMargin', 'eventBodyTemplate', 'eventTpl', 'allowOverlap', 'dragConfig', 'eventBarIconClsField', 'onEventCreated', 'constrainDragToResource', 'snapRelativeToEventStartDate', 'eventSelModelType', 'eventSelModel', 'simpleSelect', 'multiSelect', 'allowDeselect', 'lockedGridDependsOnSchedule'], function(prop) {
      if (prop in me) {
        me.normalViewConfig[prop] = me[prop];
      }
    });
    me.callParent(arguments);
    if (!me.isHorizontal()) {
      me.setGroupingFeatureDisabled(true);
    }
    if (me.isVertical()) {
      me.mon(me.resourceStore, me.verticalListeners);
    }
    var lockedView = me.lockedGrid.getView();
    var normalView = me.getSchedulingView();
    lockedView.on('resize', me.onLockedViewResize, me);
    me.registerRenderer(normalView.columnRenderer, normalView);
    if (me.resourceZones) {
      var resourceZoneStore = Ext.StoreManager.lookup(me.resourceZones);
      me.resourceZonesPlug = new Sch.plugin.ResourceZones(Ext.apply({store:resourceZoneStore}, me.resourceZonesConfig));
      me.resourceZonesPlug.init(me);
    }
    normalView.on('columnwidthchange', me.onColWidthChange, me);
    me.relayEvents(normalView, ['eventclick', 'eventlongpress', 'eventmousedown', 'eventmouseup', 'eventdblclick', 'eventcontextmenu', 'eventmouseenter', 'eventmouseleave', 'eventkeydown', 'eventkeyup', 'beforeeventresize', 'eventresizestart', 'eventpartialresize', 'beforeeventresizefinalize', 'eventresizeend', 'aftereventresize', 'beforeeventdrag', 'eventdragstart', 'eventdrag', 'beforeeventdropfinalize', 'eventdrop', 'aftereventdrop', 'beforedragcreate', 'dragcreatestart', 'beforedragcreatefinalize', 
    'dragcreateend', 'afterdragcreate', 'beforeeventadd']);
    if (!me.syncRowHeight) {
      me.enableRowHeightInjection(lockedView, normalView);
    }
    if (me.getDependencyStore()) {
      me.addCls('sch-scheduler-with-dependencies');
    }
  }, configureColumns:function(columns) {
    var me = this;
    columns = columns || [{xtype:'scheduler_resourcenamecolumn'}];
    me.callParent(arguments);
    me.verticalColumns = me.verticalColumns || [Ext.apply({xtype:'verticaltimeaxis'}, me.timeAxisColumnCfg || {})];
    Ext.Array.each(me.verticalColumns, function(col) {
      Ext.apply(col, {timeAxis:me.timeAxis, timeAxisViewModel:me.timeAxisViewModel, cellTopBorderWidth:me.cellTopBorderWidth, cellBottomBorderWidth:me.cellBottomBorderWidth});
    });
    me.calendarColumns = [Ext.apply({xtype:'verticaltimeaxis', width:60, timeAxis:me.timeAxis, timeAxisViewModel:me.timeAxisViewModel, cellTopBorderWidth:me.cellTopBorderWidth, cellBottomBorderWidth:me.cellBottomBorderWidth}, me.calendarTimeAxisCfg || me.weekViewTimeAxisCfg || {})];
    if (me.isVertical()) {
      me.columns = me.verticalColumns.concat(me.createResourceColumns(me.resourceColumnWidth || me.timeAxisViewModel.resourceColumnWidth));
      me.store = me.timeAxis;
      if (me.resourceStore.isGrouped()) {
        me.timeAxis.group(me.resourceStore.groupField);
        me.bindGroupingFeatureListener();
      }
    } else {
      if (me.isWeekView()) {
        me.columns = [];
        me.store = null;
        me.on('beforerender', me.refreshCalendarColumns, me);
      }
    }
  }, applyViewSettings:function(preset, initial) {
    this.callParent(arguments);
    var schedulingView = this.getSchedulingView(), height;
    if (this.orientation === 'vertical') {
      height = preset.timeColumnWidth || 60;
      schedulingView.setColumnWidth(preset.resourceColumnWidth || 100, true);
      schedulingView.setRowHeight(height, true);
    }
  }, onRender:function() {
    if (!this.isHorizontal()) {
      this.reconfigureBufferedRendering(true);
    }
    this.callParent(arguments);
  }, afterRender:function() {
    var me = this;
    var schedulingView = this.getSchedulingView();
    this.callParent(arguments);
    if (this.isVertical()) {
      this.onLockedViewResize(null, null, this.lockedGrid.getView().getHeight());
    } else {
      if (this.isWeekView()) {
        this.mon(this.timeAxis, this.calendarListeners);
        this.mon(this.resourceStore, this.calendarResourceStoreListeners);
        this.normalGrid.on(this.calendarNormalGridListeners);
      }
    }
    if (this.infiniteScroll) {
      schedulingView.on({eventdragstart:this.doSuspendLayouts, aftereventdrop:this.doResumeLayouts, eventresizestart:this.doSuspendLayouts, aftereventresize:this.doResumeLayouts, scope:this});
    }
    if (this.lockedGridDependsOnSchedule) {
      schedulingView.on('itemupdate', this.onNormalViewItemUpdate, this);
    }
    this.relayEvents(this.getEventSelectionModel(), ['selectionchange', 'deselect', 'select'], 'event');
    this.getView().on('refresh', function() {
      if (!me.isHorizontal()) {
        me.reconfigureBufferedRendering();
      }
    });
  }, getTimeSpanDefiningStore:function() {
    return this.eventStore;
  }, destroy:function() {
    var me = this;
    if (me.destroyStores) {
      me.getDependencyStore() && me.getDependencyStore().destroy();
      me.getAssignmentStore() && me.getAssignmentStore().destroy();
      me.getEventStore() && me.getEventStore().destroy();
      me.getResourceStore() && me.getResourceStore().destroy();
    }
    Ext.destroyMembers(me, 'resourceZonesPlug');
    me.callParent(arguments);
  }, scrollToDateCentered:function(date, animate) {
    var view = this.getSchedulingView();
    if (view.isWeekView()) {
      var column = view.weekview.getColumnsBy(function(column) {
        return column.start <= date && column.end > date;
      })[0];
      if (column) {
        var deltaX = view.getWidth() / 2;
        var deltaY = view.getViewContainerHeight() / 2;
        view.scrollHorizontallyTo(Math.max(column.getLocalX() - deltaX, 0));
        view.scrollVerticallyTo(Math.max(view.getCoordinateFromDate(date, true) - deltaY, 0));
      }
    } else {
      return this.callParent(arguments);
    }
  }};
}, doSuspendLayouts:function() {
  this.timeAxis.on({beginreconfigure:this.onBeginReconfigure, endreconfigure:this.onEndReconfigure, scope:this});
  this.lockedGrid.suspendLayouts();
  this.normalGrid.suspendLayouts();
}, doResumeLayouts:function() {
  this.timeAxis.un({beginreconfigure:this.onBeginReconfigure, endreconfigure:this.onEndReconfigure, scope:this});
  this.lockedGrid.resumeLayouts();
  this.normalGrid.resumeLayouts();
}, onBeginReconfigure:function() {
  this.normalGrid.resumeLayouts();
}, onEndReconfigure:function() {
  this.normalGrid.suspendLayouts();
}, onColWidthChange:function(timeAxisViewModel, width) {
  if (this.isVertical()) {
    this.resourceColumnWidth = width;
    this.refreshResourceColumns();
  } else {
    if (this.isWeekView()) {
      this.weekViewColumnWidth = width;
      this.refreshCalendarColumns();
    }
  }
}, enableRowHeightInjection:function(lockedView, schedulingView) {
  var me = this;
  var cellTpl = new Ext.XTemplate('{%', 'this.processCellValues(values);', 'this.nextTpl.applyOut(values, out, parent);', '%}', {priority:1, processCellValues:Ext.Function.bind(me.embedRowHeight, me)});
  lockedView.addCellTpl(cellTpl);
  Ext.Array.each(this.columns, function(column) {
    column.hasCustomRenderer = true;
  });
  Ext.Array.each(this.horizontalColumns, function(column) {
    column.hasCustomRenderer = true;
  });
}, embedRowHeight:function(cellValues) {
  var me = this, schedulingView = me.getSchedulingView();
  if (schedulingView.isHorizontal()) {
    var nbrBands = 1;
    if (schedulingView.rowHasDynamicRowHeight(cellValues.record)) {
      var resource = cellValues.record;
      var layout = schedulingView.eventLayout.horizontal;
      nbrBands = layout.getNumberOfBands(resource, function() {
        return schedulingView.getEventStore().filterEventsForResource(resource, schedulingView.timeAxis.isRangeInAxis, schedulingView.timeAxis);
      });
    }
    var rowHeight = nbrBands * me.getRowHeight() - (nbrBands - 1) * schedulingView.barMargin + schedulingView.cellTopBorderWidth + schedulingView.cellBottomBorderWidth - 1;
    cellValues.style = (cellValues.style || '') + ';height:' + rowHeight + 'px;';
  }
}, getEventSelectionModel:function() {
  return this.getSchedulingView().getEventSelectionModel();
}, refreshResourceColumns:function() {
  var w = this.resourceColumnWidth || this.timeAxisViewModel.resourceColumnWidth;
  this.reconfigure(this.verticalColumns.concat(this.createResourceColumns(w)));
}, onCalendarColumnResize:function(headerCt, column, width) {
  if (width !== this.timeAxisViewModel.weekViewColumnWidth) {
    this.timeAxisViewModel.setViewColumnWidth(width, true);
  }
  this.getSchedulingView().weekview.repaintEventsForColumn(column, headerCt.columnManager.indexOf(column));
}, onCalendarResourceStoreChange:function() {
  this.getSchedulingView().refreshView();
}, refreshCalendarColumns:function() {
  var rows = this.createCalendarRows();
  var columns = this.createCalendarColumns();
  this.reconfigure(rows, this.calendarColumns.concat(columns));
}, setGroupingFeatureDisabled:function(disabled) {
  var me = this, view = me.normalGrid.view;
  if (!view.groupingFeature) {
    return;
  }
  view.groupingFeature[disabled ? 'disable' : 'enable']();
  view = me.lockedGrid.view;
  view.groupingFeature[disabled ? 'disable' : 'enable']();
}, refreshGroupingStore:function() {
  var feature = this.normalGrid.view.groupingFeature;
  if (feature) {
    feature.dataSource.processStore(this.timeAxis);
  }
}, bindGroupingFeatureListener:function() {
  this.mon(this.timeAxis, 'reconfigure', this.refreshGroupingStore, this, {priority:10});
}, unbindGroupingFeatureListener:function() {
  this.mun(this.timeAxis, 'reconfigure', this.refreshGroupingStore);
}, setMode:function(modeCfg, force) {
  var me = this;
  if (!me.normalGrid) {
    me.on('afterrender', function() {
      me.setMode(modeCfg, true);
    });
    return;
  }
  var mode = typeof modeCfg === 'string' ? modeCfg : modeCfg.mode;
  if (!mode) {
    throw new Error('Mode is undefined');
  }
  if (mode === 'calendar') {
    mode = 'weekview';
  }
  var viewPresetArgs;
  if (modeCfg.viewPreset) {
    viewPresetArgs = [modeCfg.viewPreset, modeCfg.startDate || null, modeCfg.endDate || null];
  }
  if (mode === me.mode && !force) {
    viewPresetArgs && me.setViewPreset.apply(me, viewPresetArgs);
    return;
  }
  if (me.fireEvent('beforemodechange', me, modeCfg) !== false) {
    me.mode = mode;
    if (me.isHorizontal()) {
      me.removeCls(me.verticalCls).removeCls(me.weekviewCls).addCls(me.horizontalCls);
    } else {
      if (me.isVertical()) {
        me.removeCls(me.horizontalCls).removeCls(me.weekviewCls).addCls(me.verticalCls);
      } else {
        if (me.isWeekView()) {
          me.removeCls(me.horizontalCls).removeCls(me.verticalCls).addCls(me.weekviewCls);
        }
      }
    }
    var normalGrid = me.normalGrid, lockedView = me.lockedGrid.getView(), schedulingView = me.getSchedulingView(), normalHeaderCt = normalGrid.headerCt;
    me.suspendRefresh();
    Ext.suspendLayouts();
    me.setGroupingFeatureDisabled(!me.isHorizontal());
    me.unbindGroupingFeatureListener();
    var isWeekView = me.isWeekView();
    var isSchWeekView = schedulingView.isWeekView();
    if (isSchWeekView && !isWeekView || !isSchWeekView && isWeekView) {
      viewPresetArgs = viewPresetArgs || me._oldViewPresetArgs || [isWeekView ? 'week' : 'weekAndDay'];
      me._oldViewPresetArgs = [me.viewPreset, me.timeAxis.getStart(), me.timeAxis.getEnd()];
    }
    schedulingView.setMode(mode);
    normalHeaderCt.removeAll(true);
    me.reconfigureBufferedRendering();
    if (!me.isWeekView()) {
      me.timeAxis.setMode('plain');
      me.mun(me.timeAxis, me.calendarListeners);
    } else {
      me.timeAxis.setMode('week');
      me.mon(me.timeAxis, me.calendarListeners);
    }
    viewPresetArgs && me.setViewPreset.apply(me, viewPresetArgs);
    if (me.isHorizontal()) {
      me.mun(me.resourceStore, me.verticalListeners);
      me.mun(me.resourceStore, me.calendarResourceStoreListeners);
      me.normalGrid.un(me.calendarNormalGridListeners);
      schedulingView.setRowHeight(me.getRowHeight(), true);
      me.reconfigure(me.resourceStore, me.horizontalColumns);
      if (me.horizontalLockedWidth !== null) {
        me.lockedGrid.setWidth(me.horizontalLockedWidth);
      }
    } else {
      if (me.isWeekView()) {
        me.mun(me.resourceStore, me.verticalListeners);
        me.mon(me.resourceStore, me.calendarResourceStoreListeners);
        me.normalGrid.on(me.calendarNormalGridListeners);
        me.bindGroupingFeatureListener();
        me.refreshCalendarColumns();
        schedulingView.setRowHeight(me.getRowHeight(), true);
        schedulingView.setColumnWidth(me.timeAxisViewModel.weekViewColumnWidth || 100, true);
      } else {
        me.normalGrid.un(me.calendarNormalGridListeners);
        me.mun(me.resourceStore, me.calendarResourceStoreListeners);
        var lockedWidth = 0;
        me.horizontalLockedWidth = me.lockedGrid.getWidth();
        me.mon(me.resourceStore, me.verticalListeners);
        me.bindGroupingFeatureListener();
        me.reconfigure(me.timeAxis, me.verticalColumns.concat(me.createResourceColumns(me.resourceColumnWidth || me.timeAxisViewModel.resourceColumnWidth)));
        Ext.Array.each(me.lockedGrid.query('gridcolumn'), function(col) {
          lockedWidth += col.rendered ? col.getWidth() : col.width || 100;
        });
        schedulingView.setColumnWidth(me.timeAxisViewModel.resourceColumnWidth || 100, true);
        me.lockedGrid.setWidth(lockedWidth);
      }
    }
    var groupField = me.resourceStore.groupField;
    if (groupField) {
      me.store.group(groupField);
    }
    me.resumeRefresh(false);
    var splitter = me.getSplitter();
    if (splitter) {
      splitter.setVisible(mode === 'horizontal');
    }
    me.refreshViews(false);
    Ext.resumeLayouts(true);
    me.fireEvent('modechange', me, modeCfg);
  }
}, reconfigureBufferedRendering:function(initial) {
  if (this.bufferedRenderer) {
    var lockedPlugin = this.lockedGrid.bufferedRenderer, normalPlugin = this.normalGrid.bufferedRenderer, value;
    if (!this.isHorizontal()) {
      value = this.timeAxis.getCount();
      this.__oldLeadingBufferZone = lockedPlugin.leadingBufferZone;
    } else {
      if (this.__oldLeadingBufferZone) {
        value = this.__oldLeadingBufferZone;
        this.__oldLeadingBufferZone = null;
      }
    }
    if (!initial && lockedPlugin.scroller && lockedPlugin.scroller.getLockedScroller()) {
      var height = this.lockedGrid.view.getHeight(), viewSize = Math.ceil(height / lockedPlugin.rowHeight) + lockedPlugin.trailingBufferZone + value;
      lockedPlugin.setViewSize(viewSize, true);
      normalPlugin.setViewSize(viewSize, true);
    }
    lockedPlugin.leadingBufferZone = normalPlugin.leadingBufferZone = value;
  }
}, createCalendarRows:function() {
  var me = this, rows = me.timeAxis.getRowTicks();
  me.timeAxisViewModel.calendarRowsAmount = rows.length;
  return new Ext.data.Store({model:'Sch.model.TimeAxisTick', data:rows});
}, createCalendarColumns:function() {
  var me = this, timeAxis = me.timeAxis, currentHeader = timeAxis.headerConfig.middle, columns = [], lastDay;
  var startTime = me.startTime = timeAxis.startTime;
  var endTime = me.endTime = timeAxis.endTime;
  timeAxis.each(function(tick) {
    var start = tick.getStartDate();
    if (lastDay !== start.getDay()) {
      lastDay = start.getDay();
      start.setHours(startTime);
      var end = new Date(start);
      end.setHours(endTime);
      var header = {xclass:me.calendarColumnClass || me.weekViewColumnClass, renderer:me.mainRenderer, scope:me, start:start, end:end};
      if (currentHeader.renderer) {
        header.text = currentHeader.renderer.call(currentHeader.scope || me, start, end, header, columns.length, me.getEventStore());
      } else {
        header.text = Ext.Date.format(start, currentHeader.dateFormat);
      }
      columns.push(header);
    }
  });
  me.timeAxisViewModel.updateCalendarColumnDates(columns);
  return columns;
}, onNormalViewItemUpdate:function(record) {
  if (this.lockedGridDependsOnSchedule) {
    var lockedView = this.lockedGrid.getView();
    lockedView.suspendEvents();
    lockedView.refreshNode(lockedView.indexOf(record));
    if (this.syncRowHeight) {
      this.syncRowHeights();
    }
    lockedView.resumeEvents();
  }
}, onLockedViewResize:function(cmp, width, height, oldWidth, oldHeight) {
  if (!this.isHorizontal() && height !== oldHeight) {
    this.timeAxisViewModel.update(height - 21);
  }
}, setRowHeight:function(height, preventRefresh) {
  preventRefresh = preventRefresh || !this.lockedGrid;
  this.readRowHeightFromPreset = false;
  this.timeAxisViewModel.setViewRowHeight(height, preventRefresh);
}}, 0, 0, 0, 0, 0, 0, [Sch.mixin, 'SchedulerPanel'], 0);
Ext.cmd.derive('Sch.plugin.CurrentTimeLine', Sch.plugin.Lines, {updateInterval:60000, showHeaderElements:true, autoUpdate:true, expandToFitView:true, timer:null, init:function(cmp) {
  if (Ext.getVersion('touch')) {
    this.showHeaderElements = false;
  }
  var store = new Ext.data.JsonStore({autoDestroy:true, fields:['Date', 'Cls', 'Text'], data:[{Date:new Date, Cls:'sch-todayLine', Text:this.L('tooltipText')}]});
  var record = store.first();
  if (this.autoUpdate) {
    this.timer = setInterval(function() {
      record.set('Date', new Date);
    }, this.updateInterval);
  }
  this.store = store;
  Sch.plugin.Lines.prototype.init.apply(this, arguments);
}, destroy:function() {
  clearInterval(this.timer);
  this.timer = null;
  if (this.store.autoDestroy) {
    this.store.destroy();
  }
  Sch.plugin.Lines.prototype.destroy.apply(this, arguments);
}}, 0, 0, 0, 0, ['plugin.scheduler_currenttimeline'], [[Sch.mixin.Localizable.prototype.mixinId || Sch.mixin.Localizable.$className, Sch.mixin.Localizable]], [Sch.plugin, 'CurrentTimeLine'], 0);
Ext.cmd.derive('Sch.patches.LockingScroller', Sch.util.Patch, {target:'Ext.scroll.Scroller', minVersion:'6.2.0', overrides:{scrollTo:function() {
  if (this.getNormalScroller && !this.getNormalScroller()) {
    if (Sch.panel.TimelineGridPanel && this.component instanceof Sch.panel.TimelineGridPanel || Sch.panel.TimelineTreePanel && this.component instanceof Sch.panel.TimelineTreePanel) {
      return;
    }
  }
  return this.callParent(arguments);
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'LockingScroller'], 0);
Ext.cmd.derive('Sch.plugin.NonWorkingTime', Sch.plugin.Zones, {alternateClassName:'Gnt.feature.WorkingTime', expandToFitView:true, calendar:{type:'calendar'}, timeAxis:null, init:function(timelinePanel) {
  this.calendar = this.calendar && Ext.StoreMgr.lookup(this.calendar);
  if (!this.calendar) {
    Ext.Error.raise("Required attribute 'calendar' missed during initialization of 'Sch.plugin.NonWorkingTime'");
  }
  this.store = new Ext.data.Store({model:'Sch.model.Range', autoDestroy:true});
  this.timeAxis = timelinePanel.getTimeAxis();
  Sch.plugin.Zones.prototype.init.apply(this, arguments);
  if (timelinePanel.isWeekView()) {
    timelinePanel.normalGrid.headerCt.on('afterlayout', this.onViewChange, this);
  } else {
    timelinePanel.on('viewchange', this.onViewChange, this);
  }
  this.bindCalendar(this.calendar);
}, bindCalendar:function(calendar) {
  var listeners = {datachanged:this.refresh, update:this.refresh, scope:this, delay:1};
  if (this.calendar) {
    this.calendar.un(listeners);
  }
  if (calendar) {
    calendar.on(listeners);
  }
  this.calendar = calendar;
  this.refresh();
}, onViewReady:function() {
  Sch.plugin.Zones.prototype.onViewReady.apply(this, arguments);
  if (this.schedulerView.isWeekView()) {
    this.onTimelinePanelBeforeModeChange();
    this.headerListeners = {};
  }
}, onViewChange:function() {
  var DATE = Sch.util.Date;
  var disabled = DATE.isUnitGreater(this.timeAxis.unit, DATE.WEEK);
  this.setDisabled(disabled);
  if (!disabled) {
    this.refresh();
  }
}, setDisabled:function(disabled) {
  var wasDisabled = this.disabled;
  Sch.plugin.Zones.prototype.setDisabled.apply(this, arguments);
  if (wasDisabled && !disabled) {
    this.refresh();
  }
}, refresh:function() {
  if (this.store && !this.store.destroyed) {
    this.store.removeAll(true);
    if (this.calendar) {
      this.store.add(this.calendar.getHolidaysRanges(this.timeAxis.getStart(), this.timeAxis.getEnd(), true));
    }
  }
}, destroy:function() {
  this.bindCalendar(null);
  Sch.plugin.Zones.prototype.destroy.apply(this, arguments);
}}, 0, 0, 0, 0, ['plugin.scheduler_nonworkingtime'], 0, [Sch.plugin, 'NonWorkingTime', Gnt.feature, 'WorkingTime'], 0);
Ext.cmd.derive('Sch.mixin.TimelinePanel', Sch.mixin.AbstractTimelinePanel, {destroyStores:false, bufferCoef:5, bufferThreshold:0.2, infiniteScroll:false, showCrudManagerMask:true, highlightWeekends:false, zoomOnTimeAxisDoubleClick:true, switchToDayViewOnWeekDayHeaderDblClick:true, waitingForAutoTimeSpan:false, showTodayLine:false, calendar:null, horizontalTimeAxisColumnCfg:null, columnLinesFeature:null, renderWaitListener:null, schedulePinchThreshold:30, pinchStartDistanceX:null, pinchStartDistanceY:null, 
pinchDistanceX:null, pinchDistanceY:null, horizontalColumns:null, forceDefineTimeSpanByStore:false, workingTimePlugin:null, split:true, refreshSuspensionCount:0, tipCfg:{cls:'sch-tip', showDelay:400, hideDelay:0, constrain:true, autoHide:true, anchor:'t'}, inheritables:function() {
  return {columnLines:true, enableLocking:true, lockable:true, stateEvents:['viewchange'], syncRowHeight:false, layout:'border', initComponent:function() {
    if (this.partnerTimelinePanel) {
      if (typeof this.partnerTimelinePanel === 'string') {
        this.partnerTimelinePanel = Ext.getCmp(this.partnerTimelinePanel);
      }
      this.timeAxisViewModel = this.partnerTimelinePanel.timeAxisViewModel;
      this.timeAxis = this.partnerTimelinePanel.getTimeAxis();
      this.startDate = this.timeAxis.getStart();
      this.endDate = this.timeAxis.getEnd();
    }
    this._initializeTimelinePanel();
    this.configureChildGrids();
    this.forceFit = false;
    this.configureColumns(this.columns);
    if (Ext.getVersion().equals('6.0.2.437')) {
      this.viewConfig = Ext.apply(this.viewConfig || {}, {componentLayout:'timeline_tablelayout'});
    }
    var viewConfig = this.normalViewConfig = this.normalViewConfig || {};
    var id = this.getId();
    Ext.apply(this.normalViewConfig, {id:id + '-timelineview', eventPrefix:this.autoGenId ? null : id, timeAxisViewModel:this.timeAxisViewModel, eventBorderWidth:this.eventBorderWidth, timeAxis:this.timeAxis, readOnly:this.readOnly, mode:this.mode, rtl:this.rtl, cellBorderWidth:this.cellBorderWidth, cellTopBorderWidth:this.cellTopBorderWidth, cellBottomBorderWidth:this.cellBottomBorderWidth, infiniteScroll:this.infiniteScroll, bufferCoef:this.bufferCoef, bufferThreshold:this.bufferThreshold});
    Ext.Array.each(['eventRendererScope', 'eventRenderer', 'dndValidatorFn', 'resizeValidatorFn', 'createValidatorFn', 'tooltipTpl', 'validatorFnScope', 'eventResizeHandles', 'enableEventDragDrop', 'enableDragCreation', 'resizeConfig', 'createConfig', 'tipCfg', 'getDateConstraints'], function(prop) {
      if (prop in this) {
        viewConfig[prop] = this[prop];
      }
    }, this);
    this.callParent(arguments);
    this.lockedGrid.view.addCls('sch-lockedview');
    if (this.rtl) {
      this.lockedGrid.view.addCls('sch-locked-column-fixer');
      this.addCls('sch-rtl');
    } else {
      this.addCls('sch-ltr');
    }
    var plugins = this.plugins = [].concat(this.plugins || []);
    if (this.highlightWeekends) {
      var calendar = this.getCalendar();
      calendar = calendar && Ext.StoreMgr.lookup(calendar) || new Sch.data.Calendar;
      this.workingTimePlugin = new Sch.plugin.NonWorkingTime({calendar:calendar});
      this.timeAxisViewModel.setCalendar(calendar);
      plugins.push(this.workingTimePlugin);
      this.addCls('sch-timelinepanel-highlightweekends');
    }
    if (this.showTodayLine) {
      this.todayLinePlugin = new Sch.plugin.CurrentTimeLine;
      plugins.push(this.todayLinePlugin);
    }
    this.patchNavigationModel(this);
    if (Ext.supports.Touch) {
      this.timeAxisViewModel.on('update', this.refreshHeaderContainerScrollable, this);
    }
    this.setViewPreset(this.viewPreset, this.startDate || this.timeAxis.getStart(), this.endDate || this.timeAxis.getEnd(), true);
    if (!this.startDate) {
      var crud = this.crudManager;
      if (crud && !crud.loaded) {
        this.bindAutoTimeSpanListeners();
      } else {
        var store = this.getTimeSpanDefiningStore();
        if (store.isTreeStore ? store.getRoot() && store.getRoot().childNodes.length : store.getCount()) {
          this.applyStartEndDatesFromStore();
        } else {
          if (store.isLoading() || this.forceDefineTimeSpanByStore) {
            this.bindAutoTimeSpanListeners();
          }
        }
      }
    }
    var columnLines = this.columnLines;
    if (columnLines) {
      this.columnLinesFeature = new Sch.feature.ColumnLines(Ext.isObject(columnLines) ? columnLines : undefined);
      this.columnLinesFeature.init(this);
      this.columnLines = true;
    }
    this.relayEvents(this.getSchedulingView(), ['beforetooltipshow', 'scheduleclick', 'scheduledblclick', 'schedulecontextmenu', 'schedulelongpress', 'schedulepinch', 'schedulepinchstart', 'schedulepinchend']);
    this.on('zoomchange', function() {
      this.normalGrid.scrollTask.cancel();
    });
    if (this.crudManager) {
      if (!this.crudManager.autoSync && this.showCrudManagerMask) {
        this.mon(this.crudManager, {beforesend:this.beforeCrudOperationStart, synccanceled:this.onCrudOperationComplete, loadcanceled:this.onCrudOperationComplete, load:this.onCrudOperationComplete, sync:this.onCrudOperationComplete, requestfail:this.onCrudOperationComplete, scope:this});
        if (this.crudManager.isLoading()) {
          this.beforeCrudOperationStart(this.crudManager, null, 'load');
        }
      }
      this.mon(this.crudManager, {beforeloadapply:this.onCrudBeforeLoad, load:this.onCrudLoad, scope:this});
    }
    if (Ext.isMac) {
      this.patchHeaderScrollSync(this);
    }
    this.afterInitComponent();
  }, refreshHeaderContainerScrollable:function() {
    var scrollable = this.getSchedulingView().headerCt.getScrollable();
    if (!scrollable) {
      return;
    }
    if (Ext.getVersion().isLessThan('6.0.1')) {
      var old = scrollable.isConfiguring;
      scrollable.isConfiguring = true;
      scrollable.refresh();
      scrollable.refreshAxes();
      scrollable.isConfiguring = old;
    } else {
      scrollable.refresh();
    }
  }, getState:function() {
    var me = this, state = me.callParent(arguments);
    Ext.apply(state, {viewPreset:me.viewPreset, startDate:me.getStart(), endDate:me.getEnd(), zoomMinLevel:me.zoomMinLevel, zoomMaxLevel:me.zoomMaxLevel, currentZoomLevel:me.currentZoomLevel});
    return state;
  }, applyState:function(state) {
    var me = this;
    me.callParent(arguments);
    if (state && state.viewPreset) {
      me.setViewPreset(state.viewPreset, state.startDate, state.endDate);
    }
    if (state && state.currentZoomLevel) {
      me.zoomToLevel(state.currentZoomLevel);
    }
  }, setTimeSpan:function() {
    this.callParent(arguments);
    if (this.waitingForAutoTimeSpan) {
      this.unbindAutoTimeSpanListeners(false);
      this.getView().refresh();
    }
    if (!this.normalGrid.getView().viewReady) {
      this.getView().refresh();
    }
  }, onBoxReady:function() {
    var me = this;
    me.callParent(arguments);
    if (me.partnerTimelinePanel) {
      if (me.partnerTimelinePanel.rendered) {
        me.setupPartnerTimelinePanel(me.partnerTimelinePanel);
      } else {
        me.partnerTimelinePanel.on('boxready', me.setupPartnerTimelinePanel, me);
      }
    }
    me.normalGrid.on({collapse:me.onNormalGridCollapse, expand:me.onNormalGridExpand, scope:me});
    me.normalGrid.headerCt.el.on({click:me.onHeaderClick, dblclick:me.onHeaderClick, contextmenu:me.onHeaderClick, delegate:'.sch-daycolumn-header', scope:me});
    me.lockedGrid.on({collapse:me.onLockedGridCollapse, expand:me.onLockedGridExpand, scope:me});
    me.lockedGrid.on({itemdblclick:me.onLockedGridItemDblClick, scope:me});
    if (Ext.supports.Touch) {
      this.getSchedulingView().on({schedulepinchstart:this.onSchedulePinchStart, schedulepinch:this.onSchedulePinch, schedulepinchend:this.onSchedulePinchEnd, scope:this});
    }
  }};
}, scrollToDate:function(date, animate) {
  var view = this.getSchedulingView();
  if (view.isWeekView()) {
    var column = view.weekview.getColumnsBy(function(column) {
      return column.start <= date && column.end > date;
    })[0];
    if (column) {
      view.scrollHorizontallyTo(column.getLocalX());
      view.scrollVerticallyTo(view.getCoordinateFromDate(date, true));
    }
  } else {
    return Sch.mixin.AbstractTimelinePanel.prototype.scrollToDate.apply(this, arguments);
  }
}, bindAutoTimeSpanListeners:function() {
  var store = this.getTimeSpanDefiningStore();
  this.waitingForAutoTimeSpan = true;
  this.suspendRefresh();
  this.mon(store, 'load', this.applyStartEndDatesFromStore, this);
  if (store.isTreeStore) {
    this.mon(store, 'rootchange', this.applyStartEndDatesFromStore, this);
    this.mon(store, 'nodeappend', this.applyStartEndDatesAfterTreeAppend, this);
  } else {
    this.mon(store, 'add', this.applyStartEndDatesFromStore, this);
  }
}, getTimeSpanDefiningStore:function() {
  throw 'Abstract method called';
}, unbindAutoTimeSpanListeners:function(doRefresh) {
  this.waitingForAutoTimeSpan = false;
  var store = this.getTimeSpanDefiningStore();
  this.resumeRefresh(doRefresh);
  store.un('load', this.applyStartEndDatesFromStore, this);
  if (store.isTreeStore) {
    store.un('rootchange', this.applyStartEndDatesFromStore, this);
    store.un('nodeappend', this.applyStartEndDatesAfterTreeAppend, this);
  } else {
    store.un('add', this.applyStartEndDatesFromStore, this);
  }
}, applyStartEndDatesAfterTreeAppend:function() {
  var store = this.getTimeSpanDefiningStore();
  if (!store.isSettingRoot && !store.__loading) {
    this.applyStartEndDatesFromStore();
  }
}, applyStartEndDatesFromStore:function() {
  var store = this.getTimeSpanDefiningStore();
  var span = store.getTotalTimeSpan();
  if (span.end && span.start && span.end - span.start === 0) {
    span.start = Sch.util.Date.add(span.start, this.timeAxis.mainUnit, -1);
    span.end = Sch.util.Date.add(span.end, this.timeAxis.mainUnit, 1);
  }
  this.setTimeSpan(span.start || new Date, span.end);
}, onLockedGridItemDblClick:function(grid, record, el, rowIndex, event) {
  if (this.isVertical() && record) {
    this.fireEvent('timeheaderdblclick', this, record.get('start'), record.get('end'), rowIndex, event);
  }
}, onHeaderClick:function(event, t) {
  var columnEl = event.getTarget('.x-column-header');
  var index = [].indexOf.call(columnEl.parentElement.childNodes, columnEl);
  var column = this.normalGrid.getColumns()[index];
  if (Sch.column.Day && column instanceof Sch.column.Day) {
    var start = column.start;
    var end = column.end;
    this.fireEvent('timeheader' + event.type, this, start, end, event);
    if (event.type === 'dblclick' && this.switchToDayViewOnWeekDayHeaderDblClick) {
      this.setViewPreset('day', start);
    }
  }
}, getSchedulingView:function() {
  return this.normalGrid && this.normalGrid.view;
}, getHorizontalTimeAxisColumn:function() {
  return this.getSchedulingView().getHorizontalTimeAxisColumn();
}, configureColumns:function(columns) {
  var lockedColumns = [];
  var normalColumns = [];
  columns = columns || [];
  if (columns.items) {
    this.columns = Ext.apply({}, this.columns);
    columns = this.columns.items = columns.items.slice();
  } else {
    columns = this.columns = columns.slice();
  }
  Ext.Array.each(columns, function(column) {
    if (column.position === 'right' || column.locked === false) {
      if (!Ext.isNumber(column.width)) {
        Ext.Error.raise('"Right" columns must have a fixed width');
      }
      column.locked = false;
      normalColumns.push(column);
    } else {
      column.locked = true;
      lockedColumns.push(column);
    }
    column.lockable = false;
  });
  if (columns.length === 0) {
    this.split = false;
  }
  Ext.Array.erase(columns, 0, columns.length);
  Ext.Array.insert(columns, 0, lockedColumns.concat(Ext.apply({xtype:'timeaxiscolumn', timeAxisViewModel:this.timeAxisViewModel, trackHeaderOver:this.trackHeaderOver, renderer:this.mainRenderer, variableRowHeight:this.variableRowHeight, scope:this}, this.horizontalTimeAxisColumnCfg || {})).concat(normalColumns));
  this.horizontalColumns = columns.slice();
}, mainRenderer:function(val, meta, rowRecord, rowIndex, colIndex) {
  var renderers = this.renderers, resource = this.isVertical() ? this.getResourceStore().getAt(colIndex) : rowRecord, retVal = '\x26nbsp;';
  meta.rowHeight = null;
  for (var i = 0; i < renderers.length; i++) {
    retVal += renderers[i].fn.call(renderers[i].scope || this, val, meta, resource, rowIndex, colIndex) || '';
  }
  if (this.variableRowHeight) {
    var view = this.getSchedulingView();
    var rowHeight = meta.rowHeight || this.getRowHeight();
    if (view.isHorizontal()) {
      rowHeight += view.cellTopBorderWidth + view.cellBottomBorderWidth - 1;
    } else {
      rowHeight -= 1;
    }
    meta.style = 'height:' + rowHeight + 'px';
  }
  return retVal;
}, onNormalGridCollapse:function() {
  var me = this;
  if (!me.normalGrid.reExpander) {
    me.normalGrid.reExpander = me.normalGrid.placeholder;
  }
  if (!me.lockedGrid.rendered) {
    me.lockedGrid.on('render', me.onNormalGridCollapse, me, {delay:1});
  } else {
    me.lockedGrid.savedWidth = me.lockedGrid.getWidth();
    if (me.lockedGrid.collapsed) {
      me.lockedGrid.expand();
    }
    me.lockedGrid.setWidth(me.getWidth() - me.normalGrid.getPlaceholder().getWidth());
    me.addCls('sch-normalgrid-collapsed');
  }
}, onNormalGridExpand:function() {
  this.removeCls('sch-normalgrid-collapsed');
}, onLockedGridCollapse:function() {
  var me = this;
  if (me.normalGrid.collapsed) {
    me.normalGrid.expand();
  }
}, onLockedGridExpand:function() {
  if (this.lockedGrid.savedWidth) {
    this.lockedGrid.setWidth(this.lockedGrid.savedWidth);
  }
}, beforeCrudOperationStart:function(manager, params, type) {
  if (this.rendered) {
    this.setLoading({msg:type === 'load' ? this.L('loadingText') : this.L('savingText')});
  } else {
    Ext.destroy(this.renderWaitListener);
    this.renderWaitListener = this.on('render', Ext.Function.bind(this.beforeCrudOperationStart, this, Array.prototype.slice.apply(arguments)), this, {delay:1, destroyable:true});
  }
}, onCrudBeforeLoad:function() {
  this.suspendRefresh();
}, onCrudLoad:function() {
  this.resumeRefresh(true);
}, onCrudOperationComplete:function() {
  Ext.destroy(this.renderWaitListener);
  this.setLoading(false);
}, onSchedulePinchStart:function(view, e) {
  this.pinchStartDistanceX = Math.abs(e.touches[0].pageX - e.touches[1].pageX);
  this.pinchStartDistanceY = Math.abs(e.touches[0].pageY - e.touches[1].pageY);
}, onSchedulePinch:function(view, e) {
  this.pinchDistanceX = Math.abs(e.touches[0].pageX - e.touches[1].pageX);
  this.pinchDistanceY = Math.abs(e.touches[0].pageY - e.touches[1].pageY);
}, onSchedulePinchEnd:function(view) {
  var xDistance = this.pinchDistanceX;
  var yDistance = this.pinchDistanceY;
  var isHorizontal = this.isHorizontal();
  if (Math.abs(xDistance - this.pinchStartDistanceX) > this.schedulePinchThreshold) {
    var scaleX = Math.abs(xDistance / this.pinchStartDistanceX);
    if (isHorizontal) {
      scaleX > 1 ? this.zoomIn() : this.zoomOut();
    } else {
      this.timeAxisViewModel.setViewColumnWidth(scaleX * this.timeAxisViewModel.resourceColumnWidth);
    }
  }
  if (Math.abs(yDistance - this.pinchStartDistanceY) > this.schedulePinchThreshold) {
    var scaleY = Math.abs(yDistance / this.pinchStartDistanceY);
    view.setRowHeight(view.getRowHeight() * scaleY);
  }
  this.pinchStartDistanceX = this.pinchStartDistanceY = this.pinchDistanceX = this.pinchDistanceY = null;
}, patchNavigationModel:function(me) {
  me.getView().getNavigationModel().focusItem = function(item) {
    item.addCls(this.focusCls);
    if ((Ext.isIE || Ext.isEdge) && !item.hasCls('sch-timetd') || !(Ext.isIE || Ext.isEdge) && me.isHorizontal()) {
      item.focus();
    }
  };
  var lockedView = me.lockedGrid.getView();
  var normalView = me.normalGrid.getView();
  lockedView.on('rowclick', function(view, record, tr, rowIndex) {
    if (normalView.lastFocused) {
      normalView.lastFocused.rowIdx = rowIndex;
      normalView.lastFocused.record = record;
    } else {
      if (Ext.isIE) {
        normalView.lastFocused = this.lastFocused;
      }
    }
  });
  normalView.on('rowclick', function(view, record, tr, rowIndex) {
    if (lockedView.lastFocused) {
      lockedView.lastFocused.rowIdx = rowIndex;
      lockedView.lastFocused.record = record;
    } else {
      if (Ext.isIE) {
        lockedView.lastFocused = this.lastFocused;
      }
    }
  });
}, patchHeaderScrollSync:function(me) {
  function sync() {
    (me.normalGrid || me).headerCt.getScrollable().syncWithPartners();
  }
  function patch() {
    me.patchHeaderScrollSyncDetacher && Ext.destroy(me.patchHeaderScrollSyncDetacher);
    me.patchHeaderScrollSyncDetacher = me.store && me.mon(me.store, {'nodeexpand':sync, 'nodecollapse':sync, buffer:1, destroyable:true});
  }
  patch();
  me.on('storechange', patch);
}, configureChildGrids:function() {
  var me = this;
  me.lockedGridConfig = Ext.apply({}, me.lockedGridConfig || {});
  me.normalGridConfig = Ext.apply({}, me.schedulerConfig || me.normalGridConfig || {});
  var lockedGrid = me.lockedGridConfig, normalGrid = me.normalGridConfig;
  if (me.lockedXType) {
    lockedGrid.xtype = me.lockedXType;
  }
  if (me.normalXType) {
    normalGrid.xtype = me.normalXType;
  }
  Ext.applyIf(lockedGrid, {useArrows:true, animCollapse:false, collapseDirection:'left', trackMouseOver:false});
  Ext.applyIf(normalGrid, {viewType:me.viewType, enableColumnMove:false, enableColumnResize:false, enableColumnHide:false, trackMouseOver:false, collapseDirection:'right', collapseMode:'placeholder', animCollapse:false});
  if (me.isVertical()) {
    lockedGrid.store = normalGrid.store = me.timeAxis;
  }
  if (lockedGrid.width) {
    me.syncLockedWidth = Ext.emptyFn;
    lockedGrid.scroll = Ext.supports.Touch ? 'both' : 'horizontal';
    lockedGrid.scrollerOwner = true;
  }
}, afterInitComponent:function() {
  var me = this;
  var lockedView = me.lockedGrid.getView();
  var normalView = me.normalGrid.getView();
  var isTree = me.store && me.store.isTreeStore;
  if (me.normalGrid.collapsed) {
    me.normalGrid.collapsed = false;
    normalView.on('boxready', function() {
      me.normalGrid.collapse();
    }, me, {delay:10});
  }
  if (me.lockedGrid.collapsed) {
    me.lockedGrid.collapsed = false;
    lockedView.on('boxready', function() {
      me.lockedGrid.collapse();
    }, me, {delay:10});
    if (lockedView.bufferedRenderer) {
      lockedView.bufferedRenderer.disabled = true;
    }
  }
  if (isTree) {
    this.setupLockableFilterableTree();
  }
  var splitter = this.getSplitter();
  if (splitter) {
    splitter.addCls('sch-timelinepanel-splitter');
    splitter.setVisible(this.isHorizontal());
  }
  if (Ext.versions.extjs.isGreaterThan('6.2.0')) {
    this.normalGrid.on('cellclick', this.onNormalGridCellClick, this);
  }
  if (this.zoomOnTimeAxisDoubleClick) {
    this.on('timeheaderdblclick', function(me, tickStart, tickEnd) {
      if (this.isHorizontal()) {
        this.zoomToSpan({start:tickStart, end:tickEnd});
      }
    });
  }
}, onNormalGridCellClick:function(panel, td, cellIndex, record, tr, rowIndex, e) {
  if (td.className.match('sch-timetd')) {
    var selectionModel = this.getSelectionModel();
    var deselect = e.ctrlKey && selectionModel.isSelected(rowIndex);
    if (deselect) {
      selectionModel.deselect(rowIndex);
    } else {
      selectionModel.select(rowIndex, e.ctrlKey);
    }
  }
}, getSplitter:function() {
  return this.child('splitter');
}, setupLockableFilterableTree:function() {
  var me = this;
  var lockedView = me.lockedGrid.getView();
  var filterableProto = Sch.mixin.FilterableTreeView.prototype;
  lockedView.initTreeFiltering = filterableProto.initTreeFiltering;
  lockedView.onFilterChangeStart = filterableProto.onFilterChangeStart;
  lockedView.onFilterChangeEnd = filterableProto.onFilterChangeEnd;
  lockedView.onFilterCleared = filterableProto.onFilterCleared;
  lockedView.onFilterSet = filterableProto.onFilterSet;
  lockedView.initTreeFiltering();
}, showMenuBy:function(t, header) {
  var menu = this.getMenu(), unlockItem = menu.down('#unlockItem'), lockItem = menu.down('#lockItem'), sep = unlockItem.prev();
  sep.hide();
  unlockItem.hide();
  lockItem.hide();
}, zoomToFit:function(options) {
  options = Ext.apply({adjustStart:1, adjustEnd:1}, options);
  var eventStore = this.getEventStore();
  var span = this.getEventStore().getTotalTimeSpan();
  if (this.zoomToSpan(span, options) === null) {
    this.getSchedulingView().fitColumns();
  }
}, refreshViews:function(keepScrollPosition) {
  if (!this.rendered) {
    return;
  }
  var refreshed = false;
  var schedulingViewListener = function() {
    refreshed = true;
  };
  var schedulingView = this.normalGrid.getView();
  var lockedView = this.lockedGrid.getView(), scroll = {left:lockedView.getScrollX(), top:schedulingView.getVerticalScroll()};
  schedulingView.on('refresh', schedulingViewListener);
  lockedView.refreshView();
  schedulingView.un('refresh', schedulingViewListener);
  if (keepScrollPosition !== false) {
    !refreshed && this.getSchedulingView().refreshKeepingScroll();
    lockedView.setScrollX(scroll.left);
    lockedView.setScrollY(scroll.top);
  } else {
    if (!refreshed) {
      this.getSchedulingView().refreshView();
    }
  }
}, getCalendar:function() {
  return this.calendar;
}, disableWeekendHighlighting:function(disabled) {
  this.workingTimePlugin.setDisabled(disabled);
  if (disabled) {
    this.removeCls('sch-timelinepanel-highlightweekends');
  } else {
    this.addCls('sch-timelinepanel-highlightweekends');
  }
}, preventRefresh:function() {
  return false;
}, suspendRefresh:function() {
  var me = this;
  if (me.refreshSuspensionCount++ === 0) {
    me.getView().on('beforerefresh', me.preventRefresh, me);
    me.normalGrid.view.blockRefresh = true;
    me.lockedGrid.view.blockRefresh = true;
  }
}, resumeRefresh:function(triggerRefresh) {
  var me = this;
  if (me.refreshSuspensionCount && !--me.refreshSuspensionCount) {
    me.getView().un('beforerefresh', me.preventRefresh, me);
    me.normalGrid.view.blockRefresh = false;
    me.lockedGrid.view.blockRefresh = false;
    if (triggerRefresh) {
      me.refreshViews();
    }
  }
}}, 0, 0, 0, 0, 0, [[Sch.mixin.Zoomable.prototype.mixinId || Sch.mixin.Zoomable.$className, Sch.mixin.Zoomable], [Sch.mixin.PartnerTimelinePanel.prototype.mixinId || Sch.mixin.PartnerTimelinePanel.$className, Sch.mixin.PartnerTimelinePanel]], [Sch.mixin, 'TimelinePanel'], function() {
  var MIN_EXT_VERSION = '6.0.0';
  Ext.apply(Sch, {VERSION:'5.1.16'});
  if (Ext.versions.extjs.isLessThan(MIN_EXT_VERSION)) {
    var c = console;
    c && c.log('The Ext JS version you are using needs to be updated to at least ' + MIN_EXT_VERSION);
  }
  if (Ext.getVersion().isGreaterThan('6.0.2')) {
    Ext.define(null, {override:'Ext.grid.plugin.BufferedRenderer', doRefreshView:function() {
      if (this.view.ownerGrid.is('timelinegrid,timelinetree')) {
        var oldIgnore = Ext.Error.ignore;
        Ext.Error.ignore = true;
        this.callParent(arguments);
        Ext.Error.ignore = oldIgnore;
      } else {
        this.callParent(arguments);
      }
    }});
  }
});
Ext.cmd.derive('Sch.panel.TimelineGridPanel', Ext.grid.Panel, {subGridXType:'gridpanel', isTimelineGridPanel:true, initComponent:function() {
  Ext.grid.Panel.prototype.initComponent.apply(this, arguments);
  this.getSchedulingView()._initializeTimelineView();
}}, 0, ['timelinegrid'], ['component', 'box', 'container', 'panel', 'tablepanel', 'gridpanel', 'grid', 'timelinegrid'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'gridpanel':true, 'grid':true, 'timelinegrid':true}, ['widget.timelinegrid'], [[Sch.mixin.Localizable.prototype.mixinId || Sch.mixin.Localizable.$className, Sch.mixin.Localizable], [Sch.mixin.TimelinePanel.prototype.mixinId || Sch.mixin.TimelinePanel.$className, Sch.mixin.TimelinePanel]], [Sch.panel, 
'TimelineGridPanel'], function() {
  this.override(Sch.mixin.TimelinePanel.prototype.inheritables() || {});
});
Ext.cmd.derive('Sch.template.DependencyInfo', Ext.XTemplate, {text:'\x3cdl class\x3d"sch-dep-tip sch-dep-tip-{[values.valid ? \'valid\' : \'invalid\']}"\x3e\x3cdiv class\x3d"x-fa fa-{[values.valid ? \'check-circle\' : \'times-circle\']}"\x3e\x3c/div\x3e\x3cdt class\x3d"sch-dep-tip-from-title"\x3e__FROM__:\x3c/dt\x3e\x3cdd class\x3d"sch-dep-tip-from-value"\x3e{[Ext.htmlEncode(values.fromTask.getName()) || "\x26nbsp;"]}\x3c/dd\x3e\x3cdt class\x3d"sch-dep-tip-to-title"\x3e__TO__:\x3c/dt\x3e\x3cdd class\x3d"sch-dep-tip-to-value"\x3e{[values.toTask \x26\x26 Ext.htmlEncode(values.toTask.getName()) || "\x26nbsp;"]}\x3c/dd\x3e\x3c/dl\x3e', 
constructor:function() {
  var me = this;
  me.text = me.text.replace(/__FROM__/, me.L('fromText')).replace(/__TO__/, me.L('toText'));
  Ext.XTemplate.prototype.constructor.call(this, me.text);
}}, 1, 0, 0, 0, 0, [[Sch.mixin.Localizable.prototype.mixinId || Sch.mixin.Localizable.$className, Sch.mixin.Localizable]], [Sch.template, 'DependencyInfo'], 0);
Ext.cmd.derive('Sch.view.dependency.DropZone', Ext.dd.DropZone, {terminalSelector:null, dependencyStore:null, toText:null, startText:null, endText:null, view:null, tipTpl:null, tip:null, constructor:function(el, config) {
  this.mixins.observable.constructor.call(this, config);
  Ext.dd.DropZone.prototype.constructor.apply(this, arguments);
}, getTargetFromEvent:function(e) {
  return e.getTarget(this.terminalSelector);
}, onNodeEnter:function(target, dd, e, data) {
  var me = this, targetRecord = me.view.resolveEventRecord(target), toSide = target.className.match(/sch-terminal-(\w+)/)[1], targetId = targetRecord.getId() || targetRecord.internalId, tplData = Ext.apply({toTask:targetRecord, toSide:toSide}, data.tplData);
  if (!me.tip) {
    me.tip = me.createTooltip();
  }
  data.valid = tplData.valid = me.isValidLink(data.fromId, targetId, dd.dragData.fromSide, toSide);
  me.tip.setData(tplData);
  me.tip.showBy(target);
  Ext.fly(target).addCls('sch-terminal-' + (data.valid ? 'valid' : 'invalid') + '-drop');
}, createTooltip:function() {
  var me = this;
  return new Ext.tip.ToolTip({tpl:me.tipTpl, view:me.view, cls:'sch-create-dependency-tip', constrain:true, anchor:'t', trackMouse:false, hideDelay:0, dismissDelay:0, delegate:me.terminalSelector, target:me.view.getEl(), constraintInsets:'7 -7 -7 7'});
}, onNodeOut:function(target, dd, e, data) {
  data.valid = false;
  Ext.fly(target).removeCls(['sch-terminal-valid-drop', 'sch-terminal-invalid-drop']);
}, onNodeOver:function(target, dd, e, data) {
  return data.valid ? this.dropAllowed : this.dropNotAllowed;
}, onNodeDrop:function(target, dz, e, data) {
  var me = this, targetRec = me.view.resolveEventRecord(target), toSide = target.className.match(/sch-terminal-(\w+)/)[1], targetId = targetRec.getId() || targetRec.internalId, valid = data.valid, newDependency = me.createDependencyModel(dz.dragData.fromId, targetId, data.fromSide, toSide);
  me.fireEvent('drop', me, newDependency, valid);
  me.fireEvent('afterdrop', me);
  return valid;
}, createDependencyModel:function(fromId, toId, fromSide, toSide) {
  var dependencyStore = this.dependencyStore, newDependency = new (dependencyStore.getModel());
  newDependency.setSourceId(fromId);
  newDependency.setTargetId(toId);
  newDependency instanceof Sch.model.Dependency && newDependency.setFromSide(fromSide);
  newDependency instanceof Sch.model.Dependency && newDependency.setToSide(toSide);
  newDependency.setType(newDependency.getTypeFromSides(fromSide, toSide, this.view.rtl));
  return newDependency;
}, isValidLink:function(fromId, toId, fromSide, toSide) {
  var newDependency = this.createDependencyModel(fromId, toId, fromSide, toSide);
  return this.dependencyStore.isValidDependency(newDependency);
}, destroyTip:function() {
  var me = this;
  me.tip && me.tip.destroy();
  me.tip = null;
}, destroy:function() {
  var me = this;
  me.destroyTip();
  Ext.dd.DropZone.prototype.destroy.apply(this, arguments);
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Sch.view.dependency, 'DropZone'], 0);
Ext.cmd.derive('Sch.view.dependency.DragZone', Ext.dd.DragZone, {terminalSelector:null, view:null, fromText:null, toText:null, startText:null, endText:null, rtl:false, useLineProxy:true, dependencyStore:null, tipTpl:null, constructor:function(config) {
  var me = this;
  me.mixins.observable.constructor.call(this, config);
  Ext.dd.DragZone.prototype.constructor.call(this, config.view.getEl(), config);
  me.tipTpl = me.tipTpl || new Sch.template.DependencyInfo;
  if (!(me.tipTpl instanceof Ext.Template)) {
    me.tipTpl = new Ext.XTemplate(me.tipTpl);
  }
  me.dropZone = me.createDropZone();
  me.relayEvents(me.dropZone, ['drop', 'afterdrop']);
  me.on({dragstart:me.onDependencyDragStart, afterdrop:me.onDependencyAfterDrop, scope:me});
}, onDependencyDragStart:function() {
  Sch.util.ScrollManager.activate(this.view);
}, onDependencyAfterDrop:function() {
  Sch.util.ScrollManager.deactivate();
  this.dropZone.destroyTip();
}, createDropZone:function() {
  return new Sch.view.dependency.DropZone(this.el, this.getDropZoneConfig());
}, getDropZoneConfig:function() {
  return {rtl:this.rtl, terminalSelector:this.terminalSelector, ddGroup:this.ddGroup, view:this.view, dependencyStore:this.dependencyStore, tipTpl:this.tipTpl};
}, initLineProxy:function(sourceNode) {
  var me = this, scroll = me.view.getScroll(), offsets = Ext.fly(sourceNode).getOffsetsTo(me.view.el), halfTerminalSize = Ext.fly(sourceNode).getWidth() / 2, posX = offsets[0] + halfTerminalSize, posY = offsets[1] + halfTerminalSize;
  posX = posX + scroll.left;
  posY = Ext.getVersion().isLessThan('6.2.0') ? posY + scroll.top : posY;
  me.lineProxyEl = me.el.createChild({cls:'sch-dependency-connector-proxy', style:'top:' + posY + 'px;left:' + posX + 'px'});
  Ext.apply(me, {containerTop:me.el.getTop(), containerLeft:me.el.getLeft(), startXY:[posX, posY], startScrollLeft:scroll.left, startScrollTop:scroll.top});
}, updateLineProxy:function(pageXY) {
  var me = this, lineProxy = me.lineProxyEl, scroll = me.view.getScroll(), viewElRect = me.view.el.dom.getBoundingClientRect(), diffX = pageXY[0] - viewElRect.left - me.startXY[0] + scroll.left, diffY = pageXY[1] - viewElRect.top - me.startXY[1] + (Ext.getVersion().isLessThan('6.2.0') ? scroll.top : 0), newHeight = Math.max(1, Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) - 2), rad = Math.atan2(diffY, diffX) - Math.PI / 2, styleBlob;
  if (Ext.isIE9m) {
    var cos = Math.cos(rad), sin = Math.sin(rad), matrixString = 'progid:DXImageTransform.Microsoft.Matrix(sizingMethod\x3d"auto expand", M11 \x3d ' + cos + ', M12 \x3d ' + -sin + ', M21 \x3d ' + sin + ', M22 \x3d ' + cos + ')', scrollValueTop, scrollValueLeft;
    if (scroll.top !== me.startScrollTop) {
      scrollValueTop = me.startScrollTop - me.containerTop;
    } else {
      scrollValueTop = scroll.top - me.containerTop;
    }
    if (scroll.left !== me.startScrollLeft) {
      scrollValueLeft = me.startScrollLeft - me.containerLeft;
    } else {
      scrollValueLeft = scroll.left - me.containerLeft;
    }
    styleBlob = {'height':newHeight + 'px', 'top':Math.min(0, diffY) + me.startXY[1] + scrollValueTop + (diffY < 0 ? 2 : 0) + 'px', 'left':Math.min(0, diffX) + me.startXY[0] + scrollValueLeft + (diffX < 0 ? 2 : 0) + 'px', 'filter':matrixString, '-ms-filter':matrixString};
  } else {
    var rotateString = 'rotate(' + rad + 'rad)';
    styleBlob = {'height':newHeight + 'px', 'transform':rotateString};
  }
  lineProxy.setStyle(styleBlob);
}, getDragData:function(e) {
  var me = this, sourceNode = e.getTarget(me.terminalSelector);
  if (e.button === 0 && sourceNode) {
    var sourceTaskRecord = me.view.resolveEventRecord(sourceNode);
    if (me.fireEvent('beforedrag', me, sourceTaskRecord) === false) {
      return null;
    }
    var side = sourceNode.className.match(/sch-terminal-(\w+)/)[1], tplData = {fromTask:sourceTaskRecord, fromSide:side}, ddel = document.createElement('div');
    sourceNode.style.display = 'block';
    return {fromId:sourceTaskRecord.getId() || sourceTaskRecord.internalId, fromSide:side, tplData:tplData, repairXY:Ext.fly(sourceNode).getXY(), ddel:ddel, valid:false, sourceTerminal:sourceNode};
  }
  return false;
}, onStartDrag:function(x, y) {
  var me = this, dd = me.dragData, sourceNode = dd.sourceTerminal, sideCls = sourceNode.className.match(/sch-terminal-(\w+)/)[0];
  me.fireEvent('dragstart', me);
  if (me.useLineProxy) {
    me.initLineProxy(sourceNode, dd.isStart);
    me.lineProxyEl.show();
  }
  me.proxy.setStyle('display', 'none');
  Ext.fly(dd.sourceTerminal.parentNode).select('.sch-terminal:not(.' + sideCls + ')').addCls('sch-terminal-hidden');
}, onDrag:function(e, t) {
  this.useLineProxy && this.updateLineProxy(e.getXY());
}, afterRepair:function() {
  var me = this;
  me.dragging = false;
  if (!me.destroyed) {
    me.fireEvent('afterdrop', me.dropZone);
  }
}, onMouseUp:function() {
  var me = this;
  me.el.removeCls('sch-terminals-visible');
  me.dragData.sourceTerminal.style.display = '';
  if (me.lineProxyEl) {
    var duration = Ext.isIE9m ? 0 : 400, el = me.lineProxyEl;
    el.animate({to:{height:0}, duration:duration, callback:function() {
      Ext.destroy(el);
    }});
    me.lineProxyEl = null;
  }
}, getRepairXY:function() {
  return this.dragData.repairXY;
}, destroy:function() {
  var me = this;
  Ext.destroy([me.lineProxyEl, me.dropZone]);
  Ext.dd.DragZone.prototype.destroy.apply(this, arguments);
}}, 1, 0, 0, 0, ['schdependencydragzone.default'], [['factoryable', Ext.mixin.Factoryable], ['observable', Ext.util.Observable]], [Sch.view.dependency, 'DragZone'], 0);
Ext.cmd.derive('Sch.util.RectangularPathFinder', Ext.Base, {config:{startSide:'right', startArrowSize:8, startArrowMargin:6, startShift:0, endSide:'left', endArrowSize:8, endArrowMargin:6, endShift:0, verticalMargin:2, horizontalMargin:5, otherBoxes:null}, constructor:function(config) {
  var me = this;
  me.callParent([config]);
  me.initConfig(config);
}, findPath:function(lineDef, noPathFallbackFn) {
  var me = this, lineDefFull, startBox, endBox, startShift, endShift, startSide, endSide, startArrowSize, endArrowSize, startArrowMargin, endArrowMargin, horizontalMargin, verticalMargin, startHorizontalMargin, startVerticalMargin, endHorizontalMargin, endVerticalMargin, otherBoxes, connStartPoint, connEndPoint, pathStartPoint, pathEndPoint, gridStartPoint, gridEndPoint, startGridBox, endGridBox, grid, path, tryNum;
  if (noPathFallbackFn && !Ext.isArray(noPathFallbackFn)) {
    noPathFallbackFn = [noPathFallbackFn];
  }
  for (tryNum = 0; lineDef && !path;) {
    lineDefFull = Ext.applyIf(lineDef, me.getConfig());
    startBox = lineDefFull.startBox, endBox = lineDefFull.endBox, startShift = lineDefFull.startShift, endShift = lineDefFull.endShift, startSide = lineDefFull.startSide, endSide = lineDefFull.endSide, startArrowSize = lineDefFull.startArrowSize, endArrowSize = lineDefFull.endArrowSize, startArrowMargin = lineDefFull.startArrowMargin, endArrowMargin = lineDefFull.endArrowMargin, horizontalMargin = lineDefFull.horizontalMargin, verticalMargin = lineDefFull.verticalMargin, startHorizontalMargin = lineDefFull.hasOwnProperty('startHorizontalMargin') ? 
    lineDefFull.startHorizontalMargin : horizontalMargin, startVerticalMargin = lineDefFull.hasOwnProperty('startVerticalMargin') ? lineDefFull.startVerticalMargin : verticalMargin, endHorizontalMargin = lineDefFull.hasOwnProperty('endHorizontalMargin') ? lineDefFull.endHorizontalMargin : horizontalMargin, endVerticalMargin = lineDefFull.hasOwnProperty('endVerticalMargin') ? lineDefFull.endVerticalMargin : verticalMargin, otherBoxes = lineDefFull.otherBoxes;
    startSide = me.normalizeSide(startSide);
    endSide = me.normalizeSide(endSide);
    connStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startBox, startSide, startShift);
    connEndPoint = me.getConnectionCoordinatesFromBoxSideShift(endBox, endSide, endShift);
    startGridBox = me.calcGridBaseBoxFromBoxAndDrawParams(startBox, startSide, startArrowSize, startArrowMargin, startHorizontalMargin, startVerticalMargin);
    endGridBox = me.calcGridBaseBoxFromBoxAndDrawParams(endBox, endSide, endArrowSize, endArrowMargin, endHorizontalMargin, endVerticalMargin);
    otherBoxes = otherBoxes && Ext.Array.map(otherBoxes, function(box) {
      return me.calcGridBaseBoxFromBoxAndDrawParams(box, false, 0, 0, horizontalMargin, verticalMargin);
    });
    pathStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startGridBox, startSide, startShift);
    pathEndPoint = me.getConnectionCoordinatesFromBoxSideShift(endGridBox, endSide, endShift);
    grid = me.buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherBoxes);
    gridStartPoint = me.convertDecartPointToGridPoint(grid, pathStartPoint);
    gridEndPoint = me.convertDecartPointToGridPoint(grid, pathEndPoint);
    path = me.findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide);
    for (lineDef = false; !path && !lineDef && noPathFallbackFn && tryNum < noPathFallbackFn.length; tryNum++) {
      lineDef = noPathFallbackFn[tryNum](lineDefFull);
    }
  }
  if (path) {
    path = me.prependPathWithArrowStaffSegment(path, connStartPoint, startArrowSize, startSide);
    path = me.appendPathWithArrowStaffSegment(path, connEndPoint, endArrowSize, endSide);
    path = me.optimizePath(path);
  }
  return path;
}, getConnectionCoordinatesFromBoxSideShift:function(box, side, shift) {
  var coords;
  switch(side) {
    case 'left':
      coords = {x:box.start, y:(box.top + box.bottom) / 2 + shift};
      break;
    case 'right':
      coords = {x:box.end, y:(box.top + box.bottom) / 2 + shift};
      break;
    case 'top':
      coords = {x:(box.start + box.end) / 2 + shift, y:box.top};
      break;
    case 'bottom':
      coords = {x:(box.start + box.end) / 2 + shift, y:box.bottom};
      break;
  }
  return coords;
}, calcGridBaseBoxFromBoxAndDrawParams:function(box, side, arrowSize, arrowMargin, horizontalMargin, verticalMargin) {
  var gridBox;
  switch(side) {
    case 'left':
      gridBox = {start:box.start - Math.max(arrowSize + arrowMargin, horizontalMargin), end:box.end + horizontalMargin, top:box.top - verticalMargin, bottom:box.bottom + verticalMargin};
      break;
    case 'right':
      gridBox = {start:box.start - horizontalMargin, end:box.end + Math.max(arrowSize + arrowMargin, horizontalMargin), top:box.top - verticalMargin, bottom:box.bottom + verticalMargin};
      break;
    case 'top':
      gridBox = {start:box.start - horizontalMargin, end:box.end + horizontalMargin, top:box.top - Math.max(arrowSize + arrowMargin, verticalMargin), bottom:box.bottom + verticalMargin};
      break;
    case 'bottom':
      gridBox = {start:box.start - horizontalMargin, end:box.end + horizontalMargin, top:box.top - verticalMargin, bottom:box.bottom + Math.max(arrowSize + arrowMargin, verticalMargin)};
      break;
    default:
      gridBox = {start:box.start - horizontalMargin, end:box.end + horizontalMargin, top:box.top - verticalMargin, bottom:box.bottom + verticalMargin};
  }
  return gridBox;
}, buildPathGrid:function(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherGridBoxes) {
  var xs, ys, y, x, ix, iy, xslen, yslen, ib, blen, box, permitted, point, points = {}, linearPoints = [];
  xs = [startGridBox.start, startSide == 'left' || startSide == 'right' ? (startGridBox.start + startGridBox.end) / 2 : pathStartPoint.x, startGridBox.end, endGridBox.start, endSide == 'left' || endSide == 'right' ? (endGridBox.start + endGridBox.end) / 2 : pathEndPoint.x, endGridBox.end];
  ys = [startGridBox.top, startSide == 'top' || startSide == 'bottom' ? (startGridBox.top + startGridBox.bottom) / 2 : pathStartPoint.y, startGridBox.bottom, endGridBox.top, endSide == 'top' || endSide == 'bottom' ? (endGridBox.top + endGridBox.bottom) / 2 : pathEndPoint.y, endGridBox.bottom];
  if (otherGridBoxes) {
    Ext.Array.forEach(otherGridBoxes, function(box) {
      xs.push(box.start, (box.start + box.end) / 2, box.end);
      ys.push(box.top, (box.top + box.bottom) / 2, box.bottom);
    });
  }
  xs = Ext.Array.unique(Ext.Array.sort(xs, Ext.Array.numericSortFn));
  ys = Ext.Array.unique(Ext.Array.sort(ys, Ext.Array.numericSortFn));
  for (iy = 0, yslen = ys.length; iy < yslen; ++iy) {
    points[iy] = points[iy] || {};
    y = ys[iy];
    for (ix = 0, xslen = xs.length; ix < xslen; ++ix) {
      x = xs[ix];
      permitted = (x <= startGridBox.start || x >= startGridBox.end || y <= startGridBox.top || y >= startGridBox.bottom) && (x <= endGridBox.start || x >= endGridBox.end || y <= endGridBox.top || y >= endGridBox.bottom);
      if (otherGridBoxes) {
        for (ib = 0, blen = otherGridBoxes.length; permitted && ib < blen; ++ib) {
          box = otherGridBoxes[ib];
          permitted = x <= box.start || x >= box.end || y <= box.top || y >= box.bottom;
        }
      }
      point = {distance:Math.pow(2, 53) - 1, permitted:permitted, x:x, y:y, ix:ix, iy:iy};
      points[iy][ix] = point;
      linearPoints.push(point);
    }
  }
  return {width:xs.length, height:ys.length, xs:xs, ys:ys, points:points, linearPoints:linearPoints};
}, convertDecartPointToGridPoint:function(grid, point) {
  var x = Ext.Array.indexOf(grid.xs, point.x), y = Ext.Array.indexOf(grid.ys, point.y);
  return grid.points[y][x];
}, findPathOnGrid:function(grid, gridStartPoint, gridEndPoint, startSide, endSide) {
  var me = this, path = false;
  if (gridStartPoint.permitted && gridEndPoint.permitted) {
    grid = me.waveForward(grid, gridStartPoint, 0);
    path = me.collectPath(grid, gridEndPoint, endSide);
  }
  return path;
}, getGridPointNeighbors:function(grid, gridPoint, predicateFn) {
  var ix = gridPoint.ix, iy = gridPoint.iy, result = [], neighbor;
  if (iy < grid.height - 1) {
    neighbor = grid.points[iy + 1][ix];
    (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
  }
  if (iy > 0) {
    neighbor = grid.points[iy - 1][ix];
    (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
  }
  if (ix < grid.width - 1) {
    neighbor = grid.points[iy][ix + 1];
    (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
  }
  if (ix > 0) {
    neighbor = grid.points[iy][ix - 1];
    (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
  }
  return result;
}, waveForward:function(grid, gridStartPoint, distance) {
  var me = this, neighbors, i, len, neighbor, neighborDistance, neighborDir, xDiff, yDiff;
  gridStartPoint.distance = distance;
  neighbors = me.getGridPointNeighbors(grid, gridStartPoint, function(point) {
    return point.permitted && point.distance > distance + 1;
  });
  for (i = 0, len = neighbors.length; i < len; ++i) {
    neighbor = neighbors[i];
    neighbor.distance = distance + 1;
  }
  for (i = 0, len = neighbors.length; i < len; ++i) {
    neighbor = neighbors[i];
    me.waveForward(grid, neighbor, distance + 1);
  }
  return grid;
}, collectPath:function(grid, gridEndPoint, endSide) {
  var me = this, pathFound = true, neighbors, lowestDistanceNeighbor, xDiff, yDiff, path = [];
  while (pathFound && gridEndPoint.distance) {
    neighbors = me.getGridPointNeighbors(grid, gridEndPoint, function(point) {
      return point.permitted && point.distance == gridEndPoint.distance - 1;
    });
    pathFound = neighbors.length > 0;
    if (pathFound) {
      neighbors = Ext.Array.sort(neighbors, function(a, b) {
        var xDiff, yDiff;
        xDiff = a.ix - gridEndPoint.ix;
        yDiff = a.iy - gridEndPoint.iy;
        var result_a = (endSide == 'left' || endSide == 'right') && yDiff === 0 || (endSide == 'top' || endSide == 'bottom') && xDiff === 0 ? -1 : 1;
        xDiff = b.ix - gridEndPoint.ix;
        yDiff = b.iy - gridEndPoint.iy;
        var result_b = (endSide == 'left' || endSide == 'right') && yDiff === 0 || (endSide == 'top' || endSide == 'bottom') && xDiff === 0 ? -1 : 1;
        if (result_a > result_b) {
          return 1;
        } else {
          if (result_a < result_b) {
            return -1;
          } else {
            if (result_a == result_b) {
              return a.y > b.y ? -1 : 1;
            }
          }
        }
      });
      lowestDistanceNeighbor = neighbors[0];
      path.push({x1:lowestDistanceNeighbor.x, y1:lowestDistanceNeighbor.y, x2:gridEndPoint.x, y2:gridEndPoint.y});
      xDiff = lowestDistanceNeighbor.ix - gridEndPoint.ix;
      yDiff = lowestDistanceNeighbor.iy - gridEndPoint.iy;
      switch(true) {
        case !yDiff && xDiff > 0:
          endSide = 'left';
          break;
        case !yDiff && xDiff < 0:
          endSide = 'right';
          break;
        case !xDiff && yDiff > 0:
          endSide = 'top';
          break;
        case !xDiff && yDiff < 0:
          endSide = 'bottom';
          break;
      }
      gridEndPoint = lowestDistanceNeighbor;
    }
  }
  return pathFound && path.reverse() || false;
}, prependPathWithArrowStaffSegment:function(path, connStartPoint, startArrowSize, startSide) {
  var prependSegment, firstSegment;
  if (path.length > 0) {
    firstSegment = path[0];
    prependSegment = {x2:firstSegment.x1, y2:firstSegment.y1};
    switch(startSide) {
      case 'left':
        prependSegment.x1 = connStartPoint.x - startArrowSize;
        prependSegment.y1 = firstSegment.y1;
        break;
      case 'right':
        prependSegment.x1 = connStartPoint.x + startArrowSize;
        prependSegment.y1 = firstSegment.y1;
        break;
      case 'top':
        prependSegment.x1 = firstSegment.x1;
        prependSegment.y1 = connStartPoint.y - startArrowSize;
        break;
      case 'bottom':
        prependSegment.x1 = firstSegment.x1;
        prependSegment.y1 = connStartPoint.y + startArrowSize;
        break;
    }
    path.unshift(prependSegment);
  }
  return path;
}, appendPathWithArrowStaffSegment:function(path, connEndPoint, endArrowSize, endSide) {
  var appendSegment, lastSegment;
  if (path.length > 0) {
    lastSegment = path[path.length - 1];
    appendSegment = {x1:lastSegment.x2, y1:lastSegment.y2};
    switch(endSide) {
      case 'left':
        appendSegment.x2 = connEndPoint.x - endArrowSize;
        appendSegment.y2 = lastSegment.y2;
        break;
      case 'right':
        appendSegment.x2 = connEndPoint.x + endArrowSize;
        appendSegment.y2 = lastSegment.y2;
        break;
      case 'top':
        appendSegment.x2 = lastSegment.x2;
        appendSegment.y2 = connEndPoint.y - endArrowSize;
        break;
      case 'bottom':
        appendSegment.x2 = lastSegment.x2;
        appendSegment.y2 = connEndPoint.y + endArrowSize;
        break;
    }
    path.push(appendSegment);
  }
  return path;
}, optimizePath:function(path) {
  var optPath = [], prevSegment, curSegment;
  if (path.length > 0) {
    prevSegment = path.shift();
    optPath.push(prevSegment);
    while (path.length > 0) {
      curSegment = path.shift();
      if (prevSegment.x1 == curSegment.x1 && prevSegment.y1 == curSegment.y1 && prevSegment.x2 == curSegment.x2 && prevSegment.y2 == curSegment.y2) {
        prevSegment = curSegment;
      } else {
        if (prevSegment.y1 - prevSegment.y2 === 0 && curSegment.y1 - curSegment.y2 === 0) {
          prevSegment.x2 = curSegment.x2;
        } else {
          if (prevSegment.x1 - prevSegment.x2 === 0 && curSegment.x1 - curSegment.x2 === 0) {
            prevSegment.y2 = curSegment.y2;
          } else {
            optPath.push(curSegment);
            prevSegment = curSegment;
          }
        }
      }
    }
  }
  return optPath;
}, normalizeSide:function(side) {
  return this.self.sideToSide[side] || side;
}, statics:{sideToSide:{'l':'left', 'r':'right', 't':'top', 'b':'bottom'}}}, 1, 0, 0, 0, ['schpathfinder.rectangular'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Sch.util, 'RectangularPathFinder'], 0);
Ext.cmd.derive('Sch.template.Dependency', Ext.XTemplate, {disableFormats:true, rtl:null, text:'\x3ctpl if\x3d"startArrow"\x3e\x3cdiv style\x3d"__SIDE__:{startArrow.side}px;top:{startArrow.top}px" class\x3d"sch-dependency sch-dependency-arrow sch-dependency-start-arrow sch-dependency-arrow-{startArrow.dir} {lineCls} {[ this.getSuffixedCls(values.cls, "-arrow") ]} {[ values.highlighted || "" ]}" \x3ctpl if\x3d"dependencyId"\x3edata-sch-dependency-id\x3d"{[values.dependencyId]}"\x3c/tpl\x3e\x3e\x3c/div\x3e\x3c/tpl\x3e\x3ctpl for\x3d"segments"\x3e\x3cdiv class\x3d"sch-dependency sch-dependency-line sch-dependency-line-{dir} {parent.lineCls} {[ parent.highlighted || "" ]} {[ this.getSuffixedCls(parent.cls, "-line") ]}" style\x3d"__SIDE__:{side}px;top:{top}px;\x3ctpl if\x3d"width !\x3d\x3d null \x26\x26 width !\x3d\x3d undefined"\x3ewidth:{width}px;\x3c/tpl\x3e\x3ctpl if\x3d"height !\x3d\x3d null \x26\x26 height !\x3d\x3d undefined"\x3eheight:{height}px\x3c/tpl\x3e" \x3ctpl if\x3d"parent.dependencyId"\x3edata-sch-dependency-id\x3d"{parent.dependencyId}"\x3c/tpl\x3e\x3e\x3c/div\x3e\x3c/tpl\x3e\x3ctpl if\x3d"endArrow"\x3e\x3cdiv style\x3d"__SIDE__:{endArrow.side}px;top:{endArrow.top}px" class\x3d"sch-dependency sch-dependency-arrow sch-dependency-end-arrow sch-dependency-arrow-{endArrow.dir} {lineCls} {[ this.getSuffixedCls(values.cls, "-arrow") ]} {[ values.highlighted || "" ]}" \x3ctpl if\x3d"dependencyId"\x3edata-sch-dependency-id\x3d"{dependencyId}"\x3c/tpl\x3e\x3e\x3c/div\x3e\x3c/tpl\x3e', 
constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  me.text = me.text.replace(/__SIDE__/g, me.rtl ? 'right' : 'left');
  Ext.XTemplate.prototype.constructor.call(this, me.text);
}, getSuffixedCls:function(cls, suffix) {
  var result = '';
  if (cls && cls.indexOf(' ') != -1) {
    result = cls.replace(/^\s*(.*)\s*$/, '$1').split(/\s+/).join(suffix + ' ') + suffix;
  } else {
    if (cls) {
      result = cls + suffix;
    }
  }
  return result;
}}, 1, 0, 0, 0, 0, 0, [Sch.template, 'Dependency'], 0);
Ext.cmd.derive('Sch.view.dependency.Painter', Ext.Base, function(thisClass) {
  function resetArrowMargins(lineDef) {
    var adjusted = false;
    if (lineDef.startArrowMargin > 0 || lineDef.endArrowMargin > 0) {
      lineDef.startArrowMargin = lineDef.endArrowMargin = 0;
      adjusted = true;
    }
    return adjusted ? lineDef : adjusted;
  }
  function shrinkStartEndMarginsBy2(lineDef) {
    var adjusted = false;
    if (lineDef.hasOwnProperty('startHorizontalMargin') && lineDef.startHorizontalMargin > 2) {
      lineDef.startHorizontalMargin = Math.round(lineDef.startHorizontalMargin / 2);
      adjusted = true;
    }
    if (lineDef.hasOwnProperty('startVerticalMargin') && lineDef.startVerticalMargin > 2) {
      lineDef.startVerticalMargin = Math.round(lineDef.startVerticalMargin / 2);
      adjusted = true;
    }
    if (lineDef.hasOwnProperty('endHorizontalMargin') && lineDef.endHorizontalMargin > 2) {
      lineDef.endHorizontalMargin = Math.round(lineDef.endHorizontalMargin / 2);
      adjusted = true;
    }
    if (lineDef.hasOwnProperty('endVerticalMargin') && lineDef.endVerticalMargin > 2) {
      lineDef.endVerticalMargin = Math.round(lineDef.endVerticalMargin / 2);
      adjusted = true;
    }
    return adjusted ? lineDef : adjusted;
  }
  function resetArrowSizes(lineDef) {
    var adjusted = false;
    if (lineDef.startArrowSize > 0 || lineDef.endArrowSize > 0) {
      lineDef.startArrowSize = lineDef.endArrowSize = 0;
      adjusted = true;
    }
    return adjusted ? lineDef : adjusted;
  }
  var lineDefAdjusters = [resetArrowMargins, shrinkStartEndMarginsBy2, shrinkStartEndMarginsBy2, shrinkStartEndMarginsBy2, resetArrowSizes];
  return {config:{selectedCls:'sch-dependency-selected', cls:'', rtl:false, lineTpl:null, canvasCls:null, pathFinderConfig:null, realLineThickness:null, useDependencyRowIntersectionCache:true}, pathFinder:null, dependencyIdAttr:'data-sch-dependency-id', constructor:function(config) {
    var me = this;
    me.initConfig(config);
    me.pathFinder = me.createPathFinder(me.getPathFinderConfig());
    if (!me.getLineTpl()) {
      me.setLineTpl(new Sch.template.Dependency({rtl:me.getRtl()}));
    }
    me.resetRowIntersectionCache();
  }, clone:function() {
    var me = this;
    return new me.self(me.getConfig());
  }, applyLineTpl:function(tpl) {
    return tpl instanceof Ext.XTemplate ? tpl : new Ext.XTemplate(tpl);
  }, updatePathFinderConfig:function(config) {
    var me = this;
    if (me.pathFinder) {
      if (config && 'type' in config && config.type !== me.pathFinder.type) {
        Ext.destroy(me.pathFinder);
        me.pathFinder = me.createPathFinder(config);
      } else {
        me.pathFinder.setConfig(config);
      }
    }
  }, createPathFinder:function(config) {
    return Sch.util.RectangularPathFinder.create(config);
  }, getCanvasSpecification:function() {
    return {tag:'div', role:'presentation', cls:this.getCanvasCls()};
  }, paint:function(primaryView, canvasEl, dependencies, overwrite) {
    var me = this, dependenciesToPaint = me.getUseDependencyRowIntersectionCache() ? me.filterByRowIntersections(primaryView, dependencies) : dependencies, markup = me.generatePaintMarkup(primaryView, dependenciesToPaint);
    canvasEl = Ext.fly(canvasEl);
    if (overwrite) {
      var tmp = document.createElement('div');
      tmp.innerHTML = markup;
      canvasEl.syncContent(tmp);
    } else {
      canvasEl.insertHtml('beforeEnd', markup);
    }
  }, generatePaintMarkup:function(primaryView, dependencies) {
    var me = this, lineDefs = me.getLineDefsForDependencies(primaryView, dependencies);
    if (!Ext.isArray(lineDefs)) {
      lineDefs = [lineDefs];
    }
    return Ext.Array.map(lineDefs, function(lineDef) {
      var tplData;
      lineDef.path = me.findPath(lineDef);
      tplData = lineDef.path && me.getLineTplData(lineDef);
      return tplData && me.getLineTpl().apply(tplData) || '';
    }).join('');
  }, isDependencyElement:function(el) {
    return Ext.fly(el).is('.sch-dependency');
  }, getElementsForDependency:function(canvasEl, dependencies) {
    var EDQ = Ext.dom.Query, me = this;
    if (dependencies && !Ext.isArray(dependencies)) {
      dependencies = [dependencies];
    }
    return new Ext.dom.CompositeElementLite(Ext.Array.reduce(dependencies || [], function(result, dependency) {
      return result.concat(EDQ.select('[' + me.dependencyIdAttr + '\x3d"' + dependency.internalId + '"]', Ext.getDom(canvasEl)));
    }, []));
  }, getDependencyElements:function(canvasEl) {
    var canvasDom = Ext.getDom(canvasEl);
    return new Ext.dom.CompositeElementLite(canvasDom && canvasDom.childNodes || []);
  }, getElementDependencyInternalId:function(el) {
    return Ext.fly(el).getAttribute(this.dependencyIdAttr);
  }, highlightDependency:function(canvasEl, dependency, cls) {
    var me = this;
    me.getElementsForDependency(canvasEl, dependency).addCls(cls || me.getSelectedCls());
  }, unhighlightDependency:function(canvasEl, dependency, cls) {
    var me = this;
    me.getElementsForDependency(canvasEl, dependency).removeCls(cls || me.getSelectedCls());
  }, getSelectedDependencyElements:function(canvasEl) {
    var me = this;
    return Ext.fly(canvasEl).select('.' + me.getSelectedCls());
  }, clearSelectedDependencies:function(canvasEl) {
    var me = this;
    me.getDependencyElements(canvasEl).removeCls(me.getSelectedCls());
  }, findPath:function(lineDef) {
    var path;
    path = this.pathFinder.findPath(lineDef, lineDefAdjusters);
    return path;
  }, getLineTplData:function(lineDef) {
    var me = this, rtl, realLineThickness, firstSegment, lastSegment, result;
    result = lineDef.path;
    if (!lineDef.startBox.rendered && !lineDef.endBox.rendered) {
      for (var i = result.length - 1; i >= 0; i--) {
        var line = result[i];
        if (line.x1 === line.x2) {
          result = [line];
          lineDef.startArrowSize = lineDef.endArrowSize = 0;
          break;
        }
      }
    }
    rtl = me.getRtl();
    realLineThickness = me.getRealLineThickness();
    firstSegment = result.length && result[0];
    lastSegment = result.length && result[result.length - 1];
    result = {cls:lineDef.cls || '', lineCls:lineDef.lineCls || '', dependencyId:lineDef.dependencyId || '', highlighted:lineDef.highlighted, segments:Ext.Array.map(result, function(segment) {
      var dir = me.getSegmentDir(segment), result;
      if (dir == 'horizontal') {
        result = {width:Math.abs(segment.x1 - segment.x2) + 1, height:realLineThickness, top:Math.min(segment.y1, segment.y2), side:Math.min(segment.x1, segment.x2), dir:dir};
      } else {
        result = {height:Math.abs(segment.y1 - segment.y2) + 1, width:realLineThickness, top:Math.min(segment.y1, segment.y2), side:Math.min(segment.x1, segment.x2), dir:dir};
      }
      return result;
    }), startArrow:lineDef.startArrowSize && {side:firstSegment.x1, top:firstSegment.y1, dir:me.convertSideToDir(lineDef.startSide, rtl)}, endArrow:lineDef.endArrowSize && {side:lastSegment.x2, top:lastSegment.y2, dir:me.convertSideToDir(lineDef.endSide, rtl)}, realLineThickness:me.getRealLineThickness()};
    return result;
  }, isDependencyInTimeSpan:function(dependency, startDate, endDate) {
    var ddr = dependency.getDateRange();
    return ddr && (!startDate || !endDate || Sch.util.Date.intersectSpans(ddr.start, ddr.end, startDate, endDate));
  }, addToRowIntersectionCacheIfNotPresent:function(primaryView, dependencies) {
    var me = this, viewStartDate = primaryView.getViewStartDate(), viewEndDate = primaryView.getViewEndDate(), all = me.dependencyStore.count() === dependencies.length;
    if (me.allInRowIntersectionCache) {
      return;
    }
    Ext.Array.each(dependencies, function(dependency) {
      if (all || !me.isInRowIntersectionCache(dependency)) {
        var source = dependency.getSourceEvent(), target = dependency.getTargetEvent();
        if (me.isDependencyInTimeSpan(dependency, viewStartDate, viewEndDate)) {
          var sourceIndex = me.getIndexForCache(primaryView, source), targetIndex = me.getIndexForCache(primaryView, target), first = Math.min(sourceIndex, targetIndex), last = Math.max(sourceIndex, targetIndex);
          if (first > -1 && last > -1) {
            first = Math.floor(first / 10);
            last = Math.floor(last / 10);
            for (var i = first; i <= last; i++) {
              if (!me.rowIntersectionCache[i]) {
                me.rowIntersectionCache[i] = [];
              }
              me.rowIntersectionCache[i].push(dependency);
              me.cachedDependencies[dependency.internalId] = true;
            }
          }
        }
      }
    });
    if (!all) {
      all = Object.keys(me.cachedDependencies).length === me.dependencyStore.count();
    }
    if (all) {
      me.allInRowIntersectionCache = true;
    }
  }, getIndexForCache:function(primaryView, event) {
    if ('getResource' in event) {
      var resource = event.getResource();
      if (resource) {
        return primaryView.getResourceStore().indexOf(resource);
      }
      if (!resource && event.resourceIdField in event.data) {
        return -1;
      }
      throw new Error('Not implemented for scheduler with multi assignment');
    } else {
      if ('getTaskStore' in event) {
        return event.getTaskStore().indexOf(event);
      }
    }
  }, resetRowIntersectionCache:function(dontClear) {
    this.allInRowIntersectionCache = false;
    if (!dontClear) {
      this.rowIntersectionCache = {};
      this.cachedDependencies = {};
    }
  }, isInRowIntersectionCache:function(dependency) {
    return !!this.cachedDependencies[dependency.internalId];
  }, filterByRowIntersections:function(primaryView, dependencies) {
    var me = this;
    if (!Ext.isArray(dependencies)) {
      dependencies = [dependencies];
    }
    if (!dependencies.length) {
      return [];
    }
    me.addToRowIntersectionCacheIfNotPresent(primaryView, dependencies);
    var dependenciesToDraw = [], rows = primaryView.getNodes(), first = primaryView.indexOf(rows[0]), last = primaryView.indexOf(rows[rows.length - 1]), fromCache;
    first = Math.floor(first / 10);
    last = Math.floor(last / 10);
    for (var i = first; i <= last; i++) {
      fromCache = me.rowIntersectionCache[i];
      fromCache && dependenciesToDraw.push.apply(dependenciesToDraw, fromCache);
    }
    return Ext.Array.intersect(dependencies, Ext.Array.unique(dependenciesToDraw));
  }, getLineDefsForDependencies:function(primaryView, dependencies) {
    var EA = Ext.Array, me = this, cache = {}, viewStartDate = primaryView.getViewStartDate(), viewEndDate = primaryView.getViewEndDate(), internalId;
    if (!Ext.isArray(dependencies)) {
      dependencies = [dependencies];
    }
    if (!dependencies.length) {
      return [];
    }
    var result = EA.reduce(dependencies || [], function(result, dependency) {
      var source = dependency.getSourceEvent(), target = dependency.getTargetEvent(), sourceBoxes, targetBoxes;
      if (me.isDependencyInTimeSpan(dependency, viewStartDate, viewEndDate)) {
        internalId = source.internalId;
        if (!cache[internalId]) {
          sourceBoxes = me.getItemBox(primaryView, source) || [];
          if (!Ext.isArray(sourceBoxes)) {
            sourceBoxes = [sourceBoxes];
          }
          cache[internalId] = sourceBoxes;
        } else {
          sourceBoxes = cache[internalId];
        }
        internalId = target.internalId;
        if (!cache[internalId]) {
          targetBoxes = me.getItemBox(primaryView, target) || [];
          if (!Ext.isArray(targetBoxes)) {
            targetBoxes = [targetBoxes];
          }
          cache[internalId] = targetBoxes;
        } else {
          targetBoxes = cache[internalId];
        }
        result = EA.reduce(sourceBoxes, function(result, sourceBox, sourceBoxIdx) {
          return EA.reduce(targetBoxes, function(result, targetBox, targetBoxIdx) {
            if (sourceBox && targetBox && (sourceBox.rendered || targetBox.rendered || sourceBox.relPos != targetBox.relPos)) {
              result.push(me.createLineDef(primaryView, dependency, source, target, sourceBox, targetBox, null));
            }
            return result;
          }, result);
        }, result);
      }
      return result;
    }, []);
    return result;
  }, getItemBox:function(primaryView, itemRecord) {
    return primaryView.getItemBox(itemRecord);
  }, createLineDef:function(primaryView, dependency, source, target, sourceBox, targetBox, otherBoxes) {
    var DEP_TYPE = dependency.self.Type, me = this, type = dependency.getType(), horizontalMargin = me.pathFinder.getHorizontalMargin(), verticalMargin = me.pathFinder.getVerticalMargin(), bidirectional = dependency.getBidirectional(), startArrowMargin = bidirectional ? me.pathFinder.getStartArrowMargin() : 0, startArrowSize = bidirectional ? me.pathFinder.getStartArrowSize() : 0, endArrowMargin = me.pathFinder.getEndArrowMargin(), endArrowSize = me.pathFinder.getEndArrowSize(), startSide = dependency.getFromSide(), 
    endSide = dependency.getToSide();
    if (!startSide) {
      switch(true) {
        case type == DEP_TYPE.StartToEnd:
          startSide = primaryView.getConnectorStartSide(source);
          break;
        case type == DEP_TYPE.StartToStart:
          startSide = primaryView.getConnectorStartSide(source);
          break;
        case type == DEP_TYPE.EndToStart:
          startSide = primaryView.getConnectorEndSide(source);
          break;
        case type == DEP_TYPE.EndToEnd:
          startSide = primaryView.getConnectorEndSide(source);
          break;
        default:
          throw new Error('Invalid dependency type: ' + dependency.getType());
      }
    }
    if (!endSide) {
      switch(true) {
        case type == DEP_TYPE.StartToEnd:
          endSide = primaryView.getConnectorEndSide(target);
          break;
        case type == DEP_TYPE.StartToStart:
          endSide = primaryView.getConnectorStartSide(target);
          break;
        case type == DEP_TYPE.EndToStart:
          endSide = primaryView.getConnectorStartSide(target);
          break;
        case type == DEP_TYPE.EndToEnd:
          endSide = primaryView.getConnectorEndSide(target);
          break;
        default:
          throw new Error('Invalid dependency type: ' + dependency.getType());
      }
    }
    switch(true) {
      case (startSide == 'left' || startSide == 'right') && (endSide == 'left' || endSide == 'right'):
        verticalMargin = 2;
        horizontalMargin = 5;
        break;
      case (startSide == 'top' || startSide == 'bottom') && (endSide == 'top' || endSide == 'bottom'):
        verticalMargin = 7;
        horizontalMargin = 2;
        break;
    }
    var distance = Number.MAX_VALUE;
    var centerHorizontalPoint = {from:(sourceBox.start + sourceBox.end) / 2, to:(targetBox.start + targetBox.end) / 2};
    var centerVerticalPoint = {from:(sourceBox.top + sourceBox.bottom) / 2, to:(targetBox.top + targetBox.bottom) / 2};
    if ((startSide === 'top' && endSide === 'bottom' || startSide === 'bottom' && endSide === 'top') && centerHorizontalPoint.from === centerHorizontalPoint.to) {
      distance = Math.abs(sourceBox[startSide] - targetBox[endSide]);
    } else {
      if ((startSide === 'left' && endSide === 'right' || startSide === 'right' && endSide === 'left') && centerVerticalPoint.from === centerVerticalPoint.to) {
        var sourceSide = startSide === 'left' ? 'start' : 'end';
        var targetSide = endSide === 'left' ? 'start' : 'end';
        if (primaryView.rtl) {
          sourceSide = sourceSide === 'start' ? 'end' : 'start';
          targetSide = targetSide === 'start' ? 'end' : 'start';
        }
        var startX = sourceBox[sourceSide];
        var endX = targetBox[targetSide];
        distance = Math.abs(startX - endX);
      }
    }
    if (distance < endArrowSize * endArrowMargin * 2) {
      startArrowMargin = endArrowMargin = 0;
      if (distance <= endArrowSize * 2) {
        startArrowSize = endArrowSize = 0;
      }
    }
    return Ext.applyIf({startBox:sourceBox, startSide:startSide, startArrowSize:startArrowSize, startArrowMargin:startArrowMargin, endBox:targetBox, endSide:endSide, endArrowSize:endArrowSize, endArrowMargin:endArrowMargin, top:Math.min(sourceBox.top, targetBox.top), bottom:Math.max(sourceBox.bottom, targetBox.bottom), verticalMargin:verticalMargin, horizontalMargin:horizontalMargin, startVerticalMargin:verticalMargin, startHorizontalMargin:horizontalMargin, endVerticalMargin:verticalMargin, endHorizontalMargin:horizontalMargin, 
    otherBoxes:otherBoxes, dependency:dependency, dependencyId:dependency.internalId, lineCls:me.getCls(), cls:dependency.getCls(), highlighted:dependency.getHighlighted()}, me.getConfig());
  }, convertSideToDir:function(side, rtl) {
    return this.self.sideToDir[side + (rtl && '-rtl' || '')];
  }, getSegmentDir:function(segment) {
    var dir = 'vertical';
    if (segment.y1 === segment.y2) {
      dir = 'horizontal';
    }
    return dir;
  }, inheritableStatics:{sideToDir:{'left':'right', 'right':'left', 'top':'down', 'bottom':'up', 'left-rtl':'left', 'right-rtl':'right', 'top-rtl':'down', 'bottom-rtl':'up'}}};
}, 1, 0, 0, 0, ['schdependencypainter.default'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Sch.view.dependency, 'Painter'], 0);
Ext.cmd.derive('Sch.view.dependency.renderingstrategy.Abstract', Ext.Base, function() {
  function depsToMap(deps) {
    return Ext.Array.reduce(deps, function(result, d) {
      result[d.getId()] = d;
      return result;
    }, {});
  }
  function uniqueDeps(deps) {
    return Ext.Object.getValues(depsToMap(deps));
  }
  function diffDeps(depsA, depsB) {
    var mapA, mapB, result = [];
    mapA = depsToMap(depsA);
    mapB = depsToMap(depsB);
    Ext.Object.each(mapA, function(k, v) {
      mapB.hasOwnProperty(k) || result.push(v);
    });
    return result;
  }
  var methodDenyFn = function() {
    Ext.Error.raise('Method is not allowed to call at this state');
  };
  var stateApi = {render:methodDenyFn, clear:methodDenyFn, scheduledRender:methodDenyFn, destroy:methodDenyFn};
  var readyState, scheduledRenderingState, destroyedState;
  readyState = Ext.applyIf({render:function(me, view, deps, all) {
    var promise, resolvePromiseFn, rejectPromiseFn, hiddenParent;
    promise = new Ext.Promise(function(resolve, reject) {
      resolvePromiseFn = resolve;
      rejectPromiseFn = reject;
    });
    if (view.canDrawDependencies()) {
      me._depsToRender = deps;
      me._depsRendered = [];
      hiddenParent = view.getPrimaryView().up('{isHidden()}');
      if (hiddenParent) {
        me._scheduledRenderDetacher = hiddenParent.on('show', function() {
          delete me._scheduledRenderDetacher;
          me._fsaState.scheduledRender(me, view);
        }, null, {single:true, destroyable:true});
      } else {
        me._scheduledRenderCancelId = Ext.asap(function() {
          delete me._scheduledRenderCancelId;
          me._fsaState.scheduledRender(me, view);
        });
      }
      me.hasListeners['rendering-start'] && me.fireEvent('rendering-start', me);
      me._renderPromise = promise;
      me._renderPromiseResolve = resolvePromiseFn;
      me._renderPromiseReject = rejectPromiseFn;
      me._fsaState = scheduledRenderingState;
    } else {
      rejectPromiseFn(deps);
    }
    return promise;
  }, clear:function(me, view, deps, all) {
    var promise;
    if (view.canDrawDependencies()) {
      if (view.isDependencyCanvasPresent()) {
        if (all) {
          view.getPainter().paint(view.getPrimaryView(), view.getDependencyCanvas(), [], true);
        } else {
          Ext.destroy(view.getPainter().getElementsForDependency(view.getDependencyCanvas(), deps));
        }
      }
      promise = Ext.Promise.resolve(deps);
    } else {
      promise = Ext.Promise.reject(deps);
    }
    return promise;
  }, destroy:function(me) {
    me.destroyed = true;
    me._fsaState = destroyedState;
  }}, stateApi);
  scheduledRenderingState = Ext.applyIf({render:function(me, view, deps, all) {
    me._depsToRender = all ? deps : uniqueDeps(me._depsToRender.concat(deps));
    return me._renderPromise;
  }, clear:function(me, view, deps, all) {
    var promise;
    if (view.canDrawDependencies()) {
      if (view.isDependencyCanvasPresent()) {
        if (all) {
          view.getPainter().paint(view.getPrimaryView(), view.getDependencyCanvas(), [], true);
        } else {
          Ext.destroy(view.getPainter().getElementsForDependency(view.getDependencyCanvas(), deps));
        }
      }
      if (all) {
        me._depsToRender = [];
      } else {
        me._depsToRender = diffDeps(me._depsToRender, deps);
      }
      promise = Ext.Promise.resolve(deps);
    } else {
      promise = Ext.Promise.reject(deps);
    }
    return promise;
  }, scheduledRender:function(me, view) {
    var hiddenParent, depsDone;
    if (view.canDrawDependencies()) {
      hiddenParent = view.getPrimaryView().up('{isHidden()}');
      if (hiddenParent) {
        me._scheduledRenderDetacher = hiddenParent.on('show', function() {
          delete me._scheduledRenderDetacher;
          me._fsaState.scheduledRender(me, view);
        }, null, {single:true, destroyable:true});
      } else {
        if (me._depsToRender.length > 0) {
          depsDone = me.delegateRendering(view, me._depsToRender, me._depsRendered);
          me._depsRendered = uniqueDeps(me._depsRendered.concat(depsDone[0]));
          me._depsToRender = depsDone[1];
          me.hasListeners['rendering-progress'] && me.fireEvent('rendering-progress', me, me._depsToRender, me._depsRendered);
          if (me._depsToRender.length > 0) {
            me._scheduledRenderCancelId = Ext.asap(function() {
              delete me._scheduledRenderCancelId;
              me._fsaState.scheduledRender(me, view);
            });
          } else {
            me.hasListeners['rendering-complete'] && me.fireEvent('rendering-complete', me, me._depsRendered);
            me._renderPromiseResolve(me._depsRendered);
            delete me._renderPromise;
            delete me._renderPromiseResolve;
            delete me._renderPromiseReject;
            delete me._depsToRender;
            delete me._depsRendered;
            me._fsaState = readyState;
          }
        } else {
          me.hasListeners['rendering-complete'] && me.fireEvent('rendering-complete', me, me._depsRendered);
          me._renderPromiseResolve(me._depsRendered);
          delete me._renderPromise;
          delete me._renderPromiseResolve;
          delete me._renderPromiseReject;
          delete me._depsToRender;
          delete me._depsRendered;
          me._fsaState = readyState;
        }
      }
    } else {
      me.hasListeners['rendering-canceled'] && me.fireEvent('rendering-canceled', me, me._depsRendered, me._depsToRender);
      me._renderPromiseReject(me._depsToRender);
      delete me._renderPromise;
      delete me._renderPromiseResolve;
      delete me._renderPromiseReject;
      delete me._depsToRender;
      delete me._depsRendered;
      me._fsaState = readyState;
    }
  }, destroy:function(me) {
    if (me._scheduledRenderCancelId) {
      Ext.asapCancel(me._scheduledRenderCancelId);
      delete me._scheduledRenderCancelId;
    }
    if (me._scheduledRenderDetacher) {
      Ext.destroy(me._scheduledRenderDetacher);
      delete me._scheduledRenderDetacher;
    }
    me.hasListeners['rendering-canceled'] && me.fireEvent('rendering-canceled', me, me._depsRendered, me._depsToRender);
    me._renderPromiseReject(me._depsToRender);
    delete me._renderPromise;
    delete me._renderPromiseResolve;
    delete me._renderPromiseReject;
    delete me._depsToRender;
    delete me._depsRendered;
    me.destroyed = true;
    me._fsaState = destroyedState;
  }}, stateApi);
  destroyedState = stateApi;
  return {_fsaState:readyState, constructor:function(config) {
    var me = this;
    me.mixins.observable.constructor.call(me, config);
  }, destroy:function() {
    var me = this;
    return me._fsaState.destroy(me);
  }, renderDependencies:function(view, deps) {
    var me = this, all = !deps;
    return me._fsaState.render(me, view, deps || view.getDependencyStore().getRange(), all);
  }, clearDependencies:function(view, deps) {
    var me = this, all = !deps;
    return me._fsaState.clear(me, view, deps || view.getDependencyStore().getRange(), all);
  }, updateDependencies:function(view, deps) {
    var me = this, all = !deps;
    deps = deps || view.getDependencyStore().getRange();
    return me._fsaState.clear(me, view, deps, all).then(function() {
      deps = all ? view.getDependencyStore().getRange() : Ext.Array.reduce(deps, function(deps, d) {
        if (d.store && Ext.Array.indexOf(d.store.removed, d) === -1) {
          deps.push(d);
        }
        return deps;
      }, []);
      return !me.destroyed ? me._fsaState.render(me, view, deps, all) : deps;
    });
  }, delegateRendering:function(view, depsToRender, depsRendered) {
  }, inheritableStatics:{depsToMap:depsToMap, uniqueDeps:uniqueDeps, diffDeps:diffDeps}};
}, 1, 0, 0, 0, ['sch_dependency_rendering_strategy.abstract'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable], [Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Sch.view.dependency.renderingstrategy, 'Abstract'], 0);
Ext.cmd.derive('Sch.view.dependency.renderingstrategy.Combined', Sch.view.dependency.renderingstrategy.Abstract, {config:{depsPerStep:50, mode:'bulk'}, delegateRendering:function(view, depsToRender, depsRendered) {
  var me = this;
  return me.getMode() == 'bulk' ? me.delegateRenderingBulk(view, depsToRender, depsRendered) : me.delegateRenderingAsync(view, depsToRender, depsRendered);
}, delegateRenderingBulk:function(view, depsToRender, depsRendered) {
  view.getPainter().paint(view.getPrimaryView(), view.getDependencyCanvas(), depsToRender, false);
  return [depsToRender, []];
}, delegateRenderingAsync:function(view, depsToRender, depsRendered) {
  var me = this, depsPerStep = me.getDepsPerStep(), renderedDeps = depsToRender.slice(0, depsPerStep), leftDeps = depsToRender.slice(depsPerStep);
  view.getPainter().paint(view.getPrimaryView(), view.getDependencyCanvas(), renderedDeps, false);
  return [renderedDeps, leftDeps];
}}, 0, 0, 0, 0, ['sch_dependency_rendering_strategy.combined'], 0, [Sch.view.dependency.renderingstrategy, 'Combined'], 0);
Ext.cmd.derive('Sch.view.dependency.View', Ext.Base, {config:{primaryView:null, dependencyStore:null, drawDependencies:true, bulkRenderingDependencyLimit:100, asyncRenderingDepsPerStep:50, painterConfig:{canvasCls:'sch-dependencyview-ct'}, canvasLayer:0, enableDependencyDragDrop:true, terminalSides:['left', 'right', 'top', 'bottom'], dragTipTpl:null, dragZoneConfig:null, selectedCls:null, overCls:null}, painter:null, renderingStrategy:null, primaryViewDetacher:null, primaryViewLockableDetacher:null, 
primaryViewElDetacher:null, dependencyStoreDetacher:null, dragZone:null, scrolling:false, constructor:function(config) {
  var me = this, view;
  me.callParent([config]);
  me.mixins.observable.constructor.call(me, config);
  me.initConfig(config);
  me.painter = me.createPainter(Ext.apply({rtl:me.getPrimaryView().rtl, dependencyStore:me.getDependencyStore()}, me.getPainterConfig()));
  if (me.painter.getUseDependencyRowIntersectionCache()) {
    if (me.getPrimaryView().resourceStore) {
      me.getPrimaryView().mon(me.getPrimaryView().resourceStore, {add:me.resetPainterCache, remove:me.resetPainterCache, clear:me.resetPainterCache, refresh:me.resetPainterCache, scope:me});
    }
    if (me.getDependencyStore()) {
      me.mon(me.getDependencyStore(), {add:me.updatePainterCache, remove:me.resetPainterCache, clear:me.resetPainterCache, refresh:me.resetPainterCache, scope:me});
    }
    me.mon(me.getPrimaryView().ownerGrid, {viewchange:me.resetPainterCache, scope:me});
  }
  if (!me.getSelectedCls()) {
    me.setSelectedCls(me.painter.getSelectedCls());
  }
  if (me.canDrawDependencies()) {
    me.startDrawDependencies();
  }
  if (me.getEnableDependencyDragDrop()) {
    view = me.getPrimaryView();
    me.dragZone = me.createDragZone(Ext.apply({view:view, ddGroup:view.getId() + '-dep-dd', rtl:view.rtl, terminalSelector:'.sch-terminal', dependencyStore:me.getDependencyStore(), tipTpl:me.getDragTipTpl()}, me.getDragZoneConfig() || {}));
    me.dragZone.on({dragstart:me.onDragStart, drop:me.onDependencyDrop, afterdrop:me.onDependencyAfterDrop, scope:me});
    me.relayEvents(me.dragZone, ['beforedrag', 'dragstart', 'drop', 'afterdrop']);
  }
}, destroy:function() {
  var me = this;
  me.stopDrawDependencies();
  me.dragZone && me.dragZone.destroy();
}, destroyDetachers:function() {
  var me = this;
  Ext.destroyMembers(this, 'primaryViewDetacher', 'primaryViewLockableDetacher', 'primaryViewElDetacher', 'dependencyStoreDetacher');
}, destroyDependencyCanvas:function() {
  var me = this;
  if (me.isDependencyCanvasPresent()) {
    Ext.destroy(me.getDependencyCanvas());
  }
}, destroyRenderingStrategy:function() {
  var me = this;
  Ext.destroy(me.renderingStrategy);
  me.renderingStrategy = null;
}, resetPainterCache:function() {
  this.painter.resetRowIntersectionCache();
}, updatePainterCache:function() {
  this.painter.resetRowIntersectionCache(true);
}, canDrawDependencies:function(ignoreDrawDependencies, ignoreDependencyCanvas, ignoreDependencyStore) {
  var me = this;
  return !!(me.painter && me.getPrimaryView() && (ignoreDrawDependencies || me.getDrawDependencies()) && (ignoreDependencyCanvas || me.isDependencyCanvasAvailable()) && (ignoreDependencyStore || me.getDependencyStore()));
}, startDrawDependencies:function() {
  var me = this, primaryView = me.getPrimaryView(), dependencyStore = me.getDependencyStore(), lockableView;
  if (!me.renderingStrategy) {
    me.renderingStrategy = me.createRenderingStrategy();
    me.primaryViewDetacher = primaryView.on(Ext.applyIf({destroyable:true}, me.getPrimaryViewListeners()));
    me.primaryViewElDetacher = primaryView.getEl().on(Ext.applyIf({destroyable:true}, me.getPrimaryViewElListeners()));
    if (primaryView.grid) {
      lockableView = primaryView.grid.ownerLockable && primaryView.grid.ownerLockable.getView();
      if (primaryView != lockableView) {
        me.primaryViewLockableDetacher = lockableView.on(Ext.applyIf({destroyable:true}, me.getPrimaryViewLockableListeners()));
      }
    }
    me.dependencyStoreDetacher = dependencyStore.on(Ext.applyIf({destroyable:true}, me.getDependencyStoreListeners()));
  }
  me.renderAllDependencies().then(null, Ext.emptyFn);
}, stopDrawDependencies:function() {
  var me = this;
  me.destroyRenderingStrategy();
  me.destroyDetachers();
  me.destroyDependencyCanvas();
}, createRenderingStrategy:function() {
  var me = this;
  return Sch.view.dependency.renderingstrategy.Combined.create({depsPerStep:me.getAsyncRenderingDepsPerStep()});
}, maybeSwitchRenderingStrategy:function() {
  var me = this;
  if (me.getDependencyStore().getCount() <= me.getBulkRenderingDependencyLimit()) {
    me.renderingStrategy.setMode('bulk');
  } else {
    me.renderingStrategy.setMode('async');
  }
}, updatePrimaryView:function(newView, oldView) {
  var me = this;
  if (oldView) {
    me.stopDrawDependencies();
  }
  if (newView) {
    if (!me.getDependencyStore() && newView.getEventStore()) {
      me.setDependencyStore(newView.getEventStore().getDependencyStore());
    }
    if (me.canDrawDependencies()) {
      me.startDrawDependencies();
    }
  }
}, applyDependencyStore:function(store) {
  return store && Ext.StoreMgr.lookup(store);
}, updateDependencyStore:function(newStore, oldStore) {
  var me = this;
  if (oldStore) {
    me.stopDrawDependencies();
  }
  if (newStore && me.canDrawDependencies()) {
    me.startDrawDependencies();
  }
}, updateDrawDependencies:function(newValue, oldValue) {
  var me = this;
  if (newValue && me.canDrawDependencies(true)) {
    me.startDrawDependencies();
  } else {
    if (!newValue) {
      me.stopDrawDependencies();
    }
  }
}, applyPainterConfig:function(config) {
  return Ext.isObject(config) ? Ext.apply({}, config) : config;
}, updatePainterConfig:function(config) {
  var me = this;
  if (me.painter) {
    if (config) {
      config = Ext.apply({}, {rtl:me.getPrimaryView().rtl}, config);
    }
    if (config && 'type' in config && config.type !== me.painter.type) {
      Ext.destroy(me.painter);
      me.painter = me.createPainter(config);
    } else {
      me.painter.setConfig(config);
    }
    me.destroyDependencyCanvas();
    if (me.canDrawDependencies()) {
      me.renderAllDependencies().then(null, Ext.emptyFn);
    }
  }
}, updateCanvasLayer:function(layer) {
  var me = this;
  me.destroyDependencyCanvas();
  if (me.canDrawDependencies()) {
    me.renderAllDependencies().then(null, Ext.emptyFn);
  }
}, updateSelectedCls:function(cls) {
  this.painter.setSelectedCls(cls);
}, getPrimaryViewListeners:function() {
  var me = this;
  return {'itemadd':me.onPrimaryViewItemAdd, 'itemremove':me.onPrimaryViewItemRemove, 'itemupdate':me.onPrimaryViewItemUpdate, 'refresh':me.onPrimaryViewRefresh, 'bufferedrefresh':me.onPrimaryViewRefresh, 'expandbody':me.onPrimaryViewExpandBody, 'collapsebody':me.onPrimaryViewCollapseBody, 'eventrepaint':me.onPrimaryViewEventRepaint, 'baseline-show':me.onPrimaryViewRefresh, 'baseline-hide':me.onPrimaryViewRefresh, scope:me};
}, getPrimaryViewLockableListeners:function() {
  var me = this;
  return {'expandbody':me.onPrimaryViewExpandBody, 'collapsebody':me.onPrimaryViewCollapseBody, scope:me};
}, getPrimaryViewElListeners:function() {
  var me = this;
  return {'dblclick':me.onPrimaryViewDependencyElPointerEvent, 'click':me.onPrimaryViewDependencyElPointerEvent, 'contextmenu':me.onPrimaryViewDependencyElPointerEvent, 'mouseover':me.onPrimaryViewDependencyElPointerEvent, 'mouseout':me.onPrimaryViewDependencyElPointerEvent, delegate:'.sch-dependency', scope:me};
}, getDependencyStoreListeners:function() {
  var me = this;
  return {'add':me.onDependencyStoreAdd, 'remove':me.onDependencyStoreRemove, 'update':me.onDependencyStoreUpdate, 'refresh':me.onDependencyStoreRefresh, 'clear':me.onDependencyStoreClear, scope:me};
}, createPainter:function(config) {
  return Sch.view.dependency.Painter.create(config);
}, getPainter:function() {
  return this.painter;
}, clonePainter:function() {
  var me = this;
  return me.painter && me.painter.clone() || null;
}, createDragZone:function(config) {
  return Sch.view.dependency.DragZone.create(config);
}, isDependencyCanvasAvailable:function() {
  var primaryView = this.getPrimaryView();
  return primaryView && primaryView.isItemCanvasAvailable();
}, isDependencyCanvasPresent:function() {
  var me = this, primaryView = me.getPrimaryView();
  return primaryView && primaryView.isItemCanvasPresent(me.getCanvasLayer());
}, getDependencyCanvas:function() {
  var me = this;
  return me.getPrimaryView().getItemCanvasEl(me.getCanvasLayer(), me.painter.getCanvasSpecification());
}, renderAllDependencies:function() {
  var me = this, promise;
  if (me.canDrawDependencies() && (me.refreshing || me.fireEvent('beforerefresh', me) !== false)) {
    me.refreshing || me.renderingStrategy.on('rendering-complete', function(strategy, rendered) {
      me.refreshing = false;
      me.fireEvent('refresh', me);
    }, null, {single:true});
    me.refreshing = true;
    promise = me.renderingStrategy.updateDependencies(me);
  } else {
    promise = Ext.Promise.reject(me.getDependencyStore().getRange());
  }
  return promise;
}, renderDependencies:function(dependencyRecords, overwrite) {
  var me = this, promise;
  if (!Ext.isArray(dependencyRecords)) {
    dependencyRecords = [dependencyRecords];
  }
  if (me.canDrawDependencies()) {
    if (overwrite) {
      promise = me.renderingStrategy.clearDependencies(me).then(function() {
        return !me.renderingStrategy.destroyed ? me.renderingStrategy.renderDependencies(me, dependencyRecords) : dependencyRecords;
      });
    } else {
      promise = me.renderingStrategy.renderDependencies(me, dependencyRecords);
    }
  } else {
    promise = Ext.Promise.reject(dependencyRecords);
  }
  return promise;
}, updateDependencies:function(dependencyRecords) {
  var me = this, promise;
  if (!Ext.isArray(dependencyRecords)) {
    dependencyRecords = [dependencyRecords];
  }
  if (me.canDrawDependencies()) {
    promise = me.renderingStrategy.updateDependencies(me, dependencyRecords);
  } else {
    promise = Ext.Promise.reject(dependencyRecords);
  }
  return promise;
}, clearDependencies:function(dependencyRecords) {
  var me = this, promise;
  if (!Ext.isArray(dependencyRecords)) {
    dependencyRecords = [dependencyRecords];
  }
  if (me.canDrawDependencies()) {
    promise = me.renderingStrategy.clearDependencies(me, dependencyRecords);
  } else {
    promise = Ext.Promise.reject(dependencyRecords);
  }
  return promise;
}, clearAllDependencies:function() {
  var me = this, promise;
  if (me.canDrawDependencies()) {
    promise = me.renderingStrategy.clearDependencies(me);
  } else {
    promise = Ext.Promise.reject();
  }
  return promise;
}, getElementsForDependency:function(dependencyRecords) {
  var me = this, result = false;
  if (me.canDrawDependencies() && me.isDependencyCanvasPresent()) {
    result = me.painter.getElementsForDependency(me.getDependencyCanvas(), dependencyRecords);
  }
  return result;
}, getDependencyForElement:function(el) {
  var me = this, depStore = me.getDependencyStore(), dependency = null, depInternalId;
  if (depStore) {
    depInternalId = me.painter.getElementDependencyInternalId(el);
    dependency = depStore.getByInternalId(depInternalId);
  }
  return dependency;
}, getDependencyElements:function() {
  var me = this, result = false;
  if (me.canDrawDependencies() && me.isDependencyCanvasPresent()) {
    result = me.painter.getDependencyElements(me.getDependencyCanvas());
  }
  return result;
}, highlightDependency:function(record, cls) {
  var me = this;
  if (!(record && record.isModel)) {
    record = me.getDependencyStore().getById(record);
  }
  record && record.highlight(cls || me.getSelectedCls());
}, unhighlightDependency:function(record, cls) {
  var me = this;
  if (!(record && record.isModel)) {
    record = me.getDependencyStore().getById(record);
  }
  record && record.unhighlight(cls || me.getSelectedCls());
}, getHighlightedDependencies:function(cls) {
  var store = this.getDependencyStore();
  return store && store.getHighlightedDependencies() || [];
}, getSelectedDependencyElements:function() {
  var me = this, result = false;
  if (me.canDrawDependencies() && me.isDependencyCanvasPresent()) {
    result = me.painter.getSelectedDependencyElements(me.getDependencyCanvas());
  }
  return result;
}, clearSelectedDependencies:function() {
  var me = this;
  if (me.canDrawDependencies() && me.isDependencyCanvasPresent()) {
    me.painter.clearSelectedDependencies(me.getDependencyCanvas());
    me.getDependencyStore().each(function(dependency) {
      me.unhighlightDependency(dependency);
    });
  }
}, onPrimaryViewItemAdd:function(records, index, node, view) {
  this.renderAllDependencies().then(null, Ext.emptyFn);
}, onPrimaryViewItemUpdate:function(eventRecord, index, node, view) {
  this.renderAllDependencies().then(null, Ext.emptyFn);
}, onPrimaryViewItemRemove:function(records, index, node, view) {
  this.renderAllDependencies().then(null, Ext.emptyFn);
}, onPrimaryViewRefresh:function(view) {
  this.renderAllDependencies().then(null, Ext.emptyFn);
}, onPrimaryViewExpandBody:function() {
  this.renderAllDependencies().then(null, Ext.emptyFn);
}, onPrimaryViewCollapseBody:function() {
  this.renderAllDependencies().then(null, Ext.emptyFn);
}, onPrimaryViewEventRepaint:function() {
  this.renderAllDependencies().then(null, Ext.emptyFn);
}, onPrimaryViewDependencyElPointerEvent:function(event, elDom, options) {
  var me = this, dependencyId, dependency;
  dependencyId = me.painter.getElementDependencyInternalId(elDom);
  dependency = me.getDependencyStore().getByInternalId(dependencyId);
  if (dependency) {
    var overCls = this.getOverCls();
    me.fireEvent('dependency' + event.type, me, dependency, event, elDom);
    if (overCls) {
      if (event.type === 'mouseover' || event.type === 'mouseout') {
        var els = me.painter.getElementsForDependency(me.getDependencyCanvas(), dependency);
        if (event.type === 'mouseover') {
          els.addCls(overCls);
        } else {
          if (event.type === 'mouseout') {
            els.removeCls(overCls);
          }
        }
      }
    }
  }
}, onDependencyStoreAdd:function(store, dependencies) {
  var me = this;
  me.maybeSwitchRenderingStrategy();
  me.renderDependencies(dependencies).then(null, Ext.emptyFn);
}, onDependencyStoreRemove:function(store, dependencies) {
  var me = this;
  me.maybeSwitchRenderingStrategy();
  me.clearDependencies(dependencies).then(null, Ext.emptyFn);
}, onDependencyStoreUpdate:function(store, dependency) {
  this.updateDependencies(dependency).then(null, Ext.emptyFn);
}, onDependencyStoreRefresh:function(store) {
  var me = this;
  me.maybeSwitchRenderingStrategy();
  me.renderAllDependencies().then(null, Ext.emptyFn);
}, onDependencyStoreClear:function(store) {
  var me = this;
  me.maybeSwitchRenderingStrategy();
  me.renderAllDependencies().then(null, Ext.emptyFn);
}, onDragStart:function() {
  var me = this, primaryView = me.getPrimaryView();
  primaryView.onDragDropStart && primaryView.onDragDropStart();
  me.getPrimaryView().getEl().addCls('sch-terminals-visible');
}, onDependencyDrop:function(dropZone, newDependency, valid) {
  valid && this.getDependencyStore().add(newDependency);
}, onDependencyAfterDrop:function() {
  var primaryView = this.getPrimaryView();
  if (!primaryView.destroyed) {
    primaryView.onDragDropEnd && primaryView.onDragDropEnd();
    primaryView.getEl().removeCls('sch-terminals-visible');
    primaryView.getEl().select('.sch-terminal-hidden').removeCls('sch-terminal-hidden');
  }
}}, 1, 0, 0, 0, ['schdependencyview.base'], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable], [Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Sch.view.dependency, 'View'], 0);
Ext.cmd.derive('Sch.view.dependency.Mixin', Ext.Mixin, {mixinConfig:{after:{initComponent:'initComponent', destroy:'destroy'}}, dependencyViewConfig:null, dependencyView:null, dependencyViewRelayDetacher:null, dependencyDragRelayDetacher:null, initComponent:function() {
  var me = this;
  me.on('viewready', function() {
    if (me.getEventStore()) {
      me.setupDependencyView(me.getDependencyViewConfig(), me.getSchedulingView());
    }
  });
}, getDependencyViewConfig:function() {
  return this.dependencyViewConfig;
}, setDependencyViewConfig:function(config) {
  var me = this;
  if (me.dependencyViewConfig !== config) {
    me.dependencyViewConfig = config;
    if (me.dependencyView) {
      if (config && 'type' in config && config.type !== me.dependencyView.type) {
        me.setupDependencyView(config, me.getSchedulingView());
      } else {
        me.dependencyView.setConfig(config);
      }
    }
  }
}, hasDependencyView:function() {
  return !!this.dependencyView;
}, getDependencyView:function() {
  return this.dependencyView;
}, createDependencyView:function(config, primaryView) {
  return Sch.view.dependency.View.create(Ext.applyIf({primaryView:primaryView}, config));
}, destroy:function() {
  Ext.destroyMembers(this, 'dependencyViewRelayDetacher', 'dependencyDragRelayDetacher', 'dependencyView');
}, setupDependencyView:function(config, primaryView) {
  var me = this;
  Ext.destroy(me.dependencyView);
  me.dependencyView = me.createDependencyView(config, primaryView);
  me.setupDependencyViewRelay();
  me.fireEvent('dependencyviewready', me, me.dependencyView);
  if (me.dependencyView.canDrawDependencies()) {
    me.dependencyView.renderAllDependencies().then(null, Ext.emptyFn);
  }
}, setupDependencyViewRelay:function() {
  var me = this;
  Ext.destroy(me.dependencyViewRelayDetacher, me.dependencyDragRelayDetacher);
  me.dependencyViewRelayDetacher = me.relayEvents(me.getDependencyView(), ['dependencyclick', 'dependencydblclick', 'dependencycontextmenu', 'dependencymouseover', 'dependencymouseout']);
  me.dependencyDragRelayDetacher = me.relayEvents(me.getDependencyView(), ['beforedrag', 'dragstart', 'drop', 'afterdrop'], 'dependency');
}}, 0, 0, 0, 0, 0, 0, [Sch.view.dependency, 'Mixin'], 0);
Ext.cmd.derive('Sch.panel.SchedulerGrid', Sch.panel.TimelineGridPanel, {alternateClassName:'Sch.SchedulerPanel', viewType:'schedulergridview', isSchedulerGrid:true, initComponent:function() {
  Sch.panel.TimelineGridPanel.prototype.initComponent.apply(this, arguments);
  this.getSchedulingView()._initializeSchedulerView();
}}, 0, ['schedulergrid', 'schedulerpanel'], ['component', 'box', 'container', 'panel', 'tablepanel', 'gridpanel', 'grid', 'timelinegrid', 'schedulergrid', 'schedulerpanel'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'gridpanel':true, 'grid':true, 'timelinegrid':true, 'schedulergrid':true, 'schedulerpanel':true}, ['widget.schedulergrid', 'widget.schedulerpanel'], [[Sch.mixin.SchedulerPanel.prototype.mixinId || Sch.mixin.SchedulerPanel.$className, Sch.mixin.SchedulerPanel], 
[Sch.view.dependency.Mixin.prototype.mixinId || Sch.view.dependency.Mixin.$className, Sch.view.dependency.Mixin]], [Sch.panel, 'SchedulerGrid', Sch, 'SchedulerPanel'], function() {
  this.override(Sch.mixin.SchedulerPanel.prototype.inheritables() || {});
});
Ext.cmd.derive('Sch.patches.TreeNavigationModel', Sch.util.Patch, {target:'Ext.tree.NavigationModel', minVersion:'6.0.0', maxVersion:'6.0.2', overrides:{onAsterisk:function() {
  if (!this.view.ownerCt.expandAll) {
    this.view.lockingPartner.ownerCt.expandAll();
    return;
  }
  this.callParent(arguments);
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TreeNavigationModel'], 0);
Ext.cmd.derive('Sch.panel.TimelineTreePanel', Ext.tree.Panel, {useArrows:true, rootVisible:false, lockedXType:'treepanel', isTimelineTreePanel:true, initComponent:function() {
  Ext.tree.Panel.prototype.initComponent.apply(this, arguments);
  this.getSchedulingView()._initializeTimelineView();
}}, 0, ['timelinetree'], ['component', 'box', 'container', 'panel', 'tablepanel', 'treepanel', 'timelinetree'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'treepanel':true, 'timelinetree':true}, ['widget.timelinetree'], [[Sch.mixin.Localizable.prototype.mixinId || Sch.mixin.Localizable.$className, Sch.mixin.Localizable], [Sch.mixin.TimelinePanel.prototype.mixinId || Sch.mixin.TimelinePanel.$className, Sch.mixin.TimelinePanel]], [Sch.panel, 'TimelineTreePanel'], 
function() {
  this.override(Sch.mixin.TimelinePanel.prototype.inheritables() || {});
});
Ext.cmd.derive('Sch.patches.BufferedRenderer', Sch.util.Patch, {target:'Ext.grid.plugin.BufferedRenderer', overrides:{refreshView:function() {
  var view = this.view, otherView = view.lockingPartner;
  if (!arguments.length && otherView && otherView.refreshCounter > view.refreshCounter) {
    this.callParent([otherView.all.startIndex]);
  } else {
    this.callParent(arguments);
  }
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'BufferedRenderer'], 0);
Ext.cmd.derive('Sch.patches.BufferedRenderer_6_2_1', Sch.util.Patch, {target:'Ext.grid.plugin.BufferedRenderer', minVersion:'6.2.1', applyFn:function() {
  if (Ext.isIE11) {
    Ext.define(null, {override:'Ext.grid.plugin.BufferedRenderer', getFirstVisibleRowIndex:function(startRow, endRow, viewportTop, viewportBottom) {
      var me = this, view = me.view, rows = view.all, elements = rows.elements, clientHeight = me.viewClientHeight, target, targetTop, bodyTop = me.bodyTop;
      if (rows.getCount() && me.variableRowHeight) {
        if (!arguments.length) {
          startRow = rows.startIndex;
          endRow = rows.endIndex;
          viewportTop = me.scrollTop;
          viewportBottom = viewportTop + clientHeight;
          if (bodyTop > viewportBottom || bodyTop + me.bodyHeight < viewportTop) {
            me.teleported = true;
            return Math.floor(me.scrollTop / me.rowHeight);
          }
          target = startRow + Math.min(me.numFromEdge + (me.lastScrollDirection === -1 ? me.leadingBufferZone : me.trailingBufferZone), Math.floor((endRow - startRow) / 2));
        } else {
          if (startRow === endRow) {
            return endRow;
          }
          target = startRow + Math.floor((endRow - startRow) / 2);
        }
        var targetElement = elements[target];
        targetTop = bodyTop + targetElement.offsetTop;
        if (targetTop + targetElement.offsetHeight <= viewportTop && targetElement.offsetHeight) {
          return me.getFirstVisibleRowIndex(target + 1, endRow, viewportTop, viewportBottom);
        }
        if (targetTop <= viewportTop) {
          return target;
        } else {
          if (target !== startRow) {
            return me.getFirstVisibleRowIndex(startRow, target - 1, viewportTop, viewportBottom);
          }
        }
      }
      return Math.floor(me.scrollTop / me.rowHeight);
    }});
  }
}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'BufferedRenderer_6_2_1'], 0);
Ext.cmd.derive('Sch.patches.CellContext', Sch.util.Patch, {target:'Ext.grid.CellContext', minVersion:'6.0.0', maxVersion:'6.2.0', applyFn:function() {
  var overrides = {setAll:function(view, recordIndex, columnIndex, record, columnHeader) {
    var me = this;
    if (columnHeader && columnIndex == -1 && view !== me.view) {
      view = me.view;
      columnIndex = view.getVisibleColumnManager().indexOf(columnHeader);
    }
    return this.callParent(arguments);
  }};
  if (Ext.getVersion().isGreaterThanOrEqual('6.0.1')) {
    overrides.setPosition = function(row, col) {
      row = row || 0;
      col = col || 0;
      return this.callParent(arguments);
    };
  }
  Ext.override(Ext.grid.CellContext, overrides);
}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'CellContext'], 0);
Ext.cmd.derive('Sch.patches.CellContext_6_2_0', Sch.util.Patch, {minVersion:'6.2.0', maxVersion:'6.2.1', target:'Ext.grid.CellContext', overrides:{setView:function(view) {
  this.view = view;
  this.refresh();
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'CellContext_6_2_0'], 0);
Ext.cmd.derive('Sch.patches.DomScroller', Sch.util.Patch, {target:'Ext.scroll.DomScroller', maxVersion:'6.2.0', overrides:{privates:{convertX:function(x) {
  if (x == null) {
    return null;
  }
  return this.callParent(arguments);
}}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'DomScroller'], 0);
Ext.cmd.derive('Sch.patches.DragZone', Sch.util.Patch, {target:'Ext.dd.DragZone', minVersion:'6.2.0', overrides:{unreg:function() {
  try {
    this.callParent(arguments);
  } catch (e$42) {
  }
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'DragZone'], 0);
Ext.cmd.derive('Sch.patches.Explorer', Sch.util.Patch, {target:['Ext.util.CSS'], minVersion:'6.0.0', maxVersion:'6.0.1', applyFn:function() {
  if (Ext.isIE9m) {
    Ext.util.CSS.createStyleSheet('.x-column-header-trigger { z-index: 10; }');
  }
}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'Explorer'], 0);
Ext.cmd.derive('Sch.patches.LockableGridEmptyText', Sch.util.Patch, {target:'Ext.grid.locking.Lockable', minVersion:'6.2.0', maxVersion:'6.4.9', reportUrl:'https://www.sencha.com/forum/showthread.php?338759-Lockable-grid-empty-text-is-not-visible-due-to-lockable-sync-skipping\x26p\x3d1177730', obsoleteTestName:'patches/006_lockable_grid_empty_text.t.js', description:["Lockable grid skips locked/normal grid layout synchronization in case there're no rows rendered", "This breaks empty text display, the element is attached to corresponding grid view but it's occluded", 
"and thus isn't visible, due to layout synchronization syncking skip."].join(' '), overrides:{syncLockableLayout:function() {
  var me = this;
  me.callParent();
  if (!me.store.getCount() && me.lockedGrid && me.normalGrid && (me.lockedGrid.getEmptyText() || me.normalGrid.getEmptyText()) && !me.afterLayoutListener) {
    me.afterLayoutListener = Ext.on({afterlayout:me.doSyncLockableLayout, scope:me, single:true});
  }
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'LockableGridEmptyText'], 0);
Ext.cmd.derive('Sch.patches.RowSynchronizer', Sch.util.Patch, {target:'Ext.grid.locking.RowSynchronizer', minVersion:'6.0.0', maxVersion:'6.0.1', overrides:{finish:function(other) {
  if (!other) {
    return;
  }
  return this.callParent(arguments);
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'RowSynchronizer'], 0);
Ext.cmd.derive('Sch.patches.TablePanel', Sch.util.Patch, {target:'Ext.panel.Table', applyFn:function() {
  var overrides = {};
  if (Ext.getVersion().equals('6.0.1.250')) {
    overrides.ensureVisible = function(record, options) {
      if (options && options.column && this.getVisibleColumnManager().indexOf(options.column) === -1) {
        return;
      }
      this.callParent(arguments);
    };
  }
  Ext.ClassManager.get(this.target).override(overrides);
}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TablePanel'], 0);
Ext.cmd.derive('Sch.patches.TablePanel_6_2_1', Sch.util.Patch, {target:'Ext.panel.Table', minVersion:'6.2.1', overrides:{privates:{initFocusableElement:function() {
}, doEnsureVisible:function(record, options) {
  if (this.lockable) {
    return this.ensureLockedVisible(record, options);
  }
  if (typeof record !== 'number' && !record.isEntity) {
    record = this.store.getById(record);
  }
  var me = this, view = me.getView(), domNode = view.getNode(record), isLocking = me.ownerGrid.lockable, callback, scope, animate, highlight, select, doFocus, verticalScroller, horizontalScroller, column, cell;
  if (options) {
    callback = options.callback;
    scope = options.scope;
    animate = options.animate;
    highlight = options.highlight;
    select = options.select;
    doFocus = options.focus;
    column = options.column;
  }
  if (me.deferredEnsureVisible) {
    me.deferredEnsureVisible.destroy();
  }
  if (!view.componentLayoutCounter) {
    me.deferredEnsureVisible = view.on({resize:me.doEnsureVisible, args:Ext.Array.slice(arguments), scope:me, single:true, destroyable:true});
    return;
  }
  if (typeof column === 'number') {
    column = me.ownerGrid.getVisibleColumnManager().getColumns()[column];
  }
  if (domNode) {
    verticalScroller = isLocking ? me.ownerGrid.getScrollable() : view.getScrollable();
    if (verticalScroller) {
      if (column) {
        cell = Ext.fly(domNode).selectNode(column.getCellSelector());
      }
      if (isLocking && column) {
        verticalScroller.scrollIntoView(domNode, false);
        view.getScrollable().scrollIntoView(cell || domNode, true, animate, highlight);
      } else {
        verticalScroller.scrollIntoView(cell || domNode, !!column, animate, highlight);
      }
    }
    if (!record.isEntity) {
      record = view.getRecord(domNode);
    }
    if (select) {
      view.getSelectionModel().select(record);
    }
    if (doFocus) {
      view.getNavigationModel().setPosition(record, 0);
    }
    Ext.callback(callback, scope || me, [true, record, domNode]);
  } else {
    if (view.bufferedRenderer) {
      view.bufferedRenderer.scrollTo(record, {animate:animate, highlight:highlight, select:select, focus:doFocus, column:column, callback:function(recordIdx, record, domNode) {
        Ext.callback(callback, scope || me, [true, record, domNode]);
      }});
    } else {
      Ext.callback(callback, scope || me, [false, null]);
    }
  }
}}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TablePanel_6_2_1'], 0);
Ext.cmd.derive('Sch.patches.TableView', Sch.util.Patch, {target:'Ext.view.Table', minVersion:'6.0.1', maxVersion:'6.0.1.9999', overrides:{suspendCellEditing:function(actionable) {
  var me = actionable, editor = me.activeEditor;
  if (editor && editor.editing) {
    me.suspendedEditor = editor;
    me.suspendEvents();
    editor.suspendEvents();
    editor.cancelEdit(true);
    editor.resumeEvents();
    me.resumeEvents();
  }
}, resumeCellEditing:function(actionable, position) {
  var me = actionable, editor = me.activeEditor = me.suspendedEditor, result;
  if (editor) {
    me.suspendEvents();
    editor.suspendEvents();
    result = me.activateCell(position, true, true);
    editor.field && editor.field.focus(false, true);
    editor.resumeEvents();
    me.resumeEvents();
  }
  return result;
}, suspendActionableMode:function() {
  var me = this, actionables = me.grid.actionables, len = actionables.length, i;
  for (i = 0; i < len; i++) {
    var actionable = actionables[i];
    if (Ext.grid.plugin.CellEditing && actionable instanceof Ext.grid.plugin.CellEditing) {
      me.suspendCellEditing(actionable);
    }
  }
}, resumeActionableMode:function(position) {
  var me = this, actionables = me.grid.actionables, len = actionables.length, i, activated;
  me.toggleChildrenTabbability(false);
  for (i = 0; i < len; i++) {
    var actionable = actionables[i];
    if (!activated && Ext.grid.plugin.CellEditing && actionable instanceof Ext.grid.plugin.CellEditing) {
      activated = me.resumeCellEditing(actionable, position);
    }
  }
  if (!activated) {
    me.activateCell(position);
  }
}, saveFocusState:function() {
  var me = this, store = me.dataSource, actionableMode = me.actionableMode, navModel = me.getNavigationModel(), focusPosition = actionableMode ? me.actionPosition : navModel.getPosition(true), activeElement = Ext.Element.getActiveElement(true), focusCell = focusPosition && focusPosition.view === me && focusPosition.getCell(), refocusRow, refocusCol;
  if (focusCell && focusCell.contains(activeElement)) {
    focusPosition = focusPosition.clone();
    activeElement.suspendFocusEvents();
    if (actionableMode) {
      me.suspendActionableMode();
    } else {
      navModel.setPosition();
    }
    activeElement.resumeFocusEvents();
    return function() {
      if (store.getCount()) {
        refocusRow = Math.min(focusPosition.rowIdx, me.all.getCount() - 1);
        refocusCol = Math.min(focusPosition.colIdx, me.getVisibleColumnManager().getColumns().length - 1);
        focusPosition = (new Ext.grid.CellContext(me)).setPosition(store.contains(focusPosition.record) ? focusPosition.record : refocusRow, refocusCol);
        if (actionableMode) {
          me.resumeActionableMode(focusPosition);
        } else {
          navModel.setPosition(focusPosition, null, null, null, true);
        }
      } else {
        focusPosition.column.focus();
      }
    };
  }
  return Ext.emptyFn;
}, activateCell:function() {
  return true;
}, onFocusEnter:function(e) {
  if (!Ext.fly(e.target).hasCls('sch-event')) {
    this.callParent(arguments);
  }
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TableView'], 0);
Ext.cmd.derive('Sch.patches.TableView2', Sch.util.Patch, {target:'Ext.view.Table', minVersion:'6.0.2', maxVersion:'6.2.0', overrides:{privates:{setActionableMode:function(enabled, position) {
  var me = this, navModel = me.getNavigationModel(), activeEl, actionables = me.grid.actionables, len = actionables.length, i, record, column, isActionable = false, lockingPartner;
  if (me.actionableMode === enabled) {
    if (!enabled || position.isEqual(me.actionPosition)) {
      return false;
    }
  }
  if (enabled) {
    if (position && (position.view === me || position.view === (lockingPartner = me.lockingPartner) && lockingPartner.actionableMode)) {
      isActionable = me.activateCell(position);
    }
    return isActionable;
  } else {
    activeEl = Ext.fly(Ext.Element.getActiveElement());
    if (me.el.contains(activeEl)) {
      record = me.actionPosition && me.actionPosition.record || me.getRecord(activeEl);
      column = me.getHeaderByCell(activeEl.findParent(me.getCellSelector()));
      if (!position) {
        position = (new Ext.grid.CellContext(me)).setPosition(record || 0, column || 0);
      }
      me._leavingActionableMode = true;
      position.getCell().focus();
      me._leavingActionableMode = false;
      activeEl = Ext.fly(Ext.Element.getActiveElement());
      if (!(me.el.contains(activeEl) && activeEl.is(me.getCellSelector()))) {
        position = null;
      }
    }
    for (i = 0; i < len; i++) {
      if (actionables[i].deactivate) {
        actionables[i].deactivate();
      }
    }
    if (me.actionRow) {
      me.actionRow.saveTabbableState({skipSelf:true, includeSaved:false});
    }
    if (me.destroyed) {
      return false;
    }
    me.actionableMode = me.ownerGrid.actionableMode = false;
    me.actionPosition = navModel.actionPosition = me.actionRow = null;
    if (position) {
      navModel.setPosition(position);
    }
  }
}}, saveFocusState:function() {
  var me = this, store = me.dataSource, actionableMode = me.actionableMode, navModel = me.getNavigationModel(), focusPosition = actionableMode ? me.actionPosition : navModel.getPosition(true), activeElement = Ext.Element.getActiveElement(true), focusCell = focusPosition && focusPosition.view === me && focusPosition.getCell(), refocusRow, refocusCol;
  if (focusCell && focusCell.contains(activeElement)) {
    focusPosition = focusPosition.clone();
    activeElement.suspendFocusEvents();
    if (actionableMode) {
      me.suspendActionableMode();
    } else {
      navModel.setPosition();
    }
    activeElement.resumeFocusEvents();
    return function() {
      if (store.getCount()) {
        refocusRow = Math.min(focusPosition.rowIdx, me.all.getCount() - 1);
        refocusCol = Math.min(focusPosition.colIdx, me.getVisibleColumnManager().getColumns().length - 1);
        focusPosition = (new Ext.grid.CellContext(me)).setPosition(store.contains(focusPosition.record) ? focusPosition.record : refocusRow, refocusCol);
        if (actionableMode && !me._leavingActionableMode) {
          me.resumeActionableMode(focusPosition);
        } else {
          navModel.setPosition(focusPosition, null, null, null, true);
        }
      } else {
        focusPosition.column.focus();
      }
    };
  }
  return Ext.emptyFn;
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TableView2'], 0);
Ext.cmd.derive('Sch.patches.TableView_6_0_2', Sch.util.Patch, {target:'Ext.view.Table', minVersion:'6.0.2', maxVersion:'6.0.3', overrides:{handleUpdate:function(store, record, operation, changedFieldNames, info, allColumns) {
  operation = operation || Ext.data.Model.EDIT;
  var me = this, recordIndex = me.store.indexOf(record), rowTpl = me.rowTpl, markDirty = me.markDirty, dirtyCls = me.dirtyCls, clearDirty = operation !== Ext.data.Model.EDIT, columnsToUpdate = [], hasVariableRowHeight = me.variableRowHeight, updateTypeFlags = 0, ownerCt = me.ownerCt, cellFly = me.cellFly || (me.self.prototype.cellFly = new Ext.dom.Fly), oldItemDom, oldDataRow, newItemDom, newAttrs, attLen, attName, attrIndex, overItemCls, columns, column, len, i, cellUpdateFlag, cell, fieldName, 
  value, defaultRenderer, scope, elData, emptyValue;
  if (me.viewReady) {
    oldItemDom = me.getNodeByRecord(record);
    if (oldItemDom) {
      if (record.isCollapsedPlaceholder) {
        Ext.fly(oldItemDom).syncContent(me.createRowElement(record, me.indexOfRow(record)));
        return;
      }
      overItemCls = me.overItemCls;
      columns = me.ownerCt.getVisibleColumnManager().getColumns();
      if (allColumns) {
        columnsToUpdate = columns;
        updateTypeFlags = 1;
      } else {
        for (i = 0, len = columns.length; i < len; i++) {
          column = columns[i];
          if (column.preventUpdate) {
            cell = Ext.fly(oldItemDom).down(column.getCellSelector(), true);
            if (cell && !clearDirty && markDirty) {
              cellFly.attach(cell);
              if (record.isModified(column.dataIndex)) {
                cellFly.addCls(dirtyCls);
              } else {
                cellFly.removeCls(dirtyCls);
              }
            }
          } else {
            cellUpdateFlag = me.shouldUpdateCell(record, column, changedFieldNames);
            if (cellUpdateFlag) {
              updateTypeFlags = updateTypeFlags | cellUpdateFlag;
              columnsToUpdate[columnsToUpdate.length] = column;
              hasVariableRowHeight = hasVariableRowHeight || column.variableRowHeight;
            }
          }
        }
      }
      me.fireEvent('beforeitemupdate', record, recordIndex, oldItemDom, columnsToUpdate);
      if (me.getRowClass || !me.getRowFromItem(oldItemDom) || updateTypeFlags & 1 || oldItemDom.tBodies[0].childNodes.length > 1) {
        elData = oldItemDom._extData;
        newItemDom = me.createRowElement(record, me.indexOfRow(record), columnsToUpdate);
        if (Ext.fly(oldItemDom, '_internal').hasCls(overItemCls)) {
          Ext.fly(newItemDom).addCls(overItemCls);
        }
        if (Ext.isIE9m && oldItemDom.mergeAttributes) {
          oldItemDom.mergeAttributes(newItemDom, true);
        } else {
          newAttrs = newItemDom.attributes;
          attLen = newAttrs.length;
          for (attrIndex = 0; attrIndex < attLen; attrIndex++) {
            attName = newAttrs[attrIndex].name;
            if (attName !== 'id') {
              oldItemDom.setAttribute(attName, newAttrs[attrIndex].value);
            }
          }
        }
        if (elData) {
          elData.isSynchronized = false;
        }
        if (columns.length && (oldDataRow = me.getRow(oldItemDom))) {
          me.updateColumns(oldDataRow, Ext.fly(newItemDom).down(me.rowSelector, true), columnsToUpdate);
        }
        while (rowTpl) {
          if (rowTpl.syncContent) {
            if (rowTpl.syncContent(oldItemDom, newItemDom, changedFieldNames ? columnsToUpdate : null) === false) {
              break;
            }
          }
          rowTpl = rowTpl.nextTpl;
        }
      } else {
        for (i = 0, len = columnsToUpdate.length; i < len; i++) {
          column = columnsToUpdate[i];
          fieldName = column.dataIndex;
          value = record.get(fieldName);
          cell = Ext.fly(oldItemDom).down(column.getCellSelector(), true);
          cellFly.attach(cell);
          if (!clearDirty && markDirty) {
            if (record.isModified(column.dataIndex)) {
              cellFly.addCls(dirtyCls);
            } else {
              cellFly.removeCls(dirtyCls);
            }
          }
          defaultRenderer = column.usingDefaultRenderer;
          scope = defaultRenderer ? column : column.scope;
          if (column.updater) {
            Ext.callback(column.updater, scope, [cell, value, record, me, me.dataSource], 0, column, ownerCt);
          } else {
            if (column.renderer) {
              value = Ext.callback(column.renderer, scope, [value, null, record, 0, 0, me.dataSource, me], 0, column, ownerCt);
            }
            emptyValue = value == null || value === '';
            value = emptyValue ? column.emptyCellText : value;
            if (column.producesHTML || emptyValue) {
              cellFly.down(me.innerSelector, true).innerHTML = value;
            } else {
              cellFly.down(me.innerSelector, true).childNodes[0].data = value;
            }
          }
          if (me.highlightClass) {
            Ext.fly(cell).addCls(me.highlightClass);
            if (!me.changedCells) {
              me.self.prototype.changedCells = [];
              me.prototype.clearChangedTask = new Ext.util.DelayedTask(me.clearChangedCells, me.prototype);
              me.clearChangedTask.delay(me.unhighlightDelay);
            }
            me.changedCells.push({cell:cell, cls:me.highlightClass, expires:Ext.Date.now() + 1000});
          }
        }
      }
      if (clearDirty && markDirty && !record.dirty) {
        Ext.fly(oldItemDom, '_internal').select('.' + dirtyCls).removeCls(dirtyCls);
      }
      if (hasVariableRowHeight) {
        Ext.suspendLayouts();
      }
      me.fireEvent('itemupdate', record, recordIndex, oldItemDom);
      if (hasVariableRowHeight) {
        me.ownerGrid.updateLayout();
        Ext.resumeLayouts(true);
      }
    }
  }
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TableView_6_0_2'], 0);
Ext.cmd.derive('Sch.patches.TableView_6_2_0', Sch.util.Patch, {minVersion:'6.2.0', maxVersion:'6.2.1', target:'Ext.view.Table', overrides:{getDefaultFocusPosition:function(fromComponent) {
  var me = this, store = me.dataSource, focusPosition = me.lastFocused, newPosition = (new Ext.grid.CellContext(me)).setPosition(0, 0), targetCell, scroller;
  if (fromComponent) {
    if (fromComponent.isColumn && fromComponent.cellFocusable !== false) {
      if (!focusPosition) {
        focusPosition = newPosition;
      }
      focusPosition.setColumn(fromComponent);
      focusPosition.setView(fromComponent.getView());
    } else {
      if (fromComponent.isTableView && fromComponent.lastFocused) {
        focusPosition = (new Ext.grid.CellContext(me)).setPosition(fromComponent.lastFocused.record, 0);
      }
    }
  }
  if (focusPosition) {
    scroller = me.getScrollable();
    if (!store.contains(focusPosition.record) || scroller && !scroller.isInView(focusPosition.getRow()).y) {
      focusPosition.setRow(store.getAt(Math.min(focusPosition.rowIdx, store.getCount() - 1)));
    }
  } else {
    focusPosition = newPosition;
    targetCell = me.el.down(me.getCellSelector() + '[tabIndex\x3d"-1"]');
    if (targetCell) {
      focusPosition.setPosition(me.getRecord(targetCell), me.getHeaderByCell(targetCell));
    } else {
      focusPosition = null;
    }
  }
  return focusPosition;
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TableView_6_2_0'], 0);
Ext.cmd.derive('Sch.patches.TimelineGridView', Sch.util.Patch, {target:'Sch.view.TimelineGridView', minVersion:'6.0.1', overrides:{initComponent:function() {
  this.callParent(arguments);
  if (this.rtl) {
    this.headerCt.on('afterlayout', function(header) {
      header.scrollTo(this.getScrollX());
    }, this);
  }
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TimelineGridView'], 0);
Ext.cmd.derive('Sch.patches.TimelineGridViewScroll6_2', Sch.util.Patch, {target:'Sch.view.TimelineGridView', minVersion:'6.2.0', overrides:{scrollVerticallyTo:function(y, animate) {
  this.up('timelinegrid,timelinetree').getScrollable().scrollTo(null, y, animate);
}, getVerticalScroll:function() {
  var scrollable = this.up('timelinegrid,timelinetree').getScrollable();
  if (scrollable.getNormalScroller) {
    if (scrollable.getNormalScroller()) {
      return scrollable.getPosition().y;
    } else {
      return 0;
    }
  } else {
    return scrollable.getPosition().y;
  }
}}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TimelineGridViewScroll6_2'], 0);
Ext.cmd.derive('Sch.patches.TimelinePanel', Sch.util.Patch, {target:'Sch.mixin.TimelinePanel', minVersion:'6.2.0', applyFn:function() {
  Sch.panel.TimelineGridPanel && Sch.panel.TimelineGridPanel.override({hideHeaders:false});
  Sch.panel.TimelineTreePanel && Sch.panel.TimelineTreePanel.override({hideHeaders:false});
}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TimelinePanel'], 0);
Ext.cmd.derive('Sch.patches.TouchAction', Sch.util.Patch, {target:'Ext.dom.TouchAction', applyFn:function() {
  var old = Ext.dom.TouchAction.onTouchEnd;
  Ext.dom.TouchAction.onTouchEnd = function(e) {
    e.touches = e.touches || [];
    return old.apply(this, arguments);
  };
}}, 0, 0, 0, 0, 0, 0, [Sch.patches, 'TouchAction'], 0);
Ext.cmd.derive('MultiEmpDispatch.Application', Ext.app.Application, {name:'MultiEmpDispatch', quickTips:false, platformConfig:{desktop:{quickTips:true}}, onAppUpdate:function() {
  Ext.Msg.confirm('Application Update', 'This application has an update, reload?', function(choice) {
    if (choice === 'yes') {
      window.location.reload();
    }
  });
}}, 0, 0, 0, 0, 0, 0, [MultiEmpDispatch, 'Application'], 0);
Ext.cmd.derive('Sdc.data.mixin.AbstractDecodeMessages', Ext.Base, {decodeErrors:function(response, defaultMessage) {
  try {
    var jsonResponse = Ext.decode(response), responseData = jsonResponse, errors = responseData.Messages.ErrorMessages, i, message = '';
    for (i = 0; i < errors.length; ++i) {
      message += '- ' + errors[i] + '\x3cbr/\x3e';
    }
  } catch (error) {
    message = defaultMessage;
  }
  Ext.MessageBox.show({title:Sdc.locale.Messages.ERROR, msg:message, buttons:Ext.MessageBox.OK, icon:Ext.MessageBox.ERROR});
}, decodeWarnings:function(response, window) {
  try {
    var jsonResponse = Ext.decode(response), responseData = jsonResponse, warnings = responseData.Messages.WarningMessages, i, message = '';
    for (i = 0; i < warnings.length; ++i) {
      message += '- ' + warnings[i] + '\x3cbr/\x3e';
    }
  } catch (error) {
  }
  if (message === '') {
    if (window && window.hide) {
      window.hide();
    }
  } else {
    Ext.MessageBox.show({title:Sdc.locale.Messages.WARNING, msg:message, buttons:Ext.MessageBox.OK, icon:Ext.MessageBox.WARNING, fn:function(button, text) {
      Ext.MessageBox.hide();
      if (window && window.hide) {
        window.hide();
      }
    }});
  }
}}, 0, 0, 0, 0, 0, 0, [Sdc.data.mixin, 'AbstractDecodeMessages'], 0);
Ext.cmd.derive('Sdc.data.mixin.AppointmentValidations', Ext.Base, {isAppointmentValid:function(resource, appointment) {
  var appointments = this.getEventsForResource(resource);
  if (!appointments || appointments.length === 0) {
    return true;
  }
  for (var i = 0, l = appointments.length; i < l; i++) {
    if (appointments[i].data.CustomID != appointment.data.CustomID) {
      if (appointments[i].getStartDate() < appointment.getStartDate() && appointment.getStartDate() < appointments[i].getEndDate()) {
        return false;
      }
      if (appointments[i].getStartDate() < appointment.getEndDate() && appointment.getEndDate() < appointments[i].getEndDate()) {
        return false;
      }
      if (appointment.getStartDate() <= appointments[i].getStartDate() && appointments[i].getEndDate() <= appointment.getEndDate()) {
        return false;
      }
    }
  }
  return true;
}}, 0, 0, 0, 0, 0, 0, [Sdc.data.mixin, 'AppointmentValidations'], 0);
Ext.cmd.derive('Sdc.model.Appointments', Sch.model.Event, {resourceIdField:'EmployeeID', idProperty:'CustomID', startDateField:'ScheduledDateTimeBegin', endDateField:'ScheduledDateTimeEnd', nameField:'RefNbr', fields:[{name:'SOID', type:'int', allowNull:true}, {name:'EmployeeID', type:'int', allowNull:true}, {name:'CanDeleteAppointment', type:'bool'}, {name:'AppointmentID', type:'int'}, {name:'AutoDocDesc', type:'string'}, {name:'Confirmed', type:'bool'}, {name:'BranchLocationID', type:'int'}, {name:'BranchID', 
type:'int', allowNull:true}, {name:'BranchLocationID', type:'int', allowNull:true}, {name:'CustomerID', type:'int', allowNull:true}, {name:'CustomerID', type:'string'}, {name:'DocDesc', type:'string'}, {name:'LongDescr', type:'string'}, {name:'ScheduledDateTimeBegin', type:'date', dateFormat:'m/d/Y g:i A', mapping:'CustomDateTimeStart', convert:function(value, record) {
  return new Date(value);
}, serialize:function(value, record) {
  return Ext.Date.format(value, 'Y-m-d g:i:s A');
}}, {name:'ScheduledDateTimeEnd', type:'date', dateFormat:'m/d/Y g:i A', mapping:'CustomDateTimeEnd', convert:function(value, record) {
  return new Date(value);
}, serialize:function(value, record) {
  return Ext.Date.format(value, 'Y-m-d g:i:s A');
}}, {name:'Status', type:'string'}, {name:'ActualStartTime', type:'date', dateFormat:'m/d/Y g:i A', allowNull:true, convert:function(value, record) {
  if (value) {
    return new Date(value);
  }
  return value;
}, serialize:function(value, record) {
  if (value) {
    return Ext.Date.format(value, 'Y-m-d g:i:s A');
  }
  return value;
}}, {name:'ActualEndTime', type:'date', dateFormat:'m/d/Y g:i A', allowNull:true, convert:function(value, record) {
  if (value) {
    return new Date(value);
  }
  return value;
}, serialize:function(value, record) {
  if (value) {
    return Ext.Date.format(value, 'Y-m-d g:i:s A');
  }
  return value;
}}, {name:'SORefNbr', type:'string'}, {name:'SrvOrdType', type:'string'}, {name:'SrvOrdTypeDescr', type:'string'}, {name:'CustomID', type:'string'}, {name:'CustomerLocation', type:'string'}, {name:'OldEmployeeID', type:'int', allowNull:true}, {name:'CustomerName', type:'string'}, {name:'ContactName', type:'string'}, {name:'ContactEmail', type:'string'}, {name:'ContactPhone', type:'string'}, {name:'LocationDesc', type:'string'}, {name:'FirstResourceName', type:'string'}, {name:'FirstServiceDesc', 
type:'string'}, {name:'ServiceCount', type:'int'}, {name:'RoomDesc', type:'string'}, {name:'RoomID', type:'string'}, {name:'EstimatedDurationTotal', type:'float'}, {name:'TravelTime', type:'string'}, {name:'ServiceDuration', type:'float'}, {name:'DriverName', type:'string'}, {name:'LocationCD', type:'string'}, {name:'PostalCode', type:'string'}, {name:'Address', type:'string'}, {name:'EmployeeCount', type:'int'}, {name:'ValidatedByDispatcher', type:'bool'}, {name:'WarningResourceAvailableFlag', type:'bool', 
defaultValue:false}, {name:'WarningAppointmentValidFlag', type:'bool', defaultValue:false}, {name:'Draggable', type:'bool', convert:function(newValue, model) {
  return true;
}}, {name:'Resizable', type:'bool', convert:function(newValue, model) {
  return true;
}}, {name:'WFStageCD', type:'string'}, {name:'OpenAppointmentScreenOnError', type:'bool', defaultValue:false}]}, 0, 0, 0, 0, 0, 0, [Sdc.model, 'Appointments'], 0);
Ext.cmd.derive('MultiEmpDispatch.store.AppointmentStore', Sch.data.EventStore, {model:'Sdc.model.Appointments', storeId:'Appointments', autoSync:true, successLoad:false, currentStartDate:null, currentEndDate:null, focusAppointmentID:null, unassignedAppointment:null, proxy:{type:'ajax', headers:{'Content-type':'application/json; charset\x3dutf-8'}, api:{read:pageUrl + '/GetDispatchBoardAppointments', create:'data/e-create.aspx', destroy:pageUrl + '/DeleteAppointments', update:pageUrl + '/PutAppointments'}, 
reader:{type:'json', rootProperty:'Rows', metaProperty:'MetaData', totalProperty:'TotalRows', successProperty:'Success', messageProperty:'Message'}, writer:{type:'json', rootProperty:'appointment', writeAllFields:true, encode:false}, extraParams:{scheduledStartDate:null, scheduledEndDate:'null', branchLocationID:null, employeeIDList:null}, extractResponseData:function(response) {
  return Ext.decode(response.responseText).Result;
}}, listeners:{load:function() {
  var me = this, index = 0;
  me.successLoad == false && me.scheduler.focusCurrentTime();
  me.successLoad = true;
  if (me.focusAppointmentID) {
    index = me.find('AppointmentID', me.focusAppointmentID);
    if (index != -1) {
      me.scheduler.getSchedulingView().scrollEventIntoView(me.getAt(index), true, true);
      me.scheduler.focusAppointment = me.getAt(index);
      me.scheduler.mainContainer.showAppointmentToast(me.getAt(index), null);
    }
  }
  if (me.unassignedAppointment) {
    index = me.find('AppointmentID', me.unassignedAppointment);
    if (index != -1 && me.getAt(index).get('EmployeeID') == me.targetResource.get('EmployeeID')) {
      me.scheduler.getSchedulingView().scrollEventIntoView(me.getAt(index), true, true);
      me.scheduler.focusAppointment = me.getAt(index);
      me.scheduler.mainContainer.showAppointmentToast(me.getAt(index), me.targetResource);
    }
  }
  me.scheduler.mainContainer.loadMask.hide();
  me.focusAppointmentID = null;
  me.unassignedAppointment = null;
  me.targetResource = null;
}}, onCreateRecords:function(records, operation, success) {
  var me = this;
  if (!success) {
    me.rejectChanges();
    me.remove(records);
  }
}, onUpdateRecords:function(records, operation, success) {
  var me = this;
  if (!success) {
    var message = operation.error != null && operation.error.status == 404 ? Sdc.locale.Messages.ERROR_CONNECTION_FAILURE : operation.error.statusText;
    me.decodeErrors(operation.error.responseText, message);
    me.rejectChanges();
  } else {
    me.decodeWarnings(operation.getResponse().responseText);
    if (records[0].data.EmployeeCount > 1) {
      if (me.scheduler && me.scheduler.mainContainer) {
        var refreshParams = {context:me.scheduler.mainContainer, appointment:true};
        me.scheduler.mainContainer.reloadCalendar(refreshParams);
      }
    } else {
      records[0].data.OldEmployeeID = records[0].data.EmployeeID;
      records[0].data.CustomID = records[0].data.AppointmentID + '' + records[0].data.EmployeeID;
    }
    me.load();
  }
}, onDestroyRecords:function(records, operation, success) {
  var me = this;
  if (!success) {
    var message = operation.error != null && operation.error.status == 404 ? Sdc.locale.Messages.ERROR_CONNECTION_FAILURE : operation.error.statusText;
    me.decodeErrors(operation.error.responseText, message);
    me.rejectChanges();
  } else {
    me.decodeWarnings(operation.getResponse().responseText);
    if (me.scheduler && me.scheduler.mainContainer) {
      var refreshParams = {context:me.scheduler.mainContainer, appointment:true, serviceOrder:true};
      me.scheduler.mainContainer.reloadCalendar(refreshParams);
    }
  }
}}, 0, 0, 0, 0, 0, [['DecodeMessages', Sdc.data.mixin.AbstractDecodeMessages], ['AppointmentValidations', Sdc.data.mixin.AppointmentValidations]], [MultiEmpDispatch.store, 'AppointmentStore'], 0);
Ext.cmd.derive('Sdc.data.mixin.AvailabilityValidations', Ext.Base, {isResourceAvailable:function(resource, start, end) {
  var availability = this.getEventsForResource(resource);
  if (!availability || availability.length === 0) {
    return false;
  }
  for (var i = 0, l = availability.length; i < l; i++) {
    if (Sch.util.Date.timeSpanContains(availability[i].getStartDate(), availability[i].getEndDate(), start, end)) {
      return true;
    }
  }
  return false;
}}, 0, 0, 0, 0, 0, 0, [Sdc.data.mixin, 'AvailabilityValidations'], 0);
Ext.cmd.derive('Sdc.model.Availability', Sch.model.Event, {resourceIdField:'EmployeeID', startDateField:'TimeStart', endDateField:'TimeEnd', fields:[{name:'TimeStart', type:'date', dateFormat:'m/d/Y g:i A', mapping:'CustomDateTimeStart', convert:function(value, record) {
  return new Date(value);
}, serialize:function(value, record) {
  return Ext.Date.format(new Date(value), 'Y-m-d g:i:s A');
}}, {name:'TimeEnd', type:'date', dateFormat:'m/d/Y g:i A', mapping:'CustomDateTimeEnd', convert:function(value, record) {
  return new Date(value);
}, serialize:function(value, record) {
  return Ext.Date.format(new Date(value), 'Y-m-d g:i:s A');
}}, {name:'CompanyID', type:'int'}, {name:'BranchID', type:'int'}, {name:'BranchLocationID', type:'int', allowNull:true}, {name:'EmployeeID', type:'int', allowNull:true}, {name:'RecordID', type:'int', allowNull:true}, {name:'TimeSlotID', type:'int', allowNull:true}, {name:'RecordCount', type:'int'}, {name:'ScheduleType', type:'string'}, {name:'ScheduleRefNbr', type:'string'}, {name:'TimeDiff', type:'float'}, {name:'BranchLocationDesc', type:'string'}, {name:'BranchLocationCD', type:'string'}, {name:'Cls', 
type:'string', convert:function(newValue, model) {
  var value = newValue, scheduleType = model.get('ScheduleType');
  if (scheduleType == 'A') {
    value = 'availability-scheduler';
  }
  if (scheduleType == 'U') {
    value = 'unavailability-scheduler';
  }
  return value;
}}]}, 0, 0, 0, 0, 0, 0, [Sdc.model, 'Availability'], 0);
Ext.cmd.derive('MultiEmpDispatch.store.AvailabilityStore', Sch.data.EventStore, {model:'Sdc.model.Availability', autoSync:true, successLoad:false, currentStartDate:null, currentEndDate:null, proxy:{type:'ajax', headers:{'Content-type':'application/json; charset\x3dutf-8'}, url:pageUrl + '/GetEmployeeWorkingSchedule', reader:{type:'json', rootProperty:'Rows', metaProperty:'MetaData', totalProperty:'TotalRows', successProperty:'Success', messageProperty:'Message'}, writer:{type:'json'}, simpleSortMode:true, 
limitParam:false, startParam:false, pageParam:false, noCache:false, extraParams:{scheduledStartDate:null, scheduledEndDate:'null', compressSlot:true, employeeIDList:null}, extractResponseData:function(response) {
  return Ext.decode(response.responseText).Result;
}}}, 0, 0, 0, 0, 0, [['EmployeeValidations', Sdc.data.mixin.AvailabilityValidations]], [MultiEmpDispatch.store, 'AvailabilityStore'], 0);
Ext.cmd.derive('Sdc.model.DayRules', Sch.model.Range, {fields:[{name:'StartDate', type:'date', dateFormat:'m/d/Y g:i A', convert:function(value, record) {
  return new Date(value);
}, serialize:function(value, record) {
  return Ext.Date.format(value, 'Y-m-d g:i:s A');
}}, {name:'EndDate', type:'date', dateFormat:'m/d/Y g:i A', convert:function(value, record) {
  return new Date(value);
}, serialize:function(value, record) {
  return Ext.Date.format(value, 'Y-m-d g:i:s A');
}}, {name:'Type', type:'string'}, {name:'WorkDay', type:'bool'}, {name:'Cls', type:'string', convert:function(newValue, model) {
  var type = model.get('Type'), workDay = model.get('WorkDay');
  if (type) {
    if (type && type == 'CA') {
      return 'calendar-zone-cls';
    }
    if (type && type == 'CE') {
      if (workDay) {
        return 'calendar-exception-workday-zone-cls';
      } else {
        return 'calendar-exception-not-workday-zone-cls';
      }
    }
  }
  return newValue;
}}]}, 0, 0, 0, 0, 0, 0, [Sdc.model, 'DayRules'], 0);
Ext.cmd.derive('MultiEmpDispatch.store.DayRuleStore', Ext.data.Store, {model:'Sdc.model.DayRules', remoteSort:false, remoteFilter:false, proxy:{type:'ajax', headers:{'Content-type':'application/json; charset\x3dutf-8'}, url:pageUrl + '/GetDayRules', reader:{type:'json', rootProperty:'Rows', metaProperty:'MetaData', totalProperty:'TotalRows', successProperty:'Success', messageProperty:'Message'}, writer:{type:'json', encode:false}, simpleSortMode:true, limitParam:false, startParam:false, pageParam:false, 
noCache:false, extraParams:{scheduledStartDate:null, scheduledEndDate:'null'}, extractResponseData:function(response) {
  return Ext.decode(response.responseText).Result;
}}}, 0, 0, 0, 0, 0, 0, [MultiEmpDispatch.store, 'DayRuleStore'], 0);
Ext.cmd.derive('Sdc.model.Employee', Sch.model.Resource, {idProperty:'EmployeeID', nameField:'DisplayName', fields:[{name:'EmployeeID', type:'int'}, {name:'EmployeeCD', type:'string'}, {name:'ContactID', mapping:'Contact.ContactID', type:'int'}, {name:'CompanyID', mapping:'Contact.CompanyID', type:'int'}, {name:'DisplayName', mapping:'Contact.DisplayName', type:'string'}, {name:'FirstName', mapping:'Contact.FirstName', type:'string'}, {name:'LastName', mapping:'Contact.LastName', type:'string'}, 
{name:'FullName', mapping:'Contact.FullName', type:'string'}, {name:'Email', mapping:'Contact.Email', type:'string'}, {name:'Phone1', mapping:'Contact.Phone1', type:'string'}, {name:'Phone2', mapping:'Contact.Phone2', type:'string'}, {name:'Phone3', mapping:'Contact.Phone3', type:'string'}, {name:'IsVendor', mapping:'IsVendor', type:'bool'}, {name:'Display', type:'string', convert:function(value, record) {
  if (record.get('EmployeeCD') && record.get('DisplayName')) {
    return record.get('EmployeeCD').replace(/\s+/g, '') + ' - ' + record.get('DisplayName');
  }
  if (!record.get('DisplayName')) {
    return record.get('EmployeeCD').replace(/\s+/g, '');
  }
  return record.get('DisplayName');
}}], isAvailable:function(start, end) {
  return true;
}}, 0, 0, 0, 0, 0, 0, [Sdc.model, 'Employee'], 0);
Ext.cmd.derive('MultiEmpDispatch.store.EmployeeStore', Sch.data.ResourceStore, {model:'Sdc.model.Employee', storeId:'Employees', remoteSort:false, remoteFilter:true, start:0, pageSize:10, proxy:{type:'ajax', headers:{'Content-type':'application/json; charset\x3dutf-8'}, url:pageUrl + '/GetEmployees', reader:{type:'json', rootProperty:'Rows', metaProperty:'MetaData', totalProperty:'TotalRows', successProperty:'Success', messageProperty:'Message'}, writer:{type:'json'}, extraParams:{ignoreAvailabilityFlag:false, 
ignoreActiveFlag:false, scheduledStartDate:'null', scheduledEndDate:'null', loadVendor:true}, extractResponseData:function(response) {
  return Ext.decode(response.responseText).Result;
}}, listeners:{load:function() {
  var me = this;
  var buttonEpClearFilter = me.clearFilterButton;
  if (buttonEpClearFilter) {
    !me.getFilters().getCount() > 0 ? buttonEpClearFilter.hide() : buttonEpClearFilter.show();
  }
  if (me.scheduler) {
    me.scheduler.focusCurrentTime();
  }
}}, disablePaging:function() {
  var me = this;
  me.proxy.limitParam = false;
  me.proxy.startParam = false;
  me.proxy.pageParam = false;
  me.proxy.noCache = false;
}}, 0, 0, 0, 0, 0, 0, [MultiEmpDispatch.store, 'EmployeeStore'], 0);
Ext.cmd.derive('Sdc.model.ServiceOrder', Ext.data.TreeModel, {idProperty:'SOID', nameField:'RefNbr', fields:[{name:'SrvOrdType', type:'string'}, {name:'RefNbr', type:'string'}, {name:'SOID', type:'int'}, {name:'AddressLine1', type:'string'}, {name:'AddressLine2', type:'string'}, {name:'AddressLine3', type:'string'}, {name:'AddressValidated', type:'bool'}, {name:'AssignedEmpID', type:'int'}, {name:'AssignedEmpDislpayName', type:'string'}, {name:'AutoDocDesc', type:'string'}, {name:'BillCustomerID', 
type:'int'}, {name:'BillLocationID', type:'int'}, {name:'CauseID', type:'int'}, {name:'CheckOutDateTime', type:'date', dateFormat:'MS', serialize:function(value, record) {
  return Ext.Date.format(value, 'Y-m-d g:i:s A');
}}, {name:'CheckOutFlag', type:'bool'}, {name:'City', type:'string'}, {name:'ContactID', type:'int'}, {name:'ContractID', type:'int'}, {name:'CountryID', type:'int'}, {name:'BranchLocationID', type:'int'}, {name:'CustomerID', type:'int'}, {name:'OrderDate', type:'date', dateFormat:'m/d/Y g:i A', mapping:'CustomOrderDate', convert:function(value, record) {
  return new Date(value);
}, serialize:function(value, record) {
  return Ext.Date.format(value, 'Y-m-d g:i:s A');
}}, {name:'DocDesc', type:'string'}, {name:'EMail', type:'string'}, {name:'EstimatedDurationTotal', type:'int'}, {name:'Fax', type:'string'}, {name:'Hold', type:'bool'}, {name:'LocationID', type:'int'}, {name:'LongDescr', type:'string'}, {name:'Priority', type:'string'}, {name:'ResolutionDate', type:'date', dateFormat:'MS', serialize:function(value, record) {
  return Ext.Date.format(value, 'Y-m-d g:i:s A');
}}, {name:'Severity', type:'string'}, {name:'SLARemaning', type:'string'}, {name:'Status', type:'string'}, {name:'SourceType', type:'string'}, {name:'SourceRefNbr', type:'string'}, {name:'AssignedEmployeeDisplayName', type:'string'}, {name:'CustomerDisplayName', type:'string'}, {name:'ContactName', type:'string'}, {name:'ContactPhone', type:'string'}, {name:'ContactEmail', type:'string'}, {name:'ServicesRemaning', type:'int'}, {name:'BranchLocationDesc', type:'string'}, {name:'ServicesCount', type:'int'}]}, 
0, 0, 0, 0, 0, 0, [Sdc.model, 'ServiceOrder'], 0);
Ext.cmd.derive('Sdc.model.ServiceOrderTreeNode', Sdc.model.ServiceOrder, {idProperty:'TreeID', nameField:'RefNbr', fields:[{name:'TreeID', type:'int'}, {name:'RefNbr', type:'string'}, {name:'text', type:'string', mapping:'Text'}, {name:'leaf', type:'bool', mapping:'Leaf'}, {name:'SODetID', type:'int', allowNull:true}, {name:'ServiceID', type:'int'}], getName:function() {
  var me = this;
  if (me.nameField) {
    return me.get(me.nameField);
  } else {
    return me.getId();
  }
}}, 0, 0, 0, 0, 0, 0, [Sdc.model, 'ServiceOrderTreeNode'], 0);
Ext.cmd.derive('MultiEmpDispatch.store.ServiceOrderStore', Ext.data.TreeStore, {model:'Sdc.model.ServiceOrderTreeNode', autoLoad:false, remoteFilter:true, serviceOrderFlag:true, pageSize:15, root:{TreeID:0, text:'ServiceOrder', leaf:false, expanded:false}, proxy:{type:'ajax', headers:{'Content-type':'application/json; charset\x3dutf-8'}, url:pageUrl + '/GetServiceOrdersTree', reader:{type:'json', rootProperty:'Rows', metaProperty:'MetaData', totalProperty:'TotalRows', successProperty:'Success', messageProperty:'Message'}, 
extraParams:{branchID:null, branchLocationID:null, scheduledStartDate:null, scheduledEndDate:'null', isRoomCalendar:false}, extractResponseData:function(response) {
  return Ext.decode(response.responseText).Result;
}}, getTotalCount:function() {
  if (!this.proxy.reader.metaData) {
    return 0;
  }
  this.totalCount = this.proxy.reader.metaData.TotalRows;
  return this.totalCount;
}, listeners:{load:function(store, records, success, eOpts) {
  var me = this;
  if (success) {
    me.getRootNode().expand();
  }
  if (me.serviceOrderFlag && me.getRootNode().hasChildNodes()) {
    me.serviceOrderTree.mainContainer && me.serviceOrderTree.mainContainer.getMainTabPanel().expand();
    if (AppSource == '') {
      me.serviceOrderTree.mainContainer.getMainTabPanel().setActiveTab(ID.serviceOrderGrid);
    }
    me.serviceOrderFlag = false;
  }
  var buttonSoClearFilter = me.clearFilterButton;
  if (buttonSoClearFilter) {
    if (!me.getFilters().getCount() > 0) {
      buttonSoClearFilter.hide();
    } else {
      buttonSoClearFilter.show();
    }
  }
}}}, 0, 0, 0, 0, 0, 0, [MultiEmpDispatch.store, 'ServiceOrderStore'], 0);
Ext.cmd.derive('MultiEmpDispatch.store.UnassignedAppointmentStore', Ext.data.Store, {model:'Sdc.model.Appointments', autoSync:true, remoteSort:false, remoteFilter:true, start:0, pageSize:20, grid:null, unassignedAppointmentFlag:true, clearFilterButton:null, proxy:{type:'ajax', headers:{'Content-type':'application/json; charset\x3dutf-8'}, api:{read:pageUrl + '/GetUnassignedAppointments', create:'data/e-create.aspx', destroy:pageUrl + '/DeleteAppointments', update:pageUrl + '/PutAppointments'}, reader:{type:'json', 
rootProperty:'Rows', metaProperty:'MetaData', totalProperty:'TotalRows', successProperty:'Success', messageProperty:'Message'}, writer:{type:'json', rootProperty:'appointment', writeAllFields:true, encode:false}, extraParams:{unassignedAppointmentByRoom:false, scheduledStartDate:null, scheduledEndDate:'null', branchID:null, branchLocationID:null}, extractResponseData:function(response) {
  return Ext.decode(response.responseText).Result;
}}, listeners:{load:function(store, records, success, eOpts) {
  var me = this;
  var recordsLength = records ? records.length : 0;
  me.grid.updateGridTitle(recordsLength);
  if (me.unassignedAppointmentFlag && recordsLength > 0) {
    me.grid.mainContainer.getMainTabPanel().expand();
  }
  if (me.mainContainer && AppSource != '') {
    me.grid.mainContainer.getMainTabPanel().setActiveTab(ID.unassignedAppointmentGrid);
    AppSource = '';
  }
  var buttonUaClearFilter = me.clearFilterButton;
  if (buttonUaClearFilter) {
    if (!me.getFilters().getCount() > 0) {
      buttonUaClearFilter.disable();
    } else {
      buttonUaClearFilter.enable();
    }
  }
}}, onUpdateRecords:function(records, operation, success) {
  var me = this;
  if (!success) {
    var response = Ext.decode(operation.error.response.responseText);
    var refreshParams = {context:me.mainContainer, appointment:true, unassignedAppointment:true};
    var callback = me.mainContainer.reloadCalendar;
    var callParams = {ProcessID:response.Result.Rows[0].ProcessID};
    Sdc.util.PopUpManager.openPageUrl('appointmentBridge', callParams, null, callback, refreshParams);
    me.rejectChanges();
  }
}}, 0, 0, 0, 0, 0, 0, [MultiEmpDispatch.store, 'UnassignedAppointmentStore'], 0);
Ext.cmd.derive('Sdc.message.Notification', Ext.Base, {singleton:true, msgContainer:null, msgInner:null, lastCls:null, ERROR:'error', ALERT:'alert', WARNING:'warning', INFO:'info', init:function() {
  var me = this;
  if (!me.msgContainer) {
    me.msgContainer = Ext.DomHelper.insertFirst(document.body, {id:'msg-div'}, true);
  }
  me.msgContainer.addListener('click', me.onClick, me);
}, createBox:function(title, summary, callbackObj, cls) {
  return '\x3cdiv class\x3d"msg ' + cls + ' x-border-box"\x3e\x3ch3\x3e' + title + '\x3c/h3\x3e\x3cp\x3e' + (summary && summary.description ? summary.description : '') + (summary && summary.label ? '\x3cstrong id\x3d"summaryLabelLink"\x3e ' + summary.label + '\x3cstrong\x3e' : '') + '\x3c/p\x3e' + (callbackObj && callbackObj.label ? '\x3cp\x3e\x3cstrong id\x3d"eventLabelLink"\x3e' + callbackObj.label + '\x3c/strong\x3e\x3cp\x3e' : '') + '\x3cdiv id\x3d"messageCloseButton" class\x3d"x-corner"\x3e\x3c/div\x3e\x3c/div\x3e';
}, displayMessage:function(title, summaryObj, cls, callbackObj) {
  var me = this;
  if (!me.msgContainer) {
    me.msgContainer = Ext.DomHelper.insertFirst(document.body, {id:'msg-div'}, true);
  }
  if (me.msgInner) {
    me.msgInner.destroy();
  }
  me.msgInner = Ext.DomHelper.append(me.msgContainer, me.createBox(title, summaryObj, callbackObj, cls), true);
  me.msgInner.summaryCallbackObj = summaryObj;
  me.msgInner.eventCallbackObj = callbackObj;
  me.msgInner.hide();
  me.msgInner.fadeIn({opacity:0.95, duration:500}).fadeOut({opacity:0, delay:4000, duration:1000, remove:true});
}, onClick:function(eventObject, target, eOpts) {
  var me = this;
  if (target.id == ID.messageCloseButton) {
    if (me.msgInner) {
      me.msgInner.destroy();
    }
  }
  if (target.id == ID.summaryLabelLink && me.msgInner.summaryCallbackObj) {
    if (!me.msgInner.summaryCallbackObj.callbackFn) {
      return;
    }
    var scope = me.msgInner.summaryCallbackObj.scope || me;
    Ext.callback(me.msgInner.summaryCallbackObj.callbackFn, scope, me.msgInner.summaryCallbackObj.callbackParams);
  }
  if (target.id == ID.eventLabelLink && me.msgInner.eventCallbackObj) {
    var scope = me.msgInner.summaryCallbackObj.scope || me;
    Ext.callback(me.msgInner.eventCallbackObj.callbackFn, scope, me.msgInner.eventCallbackObj.callbackParams);
  }
}}, 0, 0, 0, 0, 0, 0, [Sdc.message, 'Notification'], 0);
Ext.cmd.derive('Sdc.locale.UrlValidator', Ext.Base, {baseUrl:null, webMethodUrl:null, url:{}, constructor:function(cfg) {
  var me = this;
  Ext.apply(me, cfg || {});
  me.callParent(arguments);
}, setBaseUrl:function(baseUrl) {
  var me = this;
  if (!baseUrl) {
    return false;
  }
  me.baseUrl = baseUrl;
  return true;
}, setWebMethodUrl:function(webMethodUrl) {
  var me = this;
  if (!webMethodUrl) {
    return false;
  }
  me.webMethodUrl = webMethodUrl;
  return true;
}, getUrlPath:function(urlKey, params) {
  var me = this;
  var result = '', queryString = '';
  var clsProto = this.self && this.self.prototype;
  if (clsProto.url && clsProto.url[urlKey]) {
    var urlCfg = clsProto.url[urlKey], firstElement = true;
    if (urlCfg) {
      var queryStringKey = urlCfg.queryStringKey;
      for (var key in params) {
        if (queryStringKey.hasOwnProperty(key) && queryStringKey[key]) {
          if (firstElement) {
            firstElement = false;
          } else {
            queryString = queryString + '\x26';
          }
          queryString = queryString + key + '\x3d' + params[key];
        }
      }
    }
    if (urlCfg.webMethod) {
      if (me.webMethodUrl) {
        result = me.webMethodUrl;
      }
    } else {
      if (me.baseUrl) {
        result = me.baseUrl;
      }
    }
    result = result + urlCfg.path;
    if (queryString) {
      result = result + '?' + queryString;
    }
  }
  return result;
}}, 1, 0, 0, 0, 0, 0, [Sdc.locale, 'UrlValidator'], 0);
Ext.cmd.derive('Sdc.locale.Url', Sdc.locale.UrlValidator, {singleton:true, baseUrl:null, url:{serviceOrder:{path:'pages/FS/FS300100.aspx', queryStringKey:{SrvOrdType:true, RefNbr:true, PopupPanel:true}}, crmCases:{path:'pages/CR/cr306000.aspx', queryStringKey:{CaseCD:true, PopupPanel:true}}, saleOrder:{path:'pages/SO/so301000.aspx', queryStringKey:{OrderType:true, OrderNbr:true, PopupPanel:true}}, cloneAppointment:{path:'pages/FS/FS500201.aspx', queryStringKey:{SrvOrdType:true, RefNbr:true, ScheduledStartTime:true, 
ScheduledEndTime:true, AppointmentID:true, PopupPanel:true}}, appointment:{path:'pages/FS/FS300200.aspx', queryStringKey:{SrvOrdType:true, sORefNbr:true, RefNbr:true, PopupPanel:true}}, employee:{path:'pages/EP/ep203000.aspx', queryStringKey:{bAccountID:true, PopupPanel:true}}, singleEmpDispatch:{path:'pages/FS/calendars/SingleEmpDispatch/FS300400.aspx', queryStringKey:{branchID:true, branchLocationID:true, bAccountID:true, Date:true, PopupPanel:true}}, appointmentInquiry:{path:'pages/FS/FS400100.aspx', 
queryStringKey:{PopupPanel:true}}, employeeScheduler:{path:'pages/FS/FS202200.aspx', queryStringKey:{EmployeeID:true, RecordID:true, DateStart:true, TimeStart:true, DateEnd:true, TimeEnd:true, PopupPanel:true}}, appointmentBridge:{path:'pages/FS/FS200000.aspx', queryStringKey:{ProcessID:true, PopupPanel:true}}, newAppointmentBridge:{path:'/NewAppointmentBridge', webMethod:true, queryStringKey:{appointment:true, sODetIDList:true, employeeIDList:true, PopupPanel:true}}, newWrkSchedulerBridge:{path:'/NewWrkSchedulerBridge', 
webMethod:true, queryStringKey:{wrkEmployeeSchedule:true, PopupPanel:true}}, getSetup:{path:'/GetSetups', webMethod:true, queryStringKey:{}}, getCalendarFieldPreferences:{path:'/GetCustomFieldAppointments', webMethod:true, queryStringKey:{isActive:true}}, getCalendarStatusPreferences:{path:'/GetCustomAppointmentStatuses', webMethod:true, queryStringKey:{isActive:true}}}, constructor:function() {
  var me = this;
  me.callParent(arguments);
}}, 1, 0, 0, 0, 0, 0, [Sdc.locale, 'Url'], 0);
Ext.cmd.derive('Sdc.util.PopUpManager', Ext.Base, {singleton:true, paramsOptions:{toolbar:0, location:0, menubar:0, width:960, height:700}, lastAppointment:null, lastAvailability:null, sODetIDList:[], employeeIDList:[], constructor:function(cfg) {
  var me = this;
  Ext.apply(me, cfg || {});
  me.callParent(arguments);
}, getWindowConfiguration:function(config) {
  var me = this, result = '', option, i = 1, length;
  length = me.paramsOptions ? Object.keys(me.paramsOptions).length : 0;
  for (var key in me.paramsOptions) {
    option = key + '\x3d' + (config && config.hasOwnProperty(key) ? config[key] : me.paramsOptions[key]);
    result = result + option + (length > i ? ',' : '');
    ++i;
  }
  return result;
}, openPageUrl:function(pageID, params, popupCfg, fn, refreshParams) {
  if (!pageID) {
    throw 'Cannot Open Page, missing Url ID';
  }
  if (pageID === 'newAppointmentBridgeID') {
    me.newAppointmentBridgeID(params, popupCfg, fn, refreshParams);
    return;
  }
  var me = this;
  var cfg = {PopupPanel:'On'};
  params = Ext.merge(params, cfg);
  var urlPath = Sdc.locale.Url.getUrlPath(pageID, params);
  if (!urlPath) {
    throw 'Url ID cannot be found in the system: ' + pageID;
  }
  var newWindow = window.open(urlPath, 'pop', me.getWindowConfiguration(popupCfg));
  if (!fn) {
    return;
  }
  var interval = window.setInterval(function() {
    try {
      if (newWindow == null || newWindow.closed) {
        window.clearInterval(interval);
        fn(refreshParams);
      }
    } catch (e$43) {
    }
  }, 1000);
}, newAppointmentBridgeID:function(params, popupCfg, fn, refreshParams) {
  var me = this;
  if (!me.WindowSrvOrdType) {
    me.WindowSrvOrdType = Ext.create('Sdc.window.WindowSrvOrdType');
    me.WindowSrvOrdType.newAppointmentBridgeCallback = me.newAppointmentBridgeCallback;
  }
  var srvOrdTypeNotDefined = params && !params.SrvOrdType;
  if (Sdc.locale.SchedulerSetup.askForSrvOrdTypeInCalendars && srvOrdTypeNotDefined) {
    me.WindowSrvOrdType.context = {params:params, popupCfg:popupCfg, fn:fn, refreshParams:refreshParams};
    me.WindowSrvOrdType.show();
  } else {
    if (srvOrdTypeNotDefined) {
      params['SrvOrdType'] = Sdc.locale.SchedulerSetup.DfltSrvOrdType;
    }
    me.newAppointmentBridgeCallback(params, popupCfg, fn, refreshParams);
  }
}, newAppointmentBridgeCallback:function(params, popupCfg, fn, refreshParams) {
  var me = this;
  var values = Sdc.util.PopUpManager.getAppointmentPageParams(params);
  if (values) {
    Ext.Ajax.request({url:Sdc.locale.Url.getUrlPath('newAppointmentBridge', null), method:'POST', headers:{'Content-Type':'application/json'}, jsonData:values, success:function(response) {
      var jsonResponse = Ext.decode(response.responseText);
      if (jsonResponse.Result && jsonResponse.Result.Rows.length > 0) {
        var wrkProcess = jsonResponse.Result.Rows[0];
        if (wrkProcess.AppointmentID && !wrkProcess.ProcessID) {
          refreshParams.focusAppointmentID = wrkProcess.AppointmentID;
          fn(refreshParams);
        } else {
          refreshParams && refreshParams.context && refreshParams.context.loadMask && refreshParams.context.loadMask.hide();
          var callParams = {ProcessID:wrkProcess.ProcessID};
          Sdc.util.PopUpManager.openPageUrl('appointmentBridge', callParams, popupCfg, fn, refreshParams);
        }
      }
    }, failure:function(response) {
      console.log('server-side failure with status code ' + response.status);
      me.decodeErrors(response, response.statusText);
    }});
  }
}, newWrkSchedulerBridgeID:function(params, popupCfg, fn, refreshParams) {
  var me = this;
  var values = me.getWrkSchedulerPageParams(params);
  if (values) {
    Ext.Ajax.request({url:Sdc.locale.Url.getUrlPath('newWrkSchedulerBridge', null), method:'POST', headers:{'Content-Type':'application/json'}, jsonData:values, success:function(response) {
      var jsonResponse = Ext.decode(response.responseText);
      if (jsonResponse.Result && jsonResponse.Result.Rows.length > 0) {
        var wrkProcess = jsonResponse.Result.Rows[0];
        var callParams = {ProcessID:wrkProcess.ProcessID};
        Sdc.util.PopUpManager.openPageUrl('appointmentBridge', callParams, popupCfg, fn, refreshParams);
      }
    }, failure:function(response) {
      console.log('server-side failure with status code ' + response.status);
    }});
  }
}, getWrkSchedulerPageParams:function(values) {
  var me = this;
  if (values) {
    var obj = null;
    if (!me.lastAvailability) {
      me.lastAvailability = Ext.create('Sdc.model.Availability');
    } else {
      me.lastAvailability.reject();
    }
    var availability = me.lastAvailability;
    if (values.TimeStart) {
      availability.set('TimeStart', new Date(values.TimeStart));
    }
    if (values.TimeEnd) {
      availability.set('TimeEnd', new Date(values.TimeEnd));
    }
    if (values.EmployeeID) {
      availability.set('EmployeeID', values.EmployeeID);
    }
    if (values.BranchID) {
      availability.set('BranchID', values.BranchID);
    }
    if (values.BranchLocationID) {
      availability.set('BranchLocationID', values.BranchLocationID);
    }
    obj = {wrkEmployeeSchedule:availability.data};
    return obj;
  } else {
    return null;
  }
}, getAppointmentPageParams:function(values) {
  var me = this;
  if (values) {
    var obj = null;
    if (!me.lastAppointment) {
      me.lastAppointment = Ext.create('Sdc.model.Appointments');
    } else {
      me.lastAppointment.reject();
      me.sODetIDList = [];
      me.employeeIDList = [];
    }
    var appointment = me.lastAppointment;
    if (values.SOID) {
      appointment.set('SOID', values.SOID);
    }
    if (values.RoomID) {
      appointment.set('RoomID', values.RoomID);
    }
    if (values.SrvOrdType) {
      appointment.set('SrvOrdType', values.SrvOrdType);
    }
    if (values.ScheduledDateTimeBegin && values.ScheduledDateTimeBegin instanceof Date) {
      appointment.set('ScheduledDateTimeBegin', values.ScheduledDateTimeBegin);
    }
    if (values.ScheduledDateTimeEnd && values.ScheduledDateTimeEnd instanceof Date) {
      appointment.set('ScheduledDateTimeEnd', values.ScheduledDateTimeEnd);
    }
    if (values.SODetIDList && values.SODetIDList instanceof Array) {
      me.sODetIDList = values.SODetIDList;
    }
    if (values.BranchID) {
      appointment.set('BranchID', values.BranchID);
    }
    if (values.BranchLocationID) {
      appointment.set('BranchLocationID', values.BranchLocationID);
    }
    if (values.CustomerID) {
      appointment.set('CustomerID', values.CustomerID);
    }
    if (values.SMequipmentID) {
      appointment.set('SMequipmentID', values.SMequipmentID);
    }
    if (values.EmployeeIDList && values.EmployeeIDList instanceof Array) {
      me.employeeIDList = values.EmployeeIDList;
    }
    obj = {appointment:appointment.data, sODetIDList:me.sODetIDList, employeeIDList:me.employeeIDList};
    return obj;
  } else {
    return null;
  }
}}, 1, 0, 0, 0, 0, [['DecodeMessages', Sdc.data.mixin.AbstractDecodeMessages]], [Sdc.util, 'PopUpManager'], 0);
Ext.cmd.derive('Sdc.data.mixin.AppointmentActions', Ext.Base, {constructor:function() {
  var me = this;
  me.initForm();
}, initForm:function() {
  var me = this;
}, editAppointment:function(appointment, refreshCallBack, refreshParams) {
  if (!appointment) {
    return false;
  }
  var params = {RefNbr:appointment.get('RefNbr'), SrvOrdType:appointment.get('SrvOrdType')};
  Sdc.util.PopUpManager.openPageUrl('appointment', params, null, refreshCallBack, refreshParams);
  return true;
}, cloneAppointment:function(appointment, refreshCallBack, refreshParams) {
  if (!appointment) {
    return false;
  }
  var params = {RefNbr:appointment.get('RefNbr'), SrvOrdType:appointment.get('SrvOrdType'), ScheduledStartTime:Ext.Date.format(appointment.get('ScheduledDateTimeBegin'), 'Y-m-d h:i:s A'), ScheduledEndTime:Ext.Date.format(appointment.get('ScheduledDateTimeEnd'), 'Y-m-d h:i:s A'), AppointmentID:appointment.get('AppointmentID')};
  Sdc.util.PopUpManager.openPageUrl('cloneAppointment', params, null, refreshCallBack, refreshParams);
  return true;
}, validateAppointment:function(appointment, refreshCallBack, refreshParams) {
  var me = this;
  if (!appointment) {
    return false;
  }
  if (!appointment.get('ValidatedByDispatcher')) {
    appointment.set('ValidatedByDispatcher', true);
  } else {
    appointment.set('ValidatedByDispatcher', false);
  }
  return true;
}, confirmAppointment:function(appointment, refreshCallBack, refreshParams) {
  var me = this;
  if (!appointment) {
    return false;
  }
  if (!appointment.get('Confirmed')) {
    appointment.set('Confirmed', true);
  } else {
    appointment.set('Confirmed', false);
  }
  return true;
}, deleteAppointment:function(store, appointment, refreshCallBack, refreshParams) {
  var msg = Sdc.locale.Messages.ALERT_DELETE_APPOINTMENT;
  var width = 350;
  if (appointment.get('EmployeeCount') > 1) {
    msg = Sdc.locale.Messages.ALERT_DELETE_SHARED;
    width = 500;
  }
  Ext.MessageBox.show({title:Sdc.locale.Messages.DELETE, msg:msg, minWidth:width, icon:Ext.MessageBox.QUESTION, buttons:Ext.Msg.YESNO, fn:function(button, text) {
    if (button == 'yes') {
      store.remove(appointment);
      Ext.MessageBox.hide();
    } else {
      Ext.MessageBox.hide();
    }
  }});
}}, 1, 0, 0, 0, 0, 0, [Sdc.data.mixin, 'AppointmentActions'], 0);
Ext.cmd.derive('Sdc.shortcuts.mixin.AbstractAppointmentShortcuts', Ext.Base, {apppointmentShortcuts:[{'name':'Edit', 'functionName':'editAppointment', 'validateFn':function(record) {
  return true;
}, 'shortcutFn':function(store, record, callbackFn, callbackParams) {
  var me = this;
  me.editAppointment(record, callbackFn, callbackParams);
}}, {'name':'Clone', 'functionName':'cloneAppointment', 'validateFn':function(record) {
  return true;
}, 'shortcutFn':function(store, record, callbackFn, callbackParams) {
  var me = this;
  me.cloneAppointment(record, callbackFn, callbackParams);
}}, {'name':'Share', 'functionName':'shareAppointment', 'validateFn':function(record) {
  return true;
}, 'shortcutFn':function(store, record, callbackFn, callbackParams) {
  var me = this;
  me.shareAppointment(record, callbackFn, callbackParams);
}}, {'name':'Delete', 'functionName':'deleteAppointment', 'validateFn':function(record) {
  return true;
}, 'shortcutFn':function(store, record, callbackFn, callbackParams) {
  var me = this;
  me.deleteAppointment(store, record, callbackFn, callbackParams);
}}], appointmentShortcutsFn:function(functionName, store, record, callbackFn, callbackParams) {
  var me = this;
  var shortcut = Ext.Array.findBy(me.apppointmentShortcuts, function(shortcut) {
    return shortcut.functionName == functionName;
  }, me);
  if (shortcut && shortcut.shortcutFn && record) {
    Ext.callback(shortcut.shortcutFn, me, [store, record, callbackFn, callbackParams]);
  }
}, getAppointmentShortcuts:function(record) {
  var me = this;
  var shortcuts = [];
  for (var i = 0; i < me.apppointmentShortcuts.length; i++) {
    var shortcut = me.apppointmentShortcuts[i];
    if (shortcut.validateFn && shortcut.validateFn(record)) {
      shortcuts.push({'name':shortcut['name'], 'functionName':shortcut['functionName']});
    }
  }
  return shortcuts;
}}, 0, 0, 0, 0, 0, [[Sdc.data.mixin.AppointmentActions.prototype.mixinId || Sdc.data.mixin.AppointmentActions.$className, Sdc.data.mixin.AppointmentActions]], [Sdc.shortcuts.mixin, 'AbstractAppointmentShortcuts'], 0);
Ext.cmd.derive('Sdc.data.mixin.ServiceOrderActions', Ext.Base, {constructor:function() {
  var me = this;
}, editServiceOrder:function(serviceOrder, refreshCallBack, refreshParams) {
  if (!serviceOrder) {
    return false;
  }
  var params = {RefNbr:serviceOrder.get('RefNbr'), SrvOrdType:serviceOrder.get('SrvOrdType')};
  Sdc.util.PopUpManager.openPageUrl('serviceOrder', params, null, refreshCallBack, refreshParams);
  return true;
}}, 1, 0, 0, 0, 0, 0, [Sdc.data.mixin, 'ServiceOrderActions'], 0);
Ext.cmd.derive('Sdc.shortcuts.mixin.AbstractServiceOrderShortcuts', Ext.Base, {serviceOrderShortcuts:[{'name':'Edit', 'functionName':'editServiceOrder', 'validateFn':function(record) {
  return true;
}, 'shortcutFn':function(store, record, callbackFn, callbackParams) {
  var me = this;
  me.editServiceOrder(record, callbackFn, callbackParams);
}}], serviceOrderShortcutsFn:function(functionName, store, record, callbackFn, callbackParams) {
  var me = this;
  var shortcut = Ext.Array.findBy(me.serviceOrderShortcuts, function(shortcut) {
    return shortcut.functionName == functionName;
  }, me);
  if (shortcut && shortcut.shortcutFn && record) {
    Ext.callback(shortcut.shortcutFn, me, [store, record, callbackFn, callbackParams]);
  }
}, getServiceOrderShortcuts:function(record) {
  var me = this;
  var shortcuts = [];
  for (var i = 0; i < me.serviceOrderShortcuts.length; i++) {
    var shortcut = me.serviceOrderShortcuts[i];
    if (shortcut.validateFn && shortcut.validateFn(record)) {
      shortcuts.push({'name':shortcut['name'], 'functionName':shortcut['functionName']});
    }
  }
  return shortcuts;
}}, 0, 0, 0, 0, 0, [[Sdc.data.mixin.ServiceOrderActions.prototype.mixinId || Sdc.data.mixin.ServiceOrderActions.$className, Sdc.data.mixin.ServiceOrderActions]], [Sdc.shortcuts.mixin, 'AbstractServiceOrderShortcuts'], 0);
Ext.cmd.derive('Sdc.data.mixin.AvailabilityActions', Ext.Base, {constructor:function() {
  var me = this;
}, editAvailability:function(availability, refreshCallBack, refreshParams) {
  if (!availability) {
    return false;
  }
  if (!availability.get('RecordID')) {
    return false;
  }
  var params = {RecordID:availability.get('RecordID')};
  Sdc.util.PopUpManager.openPageUrl('employeeScheduler', params, null, refreshCallBack, refreshParams);
  return true;
}}, 1, 0, 0, 0, 0, 0, [Sdc.data.mixin, 'AvailabilityActions'], 0);
Ext.cmd.derive('Sdc.shortcuts.mixin.AbstractAvailabilityShortcuts', Ext.Base, {availabilityShortcuts:[{'name':'Edit', 'functionName':'editAvailability', 'validateFn':function(record) {
  return true;
}, 'shortcutFn':function(store, record, callbackFn, callbackParams) {
  var me = this;
  me.editAvailability(record, callbackFn, callbackParams);
}}], availabilityShortcutsFn:function(functionName, store, record, callbackFn, callbackParams) {
  var me = this;
  var shortcut = Ext.Array.findBy(me.availabilityShortcuts, function(shortcut) {
    return shortcut.functionName == functionName;
  }, me);
  if (shortcut && shortcut.shortcutFn && record) {
    Ext.callback(shortcut.shortcutFn, me, [store, record, callbackFn, callbackParams]);
  }
}, getAvailabilityShortcuts:function(record) {
  var me = this;
  var shortcuts = [];
  for (var i = 0; i < me.availabilityShortcuts.length; i++) {
    var shortcut = me.availabilityShortcuts[i];
    if (shortcut.validateFn && shortcut.validateFn(record)) {
      shortcuts.push({'name':shortcut['name'], 'functionName':shortcut['functionName']});
    }
  }
  return shortcuts;
}}, 0, 0, 0, 0, 0, [[Sdc.data.mixin.AvailabilityActions.prototype.mixinId || Sdc.data.mixin.AvailabilityActions.$className, Sdc.data.mixin.AvailabilityActions]], [Sdc.shortcuts.mixin, 'AbstractAvailabilityShortcuts'], 0);
Ext.cmd.derive('Sdc.shortcut.SchedulerShortcuts', Ext.Base, {alternateClassName:'Sdc.SchedulerShortcuts', singleton:true, enableSchedulerShortcuts:true, enableFlagAppointmentShortcuts:true, enableFlagServiceOrderShortcuts:true, enableFlagAvailabilityShortcuts:true, mainContainer:null, serviceOrderList:null, scheduler:null, panel:null, constructor:function(cfg) {
  var me = this;
  Ext.apply(me, cfg || {});
  me.callParent(arguments);
}, initComponent:function(cfg) {
  var me = this;
  Ext.apply(me, cfg);
  me.initShortcuts();
}, initShortcuts:function() {
  var me = this;
  var mapKeys = {e:'edit', d:'delete'};
  me.keymap = new Ext.util.KeyMap({target:document});
  Ext.iterate(mapKeys, function(key, functionName) {
    me.keymap.addBinding({key:key, scope:me, fn:function() {
      var processFlag = false;
      if (me.enableSchedulerShortcuts) {
        if (me.enableFlagAppointmentShortcuts) {
          processFlag = me.appointmentProcessShortcut(functionName);
        }
        if (me.enableFlagServiceOrderShortcuts && !processFlag) {
          processFlag = me.serviceOrderProcessShortcut(functionName);
        }
        if (me.enableFlagAvailabilityShortcuts && !processFlag) {
          processFlag = me.availabilityProcessShortcut(functionName);
        }
      }
    }});
  }, me);
}, appointmentProcessShortcut:function(functionName) {
  var me = this;
  if (me.getAppointmentSelected() || me.scheduler != null && me.scheduler.focusAppointment != null || me.calendar != null && me.calendar.focusAppointment != null) {
    var refreshConfig = me.getAppointmentRefreshConfig();
    var appointment = null;
    if (me.scheduler != null) {
      appointment = me.scheduler.focusAppointment != null ? me.scheduler.focusAppointment : me.getAppointmentSelected();
      me.scheduler.focusAppointment = null;
    }
    if (me.calendar != null) {
      appointment = me.calendar.focusAppointment != null ? me.calendar.focusAppointment : me.getAppointmentSelected();
      me.calendar.focusAppointment = null;
    }
    Ext.callback(me.appointmentShortcutsFn, me, [functionName + 'Appointment', me.getAppointmentStore(), appointment, refreshConfig['refreshCallback'], refreshConfig['refreshParams']]);
    return true;
  } else {
    return false;
  }
}, serviceOrderProcessShortcut:function(functionName) {
  var me = this;
  if (me.getServiceOrderSelected()) {
    var refreshConfig = me.getServiceOrderRefreshConfig();
    Ext.callback(me.serviceOrderShortcutsFn, me, [functionName + 'ServiceOrder', me.getServiceOrderStore(), me.getServiceOrderSelected(), refreshConfig['refreshCallback'], refreshConfig['refreshParams']]);
    return true;
  } else {
    return false;
  }
}, availabilityProcessShortcut:function(functionName) {
  var me = this;
  if (me.getAppointmentSelected()) {
    var refreshConfig = me.getAppointmentRefreshConfig();
    Ext.callback(me.availabilityShortcutsFn, me, [functionName + 'Availability', me.getAppointmentStore(), me.getAppointmentSelected(), refreshConfig['refreshCallback'], refreshConfig['refreshParams']]);
    return true;
  } else {
    return false;
  }
}, enableShortcuts:function(silent) {
  var me = this;
  me.enableSchedulerShortcuts = true;
  if (silent !== true) {
    me.fireEvent('enable', me);
  }
}, disableShortcuts:function(silent) {
  var me = this;
  me.enableSchedulerShortcuts = false;
  if (silent !== true) {
    me.fireEvent('disable', me);
  }
}, disableAppointmentShortcuts:function() {
  var me = this;
  me.enableFlagAppointmentShortcuts = false;
}, disableServiceOrderShortcuts:function() {
  var me = this;
  me.enableFlagServiceOrderShortcuts = false;
}, disableAvailabilityShortcuts:function() {
  var me = this;
  me.enableFlagAvailabilityShortcuts = false;
}, enableAppointmentShortcuts:function() {
  var me = this;
  me.enableFlagAppointmentShortcuts = false;
}, enableServiceOrderShortcuts:function() {
  var me = this;
  me.enableFlagServiceOrderShortcuts = false;
}, enableAvailabilityShortcuts:function() {
  var me = this;
  me.enableFlagAvailabilityShortcuts = true;
}, setServiceOrderList:function(serviceOrder) {
  var me = this;
  if (serviceOrder) {
    me.serviceOrderList = serviceOrder;
  }
}, setScheduler:function(scheduler) {
  var me = this;
  if (scheduler) {
    me.scheduler = scheduler;
  }
}, getServiceOrderList:function() {
  var me = this;
  return me.serviceOrderList;
}, getScheduler:function() {
  var me = this;
  return me.scheduler;
}, getAppointmentSelected:function() {
  var me = this;
  if (!me.scheduler || !me.scheduler.getEventSelectionModel) {
    return null;
  }
  return me.scheduler.getEventSelectionModel().getSelection()[0];
}, getServiceOrderSelected:function() {
  var me = this;
  if (!me.serviceOrderList || !me.serviceOrderList.getSelectionModel) {
    return null;
  }
  var serviceOrder = me.serviceOrderList.getSelectionModel().getSelection()[0];
  if (serviceOrder && serviceOrder.get('leaf')) {
    return serviceOrder.parentNode;
  } else {
    return serviceOrder;
  }
}, getServiceOrderStore:function() {
  var me = this;
  if (!me.serviceOrderList || !me.serviceOrderList.getStore) {
    return null;
  }
  return me.serviceOrderList.getStore();
}, getAppointmentStore:function() {
  var me = this;
  if (!me.scheduler || !me.scheduler.getEventStore) {
    return null;
  }
  return me.scheduler.getEventStore();
}, getAppointmentRefreshConfig:function() {
  var me = this;
  var values = {refreshCallback:null, refreshParams:null};
  if (!me.scheduler || !me.scheduler.mainContainer.reloadCalendar) {
    return values;
  }
  var refreshParams = {context:me.scheduler.mainContainer, appointment:true};
  var callback = me.scheduler.mainContainer.reloadCalendar;
  if (callback) {
    values['refreshCallback'] = callback;
    values['refreshParams'] = refreshParams;
  }
  return values;
}, getServiceOrderRefreshConfig:function() {
  var me = this;
  var values = {refreshCallback:null, refreshParams:null};
  if (!me.scheduler || me.scheduler.reloadCalendar) {
    return values;
  }
  var refreshParams = {context:me.scheduler.mainContainer, serviceOrder:true};
  var callback = me.scheduler.mainContainer.reloadCalendar;
  if (callback) {
    values['refreshCallback'] = callback;
    values['refreshParams'] = refreshParams;
  }
  return values;
}}, 1, ['schedulershortcuts'], ['schedulershortcuts'], {'schedulershortcuts':true}, ['widget.schedulershortcuts'], [[Sdc.shortcuts.mixin.AbstractAppointmentShortcuts.prototype.mixinId || Sdc.shortcuts.mixin.AbstractAppointmentShortcuts.$className, Sdc.shortcuts.mixin.AbstractAppointmentShortcuts], [Sdc.shortcuts.mixin.AbstractServiceOrderShortcuts.prototype.mixinId || Sdc.shortcuts.mixin.AbstractServiceOrderShortcuts.$className, Sdc.shortcuts.mixin.AbstractServiceOrderShortcuts], [Sdc.shortcuts.mixin.AbstractAvailabilityShortcuts.prototype.mixinId || 
Sdc.shortcuts.mixin.AbstractAvailabilityShortcuts.$className, Sdc.shortcuts.mixin.AbstractAvailabilityShortcuts]], [Sdc.shortcut, 'SchedulerShortcuts', Sdc, 'SchedulerShortcuts'], 0);
Ext.cmd.derive('Sdc.view.MainContainer', Ext.Panel, {initComponent:function() {
  var me = this;
  var config = {};
  me.loadMask = new Ext.LoadMask({msg:Sdc.locale.Messages.LOADING_TEXT, target:this});
  Ext.apply(me, config);
  Ext.panel.Panel.prototype.initComponent.apply(this, arguments);
  Sdc.message.Notification.init();
  Sdc.shortcut.SchedulerShortcuts.initComponent({enableSchedulerShortcuts:true, mainContainer:me, serviceOrderList:Ext.getCmp(ID.serviceOrderGrid), scheduler:Ext.getCmp(ID.employeesScheduler) ? Ext.getCmp(ID.employeesScheduler) : Ext.getCmp(ID.employeesCalendar)});
}, showAppointmentToast:function(appointmentRow, EmployeeRow) {
  if (!appointmentRow) {
    return;
  }
  var me = this;
  var message = '', tpl = '';
  if (appointmentRow && !EmployeeRow) {
    tpl = Sdc.locale.Messages.INFO_PREFIX_APPOINTMENT_CREATION + ' \x3ca href\x3d"#" class\x3d"appointment-link-toast"\x3e{0} - {1}\x3c/a\x3e ' + Sdc.locale.Messages.INFO_SUFFIX_APPOINTMENT_CREATION;
  }
  if (appointmentRow && EmployeeRow) {
    tpl = Sdc.locale.Messages.INFO_PREFIX_APPOINTMENT_ASSIGN + ' \x3ca href\x3d"#" class\x3d"appointment-link-toast"\x3e{0} - {1}\x3c/a\x3e ' + Sdc.locale.Messages.INFO_SUFFIX_APPOINTMENT_ASSIGN;
  }
  if (appointmentRow && tpl) {
    message = Ext.String.format(tpl, appointmentRow.get('SrvOrdType'), appointmentRow.get('RefNbr'));
  }
  var toast = Ext.create('Ext.window.Toast', {layout:'fit', align:'t', hideDuration:200, autoCloseDelay:5000, paddingY:4, currentAppointment:appointmentRow, items:[{xtype:'component', html:message, listeners:{click:{element:'el', fn:function(record, event, eOpts) {
    if (record.target.className == 'appointment-link-toast') {
      var refreshCallBack = me.reloadCalendar;
      var refreshParams = {context:me, appointment:true, unassignedAppointment:true};
      var params = {SrvOrdType:toast.currentAppointment.get('SrvOrdType'), RefNbr:toast.currentAppointment.get('RefNbr')};
      Sdc.util.PopUpManager.openPageUrl('appointment', params, null, refreshCallBack, refreshParams);
    }
  }}}}]});
  toast.show();
}}, 0, 0, ['component', 'box', 'container', 'panel'], {'component':true, 'box':true, 'container':true, 'panel':true}, 0, 0, [Sdc.view, 'MainContainer'], 0);
Ext.cmd.derive('Sdc.locale.Messages', Ext.Base, {singleton:true, constructor:function() {
  var me = this;
  for (var key in __localeStrings) {
    this[key] = __localeStrings[key];
  }
  me.callParent(arguments);
  Ext.override(Ext.grid.header.Container, {sortAscText:me.COLUMNGRID_SORT_ASC_TEXT, sortDescText:me.COLUMNGRID_SORT_DESC_TEXT, columnsText:me.COLUMNGRID_COLUMNS_TEXT});
  Ext.override(Ext.PagingToolbar, {beforePageText:me.PAGINGTOOLBAR_BEFORE_PAGE_TEXT, afterPageText:me.PAGINGTOOLBAR_AFTER_PAGE_TEXT, firstText:me.PAGINGTOOLBAR_FIRST_TEXT, prevText:me.PAGINGTOOLBAR_PREV_TEXT, nextText:me.PAGINGTOOLBAR_NEXT_TEXT, lastText:me.PAGINGTOOLBAR_LAST_TEXT, refreshText:me.PAGINGTOOLBAR_REFRESH_TEXT, displayMsg:me.PAGINGTOOLBAR_DISPLAY_MSG, emptyMsg:me.PAGINGTOOLBAR_EMPTY_MSG});
  Ext.override(Ext.picker.Date, {todayText:me.DATEPICKER_TODAY_TEXT, nextText:me.DATEPICKER_NEXT_TEXT, prevText:me.DATEPICKER_PREV_TEXT, monthYearText:me.DATEPICKER_MONTH_YEAR_TEXT, todayTip:me.DATEPICKER_TODAY_TIP});
  Ext.override(Ext.picker.Month, {okText:'\x26#160;' + me.DATEPICKER_OK_TEXT + '\x26#160;', cancelText:me.DATEPICKER_CANCEL_TEXT});
  Ext.override(Ext.window.Window, {closeToolText:me.TOOLTIP_CLOSE_TOOL_TEXT});
  Ext.override(Ext.view.AbstractView, {loadingText:me.LOADING_TEXT});
  Ext.apply(Ext.form.field.ComboBox.prototype.defaultListConfig, {loadingText:me.LOADING_TEXT});
  Ext.override(Ext.panel.Panel, {collapseToolText:me.PANEL_COLLAPSE_TOOL_TEXT, expandToolText:me.PANEL_EXPAND_TOOL_TEXT});
  var dayNames = [me.Sunday, me.Monday, me.Tuesday, me.Wednesday, me.Thursday, me.Friday, me.Saturday];
  Ext.Date.dayNames = dayNames;
  var abbr_dayNames = [me.abbr_Sunday, me.abbr_Monday, me.abbr_Tuesday, me.abbr_Wednesday, me.abbr_Thursday, me.abbr_Friday, me.abbr_Saturday];
  Ext.Date.abbr_dayNames = abbr_dayNames;
  var monthNames = [me.January, me.February, me.March, me.April, me.May, me.June, me.July, me.August, me.September, me.October, me.November, me.December];
  Ext.Date.monthNames = monthNames;
  var abbr_monthNames = [me.abbr_January, me.abbr_February, me.abbr_March, me.abbr_April, me.abbr_May, me.abbr_June, me.abbr_July, me.abbr_August, me.abbr_September, me.abbr_October, me.abbr_November, me.abbr_December];
  Ext.Date.abbr_monthNames = abbr_monthNames;
  Ext.Date.getShortDayName = function(day) {
    return Ext.Date.abbr_dayNames[day];
  };
  Ext.Date.getShortMonthName = function(month) {
    return Ext.Date.abbr_monthNames[month];
  };
}}, 1, 0, 0, 0, 0, 0, [Sdc.locale, 'Messages'], 0);
Ext.cmd.derive('Sdc.util.AbstractColor', Ext.Base, {constructor:function(cfg) {
  var me = this;
  Ext.apply(me, cfg || {});
  me.callParent(arguments);
}, hsvToRgb:function(h, s, v) {
  var me = this;
  if (h instanceof Array) {
    return me.hsvToRgb.call(this, h[0], h[1], h[2]);
  }
  if (h == 360) {
    h = 0;
  }
  var computedR = 0;
  var computedG = 0;
  var computedB = 0;
  var i, f, p, q, t;
  i = Math.floor(h / 60 % 6);
  f = h / 60 - i;
  p = v * (1 - s);
  q = v * (1 - f * s);
  t = v * (1 - (1 - f) * s);
  switch(i) {
    case 0:
      computedR = v, computedG = t, computedB = p;
      break;
    case 1:
      computedR = q, computedG = v, computedB = p;
      break;
    case 2:
      computedR = p, computedG = v, computedB = t;
      break;
    case 3:
      computedR = p, computedG = q, computedB = v;
      break;
    case 4:
      computedR = t, computedG = p, computedB = v;
      break;
    case 5:
      computedR = v, computedG = p, computedB = q;
      break;
  }
  return [me.realToDec(computedR), me.realToDec(computedG), me.realToDec(computedB)];
}, realToDec:function(n) {
  return Math.round(n * 255);
}, invert:function(r, g, b) {
  if (r instanceof Array) {
    return this.invert.call(this, r[0], r[1], r[2]);
  }
  return [255 - r, 255 - g, 255 - b];
}, hexToRgb:function(hex) {
  var me = this;
  var r, g, b;
  r = parseInt(me.cutHex(hex).substring(0, 2), 16);
  g = parseInt(me.cutHex(hex).substring(2, 4), 16);
  b = parseInt(me.cutHex(hex).substring(4, 6), 16);
  return [r, g, b];
}, cutHex:function(hex) {
  return hex.charAt(0) == '#' ? hex.substring(1, 7) : hex;
}, rgbToHex:function(r, g, b) {
  var me = this;
  if (r instanceof Array) {
    return me.rgbToHex.call(me, r[0], r[1], r[2]);
  }
  return me.toHex(r) + me.toHex(g) + me.toHex(b);
}, toHex:function(n) {
  n = parseInt(n, 10);
  if (isNaN(n)) {
    return '00';
  }
  n = Math.max(0, Math.min(n, 255));
  return '0123456789ABCDEF'.charAt((n - n % 16) / 16) + '0123456789ABCDEF'.charAt(n % 16);
}, rgbToHsv:function(r, g, b) {
  if (r instanceof Array) {
    return this.rgbToHsv.call(this, r[0], r[1], r[2]);
  }
  var me = this;
  var computedH = 0;
  var computedS = 0;
  var computedV = 0;
  var r = parseInt(('' + r).replace(/\s/g, ''), 10);
  var g = parseInt(('' + g).replace(/\s/g, ''), 10);
  var b = parseInt(('' + b).replace(/\s/g, ''), 10);
  if (!me.isValidRgbColor(r, g, b)) {
    return;
  }
  r = r / 255;
  g = g / 255;
  b = b / 255;
  var minRGB = Math.min(r, Math.min(g, b));
  var maxRGB = Math.max(r, Math.max(g, b));
  if (minRGB == maxRGB) {
    computedV = minRGB;
    return [0, 0, computedV];
  }
  var d = r == minRGB ? g - b : b == minRGB ? r - g : b - r;
  var h = r == minRGB ? 3 : b == minRGB ? 1 : 5;
  computedH = 60 * (h - d / (maxRGB - minRGB));
  computedS = (maxRGB - minRGB) / maxRGB;
  computedV = maxRGB;
  return [computedH, computedS, computedV];
}, isValidRgbColor:function(r, g, b) {
  var me = this;
  if (r instanceof Array) {
    return me.isValidRgbColor.call(this, r[0], r[1], r[2]);
  }
  var r = parseInt(('' + r).replace(/\s/g, ''), 10);
  var g = parseInt(('' + g).replace(/\s/g, ''), 10);
  var b = parseInt(('' + b).replace(/\s/g, ''), 10);
  if (r == null || g == null || b == null || isNaN(r) || isNaN(g) || isNaN(b)) {
    return false;
  }
  if (r < 0 || g < 0 || b < 0 || r > 255 || g > 255 || b > 255) {
    return false;
  }
  return true;
}, isValidHsvComponent:function(h, s, v) {
  var me = this;
  if (h instanceof Array) {
    return me.isValidHsvComponent.call(this, h[0], s[1], v[2]);
  }
  var h = parseFloat(('' + h).replace(/\s/g, ''));
  var s = parseFloat(('' + s).replace(/\s/g, ''));
  var v = parseFloat(('' + v).replace(/\s/g, ''));
  if (h == null || s == null || v == null || isNaN(h) || isNaN(s) || isNaN(v)) {
    return false;
  }
  if (h < 0 || s < 0 || v < 0 || h > 360 || s > 1 || v > 1) {
    return false;
  }
  return true;
}}, 1, 0, 0, 0, 0, 0, [Sdc.util, 'AbstractColor'], 0);
Ext.cmd.derive('Sdc.locale.SchedulerSetup', Ext.Base, {singleton:true, baseUrl:null, appResizePrecision:30, dfltBranchID:null, dfltBranchLocationID:null, dfltSrvOrdType:null, askForSrvOrdTypeInCalendars:null, dfltCalendarStartTime:null, calendarFieldPreferences:null, calendarStatusPreferences:null, showServiceOrderDaysGap:null, dfltCalendarViewMode:'vertical', dfltTimeRange:'day', dfltDayResolution:16, dfltWeekResolution:12, dfltMonthResolution:10, dfltCalendarStartTime:null, dfltCalendarEndTime:null, 
constructor:function(cfg) {
  var me = this;
  Ext.apply(me, cfg || {});
  me.callParent(arguments);
}, loadCalendarPreferences:function() {
  var me = this;
  Ext.Ajax.request({url:Sdc.locale.Url.getUrlPath('getCalendarFieldPreferences', {isActive:true}), async:false, headers:{'Content-type':'application/json; charset\x3dutf-8'}, success:function(response, opts) {
    var jsonResponse = Ext.decode(response.responseText);
    me.calendarFieldPreferences = null;
    if (jsonResponse && jsonResponse.Result && jsonResponse.Result.Rows) {
      me.calendarFieldPreferences = jsonResponse.Result.Rows;
    }
  }, failure:function(response, opts) {
    console.log('server-side failure with status code ' + response.status);
  }});
  Ext.Ajax.request({url:Sdc.locale.Url.getUrlPath('getCalendarStatusPreferences'), async:false, headers:{'Content-type':'application/json; charset\x3dutf-8'}, success:function(response, opts) {
    var jsonResponse = Ext.decode(response.responseText);
    me.calendarStatusPreferences = null;
    if (jsonResponse && jsonResponse.Result && jsonResponse.Result.Rows) {
      me.calendarStatusPreferences = jsonResponse.Result.Rows;
    }
  }, failure:function(response, opts) {
    console.log('server-side failure with status code ' + response.status);
  }});
}, loadSetupConfiguration:function() {
  var me = this;
  Ext.Ajax.request({url:Sdc.locale.Url.getUrlPath('getSetup', null), async:false, headers:{'Content-type':'application/json; charset\x3dutf-8'}, success:function(response, opts) {
    var jsonResponse = Ext.decode(response.responseText), setup = null, userPreferences = null;
    if (jsonResponse && jsonResponse.Result && jsonResponse.Result.Rows[0]) {
      setup = jsonResponse.Result.Rows[0];
      if (jsonResponse.Result.Rows[1]) {
        userPreferences = jsonResponse.Result.Rows[1];
      }
    }
    if (setup) {
      var appointment = setup.CustomAppointmentName, employee = setup.CustomEmployeeName, branchLocation = setup.CustomBranchLocationName;
      me.updateCustomNames(appointment, employee, branchLocation);
      if (setup.AppResizePrecision > 0) {
        Sdc.locale.SchedulerSetup.appResizePrecision = setup.AppResizePrecision;
      }
      if (userPreferences) {
        Sdc.locale.SchedulerSetup.dfltBranchLocationID = userPreferences.DfltBranchLocationID;
        Sdc.locale.SchedulerSetup.dfltSrvOrdType = userPreferences.DfltSrvOrdType ? userPreferences.DfltSrvOrdType : setup.DfltSrvOrdType;
        Sdc.locale.SchedulerSetup.askForSrvOrdTypeInCalendars = userPreferences.AskForSrvOrdTypeInCalendars;
      }
      if (setup.DfltCalendarViewMode) {
        Sdc.locale.SchedulerSetup.dfltCalendarViewMode = setup.DfltCalendarViewMode == 'HO' ? 'horizontal' : 'vertical';
      }
      if (setup.TimeRange) {
        Sdc.locale.SchedulerSetup.dfltTimeRange = setup.TimeRange;
      }
      if (setup.DayResolution) {
        Sdc.locale.SchedulerSetup.dfltDayResolution = setup.DayResolution;
      }
      if (setup.WeekResolution) {
        Sdc.locale.SchedulerSetup.dfltWeekResolution = setup.WeekResolution;
      }
      if (setup.MonthResolution) {
        Sdc.locale.SchedulerSetup.dfltMonthResolution = setup.MonthResolution;
      }
      if (setup.CustomDfltCalendarStartTime) {
        Sdc.locale.SchedulerSetup.dfltCalendarStartTime = setup.CustomDfltCalendarStartTime;
      }
      if (setup.CustomDfltCalendarEndTime) {
        Sdc.locale.SchedulerSetup.dfltCalendarEndTime = setup.CustomDfltCalendarEndTime;
      }
      if (setup.TimeFilter) {
        Sdc.locale.SchedulerSetup.dfltTimeFilter = setup.TimeFilter;
      }
      Sdc.locale.SchedulerSetup.dfltBranchID = setup.DfltBranchID;
      Sdc.locale.SchedulerSetup.dfltCalendarStartTime = setup.CustomDfltCalendarStartTime;
      Sdc.locale.SchedulerSetup.showServiceOrderDaysGap = setup.ShowServiceOrderDaysGap;
    } else {
      Ext.MessageBox.show({title:Sdc.locale.Messages.ALERT, msg:Sdc.locale.Messages.ALERT_SETUP_NOT_DEFINED, minWidth:500, icon:Ext.MessageBox.WARNING, buttons:Ext.Msg.YES});
    }
  }, failure:function(response, opts) {
    console.log('server-side failure with status code ' + response.status);
  }});
}, getColorsFromPreferences:function(status) {
  var me = this;
  for (i = 0; i < me.calendarStatusPreferences.length; i++) {
    if (status == me.calendarStatusPreferences[i].FieldName.toLowerCase()) {
      break;
    }
  }
  var colors = [];
  colors.push(me.hexToRgb(me.calendarStatusPreferences[i].BackgroundColor.substring(1, 7)));
  colors.push(me.hexToRgb(me.calendarStatusPreferences[i].TextColor.substring(1, 7)));
  return colors;
}, getCalendarStatusColor:function(status) {
  var me = this;
  var color;
  var textColor;
  var i;
  var style;
  var colors = me.getColorsFromPreferences(status);
  var a = colors[0];
  var b = colors[1];
  var style = 'background: rgba({0}, {1}, {2}, 0.75) !important;background-color: rgba({0}, {1}, {2}, 0.75) !important;border-top-color : #ffffff;border-bottom-color : #ffffff;border-left-color : #ffffff !important;border-right-color : #ffffff !important;color: rgba({3}, {4}, {5}, 1) !important;';
  return Ext.String.format(style, a[0], a[1], a[2], b[0], b[1], b[2]);
}, updateCustomNames:function(appointmentText, employeeText, branchLocationText) {
  var me = this;
  var appointment = 'Appointment';
  var employee = 'Staff';
  var branchLocation = 'Branch Location';
  var maxLength = 20;
  if (appointmentText && appointmentText != '') {
    me.replaceCustomName(appointmentText, appointment, Sdc.locale.Messages);
  }
  if (employeeText && employeeText != '') {
    me.replaceCustomName(employeeText, employee, Sdc.locale.Messages);
  }
  if (branchLocationText && branchLocationText != '') {
    me.replaceCustomName(branchLocationText, branchLocation, Sdc.locale.Messages);
  }
}, replaceCustomName:function(newValue, oldValue, object) {
  var me = this;
  for (var key in object) {
    var value = object[key];
    if (typeof value == 'string') {
      object[key] = value.replace(oldValue, newValue);
    }
  }
  if (me.title) {
    me.title = me.title.replace(oldValue, newValue);
  }
}}, 1, 0, 0, 0, 0, [['abstractColor', Sdc.util.AbstractColor]], [Sdc.locale, 'SchedulerSetup'], 0);
Ext.cmd.derive('Sdc.controller.PresetController', Ext.Base, {singleton:true, alternateClassName:['Sdc.PresetController'], defaultPresets:{fsHDay:{timeColumnWidth:60, rowHeight:50, resourceColumnWidth:150, displayDateFormat:'G:i', shiftIncrement:1, shiftUnit:'DAY', defaultSpan:24, timeResolution:{unit:'HOUR', increment:1}, headerConfig:{middle:{unit:'HOUR', align:'center', dateFormat:'G:i'}, top:{unit:'DAY', align:'center', dateFormat:'D d/m'}}}, fsHWeek:{timeColumnWidth:75, rowHeight:50, resourceColumnWidth:150, 
displayDateFormat:'Y-m-d', shiftUnit:'DAY', shiftIncrement:1, defaultSpan:10, timeResolution:{unit:'HOUR', increment:1}, headerConfig:{middle:{unit:'DAY', align:'center', increment:1, dateFormat:'Y F d'}, top:{unit:'WEEK', align:'center', dateFormat:'D d M'}}}, fsHMonth:{timeColumnWidth:20, rowHeight:50, resourceColumnWidth:150, displayDateFormat:'Y-m-d', shiftUnit:'DAY', shiftIncrement:1, defaultSpan:1, timeResolution:{unit:'HOUR', increment:1}, headerConfig:{top:{unit:'WEEK', align:'center', dateFormat:'D d M Y'}, 
middle:{unit:'DAY', align:'center', increment:1, renderer:function(start) {
  return Ext.Date.dayNames[start.getDay()].substring(0, 1);
}}}}, fsVDay:{timeColumnWidth:60, rowHeight:50, resourceColumnWidth:150, displayDateFormat:'G:i', shiftIncrement:1, shiftUnit:'DAY', defaultSpan:24, timeResolution:{unit:'MINUTE', increment:30}, headerConfig:{middle:{unit:'HOUR', align:'center', dateFormat:'G:i'}, top:{unit:'DAY', align:'center', dateFormat:'D d/m'}}}, fsVWeek:{timeColumnWidth:100, rowHeight:50, resourceColumnWidth:150, displayDateFormat:'Y-m-d G:i', shiftUnit:'DAY', shiftIncrement:1, defaultSpan:5, timeResolution:{unit:'HOUR', increment:1}, 
headerConfig:{middle:{unit:'DAY', align:'center', dateFormat:'D d M'}, top:{unit:'WEEK', align:'center', dateFormat:'D d M'}}}, fsVMonth:{timeColumnWidth:80, rowHeight:50, resourceColumnWidth:150, displayDateFormat:'Y-m-d G:i', shiftUnit:'DAY', shiftIncrement:1, defaultSpan:5, timeResolution:{unit:'HOUR', increment:1}, headerConfig:{middle:{unit:'DAY', align:'center', dateFormat:'D d M'}, top:{unit:'WEEK', align:'center', dateFormat:'D d M'}}}}, presetButton:null, scheduledMode:null, constructor:function(cfg) {
  var me = this;
  Ext.apply(me, cfg || {});
  me.callParent(arguments);
  this.registerDefaults();
  this.presetButton = Ext.create('Ext.button.Button', {text:Sdc.locale.Messages.DAY, itemId:'presets', menu:{items:[{text:Sdc.locale.Messages.DAY, itemId:'D', maxZoomLevel:19, minZoomLevel:14, dfltResolution:Sdc.locale.SchedulerSetup.dfltDayResolution}, {text:Sdc.locale.Messages.WEEK, itemId:'W', maxZoomLevel:19, minZoomLevel:12, dfltResolution:Sdc.locale.SchedulerSetup.dfltWeekResolution}, {text:Sdc.locale.Messages.MONTH, itemId:'M', maxZoomLevel:19, minZoomLevel:10, dfltResolution:Sdc.locale.SchedulerSetup.dfltMonthResolution}]}, 
  getPresetItem:function(itemId) {
    var result = null;
    return this.menu.items.items.find(function(item) {
      return item.itemId === itemId;
    });
  }, updateResolution:function(dayResolution, weekResolution, monthResolution) {
    var items = this.menu.items.items;
    for (var i$44 = 0; i$44 < items.length; i$44++) {
      switch(items[i$44].itemId) {
        case 'M':
          items[i$44].dfltResolution = monthResolution;
          break;
        case 'W':
          items[i$44].dfltResolution = weekResolution;
          break;
        default:
          items[i$44].dfltResolution = dayResolution;
      }
    }
  }});
}, registerDefaults:function() {
  var pm = Sch.preset.Manager, vp = this.defaultPresets;
  for (var p in vp) {
    pm.registerPreset(p, vp[p]);
  }
}, getPresetIDByName:function(name) {
  var id = '';
  var prefix = 'fs' + (this.scheduledMode == 'vertical' ? 'V' : 'H');
  switch(name) {
    case 'M':
      id = prefix + 'Month';
      break;
    case 'W':
      id = prefix + 'Week';
      break;
    default:
      id = prefix + 'Day';
  }
  return id;
}, updatePreset:function(preset) {
  var name = '';
  switch(preset) {
    case 'M':
      name = Sdc.locale.Messages.MONTH;
      break;
    case 'W':
      name = Sdc.locale.Messages.WEEK;
      break;
    default:
      name = Sdc.locale.Messages.DAY;
  }
  this.presetButton.setText(name);
}, setScheduledMode:function(mode) {
  if ((mode == 'vertical' || mode == 'horizontal') && mode != this.scheduledMode) {
    this.scheduledMode = mode;
  }
}}, 1, 0, 0, 0, 0, 0, [Sdc.controller, 'PresetController', Sdc, 'PresetController'], 0);
Ext.cmd.derive('Sdc.model.Branch', Ext.data.Model, {fields:[{name:'BranchID', type:'int', allowNull:true}, {name:'BranchCD', type:'string'}, {name:'Name', type:'string'}, {name:'Deleted', type:'boolean'}, {name:'Display', type:'string', convert:function(value, record) {
  if (record.get('BranchCD') && record.get('Name')) {
    return record.get('BranchCD').replace(/\s+/g, '') + ' - ' + record.get('Name');
  }
  if (!record.get('Name')) {
    return record.get('BranchCD').replace(/\s+/g, '');
  }
  return record.get('Name');
}}]}, 0, 0, 0, 0, 0, 0, [Sdc.model, 'Branch'], 0);
Ext.cmd.derive('Sdc.data.BranchStore', Ext.data.Store, {model:'Sdc.model.Branch', start:0, pageSize:10, includeValueAll:false, proxy:{url:pageUrl + '/GetBranches', type:'ajax', headers:{'Content-type':'application/json; charset\x3dutf-8'}, reader:{type:'json', rootProperty:'Result.Rows', metaProperty:'MetaData', totalProperty:'Result.TotalRows', successProperty:'Success', messageProperty:'Message'}, writer:{type:'json', rootProperty:'branch', encode:false}}, listeners:{load:function(store, records, 
success, eOpts) {
  var me = this;
  if (me.includeValueAll && store.find('BranchID', -1) == -1) {
    store.insert(0, {BranchCD:Sdc.locale.Messages.ALL, BranchID:-1});
  }
}}}, 0, 0, 0, 0, 0, 0, [Sdc.data, 'BranchStore'], 0);
Ext.cmd.derive('Sdc.model.BranchLocation', Ext.data.Model, {fields:[{name:'BranchLocationID', type:'int', allowNull:true}, {name:'BranchLocationCD', type:'string'}, {name:'Descr', type:'string'}, {name:'Display', type:'string', convert:function(value, record) {
  if (record.get('BranchLocationCD') && record.get('Descr')) {
    return record.get('BranchLocationCD').replace(/\s+/g, '') + ' - ' + record.get('Descr');
  }
  if (!record.get('Descr')) {
    return record.get('BranchLocationCD').replace(/\s+/g, '');
  }
  return record.get('Descr');
}}]}, 0, 0, 0, 0, 0, 0, [Sdc.model, 'BranchLocation'], 0);
Ext.cmd.derive('Sdc.data.BranchLocationStore', Ext.data.Store, {model:'Sdc.model.BranchLocation', start:0, pageSize:10, includeValueAll:false, proxy:{url:pageUrl + '/GetBranchLocations', type:'ajax', headers:{'Content-type':'application/json; charset\x3dutf-8'}, reader:{type:'json', rootProperty:'Result.Rows', metaProperty:'MetaData', totalProperty:'Result.TotalRows', successProperty:'Success', messageProperty:'Message'}, writer:{type:'json', rootProperty:'branchLocation', encode:false}, afterRequest:function(request, 
success) {
  if (success) {
  }
}}, listeners:{load:function(store, records, success, eOpts) {
  var me = this;
  if (me.includeValueAll && store.find('BranchLocationID', -1) == -1) {
    store.insert(0, {Descr:Sdc.locale.Messages.ALL, BranchLocationID:-1});
  }
}}}, 0, 0, 0, 0, 0, 0, [Sdc.data, 'BranchLocationStore'], 0);
Ext.cmd.derive('Sdc.controller.BranchController', Ext.Base, {singleton:true, alternateClassName:['Sdc.BranchController'], storeFilterByBranchID:[], ignoreBranchLocationCombobox:false, dfltBranchID:null, dfltBranchLocationID:null, branchCombobox:null, branchLocationCombobox:null, constructor:function(cfg) {
  var me = this;
  Ext.apply(me, cfg || {});
  me.callParent(arguments);
  me.initBranchCombobox();
  me.initBranchLocationCombobox();
}, initComponent:function() {
  var me = this;
  var config = {};
  Ext.apply(me, config);
  me.callParent(arguments);
  me.initBranchCombobox();
  me.initBranchLocationCombobox();
}, initBranchCombobox:function() {
  var me = this;
  if (me.branchCombobox == null) {
    var branchStore = Ext.create('Sdc.data.BranchStore', {includeValueAll:true});
    me.branchCombobox = Ext.create('Ext.form.ComboBox', {valueField:'BranchID', displayField:'Display', queryMode:'remote', queryParam:'filter', store:branchStore, width:120, matchFieldWidth:false, forceSelection:true, allowBlank:false, pageSize:10, editable:false, typeAhead:false, ignoreLoad:true, listConfig:{emptyText:Sdc.locale.Messages.BRANCH_NOT_FOUND, minWidth:null}, listeners:{'change':function(object, newValue, oldValue) {
      if (newValue) {
        me.clearAllStoreComboBox();
        if (me.ignoreBranchLocationCombobox) {
          me.branchCombobox.ignoreLoad ? me.branchCombobox.ignoreLoad = false : me.loadStoresByBranch();
        } else {
          var brachLocationCombobox = me.getBranchLocationCombobox();
          brachLocationCombobox.setDisabled(true);
          brachLocationCombobox.setValue('');
          brachLocationCombobox.store.removeAll();
          brachLocationCombobox.store.getProxy().extraParams.branchID = newValue;
          brachLocationCombobox.store.loadPage(1);
          brachLocationCombobox.setDisabled(false);
        }
      }
    }}});
  }
}, initBranchLocationCombobox:function() {
  var me = this;
  if (me.branchLocationCombobox == null) {
    var branchLocationStore = Ext.create('Sdc.data.BranchLocationStore', {includeValueAll:true});
    me.branchLocationCombobox = Ext.create('Ext.form.ComboBox', {valueField:'BranchLocationID', displayField:'Display', queryMode:'remote', queryParam:'filter', width:120, store:branchLocationStore, matchFieldWidth:false, editable:false, forceSelection:true, allowBlank:false, pageSize:10, typeAhead:false, emptyText:Sdc.locale.Messages.EMPTY_BRANCH_LOCATION, ignoreLoad:true, listConfig:{emptyText:Sdc.locale.Messages.BRANCH_LOCATION_NOT_FOUND, minWidth:null}, listeners:{'change':function(combobox, 
    newValue, oldValue) {
      if (newValue) {
        combobox.ignoreLoad ? combobox.ignoreLoad = false : me.loadStoresByBranch();
      }
    }}});
  }
}, loadBranchStores:function(dfltBranchID, dfltBranchLocationID) {
  var me = this;
  if (dfltBranchID) {
    me.setDefaultBranchID(dfltBranchID);
    if (dfltBranchLocationID) {
      me.setDefaultBranchLocationID(dfltBranchLocationID);
    }
  }
  me.branchCombobox.store.load({scope:me, callback:function(records, operation, success) {
    me.branchLocationCombobox.store.getProxy().extraParams.branchID = me.dfltBranchID;
    me.branchLocationCombobox.store.loadPage(1, {scope:me, callback:function(records, operation, success) {
      var index;
      if (me.branchLocationCombobox) {
        if (me.dfltBranchID && records && records.length > 0) {
          index = me.branchLocationCombobox.store.find('BranchLocationID', me.dfltBranchLocationID);
          me.dfltBranchID = null;
        }
        index = index && index != -1 ? index : 0;
        if (me.branchLocationCombobox.store.getCount() > 0) {
          me.branchLocationCombobox.setValue(me.branchLocationCombobox.store.getAt(index).get('BranchLocationID'));
        }
      }
    }});
  }});
  me.branchCombobox.suspendEvents(true);
  me.branchCombobox.setValue(me.dfltBranchID);
  me.branchCombobox.resumeEvents();
}, clearAllStoreComboBox:function() {
  var me = this;
  if (me.storeFilterByBranchID && me.storeFilterByBranchID.length > 0) {
    me.storeFilterByBranchID.forEach(function(storeObject) {
      if (storeObject.store.getComboBox && storeObject.store.getComboBox() != null) {
        var combo = storeObject.store.getComboBox();
        if (combo.clearValueOnBranchReload == true && combo.clearValue) {
          combo.clearValue();
        }
      }
    });
  }
}, setDefaultBranchID:function(dfltBranchID) {
  var me = this;
  if (dfltBranchID) {
    me.dfltBranchID = dfltBranchID;
  }
}, setDefaultBranchLocationID:function(dfltBranchLocationID) {
  var me = this;
  if (dfltBranchLocationID) {
    me.dfltBranchLocationID = dfltBranchLocationID;
  }
}, getBranchCombobox:function() {
  var me = this;
  if (me.branchCombobox == null) {
    me.initBranchCombobox();
  }
  return me.branchCombobox;
}, getBranchLocationCombobox:function() {
  var me = this;
  if (me.branchLocationCombobox == null) {
    me.initBranchLocationCombobox();
  }
  return me.branchLocationCombobox;
}, registerStore:function(storeID, storeObject) {
  var me = this;
  if (storeObject.getProxy()) {
    storeObject.getProxy().extraParams.branchLocationID = me.getCurrentBranchLocationID();
    storeObject.getProxy().extraParams.branchID = me.getCurrentBranchID();
  }
  me.storeFilterByBranchID.push({storeID:storeID, store:storeObject});
}, loadStoresByBranch:function() {
  var me = this;
  if (me.storeFilterByBranchID && me.storeFilterByBranchID.length > 0) {
    me.storeFilterByBranchID.forEach(function(storeObject) {
      if (me.ignoreBranchLocationCombobox == false) {
        storeObject.store.getProxy().extraParams.branchLocationID = me.getCurrentBranchLocationID();
      }
      storeObject.store.getProxy().extraParams.branchID = me.getCurrentBranchID();
      if (storeObject.storeID == 'serviceOrder' || storeObject.storeID == 'routeStore') {
        storeObject.store.load();
      } else {
        storeObject.store.suspendAutoSync();
        if (storeObject.store && storeObject.store.getCount() > 0) {
          storeObject.store.removeAll();
        }
        storeObject.store.resumeAutoSync();
        storeObject.store.loadDate ? storeObject.store.loadDate() : storeObject.store.load();
      }
    });
  }
}, getCurrentBranchLocationID:function() {
  var me = this;
  var value = me.branchLocationCombobox.getValue();
  if (value == null) {
    return me.dfltBranchLocationID;
  }
  if (value != -1) {
    return value;
  }
  return 'null';
}, getCurrentBranchID:function() {
  var me = this;
  var value = me.branchCombobox.getValue();
  if (value == null) {
    return me.dfltBranchID;
  }
  if (value != -1) {
    return value;
  }
  return 'null';
}}, 1, 0, 0, 0, 0, 0, [Sdc.controller, 'BranchController', Sdc, 'BranchController'], 0);
Ext.cmd.derive('Sdc.data.SupervisorStore', Sch.data.ResourceStore, {model:'Sdc.model.Employee', remoteFilter:true, start:0, pageSize:10, proxy:{url:pageUrl + '/GetEmployees', type:'ajax', headers:{'Content-type':'application/json; charset\x3dutf-8'}, reader:{type:'json', rootProperty:'Result.Rows', metaProperty:'MetaData', totalProperty:'Result.TotalRows', successProperty:'Success', messageProperty:'Message'}, writer:{type:'json'}, extraParams:{branchID:'null', branchLocationID:'null', ignoreActiveFlag:true, 
ignoreAvailabilityFlag:true, scheduledStartDate:'null', scheduledEndDate:'null', loadVendor:false}, simpleSortMode:true}}, 0, 0, 0, 0, 0, 0, [Sdc.data, 'SupervisorStore'], 0);
Ext.cmd.derive('Sdc.form.FormFilterEmployee', Ext.form.Panel, {store:null, openFlag:false, initComponent:function() {
  var me = this;
  var filterReportsTo = null;
  filterReportsTo = Ext.create('Ext.form.ComboBox', {id:ID.employeeFilterCombo, fieldLabel:FieldsLabel.reportsTo, valueField:'EmployeeID', displayField:'Display', queryMode:'remote', queryParam:'filter', store:Ext.create('Sdc.data.SupervisorStore'), margin:'0 0 10 5', labelWidth:120, width:350, matchFieldWidth:false, typeAhead:false, pageSize:10, emptyText:Sdc.locale.Messages.EMPTY_EMPLOYEE, listConfig:{loadingText:Sdc.locale.Messages.LOADING_TEXT, emptyText:Sdc.locale.Messages.EMPLOYEE_NOT_FOUND, 
  minWidth:null}, listeners:{'beforequery':function(queryEvent) {
    var filter = [];
    var values = [];
    values.push(queryEvent.query);
    filter.push({property:'DisplayName', value:values});
    queryEvent.query = Ext.encode(filter);
  }}});
  Sdc.BranchController.registerStore('supervisor', filterReportsTo.store);
  var config = {margin:'10 10 10 10', items:[filterReportsTo, {xtype:'tabpanel', activeTab:0, border:true, items:[{title:Sdc.locale.Messages.TITLE_SKILLS, width:460, height:245, items:[{xtype:'checkboxgroup', id:ID.employeeSkillsCheckboxGroup, columns:[215, 215], height:235, width:450, scrollable:true, form:me, renderFlag:false, listeners:{beforerender:function() {
    var me = this, i = 0, store = me.form.store, filters = store.getFilters(), rawValues = [], values = [];
    if (!me.renderFlag) {
      me.renderFlag = true;
    }
    rawValues = filters.getByKey('Skill') ? filters.getByKey('Skill').getValue() : [];
    rawValues.forEach(function(element, index, array) {
      values[element] = true;
    });
    Ext.Ajax.request({url:pageUrl + '/GetSkills', headers:{'Content-type':'application/json; charset\x3dutf-8'}, success:function(response, opts) {
      var response = Ext.decode(response.responseText);
      var jsonResponse = response.Result.Rows;
      var i_max = jsonResponse.length;
      var displayName = '';
      for (i = 0; i < i_max; i++) {
        displayName = jsonResponse[i].Descr ? jsonResponse[i].Descr : jsonResponse[i].SkillCD;
        me.add([{boxLabel:Ext.util.Format.ellipsis(displayName, 27), name:jsonResponse[i].SkillID}]);
        displayName = '';
      }
      values.length > 0 && me.setValue(values);
    }, failure:function(response, opts) {
      console.log('server-side failure with status code ' + response.status);
    }});
  }}}]}, {title:Sdc.locale.Messages.TITLE_LICENSESTYPE, width:460, height:245, items:[{xtype:'checkboxgroup', id:ID.employeeLicensesCheckboxGroup, columns:[215, 215], height:235, width:450, scrollable:true, form:me, renderFlag:false, listeners:{beforerender:function() {
    var me = this, i = 0, store = me.form.store, filters = store.getFilters(), rawValues = [], values = [];
    if (!me.renderFlag) {
      me.renderFlag = true;
    }
    rawValues = filters.getByKey('LicenseType') ? filters.getByKey('LicenseType').getValue() : [];
    rawValues.forEach(function(element, index, array) {
      values[element] = true;
    });
    Ext.Ajax.request({url:pageUrl + '/GetLicenseTypes', headers:{'Content-type':'application/json; charset\x3dutf-8'}, success:function(response, opts) {
      var response = Ext.decode(response.responseText);
      var jsonResponse = response.Result.Rows;
      var i_max = jsonResponse.length;
      var displayName = '';
      for (i = 0; i < i_max; i++) {
        displayName = jsonResponse[i].Descr ? jsonResponse[i].Descr : jsonResponse[i].LicenseTypeCD;
        me.add([{boxLabel:Ext.util.Format.ellipsis(displayName, 27), name:jsonResponse[i].LicenseTypeID}]);
        displayName = '';
      }
      values.length > 0 && me.setValue(values);
    }, failure:function(response, opts) {
      console.log('server-side failure with status code ' + response.status);
    }});
  }}}]}, {title:Sdc.locale.Messages.TITLE_SERVICES, width:460, height:245, items:[{xtype:'checkboxgroup', id:ID.employeeServicesCheckboxGroup, columns:[215, 215], height:235, width:450, scrollable:true, form:me, renderFlag:false, listeners:{beforerender:function() {
    var me = this, i = 0, store = me.form.store, filters = store.getFilters(), rawValues = [], values = [];
    if (!me.renderFlag) {
      me.renderFlag = true;
    }
    rawValues = filters.getByKey('Service') ? filters.getByKey('Service').getValue() : [];
    rawValues.forEach(function(element, index, array) {
      values[element] = true;
    });
    Ext.Ajax.request({url:pageUrl + '/GetServices', headers:{'Content-type':'application/json; charset\x3dutf-8'}, success:function(response, opts) {
      var response = Ext.decode(response.responseText);
      var jsonResponse = response.Result.Rows;
      var i_max = jsonResponse.length;
      var displayName = '';
      for (i = 0; i < i_max; i++) {
        displayName = jsonResponse[i].Descr ? jsonResponse[i].Descr : jsonResponse[i].InventoryCD;
        me.add([{boxLabel:Ext.util.Format.ellipsis(displayName, 27), name:jsonResponse[i].InventoryID}]);
        displayName = '';
      }
      values.length > 0 && me.setValue(values);
    }, failure:function(response, opts) {
      console.log('server-side failure with status code ' + response.status);
    }});
  }}}]}, {title:Sdc.locale.Messages.TITLE_GEOZONES, width:460, height:245, items:[{xtype:'checkboxgroup', id:ID.employeeGeoZonesCheckboxGroup, columns:[215, 215], height:235, width:450, scrollable:true, form:me, renderFlag:false, listeners:{beforerender:function() {
    var me = this, i = 0;
    if (!me.renderFlag) {
      me.renderFlag = true;
    }
    Ext.Ajax.request({url:pageUrl + '/GetGeoZones', headers:{'Content-type':'application/json; charset\x3dutf-8'}, success:function(response, opts) {
      var response = Ext.decode(response.responseText);
      var jsonResponse = response.Result.Rows;
      var i_max = jsonResponse.length;
      var displayName = '';
      for (i = 0; i < i_max; i++) {
        displayName = jsonResponse[i].Descr ? jsonResponse[i].Descr : jsonResponse[i].GeoZoneCD;
        me.add([{boxLabel:Ext.util.Format.ellipsis(displayName, 27), name:jsonResponse[i].GeoZoneID}]);
        displayName = '';
      }
    }, failure:function(response, opts) {
      console.log('server-side failure with status code ' + response.status);
    }});
  }}}], bbar:['-\x3e', {xtype:'label', dock:'bottom', text:Sdc.locale.Messages.NOTE_GEOZONE_FILTER}]}]}], applyFilters:function() {
    var store = me.store;
    if (store != null) {
      var filters = [], reportsToID = null, reportsTo = [], employeeName = null, employeeNameValue = [], form = me.getForm();
      var likeText = me.externalNameSearch != null ? me.externalNameSearch.getRawValue() : '', reportsToID = form.findField(ID.employeeFilterCombo).getValue(), skills = Object.keys(form.findField(ID.employeeSkillsCheckboxGroup).getValue()), licenses = Object.keys(form.findField(ID.employeeLicensesCheckboxGroup).getValue()), geoZones = Object.keys(form.findField(ID.employeeGeoZonesCheckboxGroup).getValue()), services = Object.keys(form.findField(ID.employeeServicesCheckboxGroup).getValue());
      if (reportsToID) {
        reportsTo.push(reportsToID);
        filters.push({property:'ReportsTo', value:reportsTo});
      }
      var filtersRawValues = store.getFilters();
      if (!form.findField(ID.employeeServicesCheckboxGroup).renderFlag) {
        services = filtersRawValues.getByKey('Service') ? filtersRawValues.getByKey('Service').getValue() : services;
      }
      if (!form.findField(ID.employeeSkillsCheckboxGroup).renderFlag) {
        skills = filtersRawValues.getByKey('Skill') ? filtersRawValues.getByKey('Skill').getValue() : skills;
      }
      if (!form.findField(ID.employeeLicensesCheckboxGroup).renderFlag) {
        licenses = filtersRawValues.getByKey('LicenseType') ? filtersRawValues.getByKey('LicenseType').getValue() : licenses;
      }
      if (!form.findField(ID.employeeGeoZonesCheckboxGroup).renderFlag) {
        geoZones = filtersRawValues.getByKey('GeoZone') ? filtersRawValues.getByKey('GeoZone').getValue() : geoZones;
      }
      store.remoteFilter = false;
      store.clearFilter();
      store.remoteFilter = true;
      likeText != '' && filters.push({property:'DisplayName', value:[likeText]});
      skills.length > 0 && filters.push({property:'Skill', value:skills});
      licenses.length > 0 && filters.push({property:'LicenseType', value:licenses});
      geoZones.length > 0 && filters.push({property:'GeoZone', value:geoZones});
      services.length > 0 && filters.push({property:'Service', value:services});
      if (filters.length > 0) {
        store.filter(filters);
      } else {
        store.clearFilter(true);
        store.load();
      }
    }
  }, resetFilters:function() {
    var store = me.store;
    if (store != null) {
      var form = me.getForm();
      form.findField(ID.employeeSkillsCheckboxGroup).reset();
      form.findField(ID.employeeLicensesCheckboxGroup).reset();
      form.findField(ID.employeeGeoZonesCheckboxGroup).reset();
      form.findField(ID.employeeServicesCheckboxGroup).reset();
      form.findField(ID.employeeFilterCombo).reset();
      me.externalNameSearch != null && me.externalNameSearch.setValue('');
      store.getFilters().getCount() > 0 && store.clearFilter();
    }
  }, getServicesCheckBoxGroup:function() {
    var form = me.getForm();
    return form.findField(ID.employeeServicesCheckboxGroup);
  }};
  Ext.apply(me, config);
  Ext.form.Panel.prototype.initComponent.apply(this, arguments);
  filterReportsTo.store.load();
}}, 0, ['FormFilterEmployee'], ['component', 'box', 'container', 'panel', 'form', 'FormFilterEmployee'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'FormFilterEmployee':true}, ['widget.FormFilterEmployee'], 0, [Sdc.form, 'FormFilterEmployee'], 0);
Ext.cmd.derive('Sdc.window.WindowFilterEmployee', Ext.window.Window, {initComponent:function() {
  var me = this;
  var store = me.store;
  formFilter = null;
  var formFilter = Ext.create('Sdc.form.FormFilterEmployee', {scheduler:me.scheduler, store:store, employeeStore:me.employeeStore, externalNameSearch:me.externalNameSearch});
  var config = {title:Sdc.locale.Messages.TITLE_STAFF_FILTERS, id:ID.employeeFormFilter, closeAction:'hide', margin:'10 10 10 10', modal:true, height:450, width:480, resizable:false, layout:'fit', form:formFilter, items:formFilter, buttons:[{id:ID.employeeFilterButton, text:Sdc.locale.Messages.BUTTON_FILTER, window:me, handler:function() {
    var me = this;
    me.window.form.applyFilters();
  }}, {id:ID.employeeFilterCloseButton, text:Sdc.locale.Messages.BUTTON_FILTER_CLOSE, window:me, handler:function() {
    var me = this;
    me.window.form.applyFilters();
    me.window.hide();
  }}, {id:ID.employeeCloseButton, text:Sdc.locale.Messages.BUTTON_CLOSE, window:me, handler:function() {
    var me = this;
    me.window.hide();
  }}]};
  Ext.apply(me, config);
  Ext.window.Window.prototype.initComponent.apply(this, arguments);
}, setExternalSearch:function(externalSearch) {
  var me = this;
  if (externalSearch) {
    me.form.externalNameSearch = externalSearch;
    return true;
  } else {
    return false;
  }
}}, 0, ['windowfilterserviceorder'], ['component', 'box', 'container', 'panel', 'window', 'windowfilterserviceorder'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'windowfilterserviceorder':true}, ['widget.windowfilterserviceorder'], 0, [Sdc.window, 'WindowFilterEmployee'], 0);
Ext.cmd.derive('MultiEmpDispatch.view.main.Main', Sdc.view.MainContainer, {controller:'main', id:ID.mainContainer, layout:'border', width:$('#scheduler-container').width(), height:$(window).height() - 40, startDate:null, endDate:null, appointmentStore:null, serviceOrderStore:null, availabilityStore:null, dayRuleStore:null, employeeStore:null, unassignedAppointmentStore:null, initComponent:function() {
  var me = this;
  var branchCombobox = Sdc.controller.BranchController.getBranchCombobox();
  var branchLocationCombobox = Sdc.controller.BranchController.getBranchLocationCombobox();
  var calendarDateField = Ext.create('Sdc.form.field.FSDateField', {currentStartDate:me.startDate, currentEndDate:me.endDate, selectedPreset:Sdc.locale.SchedulerSetup.dfltTimeRange});
  Sdc.controller.PresetController.updatePreset(Sdc.locale.SchedulerSetup.dfltTimeRange);
  Sdc.controller.PresetController.setScheduledMode(Sdc.locale.SchedulerSetup.dfltCalendarViewMode);
  Sdc.controller.PresetController.presetButton.updateResolution(Sdc.locale.SchedulerSetup.dfltDayResolution, Sdc.locale.SchedulerSetup.dfltWeekResolution, Sdc.locale.SchedulerSetup.dfltMonthResolution);
  me.employeeStore = Ext.create('MultiEmpDispatch.store.EmployeeStore');
  me.appointmentStore = Ext.create('MultiEmpDispatch.store.AppointmentStore');
  me.serviceOrderStore = Ext.create('MultiEmpDispatch.store.ServiceOrderStore', {});
  me.availabilityStore = Ext.create('MultiEmpDispatch.store.AvailabilityStore');
  me.unassignedAppointmentStore = Ext.create('MultiEmpDispatch.store.UnassignedAppointmentStore');
  me.dayRuleStore = Ext.create('MultiEmpDispatch.store.DayRuleStore');
  me.appointmentStore.getProxy().extraParams.scheduledStartDate = Ext.encode(calendarDateField.getStartDate());
  me.appointmentStore.getProxy().extraParams.scheduledEndDate = Ext.encode(calendarDateField.getEndDate());
  me.dayRuleStore.getProxy().extraParams.scheduledStartDate = Ext.encode(calendarDateField.getStartDate());
  me.dayRuleStore.getProxy().extraParams.scheduledEndDate = Ext.encode(calendarDateField.getEndDate());
  me.availabilityStore.getProxy().extraParams.scheduledStartDate = Ext.encode(calendarDateField.getStartDate());
  me.availabilityStore.getProxy().extraParams.scheduledEndDate = Ext.encode(calendarDateField.getEndDate());
  me.unassignedAppointmentStore.getProxy().extraParams.scheduledStartDate = Ext.encode(calendarDateField.getStartDate());
  me.unassignedAppointmentStore.getProxy().extraParams.scheduledEndDate = Ext.encode(calendarDateField.getEndDate());
  me.employeeStore.getProxy().extraParams.scheduledStartDate = Ext.encode(calendarDateField.getStartDate());
  me.employeeStore.getProxy().extraParams.scheduledEndDate = Ext.encode(calendarDateField.getEndDate());
  Sdc.controller.BranchController.loadBranchStores(Sdc.locale.SchedulerSetup.dfltBranchID, Sdc.locale.SchedulerSetup.dfltBranchLocationID);
  me.serviceOrderStore.getProxy().extraParams.scheduledStartDate = null;
  me.serviceOrderStore.getProxy().extraParams.scheduledEndDate = null;
  me.unassignedAppointmentStore.mainContainer = me;
  if (Sdc.locale.SchedulerSetup.showServiceOrderDaysGap != null) {
    me.serviceOrderStore.getProxy().extraParams.scheduledStartDate = Ext.encode((new Date(calendarDateField.getStartDate())).addDays(-Sdc.locale.SchedulerSetup.showServiceOrderDaysGap));
    me.serviceOrderStore.getProxy().extraParams.scheduledEndDate = Ext.encode((new Date(calendarDateField.getEndDate())).addDays(Sdc.locale.SchedulerSetup.showServiceOrderDaysGap));
  }
  Sdc.controller.BranchController.registerStore('appointment', me.appointmentStore);
  Sdc.controller.BranchController.registerStore('employee', me.employeeStore);
  Sdc.controller.BranchController.registerStore('serviceOrder', me.serviceOrderStore);
  Sdc.controller.BranchController.registerStore('availability', me.availabilityStore);
  Sdc.controller.BranchController.registerStore('unassignedAppointment', me.unassignedAppointmentStore);
  var windowFormFilter = Ext.create('Sdc.window.WindowFilterEmployee', {store:me.employeeStore});
  var loadEmployeeFunction = function(store, records, success, eOpts) {
    var employeeIDList = [];
    if (store.getCount() > 0) {
      store.each(function(record) {
        employeeIDList.push(record.get('EmployeeID'));
      }, me);
    }
    me.availabilityStore.getProxy().extraParams.employeeIDList = Ext.encode(employeeIDList);
    me.appointmentStore.getProxy().extraParams.employeeIDList = Ext.encode(employeeIDList);
    me.availabilityStore.load();
    me.appointmentStore.load();
  };
  me.serviceOrderStore.getRoot().expand();
  me.employeeStore.on('load', loadEmployeeFunction, me);
  var config = {items:[{xtype:'tabpanel', itemId:ID.mainTabPanel, region:'west', margin:'10 10 10 10', collapsible:true, header:false, split:true, useArrows:true, collapsed:true, activeTab:ID.unassignedAppointmentGrid, items:[{xtype:'serviceordergrid', mainContainer:me, store:me.serviceOrderStore}, {xtype:'unassignedappointmentgrid', startDate:me.startDate, store:me.unassignedAppointmentStore, mainContainer:me}]}, {xtype:'scheduler', region:'center', mainContainer:me, eventStore:me.appointmentStore, 
  resourceStore:me.employeeStore, resourceZones:me.availabilityStore, dayRuleStore:me.dayRuleStore, serviceOrderStore:me.serviceOrderStore, startDate:calendarDateField.currentStartDate, endDate:calendarDateField.currentEndDate, windowFormFilter:windowFormFilter, branchCombobox:branchCombobox, branchLocationCombobox:branchLocationCombobox, calendarDateField:calendarDateField}]};
  Ext.apply(me, config);
  Sdc.view.MainContainer.prototype.initComponent.apply(this, arguments);
  me.dayRuleStore.load();
  me.filter = null;
  if (RefNbr != '') {
    me.filter = [{property:'RefNbr', value:[RefNbr]}];
  }
  me.unassignedAppointmentStore.load();
  me.employeeStore.load();
}, reloadCalendar:function(refreshParams) {
  if (refreshParams) {
    var me = refreshParams.context;
    if (me.serviceOrderStore && refreshParams.serviceOrder) {
      if (me.filter) {
        me.filter = null;
      } else {
        me.serviceOrderStore.load();
      }
    }
    if (me.appointmentStore && refreshParams.appointment) {
      me.appointmentStore.focusAppointmentID = refreshParams.focusAppointmentID;
      me.appointmentStore.load();
    }
    me.availabilityStore && refreshParams.availability && me.availabilityStore.load();
    me.employeeStore && refreshParams.employee && me.employeeStore.load();
    me.unassignedAppointmentStore && refreshParams.unassignedAppointment && me.unassignedAppointmentStore.load();
  }
}, getMainTabPanel:function() {
  var me = this;
  return me.getComponent(ID.mainTabPanel);
}}, 0, ['appcontainer'], ['component', 'box', 'container', 'panel', 'appcontainer'], {'component':true, 'box':true, 'container':true, 'panel':true, 'appcontainer':true}, ['widget.appcontainer'], 0, [MultiEmpDispatch.view.main, 'Main'], 0);
Ext.cmd.derive('Sdc.controller.SchedulerController', Ext.app.ViewController, {constructor:function(cfg) {
  var me = this;
  Sdc.locale.Url.setBaseUrl(baseUrl);
  Sdc.locale.Url.setWebMethodUrl(pageUrl);
  Ext.apply(me, cfg || {});
  Ext.app.ViewController.prototype.constructor.apply(this, cfg);
  Sdc.locale.SchedulerSetup.title = me.title;
  Sdc.locale.SchedulerSetup.loadSetupConfiguration();
  Sdc.locale.SchedulerSetup.loadCalendarPreferences();
}}, 1, 0, 0, 0, 0, 0, [Sdc.controller, 'SchedulerController'], 0);
Ext.cmd.derive('MultiEmpDispatch.view.main.MainController', Sdc.controller.SchedulerController, {refs:[{ref:'employeeScheduler', selector:'employeescheduler'}], init:function() {
  var me = this;
  me.control({'scheduler schedulergridview':{serviceorderdrop:me.onServiceOrderDrop, unassignedappointmentdrop:me.onUnassignedAppointmentDrop}});
}, onServiceOrderDrop:function(scheduler, schedulerView, droppedServiceOrder, targetResource, date) {
  var startdate = Ext.Date.parse(date.format('dd-mm-yyyy H:MM'), 'd-m-Y G:i'), timeEstimated = droppedServiceOrder.get('EstimatedDurationTotal'), duration = timeEstimated !== 'undefined' && timeEstimated ? timeEstimated : 0, end = Sch.util.Date.add(startdate, Sch.util.Date.MINUTE, duration);
  var values = {SOID:droppedServiceOrder.get('SOID'), SrvOrdType:droppedServiceOrder.get('SrvOrdType'), ScheduledDateTimeBegin:startdate, ScheduledDateTimeEnd:end, EmployeeIDList:targetResource.get('EmployeeID') ? [targetResource.get('EmployeeID')] : [], SODetIDList:droppedServiceOrder.get('SODetID') ? [droppedServiceOrder.get('SODetID')] : []};
  var refreshParams = {context:scheduler.mainContainer, appointment:true, serviceOrder:true};
  var callback = scheduler.mainContainer.reloadCalendar;
  if (droppedServiceOrder.get('SLARemaning') == Sdc.locale.Messages.SERVICEORDER_TIMEEXCEEDED) {
    Ext.MessageBox.show({title:Sdc.locale.Messages.ALERT, msg:Sdc.locale.Messages.ALERT_SLATIME_EXCEEDED, minWidth:500, icon:Ext.MessageBox.WARNING, buttons:Ext.Msg.YES, fn:function(button, text) {
      scheduler.mainContainer.loadMask.show();
      Sdc.util.PopUpManager.newAppointmentBridgeID(values, null, callback, refreshParams);
    }});
  } else {
    scheduler.mainContainer.loadMask.show();
    Sdc.util.PopUpManager.newAppointmentBridgeID(values, null, callback, refreshParams);
  }
}, onUnassignedAppointmentDrop:function(scheduler, schedulerView, droppedAppointment, targetResource, date) {
  scheduler.mainContainer.loadMask.show();
  droppedAppointment.set({EmployeeID:targetResource.get('EmployeeID'), OpenAppointmentScreenOnError:true});
  scheduler.mainContainer.appointmentStore.unassignedAppointment = droppedAppointment.get('AppointmentID');
  scheduler.mainContainer.appointmentStore.targetResource = targetResource;
  var refreshParams = {context:scheduler.mainContainer, appointment:true, unassignedAppointment:true};
  scheduler.mainContainer.reloadCalendar(refreshParams);
}}, 0, 0, 0, 0, ['controller.main'], 0, [MultiEmpDispatch.view.main, 'MainController'], 0);
Ext.cmd.derive('Sdc.view.ScheduleDropZone', Ext.dd.DropZone, {constructor:function() {
  Ext.dd.DropZone.prototype.constructor.apply(this, arguments);
  var schedulerView = this.schedulerView;
  this.proxyTpl = this.proxyTpl || new Ext.XTemplate('\x3cspan class\x3d"sch-dd-newtime"\x3e{[ this.getText(values) ]}\x3c/span\x3e', {getText:function(vals) {
    var retVal = vals.LockFlag ? Ext.Date.format(vals.StartDate, 'Y-m-d H:i') : schedulerView.getFormattedDate(vals.StartDate);
    if (vals.Duration) {
      retVal += ' - ' + schedulerView.getFormattedEndDate(Sch.util.Date.add(vals.StartDate, Sch.util.Date.MILLI, vals.Duration), vals.StartDate);
    }
    return retVal;
  }});
}, validatorFn:Ext.emptyFn, getTargetFromEvent:function(e) {
  return e.getTarget('.' + this.schedulerView.timeCellCls);
}, onNodeEnter:function(target, dragSource, e, data) {
  var s = this.schedulerView;
  s.dragCreator.setDisabled(true);
}, onNodeOut:function(target, dragSource, e, data) {
  var s = this.schedulerView;
  s.dragCreator.setDisabled(false);
}, onNodeOver:function(target, dragSource, e, data) {
  var s = this.schedulerView, date = s.getDateFromDomEvent(e, 'round'), newText;
  if (data.lockFlag && data.dateTimeBegin) {
    date = new Date(data.dateTimeBegin);
  }
  if (!date) {
    return this.dropNotAllowed;
  }
  this.proxyTpl.overwrite(dragSource.proxy.el.down('.sch-dd-proxy-hd'), {StartDate:date, Duration:data.duration, LockFlag:data.lockFlag});
  var targetRecord = s.resolveResource(e.getTarget('.' + s.timeCellCls));
  if (this.validatorFn.call(this.validatorFnScope || this, data.records, targetRecord, date, data.duration, e) !== false) {
    return this.dropAllowed + (this.enableCopy && e.ctrlKey ? ' add' : '');
  } else {
    return this.dropNotAllowed;
  }
}, onNodeDrop:function(target, dragSource, e, data) {
  var s = this.schedulerView, targetRecord = s.resolveResource(target), date = s.getDateFromDomEvent(e, 'round'), valid = false, isCopy = this.enableCopy && e.ctrlKey;
  view.dragCreator.setDisabled(false);
  if (date && this.validatorFn.call(this.validatorFnScope || this, data.records, targetRecord, date, data.duration, e) !== false) {
    var copies, index = s.resourceStore.indexOf(targetRecord);
    if (isCopy) {
      copies = this.copyRecords(data.records, date, targetRecord, data.sourceEventRecord, index);
      valid = true;
    } else {
      valid = this.updateRecords(data.records, date, targetRecord, data.sourceEventRecord, index, data);
    }
    if (valid) {
      s.getSelectionModel().deselectAll();
    }
    s.fireEvent('eventdrop', s, isCopy ? copies : data.records, isCopy);
  }
  s.fireEvent('aftereventdrop', s);
  return valid;
}, updateRecords:function(records, newStartDate, dropResourceRecord, sourceEventRecord, targetIndex, data) {
  if (records.length === 1) {
    sourceEventRecord.beginEdit();
    sourceEventRecord.assign(dropResourceRecord);
    sourceEventRecord.setStartDate(newStartDate);
    sourceEventRecord.setEndDate(Sch.util.Date.add(newStartDate, Sch.util.Date.MILLI, data.duration));
    sourceEventRecord.endEdit();
    return true;
  }
  var sourceEventRecordStart = sourceEventRecord.getStartDate(), resourceStore = this.schedulerView.resourceStore, diffStart = newStartDate - sourceEventRecordStart, sourceIndex = resourceStore.indexOf(sourceEventRecord.getResource()), diff, oldIndex, newResourceRecord, r, newIndex, nbrRecords = resourceStore.getCount(), i;
  for (i = 0; i < records.length; i++) {
    r = records[i];
    oldIndex = resourceStore.indexOf(r.getResource());
    newIndex = oldIndex - sourceIndex + targetIndex;
    if (newIndex < 0 || newIndex > nbrRecords) {
      return false;
    }
  }
  for (i = 0; i < records.length; i++) {
    r = records[i];
    oldIndex = resourceStore.indexOf(r.getResource());
    diff = oldIndex - sourceIndex;
    newResourceRecord = resourceStore.getAt(targetIndex + diff);
    r.beginEdit();
    r.assign(newResourceRecord);
    r.setStartDate(Sch.util.Date.add(r.getStartDate(), Sch.util.Date.MILLI, diffStart));
    r.setEndDate(Sch.util.Date.add(r.getEndDate(), Sch.util.Date.MILLI, diffStart));
    r.endEdit();
  }
  return true;
}, copyRecords:function(records, newStartDate, targetRecord, sourceEventRecord, targetIndex) {
  var record = records[0], newItem = record.copy(), duration = sourceEventRecord.getEndDate() - sourceEventRecord.getStartDate();
  newItem.assign(targetRecord);
  newItem.setStartDate(newStartDate);
  newItem.setEndDate(Sch.util.Date.add(newStartDate, Sch.util.Date.MILLI, duration));
  return [newItem];
}}, 1, 0, 0, 0, 0, 0, [Sdc.view, 'ScheduleDropZone'], 0);
Ext.cmd.derive('MultiEmpDispatch.view.main.ScheduleDropZone', Sdc.view.ScheduleDropZone, {ddGroup:'schedule', validatorFn:function(draggedEventRecords, resource, date, durationMs) {
  return this.isValidDrop(resource, date, durationMs);
}, isValidDrop:function(resource, startDate, durationMs) {
  return resource.isAvailable(startDate, Sch.util.Date.add(startDate, Sch.util.Date.MILLI, durationMs));
}, onNodeDrop:function(target, dragSource, e, data) {
  var me = this;
  var view = me.schedulerView;
  var scheduler = me.scheduler;
  var resource = view.resolveResource(target), date = view.getDateFromDomEvent(e, 'round'), task = data.records[0];
  if (data.records[0].data.leaf) {
    parent = data.records[0].parentNode;
    task.data.SrvOrdType = parent.get('SrvOrdType');
    task.data.RefNbr = parent.get('RefNbr');
    task.data.SOID = parent.get('SOID');
  }
  if (task instanceof Sdc.model.ServiceOrderTreeNode) {
    view.fireEvent('serviceorderdrop', scheduler, view, task, resource, date);
  } else {
    view.fireEvent('unassignedappointmentdrop', scheduler, view, task, resource, date);
  }
}}, 0, 0, 0, 0, 0, 0, [MultiEmpDispatch.view.main, 'ScheduleDropZone'], 0);
Ext.cmd.derive('Sdc.panel.mixin.AbstractAppointmentEvents', Ext.Base, {onEventContextMenu:function(scheduler, eventRecord, event, eOpts) {
  var me = this;
  var menuAppointment = me.menuAppointment;
  var position = event.getXY();
  event.stopEvent();
  menuAppointment.record = eventRecord;
  menuAppointment.showAt(position);
}, onEventDblClick:function(scheduler, eventRecord, e, eOpts) {
  var me = this;
  if (!me.appointmentToolTip) {
    return false;
  }
  me.appointmentToolTip.appointmentRecord = eventRecord;
  me.appointmentToolTip.eventTarget = e.currentTarget instanceof Window ? e.delegatedTarget : e.currentTarget;
  var isCalendarMonthYear = scheduler.eventStore && scheduler.eventStore.calendar && scheduler.eventStore.calendar.getMode && (scheduler.eventStore.calendar.getMode === 'month' || scheduler.eventStore.calendar.getMode === 'year');
  if (isCalendarMonthYear) {
    me.appointmentToolTip.showAt(me.appointmentToolTip.getTargetXY(100, 20));
  } else {
    me.appointmentToolTip.showAt(me.appointmentToolTip.getTargetXY());
  }
  return false;
}, onEventClick:function(scheduler, eventRecord, event, eOpts) {
  var me = this;
  var refreshParams = {context:me.mainContainer, appointment:true, unassignedAppointment:true};
  var refreshCallBack = me.mainContainer.reloadCalendar;
  if (event.target.className == 'x-fa fa-trash') {
    me.deleteAppointment(scheduler.eventStore, eventRecord, refreshCallBack, refreshParams);
  }
  if (event.target.id == ID.serviceOrderRefNbr) {
    var params = {RefNbr:eventRecord.data.SORefNbr, SrvOrdType:eventRecord.data.SrvOrdType};
    Sdc.util.PopUpManager.openPageUrl('serviceOrder', params, null, null, null);
  }
  if (event.target.id == ID.appointmentRefNbr || eventRecord.get('RefNbr') === event.target.innerHTML) {
    var params = {SrvOrdType:eventRecord.get('SrvOrdType'), RefNbr:eventRecord.get('RefNbr')};
    Sdc.util.PopUpManager.openPageUrl('appointment', params, null, refreshCallBack, refreshParams);
  }
}}, 0, 0, 0, 0, 0, [[Sdc.data.mixin.AppointmentActions.prototype.mixinId || Sdc.data.mixin.AppointmentActions.$className, Sdc.data.mixin.AppointmentActions]], [Sdc.panel.mixin, 'AbstractAppointmentEvents'], 0);
Ext.cmd.derive('Sdc.panel.SchedulerGrid', Sch.panel.SchedulerGrid, {initComponent:function() {
  var me = this;
  var config = {};
  Ext.apply(me, config);
  Sch.panel.SchedulerGrid.prototype.initComponent.apply(this, arguments);
}, focusCurrentTime:function() {
  var me = this;
  if (!Sdc.locale.SchedulerSetup.dfltCalendarStartTime) {
    return;
  }
  var startDate = new Date(Sdc.locale.SchedulerSetup.dfltCalendarStartTime);
  var startHour = startDate.getHours(), startMinutes = startDate.getMinutes(), yPosition = 0, intervalTime = 250;
  var currentDate = new Date(me.getStart());
  currentDate.setHours(startHour);
  currentDate.setMinutes(startMinutes);
  yPosition = me.pluginZone.getHeaderElementPosition(currentDate);
  if (yPosition != -1) {
    var checkTimeFunction = setInterval(function() {
      if (yPosition != me.getSchedulingView().getVerticalScroll()) {
        var height = me.getSchedulingView().getHeight();
        me.getSchedulingView().scrollVerticallyTo(yPosition);
        if (yPosition >= Math.floor(me.getSchedulingView().getScroll().top) && yPosition <= Math.ceil(me.getSchedulingView().getScroll().top + height) && me.getSchedulingView().getScroll().top != 0) {
          clearInterval(checkTimeFunction);
        }
      } else {
        clearInterval(checkTimeFunction);
      }
    }, intervalTime);
  }
}}, 0, 0, ['component', 'box', 'container', 'panel', 'tablepanel', 'gridpanel', 'grid', 'timelinegrid', 'schedulergrid', 'schedulerpanel'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'gridpanel':true, 'grid':true, 'timelinegrid':true, 'schedulergrid':true, 'schedulerpanel':true}, 0, [['abstractAppointmentEvents', Sdc.panel.mixin.AbstractAppointmentEvents], ['abstractDecodeMessages', Sdc.data.mixin.AbstractDecodeMessages]], [Sdc.panel, 'SchedulerGrid'], 0);
Ext.cmd.derive('Sdc.form.FormFilterUnassignedAppointment', Ext.form.Panel, {initComponent:function() {
  var me = this;
  var config = {margin:'10 10 10 10', items:[{xtype:'tabpanel', activeTab:0, border:true, items:[{title:Sdc.locale.Messages.TITLE_SKILLS, width:460, height:245, items:[{xtype:'checkboxgroup', id:ID.skillsCheckboxGroupUa, columns:[215, 215], height:235, width:450, scrollable:true, listeners:{beforerender:function() {
    var me = this;
    Ext.Ajax.request({url:pageUrl + '/GetSkills', headers:{'Content-type':'application/json; charset\x3dutf-8'}, success:function(response, opts) {
      var response = Ext.decode(response.responseText);
      var jsonResponse = response.Result.Rows;
      var i_max = jsonResponse.length;
      var i = 0;
      var displayName = '';
      for (i = 0; i < i_max; i++) {
        displayName = jsonResponse[i].Descr ? jsonResponse[i].Descr : jsonResponse[i].SkillCD;
        me.add([{boxLabel:Ext.util.Format.ellipsis(displayName, 27), name:jsonResponse[i].SkillID}]);
      }
    }, failure:function(response, opts) {
      console.log('server-side failure with status code ' + response.status);
    }});
  }}}]}]}], applyFilters:function() {
    var store = me.store;
    if (store != null) {
      store.remoteFilter = false;
      store.clearFilter();
      store.remoteFilter = true;
      var filters = [], form = me.getForm();
      var likeText = me.externalSearch != null ? me.externalSearch.getValue() : '', skills = Object.keys(form.findField(ID.skillsCheckboxGroupUa).getValue());
      likeText != '' && filters.push({property:'LikeText', value:[likeText]});
      skills.length > 0 && filters.push({property:'Skill', value:skills});
      if (filters.length > 0) {
        store.filter(filters);
      } else {
        store.clearFilter(true);
        store.load();
      }
    }
  }, resetFilters:function() {
    var store = me.store;
    if (store != null) {
      var form = me.getForm();
      me.externalSearch != null && me.externalSearch.reset();
      form.findField(ID.skillsCheckboxGroupUa).reset();
      store.getFilters().getCount() > 0 && store.clearFilter();
    }
  }};
  Ext.apply(me, config);
  Ext.form.Panel.prototype.initComponent.apply(this, arguments);
}}, 0, ['FormFilterUnassignedAppointment'], ['component', 'box', 'container', 'panel', 'form', 'FormFilterUnassignedAppointment'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'FormFilterUnassignedAppointment':true}, ['widget.FormFilterUnassignedAppointment'], 0, [Sdc.form, 'FormFilterUnassignedAppointment'], 0);
Ext.cmd.derive('Sdc.window.windowFilterUnassignedAppointment', Ext.window.Window, {initComponent:function() {
  var me = this, uaStore = this.store, externalSearch = this.externalSearch;
  employeeStore = this.employeeStore;
  var formFilter = Ext.create('Sdc.form.FormFilterUnassignedAppointment', {store:uaStore, employeeStore:employeeStore, externalSearch:externalSearch});
  var filterButton = Ext.create('Ext.Button', {id:ID.unassignedAppointmentFilterButton, text:Sdc.locale.Messages.BUTTON_FILTER, window:this, handler:function() {
    this.setDisabled(true);
    formFilter.applyFilters();
  }});
  var externalSearchFunction = function() {
    filterButton.setDisabled(false);
  };
  uaStore.on('load', externalSearchFunction, this);
  var config = {title:Sdc.locale.Messages.TITLE_UNASSIGNED_APPOINTMENT_FILTERS, id:ID.unassignedAppointmentFormFilter, closeAction:'hide', modal:true, height:400, width:430, resizable:false, layout:'fit', form:formFilter, items:formFilter, buttons:[filterButton, {id:ID.unassignedAppointmentFilterCloseButton, text:Sdc.locale.Messages.BUTTON_FILTER_CLOSE, window:this, handler:function() {
    formFilter.applyFilters();
    this.window.hide();
  }}, {id:ID.unassignedAppointmentCloseButton, text:Sdc.locale.Messages.BUTTON_CLOSE, window:this, handler:function() {
    this.window.hide();
  }}]};
  Ext.apply(this, config);
  Ext.window.Window.prototype.initComponent.apply(this, arguments);
}}, 0, ['windowFilterUnassignedAppointment'], ['component', 'box', 'container', 'panel', 'window', 'windowFilterUnassignedAppointment'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'windowFilterUnassignedAppointment':true}, ['widget.windowFilterUnassignedAppointment'], 0, [Sdc.window, 'windowFilterUnassignedAppointment'], 0);
Ext.cmd.derive('Sdc.menu.EmployeeMenu', Ext.menu.Menu, {record:null, scheduler:null, initComponent:function() {
  var me = this;
  var config = {items:[{iconCls:'x-fa fa-user', text:Sdc.locale.Messages.BUTTON_EDIT_APPOINTMENT, scope:me, handler:function() {
    var record = me.record, scheduler = me.scheduler;
    if (record) {
      var params = {bAccountID:record.model ? record.model.get('EmployeeID') : record.get('EmployeeID')};
      Sdc.util.PopUpManager.openPageUrl('employee', params, null, null, null);
    }
  }}, {iconCls:'x-fa fa-calendar', text:Sdc.locale.Messages.TITLE_STAFF_CALENDARS, scope:me, handler:function() {
    var record = me.record, scheduler = me.scheduler;
    if (record) {
      var params = {branchID:scheduler.branchCombobox.getValue(), branchLocationID:scheduler.branchLocationCombobox.getValue(), bAccountID:record.model ? record.model.get('EmployeeID') : record.get('EmployeeID'), Date:Ext.Date.format(scheduler.getStartDate(), 'Y-m-d h:i:s A')};
      Sdc.util.PopUpManager.openPageUrl('singleEmpDispatch', params, null, null, null);
    }
  }}]};
  Ext.apply(me, config);
  if (me.scheduler) {
    Ext.menu.Menu.prototype.initComponent.apply(this, arguments);
  } else {
    throw '[ERROR] Missing Scheduler Panel';
  }
}}, 0, 0, ['component', 'box', 'container', 'panel', 'menu'], {'component':true, 'box':true, 'container':true, 'panel':true, 'menu':true}, 0, 0, [Sdc.menu, 'EmployeeMenu'], 0);
Ext.cmd.derive('Sdc.menu.AppointmentMenu', Ext.menu.Menu, {record:null, scheduler:null, initComponent:function() {
  var me = this;
  var config = {items:[{iconCls:'x-fa fa-pencil', text:Sdc.locale.Messages.BUTTON_EDIT_APPOINTMENT, itemId:ID.editAppointment, scope:me, handler:function() {
    var recordData = me.record ? me.record : null;
    var scheduler = me.scheduler;
    var refreshParams = {context:scheduler.mainContainer, appointment:true};
    var refreshCallBack = scheduler.mainContainer.reloadCalendar;
    me.editAppointment(recordData, refreshCallBack, refreshParams);
  }}, {iconCls:'x-fa fa-files-o', text:Sdc.locale.Messages.BUTTON_CLONE_APPOINTMENT, scope:me, handler:function() {
    var recordData = me.record ? me.record : null;
    var scheduler = me.scheduler;
    var refreshParams = {context:scheduler.mainContainer, appointment:true};
    var refreshCallBack = scheduler.mainContainer.reloadCalendar;
    me.cloneAppointment(recordData, refreshCallBack, refreshParams);
  }}, {iconCls:'x-fa fa-check-square-o', text:Sdc.locale.Messages.BUTTON_VALIDATE_BY_DISPATCH, itemId:ID.validateByDispatch, scope:me, handler:function() {
    var recordData = me.record ? me.record : null;
    var scheduler = me.scheduler;
    var refreshParams = {context:scheduler.mainContainer, appointment:true};
    var refreshCallBack = scheduler.mainContainer.reloadCalendar;
    me.validateAppointment(recordData, refreshCallBack, refreshParams);
  }}, {iconCls:'x-fa fa-square-o', text:Sdc.locale.Messages.BUTTON_CLEAR_VALIDATION, itemId:ID.clearValidation, scope:me, handler:function() {
    var recordData = me.record ? me.record : null;
    var scheduler = me.scheduler;
    var refreshParams = {context:scheduler.mainContainer, appointment:true};
    var refreshCallBack = scheduler.mainContainer.reloadCalendar;
    me.validateAppointment(recordData, refreshCallBack, refreshParams);
  }}, {iconCls:'x-fa fa-calendar-check-o', text:Sdc.locale.Messages.BUTTON_CONFIRM_APPOINTMENT, itemId:ID.confirmAppointment, scope:me, handler:function() {
    var recordData = me.record ? me.record : null;
    var scheduler = me.scheduler;
    var refreshParams = {context:scheduler.mainContainer, appointment:true};
    var refreshCallBack = scheduler.mainContainer.reloadCalendar;
    me.confirmAppointment(recordData, refreshCallBack, refreshParams);
  }}, {iconCls:'x-fa fa-calendar-o', text:Sdc.locale.Messages.BUTTON_UNCONFIRM_APPOINTMENT, itemId:ID.unconfirmAppointment, scope:me, handler:function() {
    var recordData = me.record ? me.record : null;
    var scheduler = me.scheduler;
    var refreshParams = {context:scheduler.mainContainer, appointment:true};
    var refreshCallBack = scheduler.mainContainer.reloadCalendar;
    me.confirmAppointment(recordData, refreshCallBack, refreshParams);
  }}, {iconCls:'x-fa fa-trash', text:Sdc.locale.Messages.BUTTON_DELETE_APPOINTMENT, itemId:ID.deleteAppointment, scope:me, handler:function() {
    var recordData = me.record ? me.record : null;
    var scheduler = me.scheduler;
    var refreshParams = {context:scheduler.mainContainer, appointment:true};
    var refreshCallBack = scheduler.mainContainer.reloadCalendar;
    me.deleteAppointment(scheduler.eventStore, recordData, refreshCallBack, refreshParams);
  }}], listeners:{show:function(menu) {
    var recordData = me.record ? me.record : null;
    var componentValidate = menu.getComponent(ID.validateByDispatch);
    var componentClear = menu.getComponent(ID.clearValidation);
    var componentConfirm = menu.getComponent(ID.confirmAppointment);
    var componentUnconfirm = menu.getComponent(ID.unconfirmAppointment);
    var componentEdit = menu.getComponent(ID.editAppointment);
    if (!recordData) {
      return;
    }
    var recordStatus = recordData.get('Status');
    if (recordStatus == AppointmentStatus.scheduledBySystem || recordStatus == AppointmentStatus.scheduled || recordStatus == AppointmentStatus.completed || recordStatus == AppointmentStatus.inprocess) {
      componentEdit.setText(Sdc.locale.Messages.BUTTON_EDIT_APPOINTMENT);
      if (recordData.get('ValidatedByDispatcher')) {
        componentValidate.hide();
        componentClear.show();
      } else {
        componentValidate.show();
        componentClear.hide();
      }
      if (recordData.get('Confirmed')) {
        componentConfirm.hide();
        componentUnconfirm.show();
      } else {
        componentConfirm.show();
        componentUnconfirm.hide();
      }
    } else {
      if (recordStatus == AppointmentStatus.canceled || recordStatus == AppointmentStatus.closed) {
        if (recordStatus == AppointmentStatus.closed) {
          componentEdit.setText(Sdc.locale.Messages.BUTTON_OPEN_APPOINTMENT);
        } else {
          componentEdit.setText(Sdc.locale.Messages.BUTTON_EDIT_APPOINTMENT);
        }
        componentValidate.hide();
        componentClear.hide();
        componentUnconfirm.hide();
        componentConfirm.hide();
      }
    }
  }}};
  Ext.apply(me, config);
  if (me.scheduler) {
    Ext.menu.Menu.prototype.initComponent.apply(this, arguments);
  } else {
    throw '[ERROR] Missing Scheduler Panel';
  }
  me.mixins.appointmentActions.constructor.call(me, arguments);
}}, 0, 0, ['component', 'box', 'container', 'panel', 'menu'], {'component':true, 'box':true, 'container':true, 'panel':true, 'menu':true}, 0, [['appointmentActions', Sdc.data.mixin.AppointmentActions]], [Sdc.menu, 'AppointmentMenu'], 0);
Ext.cmd.derive('Sdc.model.BusinessDate', Ext.data.Model, {fields:[{name:'Date', type:'date', dateFormat:'m/d/Y g:i A', mapping:'CustomDate', convert:function(value, record) {
  return new Date(value);
}, serialize:function(value, record) {
  return Ext.Date.format(new Date(value), 'Y-m-d g:i:s A');
}}, {name:'Cls', type:'string'}, {name:'Text', type:'string'}]}, 0, 0, 0, 0, 0, 0, [Sdc.model, 'BusinessDate'], 0);
Ext.cmd.derive('Sdc.data.BusinessDateStore', Ext.data.Store, {model:'Sdc.model.BusinessDate', start:0, pageSize:10, proxy:{url:pageUrl + '/GetBusinessDate', type:'ajax', headers:{'Content-type':'application/json; charset\x3dutf-8'}, reader:{type:'json', rootProperty:'Result.Rows', metaProperty:'MetaData', totalProperty:'Result.TotalRows', successProperty:'Success', messageProperty:'Message'}, writer:{type:'json'}}}, 0, 0, 0, 0, 0, 0, [Sdc.data, 'BusinessDateStore'], 0);
Ext.cmd.derive('Sdc.plugin.CurrentBussinessDateTimeLine', Sch.plugin.Lines, {updateInterval:60000, showHeaderElements:true, autoUpdate:true, expandToFitView:true, timer:null, init:function(cmp) {
  if (Ext.getVersion('touch')) {
    this.showHeaderElements = false;
  }
  var store = Ext.create('Sdc.data.BusinessDateStore');
  store.load();
  if (this.autoUpdate) {
    this.timer = setInterval(function() {
      store.load();
    }, this.updateInterval);
  }
  cmp.on('destroy', this.onHostDestroy, this);
  this.store = store;
  Sch.plugin.Lines.prototype.init.apply(this, arguments);
}, onHostDestroy:function() {
  if (this.timer) {
    clearInterval(this.timer);
    this.timer = null;
  }
  if (this.store.autoDestroy) {
    this.store.destroy();
  }
}}, 0, 0, 0, 0, 0, 0, [Sdc.plugin, 'CurrentBussinessDateTimeLine'], 0);
Ext.cmd.derive('Sdc.tip.AppointmentToolTip', Ext.tip.ToolTip, {initComponent:function() {
  var me = this;
  var config = {trackMouse:false, dismissDelay:0, appointmentRecord:null, appointmentTrigger:null, showDelay:500, width:290, maxWidth:500, anchor:'right', constrain:true, constrainPosition:false, toolTipTpl:Ext.XTemplate.from('tooltip-appointment').compile(), renderTo:Ext.getBody(), listeners:{beforeshow:me.updateTipBody}};
  Ext.apply(me, config);
  Ext.tip.ToolTip.prototype.initComponent.apply(this, arguments);
}, getTargetXY:function(width, height) {
  var me = this;
  var coordinate = Ext.fly(me.eventTarget).getXY();
  var eventLeft = coordinate[0], eventTop = coordinate[1], width = width ? width : Ext.fly(me.eventTarget).getWidth(), height = height ? height : Ext.fly(me.eventTarget).getHeight(), BottomLimit = 50, TopLimit = 100, toolTipHeight = me.getHeight(), toolTipWidth = me.getWidth(), windowHeight = $(window).height(), windowWidth = $(window).width(), toolTipLeft, toolTipTop;
  toolTipTop = eventTop - BottomLimit + toolTipHeight > windowHeight ? eventTop - (toolTipHeight - BottomLimit) : eventTop - toolTipHeight / 2;
  toolTipTop = eventTop - toolTipHeight < 0 ? eventTop - TopLimit : toolTipTop;
  toolTipLeft = eventLeft + width + 8 + toolTipWidth > windowWidth ? eventLeft - toolTipWidth - 8 : eventLeft + width + 8;
  coordinate = [toolTipLeft, toolTipTop];
  return coordinate;
}, updateTipBody:function(toolTip) {
  var services = null;
  var values = toolTip.appointmentRecord.data;
  var infoTooltip = null;
  var warningMessages = [];
  var employeeName = toolTip.appointmentRecord.get('EmployeeID') ? toolTip.appointmentRecord.getResource().getName() : null;
  if (values.WarningResourceAvailableFlag) {
    warningMessages.push(Messages.warningResourceAvailable(null));
  }
  if (values.WarningAppointmentValidFlag) {
    warningMessages.push(Messages.warningAppointmentValid(null));
  }
  Ext.Ajax.request({async:false, url:pageUrl + '/GetAppointmentToolTip?appointmentID\x3d' + values['AppointmentID'], headers:{'Content-type':'application/json; charset\x3dutf-8'}, success:function(response, opts) {
    var response = Ext.decode(response.responseText);
    infoTooltip = response.Result.Rows[0];
  }, failure:function(response, opts) {
    console.log('server-side failure with status code ' + response.status);
  }});
  if (infoTooltip) {
    values['SrvOrdTypeDesc'] = infoTooltip.srvOrdType.Descr;
    values['branchLocationDesc'] = infoTooltip.branchLocationDesc;
    values['employees'] = infoTooltip.employees;
    values['resources'] = infoTooltip.resources;
    values['services'] = infoTooltip.services;
    values['serviceOrder'] = infoTooltip.serviceOrder;
    values['warningMessages'] = warningMessages;
    values['Messages'] = Sdc.locale.Messages;
  }
  toolTip.update(this.toolTipTpl.applyTemplate(values));
}}, 0, 0, ['component', 'box', 'container', 'panel', 'tip', 'tooltip'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tip':true, 'tooltip':true}, 0, 0, [Sdc.tip, 'AppointmentToolTip'], 0);
Ext.cmd.derive('Sdc.form.field.FSDateField', Ext.button.Button, {itemId:'dateButton', arrowVisible:false, glyph:'f073@FontAwesome', selectedPreset:null, currentStartDate:null, currentEndDate:null, iconAlign:'right', autoSwitchPreset:true, initComponent:function() {
  var me = this;
  me.addListener('updateschedule');
  if (me.currentStartDate == null) {
    me.currentStartDate = new Date;
  }
  if (me.currentEndDate == null) {
    me.currentEndDate = new Date;
  }
  if (me.selectedPreset == null) {
    me.selectedPreset = 'D';
  }
  var dateMenu = Ext.create('Ext.menu.DatePicker', {currentStartDate:me.currentStartDate, currentEndDate:me.currentEndDate, selectedPreset:me.selectedPreset, handler:function(dp, date) {
    me.updateDate(date);
  }, next:function() {
    this.addValue(1);
  }, previous:function() {
    this.addValue(-1);
  }, shiftDate:function(count, preset) {
    switch(preset) {
      case 'Y':
        this.currentStartDate = new Date(this.currentStartDate.getFullYear() + count, 0, 1);
        this.currentEndDate = new Date(this.currentStartDate.getFullYear(), 11, 31);
        break;
      case 'M':
        this.currentStartDate.addMonths(count).startMonth();
        this.currentEndDate = (new Date(this.currentStartDate)).endMonth();
        break;
      case 'W':
        this.currentStartDate.addWeeks(count).startWeek();
        this.currentEndDate = (new Date(this.currentStartDate)).endWeek();
        break;
      default:
        this.currentStartDate.addDays(count);
        this.currentEndDate = new Date(this.currentStartDate);
    }
  }, addValue:function(count) {
    var presetToUse = this.selectedPreset === 'A' ? me.scheduler.togglePreviewViewMode.toUpperCase()[0] : this.selectedPreset;
    this.shiftDate(count, presetToUse);
    this.currentStartDate.setHours(0, 0, 0, 0);
    this.currentEndDate.setHours(23, 59, 59, 59);
    me.currentStartDate = this.currentStartDate;
    me.currentEndDate = this.currentEndDate;
    me.scheduler && me.fireEvent('updateschedule', me.currentStartDate, me.currentEndDate, count);
    me.refreshDisplayText();
  }});
  var config = {text:Ext.Date.format(me.currentStartDate, 'M j, Y'), menu:dateMenu, updatePreset:function(preset, forceUpdate) {
    forceUpdate = forceUpdate === undefined ? false : forceUpdate;
    var menu = this.down('menu');
    var presetValue = menu.selectedPreset;
    if (menu.selectedPreset != preset || forceUpdate) {
      var startDate = menu.currentStartDate != null ? new Date(menu.currentStartDate) : new Date;
      var endDate = new Date(startDate);
      switch(preset) {
        case 'Y':
          startDate = new Date(startDate.getFullYear(), 0, 1);
          endDate = new Date(startDate.getFullYear(), 11, 31);
          startDate.setHours(0, 0, 0, 0);
          endDate.setHours(23, 59, 59, 59);
          break;
        case 'M':
          startDate = startDate.startMonth();
          endDate = (new Date(startDate)).endMonth();
          startDate.setHours(0, 0, 0, 0);
          endDate.setHours(23, 59, 59, 59);
          break;
        case 'W':
          startDate = startDate.startWeek();
          endDate = (new Date(startDate)).endWeek();
          startDate.setHours(0, 0, 0, 0);
          endDate.setHours(23, 59, 59, 59);
          break;
        default:
          startDate.setHours(0, 0, 0, 0);
          endDate.setHours(23, 59, 59, 59);
      }
      menu.currentStartDate = startDate;
      menu.currentEndDate = endDate;
      menu.selectedPreset = preset;
      me.currentStartDate = startDate;
      me.currentEndDate = endDate;
      me.selectedPreset = preset;
    }
    if (me.autoSwitchPreset) {
      me.scheduler && me.scheduler.switchViewPreset && me.scheduler.switchViewPreset(Sdc.controller.PresetController.getPresetIDByName(this.selectedPreset), menu.currentStartDate, menu.currentEndDate);
    }
    me.scheduler && me.fireEvent('updateschedule', me.currentStartDate, me.currentEndDate);
    this.refreshDisplayText();
  }, updateDate:function(date) {
    var menu = this.down('menu');
    var presetValue = menu.selectedPreset;
    var startDate = new Date(date);
    var endDate = new Date(startDate);
    switch(presetValue) {
      case 'Y':
        startDate = new Date(startDate.getFullYear(), 0, 1);
        endDate = new Date(startDate.getFullYear(), 11, 31);
        startDate.setHours(0, 0, 0, 0);
        endDate.setHours(23, 59, 59, 59);
        presetValue = 'Y';
        break;
      case 'M':
        startDate = startDate.startMonth();
        endDate = (new Date(startDate)).endMonth();
        startDate.setHours(0, 0, 0, 0);
        endDate.setHours(23, 59, 59, 59);
        presetValue = 'M';
        break;
      case 'W':
        startDate = startDate.startWeek();
        endDate = (new Date(startDate)).endWeek();
        startDate.setHours(0, 0, 0, 0);
        endDate.setHours(23, 59, 59, 59);
        presetValue = 'W';
        break;
      default:
        startDate.setHours(0, 0, 0, 0);
        endDate.setHours(23, 59, 59, 59);
        presetValue = 'D';
    }
    if (menu.currentStartDate != startDate || menu.currentEndDate != endDate) {
      menu.currentStartDate = startDate;
      menu.currentEndDate = endDate;
      me.currentStartDate = startDate;
      me.currentEndDate = endDate;
      if (me.scheduler != null) {
        me.fireEvent('updateschedule', me.currentStartDate, me.currentEndDate, 'updDate');
      }
    }
    this.refreshDisplayText();
  }, refreshDisplayText:function() {
    var menu = this.down('menu');
    var displayDate = '';
    switch(menu.selectedPreset) {
      case 'Y':
        displayDate = Ext.Date.format(menu.currentStartDate, 'Y');
        break;
      case 'M':
        displayDate = Ext.Date.format(menu.currentStartDate, 'F Y');
        break;
      case 'W':
        displayDate = Ext.Date.format(menu.currentStartDate, 'M j, Y') + ' - ' + Ext.Date.format(menu.currentEndDate, 'M j, Y');
        break;
      default:
        displayDate = Ext.Date.format(menu.currentStartDate, 'M j, Y');
    }
    this.setText(displayDate);
  }};
  Ext.apply(this, config);
  Ext.button.Button.prototype.initComponent.apply(this, arguments);
  me.updateDate(me.currentStartDate);
}, setStartDate:function(date) {
  var menu = this.down('menu');
  menu.currentStartDate = new Date(date);
  this.currentStartDate = new Date(date);
}, getStartDate:function() {
  return this.currentStartDate;
}, getEndDate:function() {
  return this.currentEndDate;
}}, 0, ['FSDateField'], ['component', 'box', 'button', 'FSDateField'], {'component':true, 'box':true, 'button':true, 'FSDateField':true}, ['widget.FSDateField'], 0, [Sdc.form.field, 'FSDateField'], 0);
Ext.cmd.derive('MultiEmpDispatch.view.main.Scheduler', Sdc.panel.SchedulerGrid, {id:ID.employeesScheduler, itemId:ID.employeesScheduler, title:Sdc.locale.Messages.TITLE_DASHBOARD, width:1000, height:350, border:true, margin:'10 10 10 10', split:false, weekStartDay:0, initComponent:function() {
  var me = this;
  me.branchLocationCombobox.on('change', function() {
    me.focusCurrentTime();
  });
  var availabilityStore = me.resourceZones;
  me.resourceStore.availabilityStore = availabilityStore;
  var calendarDateField = me.calendarDateField;
  calendarDateField.scheduler = me;
  calendarDateField.on('updateschedule', me.updateEvents, me);
  var menuAppointment = Ext.create('Sdc.menu.AppointmentMenu', {record:null, scheduler:me});
  var menuEmployee = Ext.create('Sdc.menu.EmployeeMenu', {record:null, scheduler:me});
  me.eventStore.scheduler = me;
  me.windowFormFilter.scheduler = me;
  me.resourceStore.scheduler = me;
  var filterEmployeeName = Ext.create('Ext.form.field.Text', {id:ID.employeeNameFilterCombo, width:120, enableKeyEvents:true, emptyText:Sdc.locale.Messages.EMPTY_EMPLOYEE_NAME_FILTER, listeners:{'keypress':function(combo, e, eOpts) {
    if (e.type == 'keypress' && e.button == 12) {
      this.windowFormFilter.form.applyFilters();
    }
  }, 'blur':function(combo, records, eOpts) {
    if (records) {
      this.windowFormFilter.form.applyFilters();
    }
  }}});
  me.windowFormFilter.setExternalSearch(filterEmployeeName);
  filterEmployeeName.windowFormFilter = me.windowFormFilter;
  var appointmentToolTip = Ext.create('Sdc.tip.AppointmentToolTip', {});
  var clearFilterButton = Ext.create('Ext.panel.Tool', {glyph:'f12d@FontAwesome', callback:function() {
    me.windowFormFilter.form.resetFilters();
  }});
  var zoomSlider = Ext.create('Ext.slider.Single', {itemId:'zoomSlider', hidden:Sdc.locale.SchedulerSetup.dfltCalendarViewMode == 'horizontal' ? false : true, style:'margin-left:10px', width:100, value:0, increment:1, minValue:0, maxValue:10, refreshZoomLevel:function() {
    this.setMinValue(me.minZoomLevel);
    this.setMaxValue(me.maxZoomLevel);
    this.setValue(me.getCurrentZoomLevelIndex());
  }, listeners:{afterrender:function() {
    var item = Sdc.controller.PresetController.presetButton.getPresetItem(Sdc.locale.SchedulerSetup.dfltTimeRange);
    if (item) {
      me.setMaxZoomLevel(item.maxZoomLevel);
      me.setMinZoomLevel(item.minZoomLevel);
    }
    this.refreshZoomLevel();
    this.setValue(item.dfltResolution);
    this.on('change', me.onZoomSliderChange, me);
  }}});
  me.resourceStore.clearFilterButton = clearFilterButton;
  Sch.preset.Manager.items.forEach(function(item, index) {
    item.rowHeight = 50;
  });
  Ext.apply(me, {viewPreset:Sdc.controller.PresetController.getPresetIDByName(Sdc.locale.SchedulerSetup.dfltTimeRange), mode:Sdc.locale.SchedulerSetup.dfltCalendarViewMode, appointmentToolTip:appointmentToolTip, menuAppointment:menuAppointment, menuEmployee:menuEmployee, zoomSlider:zoomSlider, eventBodyTemplate:Ext.XTemplate.from('bodyTemplate-appointment').compile(), tbar:[{id:ID.newAppointment, text:Sdc.locale.Messages.TITLE_APPOINTMENT, glyph:'f055@FontAwesome', scheduler:me, handler:function() {
    var startdate = Ext.Date.parse(me.calendarDateField.getStartDate().format('dd-mm-yyyy H:MM'), 'd-m-Y G:i');
    var params = {BranchID:me.branchCombobox.getValue(), ScheduledDateTimeBegin:startdate, ScheduledDateTimeEnd:startdate};
    if (me.branchLocationCombobox.getValue() != -1) {
      params['BranchLocationID'] = me.branchLocationCombobox.getValue();
    }
    var refreshParams = {context:me.mainContainer, appointment:true, serviceOrder:true, unassignedAppointment:true};
    var callback = me.mainContainer.reloadCalendar;
    Sdc.util.PopUpManager.newAppointmentBridgeID(params, null, callback, refreshParams);
  }}, {xtype:'tbtext', text:Sdc.locale.Messages.LABEL_BRANCH}, me.branchCombobox, {xtype:'tbtext', text:Sdc.locale.Messages.LABEL_BRANCH_LOCATION}, me.branchLocationCombobox, {xtype:'tbtext', text:Sdc.locale.Messages.TITLE_STAFF}, filterEmployeeName, '-\x3e', Sdc.controller.PresetController.presetButton, {glyph:'f053@FontAwesome', tooltip:Sdc.locale.Messages.BUTTON_PREVIOUS_DAY, handler:function() {
    calendarDateField.menu.previous();
  }}, calendarDateField, {glyph:'f054@FontAwesome', tooltip:Sdc.locale.Messages.BUTTON_NEXT_DAY, handler:function() {
    calendarDateField.menu.next();
  }}], columns:[{header:Sdc.locale.Messages.TITLE_STAFF, width:150, dataIndex:'DisplayName', renderer:function(value, metaData, record, rowIdx, colIdx, store) {
    var toolTipBody = '\x3cdiv\x3e \x3cdiv class\x3d"sch-event-footer x-fa fa-phone" style\x3d"float: left; width: 18px;"\x3e\x3c/div\x3e \x3cspan\x3e' + (record && record.get('Phone1') ? record.get('Phone1') : Sdc.locale.Messages.WARNING_PHONE_NUMBER_MISSING) + '\x3c/span\x3e \x3c/div\x3e';
    var tooltip = Ext.String.htmlEncode(toolTipBody);
    metaData.tdAttr = 'data-qtip\x3d"' + tooltip + '"';
    return value;
  }}], viewConfig:{barMargin:1, stripeRows:false}, listeners:{scope:me, viewready:function() {
    me.onZoomSliderChange(me.zoomSlider, me.zoomSlider.getValue());
    me.down('#timeFilter').selectFilter(Sdc.locale.SchedulerSetup.dfltTimeFilter);
    me.down('#timeFilter').refreshFilterOptions();
  }, modechange:function(scheduler, modeCfg, eOpts) {
    if (me.getMode() == 'vertical') {
      me.down('#zoomInButton').hide(false);
      me.down('#zoomOutButton').hide(false);
      me.down('#zoomSlider').hide(false);
    } else {
      me.down('#zoomInButton').show(false);
      me.down('#zoomOutButton').show(false);
      me.down('#zoomSlider').show(false);
    }
    if (Sdc.locale.SchedulerSetup.appResizePrecision) {
      me.getSchedulingView().setTimeResolution(Sch.util.Date.MINUTE, Sdc.locale.SchedulerSetup.appResizePrecision);
    }
  }, viewchange:function(timelinePanel, eOpts) {
    if (Sdc.locale.SchedulerSetup.appResizePrecision) {
      me.getSchedulingView().setTimeResolution(Sch.util.Date.MINUTE, Sdc.locale.SchedulerSetup.appResizePrecision);
    }
  }, beforeeventadd:me.onDragCreate, eventcontextmenu:me.onEventContextMenu, eventdblclick:me.onEventDblClick, eventclick:me.onEventClick, zoomchange:function(timelinePanel, level, eOpts) {
    me.zoomSlider.setValue(level);
    me.setTimeSpan(me.calendarDateField.getStartDate(), me.calendarDateField.getEndDate());
    me.down('#timeFilter').refreshFilterOptions();
    if (Sdc.locale.SchedulerSetup.appResizePrecision) {
      me.getSchedulingView().setTimeResolution(Sch.util.Date.MINUTE, Sdc.locale.SchedulerSetup.appResizePrecision);
    }
  }, cellcontextmenu:function(view, cell, cellIndex, record, row, rowIndex, event) {
    var column = view.getHeaderByCell(cell);
    var position = view.getPositionByEvent(event);
    var dataIndex = column.dataIndex;
    if (me.getMode() == 'horizontal' && dataIndex == 'DisplayName') {
      var position = event.getXY();
      event.stopEvent();
      me.menuEmployee.record = record;
      me.menuEmployee.showAt(position);
    }
  }}, plugins:[me.currentTimeLinePlugin = Ext.create('Sdc.plugin.CurrentBussinessDateTimeLine', {updateInterval:30000}), me.pluginZone = Ext.create('Sch.plugin.Zones', {showHeaderElements:true, store:me.dayRuleStore})], tools:[{glyph:'f0b0@FontAwesome', callback:function() {
    me.windowFormFilter.show();
  }}, clearFilterButton], dockedItems:[{xtype:'pagingtoolbar', store:me.resourceStore, dock:'bottom', displayInfo:false, scheduler:me, items:['-\x3e', {xtype:'FSTimeFilter', scheduler:me}, {xtype:'button', hidden:Sdc.locale.SchedulerSetup.dfltCalendarViewMode == 'horizontal' ? false : true, itemId:'zoomOutButton', iconCls:'x-fa fa-minus', style:'margin-right: 5px', handler:function() {
    var currentFilter = me.down('#timeFilter').getCurrentFilter();
    me.down('#timeFilter').selectFilter('CF');
    zoomSlider.setValue(zoomSlider.getValue() - 1);
    me.down('#timeFilter').selectFilter(currentFilter);
  }}, zoomSlider, {xtype:'button', hidden:Sdc.locale.SchedulerSetup.dfltCalendarViewMode == 'horizontal' ? false : true, itemId:'zoomInButton', iconCls:'x-fa fa-plus', style:'margin-right: 5px', handler:function() {
    var currentFilter = me.down('#timeFilter').getCurrentFilter();
    me.down('#timeFilter').selectFilter('CF');
    zoomSlider.setValue(zoomSlider.getValue() + 1);
    me.down('#timeFilter').selectFilter(currentFilter);
  }}, {xtype:'button', iconCls:'x-fa fa-list', cls:'margin-right: 5px ' + (Sdc.locale.SchedulerSetup.dfltCalendarViewMode == 'horizontal' ? 'fa-rotate-90' : ''), handler:function() {
    var currentFilter = me.down('#timeFilter').getCurrentFilter();
    me.down('#timeFilter').selectFilter('CF');
    if (me.getMode() == 'vertical') {
      me.setMode('horizontal');
      Sdc.controller.PresetController.setScheduledMode('horizontal');
      calendarDateField.updatePreset(calendarDateField.selectedPreset);
      this.addCls('fa-rotate-90');
    } else {
      me.setMode('vertical');
      Sdc.controller.PresetController.setScheduledMode('vertical');
      calendarDateField.updatePreset(calendarDateField.selectedPreset);
      this.removeCls('fa-rotate-90');
    }
    me.down('#timeFilter').selectFilter(currentFilter);
    me.down('#timeFilter').refreshFilterOptions();
  }}], beforechange:function(pagingToolar, page, eOpts) {
    var refreshParams = {context:pagingToolar.scheduler.mainContainer, appointment:true};
    pagingToolar.scheduler.mainContainer.reloadCalendar(refreshParams);
  }}], onZoomSliderChange:function(s, v) {
    if (v != me.getCurrentZoomLevelIndex()) {
      var currentFilter = me.down('#timeFilter').getCurrentFilter();
      me.down('#timeFilter').selectFilter('CF');
      this.zoomToLevel(v, false);
      me.down('#timeFilter').selectFilter(currentFilter);
    }
  }, eventRenderer:function(event, resourceRecord, meta) {
    var warningResourceAvailableFlag = false;
    warningAppointmentValidFlag = false, warningAppointmentValidatedByDispatcherFlag = false, warningCounter = 0, fieldPreferences = Sdc.locale.SchedulerSetup.calendarFieldPreferences, status = 'scheduled';
    if (!event.get('ValidatedByDispatcher') && !event.get('Confirmed')) {
      warningAppointmentValidatedByDispatcherFlag = true;
      warningCounter++;
    }
    if (!this.eventStore.isAppointmentValid(resourceRecord, event)) {
      warningAppointmentValidFlag = true;
      warningCounter++;
    }
    if (!resourceRecord.get('IsVendor') && !availabilityStore.isResourceAvailable(resourceRecord, event.getStartDate(), event.getEndDate())) {
      warningResourceAvailableFlag = true;
      warningCounter++;
    }
    switch(event.data.Status) {
      case AppointmentStatus.scheduledBySystem:
      case AppointmentStatus.scheduled:
        status = event.data.Confirmed ? AppointmentStatusName.confirmed : warningAppointmentValidatedByDispatcherFlag ? AppointmentStatusName.scheduled : AppointmentStatusName.validated;
        break;
      case AppointmentStatus.canceled:
        status = AppointmentStatusName.canceled;
        break;
      case AppointmentStatus.completed:
        status = AppointmentStatusName.completed;
        break;
      case AppointmentStatus.inprocess:
        status = AppointmentStatusName.inprocess;
        break;
      case AppointmentStatus.closed:
        status = AppointmentStatusName.closed;
        break;
      case AppointmentStatus.onhold:
        status = AppointmentStatusName.onhold;
        break;
      default:
        status = AppointmentStatusName.scheduled;
        break;
    }
    meta.style = Sdc.locale.SchedulerSetup.getCalendarStatusColor(status);
    return {Messages:Sdc.locale.Messages, ViewMode:me.getMode(), StatusName:status.charAt(0).toUpperCase() + status.slice(1), Preferences:fieldPreferences, Appointment:event.data, TotalEmployeesMessage:Ext.String.format(Sdc.locale.Messages.WARNING_APPOINTMENT_VALID, event.get('EmployeeCount') - 1), WarningCounter:warningCounter, WarningResourceAvailableFlag:warningResourceAvailableFlag, WarningAppointmentValidFlag:warningAppointmentValidFlag, WarningAppointmentValidatedByDispatcherFlag:warningAppointmentValidatedByDispatcherFlag};
  }, refreshRow:function(s, rs) {
    var me = this;
    if (!(rs instanceof Array)) {
      rs = [rs];
    }
    var index = me.resourceStore.indexOf(rs[0].getResource());
    me.getView().refreshNode(index);
  }});
  availabilityStore.on({add:me.refreshRow, update:me.refreshRow, scope:me, delay:500});
  availabilityStore.on('load', function(store, records, success, eOpts) {
    me.getView().refresh();
  }, me);
  Sdc.panel.SchedulerGrid.prototype.initComponent.apply(this, arguments);
  Sdc.controller.PresetController.presetButton.menu.on('click', me.onPresetMenu, me);
  Sdc.locale.Url.setBaseUrl(baseUrl);
  Sdc.locale.Url.setWebMethodUrl(pageUrl);
}, updateEvents:function(startDate, endDate) {
  var me = this;
  me.currentDate = startDate;
  if (me.timer) {
    clearTimeout(me.timer);
  }
  me.setTimeSpan(me.calendarDateField.getStartDate(), me.calendarDateField.getEndDate());
  me.timer = setTimeout(function() {
    me.resourceStore.getProxy().extraParams.scheduledStartDate = Ext.encode(me.calendarDateField.getStartDate());
    me.resourceStore.getProxy().extraParams.scheduledEndDate = Ext.encode(me.calendarDateField.getEndDate());
    me.resourceStore.load();
    me.dayRuleStore.getProxy().extraParams.scheduledStartDate = Ext.encode(me.calendarDateField.getStartDate());
    me.dayRuleStore.getProxy().extraParams.scheduledEndDate = Ext.encode(me.calendarDateField.getEndDate());
    me.dayRuleStore.load();
    me.eventStore.getProxy().extraParams.scheduledStartDate = Ext.encode(me.calendarDateField.getStartDate());
    me.eventStore.getProxy().extraParams.scheduledEndDate = Ext.encode(me.calendarDateField.getEndDate());
    me.eventStore.load();
    me.resourceZones.getProxy().extraParams.scheduledStartDate = Ext.encode(me.calendarDateField.getStartDate());
    me.resourceZones.getProxy().extraParams.scheduledEndDate = Ext.encode(me.calendarDateField.getEndDate());
    me.resourceZones.load();
    me.mainContainer.unassignedAppointmentStore.getProxy().extraParams.scheduledStartDate = Ext.encode(me.calendarDateField.getStartDate());
    me.mainContainer.unassignedAppointmentStore.getProxy().extraParams.scheduledEndDate = Ext.encode(me.calendarDateField.getEndDate());
    me.mainContainer.unassignedAppointmentStore.load();
    if (Sdc.locale.SchedulerSetup.showServiceOrderDaysGap != null) {
      me.serviceOrderStore.getProxy().extraParams.scheduledStartDate = Ext.encode((new Date(me.calendarDateField.getStartDate())).addDays(-Sdc.locale.SchedulerSetup.showServiceOrderDaysGap));
      me.serviceOrderStore.getProxy().extraParams.scheduledEndDate = Ext.encode((new Date(me.calendarDateField.getEndDate())).addDays(Sdc.locale.SchedulerSetup.showServiceOrderDaysGap));
    } else {
      me.serviceOrderStore.getProxy().extraParams.scheduledStartDate = null;
      me.serviceOrderStore.getProxy().extraParams.scheduledEndDate = null;
    }
    me.serviceOrderStore.load();
    me.focusCurrentTime();
  }, 500);
}, onDragCreate:function(scheduler, eventRecord, resources, eOpts) {
  var me = this, resource = resources[0], startdate = Ext.Date.parse(eventRecord.get('ScheduledDateTimeBegin').format('dd-mm-yyyy H:MM'), 'd-m-Y G:i'), enddate = Ext.Date.parse(eventRecord.get('ScheduledDateTimeEnd').format('dd-mm-yyyy H:MM'), 'd-m-Y G:i');
  var values = {BranchID:me.branchCombobox.getValue(), ScheduledDateTimeBegin:startdate, ScheduledDateTimeEnd:enddate, EmployeeIDList:resource.get('EmployeeID') ? [resource.get('EmployeeID')] : []};
  if (me.branchLocationCombobox.getValue() != -1) {
    values['BranchLocationID'] = me.branchLocationCombobox.getValue();
  }
  if (ExternalCustomerID) {
    values['CustomerID'] = ExternalCustomerID;
  }
  if (ExternalSMEquipmentID) {
    values['SMequipmentID'] = ExternalSMEquipmentID;
  }
  var refreshParams = {context:me.mainContainer, appointment:true};
  var callback = me.mainContainer.reloadCalendar;
  Sdc.util.PopUpManager.newAppointmentBridgeID(values, null, callback, refreshParams);
  return false;
}, afterRender:function() {
  var me = this;
  Sdc.panel.SchedulerGrid.prototype.afterRender.apply(this, arguments);
  var taskDropZone = Ext.create('MultiEmpDispatch.view.main.ScheduleDropZone', me.getEl(), {scheduler:me, schedulerView:me.getSchedulingView()});
  var grid = me.view.normalGrid;
  grid.headerCt.on('headercontextmenu', function(container, record, event, t, eOpts) {
    if (me.getMode() == 'vertical') {
      var position = event.getXY();
      event.stopEvent();
      me.menuEmployee.record = record;
      me.menuEmployee.showAt(position);
    }
  });
  var headerTip = Ext.create('Ext.tip.ToolTip', {target:grid.headerCt.el, delegate:'.x-column-header', trackMouse:false, renderTo:Ext.getBody(), width:150, region:'center', listeners:{beforeshow:function(toolTip) {
    if (me.getMode() == 'vertical') {
      if (!me.menuEmployee.isHidden()) {
        return false;
      }
      if (!toolTip.triggerElement) {
        return false;
      }
      var column = grid.headerCt.down('gridcolumn[id\x3d' + toolTip.triggerElement.id + ']');
      if (!column) {
        return false;
      }
      var toolTipBody = '\x3cdiv\x3e \x3cdiv class\x3d"sch-event-footer x-fa fa-phone" style\x3d"float: left; width: 18px;"\x3e\x3c/div\x3e \x3cspan\x3e' + (column.model && column.model.data.Phone1 ? column.model.data.Phone1 : Sdc.locale.Messages.WARNING_PHONE_NUMBER_MISSING) + '\x3c/span\x3e \x3c/div\x3e';
      toolTip.update(toolTipBody);
    } else {
      return false;
    }
  }}});
  if (Sdc.locale.SchedulerSetup.appResizePrecision) {
    me.getSchedulingView().setTimeResolution(Sch.util.Date.MINUTE, Sdc.locale.SchedulerSetup.appResizePrecision);
  }
  me.focusCurrentTime();
}, onRender:function() {
  Sdc.panel.SchedulerGrid.prototype.onRender.apply(this, arguments);
  this.getEventStore().load();
}, onPresetMenu:function(menu, item, e, eOpts) {
  if (item) {
    this.down('#presets').setText(item.text);
    var currentFilter = this.down('#timeFilter').getCurrentFilter();
    this.down('#timeFilter').selectFilter('CF');
    this.down('#dateButton').updatePreset(item.itemId);
    this.setMaxZoomLevel(item.maxZoomLevel);
    this.setMinZoomLevel(item.minZoomLevel);
    this.zoomSlider.setMinValue(item.minZoomLevel);
    this.zoomSlider.setMaxValue(item.maxZoomLevel);
    this.onZoomSliderChange(this.zoomSlider, item.dfltResolution);
    this.zoomSlider.setValue(item.dfltResolution);
    this.down('#timeFilter').selectFilter(currentFilter);
    this.down('#timeFilter').refreshFilterOptions();
    if (Sdc.locale.SchedulerSetup.appResizePrecision) {
      this.getSchedulingView().setTimeResolution(Sch.util.Date.MINUTE, Sdc.locale.SchedulerSetup.appResizePrecision);
    }
  }
}}, 0, ['scheduler'], ['component', 'box', 'container', 'panel', 'tablepanel', 'gridpanel', 'grid', 'timelinegrid', 'schedulergrid', 'schedulerpanel', 'scheduler'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'gridpanel':true, 'grid':true, 'timelinegrid':true, 'schedulergrid':true, 'schedulerpanel':true, 'scheduler':true}, ['widget.scheduler'], 0, [MultiEmpDispatch.view.main, 'Scheduler'], 0);
Ext.cmd.derive('Sdc.tip.ServiceOrderToolTip', Ext.tip.ToolTip, {initComponent:function() {
  var me = this;
  var config = {trackMouse:false, dismissDelay:0, showDelay:1000, width:300, maxWidth:500, listeners:{beforeshow:me.updateTipBody}};
  Ext.apply(me, config);
  Ext.tip.ToolTip.prototype.initComponent.apply(this, arguments);
}, getTargetXY:function() {
  var me = this;
  var coordinate = Ext.fly(me.eventTarget).getXY(), coordinateGrid = Ext.fly(ID.serviceOrderGrid).getXY(), width = Ext.fly(ID.serviceOrderGrid).getWidth();
  coordinate[0] = coordinateGrid[0] + width + 5;
  return coordinate;
}, updateTipBody:function(toolTip) {
  var me = this;
  var services = null;
  var view = me.gridView;
  var record = me.record;
  Ext.Ajax.request({async:false, url:pageUrl + '/GetServiceOrderServices?sOID\x3d' + record.get('SOID') + '\x26serviceOrderUnassignedFlag\x3dfalse', headers:{'Content-type':'application/json; charset\x3dutf-8'}, success:function(response, opts) {
    var response = Ext.decode(response.responseText);
    services = response.Result.Rows;
  }, failure:function(response, opts) {
    console.log('server-side failure with status code ' + response.status);
  }});
  var values = {ServiceOrder:record.data, Messages:Sdc.locale.Messages, Services:services};
  toolTip.update(me.toolTipTpl.applyTemplate(values));
}}, 0, 0, ['component', 'box', 'container', 'panel', 'tip', 'tooltip'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tip':true, 'tooltip':true}, 0, 0, [Sdc.tip, 'ServiceOrderToolTip'], 0);
Ext.cmd.derive('Sdc.panel.mixin.AbstractServiceOrderEvents', Ext.Base, {defaultColumns:null, onServiceOrderContextMenu:function(serviceOrderTreeView, td, cellIndex, record, tr, rowIndex, event, eOpts) {
  var me = this;
  var serviceOrderMenu = me.serviceOrderMenu;
  var position = event.getXY();
  event.stopEvent();
  if (serviceOrderMenu) {
    serviceOrderMenu.showAt(position);
    serviceOrderMenu.record = record;
  }
}, onServiceOrderClick:function(serviceOrderTreeView, td, cellIndex, record, tr, rowIndex, event, eOpts) {
  var me = this;
  var gridColumns = serviceOrderTreeView.headerCt.columnManager.columns;
  var me = this;
  var refreshParams = {context:me.mainContainer, serviceOrder:true};
  var refreshCallBack = me.mainContainer.reloadCalendar;
  if (record.get('leaf')) {
    return true;
  }
  if (gridColumns[cellIndex].text == Sdc.locale.Messages.SERVICEORDER_REFNBR && event.target && event.target.nodeName != 'IMG') {
    var params = {RefNbr:record.get('RefNbr'), SrvOrdType:record.get('SrvOrdType')};
    Sdc.util.PopUpManager.openPageUrl('serviceOrder', params, null, refreshCallBack, refreshParams);
  }
  if (gridColumns[cellIndex].text == Sdc.locale.Messages.SERVICEORDER_SOURCEREF) {
    switch(record.data.SourceType) {
      case 'SD':
        var params = {RefNbr:record.get('RefNbr'), SrvOrdType:record.get('SrvOrdType')};
        Sdc.util.PopUpManager.openPageUrl('serviceOrder', params, null, null, null);
        break;
      case 'SO':
        var params = {OrderNbr:record.get('SourceRefNbr'), OrderType:record.get('SourceType')};
        Sdc.util.PopUpManager.openPageUrl('saleOrder', params, null, null, null);
        break;
      case 'CR':
        var params = {CaseCD:record.get('SourceRefNbr')};
        Sdc.util.PopUpManager.openPageUrl('crmCases', params, null, null, null);
        break;
    }
  }
  if (gridColumns[cellIndex].text == Sdc.locale.Messages.SERVICEORDER_SUPERVISOR) {
    var params = {bAccountID:record.get('AssignedEmpID')};
    if (record.get('AssignedEmpID') != 0) {
      Sdc.util.PopUpManager.openPageUrl('employee', params, null, null, null);
    }
  }
}, onServiceOrderDblClick:function(serviceOrderTreeView, record, element, rowIndex, e, eOpts) {
  var me = this;
  if (!record.get('leaf')) {
    me.toolTip.record = record;
    me.toolTip.eventTarget = e.currentTarget;
    me.toolTip.showAt(me.toolTip.getTargetXY());
  }
  return false;
}, getServiceOrderColumns:function() {
  var me = this;
  return me.defaultColumns;
}}, 0, 0, 0, 0, 0, 0, [Sdc.panel.mixin, 'AbstractServiceOrderEvents'], 0);
Ext.cmd.derive('Sdc.panel.ServiceOrderGrid', Ext.tree.Panel, {useArrows:true, defaultColumns:[{xtype:'treecolumn', header:Sdc.locale.Messages.SERVICEORDER_REFNBR, sortable:true, filterable:true, width:135, dataIndex:'text'}, {header:Sdc.locale.Messages.SERVICEORDER_SERVICES_COUNT, sortable:true, hidden:false, width:35, dataIndex:'ServicesCount'}, {header:'', sortable:true, hidden:false, width:25, dataIndex:'ServicesRemaning', renderer:function(value, parent, record) {
  if (record.get('leaf')) {
    if (value > 0) {
      return '\x3cdiv  class \x3d "fa fa-exclamation-circle"\x3e\x3c/div\x3e';
    } else {
      return '\x3cdiv  class \x3d "x-fa fa-calendar"\x3e\x3c/div\x3e';
    }
  }
  return '';
}}, {header:Sdc.locale.Messages.SERVICEORDER_CUSTOMER, sortable:true, flex:1, minWidth:105, dataIndex:'CustomerDisplayName'}, {header:Sdc.locale.Messages.SERVICEORDER_SRVORDTYPE, sortable:true, flex:1, minWidth:105, dataIndex:'SrvOrdType'}, {header:Sdc.locale.Messages.SERVICEORDER_PRIORITY, sortable:true, hidden:false, width:25, dataIndex:'Priority'}, {header:Sdc.locale.Messages.SERVICEORDER_SEVERITY, sortable:true, hidden:false, width:25, dataIndex:'Severity'}, {header:Sdc.locale.Messages.SERVICEORDER_SLA, 
sortable:true, width:80, dataIndex:'SLARemaning'}, {header:Sdc.locale.Messages.SERVICEORDER_ORDER_DATE, sortable:true, width:78, dataIndex:'OrderDate', renderer:Ext.util.Format.dateRenderer('Y-m-d')}, {header:Sdc.locale.Messages.SERVICEORDER_ESTIMATEDTIME, sortable:true, hidden:true, width:65, dataIndex:'EstimatedDurationTotal', renderer:function(value, parent, record) {
  return value ? value.durationFormat() : value;
}}, {header:Sdc.locale.Messages.SERVICEORDER_SOURCE_TYPE, sortable:true, hidden:false, width:65, dataIndex:'SourceType', renderer:function(value, parent, record) {
  var newValue = '';
  switch(value) {
    case 'SD':
      newValue = ' Service Order';
      break;
    case 'SO':
      newValue = ' Sales Order';
      break;
    case 'CR':
      newValue = ' Case';
      break;
    default:
      newValue = '';
      break;
  }
  return newValue;
}}, {header:Sdc.locale.Messages.SERVICEORDER_SOURCEREF, sortable:true, hidden:false, width:65, dataIndex:'SourceRefNbr', tdCls:'link-customColum-grid', renderer:function(value, parent, record) {
  var newValue = value != '' && value != null ? value : record.data.SourceType == 'SD' ? record.data.RefNbr : '';
  return newValue;
}}, {header:Sdc.locale.Messages.SERVICEORDER_SUPERVISOR, sortable:true, hidden:false, width:65, dataIndex:'AssignedEmployeeDisplayName', renderer:function(value, parent, record) {
  var newValue = '';
  if (record.data.SODetID == null) {
    newValue = 'Unassigned';
  }
  if (value != '' && value != null) {
    newValue = value;
  }
  if (newValue != 'Unassigned' && newValue != '') {
    parent.tdCls = parent.tdCls + ' link-employee-grid';
  }
  return newValue;
}}], initComponent:function() {
  var me = this;
  Ext.tree.Panel.prototype.initComponent.apply(this, arguments);
}, afterRender:function() {
  var me = this;
  Ext.tree.Panel.prototype.afterRender.apply(this, arguments);
  var view = me.getView();
  me.toolTip = Ext.create('Sdc.tip.ServiceOrderToolTip', {border:true, delegate:view.itemSelector, gridView:view, toolTipTpl:Ext.XTemplate.from('tooltip-serviceorder').compile(), renderTo:Ext.getBody()});
}}, 0, 0, ['component', 'box', 'container', 'panel', 'tablepanel', 'treepanel'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'treepanel':true}, 0, [['serviceOrderFunctions', Sdc.panel.mixin.AbstractServiceOrderEvents]], [Sdc.panel, 'ServiceOrderGrid'], 0);
Ext.cmd.derive('Sdc.form.field.SearchFilterTextField', Ext.form.field.Text, {initComponent:function() {
  var config = {id:ID.searchField, name:'searchField', hideLabel:true, width:'55%', timer:null, windowFormFilter:null, listeners:{'change':function() {
    if (this.timer) {
      clearTimeout(this.timer);
    }
    var windowFormFilter = this.windowFormFilter;
    this.timer = setTimeout(function() {
      if (windowFormFilter != null) {
        windowFormFilter.form.applyFilters();
      }
    }, 1000);
  }}};
  Ext.apply(this, config);
  Ext.form.field.Text.prototype.initComponent.apply(this, arguments);
}}, 0, 0, ['component', 'box', 'field', 'textfield'], {'component':true, 'box':true, 'field':true, 'textfield':true}, 0, 0, [Sdc.form.field, 'SearchFilterTextField'], 0);
Ext.cmd.derive('Sdc.form.FormFilterServiceOrder', Ext.form.Panel, {initComponent:function() {
  var me = this;
  var assignedEmployeeComboBox = Ext.create('Ext.form.ComboBox', {id:ID.assignedEmployee, fieldLabel:Sdc.locale.Messages.LABEL_SUPERVISOR, valueField:'EmployeeID', displayField:'Display', queryMode:'remote', queryParam:'filter', store:Ext.create('Sdc.data.SupervisorStore'), margin:'0 0 10 5', labelWidth:120, width:350, matchFieldWidth:false, typeAhead:false, pageSize:10, emptyText:Sdc.locale.Messages.EMPTY_EMPLOYEE, listConfig:{loadingText:Sdc.locale.Messages.LOADING_TEXT, emptyText:Sdc.locale.Messages.EMPLOYEE_NOT_FOUND, 
  minWidth:null}, listeners:{'beforequery':function(queryEvent) {
    var filter = [];
    var values = [];
    values.push(queryEvent.query);
    filter.push({property:'DisplayName', value:values});
    queryEvent.query = Ext.encode(filter);
  }}});
  Sdc.BranchController.registerStore('assigned', assignedEmployeeComboBox.store);
  var config = {margin:'10 10 10 10', items:[assignedEmployeeComboBox, {xtype:'tabpanel', activeTab:0, border:true, items:[{title:Sdc.locale.Messages.TITLE_SKILLS, width:460, height:245, items:[{xtype:'checkboxgroup', id:ID.skillsCheckboxGroup, columns:[215, 215], height:235, width:450, scrollable:true, listeners:{beforerender:function() {
    var me = this;
    Ext.Ajax.request({url:pageUrl + '/GetSkills', headers:{'Content-type':'application/json; charset\x3dutf-8'}, success:function(response, opts) {
      var response = Ext.decode(response.responseText);
      var jsonResponse = response.Result.Rows;
      var i_max = jsonResponse.length;
      var i = 0;
      var displayName = '';
      for (i = 0; i < i_max; i++) {
        displayName = jsonResponse[i].Descr ? jsonResponse[i].Descr : jsonResponse[i].SkillCD;
        me.add([{boxLabel:Ext.util.Format.ellipsis(displayName, 27), name:jsonResponse[i].SkillID}]);
      }
    }, failure:function(response, opts) {
      console.log('server-side failure with status code ' + response.status);
    }});
  }}}]}, {title:Sdc.locale.Messages.TITLE_LICENSESTYPE, width:460, height:245, items:[{xtype:'checkboxgroup', id:ID.licensesCheckboxGroup, columns:[215, 215], height:235, width:450, scrollable:true, listeners:{beforerender:function() {
    var me = this;
    Ext.Ajax.request({url:pageUrl + '/GetLicenseTypes', headers:{'Content-type':'application/json; charset\x3dutf-8'}, success:function(response, opts) {
      var response = Ext.decode(response.responseText);
      var jsonResponse = response.Result.Rows;
      var i_max = jsonResponse.length;
      var i = 0;
      var displayName = '';
      for (i = 0; i < i_max; i++) {
        displayName = jsonResponse[i].Descr ? jsonResponse[i].Descr : jsonResponse[i].LicenseTypeCD;
        me.add([{boxLabel:Ext.util.Format.ellipsis(displayName, 27), name:jsonResponse[i].LicenseTypeID}]);
        displayName = '';
      }
    }, failure:function(response, opts) {
      console.log('server-side failure with status code ' + response.status);
    }});
  }}}]}, {title:Sdc.locale.Messages.TITLE_PROBLEMS, width:460, height:245, items:[{xtype:'checkboxgroup', id:ID.problemsCheckboxGroup, columns:[215, 215], height:235, width:450, scrollable:true, listeners:{beforerender:function() {
    var me = this;
    Ext.Ajax.request({url:pageUrl + '/GetProblems', headers:{'Content-type':'application/json; charset\x3dutf-8'}, success:function(response, opts) {
      var response = Ext.decode(response.responseText);
      var jsonResponse = response.Result.Rows;
      var i_max = jsonResponse.length;
      var i = 0;
      var displayName = '';
      for (i = 0; i < i_max; i++) {
        displayName = jsonResponse[i].Descr ? jsonResponse[i].Descr : jsonResponse[i].ProblemCD;
        me.add([{boxLabel:Ext.util.Format.ellipsis(displayName, 27), name:jsonResponse[i].ProblemID}]);
        displayName = '';
      }
    }, failure:function(response, opts) {
      console.log('server-side failure with status code ' + response.status);
    }});
  }}}]}, {title:Sdc.locale.Messages.TITLE_SERVICESTYPE, width:460, height:245, items:[{xtype:'checkboxgroup', id:ID.serviceTypesCheckboxGroup, columns:[215, 215], height:235, width:450, scrollable:true, listeners:{beforerender:function() {
    var me = this;
    Ext.Ajax.request({url:pageUrl + '/GetServiceClasses', headers:{'Content-type':'application/json; charset\x3dutf-8'}, success:function(response, opts) {
      var response = Ext.decode(response.responseText);
      var jsonResponse = response.Result.Rows;
      var i_max = jsonResponse.length;
      var i = 0;
      var displayName = '';
      for (i = 0; i < i_max; i++) {
        displayName = jsonResponse[i].Descr ? jsonResponse[i].Descr : jsonResponse[i].ItemClassCD;
        me.add([{boxLabel:Ext.util.Format.ellipsis(displayName, 27), name:jsonResponse[i].ItemClassID}]);
        displayName = '';
      }
    }, failure:function(response, opts) {
      console.log('server-side failure with status code ' + response.status);
    }});
  }}}]}]}], applyFilters:function() {
    var store = me.store;
    if (store != null) {
      store.remoteFilter = false;
      store.clearFilter();
      store.remoteFilter = true;
      var filters = [], form = me.getForm();
      var likeText = me.externalSearch != null ? me.externalSearch.getValue() : '', assignedEmployee = form.findField(ID.assignedEmployee).getValue(), skills = Object.keys(form.findField(ID.skillsCheckboxGroup).getValue()), licenses = Object.keys(form.findField(ID.licensesCheckboxGroup).getValue()), problems = Object.keys(form.findField(ID.problemsCheckboxGroup).getValue()), servicetypes = Object.keys(form.findField(ID.serviceTypesCheckboxGroup).getValue());
      if (assignedEmployee != '' && assignedEmployee != null) {
        filters.push({property:'AssignedEmpID', value:[assignedEmployee]});
      }
      likeText != '' && filters.push({property:'LikeText', value:[likeText]});
      skills.length > 0 && filters.push({property:'Skill', value:skills});
      licenses.length > 0 && filters.push({property:'LicenseType', value:licenses});
      problems.length > 0 && filters.push({property:'Problem', value:problems});
      servicetypes.length > 0 && filters.push({property:'ServiceClass', value:servicetypes});
      if (filters.length > 0) {
        store.filter(filters);
      } else {
        store.clearFilter(true);
        store.load();
      }
    }
  }, resetFilters:function() {
    var store = me.store;
    if (store != null) {
      var form = me.getForm();
      me.externalSearch != null && me.externalSearch.reset();
      form.findField(ID.assignedEmployee).reset();
      form.findField(ID.skillsCheckboxGroup).reset();
      form.findField(ID.licensesCheckboxGroup).reset();
      form.findField(ID.problemsCheckboxGroup).reset();
      form.findField(ID.serviceTypesCheckboxGroup).reset();
      store.getFilters().getCount() > 0 && store.clearFilter();
    }
  }};
  Ext.apply(me, config);
  Ext.form.Panel.prototype.initComponent.apply(this, arguments);
  assignedEmployeeComboBox.store.load();
}}, 0, ['FormFilterServiceOrder'], ['component', 'box', 'container', 'panel', 'form', 'FormFilterServiceOrder'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'FormFilterServiceOrder':true}, ['widget.FormFilterServiceOrder'], 0, [Sdc.form, 'FormFilterServiceOrder'], 0);
Ext.cmd.derive('Sdc.window.windowFilterServiceOrder', Ext.window.Window, {initComponent:function() {
  var me = this, soStore = this.store, externalSearch = this.externalSearch, employeeStore = this.employeeStore;
  var formFilter = Ext.create('Sdc.form.FormFilterServiceOrder', {store:soStore, employeeStore:employeeStore, externalSearch:externalSearch});
  var filterButton = Ext.create('Ext.Button', {id:ID.serviceOrderFilterButton, text:Sdc.locale.Messages.BUTTON_FILTER, window:this, handler:function() {
    this.setDisabled(true);
    formFilter.applyFilters();
  }});
  var externalSearchFunction = function() {
    filterButton.setDisabled(false);
  };
  soStore.on('load', externalSearchFunction, this);
  var config = {title:Sdc.locale.Messages.TITLE_SERVICEORDER_FILTERS, id:ID.serviceOrderFormFilter, closeAction:'hide', margin:'10 10 10 10', modal:true, height:450, width:480, resizable:false, layout:'fit', form:formFilter, items:formFilter, buttons:[filterButton, {id:ID.serviceOrderFilterCloseButton, text:Sdc.locale.Messages.BUTTON_FILTER_CLOSE, window:this, handler:function() {
    formFilter.applyFilters();
    this.window.hide();
  }}, {id:ID.serviceOrderCloseButton, text:Sdc.locale.Messages.BUTTON_CLOSE, window:this, handler:function() {
    this.window.hide();
  }}]};
  Ext.apply(this, config);
  Ext.window.Window.prototype.initComponent.apply(this, arguments);
}}, 0, ['windowFilterServiceOrder'], ['component', 'box', 'container', 'panel', 'window', 'windowFilterServiceOrder'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'windowFilterServiceOrder':true}, ['widget.windowFilterServiceOrder'], 0, [Sdc.window, 'windowFilterServiceOrder'], 0);
Ext.cmd.derive('Sdc.menu.ServiceOrderMenu', Ext.menu.Menu, {record:null, employeeStore:null, employeeFormFilter:null, initComponent:function() {
  var me = this;
  var config = {items:[{iconCls:'x-fa fa-filter', text:Sdc.locale.Messages.BUTTON_FILTER_RESOURCE, scope:me, hidden:me.employeeStore && me.employeeFormFilter ? false : true, handler:function() {
    var store = me.employeeStore, employeeFormFilter = me.employeeFormFilter ? me.employeeFormFilter.form : null, rawValueServiceClasses = [], filters = [], valueServiceClasses = [];
    if (me.record) {
      if (!me.record.get('leaf') && me.record.get('ServiceClassIDs') != null) {
        rawValueServiceClasses = me.record.get('ServiceClassIDs');
      } else {
        if (me.record.get('InventoryID')) {
          rawValueServiceClasses.push(me.record.get('InventoryID'));
        }
      }
    }
    store.remoteFilter = false;
    store.clearFilter();
    store.remoteFilter = true;
    rawValueServiceClasses.length > 0 && filters.push({property:'Service', value:rawValueServiceClasses});
    if (employeeFormFilter && employeeFormFilter.resetFilters) {
      employeeFormFilter.resetFilters();
    }
    filters.length > 0 ? store.filter(filters) : store.clearFilter();
    var servicesCheckBoxGroup = employeeFormFilter && employeeFormFilter.getServicesCheckBoxGroup ? employeeFormFilter.getServicesCheckBoxGroup() : null;
    if (servicesCheckBoxGroup && servicesCheckBoxGroup.items.length > 0) {
      for (var i = 0; i < rawValueServiceClasses.length; i++) {
        valueServiceClasses[rawValueServiceClasses[i]] = true;
      }
      servicesCheckBoxGroup.setValue(valueServiceClasses);
    }
  }}]};
  Ext.apply(me, config);
  if (me.employeeStore) {
    Ext.menu.Menu.prototype.initComponent.apply(this, arguments);
  } else {
    throw '[ERROR] Missing Employee Store';
  }
}}, 0, 0, ['component', 'box', 'container', 'panel', 'menu'], {'component':true, 'box':true, 'container':true, 'panel':true, 'menu':true}, 0, 0, [Sdc.menu, 'ServiceOrderMenu'], 0);
Ext.cmd.derive('Sdc.view.ServiceOrderDragZone', Ext.dd.DragZone, {grid:null, getRepairXY:function() {
  return this.dragData.repairXY;
}, ddGroup:'schedule', getDragData:function(e) {
  var sourceEl = e.getTarget(), view = this.grid.getView(), rowEl = view.findItemByChild(sourceEl), rec = rowEl && view.getRecord(rowEl);
  if (sourceEl && rec) {
    var d = rowEl.cloneNode(true), wrap = Ext.get(Ext.core.DomHelper.createDom({tag:'div', cls:'sch-dd-wrap', style:{width:'120px', height:'80px'}, children:[{tag:'span', cls:'sch-dd-proxy-hd', html:'\x26nbsp;'}]}));
    wrap.appendChild(d);
    Ext.fly(d).addCls('sch-event-SO-tooltip');
    if (rec.get('leaf')) {
      Ext.fly(d).update('\x3cb\x3eService:\x3c/b\x3e \x3cbr/\x3e' + Ext.util.Format.ellipsis(rec.get('text'), 30));
    } else {
      Ext.fly(d).update('\x3cb\x3eService Order:\x3c/b\x3e \x3cbr/\x3e' + rec.get('RefNbr'));
    }
    return {ddel:wrap.dom, repairXY:Ext.fly(rowEl).getXY(), duration:rec.get('EstimatedDurationTotal') * 60000, records:[rec]};
  }
}}, 0, 0, 0, 0, 0, 0, [Sdc.view, 'ServiceOrderDragZone'], 0);
Ext.cmd.derive('MultiEmpDispatch.view.main.ServiceOrderGrid', Sdc.panel.ServiceOrderGrid, {id:ID.serviceOrderGrid, itemId:ID.serviceOrderGrid, title:Sdc.locale.Messages.TITLE_SERVICEORDER, width:400, height:350, border:true, rootVisible:false, initComponent:function() {
  var me = this;
  var externalSearch = Ext.create('Sdc.form.field.SearchFilterTextField');
  var windowFormFilter = Ext.create('Sdc.window.windowFilterServiceOrder', {store:me.store, externalSearch:externalSearch});
  var clearFilterButton = Ext.create('Ext.Button', {iconCls:'x-fa fa-eraser', id:ID.soClearFilter, scope:me, handler:function() {
    me.windowFormFilter.form.resetFilters();
  }});
  externalSearch.windowFormFilter = windowFormFilter;
  me.store.clearFilterButton = clearFilterButton;
  me.store.serviceOrderTree = me;
  if (RefNbr != '') {
    var externalSearchFunction = function() {
      externalSearch.setValue(RefNbr);
      me.store.removeListener('load', externalSearchFunction, me);
    };
    me.store.on('load', externalSearchFunction, me);
  }
  Ext.apply(me, {windowFormFilter:windowFormFilter, columns:me.getServiceOrderColumns(), tbar:[Sdc.locale.Messages.LABEL_SEARCH, externalSearch, '-\x3e', {iconCls:'x-fa fa-filter', id:ID.soFilter, scope:me, handler:function() {
    me.windowFormFilter.show();
  }}, clearFilterButton], dockedItems:[{xtype:'pagingtoolbar', itemId:'pagingtoolbar', store:me.store, dock:'bottom', displayInfo:false}], listeners:{scope:me, cellclick:me.onServiceOrderClick, rowdblclick:me.onServiceOrderDblClick, cellcontextmenu:me.onServiceOrderContextMenu}});
  Sdc.panel.ServiceOrderGrid.prototype.initComponent.apply(this, arguments);
}, afterRender:function() {
  var me = this;
  Sdc.panel.ServiceOrderGrid.prototype.afterRender.apply(this, arguments);
  Ext.create('Sdc.view.ServiceOrderDragZone', me.getEl(), {grid:me});
  var serviceOrderMenu = Ext.create('Sdc.menu.ServiceOrderMenu', {record:null, employeeStore:me.mainContainer.employeeStore, employeeFormFilter:Ext.getCmp(ID.employeeFormFilter)});
  me.serviceOrderMenu = serviceOrderMenu;
}}, 0, ['serviceordergrid'], ['component', 'box', 'container', 'panel', 'tablepanel', 'treepanel', 'serviceordergrid'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'treepanel':true, 'serviceordergrid':true}, ['widget.serviceordergrid'], 0, [MultiEmpDispatch.view.main, 'ServiceOrderGrid'], 0);
Ext.cmd.derive('MultiEmpDispatch.view.UnassignedAppointmentDragZone', Ext.dd.DragZone, {grid:null, getRepairXY:function() {
  return this.dragData.repairXY;
}, ddGroup:'schedule', getDragData:function(e) {
  var sourceEl = e.getTarget(), view = this.grid.getView(), rowEl = view.findItemByChild(sourceEl), rec = rowEl && view.getRecord(rowEl);
  if (sourceEl && rec) {
    var d = rowEl.cloneNode(true), wrap = Ext.get(Ext.core.DomHelper.createDom({tag:'div', cls:'sch-dd-wrap appointment-dd-tooltip-container', style:{width:'150px', height:'60px', padding:'0px'}, children:[{tag:'span', cls:'sch-dd-proxy-hd appointment-dd-tooltip-span', html:'\x26nbsp;', style:{margin:'0 auto'}}]}));
    wrap.appendChild(d);
    Ext.fly(d).addCls('sch-event');
    Ext.fly(d).update('\x3cb\x3eAppointment:\x3c/b\x3e \x3cbr/\x3e' + rec.get('RefNbr'));
    Ext.fly(d).addCls('sch-event-SO-tooltip');
    return {ddel:wrap.dom, repairXY:Ext.fly(rowEl).getXY(), duration:rec.get('EstimatedDurationTotal') * 60 * 1000, records:[rec], lockFlag:true, dateTimeBegin:rec.get('ScheduledDateTimeBegin')};
  }
}}, 0, 0, 0, 0, 0, 0, [MultiEmpDispatch.view, 'UnassignedAppointmentDragZone'], 0);
Ext.cmd.derive('Sdc.tip.UnassignedAppointmentToolTip', Sdc.tip.AppointmentToolTip, {getTargetXY:function() {
  var me = this;
  var coordinate = Ext.fly(me.eventTarget).getXY(), coordinateGrid = Ext.fly(ID.unassignedAppointmentGrid).getXY(), width = Ext.fly(ID.unassignedAppointmentGrid).getWidth();
  coordinate[0] = coordinateGrid[0] + width + 5;
  return coordinate;
}}, 0, 0, ['component', 'box', 'container', 'panel', 'tip', 'tooltip'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tip':true, 'tooltip':true}, 0, 0, [Sdc.tip, 'UnassignedAppointmentToolTip'], 0);
Ext.cmd.derive('Sdc.panel.mixin.AbstractUnassignedAppointmentEvents', Ext.Base, {defaultColumns:null, getUnassignedAppointmentColumns:function() {
  var me = this;
  if (!me.defaultColumns) {
    me.initColumns();
  }
  return me.defaultColumns;
}, initColumns:function() {
  var me = this;
  me.defaultColumns = [{text:Sdc.locale.Messages.TITLE_APPOINTMENT, dataIndex:'RefNbr', width:100}, {text:Sdc.locale.Messages.SERVICEORDER_CUSTOMER, width:100, dataIndex:'CustomerName'}, {text:Sdc.locale.Messages.SERVICEORDER_SRVORDTYPE, width:100, dataIndex:'SrvOrdType'}, {text:Sdc.locale.Messages.SERVICEORDER_SERVICES_COUNT, width:80, dataIndex:'ServiceCount'}, {text:Sdc.locale.Messages.SERVICEORDER_DATE, width:75, dataIndex:'ScheduledDateTimeBegin', renderer:Ext.util.Format.dateRenderer('Y-m-d')}, 
  {text:Sdc.locale.Messages.SERVICEORDER_TIMESTART, width:70, dataIndex:'ScheduledDateTimeBegin', renderer:Ext.util.Format.dateRenderer('g:i')}, {text:Sdc.locale.Messages.SERVICEORDER_TIMEEND, width:60, dataIndex:'ScheduledDateTimeEnd', renderer:Ext.util.Format.dateRenderer('g:i')}];
}, onUnassignedAppointmentClick:function(unassignedAppointmentView, td, cellIndex, record, tr, rowIndex, event, eOpts) {
  var me = this;
  var gridColumns = unassignedAppointmentView.headerCt.columnManager.columns;
  var me = this;
  var refreshParams = {context:me.mainContainer, unassignedAppointment:true};
  var refreshCallBack = me.mainContainer.reloadCalendar;
  if (gridColumns[cellIndex].text == Sdc.locale.Messages.TITLE_APPOINTMENT) {
    var params = {SrvOrdType:record.get('SrvOrdType'), RefNbr:record.get('RefNbr')};
    Sdc.util.PopUpManager.openPageUrl('appointment', params, null, refreshCallBack, refreshParams);
  }
}, onUnassignedAppointmentDblClick:function(grid, record, element, rowIndex, e, eOpts) {
  var me = this;
  me.toolTip.appointmentRecord = record;
  me.toolTip.eventTarget = e.currentTarget;
  me.toolTip.showAt(me.toolTip.getTargetXY());
  return false;
}, onUnassignedAppointmentContextMenu:function(unassignedAppointmentView, td, cellIndex, record, tr, rowIndex, event, eOpts) {
  var me = this;
  var unassignedAppointmentMenu = me.unassignedAppointmentMenu;
  var position = event.getXY();
  event.stopEvent();
  if (unassignedAppointmentMenu) {
    unassignedAppointmentMenu.showAt(position);
    unassignedAppointmentMenu.record = record;
  }
}}, 0, 0, 0, 0, 0, 0, [Sdc.panel.mixin, 'AbstractUnassignedAppointmentEvents'], 0);
Ext.cmd.derive('Sdc.panel.UnassignedAppointmentGrid', Ext.grid.Panel, {initComponent:function() {
  var me = this;
  var config = {};
  Ext.apply(me, config);
  Ext.grid.Panel.prototype.initComponent.apply(this, arguments);
}, afterRender:function() {
  var me = this;
  Ext.grid.Panel.prototype.afterRender.apply(this, arguments);
  var view = me.getView();
  me.toolTip = Ext.create('Sdc.tip.UnassignedAppointmentToolTip', {});
}, updateGridTitle:function(appointmentsNumber) {
  var me = this;
  me.setTitle(Sdc.locale.Messages.TITLE_UNASSIGNED_APPOINTMENT + ' (' + appointmentsNumber + ')');
}}, 0, 0, ['component', 'box', 'container', 'panel', 'tablepanel', 'gridpanel', 'grid'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'gridpanel':true, 'grid':true}, 0, [['unassignedAppointmentFunctions', Sdc.panel.mixin.AbstractUnassignedAppointmentEvents]], [Sdc.panel, 'UnassignedAppointmentGrid'], 0);
Ext.cmd.derive('Sdc.menu.UnassignedAppointmentMenu', Ext.menu.Menu, {record:null, employeeStore:null, employeeFormFilter:null, initComponent:function() {
  var me = this;
  var config = {items:[{iconCls:'x-fa fa-filter', text:Sdc.locale.Messages.BUTTON_FILTER_RESOURCE, scope:me, handler:function() {
    if (me.record) {
      var resources = null;
      var services = [];
      Ext.Ajax.request({url:pageUrl + '/GetAppointmentServices?appointmentID\x3d' + me.record.get('AppointmentID'), headers:{'Content-type':'application/json; charset\x3dutf-8'}, async:false, success:function(response, opts) {
        var response = Ext.decode(response.responseText);
        resources = response.Result.Rows;
      }, failure:function(response, opts) {
        console.log('server-side failure with status code ' + response.status);
      }});
      if (resources) {
        var length = resources.length;
        for (var i = 0; i < length; i++) {
          services.push(resources[i].InventoryID);
        }
      }
      var store = me.employeeStore, employeeFormFilter = me.employeeFormFilter ? me.employeeFormFilter.form : null, rawValueServiceClasses = [], filters = [], valueServiceClasses = [];
      store.remoteFilter = false;
      store.clearFilter();
      store.remoteFilter = true;
      services.length > 0 && filters.push({property:'Service', value:services});
      if (employeeFormFilter && employeeFormFilter.resetFilters) {
        employeeFormFilter.resetFilters();
      }
      filters.length > 0 ? store.filter(filters) : store.clearFilter();
      rawValueServiceClasses = services;
      var servicesCheckBoxGroup = employeeFormFilter && employeeFormFilter.getServicesCheckBoxGroup ? employeeFormFilter.getServicesCheckBoxGroup() : null;
      if (servicesCheckBoxGroup && servicesCheckBoxGroup.items.length > 0) {
        for (var i = 0; i < rawValueServiceClasses.length; i++) {
          valueServiceClasses[rawValueServiceClasses[i]] = true;
        }
        servicesCheckBoxGroup.setValue(valueServiceClasses);
      }
    }
  }}]};
  Ext.apply(me, config);
  if (me.employeeStore) {
    Ext.menu.Menu.prototype.initComponent.apply(this, arguments);
  } else {
    throw '[ERROR] Missing Employee Store';
  }
}}, 0, 0, ['component', 'box', 'container', 'panel', 'menu'], {'component':true, 'box':true, 'container':true, 'panel':true, 'menu':true}, 0, 0, [Sdc.menu, 'UnassignedAppointmentMenu'], 0);
Ext.cmd.derive('Sdc.form.field.SearchUnassignedAppointmentsFilterTextField', Ext.form.field.Text, {initComponent:function() {
  var config = {id:ID.searchFieldUnassigned, name:'searchFieldUnassigned', hideLabel:true, width:'55%', timer:null, windowFormFilter:null, listeners:{'change':function() {
    if (this.timer) {
      clearTimeout(this.timer);
    }
    var windowFormFilter = this.windowFormFilter;
    this.timer = setTimeout(function() {
      if (windowFormFilter != null) {
        windowFormFilter.form.applyFilters();
      }
    }, 1000);
  }}};
  Ext.apply(this, config);
  Ext.form.field.Text.prototype.initComponent.apply(this, arguments);
}}, 0, 0, ['component', 'box', 'field', 'textfield'], {'component':true, 'box':true, 'field':true, 'textfield':true}, 0, 0, [Sdc.form.field, 'SearchUnassignedAppointmentsFilterTextField'], 0);
Ext.cmd.derive('MultiEmpDispatch.view.main.UnassignedAppointmentGrid', Sdc.panel.UnassignedAppointmentGrid, {id:ID.unassignedAppointmentGrid, title:Sdc.locale.Messages.TITLE_UNASSIGNED_APPOINTMENT, width:400, height:350, border:true, columnsResize:2, initComponent:function() {
  var me = this;
  me.store.grid = me;
  var externalSearch = Ext.create('Sdc.form.field.SearchUnassignedAppointmentsFilterTextField');
  var windowFormFilter = Ext.create('Sdc.window.windowFilterUnassignedAppointment', {store:me.store, externalSearch:externalSearch});
  externalSearch.store = me.store;
  var clearFilterButton = Ext.create('Ext.Button', {iconCls:'x-fa fa-eraser', id:ID.uaClearFilter, scope:me, handler:function() {
    me.windowFormFilter.form.resetFilters();
  }});
  me.store.clearFilterButton = clearFilterButton;
  externalSearch.windowFormFilter = windowFormFilter;
  if (RefNbr != '') {
    var externalSearchFunction = function() {
      externalSearch.setValue(RefNbr);
      me.store.removeListener('load', externalSearchFunction, me);
    };
    me.store.on('load', externalSearchFunction, me);
  }
  var config = {windowFormFilter:windowFormFilter, columns:me.getUnassignedAppointmentColumns(), tbar:[Sdc.locale.Messages.LABEL_SEARCH, externalSearch, '-\x3e', {iconCls:'x-fa fa-filter', id:ID.uaFilter, scope:me, handler:function() {
    me.windowFormFilter.show();
  }}, clearFilterButton], dockedItems:[{xtype:'pagingtoolbar', itemId:'pagingtoolbar', store:me.store, dock:'bottom'}], listeners:{scope:me, cellclick:me.onUnassignedAppointmentClick, rowdblclick:me.onUnassignedAppointmentDblClick, cellcontextmenu:me.onUnassignedAppointmentContextMenu}};
  Ext.apply(me, config);
  Sdc.panel.UnassignedAppointmentGrid.prototype.initComponent.apply(this, arguments);
}, afterRender:function() {
  var me = this;
  Sdc.panel.UnassignedAppointmentGrid.prototype.afterRender.apply(this, arguments);
  Ext.create('MultiEmpDispatch.view.UnassignedAppointmentDragZone', me.getEl(), {grid:me});
  var unassignedAppointmentMenu = Ext.create('Sdc.menu.UnassignedAppointmentMenu', {record:null, employeeStore:me.mainContainer.employeeStore, employeeFormFilter:Ext.getCmp(ID.employeeFormFilter)});
  me.unassignedAppointmentMenu = unassignedAppointmentMenu;
}}, 0, ['unassignedappointmentgrid'], ['component', 'box', 'container', 'panel', 'tablepanel', 'gridpanel', 'grid', 'unassignedappointmentgrid'], {'component':true, 'box':true, 'container':true, 'panel':true, 'tablepanel':true, 'gridpanel':true, 'grid':true, 'unassignedappointmentgrid':true}, ['widget.unassignedappointmentgrid'], 0, [MultiEmpDispatch.view.main, 'UnassignedAppointmentGrid'], 0);
Ext.cmd.derive('Sdc.model.SrvOrdType', Ext.data.Model, {fields:[{name:'SrvOrdType', type:'string'}, {name:'Descr', type:'string'}, {name:'Display', type:'string', convert:function(value, record) {
  if (record.get('SrvOrdType') && record.get('Descr')) {
    return record.get('SrvOrdType').replace(/\s+/g, '') + ' - ' + record.get('Descr');
  }
  if (!record.get('Descr')) {
    return record.get('SrvOrdType').replace(/\s+/g, '');
  }
  return record.get('Descr');
}}]}, 0, 0, 0, 0, 0, 0, [Sdc.model, 'SrvOrdType'], 0);
Ext.cmd.derive('Sdc.data.SrvOrdTypeStore', Ext.data.Store, {model:'Sdc.model.SrvOrdType', start:0, pageSize:10, proxy:{url:pageUrl + '/GetSrvOrdTypes', type:'ajax', headers:{'Content-type':'application/json; charset\x3dutf-8'}, reader:{type:'json', rootProperty:'Result.Rows', metaProperty:'MetaData', totalProperty:'Result.TotalRows', successProperty:'Success', messageProperty:'Message'}, writer:{type:'json', rootProperty:'srvOrdType', encode:false}}}, 0, 0, 0, 0, 0, 0, [Sdc.data, 'SrvOrdTypeStore'], 
0);
Ext.cmd.derive('Sdc.form.FormSrvOrdType', Ext.form.Panel, {initComponent:function() {
  var me = this;
  var srvOrdTypeCombo = null;
  var store = Ext.create('Sdc.data.SrvOrdTypeStore');
  srvOrdTypeCombo = Ext.create('Ext.form.ComboBox', {id:ID.srvOrdTypeFormCombo, fieldLabel:Sdc.locale.Messages.LABEL_SRVORDTYPE, valueField:'SrvOrdType', displayField:'Display', queryMode:'remote', store:store, margin:'0 0 10 5', labelWidth:120, width:350, matchFieldWidth:false, typeAhead:false, emptyText:Sdc.locale.Messages.EMPTY_SRVORDTYPE});
  var config = {margin:'10 10 10 10', srvOrdTypeCombo:srvOrdTypeCombo, items:[srvOrdTypeCombo]};
  Ext.apply(me, config);
  Ext.form.Panel.prototype.initComponent.apply(this, arguments);
  store.load();
}}, 0, ['formsrvordtype'], ['component', 'box', 'container', 'panel', 'form', 'formsrvordtype'], {'component':true, 'box':true, 'container':true, 'panel':true, 'form':true, 'formsrvordtype':true}, ['widget.formsrvordtype'], 0, [Sdc.form, 'FormSrvOrdType'], 0);
Ext.cmd.derive('Sdc.form.field.FSTimeFilter', Ext.button.Button, {itemId:'timeFilter', text:Sdc.locale.Messages.BUTTON_CLEARED_FILTER, scheduler:null, currentFilter:'CF', initComponent:function() {
  var me = this;
  var config = {menu:{items:[{itemId:'CF', text:Sdc.locale.Messages.BUTTON_CLEARED_FILTER, minZoomValid:0, vPresetValid:['fsVDay', 'fsVWeek', 'fsVMonth'], handler:function() {
    me.currentFilter = 'CF';
    me.scheduler && me.scheduler.getTimeAxis().clearFilter();
    me.setText(Sdc.locale.Messages.BUTTON_CLEARED_FILTER);
  }}, {itemId:'WT', text:Sdc.locale.Messages.FILTER_WORKING_TIME, minZoomValid:13, vPresetValid:['fsVDay'], handler:function() {
    me.currentFilter = 'WT';
    var startTime = (new Date(Sdc.locale.SchedulerSetup.dfltCalendarStartTime)).getHours();
    var endTime = null;
    if (Sdc.locale.SchedulerSetup.dfltCalendarEndTime) {
      endTime = (new Date(Sdc.locale.SchedulerSetup.dfltCalendarEndTime)).getHours();
    }
    me.scheduler && me.scheduler.getTimeAxis().filterBy(function(tick) {
      if (Sch.preset.Manager.getPreset(me.scheduler.getViewPreset()).timeResolution.unit !== Sch.util.Date.MINUTE && Sch.preset.Manager.getPreset(me.scheduler.getViewPreset()).timeResolution.unit !== Sch.util.Date.HOUR) {
        return true;
      }
      if (endTime && tick.start.getHours() <= endTime == false) {
        return false;
      }
      return tick.start.getHours() >= startTime;
    });
    me.setText(Sdc.locale.Messages.FILTER_WORKING_TIME);
  }}, {itemId:'WD', text:Sdc.locale.Messages.FILTER_WEEKDAYS, minZoomValid:10, vPresetValid:['fsVWeek', 'fsVMonth'], handler:function() {
    me.currentFilter = 'WD';
    me.scheduler && me.scheduler.getTimeAxis().filterBy(function(tick) {
      return tick.start.getDay() !== 6 && tick.start.getDay() !== 0;
    });
    me.setText(Sdc.locale.Messages.FILTER_WEEKDAYS);
  }}, {itemId:'WW', text:Sdc.locale.Messages.FILTER_WORKING_TIME_WEEKDAYS, minZoomValid:10, vPresetValid:['fsVDay', 'fsVWeek', 'fsVMonth'], handler:function() {
    me.currentFilter = 'WW';
    var startTime = (new Date(Sdc.locale.SchedulerSetup.dfltCalendarStartTime)).getHours();
    var endTime = null;
    if (Sdc.locale.SchedulerSetup.dfltCalendarEndTime) {
      endTime = (new Date(Sdc.locale.SchedulerSetup.dfltCalendarEndTime)).getHours();
    }
    if (me.scheduler) {
      me.scheduler.getMode() == 'vertical' && me.scheduler.getTimeAxis().filterBy(function(tick) {
        if (me.scheduler.getViewPreset() != 'fsVDay') {
          return tick.start.getDay() !== 6 && tick.start.getDay() !== 0;
        } else {
          if (endTime && tick.start.getHours() <= endTime == false) {
            return false;
          }
          return tick.start.getHours() >= startTime;
        }
      });
      me.scheduler.getMode() == 'horizontal' && me.scheduler.getTimeAxis().filterBy(function(tick) {
        if (tick.start.getDay() == 6 || tick.start.getDay() == 0) {
          return false;
        }
        if (Sch.preset.Manager.getPreset(me.scheduler.getViewPreset()).timeResolution.unit !== Sch.util.Date.MINUTE && Sch.preset.Manager.getPreset(me.scheduler.getViewPreset()).timeResolution.unit !== Sch.util.Date.HOUR) {
          return true;
        }
        if (endTime && tick.start.getHours() <= endTime == false) {
          return false;
        }
        return tick.start.getHours() >= startTime;
      });
    }
    me.setText(Sdc.locale.Messages.FILTER_WORKING_TIME_WEEKDAYS);
  }}, {itemId:'BD', text:Sdc.locale.Messages.FILTER_BOOKED_DAYS, minZoomValid:0, vPresetValid:['fsVDay', 'fsVWeek', 'fsVMonth'], handler:function() {
    me.currentFilter = 'BD';
    me.scheduler && me.scheduler.getTimeAxis().filterBy(function(tick) {
      if (me.scheduler.eventStore.getCount() == 0) {
        return true;
      }
      return me.scheduler.eventStore.queryBy(function(ev) {
        return Sch.util.Date.intersectSpans(ev.getStartDate(), ev.getEndDate(), tick.start, tick.end);
      }).length > 0;
    });
    me.setText(Sdc.locale.Messages.FILTER_BOOKED_DAYS);
  }}]}};
  Ext.apply(this, config);
  Ext.button.Button.prototype.initComponent.apply(this, arguments);
}, selectFilter:function(filterID) {
  var me = this;
  var current = me.menu.down('#' + filterID);
  if (current && me.scheduler) {
    if (me.scheduler.getMode() == 'horizontal' && current.minZoomValid <= me.scheduler.getCurrentZoomLevelIndex()) {
      current.handler();
    }
    if (me.scheduler.getMode() == 'vertical' && current.vPresetValid.indexOf(me.scheduler.getViewPreset()) > -1) {
      current.handler();
    }
  }
}, getCurrentFilter:function() {
  return this.currentFilter;
}, refreshFilterOptions:function() {
  var me = this;
  var items = me.menu.items.items;
  var level = me.scheduler.getCurrentZoomLevelIndex();
  for (var i$45 = 0; i$45 < items.length; i$45++) {
    if (me.scheduler.getMode() == 'horizontal' && items[i$45].minZoomValid > me.scheduler.getCurrentZoomLevelIndex() || me.scheduler.getMode() == 'vertical' && items[i$45].vPresetValid.indexOf(me.scheduler.getViewPreset()) == -1) {
      items[i$45].disable();
    } else {
      items[i$45].enable();
    }
  }
}}, 0, ['FSTimeFilter'], ['component', 'box', 'button', 'FSTimeFilter'], {'component':true, 'box':true, 'button':true, 'FSTimeFilter':true}, ['widget.FSTimeFilter'], 0, [Sdc.form.field, 'FSTimeFilter'], 0);
Ext.cmd.derive('Sdc.window.WindowSrvOrdType', Ext.window.Window, {newAppointmentBridgeCallback:null, initComponent:function() {
  var me = this;
  form = null;
  var dfltSrvOrdType = Sdc.locale.SchedulerSetup.dfltSrvOrdType;
  var form = Ext.create('Sdc.form.FormSrvOrdType');
  var config = {title:Sdc.locale.Messages.TITLE_CREATE_APPOINTMENT, id:ID.srvOrdTypeForm, closeAction:'hide', margin:'10 10 10 10', modal:true, height:150, width:480, resizable:false, layout:'fit', form:form, items:form, buttons:[{id:ID.srvOrdTypeFormOkButton, text:Sdc.locale.Messages.BUTTON_OK, window:me, handler:function() {
    var me = this;
    var context = me.window.context;
    context.params['SrvOrdType'] = me.window.form.srvOrdTypeCombo.getValue();
    if (me.window.newAppointmentBridgeCallback) {
      me.window.newAppointmentBridgeCallback(context.params, context.popupCfg, context.fn, context.refreshParams);
    }
    me.window.hide();
  }}, {id:ID.srvOrdTypeFormCloseButton, text:Sdc.locale.Messages.BUTTON_CLOSE, window:me, handler:function() {
    var me = this;
    me.window.hide();
  }}], listeners:{'show':function(window, e) {
    window.form.srvOrdTypeCombo.setValue(dfltSrvOrdType);
  }}};
  Ext.apply(me, config);
  Ext.window.Window.prototype.initComponent.apply(this, arguments);
}}, 0, ['windowsrvordtype'], ['component', 'box', 'container', 'panel', 'window', 'windowsrvordtype'], {'component':true, 'box':true, 'container':true, 'panel':true, 'window':true, 'windowsrvordtype':true}, ['widget.windowsrvordtype'], [['DecodeMessages', Sdc.data.mixin.AbstractDecodeMessages]], [Sdc.window, 'WindowSrvOrdType'], 0);
Ext.on('resize', function() {
  var width = Math.max($('#scheduler-container').width(), 600);
  var height = Math.max($(window).height() - 40, 400);
  Ext.getCmp(ID.mainContainer) != null && Ext.getCmp(ID.mainContainer).setSize(width, height);
});
Ext.application({extend:MultiEmpDispatch.Application, name:'MultiEmpDispatch', autoCreateViewport:false, launch:function() {
  var me = this;
  var start = startDate != null ? new Date(startDate) : new Date;
  var end = new Date(start);
  start.setHours(0, 0, 0, 0);
  end.setHours(24, 0, 0, 0);
  Ext.create('MultiEmpDispatch.view.main.Main', {startDate:start, endDate:end, renderTo:'scheduler-container'});
  if (window.parent && window.parent.frameHelper) {
    window.parent.frameHelper.stopLoadAnimation();
  }
}});
