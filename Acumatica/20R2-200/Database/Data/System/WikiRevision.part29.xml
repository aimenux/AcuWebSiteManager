<?xml version="1.0" encoding="utf-8"?>
<data>
	<table name="WikiRevision">
		<col name="CompanyID" type="Int" default="Zero" />
		<col name="PageID" type="UniqueIdentifier" />
		<col name="Language" type="VarChar(50)" />
		<col name="PageRevisionID" type="Int" />
		<col name="Content" type="NVarChar(MAX)" />
		<col name="ContentHtml" type="NVarChar(MAX)" nullable="true" />
		<col name="PlainText" type="NVarChar(MAX)" />
		<col name="ApprovalByID" type="UniqueIdentifier" nullable="true" />
		<col name="ApprovalDateTime" type="DateTime" nullable="true" />
		<col name="CreatedByID" type="UniqueIdentifier" />
		<col name="CreatedDateTime" type="DateTime" />
		<col name="CompanyMask" type="VarBinary(32)" default="CompanyMaskReadOnly" />
		<col name="UID" type="UniqueIdentifier" />
		<col name="RecordSourceID" type="SmallInt" nullable="true" />
	</table>
	<rows>
		<row PageID="2e919932-c74e-48ff-b85a-bc5d76360367" Language="en-US" PageRevisionID="1" Content="In this guide, you can find information about how to develop applications based on Acumatica Framework.&#xA;==In This Guide==[anchor|#_917d1e43-ded8-41ed-b16b-9ec1f6ea0eb7]&#xA;*[HelpRoot_Dev_Platform\OV__mng| Acumatica Framework Overview]&#xA;*[HelpRoot_Dev_Platform\FGS__mng|Getting Started with Acumatica Framework]&#xA;*[HelpRoot_Dev_Platform\DA__mng|Designing the Application]&#xA;*[HelpRoot_Dev_Platform\CW__mng|Configuring ASPX Pages and Reports]&#xA;*[HelpRoot_Dev_Platform\AD__mng|Accessing Data]&#xA;*[HelpRoot_Dev_Platform\BL__mng|Implementing Business Logic]&#xA;*[HelpRoot_Dev_Platform\TS__mng|Troubleshooting Acumatica Framework-Based Applications]&#xA;*[HelpRoot_Dev_Platform\GLO__mng_Glossary|Glossary]&#xA;" PlainText=" Acumatica Framework Guide In this guide, you can find information about how to develop applications based on  Acumatica Framework. In This Guide  Acumatica Framework OverviewGetting Started with Acumatica FrameworkDesigning the ApplicationConfiguring ASPX Pages and ReportsAccessing DataImplementing Business LogicTroubleshooting Acumatica Framework-Based ApplicationsGlossary" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2b3f8ebf-8da7-7326-7f8f-944901e6d274" RecordSourceID="22377" />
		<row PageID="a8c57de7-0cc6-4e09-ba7e-476b9a397f28" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="031c2057-f3de-8ad3-dcb8-71962c0e3544" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#_a9377c34-4609-44bd-8130-41acb1cf7564]
 Acumatica Framework provides the application programming interface (API) and tools for developing cloud business applications. Acumatica Framework is a part of the Acumatica Cloud xRP                         Platform, which provides various ways to develop the following:[anchor|#_10c00b42-1e8a-448c-9063-ae30f8852000]
*Add-on applications that interact with Acumatica ERP through the web services API
*Applications embedded into Acumatica ERP through the built-in customization tools
*Completely new applications based purely on Acumatica Framework
{br}

In this part of the guide, you can find an overview of the Acumatica Cloud xRP                         Platform and the place of Acumatica Framework in this platform. This part also includes an overview of Acumatica Framework tools and a high-level overview of the runtime architecture of applications based on Acumatica Framework.
==In This Part==[anchor|#_47e7ea75-a256-4f6c-bbbf-3ee121f9a1c1]
*[HelpRoot_Dev_Platform\OV__con_xRP_Platform| Acumatica Cloud xRP                         Platform]
*[HelpRoot_Dev_Platform\OV__con_Development_Tools| Acumatica Framework Development Tools]
*[HelpRoot_Dev_Platform\OV__con_Architecture|Runtime Architecture of an Application Based on Acumatica Framework]
]]></column>
			<column name="PlainText"><![CDATA[ Acumatica Framework Overview  Acumatica Framework provides the application programming interface (API) and tools for developing cloud business applications.  Acumatica Framework is a part of the  Acumatica Cloud xRP                         Platform, which provides various ways to develop the following: Add-on applications that interact with  Acumatica ERP through the web services API Applications embedded into  Acumatica ERP through the built-in customization tools Completely new applications based purely on  Acumatica FrameworkIn this part of the guide, you can find an overview of the  Acumatica Cloud xRP                         Platform and the place of  Acumatica Framework in this platform. This part also includes an overview of  Acumatica Framework tools and a high-level overview of the runtime architecture of applications based on  Acumatica Framework. In This Part  Acumatica Cloud xRP                         Platform Acumatica Framework Development ToolsRuntime Architecture of an Application Based on Acumatica Framework]]></column>
		</row>
		<row PageID="a296caef-aee5-4190-90d0-e43c6378c1b5" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="9deea65f-8e44-04a4-09fe-996c5a75edb5" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The Acumatica Cloud xRP                         Platform is the platform provided by Acumatica that is used to build the Acumatica ERP application itself, any customizations of Acumatica ERP, the mobile application for Acumatica ERP, and applications integrated with Acumatica ERP through the web services API.{br}

The Acumatica Cloud xRP                         Platform consists of a number of components, which are highlighted with light blue in the following diagram. These components serve different purposes, which are described in detail in this topic, and can be used either separately or combined to achieve your business purposes. [anchor|#_5e87a512-709f-4f19-97dd-297695881bc0][anchor|#_0a7f6124-bedf-46fc-a073-760a78ae81f6][image:StudioDeveloperGuide/Images/AcumaticaCloudXrpPlatform.png|popup|Acumatica Cloud xRP                         Platform|450px]
==Basic Components and Tools==
The base of the Acumatica Cloud xRP                         Platform is formed by the components and tools that provide the basic application functionality, such as multitenancy support, role-based access, and localization tools. These components and tools are available out-of-the-box in Acumatica ERP, any embedded in Acumatica ERP applications, or applications based purely on Acumatica Framework applications. This means that you do not need to worry about implementing mechanisms similar to these components during the design or programming of your application based on the Acumatica Cloud xRP                         Platform. {br}

 Acumatica Cloud xRP                         Platform contains the basic components and tools listed in the following table.[anchor|#_85d91eb0-f188-4afa-a9d7-c2d5966022d9]
{| class="checklist" | width="100%" 
|- 
!width="25%" ! Component or Tool
!width="75%" ! Description
|- 
| Role-based access
| A set of components responsible for user authorization, access rights verification, and audit on the data access and business logic levels. For more information, see [HelpRoot_Administration\User_Roles_GeneralInfo|User Roles: General Information] in the System Administration Guide.
|- 
| Multitenancy
| A component responsible for hosting multiple tenants on a single application server. For details about multitenancy, see [HelpRoot_Administration\SM__con_Support_of_Multiple_Companies|Support of Multiple Tenants] in the User Guide.
|- 
| Localization tools
| The tools that help you to perform the localization of the application to multiple languages. For more information about localization, see [HelpRoot_Administration\SM__con_Translation_Process|Translation Process].
|- 
| Help management system
| The integrated wiki-based help content editing, management, and search system. For details about the help management system, see [HelpRoot_Administration\SM__con_Wiki_Management|Wiki Overview].
|- 
| Document management system
| The integrated document storage and management system. For details, see [HelpRoot_Administration\DM__mng_File_Attachements|Managing Attached Files].
|- 
|  Report Designer
| A separate utility (which can be installed along with Acumatica ERP or Acumatica Framework) that you can use to design custom reports. For details on this tool, see [HelpRoot_ReportingTools\ReportDesigner_Main| Acumatica Report                         Designer Guide]. 
|}
== Acumatica Framework==
 Acumatica Framework provides the platform API, web controls, and other tools for the development of the UI and business logic of an ERP application. The platform API is used for the development of Acumatica ERP and any embedded applications (that is, customizations of Acumatica ERP). Acumatica Framework can also be used to develop an ERP application from scratch. You can find detailed information about the development of applications with Acumatica Framework in this guide.{br}

 Acumatica Framework consists of the development tools listed in the following table.[anchor|#_97a00707-41d3-4be5-9162-6c5ae64d41ff]
{| class="checklist" | width="100%" 
|- 
!width="25%" ! Component
!width="75%" ! Description
|- 
| Platform API
| The API for implementing application business logic.
|- 
| Web controls
| A set of web controls implementing access to business logic through the web UI.
|- 
| Template application
| The application and database structures providing frameset, layout, and navigation services. You can deploy a template application along with the template website by using the Acumatica Framework                             Configuration Wizard.
|- 
| Visual Studio templates
| The project template for the creation of a new application and a set of page templates that automate the creation of typical page layouts.
|- 
| Application creation wizards
| A set of components to automate the creation of the application data access classes from the database tables and the web forms during application development.
|}{br}

For details about the development tools, see [HelpRoot_Dev_Platform\OV__con_Development_Tools| Acumatica Framework Development Tools]. 
==Acuminator==
Acuminator is a static code analysis and colorizer tool for Visual Studio that simplifies development with Acumatica Frameworkthe P. Acuminator provides diagnostics and code fixes for common developer challenges related to the platform API. Also, Acuminator can colorize and format business query language (BQL) statements, and can collapse attributes and parts of BQL queries. You can find related information and download Acuminator at [https://marketplace.visualstudio.com/items?itemName=V-for-Volodymyr.Acuminator#overview|Visual Studio Marketplace]. 
== Acumatica Customization           Platform==
 Acumatica Customization           Platform provides customization tools for the development of applications embedded in Acumatica ERP. Developers that work with Acumatica Customization           Platform use the platform API provided by Acumatica Framework. {br}

With Acumatica Customization           Platform, you can perform end-customer customizations and create complex solutions for multiple customers. In these customizations, you can modify the user interface, business logic, and database schema without recompilation and re-installation of the application. Customizations are stored separately from the core application code as metadata and can be modified, exported, or imported. Because customizations are stored separately, they are preserved with the updates and upgrades of the core application.{br}

For details on Acumatica Customization           Platform, see [HelpRoot_Dev_Customization\CG_Platform| Acumatica Customization             Platform].
==Web Services APIs==
The Acumatica Cloud xRP                         Platform provides multiple types of web services APIs for development of applications integrated with Acumatica ERP. These applications can perform data migration and data import, integration of Acumatica ERP with external systems, and execution of long-running operations. {br}

You can use the contract-based REST API, contract-based SOAP API, or screen-based SOAP API to access the same business logic as is accessed in the UI. All types of the web services APIs can be used with any customization applied to Acumatica ERP. The contract-based REST API supports the OpenAPI 2.0 (formerly known as Swagger 2.0) specification.{br}

For details on the web services APIs, see [HelpRoot_Dev_Integration\IS__con_CB_API|Contract-Based Web Services API] and [HelpRoot_Dev_Integration\IS__con_SB_API|Screen-Based Web Services API].{br}

 Acumatica ERP supports the OAuth 2.0 mechanism of authorization for add-on applications that interact with Acumatica ERP through application programming interfaces (APIs). For details on the authorization of applications, see [HelpRoot_Dev_Integration\IS__mng_Authorizing_with_OAuth2|Authorizing Client Applications to Work with Acumatica ERP].
==Mobile API==
 Acumatica ERP provides the Acumatica mobile application, which allows a user to work with Acumatica ERP through the mobile devices. You can customize the mobile application by using the mobile API. For details on the mobile API, see [HelpRoot_Dev_Mobile\Mobile_Framework_Guide|Working with Mobile Framework].
==Related Articles==
*[https://adn.acumatica.com/| Acumatica Developer Network]]]></column>
			<column name="PlainText"><![CDATA[ Acumatica Cloud xRP                         PlatformThe  Acumatica Cloud xRP                         Platform         is the platform provided by  Acumatica that is used to build the  Acumatica ERP application itself, any customizations of  Acumatica ERP, the mobile application for  Acumatica ERP, and applications integrated with  Acumatica ERP through the web services API. The  Acumatica Cloud xRP                         Platform         consists of a number of components, which are highlighted with light blue in the following         diagram. These components serve different purposes, which are described in detail in this         topic, and can be used either separately or combined to achieve your business purposes.  Acumatica Cloud xRP                         PlatformBasic Components and Tools The base of the  Acumatica Cloud xRP                         Platform         is formed by the components and tools that provide the basic application functionality, such         as multitenancy support, role-based access, and localization tools. These components and         tools are available out-of-the-box in  Acumatica ERP, any embedded in  Acumatica ERP applications, or applications based purely on  Acumatica Framework         applications. This means that you do not need to worry about implementing mechanisms similar         to these components during the design or programming of your application based on the  Acumatica Cloud xRP                         Platform.   Acumatica Cloud xRP                         Platform         contains the basic components and tools listed in the following table. Component or Tool Description Role-based access A set of components responsible for user authorization, access rights                   verification, and audit on the data access and business logic levels. For more                   information, see  User Roles: General Information in the                   System Administration Guide. Multitenancy A component responsible for hosting multiple tenants on a single application                   server. For details about multitenancy, see  Support of Multiple Tenants in the User                   Guide. Localization tools The tools that help you to perform the localization of the application to                   multiple languages. For more information about localization, see  Translation Process. Help management system The integrated wiki-based help content editing, management, and search                   system. For details about the help management system, see  Wiki Overview. Document management system The integrated document storage and management system. For details, see  Managing Attached Files.  Report DesignerA separate utility (which can be installed along with  Acumatica ERP or  Acumatica Framework) that you can use to design custom reports. For details on this tool, see   Acumatica Report                         Designer Guide.   Acumatica Framework Acumatica Framework         provides the platform API, web controls, and other tools for the development of the UI and         business logic of an ERP application. The platform API is used for the development of  Acumatica ERP and any embedded applications (that is, customizations of  Acumatica ERP).  Acumatica Framework         can also be used to develop an ERP application from scratch. You can find detailed         information about the development of applications with  Acumatica Framework         in this guide.  Acumatica Framework consists of the development tools listed in the following table. Component Description Platform API The API for implementing application business logic. Web controls A set of web controls implementing access to business logic through the web                   UI. Template application The application and database structures providing frameset, layout, and                   navigation services. You can deploy a template application along with the template                   website by using the  Acumatica Framework                             Configuration Wizard. Visual Studio templates The project template for the creation of a new application and a set of page                   templates that automate the creation of typical page layouts. Application creation wizards A set of components to automate the creation of the application data access                   classes from the database tables and the web forms during application                   development. For details about the development tools, see   Acumatica Framework Development Tools.  Acuminator Acuminator is a static code analysis and colorizer tool for Visual Studio that simplifies         development with  Acumatica Frameworkthe P . Acuminator provides diagnostics and code fixes for common developer         challenges related to the platform API. Also, Acuminator can colorize and format business         query language (BQL) statements, and can collapse attributes and parts of BQL queries. You         can find related information and download Acuminator at  Visual Studio Marketplace Visual Studio Marketplace.   Acumatica Customization           Platform Acumatica Customization           Platform provides customization tools for the development of applications embedded in  Acumatica ERP. Developers that work with  Acumatica Customization           Platform use the platform API provided by  Acumatica Framework.  With  Acumatica Customization           Platform, you can perform end-customer customizations and create complex solutions for multiple         customers. In these customizations, you can modify the user interface, business logic, and         database schema without recompilation and re-installation of the application. Customizations         are stored separately from the core application code as metadata and can be modified,         exported, or imported. Because customizations are stored separately, they are preserved with         the updates and upgrades of the core application. For details on  Acumatica Customization           Platform, see   Acumatica Customization             Platform. Web Services APIs The  Acumatica Cloud xRP                         Platform         provides multiple types of web services APIs for development of applications integrated with            Acumatica ERP. These applications can perform data migration and data import, integration of  Acumatica ERP with external systems, and execution of long-running operations.  You can use the contract-based REST API, contract-based SOAP API, or screen-based SOAP API         to access the same business logic as is accessed in the UI. All types of the web services         APIs can be used with any customization applied to  Acumatica ERP. The contract-based REST API supports the OpenAPI 2.0 (formerly known as Swagger 2.0)         specification. For details on the web services APIs, see  Contract-Based Web Services API         and  Screen-Based Web Services API.  Acumatica ERP supports the OAuth 2.0 mechanism of authorization for add-on applications that interact         with  Acumatica ERP through application programming interfaces (APIs). For details on the authorization of         applications, see  Authorizing Client Applications to Work with Acumatica ERP. Mobile API  Acumatica ERP provides the  Acumatica mobile application, which allows a user to work with  Acumatica ERP through the mobile devices. You can customize the mobile application by using the mobile         API. For details on the mobile API, see  Working with Mobile Framework.  Acumatica Developer Network ]]></column>
		</row>
		<row PageID="b9392b01-5b47-4cce-b498-7aa08bcdf9fb" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="df3dc4b3-e400-05cc-50e6-b3d53c8f0b1a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can find a detailed description of the development tools provided with Acumatica Framework.{br}{TOC}
==Platform API==
The Platform API provided with Acumatica Framework is an event-driven programming API, which is traditional in rich GUI applications. This model covers database access, business logic, GUI behavior, and error handling. All coding is done with only C#.{br}

The following code gives an example of the business logic implemented in the business logic controller: The code updates the receipt total when one of the transactions related to the receipt is updated.<source lang="csharp">public virtual void DocTransation_RowUpdated(PXCache cache,
                                             PXRowUpdatedEventArgs e)
{
    DocTransaction old = e.OldRow as DocTransaction;
    DocTransaction trn = e.Row as DocTransaction;
    if ((trn != null) && (trn.TranQty != old.TranQty ||
                                   trn.UnitPrice != old.UnitPrice))
    {
        Document doc = Receipts.Current;
        if (doc != null)
        {
            doc.TotalAmt -= old.TranQty * old.UnitPrice;
            doc.TotalAmt += trn.TranQty * trn.UnitPrice;
            Receipts.Update(doc);
        }
    }
}</source>
When a user selects a document transaction in the table on a form and updates the settings of the transaction, the <tt>RowUpdated</tt> event is triggered, and the code above is executed and updates the receipt total, as shown in the following screenshots. [anchor|#_cebc9952-0bb1-4ca0-88fd-4e7a814cfce7][anchor|#_1f50b1e7-4d61-485b-88a4-56a6b68f2ff1][image:StudioDeveloperGuide/Images/OV_Total_Update_Code.png|popup|Update of document transaction details|450px]
==Visual Web Designer Support==
The Acumatica Framework Integrated Development Environment (IDE) is built on top of Microsoft Visual Studio. However, the Acumatica Framework IDE implements its own set of web controls to generate an advanced GUI in a web browser.{br}

All of Acumatica Framework&rsquo;s web controls have the same rendering and a similar appearance in design mode in the IDE and runtime mode in a web browser. Thus, the developer can utilize all the facilities of the Visual Web Designer component of Visual Studio. The application developer can use the convenient drag-and-drop mechanism to create an application form layout, to perform form visual editing, and to set a control&rsquo;s properties and behavior through an intuitive graphical interface. This approach does not require any knowledge of HTML or Java Script, yet allows the developer to create a professional and appealing web GUI.{br}

The following screenshots illustrate the design (left) and runtime (right) rendering.[image:StudioDeveloperGuide/Images/OV_WebForm_Desing_vs_Runtime.png|popup|ASPX page in design and runtime mode|450px]
==Master Pages, Templates, and CSS Support==
The Visual Studio project and item templates provide reusable and customizable project and item stubs that accelerate the development process, removing the need to create new projects and items from scratch. Project templates provide the basic files needed for a particular project type, include standard assembly references, and set the default project properties and compiler options.{br}

 Acumatica Framework distribution includes the following:
*The project template for the creation of a new application
*A set of page templates that automate the creation of typical page layouts

The master pages mechanism in ASP.NET allows for the creation of an application that looks and feels consistent. Master pages define the standard appearance and behavior that is common in all application pages. You create individual content pages that refer to the master page. When a content page is requested, it merges with the master page to produce output that combines the layout and base functionality of the master page with the content of the requested page.{br}

 Acumatica Framework fully supports the master pages mechanism and provides you with a set of predefined master pages. You can design your own master pages or modify existing ones.{br}

A web application written with Acumatica Framework supports style modification through Cascading Style Sheets (CSS).
==Application Creation Wizards==
 Acumatica Framework provides a set of wizards for automating the creation of data access classes and webpages. The use of these wizards eliminates the manual steps associated with data access class creation and data binding configuration.{br}

The Data Access Class Generator, which is shown in the following screenshot, provides the application developer with a way to create and modify data access classes. It implements the following functionality:
*Reading the data structure from a table, SQL query, or external data source
*Creating a data access class based on the data structure received from external data source
*Reading the data access class structure from its definition and merging this structure with the data structure received from the external data source
*Automatic mapping of application-specific attributes based on the names of the properties of the external data source 
[anchor|#_f3a94ebc-6d36-4807-8b04-2d4f3ec2f8e7][anchor|#_f5a9563e-a781-4f18-a1b0-18a2a2641b26][image:StudioDeveloperGuide/Images/OV_DAC_Generator.png|popup|Data Access Class Generator|300px]
The Layout Editor, which is shown in the following screenshot, automates the creation of new web forms. It uses metadata stored in the business logic controller and data access class to help the application developer create new web forms or to modify existing ones. The '''Layout Editor''' wizard implements the following features:
*Reading metadata from the business logic controller and the data access class and creating a list of controls that could be added to the webpage
*Adding the controls selected by the programmer to the webpage
*Updating the webpage controls with the changed business logic controller and the data access class metadata
[anchor|#_636c8110-aa22-48ee-853a-0584b5fb1f7a][anchor|#_a1010986-a148-4a1a-93b2-d58499a619af][image:StudioDeveloperGuide/Images/OV_Layout_Editor.png|popup|Layout Editor|300px]]]></column>
			<column name="PlainText"><![CDATA[ Acumatica Framework         Development Tools In this topic, you can find a detailed description of the development tools provided                 with  Acumatica Framework. Platform API The Platform API provided with  Acumatica Framework is an event-driven programming API, which is traditional in rich GUI                 applications. This model covers database access, business logic, GUI behavior, and                 error handling. All coding is done with only C#. The following code gives an example of the business logic implemented in the business                 logic controller: The code updates the receipt total when one of the transactions                 related to the receipt is updated. public virtual void DocTransation_RowUpdated(PXCache cache,
                                             PXRowUpdatedEventArgs e)
{
    DocTransaction old = e.OldRow as DocTransaction;
    DocTransaction trn = e.Row as DocTransaction;
    if ((trn != null) && (trn.TranQty != old.TranQty ||
                                   trn.UnitPrice != old.UnitPrice))
    {
        Document doc = Receipts.Current;
        if (doc != null)
        {
            doc.TotalAmt -= old.TranQty * old.UnitPrice;
            doc.TotalAmt += trn.TranQty * trn.UnitPrice;
            Receipts.Update(doc);
        }
    }
} When a user selects a document transaction in the table on a form and updates the                 settings of the transaction, the  RowUpdated  event is triggered,                 and the code above is executed and updates the receipt total, as shown in the                 following screenshots.  Update of document transaction details Visual Web Designer Support The  Acumatica Framework Integrated Development Environment (IDE) is built on top of Microsoft Visual                 Studio. However, the  Acumatica Framework IDE implements its own set of web controls to generate an advanced GUI in a web                 browser. All of  Acumatica Framework's web controls have the same rendering and a similar appearance in design mode in                 the IDE and runtime mode in a web browser. Thus, the developer can utilize all the                 facilities of the Visual Web Designer component of Visual Studio. The application                 developer can use the convenient drag-and-drop mechanism to create an application                 form layout, to perform form visual editing, and to set a control's properties and                 behavior through an intuitive graphical interface. This approach does not require                 any knowledge of HTML or Java Script, yet allows the developer to create a                 professional and appealing web GUI. The following screenshots illustrate the design (left) and runtime (right) rendering. ASPX page in design and runtime mode Master Pages, Templates, and CSS Support The Visual Studio project and item templates provide reusable and customizable project and                 item stubs that accelerate the development process, removing the need to create new                 projects and items from scratch. Project templates provide the basic files needed                 for a particular project type, include standard assembly references, and set the                 default project properties and compiler options.  Acumatica Framework distribution includes the following: The project template for the creation of a new application A set of page templates that automate the creation of typical page layouts The master pages mechanism in ASP.NET allows for the creation of an application that looks                 and feels consistent. Master pages define the standard appearance and behavior that                 is common in all application pages. You create individual content pages that refer                 to the master page. When a content page is requested, it merges with the master page                 to produce output that combines the layout and base functionality of the master page                 with the content of the requested page.  Acumatica Framework fully supports the master pages mechanism and provides you with a set of                 predefined master pages. You can design your own master pages or modify existing                 ones. A web application written with  Acumatica Framework         supports style modification through Cascading Style Sheets (CSS). Application Creation Wizards  Acumatica Framework                 provides a set of wizards for automating the creation of data access classes and                 webpages. The use of these wizards eliminates the manual steps associated with data                 access class creation and data binding configuration. The Data Access Class Generator, which is shown in the following screenshot, provides the                 application developer with a way to create and modify data access classes. It                 implements the following functionality: Reading the data structure from a table, SQL query, or external data source Creating a data access class based on the data structure received from external data                     source Reading the data access class structure from its definition and merging this structure                     with the data structure received from the external data source Automatic mapping of application-specific attributes based on the names of the properties                     of the external data source  Data Access Class Generator The Layout Editor, which is shown in the following screenshot, automates the creation of new                 web forms. It uses metadata stored in the business logic controller and data access                 class to help the application developer create new web forms or to modify existing                 ones. The  Layout Editor  wizard implements the following                 features: Reading metadata from the business logic controller and the data access class and creating a                     list of controls that could be added to the webpage Adding the controls selected by the programmer to the webpage Updating the webpage controls with the changed business logic controller and the data                     access class metadata Layout Editor ]]></column>
		</row>
		<row PageID="6c91a5d7-70d6-4a7e-9cfd-7d59faeae258" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="48bac540-05c2-573d-93fa-4959e7418f64" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can review the architecture of an application created based on Acumatica Framework, such as Acumatica ERP, customizations of Acumatica ERP, and applications based purely on Acumatica Framework.[anchor|#_3e7762ed-d1bf-4da9-bb7e-ef10bb94a0a6]{br}

An application written with Acumatica Framework has ''n''-tier architecture with a clear separation of the presentation, business, and data access layers, as shown in the following diagram. You can find details about each layer in the sections below.[anchor|#_df411c1a-d588-4f86-ad56-95e0d904d586][anchor|#_0f225d17-073c-4fbc-9602-15e70692d4da][image:Shared/Images/diag_ApplicationArchitecture.png|popup|450px]{br}{TOC}
==Data Access Layer==[anchor|#_08336ffb-9381-4ff0-ac0c-09c44ba3c817]
The data access layer of an application written using Acumatica Framework is implemented as a set of data access classes (DACs) that wrap data from database tables or data received through other external sources (such as Amazon Web Services). [anchor|#_125cc658-a933-4050-b0d1-cc072c846486]{br}

The instances of data access classes are maintained by the business logic layer. Between requests, these instances are stored in the session. On a standalone Acumatica ERP server, session data is stored in the server memory. In a cluster of application servers, session data is serialized and stored in a high-performance remote server through a custom optimized serialization mechanism. {br}

For details about data storage in session, see [HelpRoot_Dev_Platform\AD__con_Session|Session]. For details on working with the data access layer, see [HelpRoot_Dev_Platform\AD__mng|Accessing Data].
==Business Logic Layer==[anchor|#_b2f0da12-75da-49b8-8175-88c91c117f32]
The business logic is implemented though the business logic controller (also called ''graph''). Graphs are classes that you derive from the special API class (<tt>PXGraph</tt>) and that are tied to one or more data access classes.[anchor|#_0a352c72-a574-4b53-95c9-9260c5df0595]{br}

Each graph conceptually consists of two parts: [anchor|#_450887f4-dfdc-407a-9a26-47fbe3fd26da]
*Data views, which include the references to the required data access classes, their relationships, and other meta information 
*Business logic, which consists of actions and events associated with the modified data. 
[anchor|#_3cd841a7-5258-4bfd-8732-806552cc421c]{br}

Each graph can be accessed from the presentation layer or from the application code that is implemented within another graph. When the graph receives an execution request, it extracts the data required for request execution from the data access classes included in the data views, triggers business logic execution, returns the result of the execution to the requesting party, and updates the data access classes instances with the modified data.{br}

For details on working with the business logic layer, see [HelpRoot_Dev_Platform\BL__mng|Implementing Business Logic].
==Presentation Layer==[anchor|#_9b640b7d-ef45-4703-8773-da15097ffc28]
The presentation layer provides access to the application business logic through the UI, web services, and Acumatica mobile application. The presentation layer is completely declarative and contains no business logic.[anchor|#_e7b13402-173a-4b78-bad3-518b86614315]{br}

The UI consists of ASPX webpages (which are based on the ASP.NET Web Forms technology) and reports created with Acumatica Report                         Designer. The ASPX webpages are bound to particular graphs. [anchor|#_462f90cd-19ec-4d49-a46b-1c5a0e249744]{br}

When the user requests a new webpage, the presentation layer is responsible for processing this request. Webpages are used for generating static HTML page content and providing additional service information required for the dynamic configuration of the web controls. When the user receives the requested page and starts browsing or entering data, the presentation layer is responsible for handling asynchronous HTTP requests. During processing, the presentation layer submits a request to the business logic layer for execution. Once execution is completed, the business logic layer analyzes any changes in the graph state and generates the response that is sent back to the browser as an XML document.{br}

For details on the configuration of ASPX webpages, see [HelpRoot_Dev_Platform\CW__mng|Configuring ASPX Pages and Reports].{br}

Web services and mobile app pages provide alternative interfaces to the application business logic. From the side of the graph, a request from a webpage, the web services, or an mobile app page are identical and, thus, cause the execution of exactly the same business logic. ]]></column>
			<column name="PlainText"><![CDATA[Runtime Architecture of an Application Based on  Acumatica FrameworkIn this topic, you can review the architecture of an application created based on  Acumatica Framework, such as  Acumatica ERP, customizations of  Acumatica ERP, and applications based purely on  Acumatica Framework. An application written with  Acumatica Framework has  n -tier architecture with a clear separation of the presentation, business, and data access layers, as shown in the following diagram. You can find details about each layer in the sections below. Data Access Layer The data access layer of an application written using  Acumatica Framework is implemented as a set of data access classes (DACs) that wrap data from database tables or data received through other external sources (such as Amazon Web Services).  The instances of data access classes are maintained by the business logic layer. Between requests, these instances are stored in the session. On a standalone  Acumatica ERP server, session data is stored in the server memory. In a cluster of application servers, session data is serialized and stored in a high-performance remote server through a custom optimized serialization mechanism.  For details about data storage in session, see  Session.                 For details on working with the data access layer, see  Accessing Data. Business Logic Layer The business logic is implemented though the business logic controller (also called  graph ). Graphs are classes that you derive from the special API class ( PXGraph ) and that are tied to one or more data access classes. Each graph conceptually consists of two parts:  Data views, which include the references to the required data access classes, their relationships, and other meta information  Business logic, which consists of actions and events associated with the modified data.  Each graph can be accessed from the presentation layer or from the application code that is implemented within another graph. When the graph receives an execution request, it extracts the data required for request execution from the data access classes included in the data views, triggers business logic execution, returns the result of the execution to the requesting party, and updates the data access classes instances with the modified data. For details on working with the business logic layer, see  Implementing Business Logic. Presentation Layer The presentation layer provides access to the application business logic through the UI, web services, and  Acumatica mobile application. The presentation layer is completely declarative and contains no business logic. The UI consists of ASPX webpages (which are based on the ASP.NET Web Forms technology) and reports created with  Acumatica Report                         Designer. The ASPX webpages are bound to particular graphs.  When the user requests a new webpage, the presentation layer is responsible for processing this request. Webpages are used for generating static HTML page content and providing additional service information required for the dynamic configuration of the web controls. When the user receives the requested page and starts browsing or entering data, the presentation layer is responsible for handling asynchronous HTTP requests. During processing, the presentation layer submits a request to the business logic layer for execution. Once execution is completed, the business logic layer analyzes any changes in the graph state and generates the response that is sent back to the browser as an XML document. For details on the configuration of ASPX webpages, see  Configuring ASPX Pages and Reports. Web services and mobile app pages provide alternative interfaces to the application business                 logic. From the side of the graph, a request from a webpage, the web services, or an                 mobile app page are identical and, thus, cause the execution of exactly the same                 business logic.  ]]></column>
		</row>
		<row PageID="009b7519-160a-4a00-9524-c74fa925b851" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="9bbb8e46-ae2d-3531-ea39-3790b03a3ed7" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this part of the guide, you can find the information that you may need to start development with Acumatica Framework.{br}{TOC}
==System Requirements==
You can find the full list of system requirements in [HelpRoot_Install\System_Requirements_Studio|System Requirements for Acumatica Framework 2020 R2] in the Installation Guide.
==Installation==
For detailed information about the installation of Acumatica Framework, see [HelpRoot_Install\Installing_Acumatica_Studio|Installing Acumatica Framework] in the Installation Guide.
==Application Design==
For the information about the design of the database structure and user interface of applications based on Acumatica Framework, see [HelpRoot_Dev_Platform\DA__mng|Designing the Application] in this guide.
==Development of the Application Code==
Before you begin developing application code, we recommend that you complete the following training courses:[anchor|#_c4b09d91-5ae4-4016-9910-7c17c6bde71f]
*[https://openuni.acumatica.com/courses/development/t100-introduction-to-acumatica-framework/|T100 Development: Introduction to Acumatica Framework]
* [https://openuni.acumatica.com/courses/development/t200-acumatica-framework-fundamentals/|T200 Development: Acumatica Framework Fundamentals]
{br}

For a quick overview of application programming, refer to the topics in this part of the guide.{br}

In the Acumatica Framework Guide, you can find reference information and additional information that is not covered in the training courses. This information is provided in the following parts of the guide:[anchor|#_d5347901-332e-44c9-912c-8fa0d71bd5f6]
*[HelpRoot_Dev_Platform\CW__mng|Configuring ASPX Pages and Reports]: About the development of ASPX pages 
*[HelpRoot_Dev_Platform\AD__mng|Accessing Data]: About business query language (BQL) and working with data in cache and session
*[HelpRoot_Dev_Platform\BL__mng|Implementing Business Logic]: About events, attributes, long-running operations, and other topics related to business logic development
*[HelpRoot_Dev_Platform\TS__mng|Troubleshooting Acumatica Framework-Based Applications]: About debugging the Acumatica Framework-based applications and fixing the common errors
{br}

For a detailed description of the Acumatica Framework API, see [https://help.acumatica.com/(W(16))/Main?ScreenId=ShowWiki&pageid=41f852ad-6736-e6fa-d080-006a9776ed78|API Reference].[anchor|#_d87022d9-2f30-4116-b673-c4ff24617483]
==Website Management==
If you want to modify the position of a form in the UI, add a form to a workspace, or remove a form from the UI, you configure the UI as described in [HelpRoot_Administration\AS__mng_User_Interface_Configuration|Customizing the User Interface] in the System Administration Guide.{br}

You need to grant access rights to each new form. For details on the configuration of access rights, see [HelpRoot_Administration\SA_Managing_User_Access_Mapref|Managing User Access] in the System Administration Guide.{br}

You can create help topics for any application you have developed with Acumatica Framework by using the built-in wiki-based content management system. For details on creating help topics, see [HelpRoot_Administration\DM__mng_Wikis|Managing Wikis].
==In This Part==[anchor|#_e01ad0b2-335f-442c-8afb-1d82964abed9]
*[HelpRoot_Dev_Platform\FGS__con_Data_Query|Data Querying]
*[HelpRoot_Dev_Platform\FGS__con_BLC_Declaration|Business Logic Controller Declaration]
*[HelpRoot_Dev_Platform\FGS__con_Data_View_and_Cache|Data View and Cache]
*[HelpRoot_Dev_Platform\FGS__con_Data_Modification_Scenarios|Data Modification Scenarios]
*[HelpRoot_Dev_Platform\FGS__con_Business_Logic_Implementation|Business Logic Implementation]
]]></column>
			<column name="PlainText"><![CDATA[Getting Started with  Acumatica FrameworkIn this part of the guide, you can find the information that you may need to start         development with  Acumatica Framework. System Requirements You can find the full list of system requirements in  System Requirements for Acumatica Framework 2020 R2 in the Installation         Guide. Installation For detailed information about the installation of  Acumatica Framework,         see  Installing Acumatica Framework in the Installation         Guide. Application Design For the information about the design of the database structure and user interface of         applications based on  Acumatica Framework,         see  Designing the Application in this guide. Development of the Application Code Before you begin developing application code, we recommend that you complete the following         training courses: T100 Development: Introduction to  Acumatica FrameworkT100 Development: Introduction to Acumatica FrameworkT200 Development:  Acumatica Framework Fundamentals T200 Development: Acumatica Framework FundamentalsFor a quick overview of application programming, refer to the topics in this part of the         guide. In the  Acumatica Framework         Guide, you can find reference information and additional information that is not covered in         the training courses. This information is provided in the following parts of the guide: Configuring ASPX Pages and Reports: About the development of ASPX pages  Accessing Data: About business query language (BQL) and working with data             in cache and session Implementing Business Logic: About events, attributes, long-running operations, and             other topics related to business logic development Troubleshooting Acumatica Framework-Based Applications: About debugging the  Acumatica Framework-based applications and fixing the common errors For a detailed description of the  Acumatica Framework         API, see  API Reference API Reference. Website Management If you want to modify the position of a form in the UI, add a form to a workspace, or         remove a form from the UI, you configure the UI as described in  Customizing the User Interface in the System         Administration Guide. You need to grant access rights to each new form. For details on the configuration of         access rights, see  Managing User Access in the System         Administration Guide. You can create help topics for any application you have developed with  Acumatica Framework         by using the built-in wiki-based content management system. For details on creating help         topics, see  Managing Wikis. In This Part Data QueryingBusiness Logic Controller DeclarationData View and CacheData Modification ScenariosBusiness Logic Implementation]]></column>
		</row>
		<row PageID="9241a976-e062-4978-be14-2c1135642be2" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="d3cd0de3-99d2-7b11-df3b-01cd04aaf5de" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#_17cef726-959d-4806-a751-20ae7033b817]
 Acumatica Framework provides a custom language called BQL (business query language) that developers can use for writing database queries. BQL is written in C# and based on generic class syntax, but is still very similar to SQL syntax.{br}

 Acumatica Framework provides two dialects of BQL: traditional BQL and fluent BQL. We recommend that you use fluent BQL because statements written in fluent BQL are simpler and shorter than the ones written with traditional BQL. Further in this topic, the examples are written in fluent BQL.{br}{TOC}((({S:Warn}You can also use LINQ to select records from the database or to apply additional filtering to the data of a BQL query. For details, see [HelpRoot_Dev_Platform\AD__mng_LINQ|Creating LINQ Queries].
)))[anchor|#_2b314137-fa36-4310-ac60-1104aa2ff6de]{br}

BQL has almost the same keywords as SQL does, and they are placed in the same order as they are in SQL, as shown in the following example of BQL.<source lang="csharp">SelectFrom&lt;Product&gt;.Where&lt;Product.availQty.IsNotNull.
        And&lt;Product.availQty.IsGreater&lt;Product.bookedQty&gt;&gt;&gt;</source>
If the database provider is Microsoft SQL Server, the framework translates this expression into the following SQL query.{{{{SELECT * FROM Product 
WHERE Product.AvailQty IS NOT NULL 
AND Product.AvailQty &gt; Product.BookedQty
}}}}
BQL extends several benefits to the application developer. It does not depend on the specifics of the database provider, and it is object-oriented and extendable. Another important benefit of BQL is compile-time syntax validation, which helps to prevent SQL syntax errors.{br}

Because BQL is implemented on top of generic classes, you need data types that represent database tables. In the context of Acumatica Framework, these types are called data access classes (DACs). As an example of a DAC, you would define the <tt>Product</tt> data access class as shown in the following code fragment to execute the SQL query from the previous code example.<source lang="csharp">using System;
using PX.Data;

// Types used in BQL statements should derive from special interfaces:
// table  is derived from IBqlTable, and column is derived from IBqlField.
[PXCacheName("Product")]
public class Product : PX.Data.IBqlTable
{
    // The property holding the ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }
    // The type used in BQL statements to reference the ProductID column
    public abstract class productID : PX.Data.BQL.BqlInt.Field&lt;productID&gt; { }

    // The property holding the AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
    // The type used in BQL statements to reference the AvailQty column
    public abstract class availQty : PX.Data.BQL.BqlDecimal.Field&lt;availQty&gt; { }

    // The property holding the BookedQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? BookedQty { get; set; }
    // The type used in BQL statements to reference the BookedQty column
    public abstract class bookedQty : PX.Data.BQL.BqlDecimal.Field&lt;bookedQty&gt; { }
}</source>
Each table field is declared in a data access class in two different ways, each for a different purpose: [anchor|#_4778fa6e-219f-45fb-ae7a-0080b0e3d42c]
*As a {{public virtual}} property (which is also referred to as a ''property field'') to hold the table field data
*As a {{public abstract}} class (which is also referred to as a ''class field'') to reference a field in the BQL command
{br}{TOC}{br}

If the DAC is bound to the database, it must have the same class name the database table has. DAC fields are bound to the database by means of data mapping attributes (such as <tt>PXDBIdentity</tt> and <tt>PXDBDecimal</tt>), using the same naming convention as fields in the database.{br}

The following code demonstrates an example of how to obtain data records from the database.{{{{// Select Product records
PXResultset&lt;Product&gt; res = SelectFrom&lt;Product&gt;.Where&lt;Product.availQty.IsNotNull.
        And&lt;Product.availQty.IsGreater&lt;Product.bookedQty&gt;&gt;&gt;.View.Select(graph);
// You can iterate through the result set
foreach(PXResult&lt;Product&gt; rec in res)
{
    // A record from the result set can be cast to the DAC
    Product p = (Product)rec;
    ...
}
}}}}
==Related Articles==
*[HelpRoot_Dev_Platform\AD__mng_Querying_Data|Querying Data in Acumatica Framework]]]></column>
			<column name="PlainText"><![CDATA[Data Querying  Acumatica Framework provides a custom language called  BQL (business query language)  that developers can use for writing database queries. BQL is written in C# and based on generic class syntax, but is still very similar to SQL syntax.  Acumatica Framework provides two                 dialects of BQL: traditional BQL and fluent BQL. We recommend that you use fluent                 BQL because statements written in fluent BQL are simpler and shorter than the ones                 written with traditional BQL. Further in this topic, the examples are written in                 fluent BQL. You can also use LINQ to select records from the database or to apply additional         filtering to the data of a BQL query. For details, see  Creating LINQ Queries. BQL has almost the same keywords as SQL does, and they are placed in the same order as they are in SQL, as shown in the following example of BQL. SelectFrom<Product>.Where<Product.availQty.IsNotNull.
        And<Product.availQty.IsGreater<Product.bookedQty>>> If the database provider is Microsoft SQL Server, the framework translates this expression into the following SQL query. SELECT * FROM Product 
WHERE Product.AvailQty IS NOT NULL 
AND Product.AvailQty > Product.BookedQty BQL extends several benefits to the application developer. It does not depend on the specifics of the database provider, and it is object-oriented and extendable. Another important benefit of BQL is compile-time syntax validation, which helps to prevent SQL syntax errors. Because BQL is implemented on top of generic classes, you need data types that represent database tables. In the context of  Acumatica Framework, these types are called  data access classes (DACs) . As an example of a DAC, you would define the  Product  data access class as shown in the following code fragment to execute the SQL query from the previous code example. using System;
using PX.Data;

// Types used in BQL statements should derive from special interfaces:
// table  is derived from IBqlTable, and column is derived from IBqlField.
[PXCacheName("Product")]
public class Product : PX.Data.IBqlTable
{
    // The property holding the ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }
    // The type used in BQL statements to reference the ProductID column
    public abstract class productID : PX.Data.BQL.BqlInt.Field<productID> { }

    // The property holding the AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
    // The type used in BQL statements to reference the AvailQty column
    public abstract class availQty : PX.Data.BQL.BqlDecimal.Field<availQty> { }

    // The property holding the BookedQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? BookedQty { get; set; }
    // The type used in BQL statements to reference the BookedQty column
    public abstract class bookedQty : PX.Data.BQL.BqlDecimal.Field<bookedQty> { }
} Each table field is declared in a data access class in two different ways, each for a different purpose:  As a  public virtual  property (which is also referred to as a  property                         field ) to hold the table field data As a  public abstract  class (which is also referred to as a  class                         field ) to reference a field in the BQL command If the DAC is bound to the database, it must have the same class name the database table         has. DAC fields are bound to the database by means of data mapping attributes (such as            PXDBIdentity  and  PXDBDecimal ), using the same naming         convention as fields in the database. The following code demonstrates an example of how to obtain data records from the         database. // Select Product records
PXResultset<Product> res = SelectFrom<Product>.Where<Product.availQty.IsNotNull.
        And<Product.availQty.IsGreater<Product.bookedQty>>>.View.Select(graph);
// You can iterate through the result set
foreach(PXResult<Product> rec in res)
{
    // A record from the result set can be cast to the DAC
    Product p = (Product)rec;
    ...
} ]]></column>
		</row>
		<row PageID="61e0a0e8-78e2-4ebf-a0f1-eae124a6283e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="29949027-afbc-13cb-e792-c4e7e0c3721c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Working with the business data in Acumatica Framework is implemented through the ''business logic controller'' object also referred as ''graph '' (graph is a mathematical term for a set of objects where some pairs of objects are connected by links). A graph provides the interface for the presentation logic to operate with the business data and relies on Data Access Layer components to store and retrieve the business data from the database.{br}

The following example shows the declaration of a simple business logic controller.<source lang="csharp">//Declaration of the graph
public class ProductMaint : PXGraph&lt;ProductMaint&gt;
{
    //Declaration of the data view
    public PXSelect&lt;Product&gt; Products;

    //Declaration of the actions
    public PXCancel&lt;Product&gt; Cancel;
    public PXSave&lt;Product&gt; Save;
}</source>
In this example, the graph contains the following members:[anchor|#ul_orv_lfq_tk]
*{{Products}}: The ''data view'' that can be used for querying and modifying the data 
*{{Cancel}}: The ''action'' that discard all the changes made to the data and reloads it from the database
*{{Save}}: The ''action'' that commits the changes made to the data to the database and then reloads the committed data
]]></column>
			<column name="PlainText"><![CDATA[Business Logic Controller Declaration Working with the business data in  Acumatica Framework         is implemented through the  business logic controller  object also referred as  graph           (graph is a mathematical term for a set of objects where some pairs of objects are         connected by links). A graph provides the interface for the presentation logic to operate         with the business data and relies on Data Access Layer components to store and retrieve the         business data from the database. The following example shows the declaration of a simple business logic controller. //Declaration of the graph
public class ProductMaint : PXGraph<ProductMaint>
{
    //Declaration of the data view
    public PXSelect<Product> Products;

    //Declaration of the actions
    public PXCancel<Product> Cancel;
    public PXSave<Product> Save;
} In this example, the graph contains the following members: Products : The  data view  that can be used for querying and           modifying the data  Cancel : The  action  that discard all the changes made to the data           and reloads it from the database Save : The  action  that commits the changes made to the data to           the database and then reloads the committed data ]]></column>
		</row>
		<row PageID="cd8f9db9-2965-4ce4-9ae8-4714898fdc44" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ebed89d0-80c7-09d4-1d25-ca44f0fbfc1b" RecordSourceID="22377">
			<column name="Content"><![CDATA[Data views implement the interfaces for querying the data from the database and submitting modified data to the cache. 
Data views are declared in business logic controllers as public fields of <tt>PXSelectBase</tt>-derived type. The following data view declaration uses the <tt>SelectFrom&lt;Type&gt;.View</tt> class, which is derived from <tt>PXSelectBase</tt>.<source lang="csharp">public SelectFrom&lt;Product&gt;.View Products;</source>
The data view type is a business query language (BQL) statement that selects data to be manipulated through the data view. The main DAC of a data view is the first type parameter in the declaration. The data view that is specified as the primary view for the ASPX page must be defined the first one in the graph. For details about, BQL, see [HelpRoot_Dev_Platform\AD__mng_Querying_Data|Querying Data in Acumatica Framework].{br}

Based on this declaration, the system automatically instantiates the DAC cache.{br}

A ''DAC cache'' object in the Acumatica Framework is the primary interface for working with individual records from the graph business logic. It has two components and two primary responsibilities:[anchor|#ul_f3y_4fq_tk]
*The <tt>Cached</tt> collection: In-memory cache that contains modified entity records. The <tt>Cached</tt> collection is instantiated based on the corresponding DAC declaration and managed by the cache.
*The controller: The cache component that implements basic CRUD (create, read, update, delete) operations on the <tt>Cached</tt> collection and triggers a sequence of data manipulation events when modifying or accessing the data in the <tt>Cached</tt> collection. These events can be later subscribed from the graph to implement the business logic associated with the data modification.

The diagram below shows the internal graph structure and responsibilities of the data view and the cache.[anchor|#_95dbe30c-8feb-4f68-88f4-6093a92ffa5a][anchor|#image_t3d_csq_tk][image:StudioDeveloperGuide/Images/GraphStructure.png|popup|The graph structure|320px]
==Master-Detail Relationship Between Data Views==
The framework executes data views in the order requested by the form. You don&rsquo;t have to execute a data view explicitly to retrieve data for the UI.{br}

The following code shows the declaration of two data views.<source lang="csharp">public SelectFrom&lt;SalesOrder&gt;.View Orders;
public SelectFrom&lt;OrderLine&gt;.
           Where&lt;OrderLine.orderNbr.
               IsEqual&lt;SalesOrder.orderNbr.FromCurrent&gt;&gt;.View OrderDetails;</source>{br}

In this example, the framework first executes the {{Orders}} data view to retrieve the master data record, and then executes the {{OrderDetails}} data view. To pass the {{OrderNbr}} field value as a parameter to the {{OrderDetails}} data view, we use the <tt>Current</tt> property of the cache that keeps the data record that is currently selected in the UI. Thus the last data record retrieved by the {{Orders}} data view is available through the <tt>Current</tt> property of the cache. (But we expect to have only one master record available at a time.) Also, when you create the new master data record, it also gets available through the <tt>Current</tt> property of the cache.{br}

If the <tt>Current</tt> property is null or the field value is null, the parameter is replaced by the default value.
==Related Articles==
*[HelpRoot_Dev_Platform\AD__mng_Querying_Data|Querying Data in Acumatica Framework]]]></column>
			<column name="PlainText"><![CDATA[Data View and Cache Data views implement the interfaces for querying the data from the database and       submitting modified data to the cache.  Data views are declared in business logic         controllers as public fields of  PXSelectBase -derived type. The following         data view declaration uses the  SelectFrom<Type>.View  class, which is         derived from          PXSelectBase . public SelectFrom<Product>.View Products; The         data view type is a business query language (BQL) statement that selects data to be         manipulated through the data view. The main DAC of a data view is the first type parameter         in the declaration. The data view that is specified as the primary view for the ASPX page must be         defined the first one in the graph. For details about, BQL, see  Querying Data in Acumatica Framework. Based on this declaration, the system         automatically instantiates the DAC cache. A  DAC cache  object in the  Acumatica Framework         is the primary interface for working with individual records from the graph business logic.         It has two components and two primary responsibilities: The  Cached  collection: In-memory cache that contains modified entity           records. The  Cached  collection is instantiated based on the           corresponding DAC declaration and managed by the cache. The controller: The cache component that implements basic CRUD (create, read, update,           delete) operations on the  Cached  collection and triggers a sequence of           data manipulation events when modifying or accessing the data in the              Cached  collection. These events can be later subscribed from the           graph to implement the business logic associated with the data modification. The diagram below shows the internal graph structure and responsibilities of the data         view and the cache. The graph structure Master-Detail Relationship Between Data Views The framework executes data views in the order requested by the form. You don't have to         execute a data view explicitly to retrieve data for the UI. The following code shows the declaration of two data         views. public SelectFrom<SalesOrder>.View Orders;
public SelectFrom<OrderLine>.
           Where<OrderLine.orderNbr.
               IsEqual<SalesOrder.orderNbr.FromCurrent>>.View OrderDetails; In this example, the framework first executes the  Orders  data view to         retrieve the master data record, and then executes the  OrderDetails  data         view. To pass the  OrderNbr  field value as a parameter to the            OrderDetails  data view, we use the  Current  property of         the cache that keeps the data record that is currently selected in the UI. Thus the last         data record retrieved by the  Orders  data view is available through the            Current  property of the cache. (But we expect to have only one master         record available at a time.) Also, when you create the new master data record, it also gets         available through the  Current  property of the cache. If the  Current  property is null or the field value is null, the         parameter is replaced by the default value. ]]></column>
		</row>
		<row PageID="e6fb8c00-e144-489a-9648-d66ada46e67f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="80d516c9-aa7a-f9e8-7828-a02a3a0f8c0d" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can find the basic data manipulation scenarios that can be executed from the graph business logic or from the user interface. Entity data manipulation through the user interface indirectly invokes the same methods as the direct call from the business logic controller.{br}{TOC}
==Querying the Data for the First Time==
The data can be requested through the <tt>Select</tt> method of the data view. During this operation, the systems executes BQL command from the data view declaration. The data returned by the BQL command is passed to the requester. The following diagram illustrates this process.[anchor|#image_sry_k1r_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_FirstQuery.png|popup|Querying the data for the first time|450px]
==Updating an Existing Record==
An existing record can be updated through the <tt>Update(record)</tt> method of the data view. This method places the modified record into the cache. {br}

If the data record is not found in the <tt>Cached</tt> collection, the cache controller loads the data record from the database, adds it to the <tt>Cached</tt> collection, marks it as updated, and updates it with the new values. The search of the data record in the <tt>Cached</tt> collection and loading of the data record from the database is based on the DAC key fields. The diagram below illustrates this scenario.[anchor|#image_tyk_c3r_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_UpdateFirstTime.png|popup|Updating the record for the first time|450px]
If the updated record exists in the <tt>Cached</tt> collection the cache controller locates it and updates it with the new values. The diagram below illustrates this scenario.[anchor|#image_f3s_l3r_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_UpdateCached.png|popup|Updating the cached (previously modified) record|450px]
==Inserting a New Record==
A new record can be inserted into the cache through the <tt>Insert(record)</tt> method of the data view. The new inserted record is added to the <tt>Cached</tt> collection and marked as inserted. The diagram below illustrates this scenario.[anchor|#image_h2z_lkr_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_InsertNewRecord.png|popup|Inserting the new record|450px]
==Deleting an Existing Record==
An existing record can be deleted from the cache using the <tt>Delete(record)</tt> method, of the data view. {br}

If the data record is not found in the <tt>Cached</tt> collection, the cache controller loads the data record from the database, adds it to the <tt>Cached</tt> collection, and marks it as deleted. The search of the data record in the <tt>Cached</tt> collection and loading of the data record from the database is based on the DAC key fields. The diagram below illustrates this scenario.[anchor|#image_obg_4lr_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_DeleteNotCached.png|popup|Deleting the non-cached (unmodified) record|450px]
If the deleted record is found in the <tt>Cached</tt> collection, the cache controller locates it and marks as deleted. The diagram below illustrates this scenario.[anchor|#image_ghj_rlr_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_DeleteCached.png|popup|Deleting of the cached (previously modified) record|450px]
==Querying Updated Data==
The data can be modified and then queried again. In this scenario, the data records stored in the cache memory are merged with the result of the BQL command execution. Data record merge is based on DAC key fields. The final result of the <tt>Select()</tt> execution incorporates all the earlier record modifications that have not been preserved to the database yet. The diagram below illustrates this scenario.[anchor|#image_hk2_h4r_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_QueryUpdated.png|popup|Querying the modified data |450px]
==Persisting Changes to the Database==
When the data is modified, the system has two different versions of the data: the new one stored in the caches memory and the original one persisted in the database. At this point you have two options:[anchor|#ul_yg4_vfq_tk]
*Save the new version of data to the database using the <tt>Persist()</tt> method of the graph
*Discard all in-memory changes and load the original data version using the <tt>Clear()</tt> method of the graph

From the user interface these methods are called by invocation of the <tt>Save</tt> and <tt>Cancel</tt> actions. These actions are predefined and mapped to the <tt>Persist()</tt> and <tt>Clear()</tt> methods.{br}

The diagram below illustrated saving of the changes to the database.[anchor|#image_cjd_zqr_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_SaveChanges.png|popup|Saving the changes to the database|450px]
The diagram below illustrates discarding of all in-memory entity changes.[anchor|#image_xkc_gsr_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_DiscardChanges.png|popup|Discarding the changes and loading the original data|450px]
==Preserving the Data Version Between the Round Trips and Handling the Subsequent Selects from the Views==
It is important to understand that a graph is a stateless object. It is discarded after each data request. In order to preserve the modified data version between the requests, the cache controller serializes the <tt>Cached</tt> collection into the session state and restores it later when the graph is instantiated on the subsequent request. In this scenario, it is very important that the cache contains only the modified entity records, not the complete entity record set.
==Related Articles==
*[HelpRoot_Dev_Platform\AD__mng_Working_with_Cache_and_Session|Working with Data in Cache and Session]]]></column>
			<column name="PlainText"><![CDATA[Data Modification Scenarios In this topic, you can find the basic data manipulation scenarios that can be executed from         the graph business logic or from the user interface. Entity data manipulation through the         user interface indirectly invokes the same methods as the direct call from the business         logic controller. Querying the Data for the First Time The data can be requested through the  Select  method of the data view.         During this operation, the systems executes BQL command from the data view declaration. The         data returned by the BQL command is passed to the requester. The following diagram         illustrates this process. Querying the data for the first time Updating an Existing Record An existing record can be updated through the  Update(record)  method of the         data view. This method places the modified record into the cache.  If the data record is not found in the  Cached  collection, the cache         controller loads the data record from the database, adds it to the  Cached          collection, marks it as updated, and updates it with the new values. The search of the data         record in the  Cached  collection and loading of the data record from the         database is based on the DAC key fields. The diagram below illustrates this scenario. Updating the record for the first time If the updated record exists in the  Cached  collection the cache         controller locates it and updates it with the new values. The diagram below illustrates this         scenario. Updating the cached (previously modified) record Inserting a New Record A new record can be inserted into the cache through the  Insert(record)          method of the data view. The new inserted record is added to the  Cached          collection and marked as inserted. The diagram below illustrates this scenario. Inserting the new record Deleting an Existing Record An existing record can be deleted from the cache using the  Delete(record)          method, of the data view.  If the data record is not found in the  Cached  collection, the cache         controller loads the data record from the database, adds it to the  Cached          collection, and marks it as deleted. The search of the data record in the            Cached  collection and loading of the data record from the database is         based on the DAC key fields. The diagram below illustrates this scenario. Deleting the non-cached (unmodified) record If the deleted record is found in the  Cached  collection, the cache         controller locates it and marks as deleted. The diagram below illustrates this scenario. Deleting of the cached (previously modified) record Querying Updated Data The data can be modified and then queried again. In this scenario, the data records stored in         the cache memory are merged with the result of the BQL command execution. Data record merge         is based on DAC key fields. The final result of the  Select()  execution         incorporates all the earlier record modifications that have not been preserved to the         database yet. The diagram below illustrates this scenario. Querying the modified data  Persisting Changes to the Database When the data is modified, the system has two different versions of the data: the new one stored         in the caches memory and the original one persisted in the database. At this point you have         two options: Save the new version of data to the database using the  Persist()            method of the graph Discard all in-memory changes and load the original data version using the              Clear()  method of the graph From the user interface these methods are called by invocation of the  Save  and            Cancel  actions. These actions are predefined and mapped to the            Persist()  and  Clear()  methods. The diagram below illustrated saving of the changes to the database. Saving the changes to the database The diagram below illustrates discarding of all in-memory entity changes. Discarding the changes and loading the original data Preserving the Data Version Between the Round Trips and Handling the Subsequent Selects         from the Views It is important to understand that a graph is a stateless object. It is discarded after each         data request. In order to preserve the modified data version between the requests, the cache         controller serializes the  Cached  collection into the session state and         restores it later when the graph is instantiated on the subsequent request. In this         scenario, it is very important that the cache contains only the modified entity records, not         the complete entity record set. ]]></column>
		</row>
		<row PageID="b02bd27f-3e86-4210-9e0f-c0df7aa701d9" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="4c3eb8d0-4e76-bcb5-8ccc-ae4b044d68af" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The business logic of an Acumatica Framework-based application is implemented by overloading certain methods invoked by the system in the process of manipulating data. For such procedures as inserting a data record or updating a data record, the <tt>PXCache</tt> controllers generate series of events causing invocation of the methods called event handlers. {br}

The business logic can be divided into common logic relevant to different parts of the application and the logic specific to an application form (webpage). The common logic is implemented through event handler methods defined in attributes, while the form-specific logic is implemented as methods in the associated graph. {br}{TOC}
==Common Business Logic==
You implement the common business logic by defining event handlers in attributes. If such attribute is added to the declaration of a data access class, attribute logic is applied to the data records of this type for any graph used to access this table.{br}

There are a number of predefined attributes implemented in the framework. For example, in the following declaration of a data field for a column, the <tt>PXDBDecimal</tt> attribute binds this field to a database column of the decimal type. <source lang="csharp">[PXDBDecimal(2)]
public virtual string AvailQty { get; set; }</source>
The attributes that bind a field to a specific data type exist for most database data types.{br}

Another typical example of an attribute is <tt>PXUIField</tt>. It is used to configure the input control for the column in the user interface. This allows having the same visual representation of the column on all application screens (unless a screen redefines it). The following example shows the use of the <tt>PXUIField</tt> attribute.<source lang="csharp">[PXDBDecimal(2)]
[PXUIField(DisplayName = "Available Qty", Enabled = false)]
public virtual string AvailQty { get; set; }</source>
You can also defined your own attributes, as shown in the following code.<source lang="csharp">// Application-defined attribute that implements common business logic
public class MyAttribute : PXEventSubscriberAttribute,
                           IPX<i>EventName<i>Subscriber
{
    // An event handler
    protected virtual void <i>EventName<i>(PXCache sender,
                                     PX<i>RowEventName<i>EventArgs e)
    {
        ...
    }
    ...
}</source>
These custom attributes can also be added to the DAC declaration, as shown in the following example.<source lang="csharp">[PXDBDecimal(2)]
[PXUIField(DisplayName = "Available Qty", Enabled = false)]
[MyAttribute]
public virtual string AvailQty { get; set; }</source>
For details about attributes, see [HelpRoot_Dev_Platform\BL__mng_Working_With_Attributes|Working with Attributes].
==Screen-Specific Business Logic==
For a specific screen, the application can redefine the common logic or extend it. For this purpose, you should define event handlers in the graph associated with the screen. Each event handler method is tied to a particular table or a table field via the naming convention.{br}

For example, you can verify a value of a column as shown in the following code.<source lang="csharp">public class ProductRecalc : PXGraph&lt;ProductRecalc&gt;
{
    ...
    // Event handler verifying that the value of the AvailQty column
    // in Product records is greater than 0.
    // It is triggered when, for instance, a Product record is updated.
    protected virtual void Product_AvailQty_FieldVerifying(
        PXCache sender, 
        PXFieldVerifyingEventArgs e)
    {
        Product p = (Product)e.Row;
        if (p != null && p.AvailQty != null)
        {
            if (p.AvailQty &lt; 0)
                throw new PXSetPropertyException&lt;Product.availQty&gt;(
                    "Value must be greater than 0.");
        }
    }
}</source>
For details about events, see [HelpRoot_Dev_Platform\BL__mng_Working_With_Events|Working with Events].
==Related Articles==
*[HelpRoot_Dev_Platform\BL__mng|Implementing Business Logic]]]></column>
			<column name="PlainText"><![CDATA[Business Logic Implementation The business logic of an  Acumatica Framework-based application is implemented by overloading certain methods invoked by the system in         the process of manipulating data. For such procedures as inserting a data record or updating         a data record, the  PXCache  controllers generate series of events causing         invocation of the methods called event handlers.  The business logic can be divided into common logic relevant to different parts of the         application and the logic specific to an application form (webpage). The common logic is         implemented through event handler methods defined in attributes, while the form-specific         logic is implemented as methods in the associated graph.  Common Business Logic You implement the common business logic by defining event handlers in attributes. If such         attribute is added to the declaration of a data access class, attribute logic is applied to         the data records of this type for any graph used to access this table. There are a number of predefined attributes implemented in the framework. For example, in         the following declaration of a data field for a column, the  PXDBDecimal          attribute binds this field to a database column of the decimal type.  [PXDBDecimal(2)]
public virtual string AvailQty { get; set; } The attributes that bind a field to a specific data type exist for most database data         types. Another typical example of an attribute is  PXUIField . It is used to         configure the input control for the column in the user interface. This allows having the         same visual representation of the column on all application screens (unless a screen         redefines it). The following example shows the use of the  PXUIField          attribute. [PXDBDecimal(2)]
[PXUIField(DisplayName = "Available Qty", Enabled = false)]
public virtual string AvailQty { get; set; } You can also defined your own attributes, as shown in the following code. // Application-defined attribute that implements common business logic
public class MyAttribute : PXEventSubscriberAttribute,
                           IPX EventName Subscriber
{
    // An event handler
    protected virtual void  EventName (PXCache sender,
                                     PX RowEventName EventArgs e)
    {
        ...
    }
    ...
} These custom attributes can also be added to the DAC declaration, as shown in the following         example. [PXDBDecimal(2)]
[PXUIField(DisplayName = "Available Qty", Enabled = false)]
[MyAttribute]
public virtual string AvailQty { get; set; } For details about attributes, see  Working with Attributes. Screen-Specific Business Logic For a specific screen, the application can redefine the common logic or extend it. For this         purpose, you should define event handlers in the graph associated with the screen. Each         event handler method is tied to a particular table or a table field via the naming         convention. For example, you can verify a value of a column as shown in the following code. public class ProductRecalc : PXGraph<ProductRecalc>
{
    ...
    // Event handler verifying that the value of the AvailQty column
    // in Product records is greater than 0.
    // It is triggered when, for instance, a Product record is updated.
    protected virtual void Product_AvailQty_FieldVerifying(
        PXCache sender, 
        PXFieldVerifyingEventArgs e)
    {
        Product p = (Product)e.Row;
        if (p != null && p.AvailQty != null)
        {
            if (p.AvailQty < 0)
                throw new PXSetPropertyException<Product.availQty>(
                    "Value must be greater than 0.");
        }
    }
} For details about events, see  Working with Events. ]]></column>
		</row>
		<row PageID="7e631d16-e6c2-4d16-bc39-10d2d6780110" Language="en-US" PageRevisionID="1" PlainText="Designing the Application During the development of  Acumatica Framework-based     applications, you have to perform the following steps of application design: Analyze the requirements, plan the entity model of the application. Prepare the database schema and the data access class design. Plan the forms that provide the user interface of the application. You create application      forms from specific  Acumatica Framework form      templates. Plan the business logic controller (also referred as graph) for each form, which encapsulate      business processes and use-cases that should be implemented in the application. Each of these steps is iterated for multiple times as the development is progress. This part of the guide contains the design guidelines for the database schema and applications     built on  Acumatica Framework. In This Part Designing the Database Structure and DACsDesigning the User InterfaceNaming the Graphs and Event Handlers" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="5eac4e09-0542-aec3-7a84-78fed97eae44" RecordSourceID="22377">
			<column name="Content"><![CDATA[
During the development of Acumatica Framework-based applications, you have to perform the following steps of application design:[anchor|#ul_gdb_3ql_rl]
*Analyze the requirements, plan the entity model of the application.
*Prepare the database schema and the data access class design.
*Plan the forms that provide the user interface of the application. You create application forms from specific Acumatica Framework form templates.
*Plan the business logic controller (also referred as graph) for each form, which encapsulate business processes and use-cases that should be implemented in the application.

Each of these steps is iterated for multiple times as the development is progress.{br}

This part of the guide contains the design guidelines for the database schema and applications built on Acumatica Framework.
==In This Part==[anchor|#ul_rkc_brc_kk]
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]
*[HelpRoot_Dev_Platform\DA__mng_Designing_UI|Designing the User Interface]
*[HelpRoot_Dev_Platform\DA__mng_Code_Guidelines|Naming the Graphs and Event Handlers]
]]></column>
		</row>
		<row PageID="5659adfe-3e4a-45a6-a94a-a33c2f955194" Language="en-US" PageRevisionID="1" PlainText="Designing the Database Structure and DACs This chapter covers the main aspects of database design used in  Acumatica Framework. In This Chapter System and Application TablesTable and Column Naming ConventionsCommon Columns and Data TypesPrimary KeyForeign Keys and Nullable ColumnsAudit FieldsConcurrent Update ControlAttachment of Additional Objects to Data RecordsPreservation of Deleted RecordsMultitenancy Support" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="4a9f5caa-387c-4f27-1355-606d47f23eee" RecordSourceID="22377">
			<column name="Content"><![CDATA[
This chapter covers the main aspects of database design used in Acumatica Framework.
==In This Chapter==[anchor|#_79f1288c-0301-40f8-bdb3-721fc20ca34c]
*[HelpRoot_Dev_Platform\DA__con_System_Application_Tables|System and Application Tables]
*[HelpRoot_Dev_Platform\DA__con_Table_Column_Naming_Conventions|Table and Column Naming Conventions]
*[HelpRoot_Dev_Platform\DA__con_Common_Columns_and_Types|Common Columns and Data Types]
*[HelpRoot_Dev_Platform\DA__con_Primary_Key|Primary Key]
*[HelpRoot_Dev_Platform\DA__con_Foreign_Keys|Foreign Keys and Nullable Columns]
*[HelpRoot_Dev_Platform\DA__con_Audit_Fields|Audit Fields]
*[HelpRoot_Dev_Platform\DA__con_Concurrent_Update_Control|Concurrent Update Control]
*[HelpRoot_Dev_Platform\DA__con_Attachment_of_Objects_to_Records|Attachment of Additional Objects to Data Records]
*[HelpRoot_Dev_Platform\DA__con_Preservation_of_Deleted_Records|Preservation of Deleted Records]
*[HelpRoot_Dev_Platform\DA__con_Multitenancy_Support|Multitenancy Support]

==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_UI|Designing the User Interface]
*[HelpRoot_Dev_Platform\DA__mng_Code_Guidelines|Naming the Graphs and Event Handlers]]]></column>
		</row>
		<row PageID="509aefc2-387b-4284-8ff8-ad5fc9b725be" Language="en-US" PageRevisionID="1" PlainText="System and Application Tables The database of your  Acumatica Framework-based     application consists of the following tables: System tables: Those that are created by default for the application template and not used      to store your application data Application tables:  Acumatica ERP tables (which exist if you have implemented customization) and your own tables Do not add columns to system tables or modify them in any other way. Such modifications could     corrupt the application and would be lost during the next database upgrade.  Regarding your own application tables, you have to design and create the needed tables that     store your application data. You then map these application tables to data access classes (DACs)     that define the object model of the application. In one table, you can keep data records of     multiple entities, each of which is defined as a separate data access class in the application     object model. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="21057bac-d7a1-23fe-f1cc-284043629865" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The database of your Acumatica Framework-based application consists of the following tables:[anchor|#ul_orw_f2j_ml]
*System tables: Those that are created by default for the application template and not used to store your application data
*Application tables: Acumatica ERP tables (which exist if you have implemented customization) and your own tables

Do not add columns to system tables or modify them in any other way. Such modifications could corrupt the application and would be lost during the next database upgrade. {br}

Regarding your own application tables, you have to design and create the needed tables that store your application data. You then map these application tables to data access classes (DACs) that define the object model of the application. In one table, you can keep data records of multiple entities, each of which is defined as a separate data access class in the application object model.
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
		</row>
		<row PageID="74ee714c-b70a-4f67-8647-329c5b774b2c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="4dbde5de-d0ab-21cc-4ff1-e80a74b37b4e" RecordSourceID="22377">
			<column name="Content"><![CDATA[In this topic, you can learn how you should name tables and columns in a database that is used by an Acumatica Framework-based application.{br}{TOC}
==Table Naming Conventions==
When you are creating a table, you should consider the following suggestions regarding naming conventions:[anchor|#ul_bqq_gs4_ll]
*Make sure that table and column names are valid C# identifiers, because these names match the names of the classes and properties you declare in the application. Do not start a table or column name with a digit.
*Do not use the underscore symbol (&#95;) in table or column names, because it is a reserved symbol in Acumatica Framework. For example, {{TenantType}} is a valid column name, while {{Tenant_Type}} is invalid.
*Use singular nouns for table names. Typically, a table is mapped to a data access class that represents the entity. For instance, the {{SOShipment}} table contains data records that represent instances of the <tt>SOShipment</tt> entity. 
*:((({S:Warn}Acumatica Framework generates SQL statements with table and column names in the same letter case (that is, uppercase or lowercase) as the corresponding data access classes and fields are declared in the application. Also, the DAC Generator tool produces data access class declarations in the same letter case as the tables and columns are defined in the database schema.
)))
*Use two prefixes in table names: a two-letter tenant name and then a two-letter application module prefix. For example, the {{MTSVAppointment}} table can be used in the Services (SV) module for the MyTenant tenant (which corresponds to the ''MT'' prefix). These prefixes help to distinguish your application tables from Acumatica ERP tables and tables of other vendors if you create an add-on project or extension library.
*If you add a column to an Acumatica ERP table, start the column name with the ''Usr'' prefix followed by the two-letter tenant name. For instance, you could use {{UsrMTColumn}} for the column of the MyTenant tenant. In this case, the column will be preserved during upgrades. In your own application tables, there are no strict requirements to start column names with any prefixes.
*Be sure that custom indexes on Acumatica ERP tables start with the ''Usr'' prefix followed by the two-letter tenant name, so that the indexes will be preserved during upgrades.

==Column Naming Conventions==
We recommend that you use the following suffixes in column names:[anchor|#ul_bdq_14v_nl]
*''ID'' for surrogate keys, including database identity columns, such as {{CustomerID}}
*''CD'' for natural keys, such as {{CustomerCD}}
*''Nbr'' for numbering identifiers, such as {{OrderNbr}}
*''Price'' for prices, such as {{UnitPrice}}
*''Cost'' for costs, such as {{UnitCost}}
*''Amt'' for amounts, such as {{FreightAmt}}
*''Total'' for totals, such as {{OrderTotal}}
*''Qty'', ''QtyMin'', and ''QtyMax'' for quantities, such as {{OrderQty}}
*''Date'' for dates, such as {{OrderDate}}
*''Time'' for time points and time spans, such as {{BillableTime}}
*''Pct'' for percents, such as {{DiscountPct}}

==DAC Naming Conventions==
A DAC name should meet the following requirements:[anchor|#_52a29173-bbd8-4d24-bf2f-7a851f616ef8]
*The length of a DAC name including all namespaces should not exceed 255 symbols
*A DAC name can contain only English letters

==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Table and Column Naming Conventions In this topic, you can learn how you should name tables and       columns in a database that is used by an  Acumatica Framework-based application. Table Naming Conventions When you are creating a table, you should consider the following suggestions regarding         naming conventions: Make sure that table and column names are valid C# identifiers, because these names           match the names of the classes and properties you declare in the application. Do not start           a table or column name with a digit. Do not use the underscore symbol (_) in table or column names, because it is a reserved           symbol in  Acumatica Framework. For example,  TenantType  is a valid column name, while              Tenant_Type  is invalid. Use singular nouns for table names. Typically, a table is mapped to a data access class           that represents the entity. For instance, the  SOShipment  table contains           data records that represent instances of the  SOShipment  entity.                Acumatica Framework generates SQL statements with table and column names in the same letter case (that             is, uppercase or lowercase) as the corresponding data access classes and fields are             declared in the application. Also, the DAC Generator tool produces data access class             declarations in the same letter case as the tables and columns are defined in the             database schema. Use two prefixes in table names: a two-letter tenant name and then a two-letter           application module prefix. For example, the  MTSVAppointment  table can be           used in the Services (SV) module for the MyTenant tenant (which corresponds to the              MT  prefix). These prefixes help to distinguish your application tables from  Acumatica ERP tables and tables of other vendors if you create an add-on project or extension           library. If you add a column to an  Acumatica ERP table, start the column name with the  Usr  prefix followed by the two-letter           tenant name. For instance, you could use  UsrMTColumn  for the column of           the MyTenant tenant. In this case, the column will be preserved during upgrades. In your           own application tables, there are no strict requirements to start column names with any           prefixes. Be sure that custom indexes on  Acumatica ERP tables start with the  Usr  prefix followed by the two-letter tenant name, so that           the indexes will be preserved during upgrades. Column Naming Conventions We recommend that you use the following suffixes in column names: ID  for surrogate keys, including database identity columns, such as              CustomerID CD  for natural keys, such as  CustomerCD Nbr  for numbering identifiers, such as  OrderNbr Price  for prices, such as  UnitPrice Cost  for costs, such as  UnitCost Amt  for amounts, such as  FreightAmt Total  for totals, such as  OrderTotal Qty ,  QtyMin , and  QtyMax  for quantities, such as              OrderQty Date  for dates, such as  OrderDate Time  for time points and time spans, such as  BillableTime Pct  for percents, such as  DiscountPct DAC Naming Conventions A DAC name should meet the following requirements: The length of a DAC name including all namespaces should not exceed 255 symbols A DAC name can contain only English letters ]]></column>
		</row>
		<row PageID="3323a8a3-1736-498a-bf87-55617532c91c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="85ef1dea-ffb4-6cad-da5f-7538d1b45dd8" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#section_nnl_jqr_dm]
You should use the following data types for columns. In the '''Type Attribute on the Data Field''' column in the table below, you can find the most common type attributes that are added to the corresponding data fields in the data access class declaration.[anchor|#table_gl1_ns4_ll]
===Common Data Types===
{| class="checklist" | width="100%" 
|- 
!width="26%" ! Value
!width="21%" ! Data Type (SQL Server)
!width="21%" ! Data Type (MySQL)
!width="31%" ! Type Attribute on the Data Field
|- 
| Database identity
| int
| INT
| {{[PXDBIdentity]}}
|- 
| Natural key (for example, document number)
| nvarchar(15)
| VARCHAR(15) with utf8mb4 character set
| {{[PXDBString(15, IsKey = true, IsUnicode = true)]}}
|- 
| Line number
| int
| INT
| {{[PXDBInt]}}
|- 
| Short string (for example, a name or unit of measure)
| nvarchar(20), nvarchar(50)
| VARCHAR(20), VARCHAR(50) with utf8mb4 character set
| {{[PXDBString(20, IsUnicode = true)]}}
|- 
| Long string (such as a description)
| nvarchar(255)
| VARCHAR(255) with utf8mb4 character set
| {{[PXDBString(255, IsUnicode = true)]}}
|- 
| Type or status identifier (for instance, a document type)
| int or char(1)
| INT or CHAR(1)
| {{[PXDBInt]}} or {{[PXDBString(1, IsFixed = true)]}} respectively
|- 
| Boolean flag (for example, active/inactive)
| bit
| TINYINT(1)
| {{[PXDBBool]}}
|- 
| Price or cost, monetary units
| decimal(19, 6)
| DECIMAL(19, 6)
| {{[PXDBDecimal(6)]}}
|- 
| Amount or total, monetary units
| decimal(19, 4)
| DECIMAL(19, 4)
| {{[PXDBDecimal(4)]}}
|- 
| Quantity, pieces
| decimal(25, 6)
| DECIMAL(25, 6)
| {{[PXDBDecimal(6)]}}
|- 
| Maximum, minimum, or threshold quantity, pieces
| decimal(9, 6)
| DECIMAL(9, 6)
| {{[PXDBDecimal(2)]}}
|- 
| Percent, rate (for example, discount percent)
| decimal(9, 6)
| DECIMAL(9, 6)
| {{[PXDBDecimal(2)]}}
|- 
| Weight or volume
| decimal(25, 6) 
| DECIMAL(25, 6)
| {{[PXDBDecimal(6)]}}
|- 
| Date
| smalldatetime
| DATETIME
| {{[PXDBDate]}}
|- 
| Time span
| int
| INT
| {{[PXDBTimeSpan(DisplayMask = "t", InputMask = "t")]}}
|- 
| Coefficient (such as a conversion factor)
| decimal(9, 6)
| DECIMAL(9, 6)
| {{[PXDBDecimal(1)]}}
|}
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Common Columns and Data Types You should use the following data types for columns. In the  Type Attribute on the      Data Field  column in the table below, you can find the most common type attributes     that are added to the corresponding data fields in the data access class declaration. Common Data Types Value Data Type (SQL Server) Data Type (MySQL) Type Attribute on the Data Field Database identity int INT [PXDBIdentity] Natural key (for example, document number) nvarchar(15) VARCHAR(15) with utf8mb4 character set [PXDBString(15, IsKey = true, IsUnicode = true)] Line number int INT [PXDBInt] Short string (for example, a name or unit of measure) nvarchar(20), nvarchar(50) VARCHAR(20), VARCHAR(50) with utf8mb4 character set [PXDBString(20, IsUnicode = true)] Long string (such as a description) nvarchar(255) VARCHAR(255) with utf8mb4 character set [PXDBString(255, IsUnicode = true)] Type or status identifier (for instance, a document type) int or char(1) INT or CHAR(1) [PXDBInt]  or  [PXDBString(1, IsFixed = true)]          respectively Boolean flag (for example, active/inactive) bit TINYINT(1) [PXDBBool] Price or cost, monetary units decimal(19, 6) DECIMAL(19, 6) [PXDBDecimal(6)] Amount or total, monetary units decimal(19, 4) DECIMAL(19, 4) [PXDBDecimal(4)] Quantity, pieces decimal(25, 6) DECIMAL(25, 6) [PXDBDecimal(6)] Maximum, minimum, or threshold quantity, pieces decimal(9, 6) DECIMAL(9, 6) [PXDBDecimal(2)] Percent, rate (for example, discount percent) decimal(9, 6) DECIMAL(9, 6) [PXDBDecimal(2)] Weight or volume decimal(25, 6)  DECIMAL(25, 6) [PXDBDecimal(6)] Date smalldatetime DATETIME [PXDBDate] Time span int INT [PXDBTimeSpan(DisplayMask = "t", InputMask = "t")] Coefficient (such as a conversion factor) decimal(9, 6) DECIMAL(9, 6) [PXDBDecimal(1)] ]]></column>
		</row>
		<row PageID="9e533998-5a08-452d-9490-a02db1cf4c19" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="aa0d4bf2-33ec-45f0-f8ea-565ff0416c36" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You have to define the primary key in each application table that you create. The primary key may consist of one column or multiple columns. The primary key must include the {{CompanyID}} column if one is defined in the table. For details on the {{CompanyID}} column, see [HelpRoot_Dev_Platform\DA__con_Multitenancy_Support|Multitenancy Support].{br}

For each table, you can use one of the following typical variants of primary keys:[anchor|#ul_fl2_lvf_pl]
*One key column included in the primary key in the table and set as the key in the data access class
*A pair of columns, with one column included in the primary key in the table and the other column set as the key in the data access class
*Multiple columns that are included in the primary key and set as the compound key in the data access class
((({S:Warn}In a setup table, only the {{CompanyID}} column must be included in the primary key.
))){br}{TOC}
==One Key Column==
You may use one key column for rather short tables. For instance, you can use the two-letter country code from ISO 3166 as the key in the {{Country}} table.
==A Pair of Columns with Key Substitution in the UI==
If you want to represent a user-friendly key in the user interface (UI) that corresponds to a surrogate key in the database, you can use a pair of columns and the key substitution mechanism provided by Acumatica Framework. You can define two columns in a table, one for the surrogate key (typically the database identity column) and one for the natural key, and set only the surrogate key as primary in the table. In the application object model, you set the key to only the data field that is a natural key. In this case, Acumatica Framework provides the ability to transparently work with different keys at the database and application levels. In the UI, users work with only the natural key while the database operates with the surrogate key (see the graphic below, which illustrates key substitution).[anchor|#_bcf09c83-658b-4ea8-a637-60f700456bf0][anchor|#image_kdc_lzv_nl][image:StudioDeveloperGuide/Images/Conc_KeySubstitutionScheme.png|popup|Key substitution in Acumatica Framework|300px]
For instance, you can define two columns in the {{Product}} table, {{ProductID}} and {{ProductCD}}. {{ProductID}} is the identity column that is the only column included in the primary key of the table. {{ProductCD}} is the string key of a product instance, which is entered by the user through the UI. The {{ProductCD}} column isn&rsquo;t included in the primary key and is handled as the unique key column by Acumatica Framework.
==Multiple Column Key==
A compound key consisting of multiple columns may be used for complex entities. For instance, you can include two columns, {{DocType}} and {{DocNbr}}, in the primary key for the {{Document}} table. In the {{DocDetail}} table, you may use {{DocNbr}} and {{DocDetailNbr}} as the compound primary key. The corresponding data fields should be also set as the key fields in the data access class.
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Primary Key You have to define the primary key in each application table that you create. The primary key     may consist of one column or multiple columns. The primary key must include the       CompanyID  column if one is defined in the table. For details on the       CompanyID  column, see  Multitenancy Support. For each table, you can use one of the following typical variants of primary keys: One key column included in the primary key in the table and set as the key in the data      access class A pair of columns, with one column included in the primary key in the table and the other      column set as the key in the data access class Multiple columns that are included in the primary key and set as the compound key in the      data access class In a setup table, only the  CompanyID  column must be included in the     primary key. One Key Column You may use one key column for rather short tables. For instance, you can use the two-letter     country code from ISO 3166 as the key in the  Country  table. A Pair of Columns with Key Substitution in the UI If you want to represent a user-friendly key in the user interface (UI) that corresponds to a     surrogate key in the database, you can use a pair of columns and the key substitution mechanism     provided by  Acumatica Framework. You     can define two columns in a table, one for the surrogate key (typically the database identity     column) and one for the natural key, and set only the surrogate key as primary in the table. In     the application object model, you set the key to only the data field that is a natural key. In     this case,  Acumatica Framework     provides the ability to transparently work with different keys at the database and application     levels. In the UI, users work with only the natural key while the database operates with the     surrogate key (see the graphic below, which illustrates key substitution). Key substitution in  Acumatica FrameworkFor instance, you can define two columns in the  Product  table,       ProductID  and  ProductCD .  ProductID  is the     identity column that is the only column included in the primary key of the table.       ProductCD  is the string key of a product instance, which is entered by the     user through the UI. The  ProductCD  column isn't included in the primary key and     is handled as the unique key column by  Acumatica Framework. Multiple Column Key A compound key consisting of multiple columns may be used for complex entities. For instance,     you can include two columns,  DocType  and  DocNbr , in the     primary key for the  Document  table. In the  DocDetail  table,     you may use  DocNbr  and  DocDetailNbr  as the compound primary     key. The corresponding data fields should be also set as the key fields in the data access     class. ]]></column>
		</row>
		<row PageID="8da9e9c6-ebbf-409a-b43d-a13d2081a62e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ef328cac-6542-8070-fafb-b6c02cc3fc8e" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In the database, you have to define the primary key in each application table that you create. The primary key defines the unique data record identifier, which provides table-level integrity of data.{br}

There are no strict requirements to define column-level constraints and foreign keys in application tables. Whether you define the constraints at the database level depends on the design approach you use. At a higher level of the application object model, which is represented by data access classes, you can flexibly define any level of constraints, including default values, nullable fields, and parent-child relationships between data access classes. If you aren&rsquo;t sure whether a column should allow a null value, you can allow null values for it in the database. Later, in the data access class, you can make the data field either required or nullable; you can even make the field required on one form and optional on another.((({S:Warn}For Boolean and decimal columns, we recommend that you define default values either in the database or in data access classes. This simplifies the application code by helping to avoid checking of values for nulls multiple times.
)))
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Foreign Keys and Nullable Columns In the database, you have to define the primary key in each application table that you create.     The primary key defines the unique data record identifier, which provides table-level integrity     of data. There are no strict requirements to define column-level constraints and foreign keys in     application tables. Whether you define the constraints at the database level depends on the     design approach you use. At a higher level of the application object model, which is represented     by data access classes, you can flexibly define any level of constraints, including default     values, nullable fields, and parent-child relationships between data access classes. If you     aren't sure whether a column should allow a null value, you can allow null values for it in the     database. Later, in the data access class, you can make the data field either required or     nullable; you can even make the field required on one form and optional on another. For Boolean and decimal columns, we recommend that you define default values either in the     database or in data access classes. This simplifies the application code by helping to avoid     checking of values for nulls multiple times. ]]></column>
		</row>
		<row PageID="9dd06906-0b2f-498c-a333-cfd641bfbd9e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="cfa2fedc-265e-a426-5f08-f2d7c1134d4a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Audit fields keep meta information on the creation and the last change of a database record. Audit fields are updated automatically by the framework.{br}

To enable the tracking of audit data for a particular table, you should add the columns listed below to the table and declare the corresponding audit data fields in the data access class. You have to add the corresponding type attribute to each audit field. If the audit columns are properly created in the database table and the corresponding data fields are declared in the data access class, Acumatica Framework automatically updates audit data in these fields every time a data record is modified from the application. The date and time values are stored in the database in UTC. {br}

The audit column parameters and DAC attributes are given below.[anchor|#table_lbr_dgg_pl]
===Audit Columns===
{| class="checklist" | width="100%" 
|- 
!width="26%" ! Database Column Name
!width="21%" ! Data Type (SQL Server)
!width="21%" ! Data Type (MySQL)
!width="31%" ! Type Attribute on the Data Field
|- 
| {{CreatedByID}}
| {{uniqueidentifier}}; not null
| {{CHAR(36)}} with ASCII character set; not null
| {{[PXDBCreatedByID]}}
|- 
| {{CreatedByScreenID}}
| {{char(8)}}; not null
| {{CHAR(8)}} with ASCII character set; not null
| {{[PXDBCreatedByScreenID]}}
|- 
| {{CreatedDateTime}}
| {{datetime}}; not null
| {{DATETIME}}; not null
| {{[PXDBCreatedDateTime]}}
|- 
| {{LastModifiedByID}}
| {{uniqueidentifier}}; not null
| {{CHAR(36)}} with ASCII character set; not null
| {{[PXDBLastModifiedByID]}}
|- 
| {{LastModifiedByScreenID}}
| {{char(8)}}; not null
| {{CHAR(8)}} with ASCII character set; not null
| {{[PXDBLastModifiedByScreenID]}}
|- 
| {{LastModifiedDateTime}}
| {{datetime}}; not null
| {{DATETIME}}; not null
| {{[PXDBLastModifiedDateTime]}}
|}
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Audit Fields Audit fields keep meta information on the creation and the last change of a database record.     Audit fields are updated automatically by the framework. To enable the tracking of audit data for a particular table, you should add the columns listed     below to the table and declare the corresponding audit data fields in the data access class. You     have to add the corresponding type attribute to each audit field. If the audit columns are     properly created in the database table and the corresponding data fields are declared in the     data access class,  Acumatica Framework     automatically updates audit data in these fields every time a data record is modified from the     application. The date and time values are stored in the database in UTC.  The audit column parameters and DAC attributes are given below. Audit Columns Database Column Name Data Type (SQL Server) Data Type (MySQL) Type Attribute on the Data Field CreatedByID uniqueidentifier ; not null CHAR(36)  with ASCII character set; not null [PXDBCreatedByID] CreatedByScreenID char(8) ; not null CHAR(8)  with ASCII character set; not null [PXDBCreatedByScreenID] CreatedDateTime datetime ; not null DATETIME ; not null [PXDBCreatedDateTime] LastModifiedByID uniqueidentifier ; not null CHAR(36)  with ASCII character set; not null [PXDBLastModifiedByID] LastModifiedByScreenID char(8) ; not null CHAR(8)  with ASCII character set; not null [PXDBLastModifiedByScreenID] LastModifiedDateTime datetime ; not null DATETIME ; not null [PXDBLastModifiedDateTime] ]]></column>
		</row>
		<row PageID="8d904e5f-2b8c-4d82-a8f5-bc863f8ffc8f" Language="en-US" PageRevisionID="1" PlainText="Concurrent Update Control You can add the SQL Server time stamp column to a table to make  Acumatica Framework able     to handle concurrent updates. The corresponding time stamp data field should be declared in the     data access class. If the time stamp data field is declared,  Acumatica Framework     handles the time stamp column automatically.  Acumatica Framework     checks the row version every time the row is modified. We recommend that you add the time stamp     column, with the parameters shown in the following table, to all tables of your application. The Time Stamp Column Database Column Name Data Type (SQL Server) Data Type (MySQL) Type Attribute on the Data Field TStamp timestamp ; not null TIMESTAMP(6) ; not null [PXDBTimestamp] " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="69e9915c-9600-c563-edb6-760b408cdca8" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#section_kmd_qqr_dm]
You can add the SQL Server time stamp column to a table to make Acumatica Framework able to handle concurrent updates. The corresponding time stamp data field should be declared in the data access class. If the time stamp data field is declared, Acumatica Framework handles the time stamp column automatically. Acumatica Framework checks the row version every time the row is modified. We recommend that you add the time stamp column, with the parameters shown in the following table, to all tables of your application.[anchor|#table_ewz_fzf_pl]
===The Time Stamp Column===
{| class="checklist" | width="100%" 
|- 
!width="26%" ! Database Column Name
!width="21%" ! Data Type (SQL Server)
!width="21%" ! Data Type (MySQL)
!width="31%" ! Type Attribute on the Data Field
|- 
| {{TStamp}}
| {{timestamp}}; not null
| {{TIMESTAMP(6)}}; not null
| {{[PXDBTimestamp]}}
|}
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
		</row>
		<row PageID="2c5495c0-4705-4a38-8ea9-532b0ba1724a" Language="en-US" PageRevisionID="1" PlainText="Attachment of Additional Objects to Data Records You can attach additional objects to a data record—for instance, attach a text note or     an uploaded file or multiple uploaded files to a data record.  You turn on or off support for data record attachments for each particular table individually.     To turn on support for data record attachments, add a  NoteID  column that stores     the global data record identifier to the table and declare the corresponding field in the data     access class. For more information on uploading files through an  Acumatica ERP     form, see  To Display an Attached Image on the Form. See below for the parameters of     the global identifier column and the attribute that should be added to the corresponding DAC     field. The Global Data Record Identifier Column (NoteID) Database Column Data Type (SQL Server) Data Type (MySQL) Type Attribute on the Data Field Global data record identifier (named  NoteID ) uniqueidentifier ; null CHAR(36) [PXNote] " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="dcf3e03f-65bc-7966-0924-d7a2d5c74e13" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#section_jtw_rqr_dm]
You can attach additional objects to a data record—for instance, attach a text note or an uploaded file or multiple uploaded files to a data record. {br}

You turn on or off support for data record attachments for each particular table individually. To turn on support for data record attachments, add a {{NoteID}} column that stores the global data record identifier to the table and declare the corresponding field in the data access class. For more information on uploading files through an Acumatica ERP form, see [HelpRoot_Dev_Platform\BL__how_Display_Attached_Image|To Display an Attached Image on the Form]. See below for the parameters of the global identifier column and the attribute that should be added to the corresponding DAC field.[anchor|#table_yml_2fg_pl]
===The Global Data Record Identifier Column (NoteID)===
{| class="checklist" | width="100%" 
|- 
!width="26%" ! Database Column
!width="21%" ! Data Type (SQL Server)
!width="21%" ! Data Type (MySQL)
!width="31%" ! Type Attribute on the Data Field
|- 
| Global data record identifier (named {{NoteID}})
| 
{{uniqueidentifier}}; null
| {{CHAR(36)}}
| {{[PXNote]}}
|}
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
		</row>
		<row PageID="4a1939a3-26aa-49e3-83c6-5bcc884e66b9" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e63d8635-4d98-ef36-ccb4-fd113ffce98d" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#section_b5g_tqr_dm]
 Acumatica Framework provides a low-level mechanism (which is performed on the database level) for preserving deleted data records in the database. With this mechanism, when an application initiates the deletion of a data record, the data access layer generates an SQL query that marks the data record as deleted but does not permanently remove the data record from the table. When data records are selected from the table, the data access layer generates the SQL query, which returns only data records that are not marked as deleted. The data records that are preserved in this way can be restored. {br}

You can turn on or off the preservation of deleted data records for each table individually. To preserve data records in a particular table, add the {{DeletedDatabaseRecord}} column to the table and do not declare the data field in the data access class. When a data record is deleted in the table, the framework automatically preserves the deleted data record transparently to the application developer.[anchor|#table_q4s_ygg_pl]
===The DeletedDatabaseRecord Column===
{| class="checklist" | width="100%" 
|- 
!width="26%" ! Database Column
!width="21%" ! Data Type (SQL Server)
!width="21%" ! Data Type (MySQL)
!width="31%" ! Type Attribute on the Data Field
|- 
| {{DeletedDatabaseRecord}}
| {{bit}}; not null
| {{TINYINT(1)}}; not null
| Not declared in DAC
|}
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Preservation of Deleted Records  Acumatica Framework     provides a low-level mechanism (which is performed on the database level) for preserving deleted     data records in the database. With this mechanism, when an application initiates the deletion of     a data record, the data access layer generates an SQL query that marks the data record as     deleted but does not permanently remove the data record from the table. When data records are     selected from the table, the data access layer generates the SQL query, which returns only data     records that are not marked as deleted. The data records that are preserved in this way can be     restored.  You can turn on or off the preservation of deleted data records for each table individually.     To preserve data records in a particular table, add the  DeletedDatabaseRecord      column to the table and do not declare the data field in the data access class. When a data     record is deleted in the table, the framework automatically preserves the deleted data record     transparently to the application developer. The DeletedDatabaseRecord Column Database Column Data Type (SQL Server) Data Type (MySQL) Type Attribute on the Data Field DeletedDatabaseRecord bit ; not null TINYINT(1) ; not null Not declared in DAC ]]></column>
		</row>
		<row PageID="d0945e20-1949-40b1-bd0f-92c7c432aa24" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ceb0db61-d782-9047-f4cf-31a0ccabf396" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Multiple tenants can work on the same instance of an Acumatica Framework-based application with completely isolated data. The application looks identical to all tenants, but each tenant has exclusive access to its data only. Data is isolated at the lowest level of the application, in the data access layer that executes SQL queries for the tenant of the user who is currently signed in.{br}{TOC}[anchor|#section_wmd_vqr_dm]
==Multitenancy Support==The following graphic illustrates how different logical tenants work with the Acumatica Framework-based application in a multitenant configuration. They work with the same application but have isolated data access, as if they are working with different database instances.[anchor|#_cd5360a2-8c0e-4791-a459-30a971e9a3e8][anchor|#image_s2g_plb_4l][image:StudioDeveloperGuide/Images/Conc_Multiten_NoSharing.png|popup|Multitenant Acumatica Framework-based application|300px]
Multitenancy support is turned on or off for each particular table individually. To turn on multitenancy support for a table, add the {{CompanyID}} column to it and include the column in the primary key (see the column parameters in the table below) and all indexes. The {{CompanyID}} column is handled automatically by the framework and should not be declared in data access classes. If a table doesn&rsquo;t have the {{CompanyID}} column, all data from the table is fully accessible to all tenants that exist in the database. For more information, see [HelpRoot_Administration\SM__con_Support_of_Multiple_Companies|Support of Multiple Tenants].[anchor|#table_s4d_s3g_pl]
===The CompanyID Column===
{| class="checklist" | width="100%" 
|- 
!width="26%" ! Database Column Name
!width="21%" ! Data Type (SQL Server)
!width="21%" ! Data Type (MySQL)
!width="31%" ! Type Attribute on the Data Field
|- 
| {{CompanyID}}
| {{int}}; not null; included in primary key and all indexes
| {{INT}}; not null; included in primary key and all indexes
| Not declared in DAC
|}
==Support for Shared Data Access Between Tenants==
 Acumatica Framework provides shared data access in a multitenant configuration. Acumatica Framework supports a hierarchy of logical tenants that may work with a combination of shared and individual data. In shared access mode, every tenant may work with its individual copy of a data record; copies differ by {{CompanyID}}. All copies represent the same logical object in the application but different data records in the database. For instance, each tenant may use the individual settings of the application.{br}

The graphic below shows a possible multitenant configuration with shared data access between Tenant 1, Tenant 2, and Tenant 3. The users of Tenant 2 have access to the data of all three tenants. The users from each of the other two tenants have access to their company&rsquo;s individual data only. Physically, the data of all three tenants is stored in a single database instance.[anchor|#_8ea08c8e-8043-4ef2-bc9a-beb6a5e812a1][anchor|#image_udh_wlb_4l][image:StudioDeveloperGuide/Images/Conc_Multiten_Sharing.png|popup|Shared data access in a multitenant Acumatica Framework-based application|300px]
Support for shared data access is turned on or off for each particular table individually. To turn on support for shared data access for a table, add the {{CompanyMask}} column to the table (see the column parameters in the table below). The {{CompanyMask}} column is handled automatically by the framework and should not be declared in data access classes. If a table doesn&rsquo;t have the {{CompanyMask}} column, shared data access is not available for this table.[anchor|#table_ijy_zkg_pl]
===The CompanyMask Column===
{| class="checklist" | width="100%" 
|- 
!width="26%" ! Database Column Name
!width="21%" ! Data Type (SQL Server)
!width="21%" ! Data Type (MySQL)
!width="31%" ! Type Attribute on the Data Field
|- 
| {{CompanyMask}}
| {{varbinary(32)}}, not null, default 0xAA
| {{VARBINARY(32)}}, not null, default 0xAA
| Not declared in DAC
|}
{{CompanyMask}} is a 32-bit mask. In this mask, each two bits correspond to each tenant. The first of these two bits specifies whether the record may be read by this tenant, and the second bit specifies whether the record may be written to by this tenant. For example, suppose that {{CompanyMask}} is set to 0xBE02 for a record. That is, it specifies the following mask: {{10 11 11 10 00 00 00 10}}, which designates that the record may be both read and written to by the tenants with company IDs 2 and 3, the record may be read by the tenants with IDs 4 and 5 and the system tenant (which has ID 1), and the record may not be read or written to by other tenants. {{{{CompanyMask:  10 11 11 10 00 00 00 10
CompanyID:     4  3  2  1  8  7  6  5
}}}}{br}

The default value of {{CompanyMask}} is 0xAA, which means that the record may be read by all tenants.
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Multitenancy Support Multiple tenants can work on the same instance of an  Acumatica Framework-based     application with completely isolated data. The application looks identical to all tenants, but     each tenant has exclusive access to its data only. Data is isolated at the lowest level of the     application, in the data access layer that executes SQL queries for the tenant of the user who     is currently signed in. Multitenancy Support The following graphic    illustrates how different logical tenants work with the  Acumatica Framework-based    application in a multitenant configuration. They work with the same application but have isolated    data access, as if they are working with different database instances. Multitenant  Acumatica Framework-based application Multitenancy support is turned on or off for each particular table individually. To turn     on multitenancy support for a table, add the  CompanyID  column to it and include     the column in the primary key (see the column parameters in the table below) and all indexes.     The  CompanyID  column is handled automatically by the framework and should not     be declared in data access classes. If a table doesn't have the  CompanyID      column, all data from the table is fully accessible to all tenants that exist in the database.     For more information, see  Support of Multiple Tenants. The CompanyID Column Database Column Name Data Type (SQL Server) Data Type (MySQL) Type Attribute on the Data Field CompanyID int ; not null; included in primary key and all indexes INT ; not null; included in primary key and all indexes Not declared in DAC Support for Shared Data Access Between Tenants  Acumatica Framework     provides shared data access in a multitenant configuration.  Acumatica Framework     supports a hierarchy of logical tenants that may work with a combination of shared and     individual data. In shared access mode, every tenant may work with its individual copy of a data     record; copies differ by  CompanyID . All copies represent the same logical     object in the application but different data records in the database. For instance, each tenant     may use the individual settings of the application. The graphic below shows a possible multitenant configuration with shared data access between     Tenant 1, Tenant 2, and Tenant 3. The users of Tenant 2 have access to the data of all three     tenants. The users from each of the other two tenants have access to their company's individual     data only. Physically, the data of all three tenants is stored in a single database     instance. Shared data access in a multitenant  Acumatica Framework-based application Support for shared data access is turned on or off for each particular table individually. To     turn on support for shared data access for a table, add the  CompanyMask  column     to the table (see the column parameters in the table below). The  CompanyMask      column is handled automatically by the framework and should not be declared in data access     classes. If a table doesn't have the  CompanyMask  column, shared data access is     not available for this table. The CompanyMask Column Database Column Name Data Type (SQL Server) Data Type (MySQL) Type Attribute on the Data Field CompanyMask varbinary(32) , not null, default 0xAA VARBINARY(32) , not null, default 0xAA Not declared in DAC CompanyMask  is a 32-bit mask. In this mask, each two bits correspond to each     tenant. The first of these two bits specifies whether the record may be read by this tenant, and     the second bit specifies whether the record may be written to by this tenant. For example,     suppose that  CompanyMask  is set to 0xBE02 for a record. That is, it specifies     the following mask:  10 11 11 10 00 00 00 10 ,     which designates that the record may be both read and written to by the tenants with company IDs     2 and 3, the record may be read by the tenants with IDs 4 and 5 and the system tenant (which has     ID 1), and the record may not be read or written to by other tenants.      CompanyMask:  10 11 11 10 00 00 00 10
CompanyID:     4  3  2  1  8  7  6  5 The default value of  CompanyMask  is 0xAA, which means that the record may be     read by all tenants. ]]></column>
		</row>
		<row PageID="a40f4ed8-2f7f-4894-8bb7-71aa5402792c" Language="en-US" PageRevisionID="1" Content="This chapter summarizes the form design and style conventions used in Acumatica Framework.&#xA;==In This Chapter==[anchor|#_aa957432-43fa-40f6-a279-a70eecff8d3b]&#xA;*[HelpRoot_Dev_Platform\DA__con_Development_Environment_Options|Development Environment Options]&#xA;*[HelpRoot_Dev_Platform\DA__con_Form_Numbering|Form and Report Numbering]&#xA;*[HelpRoot_Dev_Platform\DA__con_Item_Grouping_on_Form_Toolbar|Item Grouping on the Form Toolbar]&#xA;&#xA;==Related Articles==&#xA;*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]&#xA;*[HelpRoot_Dev_Platform\DA__mng_Code_Guidelines|Naming the Graphs and Event Handlers]" PlainText="Designing the User Interface This chapter summarizes the form design and style conventions used in  Acumatica Framework. In This Chapter Development Environment OptionsForm and Report NumberingItem Grouping on the Form Toolbar" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="6f536ec6-48bb-9c6b-f14f-65a8a6b4c788" RecordSourceID="22377" />
		<row PageID="f1be73a7-1b99-4609-a6e0-4ac489edad5d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="bda9911e-b07c-755e-3ce9-8096df7d61cd" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To create stand-alone applications with Acumatica Framework or develop customizations for Acumatica ERP, the environment where you install and use Acumatica Framework, should meet particular requirements that are described in [HelpRoot_Install\System_Requirements_Studio|System Requirements for Acumatica Framework 2020 R2].
==Web Forms Designer Settings==
We recommend the following settings for the Microsoft Visual Studio environment to ensure a uniform ASPX page appearance: [anchor|#ol_uvc_glx_2t]
#Under the '''Tools''' > '''Options''' > '''Web Forms Designer''' > '''CSS''' section, set the following options: 
#*'''Font and text''': ''CSS (classes)''
#* '''Padding and borders''': ''CSS (classes)''
#* '''Floating, positioning, and sizing''': ''CSS (inline styles)''
#* '''Bullets and numbering''': ''CSS (classes)''
#* '''Background''': ''CSS (classes)''
#* '''Margins''': ''CSS (classes)''
#Under the '''Tools''' > '''Options''' > '''Web Forms Designer''' > '''CSS Styling''' section, select '''Auto Style Application''', and specify the following settings:
#*'''Only reuse classes with the prefix &ldquo;auto-style&ldquo;''': Selected
#*'''Use width and height attributes for image instead of CSS''': Selected
#*'''Use &lt;strong&gt; and &lt;em&gt; for bold and italic text''': Cleared
#*'''Use shorthand properties when generating styles''': Selected
#*'''Change positioning to absolute for controls added using Toolbox, paste, or drag and drop''': Selected
{br}{TOC}
==Design Mode Settings==
We also recommended that you use the following settings of the Design mode of ASPX pages in Visual Studio: [anchor|#ul_xvc_glx_2t]
*'''View''' > '''Visual Aids''' > '''CSS Display:none Elements''': Cleared
*'''View''' > '''Visual Aids''' > '''CSS Visibility:hidden Elements''': Cleared
{br}{TOC}
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_UI|Designing the User Interface]]]></column>
			<column name="PlainText"><![CDATA[Development Environment Options To create stand-alone applications with  Acumatica Framework or     develop customizations for  Acumatica ERP,     the environment where you install and use  Acumatica Framework,     should meet particular requirements that are described in  System Requirements for Acumatica Framework 2020 R2. Web Forms Designer Settings We recommend the following settings for the Microsoft Visual Studio environment to ensure a     uniform ASPX page appearance:  Under the  Tools Options Web Forms Designer CSS  section, set the following options:  Font and text :  CSS (classes) Padding and borders :  CSS (classes) Floating, positioning, and sizing :  CSS (inline styles) Bullets and numbering :  CSS (classes) Background :  CSS (classes) Margins :  CSS (classes) Under the  Tools Options Web Forms Designer CSS Styling  section, select  Auto Style Application , and specify the following       settings: Only reuse classes with the prefix "auto-style" : Selected Use width and height attributes for image instead of CSS :        Selected Use <strong> and <em> for bold and italic text : Cleared Use shorthand properties when generating styles : Selected Change positioning to absolute for controls added using Toolbox, paste, or drag         and drop : Selected Design Mode Settings We also recommended that you use the following settings of the Design mode of ASPX pages in     Visual Studio:  View Visual Aids CSS Display:none Elements : Cleared View Visual Aids CSS Visibility:hidden Elements : Cleared ]]></column>
		</row>
		<row PageID="4a5e6db8-cbba-4cbe-b0f1-1d774381c1b4" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="a94db220-084b-1c05-5ee0-3312b923fb1c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can find the guidelines for form and report numbering in Acumatica ERP.{br}{TOC}[anchor|#section_k2p_vlx_2t]
==Form Numbering==When you are numbering forms in Acumatica ERP, use the following conventions: {{{{  XX999999
   | | | |_ Subscreen Sequential Number
   | | |___ Screen Sequential Number
   | |_____ Screen Type: 
   |                    10: Setup
   |                    20: Maintenance
   |                    30: Data Entry
   |                    40: Inquiry 
   |                    50: Processing
   |                    60: Reports
   |_______ Two-Letter Module Code
}}}}[anchor|#section_dp5_vlx_2t]
==Report Numbering==When you are numbering reports in Acumatica ERP, use the following conventions in addition to those outlined above: {{{{  XX6X9999
     |  
     |____ Report Type: 
             61: Review Reports (Reports for document review prior to release) 
             62: Register Reports (Reports used to print audit information 
                                        on processed documents or entities)
             63: Balance Reports (Reports reflecting current or historical
                                                       balance information)
             64: Forms (Printed webpages)
             65: Inquiry Reports (Reports that provide status information
                                       required for operational management)
             66: Statistical Reports (Reports that provide statistical or 
                                                    historical information)
}}}}
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_UI|Designing the User Interface]]]></column>
			<column name="PlainText"><![CDATA[Form and Report Numbering In this topic, you can find the guidelines for form and report numbering in  Acumatica ERP. Form Numbering When you are numbering forms in  Acumatica ERP, use the following conventions:          XX999999
   | | | |_ Subscreen Sequential Number
   | | |___ Screen Sequential Number
   | |_____ Screen Type: 
   |                    10: Setup
   |                    20: Maintenance
   |                    30: Data Entry
   |                    40: Inquiry 
   |                    50: Processing
   |                    60: Reports
   |_______ Two-Letter Module Code Report Numbering When you are numbering reports in          Acumatica ERP, use the following conventions in addition to those outlined above:          XX6X9999
     |  
     |____ Report Type: 
             61: Review Reports (Reports for document review prior to release) 
             62: Register Reports (Reports used to print audit information 
                                        on processed documents or entities)
             63: Balance Reports (Reports reflecting current or historical
                                                       balance information)
             64: Forms (Printed webpages)
             65: Inquiry Reports (Reports that provide status information
                                       required for operational management)
             66: Statistical Reports (Reports that provide statistical or 
                                                    historical information) ]]></column>
		</row>
		<row PageID="abf2bced-c926-4f27-a408-66fe223418ed" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e8c385b5-7db1-0d5a-d1ef-ab7af33d449b" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Menu items can be grouped on the form toolbar to keep a reasonable number of buttons on the toolbar. When you are building the menu structure, use the menus described below.{br}{TOC}
==Data Entry Forms==[anchor|#ul_ytr_lnx_2t]
*'''Actions''': Use this menu to group the operations that give the user the ability to process the document, including the actions that navigate to related data entry forms (with the system filling in appropriate settings) so users can quickly create linked documents. For example, see the '''Enter Payment/Apply Memo''' action on the [HelpRoot_FormReference\AR_30_10_00|Invoices and Memos] ([~/?ScreenId=AR301000|AR301000]) form. The most frequently used operations can be placed on the toolbar outside any groups as separate buttons that provide quick access to the actions. For example, notice the '''Release''' action on the [HelpRoot_FormReference\AR_30_10_00|Invoices and Memos] form.
*'''Reports''': Use this menu to group the actions that open related Report Designer reports and printable forms of documents.
*'''Inquiries''': Use this menu to group the actions that navigate to related inquiry forms.

==Inquiry Forms==[anchor|#ul_bl5_b4x_2t]
*'''Actions:''' Use this menu to group the operations that give the user the ability to navigate to related data entry forms.
*'''Reports:''' Use this menu to group the actions that open the related Report Designer reports.

==Maintenance Forms==[anchor|#ul_bbq_dsx_2t]
*'''Actions''': Use this menu to group the operations that update the settings of the master record and navigate to related data entry forms.
*'''Reports''': Use this menu to group the actions that open related Report Designer reports.
*'''Inquiries''': Use this menu to group the actions that navigate to related inquiry forms.

==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_UI|Designing the User Interface]]]></column>
			<column name="PlainText"><![CDATA[Item Grouping on the Form Toolbar Menu items can be grouped on the form toolbar to keep a reasonable number of buttons on the     toolbar. When you are building the menu structure, use the menus described below. Data Entry Forms Actions : Use this menu to group the operations that give the user the      ability to process the document, including the actions that navigate to related data entry      forms (with the system filling in appropriate settings) so users can quickly create linked      documents. For example, see the  Enter Payment/Apply Memo  action on the         ([~/?ScreenId=AR301000|AR301000]) Invoices and Memos(AR301000)  form. The most frequently used operations can be placed on the toolbar      outside any groups as separate buttons that provide quick access to the actions. For example,      notice the  Release  action on the   ([~/?ScreenId=AR301000|AR301000]) Invoices and Memos form. Reports : Use this menu to group the actions that open related Report      Designer reports and printable forms of documents. Inquiries : Use this menu to group the actions that navigate to      related inquiry forms. Inquiry Forms Actions:  Use this menu to group the operations that give the user the      ability to navigate to related data entry forms. Reports:  Use this menu to group the actions that open the related      Report Designer reports. Maintenance Forms Actions : Use this menu to group the operations that update the      settings of the master record and navigate to related data entry forms. Reports : Use this menu to group the actions that open related Report      Designer reports. Inquiries : Use this menu to group the actions that navigate to      related inquiry forms. ]]></column>
		</row>
		<row PageID="aa5bcc83-1246-45e3-bd29-2e8a619eb27f" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can find the naming conventions for the graphs and event handlers.&#xA;==In This Chapter==[anchor|#_758b7053-4ae7-455e-bdc3-a74f1162ae84]&#xA;*[HelpRoot_Dev_Platform\DA__con_Graph_Naming|Graph Naming]&#xA;*[HelpRoot_Dev_Platform\DA__con_Event_Handler_Naming|Naming Conventions for Event Handlers Defined in Graphs]&#xA;&#xA;==Related Articles==&#xA;*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]&#xA;*[HelpRoot_Dev_Platform\DA__mng_Designing_UI|Designing the User Interface]" PlainText="Naming the Graphs and Event Handlers In this chapter, you can find the naming conventions for the graphs and event handlers. In This Chapter Graph NamingNaming Conventions for Event Handlers Defined in Graphs" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f0e5a63e-56e0-5ed3-0942-8c29b1d1da96" RecordSourceID="22377" />
		<row PageID="100693b9-cf45-47aa-a653-24e03f7a93e8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="feb63c44-1212-1ce3-a396-beaa4ede526f" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When you are creating business logic controllers (graphs), use the following suffixes in the names of the graphs, depending on the types of the forms they are used for:[anchor|#_724a1004-a756-4a6b-bfcc-e002275e3d74]
*{{Maint}}: For the graphs for maintenance forms that are helper forms used for the input of data on the data entry and processing forms, and for the graphs for the setup forms that provide the configuration parameters for the application. For example, {{CountryMaint}} can be the name of the graph for the Countries maintenance form, which provides editing of the list of countries.
*{{Entry}}: For the graphs for data entry forms that are used for the input of business documents. For example, {{SalesOrderEntry}} can be the name of the graph for the Sales Order data entry form, which provides the basic functionality for working with sales orders.
*{{Inq}}: For the graphs for inquiry forms, which display a list of data records selected by the specified filter. For example, {{SalesOrderInq}} can be the name of the inquiry form named Sales Order Inquiry, which provides the list of documents selected by the specified customer.
*{{Process}}: For the graphs for processing forms that provide mass processing operations. For example, {{SalesOrderProcess}} can be the name of the Approve Sales Orders processing form, which provides mass approval of sales orders.

A graph name should meet the following requirements:[anchor|#_52a29173-bbd8-4d24-bf2f-7a851f616ef8]
*The length of a graph name including all namespaces should not exceed 255 symbols
*A graph name can contain only English letters

==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Code_Guidelines|Naming the Graphs and Event Handlers]]]></column>
			<column name="PlainText"><![CDATA[Graph Naming When you are creating business logic controllers (graphs), use the following suffixes in the     names of the graphs, depending on the types of the forms they are used for: Maint : For the graphs for maintenance forms that are helper forms used for      the input of data on the data entry and processing forms, and for the graphs for the setup      forms that provide the configuration parameters for the application. For example,        CountryMaint  can be the name of the graph for the Countries maintenance form,      which provides editing of the list of countries. Entry : For the graphs for data entry forms that are used for the input of      business documents. For example,  SalesOrderEntry  can be the name of the graph      for the Sales Order data entry form, which provides the basic functionality for working with      sales orders. Inq : For the graphs for inquiry forms, which display a list of data records      selected by the specified filter. For example,  SalesOrderInq  can be the name      of the inquiry form named Sales Order Inquiry, which provides the list of documents selected by      the specified customer. Process : For the graphs for processing forms that provide mass processing      operations. For example,  SalesOrderProcess  can be the name of the Approve      Sales Orders processing form, which provides mass approval of sales orders. A graph name should meet the following requirements: The length of a graph name including all namespaces should not exceed 255 symbols A graph name can contain only English letters ]]></column>
		</row>
		<row PageID="b6ff1ff7-5bf6-4ce2-a164-7d1cc7baecd5" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2a2d8562-38c3-fdb2-3b08-a1af05ede45c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In Acumatica Framework, you must adhere to the naming conventions for an event handler to be implemented in a graph or graph extension. The name of the event handler must include the event type and the object to be processed by the handler.{br}

The name of a data record event handler must have the following segments, which are separated by the ''&#95;'' symbol:[anchor|#_3345d3a3-0237-42b2-b8b3-571f2bb56b92]
#The name of the DAC declared in the server
#The name of the record event supported by the server
{br}

Therefore, the name of a data record event handler must be in the following format: ''DACName&#95;EventName'' (such as <tt>SOOrder&#95;RowSelected</tt>).{br}

The name of a data field event handler must have the following segments, which are separated by the ''&#95;'' symbol:[anchor|#_7a3118f4-63bb-4791-80c8-6c5bb3d20b80]
#The name of the DAC declared in the server
#The name of the data field declared within the DAC whose name is specified in the first segment
# The name of the field event supported by the server
{br}

Therefore, for a field event handler, the name must be in the following format: ''DACName&#95;FieldName&#95;EventName'' (such as <tt>SOOrder&#95;CustomerID&#95;FieldUpdated</tt>).
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Code_Guidelines|Naming the Graphs and Event Handlers]]]></column>
			<column name="PlainText"><![CDATA[Naming Conventions for Event Handlers Defined in Graphs In  Acumatica Framework, you must adhere to the naming conventions for an event handler to be implemented in a graph     or graph extension. The name of the event handler must include the event type and the object to     be processed by the handler. The name of a data record event handler must have the following segments, which are separated     by the  _  symbol: The name of the DAC declared in the server The name of the record event supported by the server Therefore, the name of a data record event handler must be in the following format:       DACName_EventName  (such as  SOOrder_RowSelected ). The name of a data field event handler must have the following segments, which are separated     by the  _  symbol: The name of the DAC declared in the server The name of the data field declared within the DAC whose name is specified in the first       segment  The name of the field event supported by the server Therefore, for a field event handler, the name must be in the following format:       DACName_FieldName_EventName  (such as      SOOrder_CustomerID_FieldUpdated ). ]]></column>
		</row>
		<row PageID="ca6d5149-db7a-42b9-bce1-d6f26a5c2ca7" Language="en-US" PageRevisionID="1" PlainText="Configuring ASPX Pages and Reports In this part of the guide, you can find information about how the forms of  Acumatica ERP     or an  Acumatica Framework-based     application work and how to configure the ASPX code of these forms. An ASPX page provides the UI     of the application. The ASPX page consists of a datasource control and at least one container     control. The datasource control links the page to the graph and provides interaction with the     server. Container controls are bound to graph members and give users the ability to work with     data on the form. You can also find a brief overview of reports. In This Part Overview of ASPX Pages in Acumatica FrameworkConfiguring the ASPX PageConfiguring ContainersConfiguring TablesConfiguring TabsConfiguring BoxesConfiguring Layout and SizeMaintaining Reports" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="b2df624f-d508-4cdb-679a-310a38fb2c07" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this part of the guide, you can find information about how the forms of Acumatica ERP or an Acumatica Framework-based application work and how to configure the ASPX code of these forms. An ASPX page provides the UI of the application. The ASPX page consists of a datasource control and at least one container control. The datasource control links the page to the graph and provides interaction with the server. Container controls are bound to graph members and give users the ability to work with data on the form.{br}

You can also find a brief overview of reports.
==In This Part==[anchor|#_830e0de5-8399-4921-9886-ab953b546fa0]
*[HelpRoot_Dev_Platform\CW__mng_Overview|Overview of ASPX Pages in Acumatica Framework]
*[HelpRoot_Dev_Platform\CW__mng_Configuring_Page|Configuring the ASPX Page]
*[HelpRoot_Dev_Platform\CW__mng_Configuring_Containers|Configuring Containers]
*[HelpRoot_Dev_Platform\CW__mng_Configuring_Tables|Configuring Tables]
*[HelpRoot_Dev_Platform\CW__mng_Configuring_Tabs|Configuring Tabs]
*[HelpRoot_Dev_Platform\CW__mng_Configuring_Boxes|Configuring Boxes]
*[HelpRoot_Dev_Platform\CW__mng_Configuring_Layout|Configuring Layout and Size]
*[HelpRoot_Dev_Platform\CC__mng_Working_with_Reports|Maintaining Reports]
]]></column>
		</row>
		<row PageID="c5b04643-bdef-43ed-aa69-2d72e396c899" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f7cebfbf-328c-28e7-27e2-10aef4e6c78a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In Acumatica Framework-based applications, you can configure the appearance of forms from the front end (that is, by configuring ASPX pages) and from the back end (that is, by using the attributes and events provided by the Acumatica platform). {br}

In this chapter of the guide, you can find information about how to create the ASPX code of the forms. This chapter also includes a technical overview of the user interface of an Acumatica Framework-based application. For information about the configuration of the UI from the back end, see [HelpRoot_Dev_Platform\BL__mng_Configuring_UI_from_Back_End|Configuring the UI from the Back End].{br}{TOC}
==Technical Overview of the User Interface==
The user interface of Acumatica ERP or an Acumatica Framework-based application uses the same core technologies. To learn how the user interface works, see [HelpRoot_Dev_Platform\CW__con_Button_Click|Processing of a Button Click] and [HelpRoot_Dev_Platform\CW__con_Modern_UI|Technical Overview of the User Interface]. You can find a detailed description of the user interface in [HelpRoot_Interface\InterfaceBasics| Acumatica ERP Interface Guide].
==Configuration of ASPX Pages==
You can configure the appearance and behavior of forms by using the properties of the ASPX objects that can be used on the Acumatica ERP or Acumatica Framework ASPX pages. For details on how to work with the ASPX code of the form, see the following topics:[anchor|#_6d951934-2331-486f-a5f6-73a16af6b638]
*To configure containers, such as <tt>PXFormView</tt>, <tt>PXGrid</tt>, <tt>PXTab</tt>, <tt>PXTreeView</tt>, and <tt>PXPanel</tt>: [HelpRoot_Dev_Platform\CW__mng_Configuring_Containers|Configuring Containers]
*To configure tables (<tt>PXGrid</tt> and <tt>PXGridColumn</tt>): [HelpRoot_Dev_Platform\CW__mng_Configuring_Tables|Configuring Tables]
*To configure tabs (<tt>PXTab</tt> and <tt>PXTabItem</tt>): [HelpRoot_Dev_Platform\CW__mng_Configuring_Tabs|Configuring Tabs]
*To configure boxes, such as <tt>PXTextEdit</tt>, <tt>PXCheckBox</tt>, and <tt>PXGroupBox</tt>): [HelpRoot_Dev_Platform\CW__mng_Configuring_Boxes|Configuring Boxes]
*To configure the layout (<tt>PXLayoutRule</tt>) and size of controls: [HelpRoot_Dev_Platform\CW__mng_Configuring_Layout|Configuring Layout and Size]
]]></column>
			<column name="PlainText"><![CDATA[Overview of ASPX Pages in  Acumatica FrameworkIn  Acumatica Framework-based applications, you can configure the appearance of forms from the front end (that         is, by configuring ASPX pages) and from the back end (that is, by using the attributes and         events provided by the  Acumatica platform).  In this chapter of the guide, you can find information about how to create the ASPX code of         the forms. This chapter also includes a technical overview of the user interface of an  Acumatica Framework-based application. For information about the configuration of the UI from the back end,         see  Configuring the UI from the Back End. Technical Overview of the User Interface The user interface of  Acumatica ERP or an  Acumatica Framework-based application uses the same core technologies. To learn how the user interface works,         see  Processing of a Button Click and  Technical Overview of the User Interface. You         can find a detailed description of the user interface in   Acumatica ERP Interface Guide. Configuration of ASPX Pages You can configure the appearance and behavior of forms by using the properties of the ASPX         objects that can be used on the  Acumatica ERP or  Acumatica Framework         ASPX pages. For details on how to work with the ASPX code of the form, see the following           topics: To configure containers, such as  PXFormView ,                PXGrid ,  PXTab ,  PXTreeView ,             and  PXPanel :  Configuring ContainersTo configure tables ( PXGrid  and  PXGridColumn ):                Configuring TablesTo configure tabs ( PXTab  and  PXTabItem ):  Configuring TabsTo configure boxes, such as  PXTextEdit ,                PXCheckBox , and  PXGroupBox ):  Configuring BoxesTo configure the layout ( PXLayoutRule ) and size of controls:  Configuring Layout and Size]]></column>
		</row>
		<row PageID="28874cf9-a344-4590-9f3d-70a67318b7c4" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="14dfe5a7-8bac-5bf1-bb08-e6c7528264b5" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can find a technical overview of the user interface of Acumatica ERP. {br}

For more details on the elements of the UI, see [HelpRoot_Interface\UIG__con_New_UI| Acumatica ERP User Interface] in the Interface Guide.{br}{TOC}
==Technologies in the UI==
The user interface of Acumatica ERP includes the following frames: [anchor|#_05b28db0-1af3-4045-8a5c-7b5ecc1d80db]
*The navigation frame, which is a webpage frame that can be used for navigation between Acumatica ERP forms. 
*The Acumatica ERP form, which is located in the inner frame, which is completely independent of the navigation frame.
{br}

The webpage renders the navigation elements of the navigation frame and the forms separately by using different technologies. The work of Acumatica ERP forms is based on the ASP.NET Web Forms technology, while the navigation frame uses the ASP.NET MVC technology with the Razor view engine. {br}

The server side of the navigation frame uses the ASP.NET Web API framework. The client side uses the React library, which is a JavaScript library, to render main menu items, workspaces, tiles, and other navigation elements.
==Work of the Navigation Frame==
The following diagram shows how the browser renders the elements of the navigation frame. This process is described in more detail in the remaining sections of this topic.[anchor|#_df0ccf5c-0b54-45a7-8809-59087d3f2c98][anchor|#_dde9dd0b-91b7-490b-bcbb-694f746988f6][image:StudioDeveloperGuide/Images/ModernUIRequests.png|popup|Rendering of the navigation frame|450px]
==Request of main.cshtml==
The browser retrieves <tt>main.cshtml</tt>, which is an ASP.NET MVC view, by sending the HTTP GET request. On the server side, this request is processed by the <tt>MainController.Main()</tt> method (<tt>PX.Web.UI.Frameset.Controllers</tt>), which creates a <tt>System.Web.Mvc.ViewResult</tt> object that renders a view to the response. The returned view contains the basic skeleton of the webpage, which includes the calendar control, the search control, and the empty menu.
==Request of the Menu Structure==
The <tt>getSiteMap</tt> function in <tt>site.js</tt> uses jQuery to send an AJAX request to ASP.NET Web API of the application server. On the server side, this request is processed by the <tt>SiteMapController</tt> class (<tt>PX.Web.UI.Frameset.WebApi.Controllers</tt>). ((({S:Warn}To match the incoming request to the appropriate processing classes, the system uses the ASP.NET MVC attribute routing. For example, the <tt>SiteMapController</tt> class is annotated with the {{[FramesetRoutePrefix("sitemap")]}} attribute, which defines the {{"frameset/sitemap"}} route.
))){br}

To get the site map structure, the <tt>SiteMapController</tt> class uses the <tt>SiteMapRepository</tt> class, which implements the <tt>ISiteMapRepository</tt> interface. The <tt>SiteMapRepository</tt> class fetches different entities of the navigation frame and assembles them in one structure, which is then passed to the browser. The system serializes the structure to JSON format by using the standard ASP.NET Web API classes.{br}

The <tt>SiteMapRepository</tt> class uses other classes that have the <tt>Repository</tt> suffix in their names, such as <tt>TileRepository</tt> and <tt>WorkspaceRepository</tt>, to retrieve the entities that are used in the navigation frame. These classes are completely independent from the database. To fetch the entities from the database, the <tt>Repository</tt> classes use the classes that implement the <tt>IEntitySet</tt> interface (<tt>PX.Web.UI.Frameset.Model</tt>), such as <tt>ScreenEntitySet</tt>. The classes use the <tt>MUIGraph</tt> graph to fetch data from the database. (The graph performs only simple data operations, and does not contain any complicated business logic). For each entity, there is a DAC that is used to access data in the database. The DACs correspond to the following database tables, which are used to store data for the elements of the navigation frame. [anchor|#_96b5e227-c50f-40c1-86cb-3f35d2efb484]
===Database Tables===
{| class="checklist" | width="100%" 
|- 
!width="20%" ! Table
!width="80%" ! Description
|- 
| <tt>MUIWorkspace</tt>
| Stores information about the workspaces in the application. For more information on the workspaces, see [HelpRoot_Interface\UIG__con_New_UI_Workspaces|Workspaces] in the Interface Guide.
|- 
| <tt>MUIFavoriteWorkspace</tt>
| Stores information about the workspaces that have been pinned to the main menu. The workspaces that are not included in this list are displayed when a user clicks the '''More Items''' menu item. For details about the main menu, see [HelpRoot_Interface\UIG__con_New_UI_Main_Menu|Main Menu] in the Interface Guide.
|- 
| <tt>MUIArea</tt>
| Stores information about the areas to which workspaces belong. Areas are used to group workspaces in the '''More Items''' menu by types.
|- 
| <tt>MUISubcategory</tt>
| Stores information about the categories of Acumatica ERP forms. Categories are used to group forms in a workspace by types. For details on the categories, see [HelpRoot_Interface\UIG__con_New_UI_Workspaces#_f0e79a7c-3693-4497-bf83-9763e12a7536|Categories].
|- 
| <tt>MUIScreen</tt>
| Stores information about the locations of the Acumatica ERP forms in the user interface. The table is connected to the <tt>SiteMap</tt> table by the <tt>NoteID</tt> column.
|- 
| <tt>MUIPinnedScreen</tt>
| Stores information about the Acumatica ERP forms pinned to workspaces.
|- 
| <tt>MUIFavoriteScreen</tt>
| Stores information about the Acumatica ERP forms that have been added to favorites.
|- 
| <tt>MUITile</tt>
| Stores information about the tiles in workspaces. A tile is a special button on a workspace that you click to open a form or report with predefined settings. For details on the tiles, see [HelpRoot_Interface\UIG__con_New_UI_Workspaces#_61d15fc8-4657-43b1-9f84-5df65deea3c8|Tiles].
|- 
| <tt>MUIFavoriteTile</tt>
| Stores information about the tiles that have been added to favorites.
|- 
| <tt>MUIUserPreferences</tt>
| Stores information about the position of the main menu, which can be on the left of the browser page (default) or on the top of the browser page.
|}{br}

The following diagram illustrates the process of retrieving data for the navigation frame.[anchor|#_b9e26643-5fe3-4b5e-a127-63a7f3e451ef][anchor|#_5f02afa1-7335-4759-b8b1-ca294c546cf5][image:StudioDeveloperGuide/Images/ModernUI_SiteMapRetrieval.png|popup|Retrieval of the site map|450px]
==Rendering of the Elements of the Navigation Frame==
The main script that is used to render the navigation frame is <tt>site.js</tt>. It contains classes that use the React library to render elements of the navigation frame. Each such class includes the <tt>render</tt> method, which uses React classes to render the element. The following tables lists the main classes and their methods.[anchor|#_d87e3ff3-bec8-44e0-9113-bdcfacd0beda]
===The Classes for Rendering the Navigation Frame===
{| class="checklist" | width="100%" 
|- 
!width="20%" ! Class
!width="80%" ! Description
|- 
| <tt>MenuModules</tt>
| 
Renders the main menu (which contains the list of workspaces). For more information on the main menu, see [HelpRoot_Interface\UIG__con_New_UI_Main_Menu|Main Menu] in the Interface Guide. {br}

In addition to the <tt>render</tt> method, the class has the following methods:[anchor|#_a8bdc958-d688-4480-bc51-cef8670fdff8]
*<tt>onClick</tt>: Processes the clicking of the Edit and Delete buttons for the items of the main menu in Menu Editing mode.
*<tt>onClickFav</tt>: Processes the clicking of the Pin button in a workspace.
*<tt>onDragStart</tt>, <tt>onDragOver</tt>, <tt>onDragLeave</tt>, and <tt>onDrop</tt>: Process operations related to dragging the items of the main menu in Menu Editing mode.
For details on menu editing, see [HelpRoot_Interface\UIG__con_New_UI_Edit_Menu_Mode|Menu Editing Mode].
|- 
| <tt>TopLinks</tt>
| 
Renders the tiles in the workspaces. For details about the tiles, see [HelpRoot_Interface\UIG__con_New_UI_Workspaces#_61d15fc8-4657-43b1-9f84-5df65deea3c8|Tiles] in the Interface Guide.{br}

In addition to the <tt>render</tt> method, the class has the following methods:[anchor|#_6b2d176e-0e4f-4dbf-bd1d-2f08d21f2302]
*<tt>onClick</tt>: Processes the clicking of the Edit and Delete buttons for the tiles in Menu Editing mode and clicking of the Favorite button.
*<tt>onDragStart</tt>, <tt>onDragOver</tt>, <tt>onDragLeave</tt>, and <tt>onDrop</tt>: Process operations related to dragging the tiles in Menu Editing mode.
For details on menu editing, see [HelpRoot_Interface\UIG__con_New_UI_Edit_Menu_Mode|Menu Editing Mode].
|- 
| <tt>MenuColumn</tt>
| 
Renders a list of forms in a workspace. For the information about workspaces, see [HelpRoot_Interface\UIG__con_New_UI_Workspaces|Workspaces] in the Interface Guide.{br}

In addition to the <tt>render</tt> method, the class has the following methods:[anchor|#_c0c55751-bca8-4afc-9197-d30e827d1c65]
*<tt>onClick</tt>: Processes the clicking of the Edit and Delete buttons for a form in a workspace in Menu Editing mode.
*<tt>onClickFav</tt>: Processes the clicking of the Favorite icon for a form in a workspace.
*<tt>onClickPin</tt>: Processes the clicking of a check box when a user selects a form in a workspace in Menu Editing mode.
{br}

For more information on menu editing, see [HelpRoot_Interface\UIG__con_New_UI_Edit_Menu_Mode|Menu Editing Mode]. 
|- 
| <tt>ModuleMenu</tt>
| 
Renders all lists of forms in a workspace. For details about workspaces, see [HelpRoot_Interface\UIG__con_New_UI_Workspaces|Workspaces] in the Interface Guide. {br}

In addition to the <tt>render</tt> method, the class has the following methods:[anchor|#_62dae416-365a-4bea-983e-777e6fb67a62]
*<tt>getItemsInCol</tt>, <tt>arrangeLinks</tt>, and <tt>arrangeLinks2</tt>: Arrange links to forms in lists.
*<tt>onDragStart</tt>, <tt>onDragOver</tt>, <tt>onDragLeave</tt>, and <tt>onDrop</tt>: Process operations related to dragging the links to forms in a workspace in Menu Editing mode.

|}{br}

The <tt>site.js</tt> script also contains webpage event handlers, such as handlers for button-clicking events, which use jQuery to handle the events.
==Customization of the User Interface==
An administrator can configure the user interface to fit the work purposes of the organization, as described in [HelpRoot_Administration\AS__mng_User_Interface_Configuration|Customizing the User Interface] in the System Administration Guide.{br}

To change the styles of the elements of the navigation frame, the developer can change the CSS related to these elements. {br}

If a developer has added a new form or report to the Acumatica ERP site in a customization project, the location of the form in the user interface is included in the customization project along with the ''SiteMap'' customization project item, which is created either automatically or manually for the new item. For details, see [HelpRoot_Dev_Customization\CG_GL_Items_Screens_AddingCustom|To Add a New Custom Form to a Project] and [HelpRoot_Dev_Customization\CG_GL_Items_AnaliticalReports_Adding|To Add a Custom Analytical Report to a Project] in the Customization Guide. For the custom generic inquiries and dashboards, the information about the location in the user interface is included in the ''GenericInquiryScreen'' and ''Dashboard'' customization project items, respectively.
==Related Articles==
*[HelpRoot_Interface\UIG__con_New_UI| Acumatica ERP User Interface]]]></column>
			<column name="PlainText"><![CDATA[Technical Overview of the User Interface In this topic, you can find a technical overview of the user interface of  Acumatica ERP.  For more details on the elements of the UI, see   Acumatica ERP User Interface in the Interface Guide. Technologies in the UI The user interface of  Acumatica ERP includes the following frames:  The navigation frame, which is a webpage frame that can be used for navigation between                Acumatica ERP forms.  The  Acumatica ERP form, which is located in the inner frame, which is completely independent of the             navigation frame. The webpage renders the navigation elements of the navigation frame and the forms separately         by using different technologies. The work of  Acumatica ERP forms is based on the ASP.NET Web Forms technology, while the navigation frame uses the         ASP.NET MVC technology with the Razor view engine.  The server side of the navigation frame uses the ASP.NET Web API framework. The client side         uses the React library, which is a JavaScript library, to render main menu items,         workspaces, tiles, and other navigation elements. Work of the Navigation Frame The following diagram shows how the browser renders the elements of the navigation frame. This         process is described in more detail in the remaining sections of this topic. Rendering of the navigation frame Request of main.cshtml The browser retrieves  main.cshtml , which is an ASP.NET MVC view, by     sending the HTTP GET request. On the server side, this request is processed by the       MainController.Main()  method      ( PX.Web.UI.Frameset.Controllers ), which creates a       System.Web.Mvc.ViewResult  object that renders a view to the response. The     returned view contains the basic skeleton of the webpage, which includes the calendar control,     the search control, and the empty menu. Request of the Menu Structure The  getSiteMap  function in  site.js  uses jQuery to send         an AJAX request to ASP.NET Web API of the application server. On the server side, this         request is processed by the  SiteMapController  class           ( PX.Web.UI.Frameset.WebApi.Controllers ).  To match the incoming           request to the appropriate processing classes, the system uses the ASP.NET MVC attribute           routing. For example, the  SiteMapController  class is annotated with the              [FramesetRoutePrefix("sitemap")]  attribute, which defines the              "frameset/sitemap"  route. To get the site map structure, the  SiteMapController  class uses the            SiteMapRepository  class, which implements the            ISiteMapRepository  interface. The  SiteMapRepository          class fetches different entities of the navigation frame and assembles them in one         structure, which is then passed to the browser. The system serializes the structure to JSON         format by using the standard ASP.NET Web API classes. The  SiteMapRepository  class uses other classes that have the            Repository  suffix in their names, such as            TileRepository  and  WorkspaceRepository , to retrieve         the entities that are used in the navigation frame. These classes are completely independent         from the database. To fetch the entities from the database, the            Repository  classes use the classes that implement the            IEntitySet  interface ( PX.Web.UI.Frameset.Model ),         such as  ScreenEntitySet . The classes use the  MUIGraph          graph to fetch data from the database. (The graph performs only simple data operations, and         does not contain any complicated business logic). For each entity, there is a DAC that is         used to access data in the database. The DACs correspond to the following database tables,         which are used to store data for the elements of the navigation frame.  Database Tables Table Description MUIWorkspace Stores information about the workspaces in the application. For more                   information on the workspaces, see  Workspaces in the Interface                   Guide. MUIFavoriteWorkspace Stores information about the workspaces that have been pinned to the main                   menu. The workspaces that are not included in this list are displayed when a user                   clicks the  More Items  menu item. For details about the main                   menu, see  Main Menu in the                   Interface Guide. MUIArea Stores information about the areas to which workspaces belong. Areas are used                   to group workspaces in the  More Items  menu by                   types. MUISubcategory Stores information about the categories of  Acumatica ERP forms. Categories are used to group forms in a workspace by types. For details                   on the categories, see  Categories. MUIScreen Stores information about the locations of the  Acumatica ERP forms in the user interface. The table is connected to the                      SiteMap  table by the  NoteID                    column. MUIPinnedScreen Stores information about the  Acumatica ERP forms pinned to workspaces. MUIFavoriteScreen Stores information about the  Acumatica ERP forms that have been added to favorites. MUITile Stores information about the tiles in workspaces. A tile is a special button                   on a workspace that you click to open a form or report with predefined settings.                   For details on the tiles, see  Tiles. MUIFavoriteTile Stores information about the tiles that have been added to favorites. MUIUserPreferences Stores information about the position of the main menu, which can be on the                   left of the browser page (default) or on the top of the browser page. The following diagram illustrates the process of retrieving data for the navigation frame. Retrieval of the site map Rendering of the Elements of the Navigation Frame The main script that is used to render the navigation frame is  site.js .         It contains classes that use the React library to render elements of the navigation frame.         Each such class includes the  render  method, which uses React classes to         render the element. The following tables lists the main classes and their methods. The Classes for Rendering the Navigation Frame Class Description MenuModules Renders the main menu (which contains the list of workspaces). For more                     information on the main menu, see  Main Menu in the Interface                     Guide.  In addition to the  render  method, the class has the                     following methods: onClick : Processes the clicking of the Edit and Delete                         buttons for the items of the main menu in Menu Editing mode. onClickFav : Processes the clicking of the Pin button in                         a workspace. onDragStart ,  onDragOver ,                            onDragLeave , and  onDrop : Process                         operations related to dragging the items of the main menu in Menu Editing                         mode. For details on menu editing, see  Menu Editing Mode. TopLinks Renders the tiles in the workspaces. For details about the tiles, see  Tiles in the Interface Guide. In addition to the  render  method, the class has the                     following methods: onClick : Processes the clicking of the Edit and Delete                         buttons for the tiles in Menu Editing mode and clicking of the Favorite                         button. onDragStart ,  onDragOver ,                            onDragLeave , and  onDrop : Process                         operations related to dragging the tiles in Menu Editing mode. For details on menu editing, see  Menu Editing Mode. MenuColumn Renders a list of forms in a workspace. For the information about workspaces,                     see  Workspaces in the                     Interface Guide. In addition to the  render  method, the class has the                     following methods: onClick : Processes the clicking of the Edit and Delete                         buttons for a form in a workspace in Menu Editing mode. onClickFav : Processes the clicking of the Favorite icon                         for a form in a workspace. onClickPin : Processes the clicking of a check box when                         a user selects a form in a workspace in Menu Editing mode. For more information on menu editing, see  Menu Editing Mode.  ModuleMenu Renders all lists of forms in a workspace. For details about workspaces, see                        Workspaces in the                     Interface Guide.  In addition to the  render  method, the class has the                     following methods: getItemsInCol ,  arrangeLinks , and                            arrangeLinks2 : Arrange links to forms in lists. onDragStart ,  onDragOver ,                            onDragLeave , and  onDrop : Process                         operations related to dragging the links to forms in a workspace in Menu                         Editing mode. The  site.js  script also contains webpage event handlers, such as handlers         for button-clicking events, which use jQuery to handle the events. Customization of the User Interface An administrator can configure the user interface to fit the work purposes of the         organization, as described in  Customizing the User Interface in the System Administration Guide. To change the styles of the elements of the navigation frame, the developer can change the CSS         related to these elements.  If a developer has added a new form or report to the  Acumatica ERP site in a customization project, the location of the form in the user interface is         included in the customization project along with the  SiteMap  customization project         item, which is created either automatically or manually for the new item. For details, see            To Add a New Custom Form to a Project and  To Add a Custom Analytical Report to a Project in the         Customization Guide. For the custom generic inquiries and dashboards, the information about         the location in the user interface is included in the  GenericInquiryScreen  and            Dashboard  customization project items, respectively. ]]></column>
		</row>
		<row PageID="a23d3b80-e763-46da-9beb-c1447ceae4b3" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="7359e9b0-922b-2c35-1b34-842dc6b850c3" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When a user clicks a button on an ASPX page, such as the '''Save''' button on the toolbar of a form, the webpage creates a postback HTTP request to the server. When processing the request, the application server does the following: commits changes (if required by the operation initiated by the user), executes the operation, and collects data for the response. Then the application server sends the response to the webpage, which renders the new data. The following diagram illustrates this process, which is described in more detail in the sections of this topic.[anchor|#_15312659-29b2-4e45-8316-64f644c76ee4][anchor|#_fed9ed72-0610-465a-bb7c-6d062791a4df][image:StudioDeveloperGuide/Images/ButtonClick_MainSteps.png|popup|Processing a button click|450px]{br}{TOC}
==Sending of the HTTP Request==
When the user clicks a button on a webpage, the page creates an HTTP request to the server. The request includes the following information:[anchor|#_cb2ef695-7782-43d6-8965-9ec9f2130912]
*The values of the key fields of the record currently displayed on the page
*The changes that have been made to the data on the page
*The information on the command that was initiated by the user—the data source ID and the callback name
{br}

The <tt>PXDataSource.TypeName</tt> property defines the graph that processes data for the page. When the application server receives the request, the server creates a new instance of the graph to process the data of the request. The properties of <tt>PXDSCallbackCommand</tt>, such as <tt>CommitChanges</tt> and <tt>RepaintControls</tt>, indicate which operations should be performed on the server in addition to the operation initiated by the user.{br}

The diagram below shows how the HTTP request is sent to the server.[anchor|#_842226d5-628b-4305-beea-c12b0f77a62b][anchor|#_1d9b4e1b-ceed-4aec-a076-308a4d0a03d1][image:StudioDeveloperGuide/Images/ButtonClick_SendHttpRequest.png|popup|Sending the HTTP request|450px]
==Commitment of Changes to the Cache==
If the callback command initiated by the user has the <tt>CommitChanges</tt> property set to {{true}} or the <tt>CommitChangesIDs</tt> property specified, the server commits the changes before executing the command. The graph instance commits the changes to the cache in the order in which the data views are defined in the graph, as shown in the following diagram.[anchor|#_a42d4ba4-d42a-45cd-aecd-8d61adac57eb][anchor|#_69ef7714-050b-4c27-a914-a820afc05ce3][image:StudioDeveloperGuide/Images/ButtonClick_CommitChanges.png|popup|Committing changes|450px]
==Execution of the Command==
After the changes have been committed, the graph instance executes the operation initiated by the user, such as saving data to the database. You can find details on the sequence of events raised when data is inserted, updated, deleted, or saved to the database in [HelpRoot_Dev_Platform\BL__con_Events_Scenarios|Data Manipulation Scenarios].
==Collection of the Data for the Response==
When the command execution is completed, the application server does the following:[anchor|#_c6965c6f-5c32-4c54-a67d-d5b5f3a1a3df]
#If the <tt>RepaintControls</tt> or <tt>RepaintControlIDs</tt> property of <tt>PXDSCallbackCommand</tt> specifies any controls to be repainted after the command is executed, the application server includes in the response all information that is necessary to repaint these controls on the webpage. (By default, the value of the <tt>PXDSCallbackCommand.RepaintControls</tt> property is <tt>All</tt>, which means that all controls on the page are repainted.)
#The application server executes the <tt>Select</tt> method for each data view of the graph.

==Sending of the HTTP Response and Rendering of the Controls==
The application server sends the response to the page. The response includes data in XML format; the parameters that are necessary for the controls to be repainted are specified in JSON format, as shown in the following fragment of the response.{{{{&lt;Controls&gt;
  &lt;Control ID="ctl00_phF_form_edDocType" 
           Props="{items:&quot;INV|Invoice|1;DRM|Debit Memo|1;CRM|
                   Credit Memo|1;FCH|Overdue Charge|1;SMC|Credit WO|1&quot;,
                   value:&quot;FCH&quot;}" /&gt;
  &lt;Control ID="ctl00_phF_form_edRefNbr" Props="{value:&quot;AR005254&quot;}" /&gt;
  ...
&lt;/Controls&gt;
}}}}{br}

The scripts in the browser (the scripts from <tt>PX.Web.UI.Scripts</tt>) find the controls to be repainted by IDs and repaint these controls by using the data provided in the response. Most of the scripts in <tt>PX.Web.UI.Scripts</tt> contain a class that works with one control. For example, <tt>px&#95;textEdit.js</tt> includes the <tt>PXTextEdit</tt> class, which works with the <tt>PXTextEdit</tt> control. 
==Exceptions to the Process==
For the buttons not found on the main toolbar, the process described in this topic may slightly differ. {br}

For example, for the table toolbar buttons, which perform actions on particular rows of grids, the scripts translate the data in XML format, which is returned in the response, to HTML format by using XSLT. {br}

For the buttons in dialog boxes (the <tt>PXSmartPanel</tt> control), no commit of changes is performed. Whether data is selected from the database depends on the particular dialog box. The data that is returned from the server is in HTML format. ]]></column>
			<column name="PlainText"><![CDATA[Processing of a Button Click When a user clicks a button on an ASPX page, such as the  Save  button on the toolbar         of a form, the webpage creates a postback HTTP request to the server. When processing the         request, the application server does the following: commits changes (if required by the         operation initiated by the user), executes the operation, and collects data for the         response. Then the application server sends the response to the webpage, which renders the         new data. The following diagram illustrates this process, which is described in more detail         in the sections of this topic. Processing a button click Sending of the HTTP Request When the user clicks a button on a webpage, the page creates an HTTP request to the server.         The request includes the following information: The values of the key fields of the record currently displayed on the page The changes that have been made to the data on the page The information on the command that was initiated by the user—the data source ID             and the callback name The  PXDataSource.TypeName  property defines the graph that processes data         for the page. When the application server receives the request, the server creates a new         instance of the graph to process the data of the request. The properties of            PXDSCallbackCommand , such as  CommitChanges  and            RepaintControls , indicate which operations should be performed on the         server in addition to the operation initiated by the user. The diagram below shows how the HTTP request is sent to the server. Sending the HTTP request Commitment of Changes to the Cache If the callback command initiated by the user has the  CommitChanges          property set to  true  or the  CommitChangesIDs  property         specified, the server commits the changes before executing the command. The graph instance         commits the changes to the cache in the order in which the data views are defined in the         graph, as shown in the following diagram. Committing changes Execution of the Command After the changes have been committed, the graph instance executes the operation initiated         by the user, such as saving data to the database. You can find details on the sequence of         events raised when data is inserted, updated, deleted, or saved to the database in  Data Manipulation Scenarios. Collection of the Data for the Response When the command execution is completed, the application server does the following: If the  RepaintControls  or  RepaintControlIDs              property of  PXDSCallbackCommand  specifies any controls to be             repainted after the command is executed, the application server includes in the response             all information that is necessary to repaint these controls on the webpage. (By default,             the value of the  PXDSCallbackCommand.RepaintControls  property is                All , which means that all controls on the page are repainted.) The application server executes the  Select  method for each data             view of the graph. Sending of the HTTP Response and Rendering of the Controls The application server sends the response to the page. The response includes data in XML         format; the parameters that are necessary for the controls to be repainted are specified in         JSON format, as shown in the following fragment of the         response. <Controls>
  <Control ID="ctl00_phF_form_edDocType" 
           Props="{items:&quot;INV|Invoice|1;DRM|Debit Memo|1;CRM|
                   Credit Memo|1;FCH|Overdue Charge|1;SMC|Credit WO|1&quot;,
                   value:&quot;FCH&quot;}" />
  <Control ID="ctl00_phF_form_edRefNbr" Props="{value:&quot;AR005254&quot;}" />
  ...
</Controls> The scripts in the browser (the scripts from  PX.Web.UI.Scripts ) find the         controls to be repainted by IDs and repaint these controls by using the data provided in the         response. Most of the scripts in  PX.Web.UI.Scripts  contain a class that         works with one control. For example,  px_textEdit.js  includes the            PXTextEdit  class, which works with the  PXTextEdit          control.  Exceptions to the Process For the buttons not found on the main toolbar, the process described in this topic may         slightly differ.  For example, for the table toolbar buttons, which perform actions on particular rows of         grids, the scripts translate the data in XML format, which is returned in the response, to         HTML format by using XSLT.  For the buttons in dialog boxes (the  PXSmartPanel  control), no commit of         changes is performed. Whether data is selected from the database depends on the particular         dialog box. The data that is returned from the server is in HTML format.  ]]></column>
		</row>
		<row PageID="74dab41d-01eb-480b-8b65-96aaea381024" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can find information about configuration of the &lt;tt&gt;PXDataSource&lt;/tt&gt; control of the ASPX page of Acumatica ERP or an Acumatica Framework-based application.&#xA;==In This Chapter==[anchor|#_2e6024d2-1ded-4e03-8972-8bda21af3876]&#xA;*[HelpRoot_Dev_Platform\CW__con_DataSource_Control|Configuration of the Datasource Control]&#xA;*[HelpRoot_Dev_Platform\CW__con_CallbackCommands|Configuration of Callback Commands]&#xA;*[HelpRoot_Dev_Platform\CW__con_Callbacks|Configuration of Callbacks]&#xA;" PlainText="Configuring the ASPX Page In this chapter, you can find information about configuration of the       PXDataSource  control of the ASPX page of  Acumatica ERP     or an  Acumatica Framework-based     application. In This Chapter Configuration of the Datasource ControlConfiguration of Callback CommandsConfiguration of Callbacks" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="4a23f4eb-24fa-d301-5436-c383d3d9fa75" RecordSourceID="22377" />
		<row PageID="fdfe6193-c90e-4c23-ada5-c28a8768f6fe" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="7bf32eaf-65d6-7751-c4ab-a92ce76f1e27" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Every ASPX page must have a single <tt>PXDataSource</tt> control. The datasource control performs the following functions:[anchor|#ul_tfx_xdy_fm]
*Binds the ASPX page to the graph
*Handles all client-server interactions
*Is represented by the toolbar on the form that corresponds to the ASPX page
[anchor|#section_nn3_2rz_fm]
==TypeName and PrimaryView==
<tt>TypeName</tt> and <tt>PrimaryView</tt> are two required properties of a datasource control. For the <tt>TypeName</tt> property, you have to specify the graph that works with the page. For the <tt>PrimaryView</tt> property, you need to specify the data view that is used for navigation. The navigation actions work with the main DAC of this data view. Acumatica Framework adds callback commands to the datasource control for those actions whose data access class (DAC) is the same as the main DAC of <tt>PrimaryView</tt>.{{{{public class CountryMaint : PXGraph&lt;CountryMaint&gt;
{
    // If PrimaryView is set to Countries, 
    // Framework adds the Cancel and Save callback commands to the
    // datasource control and the corresponding buttons appear on the
    // form toolbar
    public PXCancel&lt;Country&gt; Cancel;
    public PXSave&lt;Country&gt; Save;
   
    public SelectFrom&lt;Country&gt;.View Countries;
}
}}}}]]></column>
			<column name="PlainText"><![CDATA[Configuration of the Datasource Control Every ASPX page must have a single  PXDataSource  control. The datasource         control performs the following functions: Binds the ASPX page to the graph Handles all client-server interactions Is represented by the toolbar on the form that corresponds to the ASPX page TypeName and PrimaryView TypeName  and  PrimaryView  are two required properties of         a datasource control. For the  TypeName  property, you have to specify the         graph that works with the page. For the  PrimaryView  property, you need to         specify the data view that is used for navigation. The navigation actions work with the main         DAC of this data view.  Acumatica Framework         adds callback commands to the datasource control for those actions whose data access class         (DAC) is the same as the main DAC of  PrimaryView . public class CountryMaint : PXGraph<CountryMaint>
{
    // If PrimaryView is set to Countries, 
    // Framework adds the Cancel and Save callback commands to the
    // datasource control and the corresponding buttons appear on the
    // form toolbar
    public PXCancel<Country> Cancel;
    public PXSave<Country> Save;
   
    public SelectFrom<Country>.View Countries;
} ]]></column>
		</row>
		<row PageID="2a23cb2e-82a8-4354-8679-c87dd48b5c6e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="32d2ca60-c187-6e6a-aa4d-050cc25842ff" RecordSourceID="22377">
			<column name="Content"><![CDATA[
A datasource control contains the collection of callback commands that are executed on the server. A callback command is a component of the <tt>PXDSCallbackCommand</tt> type.{br}

The callback command may be statically defined in the ASPX page markup or dynamically added by the framework. When the server initializes the page object, it dynamically adds additional callback commands to the datasource control. Along with system callback commands, the server adds callback commands from the actions defined in the graph. Callback commands are added for only those actions whose DAC is the same as the main DAC of the data view specified in the <tt>PrimaryView</tt> property.((({S:Warn}If the graph is derived from <tt>PXGraph&lt;,&gt;</tt> with two type parameters, the graph includes the default actions, which are shown in the following code.<source lang="csharp">public class PXGraph &lt;TGraph, TPrimary&gt; : PXGraph
    where  TGraph : PXGraph
    where  TPrimary :  class ,  new (), IBqlTable
{
    public  PXSave&lt;TPrimary&gt; Save;
    public  PXCancel&lt;TPrimary&gt; Cancel;
    public  PXInsert&lt;TPrimary&gt; Insert;
    public  PXCopyPasteAction&lt;TPrimary&gt; CopyPaste;
    public  PXDelete&lt;TPrimary&gt; Delete;
    public  PXFirst&lt;TPrimary&gt; First;
    public  PXPrevious&lt;TPrimary&gt; Previous;
    public  PXNext&lt;TPrimary&gt; Next;
    public  PXLast&lt;TPrimary&gt; Last;
}</source>
The framework creates the callback commands for the default actions if the DAC in the second type parameter of <tt>PXGraph&lt;,&gt;</tt> is the same as the main DAC of the data view specified in the <tt>PrimaryView</tt> property.
)))
The framework determines the properties of callback commands by merging the properties specified for the callback command on the ASPX page and the properties of the <tt>PXButton</tt> (or derived) attribute specified for the action. For example, you can set the <tt>CommitChanges</tt> property in both the callback command and the <tt>PXButton</tt> attribute added to the action in the graph. The system uses the logical {{OR}} to the two values: If either of the values is <tt>true</tt>, the resulting value is <tt>true</tt>.{br}

The datasource control provides the collection of <tt>PXDSCallbackCommand</tt> components in the <tt>CallbackCommands</tt> property of the control. The <tt>CallbackCommands</tt> property includes the list of callback commands that have been dynamically added to the datasource control from the definitions of actions in the graph. You can edit these callback commands.{br}

If you change a default property of a dynamically added callback command, the definition of the <tt>PXDSCallbackCommand</tt> component is added to the page, as the following code shows.{{{{&lt;px:PXDataSource ID="ds" ...&gt;
    &lt;CallbackCommands&gt;
        &lt;%-- The Visible property is set to False for the standard
             Next callback command --%&gt;
    &lt;px:PXDSCallbackCommand Name="Next" PopupCommand=""
                            PopupCommandTarget="" 
                            PopupPanel="" Text="" Visible="False"&gt;
}}}}
The following properties of <tt>PXDSCallbackCommand</tt> are used most frequently:[anchor|#ul_lxj_brr_1n]
*<tt>Visible</tt>: Makes the button visible (if the property is set to {{true}}) or invisible (if it is set to {{false}}) on the toolbar. The value of this property is merged with the value of the <tt>Visible</tt> parameter of the <tt>PXUIField</tt> attribute specified for the action. The system uses the logical {{AND}} of the two values: If either of the values is {{false}}, the resulting value is {{false}}. By default, this property equals {{true}}. 
*<tt>CommitChanges</tt>: Enables the posting of modified data when the callback command is invoked. Its value is merged with the value of the <tt>CommitChanges</tt> parameter of the <tt>PXButton</tt> (or derived) attribute specified on the action. The system uses the logical {{OR}} of the two values: If either of the values is {{true}}, the resulting value is {{true}}. By default, this property is equal to {{false}}. 
*<tt>DependOnGrid</tt>: Enables the posting of the current row selected in the grid when the callback command is invoked. The value is the ID of the <tt>PXGrid</tt> control.

==Buttons on the Form Toolbar==
 Acumatica Framework adds buttons to the toolbar of the form; these buttons correspond to the callback commands of the datasource control. A button appears on the toolbar if the <tt>Visible</tt> property of the callback command is equal to {{true}}. To make a button invisible on the toolbar, set the <tt>Visible</tt> property to {{false}} for the appropriate <tt>PXDSCallbackCommand</tt> component as shown in the following code. {{{{// ActionName is the name of the PXAction&lt;DAC&gt; field of the graph
&lt;px:PXDataSource ID="ds" ...&gt;
    &lt;CallbackCommands&gt;
        &lt;px:PXDSCallbackCommand Name="ActionName"
                                PostData="Self" Visible="False" /&gt;
}}}}The <tt>Visible</tt> property can also be defined in the <tt>PXUIField</tt> attribute on the action. In this case, the system applies the logical {{AND}} to the two values: If either of the values is <tt>false</tt>, the resulting value is <tt>false</tt>.]]></column>
			<column name="PlainText"><![CDATA[Configuration of Callback Commands A datasource control contains the collection of callback commands that are executed on the         server. A callback command is a component of the  PXDSCallbackCommand          type. The callback command may be statically defined in the ASPX page markup or dynamically added         by the framework. When the server initializes the page object, it dynamically adds         additional callback commands to the datasource control. Along with system callback commands,         the server adds callback commands from the actions defined in the graph. Callback commands         are added for only those actions whose DAC is the same as the main DAC of the data view         specified in the  PrimaryView  property. If the graph is derived from  PXGraph<,>  with two type parameters,         the graph includes the default actions, which are shown in the following           code. public class PXGraph <TGraph, TPrimary> : PXGraph
    where  TGraph : PXGraph
    where  TPrimary :  class ,  new (), IBqlTable
{
    public  PXSave<TPrimary> Save;
    public  PXCancel<TPrimary> Cancel;
    public  PXInsert<TPrimary> Insert;
    public  PXCopyPasteAction<TPrimary> CopyPaste;
    public  PXDelete<TPrimary> Delete;
    public  PXFirst<TPrimary> First;
    public  PXPrevious<TPrimary> Previous;
    public  PXNext<TPrimary> Next;
    public  PXLast<TPrimary> Last;
} The           framework creates the callback commands for the default actions if the DAC in the second           type parameter of  PXGraph<,>  is the same as the main DAC of the data           view specified in the  PrimaryView  property. The framework determines the properties of callback commands by merging the properties         specified for the callback command on the ASPX page and the properties of the            PXButton  (or derived) attribute specified for the action. For example,         you can set the  CommitChanges  property in both the callback command and         the  PXButton  attribute added to the action in the graph. The system uses         the logical  OR  to the two values: If either of the values is            true , the resulting value is  true . The datasource control provides the collection of  PXDSCallbackCommand          components in the  CallbackCommands  property of the control. The            CallbackCommands  property includes the list of callback commands that         have been dynamically added to the datasource control from the definitions of actions in the         graph. You can edit these callback commands. If you change a default property of a dynamically added callback command, the definition of         the  PXDSCallbackCommand  component is added to the page, as the following         code shows. <px:PXDataSource ID="ds" ...>
    <CallbackCommands>
        <%-- The Visible property is set to False for the standard
             Next callback command --%>
    <px:PXDSCallbackCommand Name="Next" PopupCommand=""
                            PopupCommandTarget="" 
                            PopupPanel="" Text="" Visible="False"> The following properties of  PXDSCallbackCommand  are used most         frequently: Visible : Makes the button visible (if the property is set to              true ) or invisible (if it is set to  false ) on the           toolbar. The value of this property is merged with the value of the              Visible  parameter of the  PXUIField  attribute           specified for the action. The system uses the logical  AND  of the two           values: If either of the values is  false , the resulting value is              false . By default, this property equals  true .  CommitChanges : Enables the posting of modified data when the callback           command is invoked. Its value is merged with the value of the              CommitChanges  parameter of the  PXButton  (or           derived) attribute specified on the action. The system uses the logical              OR  of the two values: If either of the values is  true ,           the resulting value is  true . By default, this property is equal to              false .  DependOnGrid : Enables the posting of the current row selected in the           grid when the callback command is invoked. The value is the ID of the              PXGrid  control. Buttons on the Form Toolbar  Acumatica Framework         adds buttons to the toolbar of the form; these buttons correspond to the callback commands         of the datasource control. A button appears on the toolbar if the  Visible          property of the callback command is equal to  true . To make a button         invisible on the toolbar, set the  Visible  property to            false  for the appropriate  PXDSCallbackCommand          component as shown in the following code.        // ActionName is the name of the PXAction<DAC> field of the graph
<px:PXDataSource ID="ds" ...>
    <CallbackCommands>
        <px:PXDSCallbackCommand Name="ActionName"
                                PostData="Self" Visible="False" /> The          Visible  property can also be defined in the  PXUIField        attribute on the action. In this case, the system applies the logical  AND  to       the two values: If either of the values is  false , the resulting value is          false . ]]></column>
		</row>
		<row PageID="417ca500-35a1-4f3d-9d76-e64a198126af" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="050080b0-f949-6f0a-84d4-f2f7786d757f" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#section_wjt_skp_xm]
Events are generated on the server side of your application when the client side requests data or posts changes made by a user. When the client posts data to the server, the client is initiating a callback to the server. Callbacks are initiated in the following cases:[anchor|#ul_yxq_zxg_nn]
*Focus is lost for an input control with the <tt>CommitChanges</tt> property set to <tt>True</tt>.
*Focus is lost for a grid column with the <tt>CommitChanges</tt> property set to <tt>True</tt>.
*A user finishes editing a row in a grid by proceeding to the next row or by pressing Ctrl+Enter on the keyboard.
*A user clicks a button with the <tt>CommitChanges</tt> property set to <tt>True</tt>.

By default, an Acumatica Framework form executes a callback when a user clicks one of the standard buttons on the form toolbar and when a user changes the value in a key field. You can also enable a callback for any input control or button by setting the <tt>CommitChanges</tt> property to <tt>True</tt> in the ASPX page. By default, the callback is off, so when a user changes a value in some field and shifts the focus away from it, the browser doesn&rsquo;t post anything to the server; it does, however, keep the change in memory.{br}

When a callback is triggered, the client posts all the data from the whole form that has been modified since the last callback.{br}

For information on how to configure the callback on a control, see [HelpRoot_Dev_Platform\CW__how_Enable_Callback|To Enable Callback for a Control]. For details on how to configure the callback for a button, see [HelpRoot_Dev_Platform\BL__con_Actions|Configuration of Actions].]]></column>
			<column name="PlainText"><![CDATA[Configuration of Callbacks Events are generated on the server side of your application when the client side requests         data or posts changes made by a user. When the client posts data to the server, the client         is initiating a callback to the server. Callbacks are initiated in the following cases: Focus is lost for an input control with the  CommitChanges  property           set to  True . Focus is lost for a grid column with the  CommitChanges  property set           to  True . A user finishes editing a row in a grid by proceeding to the next row or by pressing           Ctrl+Enter on the keyboard. A user clicks a button with the  CommitChanges  property set to              True . By default, an  Acumatica Framework         form executes a callback when a user clicks one of the standard buttons on the form toolbar         and when a user changes the value in a key field. You can also enable a callback for any         input control or button by setting the  CommitChanges  property to            True  in the ASPX page. By default, the callback is off, so when a user         changes a value in some field and shifts the focus away from it, the browser doesn't post         anything to the server; it does, however, keep the change in memory. When a callback is triggered, the client posts all the data from the whole form that has         been modified since the last callback. For information on how to configure the callback on a control, see  To Enable Callback for a Control. For details on how to configure the callback for a         button, see  Configuration of Actions. ]]></column>
		</row>
		<row PageID="e62f99c6-20a7-4f27-929b-b5743c1d0d67" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can find information about the configuration of different types of containers, such as &lt;tt&gt;PXFormView&lt;/tt&gt;, &lt;tt&gt;PXGrid&lt;/tt&gt;, &lt;tt&gt;PXTab&lt;/tt&gt;, &lt;tt&gt;PXTreeView&lt;/tt&gt;, and &lt;tt&gt;PXPanel&lt;/tt&gt;.&#xA;==In This Chapter==[anchor|#_8dbb4e58-ef22-4928-86e9-ed1aab41fd64]&#xA;*[HelpRoot_Dev_Platform\CW__con_Configuration_of_Containers|Configuration of Container Controls]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXForm_Properties_DataMember|Use of the DataMember Property of Containers]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXForm_Properties_SkinID|Use of the SkinID Property of Containers]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXForm_Properties_Caption|Use of the Caption Property of Containers]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXForm_AddBox_DataViews|Use of Multiple Data Views for Boxes in Containers]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXPanel|Use of the PXPanel Container]&#xA;" PlainText="Configuring Containers In this chapter, you can find information about the configuration of different types of     containers, such as  PXFormView ,  PXGrid ,       PXTab ,  PXTreeView , and  PXPanel . In This Chapter Configuration of Container ControlsUse of the DataMember Property of ContainersUse of the SkinID Property of ContainersUse of the Caption Property of ContainersUse of Multiple Data Views for Boxes in ContainersUse of the PXPanel Container" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="70b69e81-afee-d675-d2d3-1d2fd5cce2e1" RecordSourceID="22377" />
		<row PageID="ec57712c-8e1e-48aa-9d8f-4e24b026d702" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="74dded73-934b-3545-4680-6f1260852136" RecordSourceID="22377">
			<column name="Content"><![CDATA[
 Acumatica Framework provides the following container controls:[anchor|#ul_zps_s4y_fm]
*<tt>PXFormView</tt> (form)
*<tt>PXGrid</tt> (grid)
*<tt>PXTab</tt>, which consists of <tt>PXTabItem</tt> (tab) elements
*<tt>PXTreeView</tt>
* <tt>PXPanel</tt>

To configure a container control, you have to specify the data binding properties for it and add input controls to the container. The following properties are required for every container control:[anchor|#ul_qls_sln_pm]
*<tt>DataSourceID</tt>: Binds the container to a datasource control
*<tt>DataMember</tt>: Specifies the data view that provides data for the container

In the <tt>DataSourceID</tt> property, you have to specify the ID of the datasource control on the page. When you create a page from a template, this property is already specified for the default containers added from the template. When you add a nested container, you have to specify the <tt>DataSourceID</tt> property. By default, in all page templates, the datasourse control has the ''ds'' ID. After you have specified a <tt>DataSourceID</tt> for the container, you can specify the <tt>DataMember</tt> property for it. The <tt>DataMember</tt> property links the container to the data view defined in the graph. In the container, you can define input controls for data fields available through that data view.]]></column>
			<column name="PlainText"><![CDATA[Configuration of Container Controls  Acumatica Framework provides the following container controls: PXFormView  (form) PXGrid  (grid) PXTab , which consists of  PXTabItem  (tab)           elements PXTreeView PXPanel To configure a container control, you have to specify the data binding properties for it         and add input controls to the container. The following properties are required for every         container control: DataSourceID : Binds the container to a datasource control DataMember : Specifies the data view that provides data for the           container In the  DataSourceID  property, you have to specify the ID of the         datasource control on the page. When you create a page from a template, this property is         already specified for the default containers added from the template. When you add a nested         container, you have to specify the  DataSourceID  property. By default, in         all page templates, the datasourse control has the  ds  ID. After you have specified a            DataSourceID  for the container, you can specify the            DataMember  property for it. The  DataMember  property         links the container to the data view defined in the graph. In the container, you can define         input controls for data fields available through that data view. ]]></column>
		</row>
		<row PageID="f4e4f1df-64bd-40b9-b487-bdc099ee952c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="90bff23c-e828-5c2c-a68b-fedd07c39146" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you need to find out which data view provides data for a control container on a form, perform a search to find the ''DataMember'' string in the appropriate ASPX code. The <tt>DataMember</tt> property is used to bind a control container of a form to a data view defined in the business logic controller (BLC, also referred as ''graph'') of the form. The property value is the name of the data view. 
==Container Types That Have the DataMember Property==
In Acumatica Framework, <tt>DataMember</tt> is used to specify a data view for the following container types:[anchor|#_c9049869-3c3c-4b36-9248-24214d562b81]
*<tt>PXFormView</tt>
* <tt>PXGrid</tt>
* <tt>PXTab</tt>
* <tt>PXTreeView</tt>
*:((({S:Warn}The <tt>PXTreeView</tt> container is not supported by the tools of the Acumatica Customization           Platform.
)))

By default, a nested container inherits the <tt>DataMember</tt> property from the parent container. If a nested container is <tt>PXFormView</tt>, <tt>PXGrid</tt>, or <tt>PXTab</tt>, it can be bound to another data view.{br}

If the <tt>DataMember</tt> property is available for other ASPX objects, it has a special purpose. For example, you can specify the <tt>DataMember</tt> property for a <tt>PXSelector</tt> lookup control to define the appropriate data view for the grid of the lookup window.
==Property Value==
Each <tt>DataMember</tt> property value can correspond to any data view name of the BLC. Any data view except for the main data view can be used by an unlimited number of containers. The main data view must be bound to a single container.{br}

For a container to contain a box for a data field, the container must be bound to a data view declared within a BLC for the following reasons:[anchor|#_c847b090-d4c7-442a-af1c-bd6dd13db0d2]
*A data field is declared in a data access class (DAC). An instance of the DAC record can exist in the cache of a BLC that contains the declaration of a data view with the DAC reference in the BQL statement.
*Each time a data record is selected in the container, the container creates a callback to the <tt>PXDataSource</tt> control that is specified in the <tt>DataSourceID</tt> property of the container. The data source control creates a remote procedure call to the application server to execute the ''Display'' operation on the data view that is specified as the <tt>DataMember</tt> for the container. The data view checks the existence of the record in the cache; if the check fails, the data view executes the BQL request and stores the obtained record in the cache.
*The data view provides all data exchange operations with the database, cache, and <tt>PXDataSource</tt> control.
]]></column>
			<column name="PlainText"><![CDATA[Use of the DataMember Property of Containers If you need to find out which data view provides data for a control     container on a form, perform a search to find the  DataMember  string in the appropriate     ASPX code. The  DataMember  property is used to bind a control container of a     form to a data view defined in the business logic controller (BLC, also referred as      graph ) of the form. The property value is the name of the data view.  Container Types That Have the DataMember Property In  Acumatica Framework,  DataMember  is used to specify a data view for the following container     types: PXFormView PXGrid PXTab PXTreeView The  PXTreeView  container is not       supported by the tools of the  Acumatica Customization           Platform. By default, a nested container inherits the  DataMember  property from the     parent container. If a nested container is  PXFormView ,       PXGrid , or  PXTab , it can be bound to another data     view. If the  DataMember  property is available for other ASPX objects, it has a     special purpose. For example, you can specify the  DataMember  property for a       PXSelector  lookup control to define the appropriate data view for the grid     of the lookup window. Property Value Each  DataMember  property value can correspond to any data view name of the     BLC. Any data view except for the main data view can be used by an unlimited number of     containers. The main data view must be bound to a single container. For a container to contain a box for a data field, the container must be bound to a data view     declared within a BLC for the following reasons: A data field is declared in a data access class (DAC). An instance of the DAC record can      exist in the cache of a BLC that contains the declaration of a data view with the DAC reference      in the BQL statement. Each time a data record is selected in the container, the container creates a callback to      the  PXDataSource  control that is specified in the        DataSourceID  property of the container. The data source control creates a      remote procedure call to the application server to execute the  Display  operation on the      data view that is specified as the  DataMember  for the container. The data      view checks the existence of the record in the cache; if the check fails, the data view      executes the BQL request and stores the obtained record in the cache. The data view provides all data exchange operations with the database, cache, and        PXDataSource  control. ]]></column>
		</row>
		<row PageID="ce75ce73-a264-41a6-9545-68ffe2003d45" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="3792fd1f-fd7d-15ee-f464-52990dd1afc0" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In the code of Acumatica ERP, predefined skins are used to assign a style and a set of toolbar buttons to a container. The <tt>SkinID</tt> property of a container specifies which of these skins the system should apply to the container. A skin is specific to a particular container; you cannot share a skin setting between containers of different types. If you do not set the <tt>SkinID</tt> property, the container uses the default skin, if one is defined.
==Predefined Skins==
The following table lists and describes the predefined skins that are recommended to use for the <tt>PXFormView</tt>, <tt>PXGrid</tt>, and <tt>PXPanel</tt> containers.[anchor|#_67307219-dbee-440f-a18e-24613a9a35e4]
{| class="checklist" | width="100%" 
|- 
!width="12%" ! UI Element
!width="12%" ! SkinID
!width="50%" ! Description
!width="25%" ! Example
|- 
| <tt>PXFormView</tt>
|  ''Transparent''
| Is used to display a simple form container that has no caption and cannot be collapsed.
| The form container on the '''Financial Details''' tab item of the [HelpRoot_FormReference\AP_30_10_00|Bills and Adjustments] ([~/?ScreenId=AP301000|AP301000]) form
|- 
| <tt>PXGrid</tt>
|  ''Attributes''
| Is used to display a simple grid without a toolbar. The grid contains a predefined set of rows, which can be edited.
| The '''Attributes''' grid on the Attributes tab item of the [HelpRoot_FormReference\IN_20_20_00|Non-Stock Items] ([~/?ScreenId=IN202000|IN202000]) form
|- 
| 
| ''Details''
| Is used to render a detail grid in a master-detail data entry form. The grid has a toolbar that holds the default actions, such as '''Refresh''', '''Add''', '''Remove''', '''Fit to Screen''', and '''Export to Excel'''; it can also hold custom actions. The grid has no caption and paging is allowed.
| The grid on the '''1099 Settings''' tab item of the [HelpRoot_FormReference\AP_10_10_00|Accounts Payable Preferences] ([~/?ScreenId=AP101000|AP101000]) form
|- 
| 
| ''Inquire''
| Is used to display data without rows being added or removed. The grid has a toolbar that contains the '''Refresh''', '''Fit to Screen''', and '''Export to Excel''' default actions and can contain custom actions. The grid has no caption, and paging is allowed.
| The grid on the '''Attributes''' tab item of the [HelpRoot_FormReference\AR_30_30_00|Customers] ([~/?ScreenId=AR303000|AR303000]) form
|- 
| 
| ''Primary''
| Is used to display an editable primary grid that does not contain its own toolbar. To work with the grid, the user applies the action buttons of the form toolbar. The grid has no caption, and paging is allowed.
| The grid on the [HelpRoot_FormReference\CA_20_30_00|Entry Types] ([~/?ScreenId=CA203000|CA203000]) form
|- 
| 
| ''PrimaryInquire''
| Is used to display a primary grid without the availability to edit data. The grid does not contain its own toolbar. To work with the grid, the user applies the action buttons of the form toolbar, which does not contain the '''Add''', '''Delete''', and '''Switch Between Grid and Form''' buttons. The grid has no caption, and paging and filtering are allowed.
| The grid on the [HelpRoot_FormReference\AP_50_10_00|Release AP Documents] ([~/?ScreenId=AP501000|AP501000]) form
|- 
| 
| ''ShortList''
| Is used to display a small grid with a few records inside a form view. The grid has a toolbar that contains the '''Refresh''', '''Add''', and '''Remove''' default actions.
| The '''Sales Categories''' grid on the Attributes tab item of the [HelpRoot_FormReference\IN_20_20_00|Non-Stock Items] ([~/?ScreenId=IN202000|IN202000]) form
|- 
| <tt>PXPanel</tt>
|  ''Buttons''
| Is used in dialog boxes to display a horizontal row of buttons with right alignment.
| The group of buttons in the '''Add PO Receipt''' dialog box, which opens if you click the '''Add PO Receipt''' button in the toolbar of the '''Document Details''' tab item of the [HelpRoot_FormReference\AP_30_10_00|Bills and Adjustments] ([~/?ScreenId=AP301000|AP301000]) form
|- 
| 
| ''Transparent''
| Is used to group controls in a form container. The panel has no caption.
| The group of controls on the '''Template Settings''' tab item of the [HelpRoot_FormReference\SO_20_10_00|Order Types] ([~/?ScreenId=SO201000|SO201000]) form
|}]]></column>
			<column name="PlainText"><![CDATA[Use of the SkinID Property of Containers In the code of  Acumatica ERP,     predefined skins are used to assign a style and a set of toolbar buttons to a container. The       SkinID  property of a container specifies which of these skins the system     should apply to the container. A skin is specific to a particular container; you cannot share a     skin setting between containers of different types. If you do not set the       SkinID  property, the container uses the default skin, if one is defined. Predefined Skins The following table lists and describes the predefined skins that are recommended to use for     the  PXFormView ,  PXGrid , and  PXPanel      containers. UI Element SkinID Description Example PXFormView Transparent Is used to display a simple form container that has no caption and cannot be         collapsed. The form container on the  Financial Details  tab item of the            ([~/?ScreenId=AP301000|AP301000]) Bills and Adjustments (AP301000) form PXGrid Attributes Is used to display a simple grid without a toolbar. The grid contains a predefined set         of rows, which can be edited. The  Attributes  grid on the Attributes tab item of the   ([~/?ScreenId=IN202000|IN202000]) Non-Stock Items (IN202000) form Details Is used to render a detail grid in a master-detail data entry form. The grid has a         toolbar that holds the default actions, such as  Refresh ,           Add ,  Remove ,  Fit to          Screen , and  Export to Excel ; it can also hold custom         actions. The grid has no caption and paging is allowed. The grid on the  1099 Settings  tab item of the   ([~/?ScreenId=AP101000|AP101000]) Accounts Payable Preferences (AP101000) form Inquire Is used to display data without rows being added or removed. The grid has a toolbar         that contains the  Refresh ,  Fit to Screen , and           Export to Excel  default actions and can contain custom actions. The         grid has no caption, and paging is allowed. The grid on the  Attributes  tab item of the   ([~/?ScreenId=AR303000|AR303000]) Customers (AR303000) form Primary Is used to display an editable primary grid that does not contain its own toolbar. To         work with the grid, the user applies the action buttons of the form toolbar. The grid has no         caption, and paging is allowed. The grid on the   ([~/?ScreenId=CA203000|CA203000]) Entry Types (CA203000) form PrimaryInquire Is used to display a primary grid without the availability to edit data. The grid does         not contain its own toolbar. To work with the grid, the user applies the action buttons of         the form toolbar, which does not contain the  Add ,           Delete , and  Switch Between Grid and Form          buttons. The grid has no caption, and paging and filtering are allowed. The grid on the   ([~/?ScreenId=AP501000|AP501000]) Release AP Documents (AP501000) form ShortList Is used to display a small grid with a few records inside a form view. The grid has a         toolbar that contains the  Refresh ,  Add , and           Remove  default actions. The  Sales Categories  grid on the Attributes tab item of the            ([~/?ScreenId=IN202000|IN202000]) Non-Stock Items (IN202000) form PXPanel Buttons Is used in dialog boxes to display a horizontal row of buttons with right         alignment. The group of buttons in the  Add PO Receipt  dialog box, which         opens if you click the  Add PO Receipt  button in the toolbar of the           Document Details  tab item of the   ([~/?ScreenId=AP301000|AP301000]) Bills and Adjustments (AP301000) form Transparent Is used to group controls in a form container. The panel has no caption. The group of controls on the  Template Settings  tab item of the            ([~/?ScreenId=SO201000|SO201000]) Order Types (SO201000) form ]]></column>
		</row>
		<row PageID="16edab7b-9ec3-4383-a92d-253fe8eee07d" Language="en-US" PageRevisionID="1" Content="&#xA;If you plan to use a container in the mobile site map, we recommend that you specify a unique name for the &lt;tt&gt;Caption&lt;/tt&gt; property of the container. Then in the mobile site map, you can refer to the container by the specified caption in the &lt;tt&gt;Name&lt;/tt&gt; attribute of the &lt;tt&gt;&amp;lt;sm:Container&amp;gt;&lt;/tt&gt; tag, as the following code shows.{{{{&amp;lt;sm:Container Name=&quot;ValueOfTheCaptionProperty&quot;&amp;gt;&#xA;...&#xA;&amp;lt;/sm:Container&amp;gt;&#xA;}}}}{br}&#xA;&#xA;Otherwise, in the WSDL schema, the API web service assigns to the container the name of the first child element. If you use this name in the mobile site map, an error may occur after the container content is reordered because the container name might be changed in the WSDL schema." PlainText="Use of the Caption Property of Containers If you plan to use a container in the mobile site map, we recommend that you specify a unique       name for the  Caption  property of the container. Then in the mobile site       map, you can refer to the container by the specified caption in the  Name        attribute of the  &lt;sm:Container&gt;  tag, as the following code       shows. &lt;sm:Container Name=&quot;ValueOfTheCaptionProperty&quot;&gt;&#xA;...&#xA;&lt;/sm:Container&gt; Otherwise, in the WSDL schema, the API web service assigns to the container the name of the             first child element. If you use this name in the mobile site map, an error may occur             after the container content is reordered because the container name might be changed in             the WSDL schema. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="65b7334b-b545-e9e6-ac2e-a48af037f4f7" RecordSourceID="22377" />
		<row PageID="837c9078-dcd9-48f4-bb8b-d3a1fec7fb82" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="98a315b3-e3b4-ff35-4a04-d3395f88e918" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The Acumatica Customization           Platform supports the use of multiple data views for controls in the same container of an ASPX page.{br}

For example, you can create a container and set the <tt>DataMember</tt> property to the name of the data view that provides most of the fields for boxes in the container. If you also want to create a control for a data field that cannot be accessible through that data view but can be accessible through another data view of the same graph specified in the <tt>TypeName</tt> property of the <tt>PXDataSource</tt> control, you can specify the required data view immediately in the <tt>DataField</tt> property, as follows.{{{{&lt;px:PXField ... DataField="DataViewName.FieldName" /&gt;
}}}}{br}

The following code snippet shows how to use the {{MyDataView}}, {{AnotherDataView}}, and {{OnceMoreDataView}} data views declared in the same graph or in extensions for the graph to define boxes for data fields in a <tt>PXFormView</tt> container on an Acumatica ERP form.{{{{&lt;px:PXFormView ... DataMember="MyDataView" ...&gt;
  ...
    &lt;px:PXNumberEdit ... DataField="MyField_01" /&gt;
    &lt;px:PXSegmentMask ... DataField="MyField_02" /&gt;
    &lt;px:PXDateTimeEdit ... DataField="AnotherDataView.FieldName" /&gt;
    &lt;px:PXTextEdit ... DataField="MyField_05" /&gt;
    &lt;px:PXSelector ... DataField="OnceMoreDataView.OtherFieldName" /&gt;
  ...
&lt;/px:PXFormView&gt;

}}}}]]></column>
			<column name="PlainText"><![CDATA[Use of Multiple Data Views for Boxes in Containers The  Acumatica Customization           Platform supports the use of multiple data views for controls in the same container of an ASPX    page. For example, you can create a container and set the  DataMember  property to       the name of the data view that provides most of the fields for boxes in the container. If you       also want to create a control for a data field that cannot be accessible through that data       view but can be accessible through another data view of the same graph specified in the          TypeName  property of the  PXDataSource  control, you can       specify the required data view immediately in the  DataField  property, as       follows. <px:PXField ... DataField="DataViewName.FieldName" /> The following code snippet shows how to use the  MyDataView ,          AnotherDataView , and  OnceMoreDataView  data views declared       in the same graph or in extensions for the graph to define boxes for data fields in a          PXFormView  container on an  Acumatica ERP       form. <px:PXFormView ... DataMember="MyDataView" ...>
  ...
    <px:PXNumberEdit ... DataField="MyField_01" />
    <px:PXSegmentMask ... DataField="MyField_02" />
    <px:PXDateTimeEdit ... DataField="AnotherDataView.FieldName" />
    <px:PXTextEdit ... DataField="MyField_05" />
    <px:PXSelector ... DataField="OnceMoreDataView.OtherFieldName" />
  ...
</px:PXFormView>
 ]]></column>
		</row>
		<row PageID="664a1925-03f2-41c2-a35a-348fb7738580" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="6bf417fa-5992-b813-6e2d-5158f683f333" RecordSourceID="22377">
			<column name="Content"><![CDATA[
<tt>PXPanel</tt> is a container that provides an independent set of controls on the form and is used to define complex layouts. A <tt>PXPanel</tt> container has no <tt>DataMember</tt> property and cannot be independently bound to a data view. The panel can display only fields from the data view to which the parent form or tab control is bound. The panel is used only for defining blocks of controls within a form. You can add layout rules to the panel to arrange the controls within the container.{br}

 If you need to add controls that display DAC fields retrieved by an another data view, use a nested form (a <tt>PXFormView</tt> control) instead of a panel. Unlike <tt>PXPanel</tt>, the <tt>PXFormView</tt> control has the <tt>DataMember</tt> property and can be bound to a data view.{br}

You can configure the appearance of a <tt>PXPanel</tt> container in the UI by specifying the following properties of the control:[anchor|#ul_anq_ybz_4m]
*<tt>Caption</tt>: Defines the caption for the set of controls enclosed in the panel.
*<tt>RenderStyle</tt>: Defines the panel style in the UI:
**<tt>RoundBorder</tt> (default): The panel border and caption are displayed in the UI. This style requires the <tt>Caption</tt> property.
**<tt>Fieldset</tt>: The underlined caption is displayed in the UI. This style requires the <tt>Caption</tt> property.
**<tt>Simple</tt>: No border or caption is displayed in the UI. This style doesn&rsquo;t require the <tt>Caption</tt> property.

In the ASPX code, the <tt>PXPanel</tt> container is always nested in a form or tab item and is defined as follows.{{{{&lt;px:PXFormView ID="form" ...&gt;
    &lt;Template&gt;
        &lt;px:PXLayoutRule runat="server" StartRow="True"&gt;&lt;/px:PXLayoutRule&gt;
       <b> &lt;px:PXPanel ID="PXPanel1" runat="server" Caption="Shipment Information"&gt;<b>
            ...
        <b>&lt;/px:PXPanel&gt;<b>
    &lt;/Template&gt;
&lt;/px:PXFormView&gt;
}}}}]]></column>
			<column name="PlainText"><![CDATA[Use of the PXPanel Container PXPanel  is a container that provides an independent set of controls on         the form and is used to define complex layouts. A  PXPanel  container has         no  DataMember  property and cannot be independently bound to a data view.         The panel can display only fields from the data view to which the parent form or tab control         is bound. The panel is used only for defining blocks of controls within a form. You can add         layout rules to the panel to arrange the controls within the container.  If you need to add controls that display DAC fields retrieved by an another data view, use         a nested form (a  PXFormView  control) instead of a panel. Unlike            PXPanel , the  PXFormView  control has the            DataMember  property and can be bound to a data view. You can configure the appearance of a  PXPanel  container in the UI by         specifying the following properties of the control: Caption : Defines the caption for the set of controls enclosed in the           panel. RenderStyle : Defines the panel style in the UI: RoundBorder  (default): The panel border and caption are displayed               in the UI. This style requires the  Caption  property. Fieldset : The underlined caption is displayed in the UI. This               style requires the  Caption  property. Simple : No border or caption is displayed in the UI. This style               doesn't require the  Caption  property. In the ASPX code, the  PXPanel  container is always nested in a form or         tab item and is defined as follows. <px:PXFormView ID="form" ...>
    <Template>
        <px:PXLayoutRule runat="server" StartRow="True"></px:PXLayoutRule>
         <px:PXPanel ID="PXPanel1" runat="server" Caption="Shipment Information"> 
            ...
         </px:PXPanel> 
    </Template>
</px:PXFormView> ]]></column>
		</row>
		<row PageID="32679a53-e50a-4321-929c-6596712fb754" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can learn how to configure tables (grids) on ASPX pages by using the &lt;tt&gt;PXGrid&lt;/tt&gt; and &lt;tt&gt;PXGridColumn&lt;/tt&gt; ASPX objects.&#xA;==In This Chapter==[anchor|#_7eb9c2b3-f022-4732-bcb3-637d81ba78ac]&#xA;*[HelpRoot_Dev_Platform\CW__con_Configuration_of_Grids|Configuration of Grids]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXForm_Properties_SyncPosition|Use of the SyncPosition Property of PXGrid]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXGrid_AddColumn_DistplayModeProperty|Use of the DisplayMode Property of PXGridColumn]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXGrid_AddColumn_TypeProperty|Use of the Type Property of PXGridColumn]&#xA;*[HelpRoot_Dev_Platform\CW__con_Control_for_Joined_Field|Controls for Joined Data Fields]&#xA;" PlainText="Configuring Tables In this chapter, you can learn how to configure tables (grids) on ASPX pages by using the       PXGrid  and  PXGridColumn  ASPX objects. In This Chapter Configuration of GridsUse of the SyncPosition Property of PXGridUse of the DisplayMode Property of PXGridColumnUse of the Type Property of PXGridColumnControls for Joined Data Fields" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ca8a9c73-57ed-efc6-db0c-31418124199f" RecordSourceID="22377" />
		<row PageID="09489570-a3d9-4fef-b6d8-de0a6b4fb5b8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="bca0777a-9fe2-b780-5ec5-3de663bd2824" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To configure a grid on a form, you do the following:[anchor|#ol_v4d_ws2_pm]
#Specify the <tt>DataMember</tt> property of the grid to bind the grid to a data view that provides data to work through the grid.
#Add columns to the grid.
#Specify the <tt>SkinID</tt> property of the grid, which defines a set of default grid toolbar buttons.
#Add input controls to the grid, if needed.
#Enable form view mode for the grid, if needed.
#Specify the specific properties of the grid, if needed.

You can specify the following properties of a grid (<tt>PXGrid</tt>) control:[anchor|#ul_sqn_lt2_pm]
*<tt>DataMember</tt>: Specifies the data view that provides data for the grid. This property is required for data binding, along with the predefined <tt>DataSourceID</tt>.
*<tt>Columns</tt>: Provides the collection of columns of the grid.
*<tt>SkinID</tt>: Defines the style and behavior of the grid; this property includes a set of default grid toolbar buttons and the rendering of parameters of the grid.
*<tt>Mode</tt>&gt;<tt>AllowFormEdit</tt>: Enables form view mode for the grid.
*<tt>SyncPosition</tt>: Enables the synchronization of the selected row with the <tt>Current</tt> property of the cache object. The <tt>Current</tt> property is set to each row selected by the user in the grid. 
*<tt>StatusField</tt>: Specifies the field that is displayed at the bottom of the grid as the grid information status.
*<tt>AutoSize</tt>&gt;<tt>Enabled</tt>: Enables the grid height to expand to the entire area of the parent container.
*<tt>Width</tt>: Sets the width of the grid within the parent container (a standard ASP.NET property of a control). To expand a nested grid to the entire width of the parent container, set this property to {{100%}}.
*<tt>AutoAdjustColumns</tt>: Makes the whole text of the column headers displayed if space permits.
{br}{TOC}[anchor|#section_jzp_qj1_gm]
==Adding Columns and Input Controls to a Grid==
Columns are generally the only required items for a grid. If columns are defined, Acumatica Framework creates input controls at runtime based on the field state of the appropriate DAC field to provide row editing. However, you also have to define input controls for the grid in either of the following cases:[anchor|#ul_wkp_cl1_gm]
*You want to set specific properties for an input control or use a different input control. You may add only controls with specific properties; other controls will be generated with default properties at runtime.
*You have to arrange the controls for form view mode of the grid.
*:((({S:Warn}The order of the controls in form view mode doesn&rsquo;t have to match the order of the columns in the grid.
)))
[anchor|#section_olj_rdx_lm]
==Configuring Grid Toolbar Buttons==
To define the set of toolbar buttons that appear in a grid, select the needed value in the <tt>SkinID</tt> property of the grid. For details about the <tt>SkinID</tt> property, see [HelpRoot_Dev_Platform\CW__con_PXForm_Properties_SkinID|Use of the SkinID Property of Containers].{br}

The <tt>SkinID</tt> property, used primarily to define the set of toolbar buttons for a grid, also defines a complete set of UI parameters of the control, such as the column headers and the initial size of the control.[anchor|#section_kxz_3v2_pm]
==Configuring Form View Mode for a Grid==
To configure form view mode for a grid, you have to complete the following steps:[anchor|#ol_esj_5r2_pm]
#Add controls to the grid, set their properties, and arrange them by using layout rules in the same way as you do on an ordinary form.
#Enable callbacks for input controls to trigger in form view mode, and enable callbacks for input controls that correspond to columns with the enabled callback. To enable the callback for an input control, set the <tt>CommitChanges</tt> property to {{True}} for the control.
#Enable form view mode for the grid by setting the <tt>AllowFormEdit</tt> property of <tt>Mode</tt> to {{True}}.
]]></column>
			<column name="PlainText"><![CDATA[Configuration of Grids To configure a grid on a form, you do the following: Specify the  DataMember  property of the grid to bind the grid to a           data view that provides data to work through the grid. Add columns to the grid. Specify the  SkinID  property of the grid, which defines a set of           default grid toolbar buttons. Add input controls to the grid, if needed. Enable form view mode for the grid, if needed. Specify the specific properties of the grid, if needed. You can specify the following properties of a grid ( PXGrid ) control: DataMember : Specifies the data view that provides data for the grid.           This property is required for data binding, along with the predefined              DataSourceID . Columns : Provides the collection of columns of the grid. SkinID : Defines the style and behavior of the grid; this property           includes a set of default grid toolbar buttons and the rendering of parameters of the           grid. Mode > AllowFormEdit : Enables form view mode for the           grid. SyncPosition : Enables the synchronization of the selected row with           the  Current  property of the cache object. The              Current  property is set to each row selected by the user in the grid.  StatusField : Specifies the field that is displayed at the bottom of           the grid as the grid information status. AutoSize > Enabled : Enables the grid height to           expand to the entire area of the parent container. Width : Sets the width of the grid within the parent container (a           standard ASP.NET property of a control). To expand a nested grid to the entire width of           the parent container, set this property to  100% . AutoAdjustColumns : Makes the whole text of the column headers           displayed if space permits. Adding Columns and Input Controls to a Grid Columns are generally the only required items for a grid. If columns are defined,  Acumatica Framework         creates input controls at runtime based on the field state of the appropriate DAC field to         provide row editing. However, you also have to define input controls for the grid in either         of the following cases: You want to set specific properties for an input control or use a different input control.           You may add only controls with specific properties; other controls will be generated with           default properties at runtime. You have to arrange the controls for form view mode of the grid. The order of the             controls in form view mode doesn't have to match the order of the columns in the             grid. Configuring Grid Toolbar Buttons To define the set of toolbar buttons that appear in a grid, select the needed value in the            SkinID  property of the grid. For details about the            SkinID  property, see  Use of the SkinID Property of Containers. The  SkinID  property, used primarily to define the set of toolbar buttons         for a grid, also defines a complete set of UI parameters of the control, such as the column         headers and the initial size of the control. Configuring Form View Mode for a Grid To configure form view mode for a grid, you have to complete the following steps: Add controls to the grid, set their properties, and arrange them by using layout rules in           the same way as you do on an ordinary form. Enable callbacks for input controls to trigger in form view mode, and enable callbacks for           input controls that correspond to columns with the enabled callback. To enable the           callback for an input control, set the  CommitChanges  property to              True  for the control. Enable form view mode for the grid by setting the  AllowFormEdit  property           of  Mode  to  True . ]]></column>
		</row>
		<row PageID="a0f8f9e9-7997-4325-bc69-b58039dd3699" Language="en-US" PageRevisionID="1" Content="&#xA;If a form contains a grid and the form toolbar includes an action to process a single record that is highlighted in the grid, the action delegate method must have a reference to the highlighted record in the cache.{br}&#xA;&#xA;To use the &lt;tt&gt;Current&lt;/tt&gt; property of a &lt;tt&gt;PXCache&lt;/tt&gt; object to access the record highlighted in a grid, the &lt;tt&gt;Current&lt;/tt&gt; property must be synchronized with record highlighting in the grid. To force the system to provide this synchronization, you have to set the &lt;tt&gt;SyncPosition&lt;/tt&gt; property of the &lt;tt&gt;PXGrid&lt;/tt&gt; container to ''True''.((({S:Warn}If you need to make an action button on the toolbar unavailable, when a grid is empty, you should set the &lt;tt&gt;DependOnGrid&lt;/tt&gt; property of the appropriate &lt;tt&gt;PXDSCallbackCommand&lt;/tt&gt; object in the &lt;tt&gt;PXDataSource&lt;/tt&gt; control to the value that is specified in the &lt;tt&gt;ID&lt;/tt&gt; property of the &lt;tt&gt;PXGrid&lt;/tt&gt; element.&#xA;)))" PlainText="Use of the SyncPosition Property of PXGrid If a form contains a grid and the form toolbar includes an action to process a single record    that is highlighted in the grid, the action delegate method must have a reference to the    highlighted record in the cache. To use the  Current  property of a  PXCache  object to access    the record highlighted in a grid, the  Current  property must be synchronized    with record highlighting in the grid. To force the system to provide this synchronization, you    have to set the  SyncPosition  property of the  PXGrid     container to  True . If you need to make an action button on the toolbar unavailable,     when a grid is empty, you should set the  DependOnGrid  property of the     appropriate  PXDSCallbackCommand  object in the  PXDataSource      control to the value that is specified in the  ID  property of the       PXGrid  element. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2e2cf4ab-8468-9c1b-06b9-02542c079c3a" RecordSourceID="22377" />
		<row PageID="e375e4ed-73e6-47bc-a8e2-7366bc6eaf5d" Language="en-US" PageRevisionID="1" Content="&#xA;The Acumatica Customization           Platform supports the following values for the &lt;tt&gt;DisplayMode&lt;/tt&gt; property of a column in a grid.[anchor|#_764ddf1c-4806-42f6-9880-8b6d22ace0f6]&#xA;{| class=&quot;checklist&quot; | width=&quot;100%&quot; &#xA;|- &#xA;!width=&quot;20%&quot; ! Value&#xA;!width=&quot;80%&quot; ! Description&#xA;|- &#xA;| ''Value''&#xA;| Default value. An indicator that the column cell contains the value of the field.&#xA;|- &#xA;| ''Text''&#xA;| If there is a description defined for the field, an indicator that the column cell contains the description of the field.&#xA;|- &#xA;| ''Hint''&#xA;| If there is a description defined for the field, an indicator that the column cell contains both the value and the description of the field.&#xA;|}((({S:Warn}The priority of the &lt;tt&gt;Type&lt;/tt&gt; property is higher than the priority of the &lt;tt&gt;DisplayMode&lt;/tt&gt; property. If the &lt;tt&gt;Type&lt;/tt&gt; property is set, for example, to ''CheckBox'', the &lt;tt&gt;DisplayMode&lt;/tt&gt; property is ignored.&#xA;)))" PlainText="Use of the DisplayMode Property of PXGridColumn The  Acumatica Customization           Platform supports the following values for the  DisplayMode  property of a column       in a grid. Value Description Value Default value. An indicator that the column cell contains the value of the                 field. Text If there is a description defined for the field, an indicator that the column                 cell contains the description of the field. Hint If there is a description defined for the field, an indicator that the column                 cell contains both the value and the description of the field. The priority of the  Type  property is higher than the priority         of the  DisplayMode  property. If the  Type  property is         set, for example, to  CheckBox , the  DisplayMode  property is         ignored. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="528137e5-cecd-7d17-b5e8-6a7712b1dbe3" RecordSourceID="22377" />
		<row PageID="01146ab8-cc7a-4142-a626-95fbb3de4b50" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="931f5a51-26d6-b13d-e0d8-8479ae56ec35" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The Acumatica Customization           Platform supports the following values for the <tt>Type</tt> property of a column in a grid.[anchor|#_764ddf1c-4806-42f6-9880-8b6d22ace0f6]
{| class="checklist" | width="100%" 
|- 
!width="20%" ! Value
!width="80%" ! Description
|- 
| ''NotSet''
| The default value. An indicator that the field value is displayed in the column as a plain string that is formed based on the field data format.
|- 
| ''CheckBox''
| An indicator that the field value is displayed in the column as a check box, which is selected if the field value is ''True''.
|- 
| ''HyperLink''
| An indicator that the field value is displayed in the column as a hyperlink.
|- 
| ''DropDownList''
| An indicator that the column cell is rendered as a drop-down list that contains all the values specified for the referred data field.
|- 
| ''Icon''
| An indicator that the field value contains an image URL and is displayed in the column as the referred image.
|}
==Example==
The following code fragment defines the grid columns on the [HelpRoot_FormReference\SM_20_50_30|Automation Schedule Statuses] ([~/?ScreenId=SM205030|SM205030]) form.{{{{...
&lt;px:PXGridColumn AllowUpdate="False" DataField="LastRunStatus" Width="40px"
  Type="Icon" TextAlign="Center" /&gt;
&lt;px:PXGridColumn DataField="ScreenID" DisplayFormat="CC.CC.CC.CC" 
  Label="Screen ID" LinkCommand="AUScheduleExt_View" /&gt;
&lt;px:PXGridColumn DataField="Description" Label="Description" Width="200px" /&gt;
&lt;px:PXGridColumn AllowNull="False" DataField="IsActive" Label="Active" 
  TextAlign="Center" Type="CheckBox" Width="60px" /&gt;
...
}}}}In the code, the <tt>Type</tt> property for the ''LastRunStatus'' data field (which corresponds to the '''Status''' column shown in the screenshot below) is set to ''Icon''. Because the field value contains the image URL, the column cell displays the referred image.{br}

For the ''IsActive'' data field (which corresponds to the '''Active''' column), the <tt>Type</tt> property is set to ''CheckBox''. As you can see in the screenshot, the column cells are rendered as check boxes.[anchor|#_c633a483-2c8c-4e2b-b10a-5e959dc57fb6][anchor|#_1003b596-db56-44ae-8f45-84a5e7e3b028][image:StudioDeveloperGuide/Images/CG_GL_UI_PXGrid_AddColumn_TypeProperty.png|popup|Viewing different types of columns on the Automation Schedules form|302px]]]></column>
			<column name="PlainText"><![CDATA[Use of the Type Property of PXGridColumn The  Acumatica Customization           Platform supports the following values for the  Type  property of a column in a           grid. Value Description NotSet The default value. An indicator that the field value is displayed in the                   column as a plain string that is formed based on the field data format. CheckBox An indicator that the field value is displayed in the column as a check box,                   which is selected if the field value is  True . HyperLink An indicator that the field value is displayed in the column as a                   hyperlink. DropDownList An indicator that the column cell is rendered as a drop-down list that                   contains all the values specified for the referred data field. Icon An indicator that the field value contains an image URL and is displayed in                   the column as the referred image. Example The following code fragment defines the grid columns on the   ([~/?ScreenId=SM205030|SM205030]) Automation Schedule Statuses (SM205030)         form. ...
<px:PXGridColumn AllowUpdate="False" DataField="LastRunStatus" Width="40px"
  Type="Icon" TextAlign="Center" />
<px:PXGridColumn DataField="ScreenID" DisplayFormat="CC.CC.CC.CC" 
  Label="Screen ID" LinkCommand="AUScheduleExt_View" />
<px:PXGridColumn DataField="Description" Label="Description" Width="200px" />
<px:PXGridColumn AllowNull="False" DataField="IsActive" Label="Active" 
  TextAlign="Center" Type="CheckBox" Width="60px" />
... In         the code, the  Type  property for the  LastRunStatus  data field         (which corresponds to the  Status  column shown in the screenshot         below) is set to  Icon . Because the field value contains the image URL, the column         cell displays the referred image. For the  IsActive  data field (which corresponds to the  Active          column), the  Type  property is set to  CheckBox . As you can see in         the screenshot, the column cells are rendered as check boxes. Viewing different types of columns on the Automation Schedules form ]]></column>
		</row>
		<row PageID="8b21aeee-2d64-445a-83a5-c8e4a0a0a901" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="1bd1125a-5cde-4b94-c2a4-a11324223274" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#section_l1n_4r5_gm][anchor|#_930c5f76-06dd-4374-8004-f16ee73b2f4e]
You can add an input control or grid column that displays a joined data field retrieved by a data view. If a data field is joined, the framework automatically makes the control that is associated with that data field unavailable in the UI, because joined data cannot be edited through the data view in which it is joined.{br}

The following code example shows the {{SupplierProducts}} data view with a left join to {{Product}}.<source lang="csharp">public SelectFrom&lt;SupplierProduct&gt;.
    LeftJoin&lt;Product&gt;.On&lt;Product.productID.IsEqual&lt;SupplierProduct.productID&gt;&gt;.
    Where&lt;SupplierProduct.supplierID.IsEqual&lt;Supplier.supplierID.FromCurrent&gt;&gt;.View
    SupplierProducts;</source>
You can add grid columns or input controls that display product information, such as the unit price. To specify a field of a joined data access class (DAC), you use two underscore symbols between the joined DAC name and the field name, as shown in the bolded text of the following code.{{{{&lt;px:PXGridColumn DataField="ProductID" Width="140px"&gt;...&lt;/px:PXGridColumn&gt;
&lt;px:PXGridColumn DataField="<b>Product__UnitPrice<b>"
                 TextAlign="Right"
                 Width="100px"&gt;
}}}}
In this case, the columns that display {{Product}} fields will be disabled on the grid, because {{Product}} instances cannot be edited through the {{SupplierProducts}} data view. Only {{SupplierProduct}} records can be edited through this data view, because {{SupplierProduct}} is the main DAC of the data view.]]></column>
			<column name="PlainText"><![CDATA[Controls for Joined Data Fields You can add an input control or grid column that             displays a joined data field retrieved by a data view. If a data field is joined, the             framework automatically makes the control that is associated with that data field             unavailable in the UI, because joined data cannot be edited through the data view in             which it is joined. The following code example shows the  SupplierProducts  data view with a         left join to  Product . public SelectFrom<SupplierProduct>.
    LeftJoin<Product>.On<Product.productID.IsEqual<SupplierProduct.productID>>.
    Where<SupplierProduct.supplierID.IsEqual<Supplier.supplierID.FromCurrent>>.View
    SupplierProducts; You can add grid columns or input controls that display product information, such as the         unit price. To specify a field of a joined data access class (DAC), you use two underscore         symbols between the joined DAC name and the field name, as shown in the bolded text of the         following code. <px:PXGridColumn DataField="ProductID" Width="140px">...</px:PXGridColumn>
<px:PXGridColumn DataField=" Product__UnitPrice "
                 TextAlign="Right"
                 Width="100px"> In this case, the columns that display  Product  fields will be disabled on         the grid, because  Product  instances cannot be edited through the            SupplierProducts  data view. Only  SupplierProduct  records         can be edited through this data view, because  SupplierProduct  is the main         DAC of the data view. ]]></column>
		</row>
		<row PageID="dc9be8ff-f4bc-4975-9ca9-ff6a2c2d0fed" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can learn how to configure tables on ASPX pages by using the &lt;tt&gt;PXTab&lt;/tt&gt; and &lt;tt&gt;PXTabItem&lt;/tt&gt; ASPX objects.&#xA;==In This Chapter==[anchor|#_15ae7396-cbff-48b7-9588-52da7bae2bb7]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXTabItem_Properties_VisibleExp|Conditional Hiding of a Tab Item]&#xA;" PlainText="Configuring Tabs In this chapter, you can learn how to configure tables on ASPX pages by using the       PXTab  and  PXTabItem  ASPX objects. In This Chapter Conditional Hiding of a Tab Item" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="b4049d3f-b90f-9db7-12c3-fe89b159f75e" RecordSourceID="22377" />
		<row PageID="5e6701bc-1107-42f8-b9c6-9c5a586bc6ab" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2b596f1a-8aab-80f3-a6a4-0d2594a64d45" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use the <tt>Visible</tt> property of the <tt>PXTabItem</tt> element to set the visibility of the tab item. However, if you need to set the dependency of a tab item&rsquo;s visibility from a condition, you should use one of the following approaches:[anchor|#_87883a32-2443-4e31-9d35-1be486c48922]
*Set the <tt>AllowSelect</tt> property of <tt>PXCache</tt> of the data view in a <tt>RowSelected</tt> event handler.
*Use the <tt>VisibleExp</tt> and <tt>BindingContext</tt> properties of the <tt>PXTabItem</tt> element.

==Using <tt>AllowSelect</tt>==
In a <tt>RowSelected</tt> event handler, you can configure the <tt>AllowSelect</tt> property of <tt>PXCache</tt> of the data view that corresponds to the tab item. In ASPX, you also need to set the <tt>RepaintOnDemand</tt> property of <tt>PXTabItem</tt> to {{False}}.{br}

For example, the following code makes the '''Applications''' tab of the [HelpRoot_FormReference\SO_30_30_00|Invoices] ([~/?ScreenId=SO303000|SO303000]) form visible or invisible depending on the document type.<source lang="csharp">protected virtual void ARInvoice_RowSelected(PXCache cache, PXRowSelectedEventArgs e)
{
    ...
    Adjustments.Cache.AllowSelect =
      doc.DocType != ARDocType.CashSale &&
      doc.DocType != ARDocType.CashReturn;
    ...
}</source>
==Using <tt>VisibleExp</tt>==
The <tt>VisibleExp</tt> property contains a condition expression that defines a <tt>Boolean</tt> value used to set the visibility of the tab item. The expression must consist of two parts and an operator to compare these parts. The expression can contain the values of controls that belong to the container specified in the <tt>BindingContext</tt> property.{br}

As an example of the conditional hiding of a tab item, on a form with form and tab containers, if you need to set the visibility of a tab item to depend on a check box of the form container, you can define the <tt>VisibleExp</tt> and <tt>BindingContext</tt> properties of the <tt>PXTabItem</tt> element, as illustrated in the following ASPX code snippet.{br}

{{{{&lt;px:PXFormView ID="form" ...&gt;
...
  px:PXCheckBox ... ID="myControlID" ... /&gt;
...
&lt;/px:PXFormView&gt;
...
&lt;px:PXTab ...&gt;
...
  &lt;px:PXTabItem ... BindingContext="form" ...
    VisibleExp="DataControls[&quot;myControlID&quot;].Value == true"&gt;
...
&lt;/px:PXTab&gt;
}}}}In the code above, the expression uses the <tt>DataControls</tt> .NET property of the {{form}} object as a dictionary to find the needed control by the specified ID.]]></column>
			<column name="PlainText"><![CDATA[Conditional Hiding of a Tab Item You can use the  Visible  property of the  PXTabItem          element to set the visibility of the tab item. However, if you need to set the dependency of         a tab item's visibility from a condition, you should use one of the following approaches: Set the  AllowSelect  property of  PXCache  of the             data view in a  RowSelected  event handler. Use the  VisibleExp  and  BindingContext  properties             of the  PXTabItem  element. Using  AllowSelect In a  RowSelected  event handler, you can configure the            AllowSelect  property of  PXCache  of the data view         that corresponds to the tab item. In ASPX, you also need to set the            RepaintOnDemand  property of  PXTabItem  to            False . For example, the following code makes the  Applications  tab of the             ([~/?ScreenId=SO303000|SO303000]) Invoices (SO303000) form visible or invisible         depending on the document         type. protected virtual void ARInvoice_RowSelected(PXCache cache, PXRowSelectedEventArgs e)
{
    ...
    Adjustments.Cache.AllowSelect =
      doc.DocType != ARDocType.CashSale &&
      doc.DocType != ARDocType.CashReturn;
    ...
} Using  VisibleExp The  VisibleExp  property contains a condition expression that defines a            Boolean  value used to set the visibility of the tab item. The         expression must consist of two parts and an operator to compare these parts. The expression         can contain the values of controls that belong to the container specified in the            BindingContext  property. As an example of the conditional hiding of a tab item, on a form with form and tab         containers, if you need to set the visibility of a tab item to depend on a check box of the         form container, you can define the  VisibleExp  and            BindingContext  properties of the  PXTabItem  element,         as illustrated in the following ASPX code snippet. <px:PXFormView ID="form" ...>
...
  px:PXCheckBox ... ID="myControlID" ... />
...
</px:PXFormView>
...
<px:PXTab ...>
...
  <px:PXTabItem ... BindingContext="form" ...
    VisibleExp="DataControls[&quot;myControlID&quot;].Value == true">
...
</px:PXTab> In         the code above, the expression uses the  DataControls  .NET property of the            form  object as a dictionary to find the needed control by the specified         ID. ]]></column>
		</row>
		<row PageID="0219b2be-e34c-4b99-ad34-a03653f4d0ab" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can find information about the configuration of different types of boxes, such as &lt;tt&gt;PXTextEdit&lt;/tt&gt;, &lt;tt&gt;PXCheckBox&lt;/tt&gt;, and &lt;tt&gt;PXGroupBox&lt;/tt&gt;.&#xA;==In This Chapter==[anchor|#_6f8b7b09-fe62-4dcb-8886-fd6628033c83]&#xA;*[HelpRoot_Dev_Platform\CW__con_InputControls|Input Controls]&#xA;*[HelpRoot_Dev_Platform\CW__con_CommitChanges|Use of the CommitChanges Property of Boxes]&#xA;*[HelpRoot_Dev_Platform\CW__con_GroupBoxes_Property_DataField|Use of the DataField Property of PXGroupBox]&#xA;*[HelpRoot_Dev_Platform\CW__con_GroupBoxes_Property_Caption|Use of the Caption Property of PXGroupBox]&#xA;*[HelpRoot_Dev_Platform\CW__con_GroupBoxes_Property_RenderStyle|Use of the RenderStyle Property of PXGroupBox]&#xA;*[HelpRoot_Dev_Platform\CW__how_Enable_Callback|To Enable Callback for a Control]&#xA;" PlainText="Configuring Boxes In this chapter, you can find information about the configuration of different types of boxes,     such as  PXTextEdit ,  PXCheckBox , and       PXGroupBox . In This Chapter Input ControlsUse of the CommitChanges Property of BoxesUse of the DataField Property of PXGroupBoxUse of the Caption Property of PXGroupBoxUse of the RenderStyle Property of PXGroupBoxTo Enable Callback for a Control" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="309dbe59-7ef7-57b6-76f7-86e6ea15a579" RecordSourceID="22377" />
		<row PageID="87817ddf-d7ad-4ece-b151-c88c434b7318" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="42a46887-3453-5df7-9bcd-29f2c7a4b285" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#section_qrh_kg1_gm]
You can add input controls and columns to a container in the Screen Editor of the Customization Project Editor or directly in the ASPX code of the form in Visual Studio. The Screen Editor generates control definitions based on the attributes of DAC fields. It also lists data fields and controls based on the field state. {br}

The type of an input control correlates with the attributes of the DAC field that provides data for the control. To define an input control, you have to add to the DAC field the attributes that correspond to the needed type of the input control (see the table below). {br}

In ASP.NET markup, the following properties are required for every input control in a container: [anchor|#ul_nyt_45n_pm]
*<tt>ID</tt>: Identifies the control within the page. This property is required by ASP.NET.
*<tt>runat=&ldquo;Server&ldquo;</tt>: Indicates that the server should create an object of the specified class. This property is required by ASP.NET.
*<tt>DataField</tt>: Specifies the DAC field represented by the control.

Particular types of controls may need additional properties, which are shown in the following table.[anchor|#table_msk_y11_gm]
===Definition of Input Controls===
{| class="checklist" | width="100%" 
|- 
!width="21%" ! Control
!width="34%" ! Attributes on the DAC Field
!width="43%" ! ASPX Definition
|- 
| Text box
| {{[PX(DB)String]}}
| {{<px:PXTextEdit ID= ...> </px:PXTextEdit>}}
|- 
| Number edit box
| {{[PX(DB)Int]}} or {{[PX(DB)Decimal]}}
| {{<px:PXNumberEdit ID=...> </px:PXNumberEdit>}}
|- 
| Mask edit box
| {{[PX(DB)String(InputMask =...)]}}
| {{<px:PXMaskEdit ID=...> </px:PXMaskEdit>}}
|- 
| Drop-down list
| {{[PXStringList]}} or {{[PXIntList]}}
| {{<px:PXDropDown ID=...> </px:PXDropDown>}}
|- 
| Selector
| {{[PXSelector]}}
| {{<px:PXSelector ID=...> </px:PXSelector>}}
|- 
| Check box
| {{[PX(DB)Bool]}}
| {{<px:PXCheckBox ID=...> </px:PXCheckBox>}}
|- 
| Date-time picker
| {{[PX(DB)Date]}}
| {{<px:PXDateTimeEdit ID=...> </px:PXDateTimeEdit>}}
|- 
| Time span edit box
| {{[PXDBTimeSpan]}}
| {{<px:PXDateTimeEdit ID=... TimeMode="True"> </px:PXDateTimeEdit>}}
|}
==Field State==
On each round trip, the system generates a ''field state'' object for each data field that is displayed in the UI. The field state object is initialized and configured on the <tt>FieldSelecting</tt> event, which happens each time the data is prepared for displaying in the UI. All of the following attributes implement <tt>FieldSelecting</tt> event handlers and take part in the configuration of the field state object:[anchor|#ul_w3q_dsn_cjb]
*Attributes that define the data type of a field (such as <tt>PXString</tt> and <tt>PXDBDecimal</tt>)
*Attributes that configure special types of input controls (such as <tt>PXSelector</tt> and <tt>PXStringList</tt>)
*The <tt>PXUIField</tt> attribute
{br}

The application can also define its own <tt>FieldSelecting</tt> event handlers.{br}

The field state object includes properties common to the ASPX page controls. The properties specified in the field state object have greater priority and replace the values set for the controls on the ASPX page.]]></column>
			<column name="PlainText"><![CDATA[Input Controls You can add input controls and columns to a container in the Screen Editor of the  Customization Project Editor         or directly in the ASPX code of the form in Visual Studio. The Screen Editor generates         control definitions based on the attributes of DAC fields. It also lists data fields and         controls based on the field state.  The type of an input control correlates with the attributes of the DAC field that provides         data for the control. To define an input control, you have to add to the DAC field the         attributes that correspond to the needed type of the input control (see the table below).  In ASP.NET markup, the following properties are required for every input control in a         container:  ID : Identifies the control within the page. This property is required           by ASP.NET. runat="Server" : Indicates that the server should create an object of           the specified class. This property is required by ASP.NET. DataField : Specifies the DAC field represented by the control. Particular types of controls may need additional properties, which are shown in the         following table. Definition of Input Controls Control Attributes on the DAC Field ASPX Definition Text box [PX(DB)String] <px:PXTextEdit ID= ...> </px:PXTextEdit> Number edit box [PX(DB)Int]  or  [PX(DB)Decimal] <px:PXNumberEdit ID=...> </px:PXNumberEdit> Mask edit box [PX(DB)String(InputMask =...)] <px:PXMaskEdit ID=...> </px:PXMaskEdit> Drop-down list [PXStringList]  or  [PXIntList] <px:PXDropDown ID=...> </px:PXDropDown> Selector [PXSelector] <px:PXSelector ID=...> </px:PXSelector> Check box [PX(DB)Bool] <px:PXCheckBox ID=...> </px:PXCheckBox> Date-time picker [PX(DB)Date] <px:PXDateTimeEdit ID=...> </px:PXDateTimeEdit> Time span edit box [PXDBTimeSpan] <px:PXDateTimeEdit ID=... TimeMode="True">                   </px:PXDateTimeEdit> Field State On each round trip, the system generates a  field state  object for each data field         that is displayed in the UI. The field state object is initialized and configured on the            FieldSelecting  event, which happens each time the data is prepared for         displaying in the UI. All of the following attributes implement            FieldSelecting  event handlers and take part in the configuration of the         field state object: Attributes that define the data type of a field (such as  PXString              and  PXDBDecimal ) Attributes that configure special types of input controls (such as                PXSelector  and  PXStringList ) The  PXUIField  attribute The application can also define its own  FieldSelecting  event         handlers. The field state object includes properties common to the ASPX page controls. The properties         specified in the field state object have greater priority and replace the values set for the         controls on the ASPX page. ]]></column>
		</row>
		<row PageID="596c3620-e3d5-4d2f-9c19-3b65486a2761" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8a4e9c84-4876-2ba1-7f85-92d2ec7b13f5" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you need to process the value in a box every time the user changes this value, you need to set the <tt>CommitChanges</tt> property of the box to ''True'' to enable callbacks for the box.{br}

If callback is enabled for a box in a container on a page, the user has changed the box value, and focus is no longer on the box on the page, the container immediately collects all the modified data and a callback is created to pass the data to the <tt>PXDataSource</tt> control of the page (see the diagram below). {br}

The <tt>PXDataSource</tt> control creates a remote procedure call to the application server to execute the ''Update'' operation with the modified data on the data view that is specified as the <tt>DataMember</tt> property for the container. The data view executes the sequence of events for update of a data record (for details, see [HelpRoot_Dev_Platform\BL__con_Events_Update|Sequence of Events: Update of a Data Record]) on the data in the cache object of the business logic controller. The cache object raises the events that you can handle to process the modified data.[anchor|#_5151b1ac-8079-4f3d-b813-4994db87e50c][anchor|#_fa391871-4272-4618-a7d1-ec1ca6ce30fb][image:StudioDeveloperGuide/Images/CG_GL_UI_Box_Properties_CommitChanges.png|popup|Usage of the CommitChanges property to process a modified data|450px]]]></column>
			<column name="PlainText"><![CDATA[Use of the CommitChanges Property of Boxes If you need to process the value in a box every time the user changes this value, you need to    set the  CommitChanges  property of the box to  True  to enable callbacks    for the box. If callback is enabled for a box in a container on a page, the user has changed the box value,    and focus is no longer on the box on the page, the container immediately collects all the    modified data and a callback is created to pass the data to the  PXDataSource     control of the page (see the diagram below).  The  PXDataSource  control creates a remote procedure call to the application    server to execute the  Update  operation with the modified data on the data view that is    specified as the  DataMember  property for the container. The data view executes    the sequence of events for update of a data record (for details, see  Sequence of Events: Update of a Data Record) on the data in the cache object of    the business logic controller. The cache object raises the events that you can handle to process    the modified data. Usage of the CommitChanges property to process a modified data ]]></column>
		</row>
		<row PageID="b3d384a1-ada5-4ff1-bf21-ec19eb903f90" Language="en-US" PageRevisionID="1" Content="&#xA;You use a group box to display a data field with a list attribute as a set of radio buttons, where one radio button is used to display and select each single constant value of the field. To bind a group box to a data field, you have to specify the name of the data field in the &lt;tt&gt;DataField&lt;/tt&gt; property of the &lt;tt&gt;PXGroupBox&lt;/tt&gt; element in the ASPX code, as follows.{{{{&amp;lt;px:PXGroupBox ... DataField=&quot;&amp;lt;Field Name&amp;gt;&quot; ...&amp;gt;&#xA;}}}}((({S:Warn}The group box must contain a radio button for each value defined in the list of the field.&#xA;))){br}&#xA;&#xA;In the &lt;tt&gt;DataField&lt;/tt&gt; property of the &lt;tt&gt;PXGroupBox&lt;/tt&gt; element, you can specify the name of a data field that is accessible through another data view of the same graph. See [HelpRoot_Dev_Platform\CW__con_PXForm_AddBox_DataViews|Use of Multiple Data Views for Boxes in Containers] for details." PlainText="Use of the DataField Property of PXGroupBox You use a group box to display a data field with a list attribute as a set of radio buttons,             where one radio button is used to display and select each single constant value of the             field. To bind a group box to a data field, you have to specify the name of the data             field in the  DataField  property of the  PXGroupBox              element in the ASPX code, as                 follows. &lt;px:PXGroupBox ... DataField=&quot;&lt;Field Name&gt;&quot; ...&gt; The group box must contain a radio button for each value defined in                 the list of the field. In the  DataField  property of the  PXGroupBox  element, you             can specify the name of a data field that is accessible through another data view of the             same graph. See  Use of Multiple Data Views for Boxes in Containers for details. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="63f3b0e9-3775-772a-63fe-da0162f5ec64" RecordSourceID="22377" />
		<row PageID="1a889473-d65d-41a8-aaaa-f58cee7cf133" Language="en-US" PageRevisionID="1" Content="&#xA;You can define a caption for a group box by using the &lt;tt&gt;Caption&lt;/tt&gt; property of the &lt;tt&gt;PXGroupBox&lt;/tt&gt; element in the ASPX code as follows.{{{{&amp;lt;px:PXGroupBox ... Caption=&quot;Example of Group Box Caption&quot; ...&amp;gt;&#xA;}}}}{br}&#xA;&#xA;If the &lt;tt&gt;RenderStyle&lt;/tt&gt; property of a &lt;tt&gt;PXGroupBox&lt;/tt&gt; element is set to ''Simple'', the &lt;tt&gt;Caption&lt;/tt&gt; property is ignored. See [HelpRoot_Dev_Platform\CW__con_GroupBoxes_Property_RenderStyle|Use of the RenderStyle Property of PXGroupBox] for details." PlainText="Use of the Caption Property of PXGroupBox You can define a caption for a group box by using the  Caption  property of    the  PXGroupBox  element in the ASPX code as    follows. &lt;px:PXGroupBox ... Caption=&quot;Example of Group Box Caption&quot; ...&gt; If the  RenderStyle  property of a  PXGroupBox  element is    set to  Simple , the  Caption  property is ignored. See  Use of the RenderStyle Property of PXGroupBox for details. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="7d3e8185-a5f7-690d-148a-16e877210e70" RecordSourceID="22377" />
		<row PageID="a06a9841-555c-4622-963d-642f096b8ca3" Language="en-US" PageRevisionID="1" PlainText="Use of the RenderStyle Property of PXGroupBox To define the style of a group box on the form, you have to select a value of the      RenderStyle  property of the  PXGroupBox  element in the ASPX    code, as follows. &lt;px:PXGroupBox ... RenderStyle=&quot;StyleName&quot; ...&gt; The  Acumatica Framework supports the following  RenderStyle  values for the      PXGroupBox  element. Name Description Example Fieldset Indicates that the group of radio buttons can be displayed with a caption in the same         style as in a grouping layout rule. RoundBorder The default value. Indicates that the group of radio buttons can be displayed with a         caption in a rounded border. Simple Indicates that the group of radio buttons can be displayed without a caption and         border. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="1871dc6a-2bfb-1f0f-5c48-4d8e0d6806ed" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To define the style of a group box on the form, you have to select a value of the <tt>RenderStyle</tt> property of the <tt>PXGroupBox</tt> element in the ASPX code, as follows.{{{{&lt;px:PXGroupBox ... RenderStyle="StyleName" ...&gt;
}}}}{br}

The Acumatica Framework supports the following <tt>RenderStyle</tt> values for the <tt>PXGroupBox</tt> element.[anchor|#_8fd8ef67-9b72-4ae3-947e-3269f46a149b]
{| class="checklist" | width="100%" 
|- 
!width="20%" ! Name
!width="40%" ! Description
!width="40%" ! Example
|- 
| <tt>Fieldset</tt>
| Indicates that the group of radio buttons can be displayed with a caption in the same style as in a grouping layout rule.
| [anchor|#_58fa9f73-47d5-4e0d-a7bf-53b3e677528f][image:StudioDeveloperGuide/Images/CG_GL_UI_GroupBoxes_Property_RenderStyle_Fieldset.png|200px]
|- 
| <tt>RoundBorder</tt>
| The default value. Indicates that the group of radio buttons can be displayed with a caption in a rounded border.
| [anchor|#_81bb5591-6351-404d-aac5-cca2322dc996][image:StudioDeveloperGuide/Images/CG_GL_UI_GroupBoxes_Property_RenderStyle_RoundBorder.png|200px]
|- 
| <tt>Simple</tt>
| Indicates that the group of radio buttons can be displayed without a caption and border.
| [anchor|#_c34b2ffa-6073-48d1-8fd1-25654fe9b14e][image:StudioDeveloperGuide/Images/CG_GL_UI_GroupBoxes_Property_RenderStyle_Simple.png|200px]
|}]]></column>
		</row>
		<row PageID="9046e3ec-3f47-43cf-a5a7-0925520bd806" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="028463e0-b7f7-0484-0028-cb7787fa04a8" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#section_ylv_ng1_gm]
If callback is enabled for an input control in a container on an ASPX page, the container collects all the modified data and creates a callback to pass the data to the datasource control immediately when focus is lost for the control on the form. When this callback occurs, the datasource control posts the modified data to the application server. When it receives the callback, the server raises events, which you handle to process the modified data. For more details about callbacks, see [HelpRoot_Dev_Platform\CW__con_Callbacks|Configuration of Callbacks] and [HelpRoot_Dev_Platform\CW__con_CommitChanges|Use of the CommitChanges Property of Boxes].{br}{TOC}
==To Enable Callback for an Input Control==
To enable callback for an input control in the form or tab item container, set the <tt>CommitChanges</tt> property to {{True}} for the control, as the following example shows.{{{{&lt;px:PXFormView ID="form" ...&gt;
    &lt;Template&gt;
        ...
        &lt;px:PXDropDown ID="Status" ... CommitChanges="true"&gt;
        &lt;/px:PXDropDown&gt;
}}}}
==To Enable Callback for a Grid Column==
Callback in a grid is enabled separately for columns and input controls. When a user works directly in the grid (that is, in grid view mode of the grid), the callback is triggered on a column. To enable callback for a grid column, set the <tt>CommitChanges</tt> property to {{True}} for the column.{{{{&lt;px:PXGrid ID="grid" ...&gt;
    &lt;Levels&gt;
        &lt;px:PXGridLevel ...&gt;
            &lt;Columns&gt;
                ...
                &lt;px:PXGridColumn DataField="ProductID" ... CommitChanges="true"&gt;
                &lt;/px:PXGridColumn&gt;
}}}}
==To Enable Callback for a Control in Form View Mode of the Grid==
To enable callback for an input control if the callback is triggered in form view mode of the grid, set the <tt>CommitChanges</tt> property to {{True}} for the control in the grid. For more details on grids, see [HelpRoot_Dev_Platform\CW__con_Configuration_of_Grids|Configuration of Grids].{{{{&lt;px:PXGrid ID="grid" ...&gt;
    &lt;Levels&gt;
        &lt;px:PXGridLevel ...&gt;
            &lt;RowTemplate&gt;
                ...    
                &lt;px:PXSelector ID="ProductID" ... CommitChanges="true"&gt;
                &lt;/px:PXSelector&gt;
}}}}]]></column>
			<column name="PlainText"><![CDATA[To Enable Callback for a Control If callback is enabled for an input control in a container on an ASPX page, the container                 collects all the modified data and creates a callback to pass the data to the                 datasource control immediately when focus is lost for the control on the form. When                 this callback occurs, the datasource control posts the modified data to the                 application server. When it receives the callback, the server raises events, which                 you handle to process the modified data. For more details about callbacks, see  Configuration of Callbacks and  Use of the CommitChanges Property of Boxes. To Enable Callback for an Input Control To enable callback for an input control in the form or tab item container, set the                      CommitChanges  property to  True  for the                 control, as the following example shows. <px:PXFormView ID="form" ...>
    <Template>
        ...
        <px:PXDropDown ID="Status" ... CommitChanges="true">
        </px:PXDropDown> To Enable Callback for a Grid Column Callback in a grid is enabled separately for columns and input controls. When a user                 works directly in the grid (that is, in grid view mode of the grid), the callback is                 triggered on a column. To enable callback for a grid column, set the                      CommitChanges  property to  True  for the                 column. <px:PXGrid ID="grid" ...>
    <Levels>
        <px:PXGridLevel ...>
            <Columns>
                ...
                <px:PXGridColumn DataField="ProductID" ... CommitChanges="true">
                </px:PXGridColumn> To Enable Callback for a Control in Form View Mode of the Grid To enable callback for an input control if the callback is triggered in form view                 mode of the grid, set the  CommitChanges  property to                      True  for the control in the grid. For more details on grids,                 see  Configuration of Grids. <px:PXGrid ID="grid" ...>
    <Levels>
        <px:PXGridLevel ...>
            <RowTemplate>
                ...    
                <px:PXSelector ID="ProductID" ... CommitChanges="true">
                </px:PXSelector> ]]></column>
		</row>
		<row PageID="655b9a92-b944-4863-b392-42a26c79f2eb" Language="en-US" PageRevisionID="1" PlainText="Configuring Layout and Size In this chapter, you can learn how to configure the layout of ASPX pages by using the       PXLayoutRule  ASPX object and how to configure the size of ASPX controls. In This Chapter Predefined Size ValuesUse of the StartRow and StartColumn Properties of PXLayoutRuleUse of the ColumnWidth, ControlSize, and LabelsWidth Properties of PXLayoutRuleUse of the ColumnSpan Property of PXLayoutRuleUse of the Merge Property of PXLayoutRuleUse of the GroupCaption, StartGroup, and EndGroup Properties of PXLayoutRuleUse of the SuppressLabel Property of PXLayoutRule" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2f4a0eb5-b3ea-fdd3-063e-3b1a1b466a45" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this chapter, you can learn how to configure the layout of ASPX pages by using the <tt>PXLayoutRule</tt> ASPX object and how to configure the size of ASPX controls.
==In This Chapter==[anchor|#_44293be8-0b35-4a38-ba7c-fdf6649e8156]
*[HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_Predefined|Predefined Size Values]
*[HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_StartRowColumn|Use of the StartRow and StartColumn Properties of PXLayoutRule]
*[HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_Sizes|Use of the ColumnWidth, ControlSize, and LabelsWidth Properties of PXLayoutRule]
*[HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_ColumnSpan|Use of the ColumnSpan Property of PXLayoutRule]
*[HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_Merge|Use of the Merge Property of PXLayoutRule]
*[HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_Group|Use of the GroupCaption, StartGroup, and EndGroup Properties of PXLayoutRule]
*[HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_SuppressLabel|Use of the SuppressLabel Property of PXLayoutRule]
]]></column>
		</row>
		<row PageID="ffb4d55f-ef65-4aad-bc01-52bd3df47c6a" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="dc5f8b92-ff7d-07ef-782b-d0d4af734aeb" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use the predefined values described in the table below for the following properties:[anchor|#_607a3d93-ee90-4c69-ad7d-f4fea648221f]
*<tt>ColumnWidth</tt>, <tt>LabelsWidth</tt>, and <tt>ControlSize</tt> of the <tt>PXLayoutRule</tt> component
*<tt>LabelsWidth</tt> and <tt>Size</tt> of a control

==Predefined Values==
The following table shows the values in pixels that correspond to the predefined constants.[anchor|#_592a81dd-5379-4414-8726-f3b8118af34d]
{| class="checklist" | width="100%" 
|- 
!width="25%" ! Predefined Value
!width="25%" ! <tt>ColumnWidth</tt>
!width="50%" !  <tt>LabelsWidth</tt> and <tt>ControlSize</tt> of a Layout Rule; <tt>LabelsWidth</tt> and <tt>Size</tt> Properties of a Control
|- 
| ''XXS''
| 100px
| 40px
|- 
| ''XS''
| 150px
| 70px
|- 
| ''S''
| 200px
| 100px
|- 
| ''SM''
| -
| 150px
|- 
| ''M''
| 250px
| 200px
|- 
| ''XM''
| 300px
| 250px
|- 
| ''L''
| 350px
| 300px
|- 
| ''XL''
| 400px
| 350px
|- 
| ''XXL''
| 450px
| 400px
|}
==Setting of Predefined Values==
Note the following points about setting the predefined sizes of controls and their labels:[anchor|#ol_uzf_mrj_fm]
*For any property for which there are predefined values, you can specify a value in pixels, such as ''55px''. (This format is mandatory if you don&rsquo;t use abbreviations, because the property value can be defined only in pixels.)
*There is no predefined value for the <tt>Width</tt> property of a control. Therefore, you can specify a value for this property by typing any value in pixels, such as ''55px''. Before specifying the <tt>Width</tt> property value for a control, you must define the <tt>Size</tt> property value for the control as ''Empty''.
*:((({S:Warn}The <tt>Width</tt> property is declared in ASP.NET. The <tt>Size</tt> property is declared in Acumatica Framework, so you can use the predefined values.
)))
]]></column>
			<column name="PlainText"><![CDATA[Predefined Size Values You can use the predefined values described in the table below for the following      properties: ColumnWidth ,  LabelsWidth , and         ControlSize  of the  PXLayoutRule  component LabelsWidth  and  Size  of a control Predefined Values The following table shows the values in pixels that correspond to the predefined      constants. Predefined Value ColumnWidth LabelsWidth  and  ControlSize  of a Layout Rule;            LabelsWidth  and  Size  Properties of a Control XXS 100px 40px XS 150px 70px S 200px 100px SM - 150px M 250px 200px XM 300px 250px L 350px 300px XL 400px 350px XXL 450px 400px Setting of Predefined Values Note the following points about setting the predefined sizes of controls and their labels: For any property for which there are predefined values, you can specify a value in pixels,       such as  55px . (This format is mandatory if you don't use abbreviations, because the       property value can be defined only in pixels.) There is no predefined value for the  Width  property of a control.       Therefore, you can specify a value for this property by typing any value in pixels, such as         55px . Before specifying the  Width  property value for a control, you       must define the  Size  property value for the control as         Empty . The  Width  property is declared in ASP.NET. The          Size  property is declared in  Acumatica Framework,        so you can use the predefined values. ]]></column>
		</row>
		<row PageID="0edb26d6-414d-4bbb-8c30-ed1d2e65e0b8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="9f14626b-e61f-476f-bbbc-84b911ffc4ad" RecordSourceID="22377">
			<column name="Content"><![CDATA[In this topic, you can find information how to organize controls on an ASPX page into rows and columns.{br}{TOC}
==Default Layout==
By default, the system places all the controls of a container into a column within the first row, as shown in the diagram below. To do this, the system initially sets to ''True'' the <tt>StartRow</tt> property value for the uppermost <tt>PXLayoutRule</tt> component in a container.[anchor|#_118e5cc8-9e84-426d-8925-325991e03f29][anchor|#_995345b5-2bb6-4433-8fd0-d7cea97f0e86][image:StudioDeveloperGuide/Images/CG_GL_UI_LayoutRules_Properties_StartRowColumn.png|popup|The default layout of controls of a container on a form|450px]The controls continue to be placed within a single column until you add a layout rule with the <tt>StartColumn</tt> or <tt>Merge</tt> property value set to ''True''.((({S:Danger}For the proper layout, the <tt>StartRow</tt> property value must be set to ''True'' for the uppermost <tt>PXLayoutRule</tt> component of a container.
)))
==Splitting of Controls into Columns==
You can place controls in multiple columns within a row by adding <tt>PXLayoutRule</tt> components with the <tt>StartColumn</tt> property value set to ''True''. This property creates a new column of controls within the current layout row, as the following diagram shows.[anchor|#_5941e156-1d18-41eb-85b1-b7595a3eebca][anchor|#_deab242c-b488-4bda-9ae8-027f096186e4][image:StudioDeveloperGuide/Images/CG_GL_UI_LayoutRules_Properties_StartRowColumn_1.png|popup|Creation of a new column|450px]The first control under this rule is the highest control in the column.
==Splitting of Controls into Rows==
Every new <tt>PXLayoutRule</tt> component that has the <tt>StartRow</tt> property value set to ''True'' initializes a new independent placeholder of controls, which are placed in a single column by default. To place controls in multiple columns within the new row, you should include in the placeholder a new layout rule with the <tt>StartColumn</tt> property value set to ''True'', as shown in the following diagram.[anchor|#_4c1a047d-2c0e-4177-ab77-7545f981e9cd][anchor|#_6cfc9a15-5ce1-4c28-95d7-45a39b244842][image:StudioDeveloperGuide/Images/CG_GL_UI_LayoutRules_Properties_StartRowColumn_2.png|popup|Creation of a new row|450px]
==Sizes of Rows and Columns==
Because the values of the <tt>ColumnWidth</tt>, <tt>ControlSize</tt>, and <tt>LabelsWidth</tt> properties are never inherited from the previously declared <tt>PXLayoutRule</tt> component, you might need to define these properties exclusively for every new row and column.]]></column>
			<column name="PlainText"><![CDATA[Use of the StartRow and StartColumn Properties of PXLayoutRule In this topic, you can find information how to organize controls       on an ASPX page into rows and columns. Default Layout By default, the system places all the controls of a container into a column within the         first row, as shown in the diagram below. To do this, the system initially sets to            True  the  StartRow  property value for the uppermost            PXLayoutRule  component in a container. The default layout of controls of a container on a form The controls continue to be placed within a single column until you add a layout rule         with the  StartColumn  or  Merge  property value set to            True . For the proper layout, the  StartRow            property value must be set to  True  for the uppermost              PXLayoutRule  component of a container. Splitting of Controls into Columns You can place controls in multiple columns within a row by adding            PXLayoutRule  components with the  StartColumn          property value set to  True . This property creates a new column of controls within the         current layout row, as the following diagram shows. Creation of a new column The first control under this rule is the highest control in the column. Splitting of Controls into Rows Every new  PXLayoutRule  component that has the            StartRow  property value set to  True  initializes a new         independent placeholder of controls, which are placed in a single column by default. To         place controls in multiple columns within the new row, you should include in the placeholder         a new layout rule with the  StartColumn  property value set to  True ,         as shown in the following diagram. Creation of a new row Sizes of Rows and Columns Because the values of the  ColumnWidth ,  ControlSize ,         and  LabelsWidth  properties are never inherited from the previously         declared  PXLayoutRule  component, you might need to define these         properties exclusively for every new row and column. ]]></column>
		</row>
		<row PageID="40e018a5-16cc-4395-a59f-481b53a5254f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2bc8a37b-1653-0e3c-4ceb-af83a6e143fa" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use the <tt>PXLayoutRule</tt> components to define the sizes for every control (that is, its input area) and its label within a column, group, or merged set of controls. 
==Required Properties==
Every <tt>PXLayoutRule</tt> component that has the <tt>StartRow</tt> or <tt>StartColumn</tt> property value set to ''True'' must have one of the following sets of properties defined:[anchor|#ul_dv2_r4z_fm]
*<tt>LabelsWidth</tt> and <tt>ControlSize</tt>
* <tt>LabelsWidth</tt> and <tt>ColumnWidth</tt>
{br}

The following diagram illustrates the meaning of the <tt>LabelsWidth</tt>, <tt>ControlSize</tt>, and <tt>ColumnWidth</tt> properties.[anchor|#_2d810c1b-4b35-446a-8b17-780ace2f53d0][anchor|#_7fbd314e-ccbc-489c-9034-7a0a27cc7901][image:StudioDeveloperGuide/Images/CG_GL_Forms_ASPX_LayoutRule_ColumnWidth.png|popup|Use of the layout rule properties to define control sizes|332px]((({S:Warn}You should not set property values for both <tt>ColumnWidth</tt> and <tt>ControlSize</tt> for the same <tt>PXLayoutRule</tt> component; in this case, the system would use the value of the <tt>ControlSize</tt> property.
)))
==Setting of the Size==
Please note the following points about setting the sizes of controls and their labels:[anchor|#ol_uzf_mrj_fm]
*The values of the <tt>ColumnWidth</tt>, <tt>ControlSize</tt>, and <tt>LabelsWidth</tt> properties must be defined exclusively for every <tt>PXLayoutRule</tt> component; they are never inherited from the previously declared one.
*You can change the size of a single control or its label by defining values for the <tt>Size</tt>, <tt>Width</tt>, and <tt>LabelsWidth</tt> properties of the control. Property values that are set for a control have a higher priority than the property values of the <tt>PXLayoutRule</tt> component.
*You can assign a predefined size abbreviation (such as ''XXS'', ''L'', or ''XL'') for the <tt>ColumnWidth</tt>, <tt>LabelsWidth</tt>, and <tt>ControlSize</tt> properties of a layout rule and the <tt>LabelsWidth</tt> and <tt>Size</tt> properties of a control. (See [HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_Predefined|Predefined Size Values] for details.)
*The <tt>PXDateTimeEdit</tt> and <tt>PXNumberEdit</tt> control types have a predefined <tt>Width</tt> property value, which you cannot change by setting the <tt>ColumnWidth</tt> or <tt>ControlSize</tt> property values for the appropriate <tt>PXLayoutRule</tt> component. To change the width of this control, set a value for the <tt>Size</tt> or <tt>Width</tt> property of the control.
]]></column>
			<column name="PlainText"><![CDATA[Use of the ColumnWidth, ControlSize, and LabelsWidth Properties of PXLayoutRule You can use the  PXLayoutRule  components to define the sizes for every       control (that is, its input area) and its label within a column, group, or merged set of       controls.  Required Properties Every  PXLayoutRule  component that has the  StartRow  or            StartColumn  property value set to  True  must have one of the         following sets of properties defined: LabelsWidth  and  ControlSize LabelsWidth  and  ColumnWidth The following diagram illustrates the meaning of the  LabelsWidth ,            ControlSize , and  ColumnWidth  properties. Use of the layout rule properties to define control sizes You should not set property values for both  ColumnWidth  and              ControlSize  for the same  PXLayoutRule  component;           in this case, the system would use the value of the  ControlSize            property. Setting of the Size Please note the following points about setting the sizes of controls and their labels: The values of the  ColumnWidth ,  ControlSize , and                LabelsWidth  properties must be defined exclusively for every                PXLayoutRule  component; they are never inherited from the             previously declared one. You can change the size of a single control or its label by defining values for the                Size ,  Width , and  LabelsWidth              properties of the control. Property values that are set for a control have a higher             priority than the property values of the  PXLayoutRule  component. You can assign a predefined size abbreviation (such as  XXS ,  L , or                XL ) for the  ColumnWidth ,  LabelsWidth , and                ControlSize  properties of a layout rule and the                LabelsWidth  and  Size  properties of a control.             (See  Predefined Size Values for details.) The  PXDateTimeEdit  and  PXNumberEdit  control             types have a predefined  Width  property value, which you cannot change             by setting the  ColumnWidth  or  ControlSize  property             values for the appropriate  PXLayoutRule  component. To change the             width of this control, set a value for the  Size  or                Width  property of the control. ]]></column>
		</row>
		<row PageID="41c31abf-2297-4c31-b5c2-848b95f9288f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2425aaf4-c6dc-8742-7e05-0f2ddc10ac16" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You specify the <tt>ColumnSpan</tt> property value for a <tt>PXLayoutRule</tt> component by manually typing the number of columns spanned by the first control placed below the rule.
==Example==
As an example of the use of the <tt>ColumnSpan</tt> property, the form container on the [HelpRoot_FormReference\AR_30_30_00|Customers] ([~/?ScreenId=AR303000|AR303000]) form has three columns of boxes, and there is a layout rule with the <tt>ColumnSpan</tt> property set to ''2'' in the first column. This property forces the system to make the box span two columns, as shown in the following screenshot.[anchor|#_7c86fe22-cda4-4d9d-8d30-591fe6fcc11c][anchor|#_8789fcfb-b3f4-426a-b705-f31c8315accb][image:StudioDeveloperGuide/Images/CG_GL_UI_LayoutRules_Properties_ColumnSpan_02.png|popup|The box that spans two columns on the form|450px]
==Dependencies==
A <tt>PXLayoutRule</tt> component with the <tt>ColumnSpan</tt> property value specified is handled as follows:[anchor|#ul_wlc_hpz_fm]
*The <tt>LabelsWidth</tt> property value is always inherited from the previously declared <tt>PXLayoutRule</tt> component that has the <tt>StartRow</tt> or <tt>StartColumn</tt> property value set to ''True''.
*If a value for the <tt>ColumnWidth</tt> or <tt>ControlSize</tt> property is specified for the component, this value is ignored.
]]></column>
			<column name="PlainText"><![CDATA[Use of the ColumnSpan Property of PXLayoutRule You specify the  ColumnSpan  property value for a            PXLayoutRule  component by manually typing the number of columns spanned         by the first control placed below the rule. Example As an example of the use of the  ColumnSpan  property, the form container         on the   ([~/?ScreenId=AR303000|AR303000]) Customers (AR303000) form has three         columns of boxes, and there is a layout rule with the  ColumnSpan  property         set to  2  in the first column. This property forces the system to make the box span         two columns, as shown in the following screenshot. The box that spans two columns on the form Dependencies A  PXLayoutRule  component with the  ColumnSpan  property         value specified is handled as follows: The  LabelsWidth  property value is always inherited from the             previously declared  PXLayoutRule  component that has the                StartRow  or  StartColumn  property value set to                True . If a value for the  ColumnWidth  or  ControlSize              property is specified for the component, this value is ignored. ]]></column>
		</row>
		<row PageID="325b7979-f32d-40eb-920b-7880245e8a26" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f93b8996-0826-a855-2ecb-9c8e4fc671f1" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#_4e0413a2-bee4-4243-8444-8d59568dfc92]
Horizontal alignment is performed for the controls that are placed between a layout rule with the <tt>Merge</tt> property set to ''True'' and the next layout rule. Therefore, to cancel merging for all of the following controls, you have to add a <tt>PXLayoutRule</tt> component with or without the <tt>Merge</tt> property specified.
==Example==
As an example of the use of the <tt>Merge</tt> property, the '''Billing Settings''' tab item on the [HelpRoot_FormReference\AR_30_30_00|Customers] ([~/?ScreenId=AR303000|AR303000]) form has three pairs of merged check boxes in the '''Print and Email Settings''' group. This property forces the system to render the boxes in one column, as shown in the following screenshot.[anchor|#_7c86fe22-cda4-4d9d-8d30-591fe6fcc11c][anchor|#_8789fcfb-b3f4-426a-b705-f31c8315accb][image:StudioDeveloperGuide/Images/CG_GL_UI_LayoutRules_Properties_Merge_02.png|popup|The boxes merged into a single column on the form|450px]
==Dependencies==
A <tt>PXLayoutRule</tt> component with the <tt>Merge</tt> property value set to ''True'' is handled as follows:[anchor|#ul_ugn_qqz_fm]
*If the <tt>ColumnWidth</tt> property value is set for the same <tt>PXLayoutRule</tt> component, the value is ignored.
*The default values for the <tt>ControlSize</tt> and <tt>LabelsWidth</tt> properties are inherited from the previously declared <tt>PXLayoutRule</tt> component with the <tt>StartRow</tt> or <tt>StartColumn</tt> property value set to ''True''. You can override these property values, if necessary, by specifying the <tt>ControlSize</tt> and <tt>LabelsWidth</tt> property values from the predefined list of options. (See [HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_Predefined|Predefined Size Values] for details.)
]]></column>
			<column name="PlainText"><![CDATA[Use of the Merge Property of PXLayoutRule Horizontal alignment is performed for the controls             that are placed between a layout rule with the  Merge  property set to                  True  and the next layout rule. Therefore, to cancel merging for all of the             following controls, you have to add a  PXLayoutRule  component with or             without the  Merge  property specified. Example As an example of the use of the  Merge  property, the  Billing           Settings  tab item on the   ([~/?ScreenId=AR303000|AR303000]) Customers (AR303000) form has three pairs of merged check boxes in the            Print and Email Settings  group. This property forces the system to         render the boxes in one column, as shown in the following screenshot. The boxes merged into a single column on the form Dependencies A  PXLayoutRule  component with the  Merge  property         value set to  True  is handled as follows: If the  ColumnWidth  property value is set for the same              PXLayoutRule  component, the value is ignored. The default values for the  ControlSize  and              LabelsWidth  properties are inherited from the previously declared              PXLayoutRule  component with the  StartRow  or              StartColumn  property value set to  True . You can override these           property values, if necessary, by specifying the  ControlSize  and              LabelsWidth  property values from the predefined list of options. (See              Predefined Size Values for details.) ]]></column>
		</row>
		<row PageID="1341b9b1-1868-4544-9737-6c521506965f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="b7828f61-0178-d567-8b7f-21bd543be9f4" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can organize controls in a container within groups to make users&rsquo; work more logical. 
==Grouping of Controls==
To group multiple controls within a column, generally you have to add two <tt>PXLayoutRule</tt> components that have the following properties set to define the first and the last controls in the group, respectively:[anchor|#ul_dv2_r4z_fm]
*<tt>GroupCaption</tt> and <tt>EndGroup</tt>: To create a group with the caption specified in the <tt>GroupCaption</tt> property
*<tt>StartGroup</tt> and <tt>EndGroup</tt>: To create a group without a caption
((({S:Warn}You can specify both the <tt>GroupCaption</tt> property and the <tt>StartGroup</tt> property for a <tt>PXLayoutRule</tt> component that starts a group.
))){br}

For example, by specifying the <tt>GroupCaption</tt> property value for the corresponding <tt>PXLayoutRule</tt> components placed above a control, you start the group of controls and set up the header for the group. You should also add a <tt>PXLayoutRule</tt> component with the <tt>EndGroup</tt> property value set to ''True'' below (in the code) the last control that is included in the group.You end a group by using a <tt>PXLayoutRule</tt> component with a <tt>GroupCaption</tt>, <tt>StartGroup</tt>, or <tt>EndGroup</tt> property specified. Therefore, if there is another group that starts immediately below a group, you can omit the layout rule that ends the upper group, as shown in the third column of the row displayed in the example in following diagram.[anchor|#_7e54b810-3ca4-4a2c-ae5d-10db9b7f5af7][anchor|#_d48daed5-0fd4-4f8f-b39b-20fc42c76a04][image:StudioDeveloperGuide/Images/CG_GL_UI_LayoutRules_Properties_Group.png|popup|Possible use of layout rules with grouping properties|450px]
==Dependencies==
The system works as follows for all <tt>PXLayoutRule</tt> components with the <tt>GroupCaption</tt> or <tt>StartGroup</tt> property value specified:[anchor|#ul_cvl_4rz_fm]
*If the <tt>GroupCaption</tt>, <tt>StartGroup</tt>, or <tt>EndGroup</tt> property is set for a <tt>PXLayoutRule</tt> component, the system ignores the <tt>ColumnWidth</tt> property value specified for the component.
*The default values for the <tt>ControlSize</tt> and <tt>LabelsWidth</tt> properties are inherited from the previously declared <tt>PXLayoutRule</tt> component with the <tt>StartRow</tt> or <tt>StartColumn</tt> property value set to ''True''. You can override these property values, if necessary, by specifying the <tt>ControlSize</tt> and <tt>LabelsWidth</tt> property values in the layout rule that starts a group. (See [HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_Predefined|Predefined Size Values] for details.)
]]></column>
			<column name="PlainText"><![CDATA[Use of the GroupCaption, StartGroup, and EndGroup Properties of PXLayoutRule You can organize controls in a container within groups to make users' work more logical.        Grouping of Controls To group multiple controls within a column,         generally you have to add two  PXLayoutRule  components that have the         following properties set to define the first and the last controls in the group,           respectively: GroupCaption  and  EndGroup : To create a group             with the caption specified in the  GroupCaption  property StartGroup  and  EndGroup : To create a group             without a caption You can specify both the  GroupCaption  property and the              StartGroup  property for a  PXLayoutRule  component           that starts a group. For example, by specifying the            GroupCaption  property value for the corresponding            PXLayoutRule  components placed above a control, you start the group of         controls and set up the header for the group. You should also add a            PXLayoutRule  component with the  EndGroup  property         value set to  True  below (in the code) the last control that is included in the         group. You end a group by using a  PXLayoutRule  component with a          GroupCaption ,  StartGroup , or          EndGroup  property specified. Therefore, if there is another group that       starts immediately below a group, you can omit the layout rule that ends the upper group, as       shown in the third column of the row displayed in the example in following diagram. Possible use of layout rules with grouping properties Dependencies The system works as follows for all  PXLayoutRule  components with the            GroupCaption  or  StartGroup  property value           specified: If the  GroupCaption ,  StartGroup , or                EndGroup  property is set for a  PXLayoutRule              component, the system ignores the  ColumnWidth  property value             specified for the component. The default values for the  ControlSize  and                LabelsWidth  properties are inherited from the previously declared                PXLayoutRule  component with the  StartRow  or                StartColumn  property value set to  True . You can override             these property values, if necessary, by specifying the  ControlSize              and  LabelsWidth  property values in the layout rule that starts a             group. (See  Predefined Size Values for             details.) ]]></column>
		</row>
		<row PageID="618baa6a-524a-4e0b-bf1a-dfe28c1205e8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="c862ca89-8d73-ab3b-f8fa-2ca1fdc9e00c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Every control for a data field contains both a label and the input area of the control. The label is displayed left of the input area, except with check boxes; the label of a check box is displayed right of the input area of the check box. When you add a check box to a form, the check box control is automatically aligned both left and right with other input controls in the appropriate column. As a result, the area of the form left of a check box is empty.
==SuppressLabel Property==[anchor|#_52f1d012-e829-4b3f-b1c6-499510eebc9d]
To hide the labels of the controls placed within a column, you should set the <tt>SuppressLabel</tt> property value of the <tt>PXLayoutRule</tt> component of the column to ''True''. Then within the column, all check boxes are placed without any space to the left of the input control, and the labels of other controls are hidden.((({S:Warn}If needed, you can left-align a check box in the column by setting to ''True'' the <tt>AlignLeft</tt> property of the control. 
)))
The <tt>SuppressLabel</tt> property affects all of the controls of the group that are placed under the <tt>PXLayoutRule</tt> component with the ''True'' value of this property. The <tt>SuppressLabel</tt> property value must be defined for every <tt>PXLayoutRule</tt> component for the controls placed beneath the component and included in the same column; this property is never inherited from the previously declared property. ((({S:Warn}The <tt>SuppressLabel</tt> property value is never applied to <tt>PXLayoutRule</tt> components that have the <tt>ColumnSpan</tt> property value specified.
)))
==Example==
The '''Parent Info''' group on the '''Billing Settings''' tab item on the [HelpRoot_FormReference\AR_30_30_00|Customers] ([~/?ScreenId=AR303000|AR303000]) form is initially displayed with '''Parent Account''' displayed, as shown in the following screenshot.[anchor|#_73c29e59-1e54-416e-ba35-59360a840e2d]If you set the <tt>SuppressLabel</tt> property of the group layout rule to ''True'', the label of the '''Parent Account''' box is hidden and all check boxes are displayed without any space to the left of the check boxes, as shown in the following screenshot.[anchor|#_7c86fe22-cda4-4d9d-8d30-591fe6fcc11c][anchor|#_8789fcfb-b3f4-426a-b705-f31c8315accb][image:StudioDeveloperGuide/Images/CG_GL_UI_LayoutRules_Properties_SuppressLabel_02.png|popup|The same group of controls after applying the <tt>SuppressLabel</tt> property to the group|270px]]]></column>
			<column name="PlainText"><![CDATA[Use of the SuppressLabel Property of PXLayoutRule Every control for a data field contains both a label and the input area of the control. The         label is displayed left of the input area, except with check boxes; the label of a check box         is displayed right of the input area of the check box. When you add a check box to a form,         the check box control is automatically aligned both left and right with other input controls         in the appropriate column. As a result, the area of the form left of a check box is         empty. SuppressLabel Property To hide the labels of the controls placed within a             column, you should set the  SuppressLabel  property value of the                  PXLayoutRule  component of the column to  True . Then within             the column, all check boxes are placed without any space to the left of the input             control, and the labels of other controls are hidden. If needed, you can left-align a check box in the column by setting to  True  the            AlignLeft  property of the control.  The  SuppressLabel  property affects all of the controls of the group that         are placed under the  PXLayoutRule  component with the  True  value of         this property. The  SuppressLabel  property value must be defined for every            PXLayoutRule  component for the controls placed beneath the component         and included in the same column; this property is never inherited from the previously         declared property.  The  SuppressLabel  property value is never           applied to  PXLayoutRule  components that have the              ColumnSpan  property value specified. Example The  Parent Info  group on the  Billing Settings          tab item on the   ([~/?ScreenId=AR303000|AR303000]) Customers (AR303000) form         is initially displayed with  Parent Account  displayed, as shown in the         following screenshot. A group of controls with labels If you set the  SuppressLabel  property of the group layout rule to            True , the label of the  Parent Account  box is hidden and all         check boxes are displayed without any space to the left of the check boxes, as shown in the         following screenshot. The same group of controls after applying the  SuppressLabel              property to the group ]]></column>
		</row>
		<row PageID="1978cf80-0ff3-4da3-b390-d86be7148caa" Language="en-US" PageRevisionID="1" Content="&#xA;In Acumatica Report                         Designer, you can create custom reports or modify existing reports and then use these reports in Acumatica ERP or an Acumatica Framework-based application. For more information on the creation of the custom reports with the Report Designer, see [HelpRoot_ReportingTools\ReportDesigner_Main| Acumatica Report                         Designer Guide].{br}&#xA;&#xA;In this chapter, you can find details about how the system renders reports in Acumatica ERP.&#xA;==In This Chapter==[anchor|#_8be57193-ee67-4d5a-ab9f-1c605c307a25]&#xA;*[HelpRoot_Dev_Platform\CC__con_Rendering_of_Reports|Display of Reports]&#xA;*[HelpRoot_Dev_Platform\CC__con_Rendering_of_Analytical_Reports|Display of Analytical Reports]&#xA;" PlainText="Maintaining Reports In  Acumatica Report                         Designer, you can create custom reports or modify existing reports and then use these reports in  Acumatica ERP     or an  Acumatica Framework-based     application. For more information on the creation of the custom reports with the  Report Designer, see   Acumatica Report                         Designer Guide. In this chapter, you can find details about how the system renders reports in  Acumatica ERP. In This Chapter Display of ReportsDisplay of Analytical Reports" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="d4e35713-e84c-8262-44b4-f902bb6bc77a" RecordSourceID="22377" />
		<row PageID="45dbe9ed-94a0-4183-80f8-eede0415b5ae" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2c5286d8-5914-cf75-e54c-7c0aebcb6304" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can find information about how Acumatica ERP displays reports that are created with the Acumatica Report                         Designer.{br}{TOC}
==What a Report Is==
A report is an RPX file (which is created with the Acumatica Report                         Designer) that contains the report schema in XML format—that is, the description of the data that should be displayed in the report and the description of the report layout.(See the following diagram.) The description of the data of the report includes the following: the database tables that provide data for the report, the relationships between these tables, the parameters that can be specified before the report is run, and the filtering and grouping parameters. The report layout is a tree of headers, details, and footers. [anchor|#_9a518189-d4df-41a2-b15e-62cdf7f8ac11][anchor|#_6137aa26-c90a-48cf-8952-2b5386d820c4][image:StudioDeveloperGuide/Images/ReportTree.png|Report schema|450px]{br}

Reports can be saved in files on disk, or in the <tt>UserReport</tt> table of the database of an Acumatica ERP instance. (The <tt>UserReport</tt> table uses the file name of the report as a key and stores the schema of the report in XML format in the <tt>Xml</tt> column.){br}

The saved report can be published on an Acumatica ERP site—that is, added to the site map and to any applicable workspaces so that the users can work with the report. {br}

For details on creating reports with the Acumatica Report                         Designer, see the [https://openuni.acumatica.com/courses/reporting/s130-inquiries-reports-and-dashboards/|S130 Reporting: Inquiry, Report Writing, Dashboards] training course.{br}

 Acumatica ERP provides the following ways to run a report that you have created by using the Acumatica Report                         Designer:[anchor|#_eca6a93e-b569-49cf-a079-05e99888e2a7]
*From a report form, which is added to the site map, when the user clicks the '''Run Report''' button on the form toolbar
*From a maintenance or entry form, when the user clicks the action button whose name is associated with the report name
[anchor|#_ae3acf88-4440-4fac-a524-4fe7e8a7f0ac]
==How the Report Is Launched from the Report Form==
When a user opens the report form, the webpage performs the POST HTTP request to the <tt>ReportLauncher.aspx</tt> page, passing the name of the report file as the <tt>ID</tt> query string parameter of the request, as shown in the following example. {{{{http://localhost/AcumaticaDB/frames/ReportLauncher.aspx?id=YF123456.rpx&HideScript=On
}}}}{br}

The <tt>ReportLauncher.aspx</tt> page contains the <tt>PXReportViewer</tt> control, whose JavaScript objects and functions are designed to obtain the report data and display the data on the form, and the <tt>PXSoapDataSource</tt> control, which is used to retrieve data for the report.{br}

On the server side, an instance of the <tt>PX.Web.UI.PXReportViewer</tt> class processes the request as follows:[anchor|#_852edc5a-172a-4177-97d6-844ed74ee407]
#Loads the report schema from the file on disk or from the database (by using the <tt>LoadReport</tt> method) to a <tt>PX.Reports.Controls.Report</tt> object (which stores the report schema in memory and provides the methods for working with this schema).
#If the report schema is loaded successfully, performs the following:
##Instantiates a <tt>PX.Reports.Web.WebReport</tt> object that will store data of the launched report and assigns an instance ID to <tt>WebReport</tt>.
##Binds the <tt>Report</tt> object to the data source that is specified by the <tt>PXSoapDataSource</tt> control of the ASPX page. The <tt>PX.Web.UI.PXSoapDataSource</tt> class instantiates a <tt>SoapNavigator</tt> object, which will be then used to retrieve data for the report from the database. 
{br}

The server returns an XML response with the report parameters to display and with the ID of the instance of <tt>WebReport</tt> in the session. The browser displays the report parameters and other options on the report form.{br}

The following diagram illustrates how the report form is launched.[anchor|#_ca0105ff-235e-4e71-a31e-6020f39c0466][anchor|#_f87a99ba-2839-45d0-b05b-49e2494e7ad9][image:StudioDeveloperGuide/Images/LaunchOfReportForm.png|popup|Launch of the report form|450px][anchor|#_84960e46-15bb-492e-b167-a5a09b8e7163]
==How the Report Data Is Retrieved==
After the user has selected the values of the parameters of the report and clicked the '''Run Report''' button on the form toolbar of the report form, the webpage sends the GET request to <tt>PX.ReportViewer.axd</tt> on the server with the ID of the <tt>WebReport</tt> instance in the session (which was created when the report was launched), as shown in the following example.{{{{http://localhost/AcumaticaDB/PX.ReportViewer.axd?
  InstanceID=10bf4a13a38c4af39cafc80926e407f2&OpType=Report
  &PageIndex=0&Refresh=True
}}}}{br}

To process the request, the server invokes the <tt>Render</tt> method of the <tt>WebReport</tt> class, which launches the generation of the report as a long-running operation in a separate thread. For details on how the long-running operation is processed for a report, see [HelpRoot_Dev_Platform\BL__con_Asynchronous_Execution#_397e929e-f4b4-4441-9688-1e0a4ca7ab33|Processing a Report as a Long-Running Operation].{br}

To retrieve the data of the report from the database, the system uses the <tt>PX.Data.Reports.SoapNavigator</tt> object (to which a reference is stored in the <tt>Report</tt> object). <tt>SoapNavigator</tt> instantiates a <tt>PXGraph</tt> object (without a type parameter) and composes a BQL command as an instance of the <tt>PX.Data.Reports.BqlSoapCommand</tt> class. <tt>BqlSoapCommand</tt> inherits from the <tt>PX.Data.BqlCommand</tt> class and is optimized for retrieving data for the reports. <tt>BqlSoapCommand</tt> has the <tt>IndexReportFields</tt> method, which uses the [https://help.acumatica.com/(W(1))/Main?ScreenId=ShowWiki&pageid=5f2cb583-5aea-a584-786b-79aeb224895c|<tt>PX.Data.PXDependsOnFieldsAttribute</tt>] attribute to get the dependent fields of the report recursively. For details on how BQL commands are used to retrieve data from the database, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].{br}

The system processes the data and creates a <tt>ReportNode</tt> object. That is, the system creates the sections of the report based on the data retrieved from the database and on the report schema from the <tt>Report</tt> object, and calculates all formulas inside the sections. Then the system uses the resulting <tt>ReportNode</tt> object, which contains all sections with all needed values, to render data in the needed format.
==How the Report Data Is Displayed==
After the long-running operation has completed, the <tt>PXReportViewer</tt> control displays the report on the report form. {br}

If a report is displayed in HTML format and the user turns the pages of the report, the webpage sends the GET request to <tt>PX.ReportViewer.axd</tt>. The query string parameters of the request are the ID of the report in the session and the number of the page, as shown in the following request URL.{{{{http://localhost/AcumaticaERP/PX.ReportViewer.axd?
  InstanceID=008f2a8afb1a4998ade98bc64fc30ad9&OpType=Report
  &PageIndex=0
}}}}{br}

The format in which the report is displayed (either PDF or HTML) is specified in the <tt>OpType</tt> query string parameter of the request, as shown in the following request URL.{{{{http://localhost/AcumaticaERP/PX.ReportViewer.axd?
  InstanceID=008f2a8afb1a4998ade98bc64fc30ad9&OpType=PdfReport&Refresh=True
}}}}{br}

If a user turns the pages of the report or changes the format of the report, the system creates the results of the report from the <tt>ReportNode</tt> object stored in the session by using the renderer for the needed format. That is, the system does not retrieve the data of the report from the database and does not processes this data to create a <tt>ReportNode</tt> object once again. [anchor|#_1535b822-2515-4dd0-a31e-c527b7317ff0]
==How the Report Is Launched from the Maintenance or Entry Form==
On a form, when a user clicks the action button to generate a report, the data source control of the form creates a request to the Acumatica ERP server to execute the action delegate defined for the button. The server creates an instance of the graph, which provides the business logic for the form and invokes the action delegate method. The action delegate obtains from the form the data required to define the report parameters and throws an exception of the <tt>PX.Data.PXReportRequiredException</tt> type with the report ID and these parameters. The system processes the exception, saves the report parameters to the session, and redirects the user to the <tt>ReportLauncher.aspx</tt> page.{br}

The <tt>ReportLauncher.aspx</tt> page loads the report schema and instantiates a <tt>WebReport</tt> object, as described in [[#_ae3acf88-4440-4fac-a524-4fe7e8a7f0ac|How the Report Is Launched from the Report Form]. Instead of retrieving the values of report parameters from the webpage, the system opens the report with the parameters stored in the session. The system retrieves data for the report, as described in [[#_84960e46-15bb-492e-b167-a5a09b8e7163|How the Report Data Is Retrieved].
==Related Articles==
*[HelpRoot_ReportingTools\ReportDesigner_Main| Acumatica Report                         Designer Guide]
*[HelpRoot_Dev_Platform\BL__con_Asynchronous_Execution|Asynchronous Execution]]]></column>
			<column name="PlainText"><![CDATA[Display of Reports In this topic, you can find information about how  Acumatica ERP displays reports that are created with the  Acumatica Report                         Designer. What a Report Is A report is an RPX file (which is created with the  Acumatica Report                         Designer) that contains the report schema in XML format—that is, the description of the data         that should be displayed in the report and the description of the report layout.(See the         following diagram.) The description of the data of the report includes the following: the         database tables that provide data for the report, the relationships between these tables,         the parameters that can be specified before the report is run, and the filtering and         grouping parameters. The report layout is a tree of headers, details, and footers.  Report schema Reports can be saved in files on disk, or in the  UserReport  table of the         database of an  Acumatica ERP instance. (The  UserReport  table uses the file name of the report as a         key and stores the schema of the report in XML format in the  Xml          column.) The saved report can be published on an  Acumatica ERP site—that is, added to the site map and to any applicable workspaces so that the         users can work with the report.  For details on creating reports with the  Acumatica Report                         Designer, see the  S130 Reporting: Inquiry, Report Writing, Dashboards S130 Reporting: Inquiry, Report Writing, Dashboards         training course.  Acumatica ERP provides the following ways to run a report that you have created by using the  Acumatica Report                         Designer: From a report form, which is added to the site map, when the user clicks the                Run Report  button on the form toolbar From a maintenance or entry form, when the user clicks the action button whose name is             associated with the report name How the Report Is Launched from the Report Form When a user opens the report form, the webpage performs the POST HTTP request to the            ReportLauncher.aspx  page, passing the name of the report file as the            ID  query string parameter of the request, as shown in the following         example.          http://localhost/AcumaticaDB/frames/ReportLauncher.aspx?id=YF123456.rpx&HideScript=On The  ReportLauncher.aspx  page contains the            PXReportViewer  control, whose JavaScript objects and functions are         designed to obtain the report data and display the data on the form, and the            PXSoapDataSource  control, which is used to retrieve data for the         report. On the server side, an instance of the  PX.Web.UI.PXReportViewer  class         processes the request as follows: Loads the report schema from the file on disk or from the database (by using the                LoadReport  method) to a                PX.Reports.Controls.Report  object (which stores the report schema             in memory and provides the methods for working with this schema). If the report schema is loaded successfully, performs the following: Instantiates a  PX.Reports.Web.WebReport  object that will store                 data of the launched report and assigns an instance ID to                    WebReport . Binds the  Report  object to the data source that is specified by                 the  PXSoapDataSource  control of the ASPX page. The                    PX.Web.UI.PXSoapDataSource  class instantiates a                    SoapNavigator  object, which will be then used to retrieve data                 for the report from the database.  The server returns an XML response with the report parameters to display and with the ID of         the instance of  WebReport  in the session. The browser displays the report         parameters and other options on the report form. The following diagram illustrates how the report form is launched. Launch of the report form How the Report Data Is Retrieved After the user has selected the values of the parameters of the report and clicked the            Run Report  button on the form toolbar of the report form, the         webpage sends the GET request to  PX.ReportViewer.axd  on the server with         the ID of the  WebReport  instance in the session (which was created when         the report was launched), as shown in the following         example. http://localhost/AcumaticaDB/PX.ReportViewer.axd?
  InstanceID=10bf4a13a38c4af39cafc80926e407f2&OpType=Report
  &PageIndex=0&Refresh=True To process the request, the server invokes the  Render  method of the            WebReport  class, which launches the generation of the report as a         long-running operation in a separate thread. For details on how the long-running operation         is processed for a report, see  Processing a Report as a Long-Running Operation. To retrieve the data of the report from the database, the system uses the            PX.Data.Reports.SoapNavigator  object (to which a reference is stored in         the  Report  object).  SoapNavigator  instantiates a            PXGraph  object (without a type parameter) and composes a BQL command as         an instance of the  PX.Data.Reports.BqlSoapCommand  class.            BqlSoapCommand  inherits from the  PX.Data.BqlCommand          class and is optimized for retrieving data for the reports.            BqlSoapCommand  has the  IndexReportFields  method,         which uses the  PX.Data.PXDependsOnFieldsAttribute <tt>PX.Data.PXDependsOnFieldsAttribute</tt> attribute to get the         dependent fields of the report recursively. For details on how BQL commands are used to         retrieve data from the database, see  Translation of a BQL Command to SQL. The system processes the data and creates a  ReportNode  object. That is,         the system creates the sections of the report based on the data retrieved from the database         and on the report schema from the  Report  object, and calculates all         formulas inside the sections. Then the system uses the resulting            ReportNode  object, which contains all sections with all needed values,         to render data in the needed format. How the Report Data Is Displayed After the long-running operation has completed, the  PXReportViewer          control displays the report on the report form.  If a report is displayed in HTML format and the user turns the pages of the report, the         webpage sends the GET request to  PX.ReportViewer.axd . The query string         parameters of the request are the ID of the report in the session and the number of the         page, as shown in the following request         URL. http://localhost/AcumaticaERP/PX.ReportViewer.axd?
  InstanceID=008f2a8afb1a4998ade98bc64fc30ad9&OpType=Report
  &PageIndex=0 The format in which the report is displayed (either PDF or HTML) is specified in the            OpType  query string parameter of the request, as shown in the following         request         URL. http://localhost/AcumaticaERP/PX.ReportViewer.axd?
  InstanceID=008f2a8afb1a4998ade98bc64fc30ad9&OpType=PdfReport&Refresh=True If a user turns the pages of the report or changes the format of the report, the system         creates the results of the report from the  ReportNode  object stored in         the session by using the renderer for the needed format. That is, the system does not         retrieve the data of the report from the database and does not processes this data to create         a  ReportNode  object once again.  How the Report Is Launched from the Maintenance or Entry Form On a form, when a user clicks the action button to generate a report, the data source         control of the form creates a request to the  Acumatica ERP server to execute the action delegate defined for the button. The server creates an         instance of the graph, which provides the business logic for the form and invokes the action         delegate method. The action delegate obtains from the form the data required to define the         report parameters and throws an exception of the            PX.Data.PXReportRequiredException  type with the report ID and these         parameters. The system processes the exception, saves the report parameters to the session,         and redirects the user to the  ReportLauncher.aspx  page. The  ReportLauncher.aspx  page loads the report schema and instantiates         a  WebReport  object, as described in  How the Report Is Launched from the Report Form How the Report Is Launched from the Report Form. Instead of retrieving the values of report parameters from the webpage,         the system opens the report with the parameters stored in the session. The system retrieves         data for the report, as described in  How the Report Data Is Retrieved How the Report Data Is Retrieved. ]]></column>
		</row>
		<row PageID="948e10a2-13c1-42f7-9673-ec145858fc1f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="d0b43d7b-1072-cd33-a420-983959911b8e" RecordSourceID="22377">
			<column name="Content"><![CDATA[In this topic, you can find information about how Acumatica ERP displays analytical reports.{br}{TOC}
==What an Analytical Report Is==
An analytical report is a specific type of report that you can construct in Acumatica ERP by using the Analytical Report Manager (ARM) toolkit. You will likely want to use the ARM toolkit rather than the Acumatica Report                         Designer to create the following types of reports:[anchor|#_4792b4d2-bdd0-4c93-ae60-7875afdf8256]
*Financial reports that display data that is posted to the general ledger accounts and accumulated in the General Ledger module. The system gets the data of the general ledger accounts from the <tt>GLHistory</tt> table of the database. 
*Project accounting reports that display data that is accumulated in the Project module. The system gets the data for these reports from the <tt>PMHistory</tt> table of the database.
{br}

For details on analytical reports, see the [https://openuni.acumatica.com/courses/reporting/f350-financials-analytical-reports/|F350 Reporting: Analytical Reports] training course.{br}

The schema of analytical reports are stored in a set of database tables that have <tt>RM</tt> prefix in their names, such as <tt>RMReport</tt>, <tt>RMRowSet</tt>, and <tt>RMColumnSet</tt>. The analytical report is identified in the system by its code, which you specify in the '''Code''' box on the [HelpRoot_FormReference\CS_20_60_00|Report Definitions] ([~/?ScreenId=CS206000|CS206000]) form. The report code is stored in the <tt>ReportCode</tt> column of the <tt>RMReport</tt> table.{br}

The schema of an analytical report can include the position of the report in the site map so that the users can work with the report. To run the report, a user clicks the '''Run Report''' button on the form toolbar of the report form.
==How the Analytical Report Is Launched from the Report Form==
When a user opens the report form of an analytical report, the webpage performs the POST HTTP request to the <tt>RMLauncher.aspx</tt> page, passing the report code with {{.rpx}} appended as the <tt>ID</tt> query string parameter of the request, as shown in the following example.{{{{http://localhost/AcumaticaDB/frames/rmlauncher.aspx?id=dbsp.rpx&HideScript=On
}}}}{br}

The <tt>RMLauncher.aspx</tt> page contains the <tt>PXReportViewer</tt> control, whose JavaScript objects and functions are designed to obtain the report data and display the data on the form, and the <tt>ARmDataSource</tt> control, which is used to retrieve data for the analytical report.{br}

On the server side, the system (by using an instance of the <tt>PX.Web.UI.PXReportViewer</tt> class) processes the request as follows:[anchor|#_5508573f-4fbd-486e-aa16-95e306a78dcd]
#Loads the parameters of the analytical report from the database (by using the <tt>LoadReport</tt> method) to a <tt>PX.Reports.Controls.Report</tt> object as follows: 
##The system retrieves the data source of the report viewer as an instance of the <tt>PX.CS.RMReportReader</tt> class, which is a graph (derived from <tt>PXGraph&lt;RMReportMaint, RMReport&gt;</tt>) that implements the <tt>PX.Report.ARm.Data.IARmDataSource</tt> interface. 
##By using the <tt>GetReport</tt> method of <tt>IARmDataSource</tt>, the system retrieves the parameters of the analytical report from the database to the <tt>PX.Reports.ARm.ARmReport</tt> object.
##By using the <tt>CreateReport</tt> method of the <tt>PX.Reports.ARm.Data.ARmProcessor</tt> class, the system creates a <tt>Report</tt> object with the parameters retrieved from the <tt>ARmReport</tt> object.
#If the report parameters are loaded successfully, performs the following:
##The system instantiates a <tt>PX.Reports.Web.WebReport</tt> object that will store data of the launched report and assigns an instance ID to <tt>WebReport</tt>.
##The system initializes the <tt>ProcessMethod</tt> field of the <tt>WebReport</tt> object with the processing function for analytical reports.
{br}

The server returns an XML response with the report parameters to display and with the ID of the instance of <tt>WebReport</tt> in the session. The browser displays the report parameters on the report form.
==How the Data of the Analytical Report Is Retrieved==
After the user has selected the values of the parameters of the analytical report and clicked the '''Run Report''' button on the form toolbar of the report form, the webpage sends the GET request to <tt>PX.ReportViewer.axd</tt> on the server with the ID of the <tt>WebReport</tt> instance in the session (which was created when the report was launched). {br}

To process the request, the server invokes the <tt>Render</tt> method of the <tt>WebReport</tt> class, which launches the generation of the report as a long-running operation in a separate thread. For details on how the long-running operation is processed for a report, see [HelpRoot_Dev_Platform\BL__con_Asynchronous_Execution#_397e929e-f4b4-4441-9688-1e0a4ca7ab33|Processing a Report as a Long-Running Operation].{br}

To retrieve the data of the analytical report from the database, the system uses the <tt>PX.Objects.CS.RMReportReaderGL</tt> (for financial reports) and <tt>PX.Objects.CS.RMReportReaderPM</tt> (for project accounting reports) extensions of the <tt>PX.CS.RMReportReader</tt> graph. 
==How the Report Data Is Displayed==
After the long-running operation has completed, the <tt>PXReportViewer</tt> control displays the analytical report on the report form. 
==Related Articles==
*[HelpRoot_ReportingTools\GL__GL_ARM_Reports|Managing Analytical Reports]
*[HelpRoot_Dev_Platform\BL__con_Asynchronous_Execution|Asynchronous Execution]]]></column>
			<column name="PlainText"><![CDATA[Display of Analytical Reports In this topic, you can find information about how  Acumatica ERP displays analytical reports. What an Analytical Report Is An analytical report is a specific type of report that you can construct in  Acumatica ERP by using the Analytical Report Manager (ARM) toolkit. You will likely want to use                 the ARM toolkit rather than the  Acumatica Report                         Designer to create the following types of reports: Financial reports that display data that is posted to the general ledger                         accounts and accumulated in the General Ledger module. The system gets the                         data of the general ledger accounts from the  GLHistory                          table of the database.  Project accounting reports that display data that is accumulated in the                         Project module. The system gets the data for these reports from the                              PMHistory  table of the database. For details on analytical reports, see the  F350 Reporting: Analytical Reports F350 Reporting: Analytical Reports                 training course. The schema of analytical reports are stored in a set of database tables that have                      RM  prefix in their names, such as                  RMReport ,  RMRowSet , and                      RMColumnSet . The analytical report is identified in the                 system by its code, which you specify in the  Code  box on the                       ([~/?ScreenId=CS206000|CS206000]) Report Definitions (CS206000) form. The report code is stored in the                      ReportCode  column of the  RMReport                  table. The schema of an analytical report can include the position of the report in the site                 map so that the users can work with the report. To run the report, a user clicks the                      Run Report  button on the form toolbar of the report                 form. How the Analytical Report Is Launched from the Report Form When a user opens the report form of an analytical report, the webpage performs the                 POST HTTP request to the  RMLauncher.aspx  page, passing the                 report code with  .rpx  appended as the  ID  query                 string parameter of the request, as shown in the following                 example. http://localhost/AcumaticaDB/frames/rmlauncher.aspx?id=dbsp.rpx&HideScript=On The  RMLauncher.aspx  page contains the                      PXReportViewer  control, whose JavaScript objects and                 functions are designed to obtain the report data and display the data on the form,                 and the  ARmDataSource  control, which is used to retrieve data for                 the analytical report. On the server side, the system (by using an instance of the                      PX.Web.UI.PXReportViewer  class) processes the request as                     follows: Loads the parameters of the analytical report from the database (by using                         the  LoadReport  method) to a                              PX.Reports.Controls.Report  object as follows:  The system retrieves the data source of the report viewer as an                                 instance of the  PX.CS.RMReportReader  class, which                                 is a graph (derived from  PXGraph<RMReportMaint,                                     RMReport> ) that implements the                                      PX.Report.ARm.Data.IARmDataSource  interface.  By using the  GetReport  method of                                      IARmDataSource , the system retrieves the                                 parameters of the analytical report from the database to the                                      PX.Reports.ARm.ARmReport  object. By using the  CreateReport  method of the                                      PX.Reports.ARm.Data.ARmProcessor  class, the                                 system creates a  Report  object with the                                 parameters retrieved from the  ARmReport                                  object. If the report parameters are loaded successfully, performs the following: The system instantiates a                                      PX.Reports.Web.WebReport  object that will                                 store data of the launched report and assigns an instance ID to                                      WebReport . The system initializes the  ProcessMethod  field of                                 the  WebReport  object with the processing function                                 for analytical reports. The server returns an XML response with the report parameters to display and with the                 ID of the instance of  WebReport  in the session. The browser                 displays the report parameters on the report form. How the Data of the Analytical Report Is Retrieved After the user has selected the values of the parameters of the analytical report and                 clicked the  Run Report  button on the form toolbar of the                 report form, the webpage sends the GET request to                      PX.ReportViewer.axd  on the server with the ID of the                      WebReport  instance in the session (which was created when the                 report was launched).  To process the request, the server invokes the  Render  method of                 the  WebReport  class, which launches the generation of the report                 as a long-running operation in a separate thread. For details on how the                 long-running operation is processed for a report, see  Processing a Report as a Long-Running Operation. To retrieve the data of the analytical report from the database, the system uses the                      PX.Objects.CS.RMReportReaderGL  (for financial reports) and                      PX.Objects.CS.RMReportReaderPM  (for project accounting                 reports) extensions of the  PX.CS.RMReportReader  graph.  How the Report Data Is Displayed After the long-running operation has completed, the  PXReportViewer                  control displays the analytical report on the report form.  ]]></column>
		</row>
		<row PageID="cc602399-bac4-46bf-b23c-79e86251c521" Language="en-US" PageRevisionID="1" Content="&#xA;The topics in this part of the guide explain how an application based on Acumatica Framework can access data from the application database and the data stored in the session.&#xA;==In This Part==[anchor|#_14801a9b-e3f4-4e28-a65a-c03b44851ea2]&#xA;*[HelpRoot_Dev_Platform\AD__mng_Querying_Data|Querying Data in Acumatica Framework]&#xA;*[HelpRoot_Dev_Platform\AD__mng_Fluent_BQL|Creating Fluent BQL Queries]&#xA;*[HelpRoot_Dev_Platform\AD__mng_Traditional_BQL|Creating Traditional BQL Queries]&#xA;*[HelpRoot_Dev_Platform\AD__mng_LINQ|Creating LINQ Queries]&#xA;*[HelpRoot_Dev_Platform\AD__mng_Defining_PK_and_FK|Defining Relationships Between DACs]&#xA;*[HelpRoot_Dev_Platform\AD__mng_Working_with_Cache_and_Session|Working with Data in Cache and Session]&#xA;" PlainText="Accessing Data The topics in this part of the guide explain how an application based on  Acumatica Framework can     access data from the application database and the data stored in the session. In This Part Querying Data in Acumatica FrameworkCreating Fluent BQL QueriesCreating Traditional BQL QueriesCreating LINQ QueriesDefining Relationships Between DACsWorking with Data in Cache and Session" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="0dd5ceb6-d6ed-ee32-d1bc-3f2228981e6a" RecordSourceID="22377" />
		<row PageID="5978bf0a-e65c-47ca-8fec-40aa733ae2b8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="403178df-3969-1989-4e04-cfcc9d960fb7" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#_10ea3d32-c245-4dae-99af-3685d4111a2e]
In Acumatica Framework, you generally use business query language (BQL) to query data from the database. BQL statements represent specific SQL queries and are translated into SQL by Acumatica Framework, which helps you to avoid the specifics of the database provider and validate the queries at the time of compilation. Acumatica Framework provides two dialects of BQL: traditional BQL and fluent BQL. [anchor|#_1522a3d3-5821-4e37-a958-bc956b38c94e]{br}

To query data from the database, you can also use language-integrated query (LINQ), which is a part of the .NET Framework. In the code of Acumatica Framework-based applications, you can use both the standard query operators (provided by LINQ libraries) and the Acumatica Framework-specific operators that are designed to query database data. {br}

This chapter explains the aspects that are common to traditional BQL, fluent BQL, and LINQ and provides a high-level comparison of the approaches for querying data in Acumatica Framework.
==In This Chapter==[anchor|#_6140616f-ee44-4f3a-8ec1-2c609cd80d6c]
{| class="checklist invisiblechecklist" | width="100%" 
|- 
| [anchor|#_cbe0ecf8-ac56-4a4d-b0f0-d06da70c7493]
*[HelpRoot_Dev_Platform\AD__con_BQL_and_LINQ|BQL and LINQ]
*[HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes]
*[HelpRoot_Dev_Platform\AD__con_PXView_and_PXCache|PXView and PXCache of the Data View]
*[HelpRoot_Dev_Platform\BL__con_Views|PXView Type and Views Collection]
*[HelpRoot_Dev_Platform\BL__con_Data_View_Delegate|Data View Delegates]
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]
*[HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL]
*[HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache]
*[HelpRoot_Dev_Platform\AD__con_Comparison_of_TBQL_FBQL_LINQ|Comparison of Fluent BQL, Traditional BQL, and LINQ]
*[HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents]

| [anchor|#_0482456b-4645-4497-92aa-2658dd32dda5]
*[HelpRoot_Dev_Platform\AD__how_Execute_BQL_Statement|To Execute BQL Statements]
*[HelpRoot_Dev_Platform\AD__how_Process_Resultset|To Process the Result of the Execution of the BQL Statement]

|}]]></column>
			<column name="PlainText"><![CDATA[Querying Data in  Acumatica FrameworkIn  Acumatica Framework, you generally use business query language (BQL) to query data from the database. BQL statements represent specific SQL queries and are translated into SQL by  Acumatica Framework, which helps you to avoid the specifics of the database provider and validate the queries at the time of compilation.  Acumatica Framework provides two dialects of BQL: traditional BQL and fluent BQL.  To query data from the database, you can also use             language-integrated query (LINQ), which is a part of the .NET Framework. In the code of                  Acumatica Framework-based applications, you can use both the standard query operators (provided by LINQ             libraries) and the  Acumatica Framework-specific operators that are designed to query database data.  This chapter explains the aspects that are common to traditional BQL, fluent BQL, and LINQ and     provides a high-level comparison of the approaches for querying data in  Acumatica Framework. In This Chapter BQL and LINQData Access ClassesPXView and PXCache of the Data ViewPXView Type and Views CollectionData View DelegatesData Query ExecutionTranslation of a BQL Command to SQLMerge of the Records with PXCacheComparison of Fluent BQL, Traditional BQL, and LINQFluent BQL and Traditional BQL EquivalentsTo Execute BQL StatementsTo Process the Result of the Execution of the BQL Statement]]></column>
		</row>
		<row PageID="63ce6aaa-0620-4993-a9a3-a49469eb906a" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="0f9ac0b3-1bf5-9c64-b0e4-4db3c58ccad0" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When a data request occurs, the system creates an instance of a business logic controller (also referred as a ''graph''). The graph contains the data views that you define in code. In these data views, you define the queries to be executed to retrieve the requested data by using business query language (BQL), which is provided by Acumatica Framework. You also use BQL to define the data queries directly in code and in attributes.{br}

BQL is written in C#; it is based on generic class syntax, which is similar to SQL syntax. Thus, BQL has almost the same keywords as SQL does, placed in the order in which they are used in SQL. BQL offers several benefits to the application developer. BQL does not depend on the specifics of the database provider, and it is object-oriented and extendable. Also, BQL provides compile-time syntax validation, which helps to prevent SQL syntax errors.{br}

You can also use language-integrated query (LINQ) provided by the {{System.Linq}} library when you need to select records from the database in the code of Acumatica Framework-based applications or if you want to apply additional filtering to the data of a BQL query. However, you still have to use BQL to define the data views in graphs and to specify the data queries in the attributes of data fields.{br}{TOC}
==Fluent BQL and Traditional BQL==
 Acumatica Framework provides two dialects of BQL: fluent BQL and traditional BQL. Traditional BQL was the initial language for data queries in Acumatica Framework; it provides the benefits described above. Fluent BQL provides the following advantages as compared to traditional BQL:[anchor|#_08883d04-3e68-4119-ac8b-b55bb2f524a7]
*It is easier to read and edit fluent BQL queries than traditional BQL queries because each section of a fluent BQL query does not depend on the others and can appear in only specific places of the query. Also, fluent BQL queries contain fewer commas and angle brackets and do not use numbered classes (such as <tt>Select2</tt> or <tt>Select6</tt>).
*You do not need to select a suitable class for a fluent BQL query (such as <tt>PXSelectOrderBy&lt;,&gt;</tt> or <tt>PXSelectJoinOrderBy&lt;,,&gt;</tt>); instead, you simply start typing the command, and IntelliSense in Visual Studio offers continuations that are relevant for the current query state.
{br}

For a detailed list of differences between the dialects, see [HelpRoot_Dev_Platform\AD__con_Comparison_of_TBQL_FBQL_LINQ|Comparison of Fluent BQL, Traditional BQL, and LINQ].{br}

The following code shows an example of a data view written in fluent BQL.{{{{SelectFrom&lt;Product&gt;.
    Where&lt;Product.availQty.IsNotNull.
          And&lt;Product.availQty.IsGreater&lt;Product.bookedQty&gt;&gt;&gt;.View products;
}}}}{br}

The following code shows the same data view written in traditional BQL.<source lang="csharp">PXSelect&lt;Product,
    Where&lt;Product.availQty, IsNotNull,
        And&lt;Product.availQty, Greater&lt;Product.bookedQty&gt;&gt;&gt;&gt; products;</source>
Suppose the database provider is Microsoft SQL Server. Acumatica Framework translates the fluent and traditional BQL queries shown above into the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table. {{{{SELECT [list of columns] FROM Product
WHERE Product.AvailQty IS NOT NULL
    AND Product.AvailQty &gt; Product.BookedQty 
}}}}[anchor|#_204c61e0-50e3-4956-b3bf-bd27b216f89a]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
==LINQ==[anchor|#_b44e39ba-94a2-41ef-bc38-b586b837d8a5]
To configure a LINQ query, you can use the following variants of syntax:[anchor|#_92317386-9ac6-4d0c-ace6-af5dbafecd50]
*Query expressions, which use standard query operators from the {{System.Linq}} namespace (such as {{where}} or {{orderby}}) or Acumatica Framework-specific operators from the {{PX.Data.SQLTree}} namespace (such as <tt>SQL.BinaryLen</tt>, which is shown in the following example of this syntax). <source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var goods = from p in graph.Select&lt;Product&gt;()
  where 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0
  select new 
  { 
    p.ProductID, 
    p.ProductCD, 
    p.ProductName, 
    Len = p.ProductName.Length, 
    BLen = SQL.BinaryLen( p.ProductName) + 1, 
    p.GroupMask, 
    p.WorkGroupID 
};</source>
*Explicit (method-based) syntax. The arguments of the methods used in this syntax are lambda expressions. In these expressions, you can use the standard C# operators and Acumatica Framework-specific operators from the {{PX.Data.SQLTree}} namespace (such as <tt>SQL.BinaryLen</tt>, which is shown in the following code). The code below is equivalent to the query expression shown above.<source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var goods = graph.Select&lt;Product&gt;()
  .Where( p =&gt; 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0)
  .Select( p =&gt; new     
    { 
      p.ProductID, 
      p.ProductCD, 
      p.ProductName, 
      Len = p.ProductName.Length, 
      BLen = SQL.BinaryLen(p.ProductName) + 1, 
      p.GroupMask, p.WorkGroupID 
    });</source>

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Fluent_BQL|Fluent Business Query Language]
*[HelpRoot_Dev_Platform\AD__con_Traditional_BQL|Traditional Business Query Language]
*[HelpRoot_Dev_Platform\AD__con_LINQ_in_Acumatica_Framework|LINQ in Acumatica Framework]
*[HelpRoot_Dev_Platform\AD__con_Comparison_of_TBQL_FBQL_LINQ|Comparison of Fluent BQL, Traditional BQL, and LINQ]]]></column>
			<column name="PlainText"><![CDATA[BQL and LINQ When a data request occurs, the system creates an instance of a business logic controller         (also referred as a  graph ). The graph contains the data views that you define in         code. In these data views, you define the queries to be executed to retrieve the requested         data by using business query language (BQL), which is provided by  Acumatica Framework.         You also use BQL to define the data queries directly in code and in attributes. BQL is written in C#; it is based on generic class syntax, which is similar to SQL syntax.         Thus, BQL has almost the same keywords as SQL does, placed in the order in which they are         used in SQL. BQL offers several benefits to the application developer. BQL does not depend         on the specifics of the database provider, and it is object-oriented and extendable. Also,         BQL provides compile-time syntax validation, which helps to prevent SQL syntax errors. You can also use language-integrated query (LINQ) provided by the            System.Linq  library when you need to select records from the database in         the code of  Acumatica Framework-based applications or if you want to apply additional filtering to the data of a BQL         query. However, you still have to use BQL to define the data views in graphs and to specify         the data queries in the attributes of data fields. Fluent BQL and Traditional BQL  Acumatica Framework provides two dialects of BQL: fluent BQL and traditional BQL. Traditional BQL was the         initial language for data queries in  Acumatica Framework;         it provides the benefits described above. Fluent BQL provides the following advantages as         compared to traditional BQL: It is easier to read and edit fluent BQL queries than traditional BQL queries because             each section of a fluent BQL query does not depend on the others and can appear in only             specific places of the query. Also, fluent BQL queries contain fewer commas and angle             brackets and do not use numbered classes (such as  Select2  or                Select6 ). You do not need to select a suitable class for a fluent BQL query (such as                PXSelectOrderBy<,>  or                PXSelectJoinOrderBy<,,> ); instead, you simply start typing the             command, and IntelliSense in Visual Studio offers continuations that are relevant for             the current query state. For a detailed list of differences between the dialects, see  Comparison of Fluent BQL, Traditional BQL, and LINQ. The following code shows an example of a data view written in fluent         BQL. SelectFrom<Product>.
    Where<Product.availQty.IsNotNull.
          And<Product.availQty.IsGreater<Product.bookedQty>>>.View products; The following code shows the same data view written in traditional BQL. PXSelect<Product,
    Where<Product.availQty, IsNotNull,
        And<Product.availQty, Greater<Product.bookedQty>>>> products; Suppose the database provider is Microsoft SQL Server.  Acumatica Framework         translates the fluent and traditional BQL queries shown above into the following SQL query,         where  [list of columns]  is the list of columns of the            Product  table.  SELECT [list of columns] FROM Product
WHERE Product.AvailQty IS NOT NULL
    AND Product.AvailQty > Product.BookedQty   Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. LINQ To configure a LINQ query, you can use the following       variants of syntax: Query expressions, which use standard query operators from the              System.Linq  namespace (such as  where  or              orderby ) or  Acumatica Framework-specific           operators from the  PX.Data.SQLTree  namespace (such as              SQL.BinaryLen , which is shown in the following example of this           syntax).            ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var goods = from p in graph.Select<Product>()
  where 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0
  select new 
  { 
    p.ProductID, 
    p.ProductCD, 
    p.ProductName, 
    Len = p.ProductName.Length, 
    BLen = SQL.BinaryLen( p.ProductName) + 1, 
    p.GroupMask, 
    p.WorkGroupID 
}; Explicit (method-based) syntax. The arguments of the methods used in this syntax are           lambda expressions. In these expressions, you can use the standard C# operators and  Acumatica Framework-specific           operators from the  PX.Data.SQLTree  namespace (such as              SQL.BinaryLen , which is shown in the following code). The code below           is equivalent to the query expression shown           above. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var goods = graph.Select<Product>()
  .Where( p => 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0)
  .Select( p => new     
    { 
      p.ProductID, 
      p.ProductCD, 
      p.ProductName, 
      Len = p.ProductName.Length, 
      BLen = SQL.BinaryLen(p.ProductName) + 1, 
      p.GroupMask, p.WorkGroupID 
    }); ]]></column>
		</row>
		<row PageID="3f6ee8e9-b29e-4dab-b4f8-4406c3ef101d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f61570ce-3f39-909d-f7fe-120afe8c749b" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The classes that represent database tables in Acumatica Framework are called ''data access classes (DACs)''. You derive these classes from the <tt>PX.Data.IBqlTable</tt> interface. The name of a class is usually the same as the name of the database table to which it provides access (except with the DACs that have the <tt>PXTable</tt> or <tt>PXProjection</tt> attributes, which change the default binding of DACs to database tables). We recommend that you add to each DAC the <tt>PXCacheName</tt> or <tt>PXHidden</tt> attribute to specify whether and how the DAC is available in generic inquiries and reports.
==DAC Fields==
For each table column, you add a data field to the corresponding data access class by declaring the following members:[anchor|#ul_ijc_z2j_4k]
*A {{public abstract}} class (which is also referred to as a ''class field'')
*:You use this class to reference the table column in a business query language (BQL) statement. The declaration of the class field is different in the fluent BQL dialect than it is in the traditional BQL dialect. For details about the declaration, see [HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL] and [HelpRoot_Dev_Platform\AD__con_DACs_in_TraditionalBQL|Data Access Classes in Traditional BQL]. We recommend that you use the fluent BQL style of DAC declaration because it can be used both in fluent BQL and in traditional BQL. The style of class field declaration is not important for queries defined with language-integrated query (LINQ).
*A {{public virtual}} property (which is also referred to as ''property field'')
*:You bind the data field to the table column by specifying the type attribute that is derived from the <tt>PXDBFieldAttribute</tt> class, such as <tt>PXDBString</tt>, and specifying the name of the column as the name of the property. If you don&rsquo;t need to bind the property to a database column (for example, if you want the value of the property to be calculated from the database fields), you specify an unbound type attribute, such as <tt>PXDBCalced</tt>. You assign the property a name that starts with an uppercase letter. For the lists of bound and unbound type attributes, see [HelpRoot_Dev_Platform\BL__con_Attr_DB_Types|Bound Field Data Types] and [HelpRoot_Dev_Platform\BL__con_Attr_Unbound_Data_Types|Unbound Field Data Types].
*:You use the property, which, in the system, holds the column data of the table, in the queries defined with LINQ. In the SQL command generated from BQL, the framework explicitly lists columns for all bound data fields defined in the DAC. For the unbound data fields whose property attribute defines a BQL command, if this data field is used in a BQL query, the system translates the BQL command of the property to SQL when the BQL query is translated to SQL. For more information on the translation of BQL to SQL, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
The following code shows an example of the <tt>Product</tt> DAC declaration in the fluent BQL style.<source lang="csharp">using System;
using PX.Data;

public class Product : PX.Data.IBqlTable
{
    // The class used in BQL statements to refer to the ProductID column
    public abstract class productID : PX.Data.BQL.BqlInt.Field&lt;productID&gt;
    {
    }
    // The property holding the ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }

    // The class used in BQL statements to refer to the AvailQty column
    public abstract class availQty : PX.Data.BQL.BqlDecimal.Field&lt;availQty&gt;
    {
    }
    // The property holding the AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
}</source>
==Bound and Unbound Data Fields==
A data field can be bound (mapped) or unbound (not mapped) to a database column. The type attribute on a DAC field specifies whether the field is bound or unbound. ''DB'' in the type attribute name denotes whether the field is bound. In the code below, the {{OrderNbr}} field is bound because it has the <tt>PXDBString</tt> type attribute, while the {{Description}} field is unbound because of the <tt>PXString</tt> attribute.<source lang="csharp">// DB means this is a bound DAC field
[PX<b>DB<b>String(15, IsKey = true, IsUnicode = true)]
public virtual string OrderNbr {...}
// The absence of DB means this is an unbound DAC field
[PXString(50, IsUnicode = true)]
public virtual string Description {...}</source>
The framework provides bound and unbound types for many data types, including string, Boolean, decimal, integer, and date and time. These types are abstracted from specific database types.
==Mandatory Attributes on Data Fields==
The only mandatory attributes that you should add to DAC fields are:[anchor|#ul_xf5_zvh_ln]
*Type attributes, such as <tt>PXDBString</tt>, <tt>PXString</tt>, <tt>PXDBDecimal</tt>, and <tt>PXDecimal</tt>.
*<tt>PXUIField</tt>—for fields displayed in the UI.
[anchor|#key_fields]
==Key Fields==
You define the key fields in DACs independently of the database. Database key fields may not be key fields in the DAC. To mark a field as a key field, you set the <tt>IsKey</tt> property to true in the type attribute, as follows.<source lang="csharp">[PXDBString(15, IsUnicode = true, <b>IsKey = true<b>)]
[PXDefault]
[PXUIField(DisplayName = "Product ID")]
public virtual string ProductCD
{...
}</source>
{{Product}} is the example of a DAC whose key field is different from the database key field. The primary key of the {{Product}} table in the database consist of the {{ProductID}} field. In the {{Product}} DAC, you mark the {{ProductCD}} field as the key field. The key fields defined in a DAC are used to identify DAC data records in cache objects.{br}

DACs in Acumatica ERP can include a pair of ''ID'' and ''CD'' fields (such as {{ProductID}} and {{ProductCD}}). Typically, the ''ID'' field is represented by the identity column in the database (automatically incremented integer) and serves as the ''surrogate'' field. The ''CD'' field is the ''natural'' key, usually string, which is recognizable by a human.((({S:Warn}For more information on attributes on DAC fields, see [HelpRoot_Dev_Platform\BL__mng_Working_With_Attributes|Working with Attributes].
)))
==Concurrency Management==
You should add the SQL Server timestamp column to a table to make Acumatica Framework able to handle concurrent updates. {{{{[PXDBTimestamp()]
public virtual byte[] TStamp
{
    ...
}
}}}}
The corresponding timestamp data field should be declared in the data access class. If the timestamp data field is declared, Acumatica Framework handles the timestamp column automatically. Acumatica Framework checks the row version every time the row is modified. For details about the timestamp, see [HelpRoot_Dev_Platform\DA__con_Concurrent_Update_Control|Concurrent Update Control].
==Order of the Fields in a DAC==
It is important to pay attention to the order in which fields are declared in a DAC: Every roundtrip Acumatica Framework applies changes to DAC instances in the same order as their fields are declared. All field-level event handlers are always raised in the same order as fields are declared in the DAC.
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL]
*[HelpRoot_Dev_Platform\AD__con_DACs_in_TraditionalBQL|Data Access Classes in Traditional BQL]
*[HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL]]]></column>
			<column name="PlainText"><![CDATA[Data Access Classes The classes that represent database tables in  Acumatica Framework         are called  data access classes (DACs) . You derive these classes from the            PX.Data.IBqlTable  interface. The name of a class is usually the same as         the name of the database table to which it provides access (except with the DACs that have         the  PXTable  or  PXProjection  attributes, which change         the default binding of DACs to database tables). We recommend that you add to each DAC the            PXCacheName  or  PXHidden  attribute to specify whether         and how the DAC is available in generic inquiries and reports. DAC Fields For each table column, you add a data field to the         corresponding data access class by declaring the following members: A  public abstract  class (which is also referred to as a  class             field ) You use this class to reference the table column in a business query             language (BQL) statement. The declaration of the class field is different in the fluent             BQL dialect than it is in the traditional BQL dialect. For details about the             declaration, see  Data Access Classes in Fluent BQL and  Data Access Classes in Traditional BQL. We recommend that you use the fluent BQL             style of DAC declaration because it can be used both in fluent BQL and in traditional             BQL. The style of class field declaration is not important for queries defined with             language-integrated query (LINQ). A  public virtual  property (which is also referred to as  property             field ) You bind the data field to the table column by specifying the type             attribute that is derived from the  PXDBFieldAttribute  class, such as                PXDBString , and specifying the name of the column as the name of             the property. If you don't need to bind the property to a database column (for example,             if you want the value of the property to be calculated from the database fields), you             specify an unbound type attribute, such as  PXDBCalced . You assign the             property a name that starts with an uppercase letter. For the lists of bound and unbound             type attributes, see  Bound Field Data Types and  Unbound Field Data Types. You use the property, which, in             the system, holds the column data of the table, in the queries defined with LINQ. In the             SQL command generated from BQL, the framework explicitly lists columns for all bound             data fields defined in the DAC. For the unbound data fields whose property attribute             defines a BQL command, if this data field is used in a BQL query, the system translates             the BQL command of the property to SQL when the BQL query is translated to SQL. For more             information on the translation of BQL to SQL, see  Translation of a BQL Command to SQL. The following code shows an example of the  Product  DAC declaration in       the fluent BQL       style. using System;
using PX.Data;

public class Product : PX.Data.IBqlTable
{
    // The class used in BQL statements to refer to the ProductID column
    public abstract class productID : PX.Data.BQL.BqlInt.Field<productID>
    {
    }
    // The property holding the ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }

    // The class used in BQL statements to refer to the AvailQty column
    public abstract class availQty : PX.Data.BQL.BqlDecimal.Field<availQty>
    {
    }
    // The property holding the AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
} Bound and Unbound Data Fields A data field can be bound (mapped) or unbound (not mapped) to a database column. The type         attribute on a DAC field specifies whether the field is bound or unbound.  DB  in the         type attribute name denotes whether the field is bound. In the code below, the            OrderNbr  field is bound because it has the  PXDBString          type attribute, while the  Description  field is unbound because of the            PXString  attribute. // DB means this is a bound DAC field
[PX DB String(15, IsKey = true, IsUnicode = true)]
public virtual string OrderNbr {...}
// The absence of DB means this is an unbound DAC field
[PXString(50, IsUnicode = true)]
public virtual string Description {...} The framework provides bound and unbound types for many data types, including string,         Boolean, decimal, integer, and date and time. These types are abstracted from specific         database types. Mandatory Attributes on Data Fields The only mandatory attributes that you should add to DAC fields are: Type attributes, such as  PXDBString ,  PXString ,              PXDBDecimal , and  PXDecimal . PXUIField —for fields displayed in the UI. Key Fields You define the key fields in DACs independently of the database. Database key fields may         not be key fields in the DAC. To mark a field as a key field, you set the            IsKey  property to true in the type attribute, as follows. [PXDBString(15, IsUnicode = true,  IsKey = true )]
[PXDefault]
[PXUIField(DisplayName = "Product ID")]
public virtual string ProductCD
{...
} Product  is the example of a DAC whose key field is different from the         database key field. The primary key of the  Product  table in the database         consist of the  ProductID  field. In the  Product  DAC, you         mark the  ProductCD  field as the key field. The key fields defined in a DAC         are used to identify DAC data records in cache objects. DACs in  Acumatica ERP can include a pair of  ID  and  CD  fields (such as  ProductID          and  ProductCD ). Typically, the  ID  field is represented by the         identity column in the database (automatically incremented integer) and serves as the            surrogate  field. The  CD  field is the  natural  key, usually string,         which is recognizable by a human. For more information on attributes on DAC fields, see  Working with Attributes. Concurrency Management You should add the SQL Server timestamp column to a table to make  Acumatica Framework         able to handle concurrent updates.  [PXDBTimestamp()]
public virtual byte[] TStamp
{
    ...
} The corresponding timestamp data field should be declared in the data access class. If the         timestamp data field is declared,  Acumatica Framework         handles the timestamp column automatically.  Acumatica Framework         checks the row version every time the row is modified. For details about the timestamp, see            Concurrent Update Control. Order of the Fields in a DAC It is important to pay attention to the order in which fields are declared in a DAC: Every         roundtrip  Acumatica Framework         applies changes to DAC instances in the same order as their fields are declared. All         field-level event handlers are always raised in the same order as fields are declared in the         DAC. ]]></column>
		</row>
		<row PageID="ce8ee369-bc71-4e32-8969-067b26c63c00" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="367300b5-647d-fdb4-7093-e2fc9c59b33c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
''Data views'' are graph members that are used to retrieve and modify data records of a particular data access class (DAC). You use data views:[anchor|#ul_d4z_xk5_bm]
*To provide data retrieval and manipulation functions for the UI
*To retrieve and manipulate data from code

You define a data view with a class derived from the <tt>PXSelectBase</tt> class, such as <tt>SelectFrom&lt;&gt;.View</tt> in fluent BQL and <tt>PXSelect&lt;&gt;</tt> in traditional BQL. The first DAC of the data view is the main DAC of the data view. Below are the {{Orders}} and {{OrderDetails}} data views that are defined in the {{SalesOrderEntry}} graph. Both data views provide data for the UI. Acumatica Framework automatically instantiates the data views and invokes the <tt>Select()</tt> method when either of these data views is requested by the client.<source lang="csharp">public class SalesOrderEntry : PXGraph&lt;SalesOrderEntry, SalesOrder&gt;
{
    // Provides an interface for manipulation of sales orders
    public SelectFrom&lt;SalesOrder&gt;.View Orders;

    // Provides an interface for manipulation of detail lines of
    // the specified order
    public SelectFrom&lt;OrderLine&gt;.
            Where&lt;OrderLine.orderNbr.
                IsEqual&lt;SalesOrder.orderNbr.FromCurrent&gt;&gt;.View OrderDetails;
}</source>
When a graph executes a data view, the graph creates the following objects:[anchor|#_e66ab36e-c0b7-4537-8e07-1c21913cc144]
*The <tt>PXView</tt> object, which contains the BQL command that corresponds to the data view
*The <tt>PXCache&lt;DAC&gt;</tt> objects whose type parameter is defined by the data access classes (DACs) that are used in the BQL command
The <tt>PXView</tt> object uses the BQL command to retrieve data from the database and stores the retrieved data in the <tt>PXCache</tt> object. The data view stores references to the corresponding <tt>PXView</tt> object and the <tt>PXCache</tt> object of the main DAC of the data view, as shown in the following diagram.[anchor|#_a82d0b44-8749-4cc7-910c-001f4d596762][anchor|#_d09b3994-4d5c-4062-af21-ac44d8654955][image:StudioDeveloperGuide/Images/Graph_View_BQL.png|popup|Example of relationships between classes|450px]{br}

<tt>PXCache&lt;DAC&gt;</tt> are objects that are created by the system to maintain data records retrieved from the database and the modifications to these data records. The system serializes the modified data records from all cache objects to the session between round trips and restores them on each new round trip.{br}

Each data view is connected to a cache object by the main DAC of this data view. For example, the {{Orders}} data view from the example above is related to a cache object of {{PXCache<SalesOrder>}} type. To insert a new data record, update an existing one, or delete a data record, you use the data view methods, which invoke the corresponding cache methods.{br}

Cache objects identify data records by their key fields, which are fields with the <tt>IsKey</tt> property set to <tt>true</tt> in a type attribute.Cache objects hold the data records that are modified but not yet saved to the database. Each cache object holds the data records of a single DAC. In a graph, each data view corresponds to the cache object that works with the main DAC of the data view.
For data binding, you specify a data view in the <tt>DataMember</tt> property of a UI container control, such as a form, grid, or tab on the ASPX page.]]></column>
			<column name="PlainText"><![CDATA[PXView and PXCache of the Data View Data views  are graph members that are used to retrieve and modify data records         of a particular data access class (DAC). You use data views: To provide data retrieval and manipulation functions for the UI To retrieve and manipulate data from code You define a data view with a class derived from the  PXSelectBase          class, such as  SelectFrom<>.View  in fluent BQL and            PXSelect<>  in traditional BQL. The first DAC of the data view is the         main DAC of the data view. Below are the  Orders  and            OrderDetails  data views that are defined in the            SalesOrderEntry  graph. Both data views provide data for the UI.  Acumatica Framework         automatically instantiates the data views and invokes the  Select()  method         when either of these data views is requested by the         client. public class SalesOrderEntry : PXGraph<SalesOrderEntry, SalesOrder>
{
    // Provides an interface for manipulation of sales orders
    public SelectFrom<SalesOrder>.View Orders;

    // Provides an interface for manipulation of detail lines of
    // the specified order
    public SelectFrom<OrderLine>.
            Where<OrderLine.orderNbr.
                IsEqual<SalesOrder.orderNbr.FromCurrent>>.View OrderDetails;
} When         a graph executes a data view, the graph creates the following objects: The  PXView  object, which contains the BQL command that corresponds             to the data view The  PXCache<DAC>  objects whose type parameter is defined by the             data access classes (DACs) that are used in the BQL command The  PXView  object uses the BQL command to retrieve data from the         database and stores the retrieved data in the  PXCache  object. The data         view stores references to the corresponding  PXView  object and the            PXCache  object of the main DAC of the data view, as shown in the         following diagram. Example of relationships between classes PXCache<DAC>  are objects that are created by the system         to maintain data records retrieved from the database and the modifications to these data         records. The system serializes the modified data records from all cache objects to the         session between round trips and restores them on each new round trip. Each data view         is connected to a cache object by the main DAC of this data view. For example, the            Orders  data view from the example above is related to a cache object of            PXCache<SalesOrder>  type. To insert a new data record, update an         existing one, or delete a data record, you use the data view methods, which invoke the         corresponding cache methods. Cache objects identify data records by their key fields,         which are fields with the  IsKey  property set to  true          in a type attribute. Cache objects hold the data records that are modified but not yet       saved to the database. Each cache object holds the data records of a single DAC. In a graph,       each data view corresponds to the cache object that works with the main DAC of the data         view. For data binding, you specify a data view in the  DataMember          property of a UI container control, such as a form, grid, or tab on the ASPX       page. ]]></column>
		</row>
		<row PageID="0af3b776-4c7b-4dd7-9f61-27c167abb261" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="47c44139-0458-d301-99a2-09db55d2f881" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In addition to including the <tt>Cache</tt> property, a data view includes the <tt>View</tt> property, which references a controller object of the <tt>PXView</tt> type. A <tt>PXView</tt> object is created automatically for each data view. This object is responsible for retrieving data from the database and placing it into the cache object.{br}

Each graph contains the following: a collection of cache objects, called <tt>Caches</tt>; and a collection of <tt>PXView</tt> objects, called <tt>Views</tt>. The framework handles these objects automatically; you don&rsquo;t have to initialize and control them.{br}

A <tt>PXView</tt> object contains two main parts:[anchor|#ul_t4x_1m3_ln]
*The BQL command, which is defined by the type of the data view.
*The optional delegate, which customarily constructs the data set that is returned instead of the result of the BQL command&rsquo;s execution. For details, see [HelpRoot_Dev_Platform\BL__con_Data_View_Delegate|Data View Delegates].

<tt>PXView</tt> objects, like graphs, are initialized and destroyed on each round trip.{br}

On an ASPX page, you bind each container control with a data view that provides data for the container control. To bind a container control and a data view, you specify the name of the data view in the <tt>DataMember</tt> property of the container control. When a form requests data, the system invokes the <tt>ExecuteSelect()</tt> method of the graph with data view name passed as an argument to execute every data view bound to the ASPX page&rsquo;s container controls. The positioning of container controls on the ASPX page determines the order of execution of the data views. Note that if a data view is not bound to any container control, it is not executed by request from the UI.((({S:Warn}The order in which data views are defined in a graph is important, because it defines the order in which data is saved to the database. (This order does not, however, define the order in which data views are executed.) The data view that you specify in the <tt>PrimaryView</tt> property should always be defined first in the graph.
)))
When a data record is modified on the form, the framework invokes the <tt>ExecuteInsert()</tt>, <tt>ExecuteUpdate()</tt>, or <tt>ExecuteDelete()</tt> method of the graph, passing the name of the data view as an argument. The graph obtains the data view by using its name and invokes the corresponding method of the data view.((({S:Warn} You shouldn&rsquo;t use the <tt>ExecuteSelect()</tt>, <tt>ExecuteInsert()</tt>, <tt>ExecuteUpdate()</tt>, or <tt>ExecuteDelete()</tt> method for purposes other than debugging.
)))]]></column>
			<column name="PlainText"><![CDATA[PXView Type and Views Collection In addition to including the  Cache  property, a data view includes the            View  property, which references a controller object of the            PXView  type. A  PXView  object is created         automatically for each data view. This object is responsible for retrieving data from the         database and placing it into the cache object. Each graph contains the following: a collection of cache objects, called            Caches ; and a collection of  PXView  objects, called            Views . The framework handles these objects automatically; you don't         have to initialize and control them. A  PXView  object contains two main parts: The BQL command, which is defined by the type of the data view. The optional delegate, which customarily constructs the data set that is returned           instead of the result of the BQL command's execution. For details, see  Data View Delegates. PXView  objects, like graphs, are initialized and destroyed on each round         trip. On an ASPX page, you bind each container control with a data view that provides data for         the container control. To bind a container control and a data view, you specify the name of         the data view in the  DataMember  property of the container control. When a         form requests data, the system invokes the  ExecuteSelect()  method of the         graph with data view name passed as an argument to execute every data view bound to the ASPX         page's container controls. The positioning of container controls on the ASPX page determines         the order of execution of the data views. Note that if a data view is not bound to any         container control, it is not executed by request from the UI. The order in which data views are defined in a graph is important, because it defines         the order in which data is saved to the database. (This order does not, however, define the         order in which data views are executed.) The data view that you specify in the            PrimaryView  property should always be defined first in the         graph. When a data record is modified on the form, the framework invokes the            ExecuteInsert() ,  ExecuteUpdate() , or            ExecuteDelete()  method of the graph, passing the name of the data view         as an argument. The graph obtains the data view by using its name and invokes the         corresponding method of the data view.  You shouldn't use the  ExecuteSelect() ,            ExecuteInsert() ,  ExecuteUpdate() , or            ExecuteDelete()  method for purposes other than debugging. ]]></column>
		</row>
		<row PageID="8169bc20-c1de-4160-b687-54c24ea0419d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f09b984d-9fc9-1a2e-1fe8-20812dc5e183" RecordSourceID="22377">
			<column name="Content"><![CDATA[
By default, when a data view object is requested by the UI or you invoke the <tt>Select()</tt> method on the object, the system executes the query specified in the data view type. However, you can define a dynamic query, which is an optional graph method (called the ''data view delegate'') that is executed when the data view is requested. If no dynamic query is defined in the graph, Acumatica Framework executes the BQL statement from the data view type.{br}

You can use the data view delegate in the following cases:[anchor|#ul_eq3_tpx_xk]
*If the query is constructed dynamically at runtime by adding <tt>Where&lt;&gt;</tt> and <tt>Join&lt;&gt;</tt> clauses depending on some condition, typically a filter
*If the query retrieves data fields that cannot be calculated declaratively by using attributes—for instance, if you retrieve values that are aggregated by calculated data fields
*If the result set has data records that aren&rsquo;t retrieved from the database and are composed dynamically in code

==Definition of a Data View Delegate==
To define the delegate for a data view, define a method that has the same name as the data view but uses a different case for the first letter. The delegate returns an {{IEnumerable}} object, as shown in the code below.<source lang="csharp">// The SupplierProducts data view
[PXFilterable]
public SelectFrom&lt;SupplierProduct&gt;.
  InnerJoin&lt;Supplier&gt;.On&lt;Supplier.supplierID.IsEqual&lt;
    SupplierProduct.supplierID&gt;&gt;.
  OrderBy&lt;SupplierProduct.productID.Asc, SupplierProduct.supplierPrice.Asc, 
    SupplierProduct.lastPurchaseDate.Desc&gt;.
  View.ReadOnly SupplierProducts;

// The delegate for the SupplierProducts data view
protected virtual IEnumerable supplierProducts()
{
    // Implement the dynamic query
}</source>
The framework automatically adds the delegate by its name and invokes the method when the data view object is requested.
==Execution of a Data View Delegate==
A data view executes the delegate by using the following rules:[anchor|#ul_scc_mdh_nn]
*If a delegate is defined, invokes the delegate and then does the following:
**If the delegate returns {{null}}, executes the BQL command.
**If the delegate returns an object, reorders the result according to the {{OrderBy}} clause of the BQL command.
*If a delegate is not defined, executes the BQL command.

In the delegate, you can execute any queries to get the needed data records. The result set (<tt>PXResultset&lt;&gt;</tt> object) returned by the delegate must consist of objects of the same DACs and in the same order as the classes are specified in the data view type. Thus, in the example above, you can return a {{PXResult<SupplierProduct>}} object, but you cannot return a {{PXResult<Supplier>}} object. To return a {{Supplier}} object from the delegate, you have to return the {{PXResult<SupplierProduct, Supplier>}} object from the method.((({S:Warn}The result set returned by the data view is always sorted by the {{OrderBy}} clause specified in the type of the data view object. If you sort data records in a different way within the delegate, the result set will be reordered before it is returned by the data view.
)))
==Construction of a Result Set==
You can dynamically construct the result set that is returned by the data view. To construct a result set, you create an object of a generic <tt>PXResultset</tt> type and add <tt>PXResult</tt> objects to it.{br}

The following code creates a result set of <tt>PXResult</tt> objects than contain the joined data of three data access classes: {{Supplier}}, {{OrderLine}}, and {{Product}}.<source lang="csharp">// Create a PXResultset typed with needed DACs
PXResultset&lt;Supplier, OrderLine, Product&gt; res =
    new PXResultset&lt;Supplier, OrderLine, Product&gt;();

// Compose DAC objects, and set values for the needed fields
Supplier resultSupplier = new Supplier();
OrderLine resultLine = new OrderLine();
Product resultProd = new Product();

// Create a new PXResult object from DAC objects and add it to the result set
res.Add(new PXResult&lt;Supplier, OrderLine, Product&gt;(
                resultSupplier, resultLine, resultProd));</source>
A <tt>PXResultset</tt> collection implements the {{IEnumerable}} interface; you can return the collection in a data view delegate.<source lang="csharp">protected virtual IEnumerable productRecords()
{
    ...
    // In a data view delegate, you can return the entire result set
    return res;
}</source>]]></column>
			<column name="PlainText"><![CDATA[Data View Delegates By default, when a data view object is requested by the UI or you invoke the            Select()  method on the object, the system executes the query specified         in the data view type. However, you can define a dynamic query, which is an optional graph         method (called the  data view delegate ) that is executed when the data view is         requested. If no dynamic query is defined in the graph,  Acumatica Framework         executes the BQL statement from the data view type. You can use the data view delegate in the following cases: If the query is constructed dynamically at runtime by adding              Where<>  and  Join<>  clauses depending on some           condition, typically a filter If the query retrieves data fields that cannot be calculated declaratively by using           attributes—for instance, if you retrieve values that are aggregated by calculated           data fields If the result set has data records that aren't retrieved from the database and are           composed dynamically in code Definition of a Data View Delegate To define the delegate for a data view, define a method that has the same name as the data         view but uses a different case for the first letter. The delegate returns an            IEnumerable  object, as shown in the code below. // The SupplierProducts data view
[PXFilterable]
public SelectFrom<SupplierProduct>.
  InnerJoin<Supplier>.On<Supplier.supplierID.IsEqual<
    SupplierProduct.supplierID>>.
  OrderBy<SupplierProduct.productID.Asc, SupplierProduct.supplierPrice.Asc, 
    SupplierProduct.lastPurchaseDate.Desc>.
  View.ReadOnly SupplierProducts;

// The delegate for the SupplierProducts data view
protected virtual IEnumerable supplierProducts()
{
    // Implement the dynamic query
} The framework automatically adds the delegate by its name and invokes the method when the         data view object is requested. Execution of a Data View Delegate A data view executes the delegate by using the following rules: If a delegate is defined, invokes the delegate and then does the following: If the delegate returns  null , executes the BQL command. If the delegate returns an object, reorders the result according to the                  OrderBy  clause of the BQL command. If a delegate is not defined, executes the BQL command. In the delegate, you can execute any queries to get the needed data records. The result set           ( PXResultset<>  object) returned by the delegate must consist of         objects of the same DACs and in the same order as the classes are specified in the data view         type. Thus, in the example above, you can return a            PXResult<SupplierProduct>  object, but you cannot return a            PXResult<Supplier>  object. To return a  Supplier          object from the delegate, you have to return the  PXResult<SupplierProduct,           Supplier>  object from the method. The result set returned by the data view is always sorted by the            OrderBy  clause specified in the type of the data view object. If you sort         data records in a different way within the delegate, the result set will be reordered before         it is returned by the data view. Construction of a Result Set You can dynamically construct the result set that is returned by the data view. To         construct a result set, you create an object of a generic  PXResultset          type and add  PXResult  objects to it. The following code creates a result set of  PXResult  objects than contain         the joined data of three data access classes:  Supplier ,            OrderLine , and  Product . // Create a PXResultset typed with needed DACs
PXResultset<Supplier, OrderLine, Product> res =
    new PXResultset<Supplier, OrderLine, Product>();

// Compose DAC objects, and set values for the needed fields
Supplier resultSupplier = new Supplier();
OrderLine resultLine = new OrderLine();
Product resultProd = new Product();

// Create a new PXResult object from DAC objects and add it to the result set
res.Add(new PXResult<Supplier, OrderLine, Product>(
                resultSupplier, resultLine, resultProd)); A  PXResultset  collection implements the  IEnumerable          interface; you can return the collection in a data view delegate. protected virtual IEnumerable productRecords()
{
    ...
    // In a data view delegate, you can return the entire result set
    return res;
} ]]></column>
		</row>
		<row PageID="acbf0567-2330-4b64-880d-fbe467d80e17" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e4fd176d-3535-dbea-393c-f055cf36f84f" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The system executes a data query in the following stages, which are described in detail below:[anchor|#_b16b6757-7f73-438e-a8c2-3dc22c9da0fb]
*Stage 1: When a developer executes a BQL statement in code, Acumatica Framework configures a delayed query. 
*Stage 2: If a language-integrated query (LINQ) statement is appended to the BQL statement, Microsoft LINQ configures the expression tree, which includes the delayed query.
*Stage 3: When the developer casts the result of the query to a data access class (DAC) or an array of DACs, the system does the following:
**3a: If the result of the query contains the expression tree created by LINQ, the system configures the SQL query tree that corresponds to the LINQ expression tree, and executes the SQL query tree.
**3b: If the result of the query is created only by BQL, the system configures the SQL query tree for the delayed query and executes this query tree.

The whole process is illustrated in the following diagram.[anchor|#_9ca897b3-bb16-4521-a3bb-50eb48492c19][anchor|#_1c04a30b-0a6c-46f4-95b3-ba653aad68bc][image:StudioDeveloperGuide/Images/BqlQueryExecution.png|popup|Data query execution|450px]
==Configuration of a Delayed Query==
In code, you execute a business query language (BQL) statement in one of the following ways:[anchor|#_63d869d0-9116-45b9-ab58-289537eaf763]
*You declare a data view (a <tt>PXSelectBase</tt>-derived class) as a member in a graph, and you specify this data view as the data member of the ASPX page control. The system uses this data view for basic data manipulation (inserting a data record, updating a data record, and deleting a data record) and executes the data view by calling the <tt>Select()</tt> method.
*You use the {{static}}<tt>Select()</tt> method of a <tt>PXSelectBase</tt>-derived class with a graph object as the parameter.
*You dynamically instantiate a <tt>PXSelectBase</tt>-derived class in code and execute it by using its <tt>Select()</tt> method. (You provide the graph object as a parameter to the class constructor.)
*You instantiate a class derived from the <tt>BqlCommand</tt> class (such as a <tt>Select</tt> class in traditional BQL or <tt>FromSelect</tt> in fluent BQL), create a <tt>PXView</tt> object that uses this <tt>BqlCommand</tt> class, create a graph object, and call one of the view&rsquo;s <tt>Select()</tt> methods.
{br}

When the <tt>Select()</tt> method is executed, Acumatica Framework does the following: [anchor|#_de1559ab-16bb-41cb-b196-d391dd3c8eed]
#Configures a delayed query by creating a <tt>PXDelayedQuery</tt> instance. The <tt>PXDelayedQuery</tt> instance contains a reference to a <tt>PXView</tt> object, which contains references to <tt>PXGraph</tt> and the <tt>BqlCommand</tt> object to be executed.
#Caches the delayed query by using the <tt>PXContext.SetSlot</tt> method. (For details on the slots, see [HelpRoot_Dev_Platform\AD__con_Using_Slots_to_Cache_Data|Use of Slots to Cache Data Objects].)
#Returns a <tt>PXResultset&lt;T&gt;</tt> object whose type parameter is set to the DAC specified as the type parameter of the <tt>SelectFrom</tt> class (in fluent BQL) or as the first type parameter of the <tt>PXSelect</tt> class (in traditional BQL). This result set contains information about the delayed query.
{br}

You can iterate through the result set in a {{foreach}} loop, obtaining either DAC instances or <tt>PXResult&lt;&gt;</tt> instances. A <tt>PXResult&lt;&gt;</tt> instance represents a tuple of joined records from the result set. <tt>PXResult&lt;&gt;</tt> can be cast to any of the DAC types joined in the BQL statement. For more information on the use of the <tt>PXResultset&lt;T&gt;</tt> class, see [HelpRoot_Dev_Platform\AD__how_Process_Resultset|To Process the Result of the Execution of the BQL Statement].
==Configuration of the LINQ Expression Tree==
Because the <tt>PXResultset&lt;T&gt;</tt> class implements the <tt>IQueryable&lt;T&gt;</tt> interface, developers can modify <tt>PXResultset&lt;T&gt;</tt> by using LINQ. If the developer appends LINQ statements to a result set, Microsoft LINQ incorporates the result set as an instance of the <tt>SQLQueryable&lt;T&gt;</tt> class in the LINQ expression tree. The resulting expression tree is an instance of the <tt>SQLQueryable&lt;T&gt;</tt> class, which contains references to an instance of <tt>PXGraph</tt>, Microsoft LINQ expression tree, the base <tt>PXResultset&lt;T&gt;</tt>, and an instance of <tt>PX.Data.SQLTree.SQLQueryProvider</tt>.[anchor|#_5b6caf40-4e02-4ca8-be53-d6c8996a4794]
==Execution of the Delayed Query==
Once you cast the result of the execution of the <tt>Select()</tt> method to a DAC or an array of DACs, or if you iterate through the DACs in the result by using the {{foreach}} statement, the system performs the following steps:[anchor|#_8a76596f-6fac-4f22-97c5-8a88425f984f]
#The system calls the <tt>PXDelayedQuery.GetRows</tt> method for the delayed query of the result set. This method internally calls the <tt>PXView.Select()</tt> method for the data view referred to in the delayed query.
#If the select delegate is provided, inside the <tt>PXView.Select()</tt> method, the system invokes the select delegate by using the <tt>PXView.InvokeDelegate</tt> method and saves the result in the query cache of the graph. (The query cache stores the result set obtained by the execution of a specific BQL command.)
#Inside the <tt>PXView.Select()</tt> method, the system searches for the requested records in the query cache by using the <tt>PXView.LookupCache</tt> method. If no records are found, the system requests data from the database by using the <tt>PXView.GetResult</tt> method. For details on the retrieval of records from the database, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL]. 
#The system merges the records retrieved from the database or from the query cache with the modified records stored in <tt>PXCache</tt> by using the <tt>PXView.MergeCache</tt> method. For details about the merge, see [HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache].
#The system saves the result of the query in the query cache by using the <tt>PXView.StoreCached</tt> method.
#The system returns the result as a {{List<T>}} type.

==Execution of the LINQ Expression Tree==
Once you iterate over the LINQ expression tree, the system performs the following steps:[anchor|#_730d0ba1-a332-410a-bd14-614fbef710e0]
#The system calls the <tt>SQLQueryProvider.Execute()</tt> method, which builds the {{Remotion.Linq}} expression tree based on the Microsoft LINQ expression tree and calls <tt>Remotion.Linq.QueryModel.Execute()</tt> method with the <tt>PX.Data.SQLTree.SQLinqExecutor</tt> instance as a parameter.
#The system builds the SQL query tree from the <tt>Remotion.Linq.QueryModel</tt> by calling the <tt>SQLinqExecutor.ExecuteCollection&lt;T&gt;()</tt> method. In this method, the system executes the <tt>SQLinqQueryModelVisitor.VisitQueryModel()</tt> method, which does the following:
##Calls the <tt>SQLinqQueryModelVisitor.VisitMainFromClause()</tt> method, which builds the SQL query tree for the BQL statement that corresponds to the base <tt>PXResultset&lt;T&gt;</tt> of the query. This method internally calls the <tt>BqlCommand.GetQueryInternal</tt> method, which is described in [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL#_04b426bc-32b9-4925-8f60-cdad274abeb6|Translation of a BQL Command to an SQL Query Tree].
##Builds the SQL query tree for the rest of the {{Remotion.Linq}} expression tree by calling the methods of <tt>SQLinqQueryModelVisitor</tt> for particular clauses and the columns included in the result of the query. If the system cannot build the SQL query tree for particular elements of the {{Remotion.Linq}} expression tree, the system falls back to the execution of the delayed query for the base BQL statement. For details about the fallback, see [HelpRoot_Dev_Platform\AD__con_Fallback_to_LINQ2Objects|Fallback to the LINQ to Objects Mode].
#Within the <tt>SQLinqExecutor.ExecuteCollection&lt;T&gt;()</tt> method, the system uses the built SQL query tree to compose an <tt>SQLinqView</tt> object and calls the <tt>SQLinqView.Select()</tt> method. <tt>SQLinqView.Select()</tt> internally calls the <tt>PXView.Select()</tt> method, which executes the query as described in [[#_5b6caf40-4e02-4ca8-be53-d6c8996a4794|Execution of the Delayed Query]. For details about how the SQL query tree is translated to the SQL text that is passed to the database, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL#_7334dc34-5bb3-4884-9b58-20054413bd59|Translation of the SQL Query Tree to
        SQL Text].
#The system merges the records retrieved from the database with the modified records stored in <tt>PXCache</tt>. For details about the merge, see [HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache].
#The system returns the result as a {{List<T>}} type.

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL]
*[HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache]]]></column>
			<column name="PlainText"><![CDATA[Data Query Execution The system executes a data query in the following stages, which are described in detail         below: Stage 1: When a developer executes a BQL statement in code,  Acumatica Framework configures a delayed query.  Stage 2: If a language-integrated query (LINQ) statement is appended to the BQL           statement, Microsoft LINQ configures the expression tree, which includes the delayed           query. Stage 3: When the developer casts the result of the query to a data access class (DAC)           or an array of DACs, the system does the following: 3a: If the result of the query contains the expression tree created by LINQ, the               system configures the SQL query tree that corresponds to the LINQ expression tree, and               executes the SQL query tree. 3b: If the result of the query is created only by BQL, the system configures the SQL               query tree for the delayed query and executes this query tree. The whole process is illustrated in the following diagram. Data query execution Configuration of a Delayed Query In code, you execute a business query language (BQL) statement in one of the following      ways: You declare a data view (a  PXSelectBase -derived class) as a member in a             graph, and you specify this data view as the data member of the ASPX page control. The             system uses this data view for basic data manipulation (inserting a data record,             updating a data record, and deleting a data record) and executes the data view by             calling the  Select()  method. You use the  static Select()  method of a  PXSelectBase -derived class             with a graph object as the parameter. You dynamically instantiate a  PXSelectBase -derived class in code and             execute it by using its  Select()  method. (You provide the graph             object as a parameter to the class constructor.) You instantiate a class derived from the  BqlCommand  class (such as a                Select  class in traditional BQL or  FromSelect  in             fluent BQL), create a  PXView  object that uses this                BqlCommand  class, create a graph object, and call one of the view's                Select()  methods. When the  Select()  method is executed,  Acumatica Framework         does the following:  Configures a delayed query by creating a  PXDelayedQuery  instance.             The  PXDelayedQuery  instance contains a reference to a                PXView  object, which contains references to                PXGraph  and the  BqlCommand  object to be             executed. Caches the delayed query by using the  PXContext.SetSlot  method.             (For details on the slots, see  Use of Slots to Cache Data Objects.) Returns a  PXResultset<T>  object whose type parameter is set             to the DAC specified as the type parameter of the  SelectFrom  class             (in fluent BQL) or as the first type parameter of the  PXSelect  class             (in traditional BQL). This result set contains information about the delayed query. You can iterate through the result set in a  foreach  loop, obtaining either         DAC instances or  PXResult<>  instances. A            PXResult<>  instance represents a tuple of joined records from the         result set.  PXResult<>  can be cast to any of the DAC types joined         in the BQL statement. For more information on the use of the            PXResultset<T>  class, see  To Process the Result of the Execution of the BQL Statement. Configuration of the LINQ Expression Tree Because the  PXResultset<T>  class implements the            IQueryable<T>  interface, developers can modify            PXResultset<T>  by using LINQ. If the developer appends LINQ         statements to a result set, Microsoft LINQ incorporates the result set as an instance of the            SQLQueryable<T>  class in the LINQ expression tree. The resulting         expression tree is an instance of the  SQLQueryable<T>  class, which         contains references to an instance of  PXGraph , Microsoft LINQ expression         tree, the base  PXResultset<T> , and an instance of            PX.Data.SQLTree.SQLQueryProvider . Execution of the Delayed Query Once you cast the result of the execution of the  Select()  method to a         DAC or an array of DACs, or if you iterate through the DACs in the result by using the            foreach  statement, the system performs the following steps: The system calls the  PXDelayedQuery.GetRows  method for the delayed             query of the result set. This method internally calls the                PXView.Select()  method for the data view referred to in the delayed             query. If the select delegate is provided, inside the  PXView.Select()              method, the system invokes the select delegate by using the                PXView.InvokeDelegate  method and saves the result in the query             cache of the graph. (The query cache stores the result set obtained by the execution of             a specific BQL command.) Inside the  PXView.Select()  method, the system searches for the             requested records in the query cache by using the  PXView.LookupCache              method. If no records are found, the system requests data from the database by using the                PXView.GetResult  method. For details on the retrieval of records             from the database, see  Translation of a BQL Command to SQL.  The system merges the records retrieved from the database or from the query cache with             the modified records stored in  PXCache  by using the                PXView.MergeCache  method. For details about the merge, see  Merge of the Records with PXCache. The system saves the result of the query in the query cache by using the                PXView.StoreCached  method. The system returns the result as a  List<T>  type. Execution of the LINQ Expression Tree Once you iterate over the LINQ expression tree, the system performs the following steps: The system calls the  SQLQueryProvider.Execute()  method, which             builds the  Remotion.Linq  expression tree based on the Microsoft LINQ             expression tree and calls  Remotion.Linq.QueryModel.Execute()  method             with the  PX.Data.SQLTree.SQLinqExecutor  instance as a parameter. The system builds the SQL query tree from the                Remotion.Linq.QueryModel  by calling the                SQLinqExecutor.ExecuteCollection<T>()  method. In this method,             the system executes the  SQLinqQueryModelVisitor.VisitQueryModel()              method, which does the following: Calls the  SQLinqQueryModelVisitor.VisitMainFromClause()  method,                 which builds the SQL query tree for the BQL statement that corresponds to the base                    PXResultset<T>  of the query. This method internally calls                 the  BqlCommand.GetQueryInternal  method, which is described in                    Translation of a BQL Command to an SQL Query Tree. Builds the SQL query tree for the rest of the  Remotion.Linq                  expression tree by calling the methods of  SQLinqQueryModelVisitor                  for particular clauses and the columns included in the result of the query. If the                 system cannot build the SQL query tree for particular elements of the                    Remotion.Linq  expression tree, the system falls back to the                 execution of the delayed query for the base BQL statement. For details about the                 fallback, see  Fallback to the LINQ to Objects Mode. Within the  SQLinqExecutor.ExecuteCollection<T>()  method, the             system uses the built SQL query tree to compose an  SQLinqView  object             and calls the  SQLinqView.Select()  method.                SQLinqView.Select()  internally calls the                PXView.Select()  method, which executes the query as described in                Execution of the Delayed Query Execution of the Delayed Query. For details about how the SQL query tree is translated to the SQL             text that is passed to the database, see  Translation of the SQL Query Tree to
        SQL Text. The system merges the records retrieved from the database with the modified records             stored in  PXCache . For details about the merge, see  Merge of the Records with PXCache. The system returns the result as a  List<T>  type. ]]></column>
		</row>
		<row PageID="5bc68600-61ab-4a49-958c-da5d732b2ac2" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="b2a4f25e-7b2f-5473-4ce9-3c6eefdb8460" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When the system executes a delayed query and calls the <tt>PXView.GetResult</tt> method to retrieve the data from the database, the system converts the business query language (BQL) command (<tt>PX.Data.BqlCommand</tt>) to the SQL query tree (<tt>PX.Data.SQLTree.Query</tt>), applies the needed restrictions on the SQL query tree (such as company and branch restrictions), and then converts the SQL query tree to the text of the SQL command for the target database type. This process is described in detail in the following sections.{br}{TOC}[anchor|#_04b426bc-32b9-4925-8f60-cdad274abeb6]
==Translation of a BQL Command to an SQL Query Tree==
To request the SQL query tree of the command, the system recursively calls the following methods:[anchor|#_d692456b-ded5-4e14-8612-2f70ed86e140]
#<tt>PXView.GetResult</tt>
# <tt>PXGraph.ProviderSelect</tt>
# <tt>PXDatabaseProviderBase.Select</tt>
# <tt>BqlCommand.GetQuery</tt>
{br}

The <tt>BqlCommand.GetQuery</tt> method calls the <tt>BqlCommand.GetQueryInternal</tt> method, which uses other methods as follows to prepare the SQL query tree: {br}

[anchor|#_6ca0d24a-f7fd-4587-8927-270dfc3120e6]
#If the BQL command contains aggregation, the <tt>BqlCommand.AppendAggregatedFields</tt> method appends to a new <tt>Query</tt> instance the SQL expressions (<tt>PX.Data.SQL.SQLExpression</tt>) that correspond to the fields that are surrounded with appropriate aggregation functions. If the BQL command does not contain aggregation, the <tt>BqlCommand.AppendFields</tt> method appends to a new <tt>Query</tt> instance the SQL expressions that correspond to the fields to be selected. The fields to be selected are the DAC fields that subscribe to the <tt>OnCommandPreparing</tt> event and are not restricted by <tt>PXFieldScope</tt>. 
#For each {{Join}} clause, the <tt>IBqlJoin.AppendQuery</tt> method adds to the <tt>Query</tt> instance the <tt>Joiner</tt> instance that corresponds to the {{Join}} clause.
#:The <tt>IBqlJoin.AppendQuery</tt> method obtains the type of {{Join}} and, for all classes in the <tt>On</tt> clause that implement the <tt>IBqlCreator</tt> interface, successively executes the <tt>IBqlCreator.AppendExpression</tt> method, starting from the <tt>On</tt> class and then proceeding with enclosed classes, such as the <tt>Where</tt> classes and comparison classes. For the DAC fields (<tt>IBqlField</tt>-derived classes), the <tt>BqlCommand.GetSingleExpression</tt> method obtains the SQL expression.
#For all classes in the {{Where}} and {{GroupBy}} clauses that implement the <tt>IBqlCreator</tt> interface, the system successively executes the <tt>IBqlCreator.AppendExpression</tt> method, which appends to the <tt>Query</tt> instance the SQL expression that corresponds to the classes. For the DAC fields (<tt>IBqlField</tt>-derived classes), the <tt>BqlCommand.GetSingleExpression</tt> method obtains the SQL expression.
#The <tt>IBqlOrderBy.AppendQuery</tt> method adds to the <tt>Query</tt> instance the list of <tt>OrderSegment</tt> instances that corresponds to the {{OrderBy}} clause.
#:For each sorting class (a <tt>IBqlSortColumn</tt>-derived class) in the <tt>OrderBy</tt> clause, the <tt>IBqlSortColumn.AppendQuery</tt> method adds to the <tt>Query</tt> instance the <tt>OrderSegment</tt> instance that corresponds to the sorting column. For the DAC fields (<tt>IBqlField</tt>-derived classes), the <tt>BqlCommand.GetSingleExpression</tt> method obtains the SQL expression. If the original BQL statement does not specify ordering, the system adds to the <tt>Query</tt> instance sorting by the DAC key fields (in ascending order).
{br}

The following diagram shows the conversion of a BQL command to an SQL query tree.[anchor|#_acc0abf0-a2b9-4a82-9284-b425849e51bb][anchor|#_e32946e7-fd14-4c5b-86a1-7287c6a2f569][image:StudioDeveloperGuide/Images/BqlToSqlTreeQuery.png|popup|Conversion of a BQL command to an SQL query tree|450px]
==SQL Tree Expression of a Field==
To obtain the SQL tree expression of each field of the BQL command, the <tt>BqlCommand</tt> instance creates a <tt>PXCache</tt> instance that corresponds to the data access class (DAC) to which the field belongs. The <tt>PXCache</tt> instance generates the <tt>OnCommandPreparing</tt> event with the specified <tt>PXDBOperation</tt> type (which specifies the type of the database operation). The attribute assigned to the DAC field (that is, the attribute that implements the <tt>IPXCommandPreparingSubscriber</tt> interface) handles the event and returns the <tt>PX.Data.SQLTree.SQLExpression</tt> instance that corresponds to the field or to the BQL statement that is defined by the field attribute. (For example, the <tt>PXDBCalced</tt> and <tt>PXDBScalar</tt> attributes define BQL statements.){br}

The following diagram shows how <tt>BqlCommand</tt> obtains the SQL tree expression for the fields of a BQL command.[anchor|#_dfd9cbea-2bde-41b1-a0e2-3d771f9087aa][anchor|#_960e6fff-dcdc-479d-9698-2e70da40b2be][image:StudioDeveloperGuide/Images/BQL_RequestSqlExpression.png|popup|Retrieval of the SQL tree expression for the fields of a BQL command|450px][anchor|#_ff6436a7-d8a9-43c8-9201-d5ea9afbe2d5]
==Translation of a BQL Command with Parameters to an SQL Query Tree==
Before the system requests the SQL query tree of a BQL command, the <tt>PXView</tt> object retrieves the values of the parameters used in the query as follows:[anchor|#_6a1fd88a-b93d-4d66-823d-ae975c513191]
*For a field with <tt>FromCurrent</tt> appended (in fluent BQL) or specified in the <tt>Current</tt> parameter (in traditional BQL), the <tt>PXView</tt> object retrieves the field value from the <tt>Current</tt> object of the <tt>PXCache</tt> object. If the current field value is {{null}}, the <tt>PXView</tt> object triggers the <tt>FieldDefaulting</tt> event handlers and retrieves the default value from the <tt>PXDefault</tt> attribute value (if any). 
*:((({S:Warn}The default value is not retrieved if <tt>FromCurrent.NoDefault</tt> is appended to the field (in fluent BQL) or if the <tt>Current2</tt> parameter is used (in traditional BQL).
)))
*For a field with <tt>AsOptional</tt> appended (in fluent BQL) or specified in the <tt>Optional</tt> parameter, if the explicit field value is specified, the <tt>PXView</tt> object triggers the <tt>FieldUpdating</tt> event, whose handlers can transform the external presentation of the field value to an internal value (for example, transform {{ProductCD}} to {{ProductID}}). If the field value is not specified, the <tt>PXView</tt> object retrieves the field value from the <tt>Current</tt> object of the <tt>PXCache</tt> object. If the current field value is {{null}}, the <tt>PXView</tt> object triggers the <tt>FieldDefaulting</tt> event and retrieves the default value from the <tt>PXDefault</tt> attribute value (if any).
*:((({S:Warn}The default value is not retrieved if <tt>AsOptional.NoDefault</tt> is appended to the field (in fluent BQL) or if the <tt>Optional2</tt> parameter is used.
)))
{br}

When <tt>BqlCommand</tt> creates the SQL query tree that corresponds to the BQL command, <tt>IBqlCreator.AppendExpression</tt> (which is implemented by the <tt>ParameterBase&lt;Field&gt;</tt> class) includes the parameters in the SQL query tree. After <tt>BqlCommand</tt> has created the SQL query tree that corresponds to the BQL command, the system inserts into the SQL query tree the actual values of the parameters retrieved by <tt>PXView</tt>. [anchor|#_7334dc34-5bb3-4884-9b58-20054413bd59]
==Translation of the SQL Query Tree to SQL Text==A <tt>PXGraph</tt> instance stores information about the target database type in its <tt>SqlDialect</tt> property. <tt>SQLTree.Query</tt> has the <tt>Connection</tt> property, which is responsible for the conversion of the SQL query tree to the SQL text in the format of the target database. To convert the SQL query tree to text, the system does the following:[anchor|#_1e5d0daa-4f7d-4176-aee3-223f767a4f55]
#Calls the <tt>SQLDialect.GetConnection</tt> method of the graph instance to retrieve the needed <tt>SQLTree.Connection</tt>.
#Passes this <tt>Connection</tt> instance to the <tt>SQLTree.Query.SQLQuery</tt> method, which converts the SQL query tree to the text for Microsoft SQL or MySQL, depending on the passed <tt>Connection</tt>.

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]]]></column>
			<column name="PlainText"><![CDATA[Translation of a BQL Command to SQL When the system executes a delayed query and calls the  PXView.GetResult          method to retrieve the data from the database, the system converts the business query         language (BQL) command ( PX.Data.BqlCommand ) to the SQL query tree           ( PX.Data.SQLTree.Query ), applies the needed restrictions on the SQL         query tree (such as company and branch restrictions), and then converts the SQL query tree         to the text of the SQL command for the target database type. This process is described in         detail in the following sections. Translation of a BQL Command to an SQL Query Tree To request the SQL query tree of the command, the system recursively calls the following           methods: PXView.GetResult PXGraph.ProviderSelect PXDatabaseProviderBase.Select BqlCommand.GetQuery The  BqlCommand.GetQuery  method calls the            BqlCommand.GetQueryInternal  method, which uses other methods as follows         to prepare the SQL query tree:  If the BQL command contains aggregation, the                BqlCommand.AppendAggregatedFields  method appends to a new                Query  instance the SQL  expressions               ( PX.Data.SQL.SQLExpression ) that correspond to the fields that are             surrounded with appropriate aggregation functions. If the BQL command does not contain             aggregation, the  BqlCommand.AppendFields  method appends to a new                Query  instance the SQL  expressions that correspond to the fields             to be selected. The fields to be selected are the DAC fields that subscribe to the                OnCommandPreparing  event and are not restricted by                PXFieldScope .  For each  Join  clause, the  IBqlJoin.AppendQuery              method adds to the  Query  instance the  Joiner              instance that corresponds to the  Join  clause. The                  IBqlJoin.AppendQuery  method obtains the type of                  Join  and, for all classes in the  On  clause that               implement the  IBqlCreator  interface, successively executes the                  IBqlCreator.AppendExpression  method, starting from the                  On  class and then proceeding with enclosed classes, such as the                  Where  classes and comparison classes. For the DAC fields                 ( IBqlField -derived classes), the                  BqlCommand.GetSingleExpression  method obtains the SQL               expression. For all classes in the  Where  and  GroupBy  clauses             that implement the  IBqlCreator  interface, the system successively             executes the  IBqlCreator.AppendExpression  method, which appends to             the  Query  instance the SQL  expression that corresponds to the             classes. For the DAC fields ( IBqlField -derived classes), the                BqlCommand.GetSingleExpression  method obtains the SQL             expression. The  IBqlOrderBy.AppendQuery  method adds to the                Query  instance the list of  OrderSegment              instances that corresponds to the  OrderBy  clause. For each sorting               class (a  IBqlSortColumn -derived class) in the                  OrderBy  clause, the  IBqlSortColumn.AppendQuery                method adds to the  Query  instance the                  OrderSegment  instance that corresponds to the sorting column. For               the DAC fields ( IBqlField -derived classes), the                  BqlCommand.GetSingleExpression  method obtains the SQL expression.               If the original BQL statement does not specify ordering, the system adds to the                  Query  instance sorting by the DAC key fields (in ascending               order). The following diagram shows the conversion of a BQL command to an SQL query tree. Conversion of a BQL command to an SQL query tree SQL Tree Expression of a Field To obtain the SQL tree expression of each field of the BQL command, the            BqlCommand  instance creates a  PXCache  instance that         corresponds to the data access class (DAC) to which the field belongs. The            PXCache  instance generates the  OnCommandPreparing          event with the specified  PXDBOperation  type (which specifies the type of         the database operation). The attribute assigned to the DAC field (that is, the attribute         that implements the  IPXCommandPreparingSubscriber  interface) handles the         event and returns the  PX.Data.SQLTree.SQLExpression  instance that         corresponds to the field or to the BQL statement that is defined by the field attribute.         (For example, the  PXDBCalced  and  PXDBScalar  attributes         define BQL statements.) The following diagram shows how  BqlCommand  obtains the SQL tree         expression for the fields of a BQL command. Retrieval of the SQL tree expression for the fields of a BQL command Translation of a BQL Command with Parameters to an SQL Query Tree Before the system requests the SQL query tree of a BQL command, the            PXView  object retrieves the values of the parameters used in the query         as follows: For a field with  FromCurrent  appended (in fluent BQL) or specified             in the  Current  parameter (in traditional BQL), the                PXView  object retrieves the field value from the                Current  object of the  PXCache  object. If the             current field value is  null , the  PXView  object             triggers the  FieldDefaulting  event handlers and retrieves the default             value from the  PXDefault  attribute value (if any).  The default               value is not retrieved if  FromCurrent.NoDefault  is appended to the               field (in fluent BQL) or if the  Current2  parameter is used (in               traditional BQL). For a field with  AsOptional  appended (in fluent BQL) or specified             in the  Optional  parameter, if the explicit field value is specified,             the  PXView  object triggers the  FieldUpdating              event, whose handlers can transform the external presentation of the field value to an             internal value (for example, transform  ProductCD  to                ProductID ). If the field value is not specified, the                PXView  object retrieves the field value from the                Current  object of the  PXCache  object. If the             current field value is  null , the  PXView  object             triggers the  FieldDefaulting  event and retrieves the default value             from the  PXDefault  attribute value (if any). The default value               is not retrieved if  AsOptional.NoDefault  is appended to the field               (in fluent BQL) or if the  Optional2  parameter is used. When  BqlCommand  creates the SQL query tree that corresponds to the BQL         command,  IBqlCreator.AppendExpression  (which is implemented by the            ParameterBase<Field>  class) includes the parameters in the SQL query         tree. After  BqlCommand  has created the SQL query tree that corresponds to         the BQL command, the system inserts into the SQL query tree the actual values of the         parameters retrieved by  PXView .  Translation of the SQL Query Tree to         SQL Text A  PXGraph  instance stores information about the target       database type in its  SqlDialect  property.  SQLTree.Query        has the  Connection  property, which is responsible for the conversion of the       SQL query tree to the SQL text in the format of the target database. To convert the SQL query       tree to text, the system does the following: Calls the  SQLDialect.GetConnection  method of the graph instance to           retrieve the needed  SQLTree.Connection . Passes this  Connection  instance to the              SQLTree.Query.SQLQuery  method, which converts the SQL query tree to           the text for Microsoft SQL or MySQL, depending on the passed            Connection . ]]></column>
		</row>
		<row PageID="0ff0b223-66ff-4b55-af97-fe88580ec6e5" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="55bb37d7-6e0a-434d-2303-9e44f395683a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
For the queries defined with business query language (BQL) or with BQL and LINQ, the system merges the records retrieved from the database with the modified records stored in <tt>PXCache</tt> as follows:{br}

[anchor|#_6eda37be-fde0-4a41-998b-c92941627892]
#If the query is read-only, the result set is not merged with any <tt>PXCache</tt> object. The system returns the data records as they are currently stored in the database.
#:((({S:Warn}A query is read-only if the <tt>IsReadOnly</tt> property of the underlying <tt>PXView</tt> object is {{true}}. For example, the traditional BQL statements that use aggregation or are based on one of the <tt>PXSelectReadonly</tt> classes are read-only. The fluent BQL statements that have <tt>.ReadOnly</tt> appended are read-only.
)))
#If the query is not read-only and contains filtering by data access class (DAC) fields by using LINQ (that is, only the values in specific columns of the database tables are returned in the results of the query), no merge with any <tt>PXCache</tt> object is performed. 
#If the query is not read-only, does not contain filtering of DAC fields by using LINQ, and does not contain joins, the result set is merged with the contents of the appropriate <tt>PXCache</tt> object, and the system returns the result set updated with the modifications stored in <tt>PXCache</tt>.
#If the query is not read-only, does not contain filtering by DAC fields by using LINQ, and joins data from multiple tables, the result set is merged with only the <tt>PXCache</tt> object that corresponds to the first table of the BQL statement. The <tt>PXResultset&lt;&gt;</tt> object, which represents the result set, contains objects of the generic <tt>PXResult&lt;&gt;</tt> type. This type can be cast to the data access classes (DACs) that represent the joined tables. The instance of the primary DAC to which <tt>PXResult&lt;&gt;</tt> is cast contains the records from the database that are updated with the modifications stored in <tt>PXCache</tt>. Casting <tt>PXResult&lt;&gt;</tt> to a joined DAC returns the instance that contains values from the database and has no relation with the <tt>PXCache</tt> instances of the corresponding DAC types.
{br}

The following diagram illustrates the database records being merged with <tt>PXCache</tt>.[anchor|#_4f4366d6-763c-4ef8-8d14-c4edcd1e6108][anchor|#_08b99e51-d44a-403f-88ce-d51db37bba2c][image:StudioDeveloperGuide/Images/BQL_MergeWithDB.png|popup|Merge with <tt>PXCache</tt>|450px]
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]]]></column>
			<column name="PlainText"><![CDATA[Merge of the Records with PXCache For the queries defined with business query language (BQL) or with BQL and LINQ, the system         merges the records retrieved from the database with the modified records stored in            PXCache  as follows: If the query is read-only, the result set is not merged with any                PXCache  object. The system returns the data records as they are             currently stored in the database. A query is read-only if the                  IsReadOnly  property of the underlying  PXView                object is  true . For example, the traditional BQL statements that use               aggregation or are based on one of the  PXSelectReadonly  classes are               read-only. The fluent BQL statements that have  .ReadOnly  appended               are read-only. If the query is not read-only and contains filtering by data access class (DAC) fields             by using LINQ (that is, only the values in specific columns of the database tables are             returned in the results of the query), no merge with any  PXCache              object is performed.  If the query is not read-only, does not contain filtering of DAC fields by using LINQ,             and does not contain joins, the result set is merged with the contents of the             appropriate  PXCache  object, and the system returns the result set             updated with the modifications stored in  PXCache . If the query is not read-only, does not contain filtering by DAC fields by using LINQ,             and joins data from multiple tables, the result set is merged with only the                PXCache  object that corresponds to the first table of the BQL             statement. The  PXResultset<>  object, which represents the             result set, contains objects of the generic  PXResult<>  type.             This type can be cast to the data access classes (DACs) that represent the joined             tables. The instance of the primary DAC to which  PXResult<>  is             cast contains the records from the database that are updated with the modifications             stored in  PXCache . Casting  PXResult<>  to a             joined DAC returns the instance that contains values from the database and has no             relation with the  PXCache  instances of the corresponding DAC             types. The following diagram illustrates the database records being merged with            PXCache . Merge with  PXCache ]]></column>
		</row>
		<row PageID="b5126e1e-70d9-408d-bcf9-e625a38a052e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ae88f49b-a073-8388-eeb5-86c4e7cd2e3c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can learn the main differences between the queries defined with fluent business query language (BQL), traditional BQL, and language-integrated query (LINQ).[anchor|#_ecd2097d-c0da-40cf-9f3f-dd49b282272b]
===Comparison of Fluent BQL, Traditional BQL, and LINQ===
{| class="checklist" | width="100%" 
|- 
!width="40%" ! Characteristic
!width="20%" ! Fluent BQL
!width="20%" ! Traditional BQL
!width="20%" ! LINQ
|- 
| The queries can be used to define data views in graphs.
| Yes
| Yes
| No
|- 
| The queries can be defined in code.
| Yes
| Yes
| Yes
|- 
| The queries can be defined in DAC field attributes.
| Yes
| Yes
| No
|- 
| DACs are used to define database tables in the queries.
| Yes
| Yes
| Yes
|- 
| The queries can be used for dynamic query building.
| Yes
| Yes
| Yes
|- 
| The queries can be parsed and modified by the direct use of reflection—that is, by {{Type.GetGenericArguments()}}.
| No
| Yes
| No
|- 
| Clauses (such as <tt>Join</tt>, <tt>Where</tt>, <tt>Aggregate</tt>, <tt>OrderBy</tt>, and <tt>On</tt>) can be used separately of the query.
| No, but you can pass fluent BQL expressions to traditional BQL clauses
| Yes
| No
|- 
| The query language includes numbered classes (such as <tt>Select2</tt> and <tt>Select6</tt>).
| No
| Yes
| No
|- 
| Each subsequent element of the query is passed as a generic parameter of the previous one.
| No
| Yes
| No
|- 
| To create a query, a developer needs to select a suitable command overload.
| No
| Yes
| No
|- 
| IntelliSense can offer continuations that are relevant for the current query state.
| Yes
| No
| Yes
|- 
| The queries use strongly typed expressions, which makes compile-time type checks possible.
| Yes
| No
| Yes
|- 
| The queries can contain explicit brackets in conditions.
| Yes
| No; the <tt>Where</tt> clause can be used instead
| Yes
|- 
| You can specify particular columns of the tables to be selected.
| Yes; you have to use <tt>PXFieldScope</tt>
| Yes; you have to use <tt>PXFieldScope</tt>
| Yes
|- 
| The query is not executed until it is iterated over.
| Yes
| Yes
| Yes
|}
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents]
*[HelpRoot_Dev_Platform\AD__mng_Fluent_BQL|Creating Fluent BQL Queries]
*[HelpRoot_Dev_Platform\AD__mng_Traditional_BQL|Creating Traditional BQL Queries]]]></column>
			<column name="PlainText"><![CDATA[Comparison of Fluent BQL, Traditional BQL, and LINQ In this topic, you can learn the main differences between the queries defined with fluent     business query language (BQL), traditional BQL, and language-integrated query (LINQ). Comparison of Fluent BQL, Traditional BQL, and LINQ Characteristic Fluent BQL Traditional BQL LINQ The queries can be used to define data views in graphs. Yes Yes No The queries can be defined in code. Yes Yes Yes The queries can be defined in DAC field attributes. Yes Yes No DACs are used to define database tables in the queries. Yes Yes Yes The queries can be used for dynamic query building. Yes Yes Yes The queries can be parsed and modified by the direct use of reflection—that is, by            Type.GetGenericArguments() . No Yes No Clauses (such as  Join ,  Where ,            Aggregate ,  OrderBy , and  On ) can          be used separately of the query. No, but you can pass fluent BQL expressions to traditional BQL clauses Yes No The query language includes numbered classes (such as  Select2  and            Select6 ). No Yes No Each subsequent element of the query is passed as a generic parameter of the previous          one. No Yes No To create a query, a developer needs to select a suitable command overload. No Yes No IntelliSense can offer continuations that are relevant for the current query          state. Yes No Yes The queries use strongly typed expressions, which makes compile-time type checks          possible. Yes No Yes The queries can contain explicit brackets in conditions. Yes No; the  Where  clause can be used instead Yes You can specify particular columns of the tables to be selected. Yes; you have to use  PXFieldScope Yes; you have to use  PXFieldScope Yes The query is not executed until it is iterated over. Yes Yes Yes ]]></column>
		</row>
		<row PageID="67456943-7705-4522-9e0a-967251cc841c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="dadf9326-b3e8-62a1-8f8f-f6270df03679" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The fluent business query language (BQL) library defines the equivalents of traditional BQL classes listed in the following tables.{br}

{br}{TOC}
==Data View Declarations==((({S:Warn}All data views that contain aggregating are read-only.
)))[anchor|#_4bb6d246-b083-44b0-a826-b60d00f39575]
{| class="checklist" | width="100%" 
|- 
!width="66%" ! Fluent BQL
!width="33%" ! Traditional BQL
|- 
| <tt>SelectFrom&lt;&gt;.View</tt>
|  <tt>PXSelect&lt;&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly&lt;&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.OrderBy&lt;&gt;.View</tt>
|  <tt>PXSelectOrderBy&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly3&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.AggregateTo&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectGroupBy&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectGroupByOrderBy&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.View</tt>
|  <tt>PXSelect&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.OrderBy&lt;&gt;.View</tt>
|  <tt>PXSelect&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.AggregateTo&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectGroupBy&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectGroupBy&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.View</tt>
|  <tt>PXSelectJoin&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly2&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.OrderBy&lt;&gt;.View</tt>
|  <tt>PXSelectJoinOrderBy&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly3&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.AggregateTo&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectJoinGroupBy&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectGroupByOrderBy&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.View</tt>
|  <tt>PXSelectJoin&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly2&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.OrderBy&lt;&gt;.View</tt>
|  <tt>PXSelectJoin&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly2&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.AggregateTo&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectJoinGroupBy&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectJoinGroupBy&lt;,,,,&gt;</tt>
|}
==Select Commands==[anchor|#_6254712c-00c6-4fe4-8dec-8a5d923fc29f]
{| class="checklist" | width="100%" 
|- 
!width="66%" ! Fluent BQL
!width="33%" ! Traditional BQL
|- 
| <tt>SelectFrom&lt;&gt;</tt>
|  <tt>Select&lt;&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.OrderBy&lt;&gt;</tt>
|  <tt>Select3&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.AggregateTo&lt;&gt;</tt>
|  <tt>Select4&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;</tt>
|  <tt>Select6&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;</tt>
|  <tt>Select&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.OrderBy&lt;&gt;</tt>
|  <tt>Select&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.AggregateTo&lt;&gt;</tt>
|  <tt>Select4&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;</tt>
|  <tt>Select4&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;</tt>
|  <tt>Select2&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.OrderBy&lt;&gt;</tt>
|  <tt>Select3&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.AggregateTo&lt;&gt;</tt>
|  <tt>Select5&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;</tt>
|  <tt>Select6&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;</tt>
|  <tt>Select2&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.OrderBy&lt;&gt;</tt>
|  <tt>Select2&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.AggregateTo&lt;&gt;</tt>
|  <tt>Select5&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;</tt>
|  <tt>Select5&lt;,,,,&gt;</tt>
|}
==Search Commands==[anchor|#_95502182-e7ad-4e71-8ebe-cc946d58f211]
{| class="checklist" | width="100%" 
|- 
!width="66%" ! Fluent BQL
!width="33%" ! Traditional BQL
|- 
| <tt>SelectFrom&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search&lt;&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search3&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.AggregateTo&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search4&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search6&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.AggregateTo&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search4&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search4&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.SearchFor&lt;&gt;</tt>
|  <tt>Search2&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search3&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.AggregateTo&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search5&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search6&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search2&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search2&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.AggregateTo&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search5&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search5&lt;,,,,&gt;</tt>
|}
==Join Clauses==[anchor|#_81971327-222f-4386-a0b4-c9d14304ad54]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>.InnerJoin&lt;Table&gt;.On&lt;&gt;</tt>
|  <tt>InnerJoin&lt;Table,On&gt;</tt>
|- 
|  <tt>.InnerJoin&lt;Table&gt;.On&lt;&gt;.NextJoin</tt>
|  <tt>InnerJoin&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.InnerJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly</tt>
|  <tt>InnerJoinSingleTable&lt;Table,On&gt;</tt>
|- 
|  <tt>.InnerJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly.NextJoin</tt>
|  <tt>InnerJoinSingleTable&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.LeftJoin&lt;Table&gt;.On&lt;&gt;</tt>
|  <tt>LeftJoin&lt;Table,On&gt;</tt>
|- 
|  <tt>.LeftJoin&lt;Table&gt;.On&lt;&gt;.NextJoin</tt>
|  <tt>LeftJoin&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.LeftJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly</tt>
|  <tt>LeftJoinSingleTable&lt;Table,On&gt;</tt>
|- 
|  <tt>.LeftJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly.NextJoin</tt>
|  <tt>LeftJoinSingleTable&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.RightJoin&lt;Table&gt;.On&lt;&gt;</tt>
|  <tt>RightJoin&lt;Table,On&gt;</tt>
|- 
|  <tt>.RightJoin&lt;Table&gt;.On&lt;&gt;.NextJoin</tt>
|  <tt>RightJoin&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.RightJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly</tt>
|  <tt>RightJoinSingleTable&lt;Table,On&gt;</tt>
|- 
|  <tt>.RightJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly.NextJoin</tt>
|  <tt>RightJoinSingleTable&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.FullJoin&lt;Table&gt;.On&lt;&gt;</tt>
|  <tt>FullJoin&lt;Table,On&gt;</tt>
|- 
|  <tt>.FullJoin&lt;Table&gt;.On&lt;&gt;.NextJoin</tt>
|  <tt>FullJoin&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.FullJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly</tt>
|  <tt>FullJoinSingleTable&lt;Table,On&gt;</tt>
|- 
|  <tt>.FullJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly.NextJoin</tt>
|  <tt>FullJoinSingleTable&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.CrossJoin&lt;Table&gt;</tt>
|  <tt>CrossJoin&lt;Table&gt;</tt>
|- 
|  <tt>.CrossJoin&lt;Table&gt;.NextJoin</tt>
|  <tt>CrossJoin&lt;Table,NextJoin&gt;</tt>
|- 
|  <tt>.CrossJoin&lt;Table&gt;.SingleTableOnly</tt>
|  <tt>CrossJoinSingleTable&lt;Table&gt;</tt>
|- 
|  <tt>.CrossJoin&lt;Table&gt;.SingleTableOnly.NextJoin</tt>
|  <tt>CrossJoinSingleTable&lt;Table,NextJoin&gt;</tt>
|}
==Where Clause==[anchor|#_033169a9-03e8-490c-b557-0b6110a6f0c0]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>.Where&lt;UnaryOperator&gt;</tt>
|  <tt>Where&lt;UnaryOperator&gt;</tt>
|- 
|  <tt>.Where&lt;Operand.Comparison&gt;</tt>
|  <tt>Where&lt;Operand,Comparison&gt;</tt>
|- 
|  <tt>.Where&lt;Operand.Comparison.NextOperator&gt;</tt>
|  <tt>Where&lt;Operand,Comparison,NextOperator&gt;</tt>
|- 
|  <tt>.Where&lt;UnaryOperator.NextOperator&gt;</tt>
|  <tt>Where2&lt;UnaryOperator,NextOperator&gt;</tt>
|}
==Aggregate Clause==[anchor|#_8a9ba045-c388-4181-b8e9-d2698bda79f7]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>.AggregateTo&lt;Function&gt;</tt>
|  <tt>Aggregate&lt;Function&gt;</tt>
|- 
|  <tt>.AggregateTo&lt;TFunctions&gt;.THaving</tt>
|  <tt>Aggregate&lt;TFunctions,THaving&gt;</tt>
|- 
|  <tt>.Having&lt;TCondition&gt;</tt>
|  <tt>Having&lt;TCondition&gt;</tt>
|- 
|  <tt>GroupBy&lt;Field&gt;</tt>
|  <tt>GroupBy&lt;Field&gt;</tt>
|- 
|  <tt>GroupBy&lt;Field&gt;, NextAggregate</tt>
|  <tt>GroupBy&lt;Field,NextAggregate&gt;</tt>
|- 
|  <tt>Max&lt;Field&gt;</tt>
|  <tt>Max&lt;Field&gt;</tt>
|- 
|  <tt>Max&lt;Field&gt;, NextAggregate</tt>
|  <tt>Max&lt;Field,NextAggregate&gt;</tt>
|- 
|  <tt>Min&lt;Field&gt;</tt>
|  <tt>Min&lt;Field&gt;</tt>
|- 
|  <tt>Min&lt;Field&gt;, NextAggregate</tt>
|  <tt>Min&lt;Field,NextAggregate&gt;</tt>
|- 
|  <tt>Sum&lt;Field&gt;</tt>
|  <tt>Sum&lt;Field&gt;</tt>
|- 
|  <tt>Sum&lt;Field&gt;, NextAggregate</tt>
|  <tt>Sum&lt;Field,NextAggregate&gt;</tt>
|- 
|  <tt>Avg&lt;Field&gt;</tt>
|  <tt>Avg&lt;Field&gt;</tt>
|- 
|  <tt>Avg&lt;Field&gt;, NextAggregate</tt>
|  <tt>Avg&lt;Field,NextAggregate&gt;</tt>
|- 
|  <tt>Count</tt>
|  <tt>Count</tt>
|- 
|  <tt>Count&lt;Field&gt;</tt>
|  <tt>Count&lt;Field&gt;</tt>
|}
==OrderBy Clause==[anchor|#_60f4a753-c02b-403e-be39-14378aa7a8f0]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>.OrderBy&lt;List&gt;</tt>
|  <tt>OrderBy&lt;List&gt;</tt>
|- 
|  <tt>Field.Asc</tt>
|  <tt>Asc&lt;Field&gt;</tt>
|- 
|  <tt>Field.Asc, NextSort</tt>
|  <tt>Asc&lt;Field,NextSort&gt;</tt>
|- 
|  <tt>Field.Desc</tt>
|  <tt>Desc&lt;Field&gt;</tt>
|- 
|  <tt>Field.Desc, NextSort</tt>
|  <tt>Desc&lt;Field,NextSort&gt;</tt>
|}
==Parameters==[anchor|#_26d4df1b-49a8-4ccf-9969-e88ffca8ba5d]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>Field.FromCurrent</tt>
|  <tt>Current&lt;Field&gt;</tt>
|- 
|  <tt>Field.FromCurrent.NoDefault</tt>
|  <tt>Current2&lt;Field&gt;</tt>
|- 
|  <tt>Field.AsOptional</tt>
|  <tt>Optional&lt;Field&gt;</tt>
|- 
|  <tt>Field.AsOptional.NoDefault</tt>
|  <tt>Optional2&lt;Field&gt;</tt>
|- 
|  <tt>@P.AsBool</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{bool}} type
|- 
| <tt>@P.AsByte</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{byte}} type
|- 
| <tt>@P.AsShort</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{short}} type
|- 
| <tt>@P.AsInt</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{int}} type
|- 
| <tt>@P.AsLong</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{long}} type
|- 
| <tt>@P.AsFloat</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{float}} type
|- 
| <tt>@P.AsDouble</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{double}} type
|- 
| <tt>@P.AsDecimal</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{decimal}} type
|- 
| <tt>@P.AsGuid</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{Guid}} type
|- 
| <tt>@P.AsDateTime</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{DateTime}} type
|- 
| <tt>@P.AsString</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{string}} type
|- 
| <tt>Argument.AsBool</tt>
|  <tt>Argument&lt;bool?&gt;</tt>
|- 
|  <tt>Argument.AsByte</tt>
|  <tt>Argument&lt;byte?&gt;</tt>
|- 
|  <tt>Argument.AsShort</tt>
|  <tt>Argument&lt;short?&gt;</tt>
|- 
|  <tt>Argument.AsInt</tt>
|  <tt>Argument&lt;int?&gt;</tt>
|- 
|  <tt>Argument.AsLong</tt>
|  <tt>Argument&lt;long?&gt;</tt>
|- 
|  <tt>Argument.AsFloat</tt>
|  <tt>Argument&lt;float?&gt;</tt>
|- 
|  <tt>Argument.AsDouble</tt>
|  <tt>Argument&lt;double?&gt;</tt>
|- 
|  <tt>Argument.AsDecimal</tt>
|  <tt>Argument&lt;decimal?&gt;</tt>
|- 
|  <tt>Argument.AsGuid</tt>
|  <tt>Argument&lt;Guid?&gt;</tt>
|- 
|  <tt>Argument.AsDateTime</tt>
|  <tt>Argument&lt;DateTime?&gt;</tt>
|- 
|  <tt>Argument.AsString</tt>
|  <tt>Argument&lt;string&gt;</tt>
|}
==Logical Operators and Brackets==[anchor|#_0ccc8bcc-ab61-4fbd-a31e-883e79b7d474]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>And&lt;UnaryOperator&gt;</tt>
|  <tt>And&lt;UnaryOperator&gt;</tt>
|- 
|  <tt>And&lt;Operand.Comparison&gt;</tt>
|  <tt>And&lt;Operand,Comparison&gt;</tt>
|- 
|  <tt>And&lt;Operand.Comparison&gt;.NextOperator</tt>
|  <tt>And&lt;Operand,Comparison,NextOperator&gt;</tt>
|- 
|  <tt>And&lt;UnaryOperator.NextOperator&gt;</tt>
|  <tt>And2&lt;UnaryOperator,NextOperator&gt;</tt>
|- 
|  <tt>Or&lt;UnaryOperator&gt;</tt>
|  <tt>Or&lt;UnaryOperator&gt;</tt>
|- 
|  <tt>Or&lt;Operand.Comparison&gt;</tt>
|  <tt>Or&lt;Operand,Comparison&gt;</tt>
|- 
|  <tt>Or&lt;Operand.Comparison&gt;.NextOperator</tt>
|  <tt>Or&lt;Operand,Comparison,NextOperator&gt;</tt>
|- 
|  <tt>Or&lt;UnaryOperator.NextOperator&gt;</tt>
|  <tt>Or2&lt;UnaryOperator,NextOperator&gt;</tt>
|- 
|  <tt>Not&lt;UnaryOperator&gt;</tt>
|  <tt>Not&lt;UnaryOperator&gt;</tt>
|- 
|  <tt>Not&lt;Operand.Comparison&gt;</tt>
|  <tt>Not&lt;Operand,Comparison&gt;</tt>
|- 
|  <tt>Not&lt;Operand.Comparison.NextOperator&gt;</tt>
|  <tt>Not&lt;Operand,Comparison,NextOperator&gt;</tt>
|- 
|  <tt>Not&lt;UnaryOperator.NextOperator&gt;</tt>
|  <tt>Not2&lt;UnaryOperator,NextOperator&gt;</tt>
|- 
|  <tt>Brackets&lt;UnaryOperator&gt;</tt>
|  <tt>Where&lt;UnaryOperator&gt;</tt>
|- 
|  <tt>Brackets&lt;Operand.Comparison&gt;</tt>
|  <tt>Where&lt;Operand,Comparison&gt;</tt>
|- 
|  <tt>Brackets&lt;Operand.Comparison.NextOperator&gt;</tt>
|  <tt>Where&lt;Operand,Comparison,NextOperator&gt;</tt>
|- 
|  <tt>Brackets&lt;UnaryOperator.NextOperator&gt;</tt>
|  <tt>Where2&lt;UnaryOperator,NextOperator&gt;</tt>
|}
==Comparisons==[anchor|#_df369913-4a3f-465a-8dde-83319813feb5]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>Table.field.IsEqual&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, Equal&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNotEqual&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, NotEqual&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsGreaterEqual&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, GreaterEqual&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsGreater&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, Greater&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsLessEqual&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, LessEqual&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsLess&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, Less&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsLike&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, Like&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNotLike&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, NotLike&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsBetween&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, Between&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNotBetween&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, NotBetween&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNull</tt>
|  <tt>&lt;Table.field, IsNull&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNotNull</tt>
|  <tt>&lt;Table.field, IsNotNull&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsIn&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, In&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNotIn&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, NotIn&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsInSub&lt;TSearch&gt;</tt>
|  <tt>&lt;Table.field, In2&lt;TSearch&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNotInSub&lt;TSearch&gt;</tt>
|  <tt>&lt;Table.field, NotIn2&lt;TSearch&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsIn&lt;TConst1, ..., TConstN&gt;</tt>
|  <tt>&lt;Table.field, In3&lt;TConst1, ..., TConstN&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNotIn&lt;TConst1, ..., TConstN&gt;</tt>
|  <tt>&lt;Table.field, NotIn3&lt;TConst1, ..., TConstN&gt;&gt;</tt>
|}
==Case, When, Then, and Else Operators==[anchor|#_4ba331e7-5437-4d2b-bff1-48954601473c]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>Operand1.When&lt;Condition1&gt;.Else&lt;Operand2&gt;.When&lt;Condition2&gt;.&#91;...&#93;</tt>
|  <tt>Switch&lt;Cases&gt;</tt>
|- 
|  <tt>Operand1.When&lt;Condition1&gt;.&#91;...&#93;.Else&lt;Default&gt;</tt>
|  <tt>Switch&lt;Cases,Default&gt;</tt>
|- 
|  <tt>Operand.When&lt;Condition&gt;</tt>
|  <tt>Case&lt;Condition,Operand&gt;</tt>
|- 
|  <tt>Operand.When&lt;Condition&gt;.Else&lt;Operand2&gt;.When&lt;Condition2&gt;.&#91;...&#93;</tt>
|  <tt>Case&lt;Condition,Operand,NextCase&gt;</tt>
|}
==Arithmetic Operations and Operations with Strings and Dates==[anchor|#_295d7b3a-34e3-4cf2-8440-0e6cb246ea30]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>Op1.Add&lt;Op2&gt;</tt>
|  <tt>Add&lt;Op1, Op2&gt;</tt>
|- 
|  <tt>Op1.Subtract&lt;Op2&gt;</tt>
|  <tt>Sub&lt;Op1, Op2&gt;</tt>
|- 
|  <tt>Op1.Multiply&lt;Op2&gt;</tt>
|  <tt>Mult&lt;Op1, Op2&gt;</tt>
|- 
|  <tt>Op1.Divide&lt;Op2&gt;</tt>
|  <tt>Div&lt;Op1, Op2&gt;</tt>
|- 
|  <tt>Op1.Concat&lt;Op2&gt;</tt>
|  <tt>Concat&lt;Op1, Op2&gt;</tt>
|- 
|  <tt>Op1.IfNullThen&lt;Op2&gt;</tt>
|  <tt>IsNull&lt;Op1, Op2&gt;</tt>
|- 
|  <tt>Op1.NullIf&lt;Op2&gt;</tt>
|  <tt>NullIf&lt;Op1, Op2&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Years</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.year&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Quarters</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.quarter&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Months</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.month&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Weeks</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.week&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Days</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.day&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Hours</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.hour&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Minutes</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.minute&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Seconds</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.second&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Milliseconds</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.millisecond&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Year</tt>
|  <tt>DatePart&lt;DatePart.year, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Quarter</tt>
|  <tt>DatePart&lt;DatePart.quarter, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Month</tt>
|  <tt>DatePart&lt;DatePart.month, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Week</tt>
|  <tt>DatePart&lt;DatePart.week, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.WeekDay</tt>
|  <tt>DatePart&lt;DatePart.weekDay, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Day</tt>
|  <tt>DatePart&lt;DatePart.day, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.DayOfYear</tt>
|  <tt>DatePart&lt;DatePart.dayOfYear, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Hour</tt>
|  <tt>DatePart&lt;DatePart.hour, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Minute</tt>
|  <tt>DatePart&lt;DatePart.minute, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Second</tt>
|  <tt>DatePart&lt;DatePart.second, Date&gt;</tt>
|}
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_BQL_and_LINQ|BQL and LINQ]
*[HelpRoot_Dev_Platform\AD__con_Fluent_BQL|Fluent Business Query Language]]]></column>
			<column name="PlainText"><![CDATA[Fluent BQL and Traditional BQL Equivalents The fluent business query language (BQL) library defines the equivalents of traditional BQL     classes listed in the following tables. Data View Declarations All data views that contain aggregating are read-only. Fluent BQL Traditional BQL SelectFrom<>.View PXSelect<> SelectFrom<>.View.ReadOnly PXSelectReadonly<> SelectFrom<>.OrderBy<>.View PXSelectOrderBy<,> SelectFrom<>.OrderBy<>.View.ReadOnly PXSelectReadonly3<,> SelectFrom<>.AggregateTo<>.View.ReadOnly PXSelectGroupBy<,> SelectFrom<>.AggregateTo<>.OrderBy<>.View.ReadOnly PXSelectGroupByOrderBy<,,> SelectFrom<>.Where<>.View PXSelect<,> SelectFrom<>.Where<>.View.ReadOnly PXSelectReadonly<,> SelectFrom<>.Where<>.OrderBy<>.View PXSelect<,,> SelectFrom<>.Where<>.OrderBy<>.View.ReadOnly PXSelectReadonly<,,> SelectFrom<>.Where<>.AggregateTo<>.View.ReadOnly PXSelectGroupBy<,,> SelectFrom<>.Where<>.AggregateTo<>.OrderBy<>.View.ReadOnly PXSelectGroupBy<,,,> SelectFrom<>.[Joins].View PXSelectJoin<,> SelectFrom<>.[Joins].View.ReadOnly PXSelectReadonly2<,> SelectFrom<>.[Joins].OrderBy<>.View PXSelectJoinOrderBy<,,> SelectFrom<>.[Joins].OrderBy<>.View.ReadOnly PXSelectReadonly3<,,> SelectFrom<>.[Joins].AggregateTo<>.View.ReadOnly PXSelectJoinGroupBy<,,> SelectFrom<>.[Joins].AggregateTo<>.OrderBy<>.View.ReadOnly PXSelectGroupByOrderBy<,,,> SelectFrom<>.[Joins].Where<>.View PXSelectJoin<,,> SelectFrom<>.[Joins].Where<>.View.ReadOnly PXSelectReadonly2<,,> SelectFrom<>.[Joins].Where<>.OrderBy<>.View PXSelectJoin<,,,> SelectFrom<>.[Joins].Where<>.OrderBy<>.View.ReadOnly PXSelectReadonly2<,,,> SelectFrom<>.[Joins].Where<>.AggregateTo<>.View.ReadOnly PXSelectJoinGroupBy<,,,> SelectFrom<>.[Joins].Where<>.AggregateTo<>.OrderBy<>.View.ReadOnly PXSelectJoinGroupBy<,,,,> Select Commands Fluent BQL Traditional BQL SelectFrom<> Select<> SelectFrom<>.OrderBy<> Select3<,> SelectFrom<>.AggregateTo<> Select4<,> SelectFrom<>.AggregateTo<>.OrderBy<> Select6<,,> SelectFrom<>.Where<> Select<,> SelectFrom<>.Where<>.OrderBy<> Select<,,> SelectFrom<>.Where<>.AggregateTo<> Select4<,,> SelectFrom<>.Where<>.AggregateTo<>.OrderBy<> Select4<,,,> SelectFrom<>.[Joins] Select2<,> SelectFrom<>.[Joins].OrderBy<> Select3<,,> SelectFrom<>.[Joins].AggregateTo<> Select5<,,> SelectFrom<>.[Joins].AggregateTo<>.OrderBy<> Select6<,,,> SelectFrom<>.[Joins].Where<> Select2<,,> SelectFrom<>.[Joins].Where<>.OrderBy<> Select2<,,,> SelectFrom<>.[Joins].Where<>.AggregateTo<> Select5<,,,> SelectFrom<>.[Joins].Where<>.AggregateTo<>.OrderBy<> Select5<,,,,> Search Commands Fluent BQL Traditional BQL SelectFrom<>.SearchFor<> Search<> SelectFrom<>.OrderBy<>.SearchFor<> Search3<,> SelectFrom<>.AggregateTo<>.SearchFor<> Search4<,> SelectFrom<>.AggregateTo<>.OrderBy<>.SearchFor<> Search6<,,> SelectFrom<>.Where<>.SearchFor<> Search<,> SelectFrom<>.Where<>.OrderBy<>.SearchFor<> Search<,,> SelectFrom<>.Where<>.AggregateTo<>.SearchFor<> Search4<,,> SelectFrom<>.Where<>.AggregateTo<>.OrderBy<>.SearchFor<> Search4<,,,> SelectFrom<>.[Joins].SearchFor<> Search2<,> SelectFrom<>.[Joins].OrderBy<>.SearchFor<> Search3<,,> SelectFrom<>.[Joins].AggregateTo<>.SearchFor<> Search5<,,> SelectFrom<>.[Joins].AggregateTo<>.OrderBy<>.SearchFor<> Search6<,,,> SelectFrom<>.[Joins].Where<>.SearchFor<> Search2<,,> SelectFrom<>.[Joins].Where<>.OrderBy<>.SearchFor<> Search2<,,,> SelectFrom<>.[Joins].Where<>.AggregateTo<>.SearchFor<> Search5<,,,> SelectFrom<>.[Joins].Where<>.AggregateTo<>.OrderBy<>.SearchFor<> Search5<,,,,> Join Clauses Fluent BQL Traditional BQL .InnerJoin<Table>.On<> InnerJoin<Table,On> .InnerJoin<Table>.On<>.NextJoin InnerJoin<Table,On,NextJoin> .InnerJoin<Table>.On<>.SingleTableOnly InnerJoinSingleTable<Table,On> .InnerJoin<Table>.On<>.SingleTableOnly.NextJoin InnerJoinSingleTable<Table,On,NextJoin> .LeftJoin<Table>.On<> LeftJoin<Table,On> .LeftJoin<Table>.On<>.NextJoin LeftJoin<Table,On,NextJoin> .LeftJoin<Table>.On<>.SingleTableOnly LeftJoinSingleTable<Table,On> .LeftJoin<Table>.On<>.SingleTableOnly.NextJoin LeftJoinSingleTable<Table,On,NextJoin> .RightJoin<Table>.On<> RightJoin<Table,On> .RightJoin<Table>.On<>.NextJoin RightJoin<Table,On,NextJoin> .RightJoin<Table>.On<>.SingleTableOnly RightJoinSingleTable<Table,On> .RightJoin<Table>.On<>.SingleTableOnly.NextJoin RightJoinSingleTable<Table,On,NextJoin> .FullJoin<Table>.On<> FullJoin<Table,On> .FullJoin<Table>.On<>.NextJoin FullJoin<Table,On,NextJoin> .FullJoin<Table>.On<>.SingleTableOnly FullJoinSingleTable<Table,On> .FullJoin<Table>.On<>.SingleTableOnly.NextJoin FullJoinSingleTable<Table,On,NextJoin> .CrossJoin<Table> CrossJoin<Table> .CrossJoin<Table>.NextJoin CrossJoin<Table,NextJoin> .CrossJoin<Table>.SingleTableOnly CrossJoinSingleTable<Table> .CrossJoin<Table>.SingleTableOnly.NextJoin CrossJoinSingleTable<Table,NextJoin> Where Clause Fluent BQL Traditional BQL .Where<UnaryOperator> Where<UnaryOperator> .Where<Operand.Comparison> Where<Operand,Comparison> .Where<Operand.Comparison.NextOperator> Where<Operand,Comparison,NextOperator> .Where<UnaryOperator.NextOperator> Where2<UnaryOperator,NextOperator> Aggregate Clause Fluent BQL Traditional BQL .AggregateTo<Function> Aggregate<Function> .AggregateTo<TFunctions>.THaving Aggregate<TFunctions,THaving> .Having<TCondition> Having<TCondition> GroupBy<Field> GroupBy<Field> GroupBy<Field>, NextAggregate GroupBy<Field,NextAggregate> Max<Field> Max<Field> Max<Field>, NextAggregate Max<Field,NextAggregate> Min<Field> Min<Field> Min<Field>, NextAggregate Min<Field,NextAggregate> Sum<Field> Sum<Field> Sum<Field>, NextAggregate Sum<Field,NextAggregate> Avg<Field> Avg<Field> Avg<Field>, NextAggregate Avg<Field,NextAggregate> Count Count Count<Field> Count<Field> OrderBy Clause Fluent BQL Traditional BQL .OrderBy<List> OrderBy<List> Field.Asc Asc<Field> Field.Asc, NextSort Asc<Field,NextSort> Field.Desc Desc<Field> Field.Desc, NextSort Desc<Field,NextSort> Parameters Fluent BQL Traditional BQL Field.FromCurrent Current<Field> Field.FromCurrent.NoDefault Current2<Field> Field.AsOptional Optional<Field> Field.AsOptional.NoDefault Optional2<Field> @P.AsBool Required<Field> , where the property field of           Field  has the  bool  type @P.AsByte Required<Field> , where the property field of           Field  has the  byte  type @P.AsShort Required<Field> , where the property field of           Field  has the  short  type @P.AsInt Required<Field> , where the property field of           Field  has the  int  type @P.AsLong Required<Field> , where the property field of           Field  has the  long  type @P.AsFloat Required<Field> , where the property field of           Field  has the  float  type @P.AsDouble Required<Field> , where the property field of           Field  has the  double  type @P.AsDecimal Required<Field> , where the property field of           Field  has the  decimal  type @P.AsGuid Required<Field> , where the property field of           Field  has the  Guid  type @P.AsDateTime Required<Field> , where the property field of           Field  has the  DateTime  type @P.AsString Required<Field> , where the property field of           Field  has the  string  type Argument.AsBool Argument<bool?> Argument.AsByte Argument<byte?> Argument.AsShort Argument<short?> Argument.AsInt Argument<int?> Argument.AsLong Argument<long?> Argument.AsFloat Argument<float?> Argument.AsDouble Argument<double?> Argument.AsDecimal Argument<decimal?> Argument.AsGuid Argument<Guid?> Argument.AsDateTime Argument<DateTime?> Argument.AsString Argument<string> Logical Operators and Brackets Fluent BQL Traditional BQL And<UnaryOperator> And<UnaryOperator> And<Operand.Comparison> And<Operand,Comparison> And<Operand.Comparison>.NextOperator And<Operand,Comparison,NextOperator> And<UnaryOperator.NextOperator> And2<UnaryOperator,NextOperator> Or<UnaryOperator> Or<UnaryOperator> Or<Operand.Comparison> Or<Operand,Comparison> Or<Operand.Comparison>.NextOperator Or<Operand,Comparison,NextOperator> Or<UnaryOperator.NextOperator> Or2<UnaryOperator,NextOperator> Not<UnaryOperator> Not<UnaryOperator> Not<Operand.Comparison> Not<Operand,Comparison> Not<Operand.Comparison.NextOperator> Not<Operand,Comparison,NextOperator> Not<UnaryOperator.NextOperator> Not2<UnaryOperator,NextOperator> Brackets<UnaryOperator> Where<UnaryOperator> Brackets<Operand.Comparison> Where<Operand,Comparison> Brackets<Operand.Comparison.NextOperator> Where<Operand,Comparison,NextOperator> Brackets<UnaryOperator.NextOperator> Where2<UnaryOperator,NextOperator> Comparisons Fluent BQL Traditional BQL Table.field.IsEqual<TOperand> <Table.field, Equal<TOperand>> Table.field.IsNotEqual<TOperand> <Table.field, NotEqual<TOperand>> Table.field.IsGreaterEqual<TOperand> <Table.field, GreaterEqual<TOperand>> Table.field.IsGreater<TOperand> <Table.field, Greater<TOperand>> Table.field.IsLessEqual<TOperand> <Table.field, LessEqual<TOperand>> Table.field.IsLess<TOperand> <Table.field, Less<TOperand>> Table.field.IsLike<TOperand> <Table.field, Like<TOperand>> Table.field.IsNotLike<TOperand> <Table.field, NotLike<TOperand>> Table.field.IsBetween<TOperand> <Table.field, Between<TOperand>> Table.field.IsNotBetween<TOperand> <Table.field, NotBetween<TOperand>> Table.field.IsNull <Table.field, IsNull<TOperand>> Table.field.IsNotNull <Table.field, IsNotNull<TOperand>> Table.field.IsIn<TOperand> <Table.field, In<TOperand>> Table.field.IsNotIn<TOperand> <Table.field, NotIn<TOperand>> Table.field.IsInSub<TSearch> <Table.field, In2<TSearch>> Table.field.IsNotInSub<TSearch> <Table.field, NotIn2<TSearch>> Table.field.IsIn<TConst1, ..., TConstN> <Table.field, In3<TConst1, ..., TConstN>> Table.field.IsNotIn<TConst1, ..., TConstN> <Table.field, NotIn3<TConst1, ..., TConstN>> Case, When, Then, and Else Operators Fluent BQL Traditional BQL Operand1.When<Condition1>.Else<Operand2>.When<Condition2>.[...] Switch<Cases> Operand1.When<Condition1>.[...].Else<Default> Switch<Cases,Default> Operand.When<Condition> Case<Condition,Operand> Operand.When<Condition>.Else<Operand2>.When<Condition2>.[...] Case<Condition,Operand,NextCase> Arithmetic Operations and Operations with Strings and Dates Fluent BQL Traditional BQL Op1.Add<Op2> Add<Op1, Op2> Op1.Subtract<Op2> Sub<Op1, Op2> Op1.Multiply<Op2> Mult<Op1, Op2> Op1.Divide<Op2> Div<Op1, Op2> Op1.Concat<Op2> Concat<Op1, Op2> Op1.IfNullThen<Op2> IsNull<Op1, Op2> Op1.NullIf<Op2> NullIf<Op1, Op2> Date1.Diff<Date2>.Years DateDiff<Date1, Date2, DateDiff.year> Date1.Diff<Date2>.Quarters DateDiff<Date1, Date2, DateDiff.quarter> Date1.Diff<Date2>.Months DateDiff<Date1, Date2, DateDiff.month> Date1.Diff<Date2>.Weeks DateDiff<Date1, Date2, DateDiff.week> Date1.Diff<Date2>.Days DateDiff<Date1, Date2, DateDiff.day> Date1.Diff<Date2>.Hours DateDiff<Date1, Date2, DateDiff.hour> Date1.Diff<Date2>.Minutes DateDiff<Date1, Date2, DateDiff.minute> Date1.Diff<Date2>.Seconds DateDiff<Date1, Date2, DateDiff.second> Date1.Diff<Date2>.Milliseconds DateDiff<Date1, Date2, DateDiff.millisecond> DatePart<Date>.Year DatePart<DatePart.year, Date> DatePart<Date>.Quarter DatePart<DatePart.quarter, Date> DatePart<Date>.Month DatePart<DatePart.month, Date> DatePart<Date>.Week DatePart<DatePart.week, Date> DatePart<Date>.WeekDay DatePart<DatePart.weekDay, Date> DatePart<Date>.Day DatePart<DatePart.day, Date> DatePart<Date>.DayOfYear DatePart<DatePart.dayOfYear, Date> DatePart<Date>.Hour DatePart<DatePart.hour, Date> DatePart<Date>.Minute DatePart<DatePart.minute, Date> DatePart<Date>.Second DatePart<DatePart.second, Date> ]]></column>
		</row>
		<row PageID="2204f63e-6ab7-4f29-ba28-1b549570e40f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="55d3a2b0-f91c-e8b8-02f0-de45091409dc" RecordSourceID="22377">
			<column name="Content"><![CDATA[To send a request to the database, you call the <tt>Select()</tt> method of a <tt>PXSelectBase</tt>-derived class and cast the result of the query execution to a data access class (DAC) or an array of DACs, as described in this topic. The <tt>Select()</tt> method can accept additional parameters if a business query language (BQL) statement includes parameters. {br}{TOC}
==To Execute a BQL Statement That Defines a Data View==
When an Acumatica ERP form requests data, you do not need to execute a data view manually; the system executes each data view automatically. If you need to manually execute a BQL statement that defines a data view, do the following:[anchor|#ul_lkv_zd5_nk]
#Declare a data view as a member in a graph.
#Execute the data view by calling the <tt>Select()</tt> method of a <tt>PXSelectBase</tt>-derived class.
#Cast the result of the query execution to a DAC or an array of DACs, or iterate through DACs in the result by using the {{foreach}} statement. The following sample code shows the approach of iterating through DACs. For details, see [HelpRoot_Dev_Platform\AD__how_Process_Resultset|To Process the Result of the Execution of the BQL Statement].<source lang="csharp">// Business logic controller (graph) declaration
public class OrderDataEntry : PXGraph&lt;OrderDataEntry, SalesOrder&gt;
{
    // A data view declared as a graph member
    public SelectFrom&lt;SalesOrder&gt;.
               OrderBy&lt;Asc&lt;SalesOrder.orderNbr&gt;&gt;.View Orders;
    ...
    public void SomeMethod()
    {
        // An execution of the data view in code
        foreach(SalesOrder so in Orders.Select())
        {
            // The SalesOrder record selected by a data view can
            // be modified and updated through the Update() method.
            so.OrderTotal = so.LinesTotal + so.FreightAmt;
            // Update the SalesOrder data record in PXCache
            Orders.Update(so); 
        }
    }
}</source>

==To Execute a BQL Statement Statically==
To execute a BQL statement statically, do the following: [anchor|#_b6f34987-0d58-4d76-9a59-955314d01459]
#Execute a BQL statement by using the {{static}}<tt>Select()</tt> method of a <tt>PXSelectBase</tt>-derived class. Provide a graph object as the parameter of the method. 
#Cast the result of the query execution to a DAC or an array of DACs, or iterate through DACs in the result by using the {{foreach}} statement. The following sample code shows the approach of iterating through DACs. For details, see [HelpRoot_Dev_Platform\AD__how_Process_Resultset|To Process the Result of the Execution of the BQL Statement].
<source lang="csharp">// Business logic controller (graph) declaration
public class OrderDataEntry : PXGraph&lt;OrderDataEntry, SalesOrder&gt;
{
    ...
    public void SomeMethod()
    {
        // Execution through the static Select() method
        foreach(SalesOrder so in
            SelectFrom&lt;SalesOrder&gt;.
                OrderBy&lt;Asc&lt;SalesOrder.orderNbr&gt;&gt;.View.Select(this))
            ...
    }
}</source>
==To Execute a BQL Statement Dynamically==
To execute a BQL statement dynamically, do the following: [anchor|#_fbc8ef5f-258e-4f45-abff-aa8198fee988]
#Dynamically instantiate a data view in code. You should also provide the graph object as a parameter to the data view constructor.
#Execute the data view by using the <tt>Select()</tt> method of the instance of a <tt>PXSelectBase</tt>-derived class. 
#Cast the result of the query execution to a DAC or an array of DACs, or iterate through DACs in the result by using the {{foreach}} statement. The following sample code shows the approach of iterating through DACs. For details, see [HelpRoot_Dev_Platform\AD__how_Process_Resultset|To Process the Result of the Execution of the BQL Statement].
<source lang="csharp">// Business logic controller (graph) declaration
public class OrderDataEntry : PXGraph&lt;OrderDataEntry, SalesOrder&gt;
{
    ...
    public void SomeMethod()
    {
        // Dynamic instantiation of a data view
        PXSelectBase&lt;SalesOrder&gt; orders =
            new SelectFrom&lt;SalesOrder&gt;.
                OrderBy&lt;Asc&lt;SalesOrder.orderNbr&gt;&gt;.View(this);

        // An execution of a dynamically created BQL statement
        foreach(SalesOrder so in orders.Select())
            ...
    }
}</source>
==To Execute a BQL Statement with Parameters==
Use parameters (such as <tt>AsOptional</tt>, <tt>FromCurrent</tt>, and <tt>@P.As&#91;Type&#93;</tt> in fluent BQL and <tt>Optional</tt>, <tt>Current</tt>, and <tt>Required</tt> in traditional BQL) to pass specific values to a BQL statement, as shown in the following example. For more details on how to construct a BQL statement with parameters, see [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL|To Use Parameters in Fluent BQL Queries] and [HelpRoot_Dev_Platform\AD__how_BQL_Parameters|To Use Parameters in Traditional BQL].<source lang="csharp">// Declaration of a BLC
public class ReceiptDataEntry : PXGraph&lt;ReceiptDataEntry, Document&gt;
{
    // When a screen associated with this BLC is first opened,
    // the Optional parameter is replaced with the default DocType value.
    public SelectFrom&lt;Document&gt;.
        Where&lt;Document.docType.IsEqual&lt;Document.docType.AsOptional&gt;&gt; Receipts;

    // The FromCurrent parameters are replaced with the values from
    // the Current property of the PXCache&lt;Document&gt; object.
    public SelectFrom&lt;DocTransaction&gt;.
        Where&lt;DocTransaction.docNbr.IsEqual&lt;Document.docNbr.FromCurrent&gt;.
            And&lt;DocTransaction.docType.IsEqual&lt;Document.docType.FromCurrent&gt;&gt;&gt;.
        OrderBy&lt;Asc&lt;DocTransaction.lineNbr&gt;&gt; ReceiptTransactions;

    public void SomeMethod()
    {
        // Select documents of the same DocType as the current document
        // has, or of the default DocType if the current document is null.
        PXResult&lt;Document&gt; res1 = Receipts.Select();
        foreach(Document doc in res1)
            ...

        // Select documents of the "N" DocType.
        PXResult&lt;Document&gt; res2 = Receipts.Select("N");
        foreach(Document doc in res2)
            ...

        // Use parameter values from the current document.
        PXResult&lt;DocTransaction&gt; res3 = ReceiptTransactions.Select();
        foreach(DocTransaction docTran in res3)
            ...

        // Use the @P.AsString parameter to provide values in code.
        // The result set here is the same as the res2 result set.
        PXResult&lt;Document&gt; res4 =
            SelectFrom&lt;Document&gt;.
                Where&lt;Document.docType.IsEqual&lt;@P.AsString&gt;&gt;.View
            .Select(this, "N");
        foreach(Document doc in res4)
            ...
    }
    ...
}</source>[anchor|#_36988f03-38e3-4f9a-89f6-1623935e81fa]
==To Execute a BQL Statement in a Data View Delegate==
If the data requested from the database cannot be described by a declarative BQL statement, implement the data view delegate that is used instead of the standard <tt>Select()</tt> logic to retrieve data from the database; this data view delegate must satisfy the following requirements:[anchor|#_1039779e-6e87-43cc-a80f-ad03aad2a906]
*The data view delegate must have the same name as the data view except for the first letter, which must be lowercase. 
*The data view delegate must return <tt>IEnumerable</tt>, as shown in the following example.
*:((({S:Warn}If the data view delegate is not defined or it returns {{null}}, the standard <tt>Select()</tt> logic is executed.
)))
{br}

The following sample code defines a data view delegate.<source lang="csharp">// A view declaration in a graph
public SelectFrom&lt;BalancedAPDocument&gt;.
    LeftJoin&lt;APInvoice&gt;.
        On&lt;APInvoice.docType.IsEqual&lt;BalancedAPDocument.docType&gt;.
            And&lt;APInvoice.refNbr.IsEqual&lt;BalancedAPDocument.refNbr&gt;&gt;&gt;.
    LeftJoin&lt;APPayment&gt;.
        On&lt;APPayment.docType.IsEqual&lt;BalancedAPDocument.docType&gt;.
            And&lt;APPayment.refNbr.IsEqual&lt;BalancedAPDocument.refNbr&gt;&gt;&gt;.View
    DocumentList;

// The data view delegate
protected virtual IEnumerable documentlist()
{
    // Iterating over the result set of a complex BQL statement
    foreach (PXResult&lt;BalancedAPDocument, APInvoice, APPayment, APAdjust&gt; res in
        SelectFrom&lt;BalancedAPDocument&gt;.
            LeftJoin&lt;APInvoice&gt;.
                On&lt;APInvoice.docType.IsEqual&lt;BalancedAPDocument.docType&gt;.
                    And&lt;APInvoice.refNbr.IsEqual&lt;BalancedAPDocument.refNbr&gt;&gt;&gt;.
            LeftJoin&lt;APPayment&gt;.
                On&lt;APPayment.docType.IsEqual&lt;BalancedAPDocument.docType&gt;.
                    And&lt;APPayment.refNbr.IsEqual&lt;BalancedAPDocument.refNbr&gt;&gt;&gt;.
            LeftJoin&lt;APAdjust&gt;.
                On&lt;APAdjust.adjgDocType.IsEqual&lt;BalancedAPDocument.docType&gt;&gt;.
            AggregateTo&lt;GroupBy&lt;BalancedAPDocument.docType&gt;,
                GroupBy&lt;BalancedAPDocument.refNbr&gt;,
                GroupBy&lt;BalancedAPDocument.released&gt;,
                GroupBy&lt;BalancedAPDocument.prebooked&gt;,
                GroupBy&lt;BalancedAPDocument.openDoc&gt;&gt;.View.Select(this))
    {
        // Casting a result set record to DAC types
        BalancedAPDocument apdoc = (BalancedAPDocument)res;
        APAdjust adj = (APAdjust)res;
        // Checking some conditions and modifying records
        ...
    }

    return new PXResult&lt;BalancedAPDocument, APInvoice, APPayment&gt;(
            apdoc, res, res);
}</source>
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]
*[HelpRoot_Dev_Platform\AD__how_Process_Resultset|To Process the Result of the Execution of the BQL Statement]]]></column>
			<column name="PlainText"><![CDATA[To Execute BQL Statements To send a request to the database, you call the                  Select()  method of a  PXSelectBase -derived             class and cast the result of the query execution to a data access class (DAC) or an             array of DACs, as described in this topic. The  Select()  method can             accept additional parameters if a business query language (BQL) statement includes             parameters.  To Execute a BQL Statement That Defines a Data View When an  Acumatica ERP form requests data, you do not need to execute a data view manually; the system                 executes each data view automatically. If you need to manually execute a BQL                 statement that defines a data view, do the following: Declare a data view as a member in a graph. Execute the data view by calling the  Select()  method of a                              PXSelectBase -derived class. Cast the result of the query execution to a DAC or an array of DACs, or                         iterate through DACs in the result by using the  foreach                          statement. The following sample code shows the approach of iterating through                         DACs. For details, see  To Process the Result of the Execution of the BQL Statement. // Business logic controller (graph) declaration
public class OrderDataEntry : PXGraph<OrderDataEntry, SalesOrder>
{
    // A data view declared as a graph member
    public SelectFrom<SalesOrder>.
               OrderBy<Asc<SalesOrder.orderNbr>>.View Orders;
    ...
    public void SomeMethod()
    {
        // An execution of the data view in code
        foreach(SalesOrder so in Orders.Select())
        {
            // The SalesOrder record selected by a data view can
            // be modified and updated through the Update() method.
            so.OrderTotal = so.LinesTotal + so.FreightAmt;
            // Update the SalesOrder data record in PXCache
            Orders.Update(so); 
        }
    }
} To Execute a BQL Statement Statically To execute a BQL statement statically, do the following:  Execute a BQL statement by using the  static Select()  method of a                          PXSelectBase -derived class. Provide a graph object as the                         parameter of the method.  Cast the result of the query execution to a DAC or an array of DACs, or                         iterate through DACs in the result by using the  foreach                          statement. The following sample code shows the approach of iterating through                         DACs. For details, see  To Process the Result of the Execution of the BQL Statement. // Business logic controller (graph) declaration
public class OrderDataEntry : PXGraph<OrderDataEntry, SalesOrder>
{
    ...
    public void SomeMethod()
    {
        // Execution through the static Select() method
        foreach(SalesOrder so in
            SelectFrom<SalesOrder>.
                OrderBy<Asc<SalesOrder.orderNbr>>.View.Select(this))
            ...
    }
} To Execute a BQL Statement Dynamically To execute a BQL statement dynamically, do the following:  Dynamically instantiate a data view in code. You should also provide the                         graph object as a parameter to the data view constructor. Execute the data view by using the  Select()  method of the                         instance of a  PXSelectBase -derived class.  Cast the result of the query execution to a DAC or an array of DACs, or                         iterate through DACs in the result by using the  foreach                          statement. The following sample code shows the approach of iterating through                         DACs. For details, see  To Process the Result of the Execution of the BQL Statement. // Business logic controller (graph) declaration
public class OrderDataEntry : PXGraph<OrderDataEntry, SalesOrder>
{
    ...
    public void SomeMethod()
    {
        // Dynamic instantiation of a data view
        PXSelectBase<SalesOrder> orders =
            new SelectFrom<SalesOrder>.
                OrderBy<Asc<SalesOrder.orderNbr>>.View(this);

        // An execution of a dynamically created BQL statement
        foreach(SalesOrder so in orders.Select())
            ...
    }
} To Execute a BQL Statement with Parameters Use parameters (such as  AsOptional ,  FromCurrent , and                      @P.As[Type]  in fluent BQL and  Optional ,                      Current , and  Required  in traditional BQL)                 to pass specific values to a BQL statement, as shown in the following example. For                 more details on how to construct a BQL statement with parameters, see  To Use Parameters in Fluent BQL Queries and  To Use Parameters in Traditional BQL. // Declaration of a BLC
public class ReceiptDataEntry : PXGraph<ReceiptDataEntry, Document>
{
    // When a screen associated with this BLC is first opened,
    // the Optional parameter is replaced with the default DocType value.
    public SelectFrom<Document>.
        Where<Document.docType.IsEqual<Document.docType.AsOptional>> Receipts;

    // The FromCurrent parameters are replaced with the values from
    // the Current property of the PXCache<Document> object.
    public SelectFrom<DocTransaction>.
        Where<DocTransaction.docNbr.IsEqual<Document.docNbr.FromCurrent>.
            And<DocTransaction.docType.IsEqual<Document.docType.FromCurrent>>>.
        OrderBy<Asc<DocTransaction.lineNbr>> ReceiptTransactions;

    public void SomeMethod()
    {
        // Select documents of the same DocType as the current document
        // has, or of the default DocType if the current document is null.
        PXResult<Document> res1 = Receipts.Select();
        foreach(Document doc in res1)
            ...

        // Select documents of the "N" DocType.
        PXResult<Document> res2 = Receipts.Select("N");
        foreach(Document doc in res2)
            ...

        // Use parameter values from the current document.
        PXResult<DocTransaction> res3 = ReceiptTransactions.Select();
        foreach(DocTransaction docTran in res3)
            ...

        // Use the @P.AsString parameter to provide values in code.
        // The result set here is the same as the res2 result set.
        PXResult<Document> res4 =
            SelectFrom<Document>.
                Where<Document.docType.IsEqual<@P.AsString>>.View
            .Select(this, "N");
        foreach(Document doc in res4)
            ...
    }
    ...
} To Execute a BQL Statement in a Data View Delegate If the data requested from the database cannot be described by a declarative BQL                 statement, implement the data view delegate that is used instead of the standard                      Select()  logic to retrieve data from the database; this data                 view delegate must satisfy the following requirements: The data view delegate must have the same name as the data view except for                         the first letter, which must be lowercase.  The data view delegate must return  IEnumerable , as shown                         in the following example. If the data view delegate is not defined or                             it returns  null , the standard                                  Select()  logic is executed. The following sample code defines a data view                 delegate. // A view declaration in a graph
public SelectFrom<BalancedAPDocument>.
    LeftJoin<APInvoice>.
        On<APInvoice.docType.IsEqual<BalancedAPDocument.docType>.
            And<APInvoice.refNbr.IsEqual<BalancedAPDocument.refNbr>>>.
    LeftJoin<APPayment>.
        On<APPayment.docType.IsEqual<BalancedAPDocument.docType>.
            And<APPayment.refNbr.IsEqual<BalancedAPDocument.refNbr>>>.View
    DocumentList;

// The data view delegate
protected virtual IEnumerable documentlist()
{
    // Iterating over the result set of a complex BQL statement
    foreach (PXResult<BalancedAPDocument, APInvoice, APPayment, APAdjust> res in
        SelectFrom<BalancedAPDocument>.
            LeftJoin<APInvoice>.
                On<APInvoice.docType.IsEqual<BalancedAPDocument.docType>.
                    And<APInvoice.refNbr.IsEqual<BalancedAPDocument.refNbr>>>.
            LeftJoin<APPayment>.
                On<APPayment.docType.IsEqual<BalancedAPDocument.docType>.
                    And<APPayment.refNbr.IsEqual<BalancedAPDocument.refNbr>>>.
            LeftJoin<APAdjust>.
                On<APAdjust.adjgDocType.IsEqual<BalancedAPDocument.docType>>.
            AggregateTo<GroupBy<BalancedAPDocument.docType>,
                GroupBy<BalancedAPDocument.refNbr>,
                GroupBy<BalancedAPDocument.released>,
                GroupBy<BalancedAPDocument.prebooked>,
                GroupBy<BalancedAPDocument.openDoc>>.View.Select(this))
    {
        // Casting a result set record to DAC types
        BalancedAPDocument apdoc = (BalancedAPDocument)res;
        APAdjust adj = (APAdjust)res;
        // Checking some conditions and modifying records
        ...
    }

    return new PXResult<BalancedAPDocument, APInvoice, APPayment>(
            apdoc, res, res);
} ]]></column>
		</row>
		<row PageID="8609c829-7b9c-4660-acf9-891b0971b6a3" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="17e24c6a-b918-3774-4617-16addd2223d8" RecordSourceID="22377">
			<column name="Content"><![CDATA[
<tt>Select()</tt> returns the <tt>PXResultset&lt;T0&gt;</tt> object. The type parameter (<tt>T0</tt>) is set to the first table selected by the business query language (BQL) statement, and <tt>PXResultset&lt;T0&gt;</tt> is a collection of <tt>PXResult&lt;T0&gt;</tt> objects. You can iterate through the result set in a <tt>foreach</tt> loop and obtain either data access class (DAC) instances or <tt>PXResult&lt;&gt;</tt> instances. A <tt>PXResult&lt;&gt;</tt> instance represents a whole result set record and can be cast to any of the DAC types joined in the BQL statement.[anchor|#_3fa4383b-2b91-4af6-b8a4-6bf4e24fa853]
==To Get the Objects of the Primary DAC==
In the {{foreach}} loop, cast each <tt>PXResult&lt;T0&gt;</tt> object in the collection to an object of the main DAC. The <tt>PXResult&lt;T0&gt;</tt> object is implicitly converted to the <tt>T0</tt> class. In the following sample code, records are selected from the {{Document}} table.<source lang="csharp">// Result set records are implicitly cast to the Document DAC.
foreach(Document doc in SelectFrom&lt;Document&gt;.View.Select(this))
{
    ...
}</source>
==To Get the Objects of Joined DACs==
[anchor|#_7772b62c-1b44-4f84-ba2c-9d53609879c8]
#In the {{foreach}} loop, cast each <tt>PXResult&lt;T0&gt;</tt> object in the collection to the needed <tt>PXResult&lt;T0, T1, T2, ...&gt;</tt> object, where <tt>T0</tt>, <tt>T1</tt>, <tt>T2</tt>, and other type parameters are joined DACs from the BQL statement. The <tt>PXResult&lt;T0, T1, T2, ...&gt;</tt> type must be specialized with the DACs of all joined tables.
#Cast each <tt>PXResult&lt;T0, T1, T2, ...&gt;</tt> item to any of the listed types to get the object of this type.
The following sample code shows how to process the result set of a BQL statement joining two tables.<source lang="csharp">// The static Select() method is called to execute a BQL command.
PXResultset&lt;OrderLine&gt; result =
    SelectFrom&lt;OrderLine&gt;.InnerJoin&lt;SalesOrder&gt;.
        On&lt;SalesOrder.orderNbr.IsEqual&lt;OrderLine.orderNbr&gt;&gt;.View.Select(this);

// Iterating over the result set:
// PXResult should be specialized with the DACs of all joined tables
// to be able to cast to these DACs.
foreach(PXResult&lt;OrderLine, SalesOrder&gt; record in result)
{
    // Casting a result set record to the OrderLine DAC:
    OrderLine detail = (OrderLine)record;
    // Casting a result set record to the SalesOrder DAC:
    SalesOrder order = (SalesOrder)record;
    ...
}</source>((({S:Warn}Starting C# 7.0, you can also deconstruct the result set as shown in the following code example.<source lang="csharp">(var line, var poLine, var _, var lotSerClass) = 
    (PXResult&lt;POReceiptLine, POLine, InventoryItem, INLotSerClass&gt;)
    SelectFrom&lt;POReceiptLine&gt;
    .LeftJoin&lt;POLine&gt;.On&lt;POReceiptLine.FK.OrderLine&gt;
    .LeftJoin&lt;InventoryItem&gt;.On&lt;POReceiptLine.FK.InventoryItem&gt;
    .LeftJoin&lt;INLotSerClass&gt;.On&lt;InventoryItem.FK.LotSerClass&gt;
    .Where&lt;POReceiptLine.receiptType.IsEqual&lt;@P.AsString&gt;
        .And&lt;POReceiptLine.receiptNbr.IsEqual&lt;@P.AsString&gt;&gt;
        .And&lt;POReceiptLine.lineNbr.IsEqual&lt;@P.AsInt&gt;&gt;&gt;
    .View.Select(Base, split.ReceiptType, split.ReceiptNbr, split.LineNbr);</source>
This code example is equivalent to the following code.<source lang="csharp">var row = (PXResult&lt;POReceiptLine, POLine, InventoryItem, INLotSerClass&gt;)
    SelectFrom&lt;POReceiptLine&gt;
    .LeftJoin&lt;POLine&gt;.On&lt;POReceiptLine.FK.OrderLine&gt;
    .LeftJoin&lt;InventoryItem&gt;.On&lt;POReceiptLine.FK.InventoryItem&gt;
    .LeftJoin&lt;INLotSerClass&gt;.On&lt;InventoryItem.FK.LotSerClass&gt;
    .Where&lt;POReceiptLine.receiptType.IsEqual&lt;@P.AsString&gt;
        .And&lt;POReceiptLine.receiptNbr.IsEqual&lt;@P.AsString&gt;&gt;
        .And&lt;POReceiptLine.lineNbr.IsEqual&lt;@P.AsInt&gt;&gt;&gt;
    .View.Select(Base, split.ReceiptType, split.ReceiptNbr, split.LineNbr);
POReceiptLine line = row;
POLine poLine = row;
INLotSerClass lotSerClass = row;</source>
)))
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]]]></column>
			<column name="PlainText"><![CDATA[To Process the Result of the Execution of the BQL Statement Select()  returns the  PXResultset<T0>                  object. The type parameter ( T0 ) is set to the first table                 selected by the business query language (BQL) statement, and                      PXResultset<T0>  is a collection of                      PXResult<T0>  objects. You can iterate through the result                 set in a  foreach  loop and obtain either data access class (DAC)                 instances or  PXResult<>  instances. A                      PXResult<>  instance represents a whole result set                 record and can be cast to any of the DAC types joined in the BQL statement. To Get the Objects of the Primary DAC In the  foreach  loop, cast each  PXResult<T0>                  object in the collection to an object of the main DAC. The                      PXResult<T0>  object is implicitly converted to the                      T0  class. In the following sample code, records are selected                 from the  Document  table. // Result set records are implicitly cast to the Document DAC.
foreach(Document doc in SelectFrom<Document>.View.Select(this))
{
    ...
} To Get the Objects of Joined DACs In the  foreach  loop, cast each                              PXResult<T0>  object in the collection to the                         needed  PXResult<T0, T1, T2, ...>  object, where                              T0 ,  T1 ,  T2 , and                         other type parameters are joined DACs from the BQL statement. The                              PXResult<T0, T1, T2, ...>  type must be specialized                         with the DACs of all joined tables. Cast each  PXResult<T0, T1, T2, ...>  item to any of the                         listed types to get the object of this type. The following sample code shows how to process the result set of a BQL                 statement joining two tables. // The static Select() method is called to execute a BQL command.
PXResultset<OrderLine> result =
    SelectFrom<OrderLine>.InnerJoin<SalesOrder>.
        On<SalesOrder.orderNbr.IsEqual<OrderLine.orderNbr>>.View.Select(this);

// Iterating over the result set:
// PXResult should be specialized with the DACs of all joined tables
// to be able to cast to these DACs.
foreach(PXResult<OrderLine, SalesOrder> record in result)
{
    // Casting a result set record to the OrderLine DAC:
    OrderLine detail = (OrderLine)record;
    // Casting a result set record to the SalesOrder DAC:
    SalesOrder order = (SalesOrder)record;
    ...
} Starting C# 7.0, you can also deconstruct the result set as shown in the following                 code                     example. (var line, var poLine, var _, var lotSerClass) = 
    (PXResult<POReceiptLine, POLine, InventoryItem, INLotSerClass>)
    SelectFrom<POReceiptLine>
    .LeftJoin<POLine>.On<POReceiptLine.FK.OrderLine>
    .LeftJoin<InventoryItem>.On<POReceiptLine.FK.InventoryItem>
    .LeftJoin<INLotSerClass>.On<InventoryItem.FK.LotSerClass>
    .Where<POReceiptLine.receiptType.IsEqual<@P.AsString>
        .And<POReceiptLine.receiptNbr.IsEqual<@P.AsString>>
        .And<POReceiptLine.lineNbr.IsEqual<@P.AsInt>>>
    .View.Select(Base, split.ReceiptType, split.ReceiptNbr, split.LineNbr); This                     code example is equivalent to the following                     code. var row = (PXResult<POReceiptLine, POLine, InventoryItem, INLotSerClass>)
    SelectFrom<POReceiptLine>
    .LeftJoin<POLine>.On<POReceiptLine.FK.OrderLine>
    .LeftJoin<InventoryItem>.On<POReceiptLine.FK.InventoryItem>
    .LeftJoin<INLotSerClass>.On<InventoryItem.FK.LotSerClass>
    .Where<POReceiptLine.receiptType.IsEqual<@P.AsString>
        .And<POReceiptLine.receiptNbr.IsEqual<@P.AsString>>
        .And<POReceiptLine.lineNbr.IsEqual<@P.AsInt>>>
    .View.Select(Base, split.ReceiptType, split.ReceiptNbr, split.LineNbr);
POReceiptLine line = row;
POLine poLine = row;
INLotSerClass lotSerClass = row; ]]></column>
		</row>
		<row PageID="f3436474-d5a9-40b3-98e9-23984b9b1416" Language="en-US" PageRevisionID="1" PlainText="Creating Fluent BQL Queries To query data from the database, you use the business query language (BQL), which has two     dialects: fluent BQL and traditional BQL. In this chapter, you can find information on how to create fluent BQL queries. For general     information about data querying, see  Querying Data in Acumatica Framework. For details     about building queries with traditional BQL, see  Creating Traditional BQL Queries. In This Chapter Fluent Business Query LanguageData Access Classes in Fluent BQLSearch and Select Commands and Data Views in Fluent BQLConstants in Fluent BQLParameters in Fluent BQLTo Select Records by Using Fluent BQLTo Use Parameters in Fluent BQL Queries" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="36dd4633-d3d7-5b13-d178-5706120de79f" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To query data from the database, you use the business query language (BQL), which has two dialects: fluent BQL and traditional BQL.{br}

In this chapter, you can find information on how to create fluent BQL queries. For general information about data querying, see [HelpRoot_Dev_Platform\AD__mng_Querying_Data|Querying Data in Acumatica Framework]. For details about building queries with traditional BQL, see [HelpRoot_Dev_Platform\AD__mng_Traditional_BQL|Creating Traditional BQL Queries].
==In This Chapter==[anchor|#_fdea5094-3248-4ffa-944e-19d5ae91bc7d]
{| class="checklist invisiblechecklist" | width="100%" 
|- 
| [anchor|#_e699c3c7-cb06-4867-b619-8e77f2a5c974]
*[HelpRoot_Dev_Platform\AD__con_Fluent_BQL|Fluent Business Query Language]
*[HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL]
*[HelpRoot_Dev_Platform\AD__con_View_Select_Search_in_Fluent_BQL|Search and Select Commands and Data Views in Fluent BQL]
*[HelpRoot_Dev_Platform\AD__con_Constants_in_FBQL|Constants in Fluent BQL]
*[HelpRoot_Dev_Platform\AC__con_Parameters_in_FBQL|Parameters in Fluent BQL]

| [anchor|#_e1f1faa0-c50a-4c10-b4f2-08ab4abd03f3]
*[HelpRoot_Dev_Platform\AD__how_Select_Records_in_Fluent_BQL|To Select Records by Using Fluent BQL]
*[HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL|To Use Parameters in Fluent BQL Queries]

|}]]></column>
		</row>
		<row PageID="ddc12506-3658-4f0a-b735-93bb0e035fd2" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e0e73ce6-29be-b334-e14d-7beca432f3b0" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Fluent business query language (BQL), which is described in this topic, is a dialect of BQL that is more similar to SQL than traditional BQL is. You can find all classes that can be used in fluent BQL in the <tt>PX.Data.BQL</tt> and <tt>PX.Data.BQL.Fluent</tt> namespaces.{br}{TOC}
==Fluent BQL Structure==
Fluent BQL uses nesting of generic classes. That is, each section of a fluent BQL query does not depend on the other sections and can appear in only specific places of the query. The order of the sections is shown in the following code.<source lang="csharp">SelectFrom&lt;&gt;.[Joins].Where&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;</source>{br}

<tt>SelectFrom&lt;&gt;</tt> is the only mandatory part of the query. You can add to the query any number of <tt>Join</tt> sections and the <tt>Where&lt;&gt;</tt>, <tt>AggregateTo&lt;&gt;</tt>, and <tt>OrderBy&lt;&gt;</tt> sections of the query, depending on whether you need the corresponding clauses of the query. {br}

The query defined with fluent BQL as described above is equivalent to the <tt>Select</tt> command in traditional BQL. To compose a query for different purposes (such as to define a data view or to define a <tt>Search</tt> command in an attribute constructor), you need to prepend additional elements to the query or append them to the query, as described in [HelpRoot_Dev_Platform\AD__con_View_Select_Search_in_Fluent_BQL|Search and Select Commands and Data Views in Fluent BQL]. You can find the equivalents of traditional BQL in fluent BQL in [HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents].
==SelectFrom&lt;&gt; Section==
In the <tt>SelectFrom&lt;&gt;</tt> section of the query, you use the <tt>SelectFrom&lt;&gt;</tt> class, which uses a data access class (DAC) as the type parameter. For details on DACs, see [HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL].
==Join Sections==
Each <tt>Join</tt> section of the fluent BQL query consists of the following components: [anchor|#_991dcc7d-c1cd-4545-8c77-75f9ba044900]
*The join type (<tt>InnerJoin&lt;&gt;</tt>, <tt>LeftJoin&lt;&gt;</tt>, <tt>RightJoin&lt;&gt;</tt>, <tt>FullJoin&lt;&gt;</tt>, <tt>CrossJoin&lt;&gt;</tt>) with the joined DAC as the type parameter.
*The joining condition (<tt>On&lt;&gt;</tt>). This condition is not specified for <tt>CrossJoin&lt;&gt;</tt>.
*The single table modifier (<tt>SingleTableOnly</tt>). This optional part of each <tt>Join</tt> section forces optimization if a DAC used in the query has the [https://help.acumatica.com/(W(3))/Main?ScreenId=ShowWiki&pageid=2331ae85-d8bc-88a4-a205-d9d41825f447|<tt>PXProjection</tt>] attribute.
The following code fragments show the <tt>Join</tt> sections with different types of joins.<source lang="csharp">.InnerJoin&lt;TBqlTable&gt;.On&lt;TJoinCondition&gt;.SingleTableOnly

.LeftJoin&lt;TBqlTable&gt;.On&lt;TJoinCondition&gt;.SingleTableOnly

.RightJoin&lt;TBqlTable&gt;.On&lt;TJoinCondition&gt;.SingleTableOnly

.FullJoin&lt;TBqlTable&gt;.On&lt;TJoinCondition&gt;.SingleTableOnly

.CrossJoin&lt;TBqlTable&gt;.SingleTableOnly</source>{br}

Fluent BQL queries can contain any number of <tt>Join</tt> sections.
==Where&lt;&gt; Section and On&lt;&gt; Subsection==
Conditions in the query are defined in the <tt>Where&lt;&gt;</tt> section and the <tt>On&lt;&gt;</tt> subsections of the <tt>Join</tt> sections. The conditions can contain the following nested components:[anchor|#_08c7560f-8a4f-41f5-86cf-fc163b4f8734]
*Comparisons, such as {{Table.field.IsEqual<TOperand>}}
*<tt>And&lt;&gt;</tt> subsections
*<tt>Or&lt;&gt;</tt> subsections
*<tt>Brackets&lt;&gt;</tt> subsections
{br}

The following code fragments show examples of an <tt>On&lt;&gt;</tt> subsection and a <tt>Where&lt;&gt;</tt> section.<source lang="csharp">.On&lt;PMTask.projectID.IsEqual&lt;PMProject.contractID&gt;.
  And&lt;
    PMTask.approverID.IsEqual&lt;EPActivityFilter.approverID.FromCurrent&gt;&gt;&gt;

.Where&lt;PMProject.isActive.IsEqual&lt;True&gt;.
  And&lt;PMTask.taskID.IsNotNull.
    Or&lt;PMProject.approverID.IsEqual&lt;
      EPActivityFilter.approverID.FromCurrent&gt;&gt;&gt;&gt;</source>
==AggregateTo&lt;&gt; and OrderBy&lt;&gt; Sections==
The <tt>AggregateTo&lt;&gt;</tt> and <tt>OrderBy&lt;&gt;</tt> sections of a fluent BQL query accept non-empty arrays of the specific base type as the only generic parameters. To make it easier for developers to write and read of the queries, fluent BQL includes groups of aliases that embed certain array usage. These aliases are pregenerated for arrays with up to 32 elements. {br}

The <tt>AggregateTo&lt;&gt;</tt> section can also include an optional <tt>Having&lt;&gt;</tt> subsection. In this subsection, you include conditions that can contain only logical operators, constants, parameters, and aggregated fields (that is, the fields with <tt>.Averaged</tt>, <tt>.Summarized</tt>, <tt>.Maximized</tt>, <tt>.Minimized</tt>, or <tt>.Grouped</tt> appended). {br}

The following code fragments show examples of <tt>AggregateTo&lt;&gt;</tt> and <tt>OrderBy&lt;&gt;</tt> sections.<source lang="csharp">.AggregateTo&lt;Sum&lt;field1&gt;, GroupBy&lt;field2&gt;, Max&lt;field3&gt;, 
  Min&lt;field4&gt;, Avg&lt;field5&gt;, Count&lt;field6&gt;&gt;.
    Having&lt;field5.Averaged.IsGreater&lt;Zero&gt;&gt;

.OrderBy&lt;field1.Asc, field2.Desc, field3.Asc&gt;</source>
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_View_Select_Search_in_Fluent_BQL|Search and Select Commands and Data Views in Fluent BQL]
*[HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL]
*[HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents]]]></column>
			<column name="PlainText"><![CDATA[Fluent Business Query Language Fluent business query language (BQL), which is described in this topic, is a dialect of BQL         that is more similar to SQL than traditional BQL is. You can find all classes that can be         used in fluent BQL in the  PX.Data.BQL  and            PX.Data.BQL.Fluent  namespaces. Fluent BQL Structure Fluent BQL uses nesting of generic classes. That is, each section of a fluent BQL query does         not depend on the other sections and can appear in only specific places of the query. The         order of the sections is shown in the following         code. SelectFrom<>.[Joins].Where<>.AggregateTo<>.OrderBy<> SelectFrom<>  is the only mandatory part of the query. You can add to         the query any number of  Join  sections and the            Where<> ,  AggregateTo<> , and            OrderBy<>  sections of the query, depending on whether you need the         corresponding clauses of the query.  The query defined with fluent BQL as described above is equivalent to the            Select  command in traditional BQL. To compose a query for different         purposes (such as to define a data view or to define a  Search  command in         an attribute constructor), you need to prepend additional elements to the query or append         them to the query, as described in  Search and Select Commands and Data Views in Fluent BQL. You can find the equivalents of         traditional BQL in fluent BQL in  Fluent BQL and Traditional BQL Equivalents. SelectFrom<> Section In the  SelectFrom<>  section of the query, you use the            SelectFrom<>  class, which uses a data access class (DAC) as the         type parameter. For details on DACs, see  Data Access Classes in Fluent BQL. Join Sections Each  Join  section of the fluent BQL query consists of the following         components:  The join type ( InnerJoin<> ,  LeftJoin<> ,                RightJoin<> ,  FullJoin<> ,                CrossJoin<> ) with the joined DAC as the type parameter. The joining condition ( On<> ). This condition is not specified             for  CrossJoin<> . The single table modifier ( SingleTableOnly ). This optional part of             each  Join  section forces optimization if a DAC used in the query has             the  PXProjection <tt>PXProjection</tt> attribute. The following code fragments show the  Join  sections with different         types of         joins. .InnerJoin<TBqlTable>.On<TJoinCondition>.SingleTableOnly

.LeftJoin<TBqlTable>.On<TJoinCondition>.SingleTableOnly

.RightJoin<TBqlTable>.On<TJoinCondition>.SingleTableOnly

.FullJoin<TBqlTable>.On<TJoinCondition>.SingleTableOnly

.CrossJoin<TBqlTable>.SingleTableOnly Fluent BQL queries can contain any number of  Join  sections. Where<> Section and On<> Subsection Conditions in the query are defined in the  Where<>  section and the            On<>  subsections of the  Join  sections. The         conditions can contain the following nested components: Comparisons, such as  Table.field.IsEqual<TOperand> And<>  subsections Or<>  subsections Brackets<>  subsections The following code fragments show examples of an  On<>  subsection and a            Where<>          section. .On<PMTask.projectID.IsEqual<PMProject.contractID>.
  And<
    PMTask.approverID.IsEqual<EPActivityFilter.approverID.FromCurrent>>>

.Where<PMProject.isActive.IsEqual<True>.
  And<PMTask.taskID.IsNotNull.
    Or<PMProject.approverID.IsEqual<
      EPActivityFilter.approverID.FromCurrent>>>> AggregateTo<> and OrderBy<> Sections The  AggregateTo<>  and  OrderBy<>  sections of a         fluent BQL query accept non-empty arrays of the specific base type as the only generic         parameters. To make it easier for developers to write and read of the queries, fluent BQL         includes groups of aliases that embed certain array usage. These aliases are pregenerated         for arrays with up to 32 elements.  The  AggregateTo<>  section can also include an optional            Having<>  subsection. In this subsection, you include conditions that         can contain only logical operators, constants, parameters, and aggregated fields (that is,         the fields with  .Averaged ,  .Summarized ,            .Maximized ,  .Minimized , or            .Grouped  appended).  The following code fragments show examples of  AggregateTo<>  and            OrderBy<>          sections. .AggregateTo<Sum<field1>, GroupBy<field2>, Max<field3>, 
  Min<field4>, Avg<field5>, Count<field6>>.
    Having<field5.Averaged.IsGreater<Zero>>

.OrderBy<field1.Asc, field2.Desc, field3.Asc> ]]></column>
		</row>
		<row PageID="957f950d-22cd-4b2f-81ca-77464d0c9eff" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="37902d7e-8752-4a12-c08b-c99922080f92" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The data access classes (DACs) that are used in fluent BQL differ from the DACs that are used in traditional BQL in the declarations of the class fields. For the general information about the declaration of DACs for both traditional BQL and fluent BQL, see [HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes].{br}

Each class field of a DAC (that is, each {{public abstract}} class of a DAC) is strongly typed, which makes it possible to perform compile-time code checks in Visual Studio. You derive class fields not from the <tt>IBqlField</tt> interface (as you would in traditional BQL) but from the specific fluent BQL classes that correspond to the type of the property field as shown in the following table. You assign the class field a name that starts with a lowercase letter.[anchor|#_fd84963d-fcc7-4e2a-a39f-869e681c297f]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Type of the Property Field
!width="50%" ! Type of the Class Field
|- 
| {{bool}}
| <tt>BqlBool.Field&lt;TSelf&gt;</tt>
|- 
| {{byte}}
| <tt>BqlByte.Field&lt;TSelf&gt;</tt>
|- 
| {{short}}
| <tt>BqlShort.Field&lt;TSelf&gt;</tt>
|- 
| {{int}}
| <tt>BqlInt.Field&lt;TSelf&gt;</tt>
|- 
| {{long}}
| <tt>BqlLong.Field&lt;TSelf&gt;</tt>
|- 
| {{float}}
| <tt>BqlFloat.Field&lt;TSelf&gt;</tt>
|- 
| {{double}}
| <tt>BqlDouble.Field&lt;TSelf&gt;</tt>
|- 
| {{decimal}}
| <tt>BqlDecimal.Field&lt;TSelf&gt;</tt>
|- 
| {{Guid}}
| <tt>BqlGuid.Field&lt;TSelf&gt;</tt>
|- 
| {{DateTime}}
| <tt>BqlDateTime.Field&lt;TSelf&gt;</tt>
|- 
| {{String}}
| <tt>BqlString.Field&lt;TSelf&gt;</tt>
|- 
| {{byte[]}}
| <tt>BqlByteArray.Field&lt;TSelf&gt;</tt>
|}
The following code shows an example of the <tt>Product</tt> DAC declaration.<source lang="csharp">using System;
using PX.Data;

[Serializable]
public class Product : PX.Data.IBqlTable
{
    // The class used in BQL statements to refer to the ProductID column
    public abstract class productID : PX.Data.BQL.BqlInt.Field&lt;productID&gt;
    {
    }
    // The property holding the ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }

    // The class used in BQL statements to refer to the AvailQty column
    public abstract class availQty : PX.Data.BQL.BqlDecimal.Field&lt;availQty&gt;
    {
    }
    // The property holding the AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
}</source>
==Simultaneous Use of DACs in Fluent BQL and Traditional BQL==
The DAC fields declared in fluent BQL style can be used in traditional BQL queries without any modifications.{br}

The class fields that are defined in the traditional BQL style (as described in [HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes]) can be used in fluent BQL queries if you wrap these fields in the <tt>Use&lt;&gt;.As&#91;Type&#93;</tt> class, where {{[Type]}} is one of the following: {{Bool}}, {{Byte}}, {{Short}}, {{Int}}, {{Long}}, {{Float}}, {{Double}}, {{Decimal}}, {{Guid}}, {{DateTime}}, {{String}}, or {{ByteArray}}. {br}

The following code shows the definition of the {{availQty}} class field in the traditional BQL style and its use in a fluent BQL comparison.<source lang="csharp">public class Product : PX.Data.IBqlTable
{
    public abstract class availQty : PX.Data.IBqlField
    {
    }
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
}

SelectFrom&lt;Product&gt;.
    Where&lt;Use&lt;Product.availQty&gt;.AsDecimal.IsNotEqual&lt;Zero&gt;&gt;.
    View AvailableProducts;</source>{br}

Though the DAC fields in the traditional BQL style can be used in fluent BQL queries, we recommend that you use the fluent BQL style of DAC declaration for simplicity. 
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes]]]></column>
			<column name="PlainText"><![CDATA[Data Access Classes in Fluent BQL The data access classes (DACs) that are used in fluent BQL differ from the DACs that                 are used in traditional BQL in the declarations of the class fields. For the general                 information about the declaration of DACs for both traditional BQL and fluent BQL,                 see  Data Access Classes. Each class field of a DAC (that is, each  public abstract  class of a                 DAC) is strongly typed, which makes it possible to perform compile-time code checks                 in Visual Studio. You derive class fields not from the  IBqlField                  interface (as you would in traditional BQL) but from the specific fluent BQL classes                 that correspond to the type of the property field as shown in the following table.                 You assign the class field a name that starts with a lowercase letter. Type of the Property Field Type of the Class Field bool BqlBool.Field<TSelf> byte BqlByte.Field<TSelf> short BqlShort.Field<TSelf> int BqlInt.Field<TSelf> long BqlLong.Field<TSelf> float BqlFloat.Field<TSelf> double BqlDouble.Field<TSelf> decimal BqlDecimal.Field<TSelf> Guid BqlGuid.Field<TSelf> DateTime BqlDateTime.Field<TSelf> String BqlString.Field<TSelf> byte[] BqlByteArray.Field<TSelf> The following code shows an example of the  Product  DAC                 declaration. using System;
using PX.Data;

[Serializable]
public class Product : PX.Data.IBqlTable
{
    // The class used in BQL statements to refer to the ProductID column
    public abstract class productID : PX.Data.BQL.BqlInt.Field<productID>
    {
    }
    // The property holding the ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }

    // The class used in BQL statements to refer to the AvailQty column
    public abstract class availQty : PX.Data.BQL.BqlDecimal.Field<availQty>
    {
    }
    // The property holding the AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
} Simultaneous Use of DACs in Fluent BQL and Traditional BQL The DAC fields declared in fluent BQL style can be used in traditional BQL queries                 without any modifications. The class fields that are defined in the traditional BQL style (as described in  Data Access Classes) can be used in fluent BQL queries if you wrap                 these fields in the  Use<>.As[Type]  class, where                      [Type]  is one of the following:  Bool ,                      Byte ,  Short ,  Int ,                      Long ,  Float ,  Double ,                      Decimal ,  Guid ,  DateTime ,                      String , or  ByteArray .  The following code shows the definition of the  availQty  class field                 in the traditional BQL style and its use in a fluent BQL                 comparison. public class Product : PX.Data.IBqlTable
{
    public abstract class availQty : PX.Data.IBqlField
    {
    }
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
}

SelectFrom<Product>.
    Where<Use<Product.availQty>.AsDecimal.IsNotEqual<Zero>>.
    View AvailableProducts; Though the DAC fields in the traditional BQL style can be used in fluent BQL queries,                 we recommend that you use the fluent BQL style of DAC declaration for simplicity.  ]]></column>
		</row>
		<row PageID="89612b68-c812-438a-86c4-05b295d450c5" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="04a66740-d133-c952-9f4c-a57c637b163b" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use fluent business query language (BQL) to define data views and specify <tt>Select</tt> and <tt>Search</tt> commands. {br}{TOC}
==Data Views==
You can use any of the following approaches to define a data view:[anchor|#_8d8e7d7f-8520-4c11-99b3-c11e839407a8]
*Use the <tt>PXViewOf&lt;&gt;</tt> class before the fluent BQL query, as shown in the following code example.<source lang="csharp">PXViewOf&lt;Product&gt;.BasedOn&lt;
    SelectFrom&lt;Product&gt;.
        Where&lt;Product.isActive.IsEqual&lt;True&gt;&gt;&gt;.ReadOnly ActiveProducts;</source>
*:The DACs that are specified as type parameters in <tt>PXViewOf&lt;&gt;</tt> and <tt>SelectFrom&lt;&gt;</tt> must be the same; this is checked by the compiler. You can omit <tt>.BasedOn&lt;&gt;</tt> if you want to declare a view that selects all records from one table. You append <tt>.ReadOnly</tt> to the view definition if you need to define a read-only data view.
*Append <tt>.View</tt> to the fluent BQL query, as shown in the following code example.<source lang="csharp">SelectFrom&lt;Product&gt;.
    Where&lt;Product.isActive.IsEqual&lt;True&gt;&gt;.View.ReadOnly ActiveProducts;</source>
*:You append <tt>.ReadOnly</tt> to the view definition if you need to define a read-only data view.
{br}

The data views defined with fluent BQL are equivalent to the corresponding traditional BQL data views. For the full list of equivalents, see [HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents]. Also, the fluent BQL data views have the same static methods as the traditional BQL data views have. 
==Select Commands==
The query defined with fluent BQL, as described in [HelpRoot_Dev_Platform\AD__con_Fluent_BQL|Fluent Business Query Language], is equivalent to the <tt>Select</tt> BQL command. For the full list of equivalents, see [HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents].
==Search Commands==
You can use any of the following approaches to define a <tt>Search</tt> BQL command:[anchor|#_80ca7272-8156-494a-bc74-d0a322f0aa7e]
*Use the <tt>SearchFor&lt;&gt;</tt> class before the fluent BQL query, as shown in the following code example.<source lang="csharp">SearchFor&lt;Product.productId&gt;.In&lt;
    SelectFrom&lt;Product&gt;.
        Where&lt;Product.isActive.IsEqual&lt;True&gt;&gt;&gt;</source>
*Append <tt>.SearchFor&lt;&gt;</tt> to the fluent BQL query, as shown in the following code example.<source lang="csharp">SelectFrom&lt;Product&gt;.
    Where&lt;Product.isActive.IsEqual&lt;True&gt;&gt;.SearchFor&lt;Product.productId&gt;</source>
{br}

The <tt>Search</tt> commands defined with fluent BQL are equivalent to the corresponding traditional BQL commands. For the full list of equivalents, see [HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents].
==Dynamic Query Building==
Because <tt>SearchFor&lt;&gt;</tt> and <tt>SelectFrom&lt;&gt;</tt> are derived from the <tt>BqlCommand</tt> class, they can be used in dynamic query building through the <tt>WhereAnd</tt>, <tt>AppendJoin</tt>, and <tt>OrderByNew</tt> functions. However, fluent BQL commands (which are derived from the <tt>FbqlCommand</tt> class) aren&rsquo;t decomposed by <tt>BqlCommand.Decompose()</tt> directly. That is, the <tt>Decompose</tt> function checks whether a command has a <tt>FbqlCommand</tt> type, retrieves the type of its underlying <tt>BqlCommand</tt>, and decomposes this underlying <tt>BqlCommand</tt> command. Therefore, the elements of the array produced by the <tt>Decompose</tt> function are components of the <tt>BqlCommand</tt>, and are not components of the passed <tt>FbqlCommand</tt>. {br}

<tt>PXViewOf&lt;TBqlTable&gt;</tt> also supports all dynamic query building actions that the traditional BQL <tt>PXView</tt> supports.
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Fluent_BQL|Fluent Business Query Language]
*[HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents]]]></column>
			<column name="PlainText"><![CDATA[Search and Select Commands and Data Views in Fluent BQL You can use fluent business query language (BQL) to define data views and specify            Select  and  Search  commands.  Data Views You can use any of the following approaches to define a data view: Use the  PXViewOf<>  class before the fluent BQL query, as shown             in the following code               example. PXViewOf<Product>.BasedOn<
    SelectFrom<Product>.
        Where<Product.isActive.IsEqual<True>>>.ReadOnly ActiveProducts; The               DACs that are specified as type parameters in  PXViewOf<>  and                  SelectFrom<>  must be the same; this is checked by the               compiler. You can omit  .BasedOn<>  if you want to declare a view               that selects all records from one table. You append  .ReadOnly  to               the view definition if you need to define a read-only data view. Append  .View  to the fluent BQL query, as shown in the following             code               example. SelectFrom<Product>.
    Where<Product.isActive.IsEqual<True>>.View.ReadOnly ActiveProducts; You               append  .ReadOnly  to the view definition if you need to define a               read-only data view. The data views defined with fluent BQL are equivalent to the corresponding traditional BQL         data views. For the full list of equivalents, see  Fluent BQL and Traditional BQL Equivalents. Also, the fluent BQL data views have         the same static methods as the traditional BQL data views have.  Select Commands The query defined with fluent BQL, as described in  Fluent Business Query Language,         is equivalent to the  Select  BQL command. For the full list of         equivalents, see  Fluent BQL and Traditional BQL Equivalents. Search Commands You can use any of the following approaches to define a  Search  BQL           command: Use the  SearchFor<>  class before the fluent BQL query, as shown             in the following code             example. SearchFor<Product.productId>.In<
    SelectFrom<Product>.
        Where<Product.isActive.IsEqual<True>>> Append  .SearchFor<>  to the fluent BQL query, as shown in the             following code             example. SelectFrom<Product>.
    Where<Product.isActive.IsEqual<True>>.SearchFor<Product.productId> The  Search  commands defined with fluent BQL are equivalent to the         corresponding traditional BQL commands. For the full list of equivalents, see  Fluent BQL and Traditional BQL Equivalents. Dynamic Query Building Because  SearchFor<>  and  SelectFrom<>  are         derived from the  BqlCommand  class, they can be used in dynamic query         building through the  WhereAnd ,  AppendJoin , and            OrderByNew  functions. However, fluent BQL commands (which are derived         from the  FbqlCommand  class) aren't decomposed by            BqlCommand.Decompose()  directly. That is, the            Decompose  function checks whether a command has a            FbqlCommand  type, retrieves the type of its underlying            BqlCommand , and decomposes this underlying            BqlCommand  command. Therefore, the elements of the array produced by         the  Decompose  function are components of the            BqlCommand , and are not components of the passed            FbqlCommand .  PXViewOf<TBqlTable>  also supports all dynamic query building actions         that the traditional BQL  PXView  supports. ]]></column>
		</row>
		<row PageID="84837158-8b2f-4f18-b51d-4c89bc165dc4" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="c55ad824-dd0a-8808-0dbb-707945c09c67" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use predefined constants (such as integer <tt>Zero</tt>, datetime <tt>Now</tt>, <tt>Today</tt>, and <tt>MaxDate</tt>, string <tt>StringEmpty</tt>, and the Boolean values <tt>True</tt> and <tt>False</tt>) in fluent BQL queries without any changes.{br}

If you need to use a custom constant in a fluent BQL query, you define this constant by using the class that corresponds to the C# type of the constant. The following table lists the constant classes that correspond to C# types.[anchor|#_a8937995-2493-4cbb-a00e-3311c19fe60e]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! C# Type
!width="50%" ! Fluent BQL Type
|- 
| {{bool}}
| <tt>BqlBool.Constant&lt;TSelf&gt;</tt>
|- 
| {{byte}}
| <tt>BqlByte.Constant&lt;TSelf&gt;</tt>
|- 
| {{short}}
| <tt>BqlShort.Constant&lt;TSelf&gt;</tt>
|- 
| {{int}}
| <tt>BqlInt.Constant&lt;TSelf&gt;</tt>
|- 
| {{long}}
| <tt>BqlLong.Constant&lt;TSelf&gt;</tt>
|- 
| {{float}}
| <tt>BqlFloat.Constant&lt;TSelf&gt;</tt>
|- 
| {{double}}
| <tt>BqlDouble.Constant&lt;TSelf&gt;</tt>
|- 
| {{decimal}}
| <tt>BqlDecimal.Constant&lt;TSelf&gt;</tt>
|- 
| {{Guid}}
| <tt>BqlGuid.Constant&lt;TSelf&gt;</tt>
|- 
| {{DateTime}}
| <tt>BqlDateTime.Constant&lt;TSelf&gt;</tt>
|- 
| {{String}}
| <tt>BqlString.Constant&lt;TSelf&gt;</tt>
|}{br}

The following code shows an example of the {{decimal_0}} constant declaration.<source lang="csharp">public class decimal_0 : PX.Data.BQL.BqlDecimal.Constant&lt;decimal_0&gt; 
{ 
  public decimal_0()
    : base(0m)
  {
  }
}</source>
==Simultaneous Use of Constants in Fluent BQL and Traditional BQL==
The predefined constants and the constants defined as described in the previous section can be used in traditional BQL without any changes. {br}

The constants defined in the traditional BQL style (that is, derived from the <tt>Constant&lt;Type&gt;</tt> class) can be used in the fluent BQL queries if you wrap these constants in the <tt>Use&lt;&gt;.As&#91;Type&#93;</tt> class, where {{[Type]}} is one of the following: {{Bool}}, {{Byte}}, {{Short}}, {{Int}}, {{Long}}, {{Float}}, {{Double}}, {{Decimal}}, {{Guid}}, {{DateTime}}, or {{String}}. {br}

The following code shows the declaration of the {{decimal_0}} constant in traditional BQL style and its use in a fluent BQL comparison.<source lang="csharp">publicclass decimal_0 : Constant&lt;Decimal&gt;
{
    public decimal_0()
        : base(0m)
    {
    }
}

SelectFrom&lt;Table&gt;.
    Where&lt;Table.decimalField.AsDecimal.IsEqual&lt;Use&lt;decimal_0&gt;.AsDecimal&gt;&gt;.
    View records;</source>{br}

Although the constants in the traditional BQL style can be used in fluent BQL queries, we recommend that you use the fluent BQL style of constant declaration for simplicity. ]]></column>
			<column name="PlainText"><![CDATA[Constants in Fluent BQL You can use predefined constants (such as integer  Zero , datetime       Now ,  Today , and  MaxDate , string       StringEmpty , and the Boolean values  True  and       False ) in fluent BQL queries without any changes. If you need to use a custom constant in a fluent BQL query, you define this constant by using     the class that corresponds to the C# type of the constant. The following table lists the     constant classes that correspond to C# types. C# Type Fluent BQL Type bool BqlBool.Constant<TSelf> byte BqlByte.Constant<TSelf> short BqlShort.Constant<TSelf> int BqlInt.Constant<TSelf> long BqlLong.Constant<TSelf> float BqlFloat.Constant<TSelf> double BqlDouble.Constant<TSelf> decimal BqlDecimal.Constant<TSelf> Guid BqlGuid.Constant<TSelf> DateTime BqlDateTime.Constant<TSelf> String BqlString.Constant<TSelf> The following code shows an example of the  decimal_0  constant     declaration. public class decimal_0 : PX.Data.BQL.BqlDecimal.Constant<decimal_0> 
{ 
  public decimal_0()
    : base(0m)
  {
  }
} Simultaneous Use of Constants in Fluent BQL and Traditional BQL The predefined constants and the constants defined as described in the previous section can be     used in traditional BQL without any changes.  The constants defined in the traditional BQL style (that is, derived from the       Constant<Type>  class) can be used in the fluent BQL queries if you     wrap these constants in the  Use<>.As[Type]  class, where       [Type]  is one of the following:  Bool ,  Byte ,       Short ,  Int ,  Long ,  Float ,       Double ,  Decimal ,  Guid ,       DateTime , or  String .  The following code shows the declaration of the  decimal_0  constant in     traditional BQL style and its use in a fluent BQL     comparison. publicclass decimal_0 : Constant<Decimal>
{
    public decimal_0()
        : base(0m)
    {
    }
}

SelectFrom<Table>.
    Where<Table.decimalField.AsDecimal.IsEqual<Use<decimal_0>.AsDecimal>>.
    View records; Although the constants in the traditional BQL style can be used in fluent BQL queries, we     recommend that you use the fluent BQL style of constant declaration for simplicity.  ]]></column>
		</row>
		<row PageID="9d56ea11-0768-4f4d-b7ab-1cea724c42cb" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8ccb9efc-301f-a43f-b8b8-3ce7b026c9bd" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you need to specify values in a fluent business query language (BQL) statement, you use fluent BQL parameters, which are replaced with the needed values in the translation to SQL. For details about how BQL statements with parameters are translated to SQL, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL#_ff6436a7-d8a9-43c8-9201-d5ea9afbe2d5|Translation of a BQL Command with Parameters to an SQL Query Tree].{br}

In this topic, you can find a description of the fluent BQL parameters and the difference between them.{br}{TOC}
==Use of the Current Value of the Field from PXCache==
To insert into the SQL query the field value of the <tt>Current</tt> object from the <tt>PXCache</tt> object, you append <tt>.FromCurrent</tt> to the field name in a fluent BQL query. If the <tt>Current</tt> object from the <tt>PXCache</tt> object is {{null}}, <tt>FromCurrent</tt> retrieves the default value of the field. If you do not need to retrieve the default value if the <tt>Current</tt> object is {{null}}, you need to append <tt>.FromCurrent.NoDefault</tt> to the field name in a fluent BQL query. In this case, the system doesn&rsquo;t retrieve the default value and inserts {{null}}.{br}

((({S:Warn}<tt>FromCurrent</tt> is the equivalent of the <tt>Current</tt> parameter in traditional BQL. <tt>FromCurrent.NoDefault</tt> is the equivalent of the <tt>Current2</tt> parameter in traditional BQL.
))){br}

By using the current field value from <tt>PXCache</tt> in the declaration of a data view, you can refer to another view to relate these data views to each other. A typical example is referencing the current master record on master-detail forms. For details on how the current field value is used, see [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL#_27cf551c-951d-463a-9005-74584894a725|To Relate Data Views to Each Another].
==Insertion of a Specific Value into the Query==
To insert a specific value into the SQL query, you use the <tt>@P.As&#91;Type&#93;</tt> classes, where <tt>&#91;Type&#93;</tt> corresponds to the C# type of the parameter. The following table lists the fluent BQL types that correspond to C# types.[anchor|#_2acba4b9-005f-40c9-bb43-efa627ae5120]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! C# Type
!width="50%" ! Fluent BQL Type
|- 
| {{bool}}
| <tt>@P.AsBool</tt>
|- 
| {{byte}}
| <tt>@P.AsByte</tt>
|- 
| {{short}}
| <tt>@P.AsShort</tt>
|- 
| {{int}}
| <tt>@P.AsInt</tt>
|- 
| {{long}}
| <tt>@P.AsLong</tt>
|- 
| {{float}}
| <tt>@P.AsFloat</tt>
|- 
| {{double}}
| <tt>@P.AsDouble</tt>
|- 
| {{decimal}}
| <tt>@P.AsDecimal</tt>
|- 
| {{Guid}}
| <tt>@P.AsGuid</tt>
|- 
| {{DateTime}}
| <tt>@P.AsDateTime</tt>
|- 
| {{String}}
| <tt>@P.AsString</tt>
|}((({S:Warn} <tt>@P.As&#91;Type&#93;</tt> is the equivalent of the <tt>Required</tt> parameter in traditional BQL.
)))
By using these classes, you can pass values to the SQL query, as described in [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL#_6e19063a-c756-4b7d-88a0-7d0100a187d9|To Pass a Field Value to the SQL Query] and [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL#_cc3c4e58-b049-4351-b3c6-ebd9e62a350d|To Pass Multiple Field Values to the SQL Query].
==Insertion of an Optional Value into the Query==
To insert an optional value into the query, you append <tt>.AsOptional</tt> to the field name in a fluent BQL query. If you specify an explicit value for this parameter during the execution of the BQL statement, <tt>AsOptional</tt> uses the specified value. If you don&rsquo;t specify an explicit value for this parameter during the execution of the BQL statement, <tt>AsOptional</tt> works similarly to <tt>FromCurrent</tt>—that is, retrieves the field value of the <tt>Current</tt> object from the <tt>PXCache</tt> object and uses the default value of the field if the <tt>Current</tt> object is {{null}}. You can append <tt>.AsOptional.NoDefault</tt> to the field name in a fluent BQL query to make the system not use the default value and insert {{null}}.((({S:Warn}<tt>AsOptional</tt> is the equivalent of the <tt>Optional</tt> parameter in traditional BQL. <tt>AsOptional.NoDefault</tt> is the equivalent of the <tt>Optional2</tt> parameter in traditional BQL.
)))
By using <tt>AsOptional</tt>, you can pass the external presentations of the values to the SQL query, as described in [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL#_4473b629-e9a7-4f41-9041-c0442303d2be|To Provide External Presentation of the Field Value to the SQL Query].{br}

When a DAC includes more than one key field, you may need to use <tt>.AsOptional</tt> in the primary data view of the graph. In this case, the primary data view typically filters the data records by all of the key fields except the last one. For example, you can select documents with the same document type as the current data record has and navigate through these documents with different document numbers. In the following example, the {{Document}} DAC has two key fields, {{DocType}} and {{DocNbr}}.<source lang="csharp">public SelectFrom&lt;Document&gt;.
        Where&lt;Document.docType.IsEqual&lt;<b>Document.docType.AsOptional<b>&gt;&gt;.View Receipts;</source>
<tt>.AsOptional</tt> could be replaced with <tt>.FromCurrent</tt> in the code above unless you need to execute the {{Receipts}} data view in code to select a document with specific document type and number.
==Insertion of a Value from the UI Control into the Query==
To insert a value from the UI control into the SQL query, you use the <tt>Argument.As&#91;Type&#93;</tt> classes, where <tt>&#91;Type&#93;</tt> corresponds to the C# type of the inserted value. The following table lists the fluent BQL types that correspond to C# types.[anchor|#_9fff804f-5503-4bc6-aaa2-d55fa0551358]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! C# Type
!width="50%" ! Fluent BQL Type
|- 
| {{bool}}
| <tt>Argument.AsBool</tt>
|- 
| {{byte}}
| <tt>Argument.AsByte</tt>
|- 
| {{short}}
| <tt>Argument.AsShort</tt>
|- 
| {{int}}
| <tt>Argument.AsInt</tt>
|- 
| {{long}}
| <tt>Argument.AsLong</tt>
|- 
| {{float}}
| <tt>Argument.AsFloat</tt>
|- 
| {{double}}
| <tt>Argument.AsDouble</tt>
|- 
| {{decimal}}
| <tt>Argument.AsDecimal</tt>
|- 
| {{Guid}}
| <tt>Argument.AsGuid</tt>
|- 
| {{DateTime}}
| <tt>Argument.AsDateTime</tt>
|- 
| {{String}}
| <tt>Argument.AsString</tt>
|}{br}

By using the <tt>Argument</tt> classes, you can pass values to the data view delegates. For more information on how to use the <tt>Argument</tt> classes, see [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL#_1f3bef64-92a7-469f-9fd2-89f0910565fe|To Pass a Value from a UI Control to a Data View].
==Related Articles==
*[HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL|To Use Parameters in Fluent BQL Queries]]]></column>
			<column name="PlainText"><![CDATA[Parameters in Fluent BQL If you need to specify values in a fluent business query language (BQL) statement, you use     fluent BQL parameters, which are replaced with the needed values in the translation to SQL. For     details about how BQL statements with parameters are translated to SQL, see  Translation of a BQL Command with Parameters to an SQL Query Tree. In this topic, you can find a description of the fluent BQL parameters and the difference     between them. Use of the Current Value of the Field from PXCache To insert into the SQL query the field value of the  Current  object from the       PXCache  object, you append  .FromCurrent  to the field name     in a fluent BQL query. If the  Current  object from the       PXCache  object is  null ,  FromCurrent      retrieves the default value of the field. If you do not need to retrieve the default value if     the  Current  object is  null , you need to append       .FromCurrent.NoDefault  to the field name in a fluent BQL query. In this     case, the system doesn't retrieve the default value and inserts  null . FromCurrent  is the equivalent of the  Current       parameter in traditional BQL.  FromCurrent.NoDefault  is the equivalent of the        Current2  parameter in traditional BQL. By using the current field value from  PXCache  in the declaration of a data     view, you can refer to another view to relate these data views to each other. A typical example     is referencing the current master record on master-detail forms. For details on how the current     field value is used, see  To Relate Data Views to Each Another. Insertion of a Specific Value into the Query To insert a specific value into the SQL query, you use the  @P.As[Type]      classes, where  [Type]  corresponds to the C# type of the parameter. The     following table lists the fluent BQL types that correspond to C# types. C# Type Fluent BQL Type bool @P.AsBool byte @P.AsByte short @P.AsShort int @P.AsInt long @P.AsLong float @P.AsFloat double @P.AsDouble decimal @P.AsDecimal Guid @P.AsGuid DateTime @P.AsDateTime String @P.AsString @P.As[Type]  is the equivalent of the  Required      parameter in traditional BQL. By using these classes, you can pass values to the SQL query, as described in  To Pass a Field Value to the SQL Query and  To Pass Multiple Field Values to the SQL Query. Insertion of an Optional Value into the Query To insert an optional value into the query, you append  .AsOptional  to the     field name in a fluent BQL query. If you specify an explicit value for this parameter during the     execution of the BQL statement,  AsOptional  uses the specified value. If you     don't specify an explicit value for this parameter during the execution of the BQL statement,       AsOptional  works similarly to  FromCurrent —that is,     retrieves the field value of the  Current  object from the       PXCache  object and uses the default value of the field if the       Current  object is  null . You can append       .AsOptional.NoDefault  to the field name in a fluent BQL query to make the     system not use the default value and insert  null . AsOptional  is the equivalent of the  Optional       parameter in traditional BQL.  AsOptional.NoDefault  is the equivalent of the        Optional2  parameter in traditional BQL. By using  AsOptional , you can pass the external presentations of the values     to the SQL query, as described in  To Provide External Presentation of the Field Value to the SQL Query. When a DAC includes more than one key field, you may need to use       .AsOptional  in the primary data view of the graph. In this case, the primary     data view typically filters the data records by all of the key fields except the last one. For     example, you can select documents with the same document type as the current data record has and     navigate through these documents with different document numbers. In the following example, the       Document  DAC has two key fields,  DocType  and       DocNbr . public SelectFrom<Document>.
        Where<Document.docType.IsEqual< Document.docType.AsOptional >>.View Receipts; .AsOptional  could be replaced with  .FromCurrent  in the     code above unless you need to execute the  Receipts  data view in code to select     a document with specific document type and number. Insertion of a Value from the UI Control into the Query To insert a value from the UI control into the SQL query, you use the       Argument.As[Type]  classes, where  [Type]  corresponds to     the C# type of the inserted value. The following table lists the fluent BQL types that     correspond to C# types. C# Type Fluent BQL Type bool Argument.AsBool byte Argument.AsByte short Argument.AsShort int Argument.AsInt long Argument.AsLong float Argument.AsFloat double Argument.AsDouble decimal Argument.AsDecimal Guid Argument.AsGuid DateTime Argument.AsDateTime String Argument.AsString By using the  Argument  classes, you can pass values to the data view     delegates. For more information on how to use the  Argument  classes, see  To Pass a Value from a UI Control to a Data View. ]]></column>
		</row>
		<row PageID="3a964dfb-df28-4bea-89d6-76439c44dae3" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2428016c-4fbf-ed7a-1213-3fbff3d5f64f" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can select records from the database by constructing a fluent business query language (BQL) statement. To construct a fluent BQL statement, you use the <tt>SelectFrom&lt;&gt;</tt> class and append the needed clauses to the statement. [anchor|#_a2ece77b-73d5-4c7b-a46a-73a1b3a9f0b5]{br}

This topic describes how to compose <tt>Select</tt> statements by using fluent BQL. For details on how to adjust these statements to define data views or to specify <tt>Search</tt> commands in fluent BQL, see [HelpRoot_Dev_Platform\AD__con_View_Select_Search_in_Fluent_BQL|Search and Select Commands and Data Views in Fluent BQL]. ((({S:Warn}In a <tt>SelectFrom&lt;&gt;</tt> class, you configure a query to the database. The actual request to the database is performed once you cast the result of the query execution to a DAC or an array of DACs, or when you iterate through DACs in the result with the {{foreach}} statement. For details, see [HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution].
)))[anchor|#_1f0a8248-99eb-4897-be95-8bb852d09cbc]
==Before You Proceed==
[anchor|#_71cbee56-a5b5-41f7-8413-216710bfe2ac]
*Make sure that the application database has the database tables from which you are going to request data, and that the application defines the data access classes (DACs) for these tables. For more information on defining DACs, see [HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL].
*Add references to <tt>PX.Data.dll</tt> and <tt>PX.Data.BQL.Fluent.dll</tt> in the project.
*Add the following {{using}} directives to your code.<source lang="csharp">using PX.Data.BQL.Fluent;
using PX.Data.BQL;</source>
[anchor|#_7070d995-fef5-4f90-98ce-2918b02a9a19]
==To Compose a Fluent BQL Statement==
[anchor|#_9576d07d-2304-4d27-98de-691ba2e984a5]
#Type the <tt>SelectFrom&lt;&gt;</tt> class with the needed DAC as the type parameter.
#:For example, suppose that you need to convert the following SQL statement to fluent BQL. {{{{SELECT Product.CategoryCD, MIN(Product.BookedQty) FROM Product
INNER JOIN SupplierProduct
    ON SupplierProduct.ProductID = Product.ProductID
INNER JOIN Supplier
    ON Supplier.AccountID = SupplierProduct.AccountID
WHERE (Product.BookedQty IS NOT NULL
       AND Product.AvailQty IS NOT NULL
       AND Product.MinAvailQty IS NOT NULL
       AND(Product.Active = 1
           OR Product.Active IS NULL)
       AND(Product.BookedQty &gt; Product.AvailQty
           OR Product.AvailQty &lt; Product.MinAvailQty))
    OR Product.AvailQty IS NOT NULL
GROUP BY Product.CategoryCD
ORDER BY Product.UnitPrice, Product.AvailQty DESC
}}}}
#:You start the corresponding fluent BQL query as follows.<source lang="csharp">SelectFrom&lt;Product&gt;</source>
#If you need to include {{JOIN}} clauses in the query, for each table that you want to join, do the following:
##Append to the statement one of the <tt>Join</tt> classes—such as <tt>InnerJoin</tt>, <tt>LeftJoin</tt>, <tt>RightJoin</tt>, <tt>FullJoin</tt>, or <tt>CrossJoin</tt>, which are directly mapped to SQL <tt>JOIN</tt> clauses. 
##Append to the statement the <tt>On&lt;&gt;</tt> clause with the joining conditions. Adhere to the following rules when you specify the conditions:
##*Use the <tt>And&lt;&gt;</tt>, <tt>Or&lt;&gt;</tt>, and <tt>Brackets&lt;&gt;</tt> classes to logically connect the conditions and comparisons.[anchor|#_6dee4411-caf2-45a0-9e91-dd82d1feb00b]
##*To specify the fields that should be used in the conditions, use the class fields defined in the DAC, such as <tt>Product.productID</tt>. (The name of the field class starts with a lowercase letter. Do not confuse it with the property field, which has the same name but starts with an uppercase letter.) [anchor|#_2672cdab-dca0-41c8-ba0b-c731c0c9c41e]
##*If you need to use constants in the fluent BQL statement, use one of the predefined BQL constants or your own constant. (For details on using constants, see [HelpRoot_Dev_Platform\AD__con_Constants_in_FBQL|Constants in Fluent BQL].) [anchor|#_74912a2a-13bd-43f1-b38c-72d5b9c54346]
##*If you need to specify the values of the parameters at run time, use the fluent BQL parameters. For information about parameters, see [HelpRoot_Dev_Platform\AC__con_Parameters_in_FBQL|Parameters in Fluent BQL]. For information about how to use parameters, see [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL|To Use Parameters in Fluent BQL Queries]. 
#:In the sample code that has been presented in this topic, you would add two <tt>Join</tt> classes to the statement, as follows.<source lang="csharp">SelectFrom&lt;Product&gt;.
    InnerJoin&lt;SupplierProduct&gt;.
        On&lt;SupplierProduct.productID.IsEqual&lt;Product.productID&gt;&gt;.
    InnerJoin&lt;Supplier&gt;.
        On&lt;Supplier.accountID.IsEqual&lt;SupplierProduct.accountID&gt;&gt;</source>
#If you need to include a {{WHERE}} clause in the query, append the <tt>Where&lt;&gt;</tt> clause to the statement and specify the conditions as follows:
#*Use the <tt>And&lt;&gt;</tt>, <tt>Or&lt;&gt;</tt>, and <tt>Brackets&lt;&gt;</tt> classes to logically connect the conditions and comparisons.[anchor|#_3a8a72df-cb21-4d72-921a-a9cbec44af48]
#*To specify the fields that should be used in the conditions, use the class fields defined in the DAC, such as <tt>Product.productID</tt>. (The name of the field class starts with a lowercase letter. Do not confuse it with the property field, which has the same name but starts with an uppercase letter.) [anchor|#_9f49ed3f-73ad-4670-984b-385a550bf082]
#*If you need to use constants in the fluent BQL statement, use one of the predefined BQL constants or your own constant. (For details on using constants, see [HelpRoot_Dev_Platform\AD__con_Constants_in_FBQL|Constants in Fluent BQL].) [anchor|#_cea0e171-8379-486d-9fe8-1b2d58368416]
#*If you need to specify the values of the parameters at run time, use the fluent BQL parameters. For information about parameters, see [HelpRoot_Dev_Platform\AC__con_Parameters_in_FBQL|Parameters in Fluent BQL]. For information about how to use parameters, see [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL|To Use Parameters in Fluent BQL Queries]. 
#:In the sample code that has been presented in this topic, you would append the <tt>Where&lt;&gt;</tt> clause to the statement, as follows.<source lang="csharp">SelectFrom&lt;Product&gt;.
    InnerJoin&lt;SupplierProduct&gt;.
        On&lt;SupplierProduct.productID.IsEqual&lt;Product.productID&gt;&gt;.
    InnerJoin&lt;Supplier&gt;.
        On&lt;Supplier.accountID.IsEqual&lt;SupplierProduct.accountID&gt;&gt;.
    Where&lt;
        Brackets&lt;Product.bookedQty.IsNotNull.
            And&lt;Product.availQty.IsNotNull&gt;.
            And&lt;Product.minAvailQty.IsNotNull&gt;.
            And&lt;Product.active.IsEqual&lt;True&gt;.
                Or&lt;Product.active.IsNull&gt;&gt;.
            And&lt;Product.bookedQty.IsGreater&lt;Product.availQty&gt;.
                Or&lt;Product.availQty.IsLess&lt;Product.minAvailQty&gt;&gt;&gt;&gt;.
        Or&lt;Product.availQty.IsNotNull&gt;&gt;</source>
#If you need to group or aggregate records, append the <tt>AggregateTo&lt;&gt;</tt> clause to the statement and specify the grouping conditions and aggregation functions by using the <tt>GroupBy</tt> clauses and the <tt>Min</tt>, <tt>Max</tt>, <tt>Sum</tt>, <tt>Avg</tt>, and <tt>Count</tt> aggregation functions.
#:In the sample code that has been presented in this topic, you would append the <tt>AggregateTo&lt;&gt;</tt> clause to the statement as follows.<source lang="csharp">SelectFrom&lt;Product&gt;.
    InnerJoin&lt;SupplierProduct&gt;.
        On&lt;SupplierProduct.productID.IsEqual&lt;Product.productID&gt;&gt;.
    InnerJoin&lt;Supplier&gt;.
        On&lt;Supplier.accountID.IsEqual&lt;SupplierProduct.accountID&gt;&gt;.
    Where&lt;
        Brackets&lt;Product.bookedQty.IsNotNull.
            And&lt;Product.availQty.IsNotNull&gt;.
            And&lt;Product.minAvailQty.IsNotNull&gt;.
            And&lt;Product.active.IsEqual&lt;True&gt;.
                Or&lt;Product.active.IsNull&gt;&gt;.
            And&lt;Product.bookedQty.IsGreater&lt;Product.availQty&gt;.
                Or&lt;Product.availQty.IsLess&lt;Product.minAvailQty&gt;&gt;&gt;&gt;.
        Or&lt;Product.availQty.IsNotNull&gt;&gt;.
    AggregateTo&lt;GroupBy&lt;Product.categoryCD&gt;, 
                Min&lt;Product.bookedQty&gt;&gt;</source>
#If you need to order records, append to the statement the <tt>OrderBy&lt;&gt;</tt> clause with the <tt>Asc&lt;&gt;</tt> and <tt>Desc&lt;&gt;</tt> classes as the type parameters.
#:In the sample code that has been presented in this topic, you would append the <tt>OrderBy&lt;&gt;</tt> clause to the statement as follows.<source lang="csharp">SelectFrom&lt;Product&gt;.
    InnerJoin&lt;SupplierProduct&gt;.
        On&lt;SupplierProduct.productID.IsEqual&lt;Product.productID&gt;&gt;.
    InnerJoin&lt;Supplier&gt;.
        On&lt;Supplier.accountID.IsEqual&lt;SupplierProduct.accountID&gt;&gt;.
    Where&lt;
        Brackets&lt;Product.bookedQty.IsNotNull.
            And&lt;Product.availQty.IsNotNull&gt;.
            And&lt;Product.minAvailQty.IsNotNull&gt;.
            And&lt;Product.active.IsEqual&lt;True&gt;.
                Or&lt;Product.active.IsNull&gt;&gt;.
            And&lt;Product.bookedQty.IsGreater&lt;Product.availQty&gt;.
                Or&lt;Product.availQty.IsLess&lt;Product.minAvailQty&gt;&gt;&gt;&gt;.
        Or&lt;Product.availQty.IsNotNull&gt;&gt;.
    AggregateTo&lt;GroupBy&lt;Product.categoryCD&gt;, 
                Min&lt;Product.bookedQty&gt;&gt;.
    OrderBy&lt;Product.unitPrice.Asc, 
            Product.availQty.Desc&gt;</source>

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Fluent_BQL|Fluent Business Query Language]
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]
*[HelpRoot_Dev_Platform\AD__how_Execute_BQL_Statement|To Execute BQL Statements]]]></column>
			<column name="PlainText"><![CDATA[To Select Records by Using Fluent BQL You can select records from the database by constructing a fluent business query                 language (BQL) statement. To construct a fluent BQL statement, you use the                      SelectFrom<>  class and append the needed clauses to the                 statement.  This topic describes how to compose                      Select  statements by using fluent BQL. For details on how to                 adjust these statements to define data views or to specify  Search                  commands in fluent BQL, see  Search and Select Commands and Data Views in Fluent BQL.                      In a  SelectFrom<>  class, you configure a query to                     the database. The actual request to the database is performed once you cast the                     result of the query execution to a DAC or an array of DACs, or when you iterate through                     DACs in the result with the  foreach  statement. For details, see                          Data Query Execution. Before You Proceed Make sure that the application database has the database tables from which                         you are going to request data, and that the application defines the data                         access classes (DACs) for these tables. For more information on defining                         DACs, see  Data Access Classes in Fluent BQL. Add references to  PX.Data.dll  and                              PX.Data.BQL.Fluent.dll  in the project. Add the following  using  directives to your                         code. using PX.Data.BQL.Fluent;
using PX.Data.BQL; To Compose a Fluent BQL Statement Type the  SelectFrom<>  class with the needed DAC as the                         type parameter. For example, suppose that you need to convert the                             following SQL statement to fluent BQL.                              SELECT Product.CategoryCD, MIN(Product.BookedQty) FROM Product
INNER JOIN SupplierProduct
    ON SupplierProduct.ProductID = Product.ProductID
INNER JOIN Supplier
    ON Supplier.AccountID = SupplierProduct.AccountID
WHERE (Product.BookedQty IS NOT NULL
       AND Product.AvailQty IS NOT NULL
       AND Product.MinAvailQty IS NOT NULL
       AND(Product.Active = 1
           OR Product.Active IS NULL)
       AND(Product.BookedQty > Product.AvailQty
           OR Product.AvailQty < Product.MinAvailQty))
    OR Product.AvailQty IS NOT NULL
GROUP BY Product.CategoryCD
ORDER BY Product.UnitPrice, Product.AvailQty DESC You                             start the corresponding fluent BQL query as                             follows. SelectFrom<Product> If you need to include  JOIN  clauses in the query, for each                         table that you want to join, do the following: Append to the statement one of the  Join                                  classes—such as  InnerJoin ,                                      LeftJoin ,  RightJoin ,                                      FullJoin , or  CrossJoin ,                                 which are directly mapped to SQL  JOIN  clauses.  Append to the statement the  On<>  clause with                                 the joining conditions. Adhere to the following rules when you                                 specify the conditions: Use the  And<> ,  Or<> , and                      Brackets<>  classes to logically connect the conditions and                 comparisons. To specify the fields that should be used in the                 conditions, use the class fields defined in the DAC, such as                      Product.productID . (The name of the field class starts with a                 lowercase letter. Do not confuse it with the property field, which has the same name                 but starts with an uppercase letter.)  If you need to use constants in the fluent BQL                 statement, use one of the predefined BQL constants or your own constant. (For                 details on using constants, see  Constants in Fluent BQL.)  If you need to specify the values of the parameters                 at run time, use the fluent BQL parameters. For information about parameters, see                      Parameters in Fluent BQL. For                 information about how to use parameters, see  To Use Parameters in Fluent BQL Queries.  In the sample code that has been presented in this topic, you would                             add two  Join  classes to the statement, as                             follows. SelectFrom<Product>.
    InnerJoin<SupplierProduct>.
        On<SupplierProduct.productID.IsEqual<Product.productID>>.
    InnerJoin<Supplier>.
        On<Supplier.accountID.IsEqual<SupplierProduct.accountID>> If you need to include a  WHERE  clause in the query, append                         the  Where<>  clause to the statement and specify the                         conditions as follows: Use the  And<> ,  Or<> , and                      Brackets<>  classes to logically connect the conditions and                 comparisons. To specify the fields that should be used in the                 conditions, use the class fields defined in the DAC, such as                      Product.productID . (The name of the field class starts with a                 lowercase letter. Do not confuse it with the property field, which has the same name                 but starts with an uppercase letter.)  If you need to use constants in the fluent BQL                 statement, use one of the predefined BQL constants or your own constant. (For                 details on using constants, see  Constants in Fluent BQL.)  If you need to specify the values of the parameters                 at run time, use the fluent BQL parameters. For information about parameters, see                      Parameters in Fluent BQL. For                 information about how to use parameters, see  To Use Parameters in Fluent BQL Queries.  In the sample code that has been presented in this topic, you would                             append the  Where<>  clause to the statement, as                             follows. SelectFrom<Product>.
    InnerJoin<SupplierProduct>.
        On<SupplierProduct.productID.IsEqual<Product.productID>>.
    InnerJoin<Supplier>.
        On<Supplier.accountID.IsEqual<SupplierProduct.accountID>>.
    Where<
        Brackets<Product.bookedQty.IsNotNull.
            And<Product.availQty.IsNotNull>.
            And<Product.minAvailQty.IsNotNull>.
            And<Product.active.IsEqual<True>.
                Or<Product.active.IsNull>>.
            And<Product.bookedQty.IsGreater<Product.availQty>.
                Or<Product.availQty.IsLess<Product.minAvailQty>>>>.
        Or<Product.availQty.IsNotNull>> If you need to group or aggregate records, append the                              AggregateTo<>  clause to the statement and specify                         the grouping conditions and aggregation functions by using the                              GroupBy  clauses and the  Min ,                              Max ,  Sum ,  Avg ,                         and  Count  aggregation functions. In the sample code                             that has been presented in this topic, you would append the                                  AggregateTo<>  clause to the statement as                         follows. SelectFrom<Product>.
    InnerJoin<SupplierProduct>.
        On<SupplierProduct.productID.IsEqual<Product.productID>>.
    InnerJoin<Supplier>.
        On<Supplier.accountID.IsEqual<SupplierProduct.accountID>>.
    Where<
        Brackets<Product.bookedQty.IsNotNull.
            And<Product.availQty.IsNotNull>.
            And<Product.minAvailQty.IsNotNull>.
            And<Product.active.IsEqual<True>.
                Or<Product.active.IsNull>>.
            And<Product.bookedQty.IsGreater<Product.availQty>.
                Or<Product.availQty.IsLess<Product.minAvailQty>>>>.
        Or<Product.availQty.IsNotNull>>.
    AggregateTo<GroupBy<Product.categoryCD>, 
                Min<Product.bookedQty>> If you need to order records, append to the statement the                              OrderBy<>  clause with the                              Asc<>  and  Desc<>  classes as                         the type parameters. In the sample code that has been presented in this                             topic, you would append the  OrderBy<>  clause to                             the statement as                         follows. SelectFrom<Product>.
    InnerJoin<SupplierProduct>.
        On<SupplierProduct.productID.IsEqual<Product.productID>>.
    InnerJoin<Supplier>.
        On<Supplier.accountID.IsEqual<SupplierProduct.accountID>>.
    Where<
        Brackets<Product.bookedQty.IsNotNull.
            And<Product.availQty.IsNotNull>.
            And<Product.minAvailQty.IsNotNull>.
            And<Product.active.IsEqual<True>.
                Or<Product.active.IsNull>>.
            And<Product.bookedQty.IsGreater<Product.availQty>.
                Or<Product.availQty.IsLess<Product.minAvailQty>>>>.
        Or<Product.availQty.IsNotNull>>.
    AggregateTo<GroupBy<Product.categoryCD>, 
                Min<Product.bookedQty>>.
    OrderBy<Product.unitPrice.Asc, 
            Product.availQty.Desc> ]]></column>
		</row>
		<row PageID="0512da12-3f77-45a8-a57a-8c68331f8174" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8a1efa2b-4483-af3b-2cf5-3710c1aa7d2d" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can update records from the database by using the <tt>Update&lt;&gt;</tt> class and append the needed clauses to the statement. [anchor|#_a2ece77b-73d5-4c7b-a46a-73a1b3a9f0b5]{br}

This topic describes how to compose <tt>Update</tt> statements by using fluent BQL. ((({S:Warn}In a <tt>Update&lt;&gt;</tt> class, you configure a query to the database. The actual request to the database is performed right away (unlike the select statement, see [HelpRoot_Dev_Platform\AD__how_Select_Records_in_Fluent_BQL|To Select Records by Using Fluent BQL]) and returns the number of updated records.
))){br}{TOC}[anchor|#_1f0a8248-99eb-4897-be95-8bb852d09cbc]
==Before You Proceed==[anchor|#_71cbee56-a5b5-41f7-8413-216710bfe2ac]
*Make sure that the application database has the database tables from which you are going to update, and that the application defines the data access classes (DACs) for these tables. For more information on defining DACs, see [HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL].
*Add references to <tt>PX.Data.dll</tt> and <tt>PX.Data.BQL.Fluent.dll</tt> in the project.
*Add the following {{using}} directives to your code.<source lang="csharp">using PX.Data.BQL.Fluent;
using PX.Data.BQL;</source>
[anchor|#_7070d995-fef5-4f90-98ce-2918b02a9a19]
==To Compose a Fluent BQL Statement==
[anchor|#_9576d07d-2304-4d27-98de-691ba2e984a5]
#Type the <tt>Update&lt;&gt;</tt> class with the needed DAC as the type parameter.
#:For example, suppose that you need to convert the following SQL statement to fluent BQL. {{{{UPDATE Product 
  SET Product.BookedQty = NULL
  INNER JOIN SupplierProduct
    ON SupplierProduct.ProductID = Product.ProductID
  INNER JOIN Supplier
    ON Supplier.AccountID = SupplierProduct.AccountID
  WHERE (Product.AvailQty IS NOT NULL
       AND Product.MinAvailQty IS NOT NULL
       AND(Product.Active = 1
           OR Product.Active IS NULL)
       AND(Product.BookedQty &gt; Product.AvailQty
           OR Product.AvailQty &lt; Product.MinAvailQty))
    OR Product.AvailQty IS NOT NULL
}}}}
#:You start the corresponding fluent BQL query as follows.<source lang="csharp">Update&lt;Product&gt;.Set&lt;Product.BookedQty.EqualTo&lt;Null&gt;&gt;</source>
#If you need to include {{JOIN}} clauses in the query, for each table that you want to join, do the following:
##Append to the statement one of the <tt>Join</tt> classes—such as <tt>InnerJoin</tt>, <tt>LeftJoin</tt>, <tt>RightJoin</tt>, <tt>FullJoin</tt>, or <tt>CrossJoin</tt>, which are directly mapped to SQL <tt>JOIN</tt> clauses. 
##Append to the statement the <tt>On&lt;&gt;</tt> clause with the joining conditions. Adhere to the following rules when you specify the conditions:
##*Use the <tt>And&lt;&gt;</tt>, <tt>Or&lt;&gt;</tt>, and <tt>Brackets&lt;&gt;</tt> classes to logically connect the conditions and comparisons.[anchor|#_8005a61e-67b0-4d82-b6b5-4ce74373a87d]
##*To specify the fields that should be used in the conditions, use the class fields defined in the DAC, such as <tt>Product.productID</tt>. (The name of the field class starts with a lowercase letter. Do not confuse it with the property field, which has the same name but starts with an uppercase letter.) [anchor|#_f69fabac-61f9-4e35-a085-11db3099b377]
##*If you need to use constants in the fluent BQL statement, use one of the predefined BQL constants or your own constant. (For details on using constants, see [HelpRoot_Dev_Platform\AD__con_Constants_in_FBQL|Constants in Fluent BQL].) [anchor|#_e461a80a-c237-4a1d-86e8-570e234d4a6d]
##*If you need to specify the values of the parameters at run time, use the fluent BQL parameters. For information about parameters, see [HelpRoot_Dev_Platform\AC__con_Parameters_in_FBQL|Parameters in Fluent BQL]. For information about how to use parameters, see [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL|To Use Parameters in Fluent BQL Queries]. 
#:In the sample code that has been presented in this topic, you would add two <tt>Join</tt> classes to the statement, as follows.<source lang="csharp">Update&lt;Product&gt;.Set&lt;Product.BookedQty.EqualTo&lt;Null&gt;&gt;.
    InnerJoin&lt;SupplierProduct&gt;.
        On&lt;SupplierProduct.productID.IsEqual&lt;Product.productID&gt;&gt;.
    InnerJoin&lt;Supplier&gt;.
        On&lt;Supplier.accountID.IsEqual&lt;SupplierProduct.accountID&gt;&gt;</source>
#If you need to include a {{WHERE}} clause in the query, append the <tt>Where&lt;&gt;</tt> clause to the statement and specify the conditions as follows:
#*Use the <tt>And&lt;&gt;</tt>, <tt>Or&lt;&gt;</tt>, and <tt>Brackets&lt;&gt;</tt> classes to logically connect the conditions and comparisons.[anchor|#_856f36eb-23ef-47ac-ae8a-164837a275db]
#*To specify the fields that should be used in the conditions, use the class fields defined in the DAC, such as <tt>Product.productID</tt>. (The name of the field class starts with a lowercase letter. Do not confuse it with the property field, which has the same name but starts with an uppercase letter.) [anchor|#_058a2da9-c814-404f-aaad-dfbfa4f52e14]
#*If you need to use constants in the fluent BQL statement, use one of the predefined BQL constants or your own constant. (For details on using constants, see [HelpRoot_Dev_Platform\AD__con_Constants_in_FBQL|Constants in Fluent BQL].) [anchor|#_85916ef4-a1ca-4f57-972a-d8f2b062de84]
#*If you need to specify the values of the parameters at run time, use the fluent BQL parameters. For information about parameters, see [HelpRoot_Dev_Platform\AC__con_Parameters_in_FBQL|Parameters in Fluent BQL]. For information about how to use parameters, see [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL|To Use Parameters in Fluent BQL Queries]. 
#:In the sample code that has been presented in this topic, you would append the <tt>Where&lt;&gt;</tt> clause to the statement, as follows.<source lang="csharp">Update&lt;Product&gt;.Set&lt;Product.BookedQty.EqualTo&lt;Null&gt;&gt;.
    InnerJoin&lt;SupplierProduct&gt;.
        On&lt;SupplierProduct.productID.IsEqual&lt;Product.productID&gt;&gt;.
    InnerJoin&lt;Supplier&gt;.
        On&lt;Supplier.accountID.IsEqual&lt;SupplierProduct.accountID&gt;&gt;
    Where&lt;
        Brackets&lt;Product.availQty.IsNotNull.
            And&lt;Product.minAvailQty.IsNotNull&gt;.
            And&lt;Product.active.IsEqual&lt;True&gt;.
                Or&lt;Product.active.IsNull&gt;&gt;.
            And&lt;Product.bookedQty.IsGreater&lt;Product.availQty&gt;.
                Or&lt;Product.availQty.IsLess&lt;Product.minAvailQty&gt;&gt;&gt;.
        Or&lt;Product.availQty.IsNotNull&gt;&gt;</source>
#:((({S:Warn}To compare values, use the <tt>IsEqual</tt> method. To assign a value, use the <tt>EqualTo</tt> method.
)))
#If you need to group or aggregate records, append the <tt>AggregateTo&lt;&gt;</tt> clause to the statement and specify the grouping conditions and aggregation functions by using the <tt>GroupBy</tt> clauses and the <tt>Min</tt>, <tt>Max</tt>, <tt>Sum</tt>, <tt>Avg</tt>, and <tt>Count</tt> aggregation functions.
#:In the sample code that has been presented in this topic, you would append the <tt>AggregateTo&lt;&gt;</tt> clause to the statement as follows.<source lang="csharp">SelectFrom&lt;Product&gt;.
    InnerJoin&lt;SupplierProduct&gt;.
        On&lt;SupplierProduct.productID.IsEqual&lt;Product.productID&gt;&gt;.
    InnerJoin&lt;Supplier&gt;.
        On&lt;Supplier.accountID.IsEqual&lt;SupplierProduct.accountID&gt;&gt;.
    Where&lt;
        Brackets&lt;Product.bookedQty.IsNotNull.
            And&lt;Product.availQty.IsNotNull&gt;.
            And&lt;Product.minAvailQty.IsNotNull&gt;.
            And&lt;Product.active.IsEqual&lt;True&gt;.
                Or&lt;Product.active.IsNull&gt;&gt;.
            And&lt;Product.bookedQty.IsGreater&lt;Product.availQty&gt;.
                Or&lt;Product.availQty.IsLess&lt;Product.minAvailQty&gt;&gt;&gt;&gt;.
        Or&lt;Product.availQty.IsNotNull&gt;&gt;.
    AggregateTo&lt;GroupBy&lt;Product.categoryCD&gt;&gt;</source>

==Example==
Suppose that you need to convert the following SQL statement to fluent BQL. The statement is used in the <tt>ARDocumentRelease</tt> graph.{{{{UPDATE ARAdjust
  SET ARAdjust.pPDCrMemoRefNbr = NULL
  WHERE ARAdjust.pendingPPD = 1
    AND ARAdjust.adjdDocType = @AdjdDocType
    AND ARAdjust.adjdRefNbr = @AdjdRefNbr
    AND ARAdjust.pPDCrMemoRefNbr = @AdjgRefNbr
}}}}
The statement looks as follows in fluent BQL.{{{{Update&lt;ARAdjust&gt;.
  Set&lt;ARAdjust.pPDCrMemoRefNbr.EqualTo&lt;Null&gt;&gt;.
  Where&lt;ARAdjust.pendingPPD.IsEqual&lt;True&gt;.
    And&lt;ARAdjust.adjdDocType.IsEqual&lt;@P.AsString&gt;&gt;.
    And&lt;ARAdjust.adjdRefNbr.IsEqual&lt;@P.AsString&gt;&gt;.
    And&lt;ARAdjust.pPDCrMemoRefNbr.IsEqual&lt;@P.AsString&gt;&gt;&gt;
.Update(this, voidadj.AdjdDocType, voidadj.AdjdRefNbr, voidadj.AdjgRefNbr);
}}}}((({S:Warn}The statement uses parameters. For details on using parameters, refer to [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL|To Use Parameters in Fluent BQL Queries].
)))
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Fluent_BQL|Fluent Business Query Language]
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]
*[HelpRoot_Dev_Platform\AD__how_Execute_BQL_Statement|To Execute BQL Statements]]]></column>
			<column name="PlainText"><![CDATA[To Update Data in Fluent BQL You can update records from the database by using the  Update<>  class     and append the needed clauses to the statement.  This topic describes how to compose       Update  statements by using fluent BQL.  In a  Update<>  class, you configure a query to the database. The                 actual request to the database is performed right away (unlike the select statement,                 see  To Select Records by Using Fluent BQL) and returns the number                 of updated records. Before You Proceed Make sure that the application database has the database tables from which you are going to      update, and that the application defines the data access classes (DACs) for these tables. For      more information on defining DACs, see  Data Access Classes in Fluent BQL. Add references to  PX.Data.dll  and        PX.Data.BQL.Fluent.dll  in the project. Add the following  using  directives to your      code. using PX.Data.BQL.Fluent;
using PX.Data.BQL; To Compose a Fluent BQL Statement Type the  Update<>  class with the needed DAC as the type        parameter. For example, suppose that you need to convert the following SQL statement to                             fluent BQL.                              UPDATE Product 
  SET Product.BookedQty = NULL
  INNER JOIN SupplierProduct
    ON SupplierProduct.ProductID = Product.ProductID
  INNER JOIN Supplier
    ON Supplier.AccountID = SupplierProduct.AccountID
  WHERE (Product.AvailQty IS NOT NULL
       AND Product.MinAvailQty IS NOT NULL
       AND(Product.Active = 1
           OR Product.Active IS NULL)
       AND(Product.BookedQty > Product.AvailQty
           OR Product.AvailQty < Product.MinAvailQty))
    OR Product.AvailQty IS NOT NULL You start the corresponding fluent BQL query as                             follows. Update<Product>.Set<Product.BookedQty.EqualTo<Null>> If you need to include  JOIN  clauses in the query, for each table that you       want to join, do the following: Append to the statement one of the  Join  classes—such as           InnerJoin ,  LeftJoin ,  RightJoin ,           FullJoin , or  CrossJoin , which are directly mapped to         SQL  JOIN  clauses.  Append to the statement the  On<>  clause with the joining         conditions. Adhere to the following rules when you specify the conditions: Use the  And<> ,  Or<> , and                      Brackets<>  classes to logically connect the conditions and                 comparisons. To specify the fields that should be used in the                 conditions, use the class fields defined in the DAC, such as                      Product.productID . (The name of the field class starts with a                 lowercase letter. Do not confuse it with the property field, which has the same name                 but starts with an uppercase letter.)  If you need to use constants in the fluent BQL                 statement, use one of the predefined BQL constants or your own constant. (For                 details on using constants, see  Constants in Fluent BQL.)  If you need to specify the values of the parameters                 at run time, use the fluent BQL parameters. For information about parameters, see                      Parameters in Fluent BQL. For                 information about how to use parameters, see  To Use Parameters in Fluent BQL Queries.  In the sample code that has been presented in this topic, you would add two                                  Join  classes to the statement, as                             follows. Update<Product>.Set<Product.BookedQty.EqualTo<Null>>.
    InnerJoin<SupplierProduct>.
        On<SupplierProduct.productID.IsEqual<Product.productID>>.
    InnerJoin<Supplier>.
        On<Supplier.accountID.IsEqual<SupplierProduct.accountID>> If you need to include a  WHERE  clause in the query, append the                              Where<>  clause to the statement and specify the                         conditions as follows: Use the  And<> ,  Or<> , and                      Brackets<>  classes to logically connect the conditions and                 comparisons. To specify the fields that should be used in the                 conditions, use the class fields defined in the DAC, such as                      Product.productID . (The name of the field class starts with a                 lowercase letter. Do not confuse it with the property field, which has the same name                 but starts with an uppercase letter.)  If you need to use constants in the fluent BQL                 statement, use one of the predefined BQL constants or your own constant. (For                 details on using constants, see  Constants in Fluent BQL.)  If you need to specify the values of the parameters                 at run time, use the fluent BQL parameters. For information about parameters, see                      Parameters in Fluent BQL. For                 information about how to use parameters, see  To Use Parameters in Fluent BQL Queries.  In the sample code that has been presented in this topic, you would                             append the  Where<>  clause to the statement, as                             follows. Update<Product>.Set<Product.BookedQty.EqualTo<Null>>.
    InnerJoin<SupplierProduct>.
        On<SupplierProduct.productID.IsEqual<Product.productID>>.
    InnerJoin<Supplier>.
        On<Supplier.accountID.IsEqual<SupplierProduct.accountID>>
    Where<
        Brackets<Product.availQty.IsNotNull.
            And<Product.minAvailQty.IsNotNull>.
            And<Product.active.IsEqual<True>.
                Or<Product.active.IsNull>>.
            And<Product.bookedQty.IsGreater<Product.availQty>.
                Or<Product.availQty.IsLess<Product.minAvailQty>>>.
        Or<Product.availQty.IsNotNull>> To                             compare values, use the  IsEqual  method. To assign a                             value, use the  EqualTo  method. If you need to group or aggregate records, append the                              AggregateTo<>  clause to the statement and specify                         the grouping conditions and aggregation functions by using the                              GroupBy  clauses and the  Min ,                              Max ,  Sum ,  Avg ,                         and  Count  aggregation functions. In the sample code                             that has been presented in this topic, you would append the                                  AggregateTo<>  clause to the statement as                             follows. SelectFrom<Product>.
    InnerJoin<SupplierProduct>.
        On<SupplierProduct.productID.IsEqual<Product.productID>>.
    InnerJoin<Supplier>.
        On<Supplier.accountID.IsEqual<SupplierProduct.accountID>>.
    Where<
        Brackets<Product.bookedQty.IsNotNull.
            And<Product.availQty.IsNotNull>.
            And<Product.minAvailQty.IsNotNull>.
            And<Product.active.IsEqual<True>.
                Or<Product.active.IsNull>>.
            And<Product.bookedQty.IsGreater<Product.availQty>.
                Or<Product.availQty.IsLess<Product.minAvailQty>>>>.
        Or<Product.availQty.IsNotNull>>.
    AggregateTo<GroupBy<Product.categoryCD>> Example Suppose that you need to convert the following SQL statement to fluent BQL. The                 statement is used in the  ARDocumentRelease  graph. UPDATE ARAdjust
  SET ARAdjust.pPDCrMemoRefNbr = NULL
  WHERE ARAdjust.pendingPPD = 1
    AND ARAdjust.adjdDocType = @AdjdDocType
    AND ARAdjust.adjdRefNbr = @AdjdRefNbr
    AND ARAdjust.pPDCrMemoRefNbr = @AdjgRefNbr The statement looks as follows in fluent BQL. Update<ARAdjust>.
  Set<ARAdjust.pPDCrMemoRefNbr.EqualTo<Null>>.
  Where<ARAdjust.pendingPPD.IsEqual<True>.
    And<ARAdjust.adjdDocType.IsEqual<@P.AsString>>.
    And<ARAdjust.adjdRefNbr.IsEqual<@P.AsString>>.
    And<ARAdjust.pPDCrMemoRefNbr.IsEqual<@P.AsString>>>
.Update(this, voidadj.AdjdDocType, voidadj.AdjdRefNbr, voidadj.AdjgRefNbr); The statement uses parameters. For details on using parameters, refer to  To Use Parameters in Fluent BQL Queries. ]]></column>
		</row>
		<row PageID="af596e3e-d343-47cf-9796-419630ca23ee" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="df59dc36-54d4-bd54-a3fb-e3151ec480a5" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you need to specify values in a fluent business query language (BQL) statement, you use fluent BQL parameters, which are replaced with the needed values in the translation to SQL. For details about how BQL statements with parameters are translated to SQL, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL#_ff6436a7-d8a9-43c8-9201-d5ea9afbe2d5|Translation of a BQL Command with Parameters to an SQL Query Tree]. {br}

You may need to use BQL parameters to relate data views to each other, to pass field values to the SQL query, to pass the external presentations of the values to the SQL query, or to pass values from UI controls to the SQL query. {br}{TOC}[anchor|#_27cf551c-951d-463a-9005-74584894a725]
==To Relate Data Views to Each Another==
To relate data views to each another, in a data query, use the field value of the <tt>Current</tt> object from the <tt>PXCache</tt> object, as shown in the following sample code.{{{{using PX.Data;
using PX.Data.BQL.Fluent;

// The view declarations in a graph
SelectFrom&lt;Document&gt;.View Documents;
SelectFrom&lt;DocTransaction&gt;.
    Where&lt;DocTransaction.docNbr.IsEqual&lt;Document.docNbr.FromCurrent&gt;.
        And&lt;DocTransaction.docType.IsEqual&lt;Document.docType.FromCurrent&gt;&gt;&gt;.View
    DocTransactions;
}}}}{br}

In this code, there is a many-to-one relationship between the <tt>DocTransaction</tt> and <tt>Document</tt> data access classes (DACs), and this relationship is implemented through the <tt>DocNbr</tt> and <tt>DocType</tt> key fields. The data views in the code connect the <tt>Document</tt> and <tt>DocTransaction</tt> records.((({S:Warn}Acumatica Framework translates the fluent BQL query of the second view in the sample code to the following SQL statement. In this SQL query, {{[parameter1]}} is the <tt>DocNbr</tt> value and {{[parameter2]}} is the <tt>DocType</tt> value retrieved from the <tt>Current</tt> property of the <tt>DocTransaction</tt> cache; {{[list of columns]}} is the list of columns of the {{DocTransaction}} table.{{{{SET @P0 = [parameter1] 
SET @P1 = [parameter2]

SELECT * FROM DocTransaction
WHERE DocTransaction.DocNbr = @P0
    AND DocTransaction.DocType = @P1
}}}}[anchor|#_c251b26e-c936-4f55-b1d0-567f39112949]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))[anchor|#_6e19063a-c756-4b7d-88a0-7d0100a187d9]
==To Pass a Field Value to the SQL Query==
To pass a specific value to the SQL query, do the following;[anchor|#_108b51c7-0745-4d91-8bf1-596b9f387482]
#Use the <tt>@P.As&#91;Type&#93;</tt> class of the needed type in the BQL statement, where {{[Type]}} is one of the following: {{Bool}}, {{Byte}}, {{Short}}, {{Int}}, {{Long}}, {{Float}}, {{Double}}, {{Decimal}}, {{Guid}}, {{DateTime}}, or {{String}}. 
#Specify the needed value as the <tt>Select()</tt> method argument. The value passed to <tt>Select()</tt> must be of the same type as the type of the specified field.
{br}

((({S:Warn}The <tt>@P.As&#91;Type&#93;</tt> class must be used only in the BQL statements that are directly executed in the application code. The data views that are queried from the UI will not work if they contain this class.
))){br}

The code below shows the execution of a BQL statement with a specific value passed in code.<source lang="csharp">using PX.Data;
using PX.Data.BQL.Fluent;
using PX.Data.BQL;

// Suppose an event handler related to the Product DAC
// is being executed.
Product product = (Product)e.Row;

// Select the Category record with the specified CategoryCD.
Category category =
    SelectFrom&lt;Category&gt;.
        Where&lt;Category.categoryCD.IsEqual&lt;@P.AsString&gt;&gt;.View.         
        Select(this, product.CategoryCD);</source>((({S:Warn} Acumatica Framework translates the previous fluent BQL query to the following SQL statement. In this SQL query, {{[parameter]}} is the value of the {{product.CategoryCD}} variable at the moment the <tt>Select()</tt> method is invoked; {{[list of columns]}} is the list of columns of the {{Category}} table.{{{{SET @P0 = [parameter] 

SELECT * FROM Category
WHERE Category.CategoryCD = @P0
}}}}[anchor|#_bcbe661b-9da6-4b78-be98-2fb444539687]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))[anchor|#_cc3c4e58-b049-4351-b3c6-ebd9e62a350d]
==To Pass Multiple Field Values to the SQL Query==
To pass multiple values to the SQL query, do the following:[anchor|#_785c07fa-7a1f-45d7-9d53-989f84d1e0ec]
#Use multiple <tt>@P.As&#91;Type&#93;</tt> classes of the needed type in the fluent BQL statement, where {{[Type]}} is one of the following: {{Bool}}, {{Byte}}, {{Short}}, {{Int}}, {{Long}}, {{Float}}, {{Double}}, {{Decimal}}, {{Guid}}, {{DateTime}}, or {{String}}. 
#Specify the needed values as the <tt>Select()</tt> method arguments in the order in which the parameters are specified in the BQL statement. The number of <tt>@P.As&#91;Type&#93;</tt> classes must match the number of parameters passed to the <tt>Select()</tt> method. 
{br}

((({S:Warn}The <tt>@P.As&#91;Type&#93;</tt> classes should be used in only the BQL statements that are executed in the application code. 
))){br}

The following code shows an example of a fluent BQL statement with two <tt>Required</tt> parameters.<source lang="csharp">using PX.Data;
using PX.Data.BQL.Fluent;
using PX.Data.BQL;

// Suppose an event handler related to the DocTransaction DAC
// is being executed.
DocTransaction line = (DocTransaction)e.Row;

Document doc =
    SelectFrom&lt;Document&gt;.
        Where&lt;Document.docNbr.IsEqual&lt;@P.AsString&gt;.
             And&lt;Document.docType.IsEqual&lt;@P.AsString&gt;&gt;&gt;.View.
    Select(this, line.DocNbr, line.DocType);</source>((({S:Warn} Acumatica Framework translates the previous fluent BQL query to the following SQL statement, where {{[list of columns]}} is the list of the columns of the {{Document}} table. {{{{SET @P0 = [line.DocNbr value]
SET @P1 = [line.DocType value]

SELECT * FROM Document
WHERE Document.DocNbr = @P0
    AND Document.DocType = @P1
}}}}[anchor|#_1da74ebb-5b71-4d0e-899b-b17c98cdb1ff]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))[anchor|#_1f3bef64-92a7-469f-9fd2-89f0910565fe]
==To Pass a Value from a UI Control to a Data View==
To pass a value from a UI control to a data view, do the following:[anchor|#_bd92083d-f390-47ff-89aa-27215c2c0dfd]
#Define a data view with the <tt>Argument.As&#91;Type&#93;</tt> class, where {{[Type]}} specifies the data type of the expected value, as shown in the following sample BQL query.<source lang="csharp">using PX.Data;
using PX.Data.BQL.Fluent;

SelectFrom&lt;TreeViewItem&gt;.
    Where&lt;TreeViewItem.parentID.IsEqual&lt;Argument.AsInt&gt;&gt;.
    OrderBy&lt;Asc&lt;TreeViewItem.parentID&gt;&gt;.View GridDataSource;</source>
#:((({S:Warn}Acumatica Framework translates the previous fluent BQL query to the following SQL statement. In this SQL query, {{[parameter]}} will contain the value received from the UI control and passed to the <tt>Select()</tt> method; {{[list of columns]}} is the list of columns of the {{TreeViewItem}} table.{{{{SET @P0 = [parameter]

SELECT [list of columns] FROM TreeViewItem
WHERE TreeViewItem.ParentID = @P0
ORDER BY TreeViewItem.ParentID
}}}}[anchor|#_946d4c6c-d15d-480f-ab0e-2de32b12386a] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
#Define the data view delegate with parameters through which you can access the values passed from the UI. (You can find more information on how to use data view delegates in [HelpRoot_Dev_Platform\AD__how_Execute_BQL_Statement#_36988f03-38e3-4f9a-89f6-1623935e81fa|To Execute a BQL Statement in a Data View Delegate].)
#:((({S:Warn}When a BQL statement with the <tt>Argument</tt> parameter is executed in code, the value must be specified in the parameters of the <tt>Select()</tt> method.
)))
[anchor|#_4473b629-e9a7-4f41-9041-c0442303d2be]
==To Provide External Presentation of the Field Value to the SQL Query==
To substitute a value in the SQL query, do the following:[anchor|#_b37d7823-a6d2-4838-8d82-0ef40e364a36]
#Add the <tt>PXSelector</tt> attribute with a substitute key to a DAC field, as shown in the following example.<source lang="csharp">using PX.Data;
using PX.Data.BQL.Fluent;

[PXSelector(typeof(SearchFor&lt;Product.productID&gt;.In&lt;SelectFrom&lt;Product&gt;&gt;,
            new Type [] {
                    typeof(Product.productCD),
                    typeof(Product.productName)
            },
            SubstituteKey = typeof(Product.productCD))]
public virtual int? ProductID { get; set; }</source>
#:In this example, <tt>PXSelector</tt> replaces the <tt>ProductID</tt> field in the user interface with the human-readable <tt>ProductCD</tt> field. In the UI control for this field, the user enters a <tt>ProductCD</tt> value. The <tt>PXSelector</tt> attribute implements the <tt>FieldUpdating</tt> event handler, which replaces the <tt>ProductCD</tt> value with the corresponding <tt>ProductID</tt> value. 
#Use the <tt>AsOptional</tt> class to select records by the external presentation of the field value, as shown in the following code for <tt>OrderLine</tt> records.<source lang="csharp">using PX.Data;
using PX.Data.BQL.Fluent;

// p is a Product data record.
// To select OrderLine records, pass the ProductCD value
// to the Select() method.
PXResultset&lt;OrderLine&gt; details = 
    SelectFrom&lt;OrderLine&gt;.
        Where&lt;OrderLine.productID.IsEqual&lt;OrderLine.productID.AsOptional&gt;&gt;.
        View.
    Select(this, p.ProductCD);</source>
#In the <tt>Select()</tt> method, provide values for all <tt>AsOptional</tt>, <tt>@P.As&#91;Type&#93;</tt>, and <tt>Argument.As&#91;Type&#93;</tt> parameters up to the last <tt>@P.As&#91;Type&#93;</tt> or <tt>Argument.As&#91;Type&#93;</tt> parameter in the fluent BQL statement, as shown in the following sample code. <source lang="csharp">using PX.Data;
using PX.Data.BQL.Fluent;

// P is a Product data record. 
// od is an OrderLine data record.

// At least three values (in addition to the graph reference) must
// be passed to the Select() method below.
// The second AsOptional parameter here will be replaced with the
// default UnitPrice value.
PXResultset&lt;OrderLine&gt; details =
    SelectFrom&lt;OrderLine&gt;.
        Where&lt;OrderLine.productID.IsEqual&lt;OrderLine.productID.AsOptional&gt;.
            And&lt;OrderLine.extPrice.IsLess&lt;@P.AsDecimal&gt;&gt;.
            And&lt;OrderLine.unitPrice.IsGreater&lt;@P.AsDecimal&gt;&gt;.
            And&lt;OrderLine.taxRate.IsEqual&lt;OrderLine.taxRate.AsOptional&gt;&gt;&gt;.View.
        .Select(this, p.ProductCD, od.ExtPrice, od.UnitPrice);</source>
#:((({S:Warn}Acumatica Framework translates the fluent BQL query in the code to the following SQL statement, where {{[list of columns]}} is the list of columns of the {{OrderLine}} table. {{{{SET @P0 = [line.ProductID value or default]
SET @P1 = [line.ExtPrice value]
SET @P2 = [line.UnitPrice value]
SET @P3 = [Default TaxRate value]

SELECT [list of columns] FROM OrderLine
WHERE OrderLine.ProductID = @P0
    AND OrderLine.ExtPrice &lt; @P1
    AND OrderLine.UnitPrice &gt; @P2
    AND OrderLine.TaxRate = @P3
}}}}[anchor|#_84541df0-9b63-434e-9efb-8397fc13f387] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
]]></column>
			<column name="PlainText"><![CDATA[To Use Parameters in Fluent BQL Queries If you need to specify values in a fluent business query language (BQL) statement,                 you use fluent BQL parameters, which are replaced with the needed values in the                 translation to SQL. For details about how BQL statements with parameters are                 translated to SQL, see  Translation of a BQL Command with Parameters to an SQL Query Tree.  You may need to use BQL parameters to relate data views to each other, to pass field                 values to the SQL query, to pass the external presentations of the values to the SQL                 query, or to pass values from UI controls to the SQL query.  To Relate Data Views to Each Another To relate data views to each another, in a data query, use the field value of the                      Current  object from the  PXCache  object, as                 shown in the following sample                 code. using PX.Data;
using PX.Data.BQL.Fluent;

// The view declarations in a graph
SelectFrom<Document>.View Documents;
SelectFrom<DocTransaction>.
    Where<DocTransaction.docNbr.IsEqual<Document.docNbr.FromCurrent>.
        And<DocTransaction.docType.IsEqual<Document.docType.FromCurrent>>>.View
    DocTransactions; In this code, there is a many-to-one relationship between the                      DocTransaction  and  Document  data access                 classes (DACs), and this relationship is implemented through the                      DocNbr  and  DocType  key fields. The data                 views in the code connect the  Document  and                      DocTransaction  records. Acumatica Framework translates the fluent BQL query of the second view in the sample code to the                     following SQL statement. In this SQL query,  [parameter1]  is the                          DocNbr  value and  [parameter2]  is the                          DocType  value retrieved from the                          Current  property of the  DocTransaction                      cache;  [list of columns]  is the list of columns of the                          DocTransaction                          table. SET @P0 = [parameter1] 
SET @P1 = [parameter2]

SELECT * FROM DocTransaction
WHERE DocTransaction.DocNbr = @P0
    AND DocTransaction.DocType = @P1  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Pass a Field Value to the SQL Query To pass a specific value to the SQL query, do the following; Use the  @P.As[Type]  class of the needed type in the BQL                         statement, where  [Type]  is one of the following:                              Bool ,  Byte ,  Short ,                              Int ,  Long ,  Float ,                              Double ,  Decimal ,                          Guid ,  DateTime , or                          String .  Specify the needed value as the  Select()  method argument.                         The value passed to  Select()  must be of the same type as                         the type of the specified field. The  @P.As[Type]  class must be used only in the BQL                     statements that are directly executed in the application code. The data views                     that are queried from the UI will not work if they contain this class. The code below shows the execution of a BQL statement with a specific value passed in                 code. using PX.Data;
using PX.Data.BQL.Fluent;
using PX.Data.BQL;

// Suppose an event handler related to the Product DAC
// is being executed.
Product product = (Product)e.Row;

// Select the Category record with the specified CategoryCD.
Category category =
    SelectFrom<Category>.
        Where<Category.categoryCD.IsEqual<@P.AsString>>.View.         
        Select(this, product.CategoryCD);  Acumatica Framework translates the previous fluent BQL query to the following SQL statement. In this                 SQL query,  [parameter]  is the value of the                      product.CategoryCD  variable at the moment the                      Select()  method is invoked;  [list of                     columns]  is the list of columns of the  Category                      table. SET @P0 = [parameter] 

SELECT * FROM Category
WHERE Category.CategoryCD = @P0  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Pass Multiple Field Values to the SQL Query To pass multiple values to the SQL query, do the following: Use multiple  @P.As[Type]  classes of the needed type in                         the fluent BQL statement, where  [Type]  is one of the                         following:  Bool ,  Byte ,                              Short ,  Int ,  Long ,                              Float ,  Double ,                              Decimal ,  Guid ,                              DateTime , or  String .  Specify the needed values as the  Select()  method                         arguments in the order in which the parameters are specified in the BQL                         statement. The number of  @P.As[Type]  classes must match                         the number of parameters passed to the  Select()  method.                      The  @P.As[Type]  classes should be used in only the BQL                     statements that are executed in the application code.  The following code shows an example of a fluent BQL statement with two                      Required  parameters. using PX.Data;
using PX.Data.BQL.Fluent;
using PX.Data.BQL;

// Suppose an event handler related to the DocTransaction DAC
// is being executed.
DocTransaction line = (DocTransaction)e.Row;

Document doc =
    SelectFrom<Document>.
        Where<Document.docNbr.IsEqual<@P.AsString>.
             And<Document.docType.IsEqual<@P.AsString>>>.View.
    Select(this, line.DocNbr, line.DocType);  Acumatica Framework translates the previous fluent BQL query to the following SQL statement, where                      [list of columns]  is the list of the columns of the                      Document  table.                      SET @P0 = [line.DocNbr value]
SET @P1 = [line.DocType value]

SELECT * FROM Document
WHERE Document.DocNbr = @P0
    AND Document.DocType = @P1  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Pass a Value from a UI Control to a Data View To pass a value from a UI control to a data view, do the following: Define a data view with the  Argument.As[Type]  class,                         where  [Type]  specifies the data type of the expected value,                         as shown in the following sample BQL                                 query. using PX.Data;
using PX.Data.BQL.Fluent;

SelectFrom<TreeViewItem>.
    Where<TreeViewItem.parentID.IsEqual<Argument.AsInt>>.
    OrderBy<Asc<TreeViewItem.parentID>>.View GridDataSource; Acumatica Framework translates the previous fluent BQL query to the following SQL                             statement. In this SQL query,  [parameter]  will contain                             the value received from the UI control and passed to the                                  Select()  method;  [list of                                 columns]  is the list of columns of the                                  TreeViewItem                                  table. SET @P0 = [parameter]

SELECT [list of columns] FROM TreeViewItem
WHERE TreeViewItem.ParentID = @P0
ORDER BY TreeViewItem.ParentID  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. Define the data view delegate with parameters through which you can access                         the values passed from the UI. (You can find more information on how to use                         data view delegates in  To Execute a BQL Statement in a Data View Delegate.) When a BQL statement with the  Argument                              parameter is executed in code, the value must be specified in the                             parameters of the  Select()  method. To Provide External Presentation of the Field Value to the SQL Query To substitute a value in the SQL query, do the following: Add the  PXSelector  attribute with a substitute key to a                         DAC field, as shown in the following                             example. using PX.Data;
using PX.Data.BQL.Fluent;

[PXSelector(typeof(SearchFor<Product.productID>.In<SelectFrom<Product>>,
            new Type [] {
                    typeof(Product.productCD),
                    typeof(Product.productName)
            },
            SubstituteKey = typeof(Product.productCD))]
public virtual int? ProductID { get; set; } In                             this example,  PXSelector  replaces the                                  ProductID  field in the user interface with the                             human-readable  ProductCD  field. In the UI control for                             this field, the user enters a  ProductCD  value. The                                  PXSelector  attribute implements the                                  FieldUpdating  event handler, which replaces the                                  ProductCD  value with the corresponding                                  ProductID  value.  Use the  AsOptional  class to select records by the                         external presentation of the field value, as shown in the following code for                              OrderLine                          records. using PX.Data;
using PX.Data.BQL.Fluent;

// p is a Product data record.
// To select OrderLine records, pass the ProductCD value
// to the Select() method.
PXResultset<OrderLine> details = 
    SelectFrom<OrderLine>.
        Where<OrderLine.productID.IsEqual<OrderLine.productID.AsOptional>>.
        View.
    Select(this, p.ProductCD); In the  Select()  method, provide values for all                              AsOptional ,  @P.As[Type] , and                              Argument.As[Type]  parameters up to the last                              @P.As[Type]  or  Argument.As[Type]                          parameter in the fluent BQL statement, as shown in the following sample                         code.                                  using PX.Data;
using PX.Data.BQL.Fluent;

// P is a Product data record. 
// od is an OrderLine data record.

// At least three values (in addition to the graph reference) must
// be passed to the Select() method below.
// The second AsOptional parameter here will be replaced with the
// default UnitPrice value.
PXResultset<OrderLine> details =
    SelectFrom<OrderLine>.
        Where<OrderLine.productID.IsEqual<OrderLine.productID.AsOptional>.
            And<OrderLine.extPrice.IsLess<@P.AsDecimal>>.
            And<OrderLine.unitPrice.IsGreater<@P.AsDecimal>>.
            And<OrderLine.taxRate.IsEqual<OrderLine.taxRate.AsOptional>>>.View.
        .Select(this, p.ProductCD, od.ExtPrice, od.UnitPrice); Acumatica Framework translates the fluent BQL query in the code to the following SQL                             statement, where  [list of columns]  is the list of                             columns of the  OrderLine  table.                                  SET @P0 = [line.ProductID value or default]
SET @P1 = [line.ExtPrice value]
SET @P2 = [line.UnitPrice value]
SET @P3 = [Default TaxRate value]

SELECT [list of columns] FROM OrderLine
WHERE OrderLine.ProductID = @P0
    AND OrderLine.ExtPrice < @P1
    AND OrderLine.UnitPrice > @P2
    AND OrderLine.TaxRate = @P3  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. ]]></column>
		</row>
		<row PageID="c3ae0da2-63d1-4a43-b1f6-b8b3a96da221" Language="en-US" PageRevisionID="1" PlainText="Creating Traditional BQL Queries To query data from the database, you use the business query language (BQL), which has two     dialects: fluent BQL and traditional BQL. In this chapter, you can find information on how to create traditional BQL queries. For the     general information about BQL, see  Querying Data in Acumatica Framework. For details about     building queries with traditional BQL, see  Creating Traditional BQL Queries. In This Chapter Traditional Business Query LanguageData Access Classes in Traditional BQLPXSelect ClassesThe Classes That Compose BQL StatementsParameters in Traditional BQL StatementsData Query ExecutionTo Select Records By Using Traditional BQLTo Filter RecordsTo Order RecordsTo Query Multiple TablesTo Group and Aggregate RecordsTo Use Parameters in Traditional BQLTo Use Arithmetic OperationsTo Compose a BQL Statement from an SQL Statement" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="5cae56f9-d5e1-e7a8-5674-529983ad3c4c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To query data from the database, you use the business query language (BQL), which has two dialects: fluent BQL and traditional BQL.{br}

In this chapter, you can find information on how to create traditional BQL queries. For the general information about BQL, see [HelpRoot_Dev_Platform\AD__mng_Querying_Data|Querying Data in Acumatica Framework]. For details about building queries with traditional BQL, see [HelpRoot_Dev_Platform\AD__mng_Traditional_BQL|Creating Traditional BQL Queries].
==In This Chapter==[anchor|#_980c134d-979b-46c3-89ce-d9d01a936586]
{| class="checklist invisiblechecklist" | width="100%" 
|- 
| 
*[HelpRoot_Dev_Platform\AD__con_Traditional_BQL|Traditional Business Query Language]
*[HelpRoot_Dev_Platform\AD__con_DACs_in_TraditionalBQL|Data Access Classes in Traditional BQL]
*[HelpRoot_Dev_Platform\AD__con_BQL_PXSelect|PXSelect Classes]
*[HelpRoot_Dev_Platform\AD__con_BQL_Commands|The Classes That Compose BQL Statements]
*[HelpRoot_Dev_Platform\AD__con_Parameters|Parameters in Traditional BQL Statements]
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]

| 
*[HelpRoot_Dev_Platform\AD__how_Construct_Statement|To Select Records By Using Traditional BQL]
*[HelpRoot_Dev_Platform\AD__how_BQL_Filter|To Filter Records]
*[HelpRoot_Dev_Platform\AD__how_BQL_OrderBy|To Order Records]
*[HelpRoot_Dev_Platform\AD__how_Query_Multiple_Tables|To Query Multiple Tables]
*[HelpRoot_Dev_Platform\AD__how_BQL_Group_and_Aggregate|To Group and Aggregate Records]
*[HelpRoot_Dev_Platform\AD__how_BQL_Parameters|To Use Parameters in Traditional BQL]
*[HelpRoot_Dev_Platform\AD__how_BQL_Functions|To Use Arithmetic Operations]
*[HelpRoot_Dev_Platform\AD__how_Translate_SQL_to_BQL|To Compose a BQL Statement from an SQL Statement]

|}]]></column>
		</row>
		<row PageID="9daff8e3-c057-4633-8bf3-fcbacf652123" Language="en-US" PageRevisionID="1" PlainText="Traditional Business Query Language When you compose a query with the traditional business query language (BQL), you work with         the following classes: The classes that correspond to database tables (data access classes) and columns. For             details on data access classes, see  Data Access Classes in Traditional BQL. The classes that define data views in a graph and select data from the database in             code ( PXSelect  classes). For more information on these classes, see                PXSelect Classes. The classes that compose BQL statements, such as  Select ,                Search ,  Where ,  OrderBy ,                And , and  Add . For more information on these             classes, see  The Classes That Compose BQL Statements. The classes that pass parameters to BQL statements, such as              Current ,  Required ,  Optional ,                Argument . For details on BQL parameters, see  Parameters in Traditional BQL Statements. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f0aaa669-98b4-f4de-ca6a-25796b9cc93b" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When you compose a query with the traditional business query language (BQL), you work with the following classes:[anchor|#_d7aa1f14-c513-4457-9f60-87d62189bf96]
*The classes that correspond to database tables (data access classes) and columns. For details on data access classes, see [HelpRoot_Dev_Platform\AD__con_DACs_in_TraditionalBQL|Data Access Classes in Traditional BQL].
*The classes that define data views in a graph and select data from the database in code (<tt>PXSelect</tt> classes). For more information on these classes, see [HelpRoot_Dev_Platform\AD__con_BQL_PXSelect|PXSelect Classes].
*The classes that compose BQL statements, such as <tt>Select</tt>, <tt>Search</tt>, <tt>Where</tt>, <tt>OrderBy</tt>, <tt>And</tt>, and <tt>Add</tt>. For more information on these classes, see [HelpRoot_Dev_Platform\AD__con_BQL_Commands|The Classes That Compose BQL Statements].
*The classes that pass parameters to BQL statements, such as <tt>Current</tt>, <tt>Required</tt>, <tt>Optional</tt>, <tt>Argument</tt>. For details on BQL parameters, see [HelpRoot_Dev_Platform\AD__con_Parameters|Parameters in Traditional BQL Statements].
]]></column>
		</row>
		<row PageID="a47ddb36-eb85-486f-9d6b-49beac42fc80" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="a4839497-4528-954c-f943-53a9a7a0c989" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The data access classes (DACs) that are used in traditional BQL differ from the DACs that are used in fluent BQL in the declarations of the class fields. For details about the DAC declaration, see [HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes].{br}

You derive each class field of a DAC (a {{public abstract}} class of a DAC) from the <tt>IBqlField</tt> interface and assign it a name that starts with a lowercase letter. {br}

The following code shows an example of the <tt>Product</tt> data access class declared in traditional BQL style.<source lang="csharp">using System;
using PX.Data;

[Serializable]
public class Product : PX.Data.IBqlTable
{
    // The class used in BQL statements to refer to the ProductID column
    public abstract class productID : PX.Data.IBqlField
    {
    }
    // The property holding the ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }

    // The class used in BQL statements to refer to the AvailQty column
    public abstract class availQty : PX.Data.IBqlField
    {
    }
    // The property holding the AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
}</source>
==Simultaneous Use of DACs in Traditional BQL and Fluent BQL==
The class fields declared in traditional BQL style cannot be used in fluent BQL queries.{br}

The class fields that are defined in the fluent BQL style (as described in [HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL]) can be used in traditional BQL queries without any modifications. Therefore, we recommend that you use the fluent BQL style of DAC declaration. 
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes]]]></column>
			<column name="PlainText"><![CDATA[Data Access Classes in Traditional BQL The data access classes (DACs) that are used in traditional BQL differ from the DACs that         are used in fluent BQL in the declarations of the class fields. For details about the DAC         declaration, see  Data Access Classes. You derive each class field of a DAC (a  public abstract  class of a DAC)         from the  IBqlField  interface and assign it a name that starts with a         lowercase letter.  The following code shows an example of the  Product  data access class         declared in traditional BQL         style. using System;
using PX.Data;

[Serializable]
public class Product : PX.Data.IBqlTable
{
    // The class used in BQL statements to refer to the ProductID column
    public abstract class productID : PX.Data.IBqlField
    {
    }
    // The property holding the ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }

    // The class used in BQL statements to refer to the AvailQty column
    public abstract class availQty : PX.Data.IBqlField
    {
    }
    // The property holding the AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
} Simultaneous Use of DACs in Traditional BQL and Fluent BQL The class fields declared in traditional BQL style cannot be used in fluent BQL         queries. The class fields that are defined in the fluent BQL style (as described in  Data Access Classes in Fluent BQL) can be used in traditional BQL queries without any         modifications. Therefore, we recommend that you use the fluent BQL style of DAC declaration.        ]]></column>
		</row>
		<row PageID="7d3035af-dac2-47fe-bbe6-b733565697cf" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="a9702f1c-7016-f4f5-08eb-aad5f10cb913" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In traditional business query language (BQL), you define a data view or request database data in code by using one of the <tt>PXSelect</tt> classes (that is, the classes derived from <tt>PXSelectBase</tt>). {br}{TOC}
==PXSelect Classes==The instances of <tt>PXSelect</tt> classes are complex objects containing the following:[anchor|#ul_ndl_p1z_hk]
*A reference to the <tt>PXView</tt> object instantiated to process the data query
*A reference (through the <tt>PXView</tt> object) to the <tt>Select</tt> object, which is the business query language (BQL) command to be executed 
*A reference to the graph
*A reference to the cache of the data access class (DAC) type that is specified in the first type parameter of <tt>PXSelect</tt>

That is, through the <tt>PXSelect</tt> classes, you can execute the BQL command and interact with the cache, as illustrated in the following diagram.[anchor|#_590e2ed4-891f-433c-a732-9f68c2377555][image:StudioDeveloperGuide/Images/PXSelect,Select,Search.png|popup|450px]((({S:Warn}Do not confuse the <tt>PXSelect</tt> classes with the <tt>Select</tt> classes. <tt>PXSelect</tt> is an aggregate of the data view, cache, and graph. You can use <tt>PXSelect</tt> classes to read, write, update, and delete records in the scope of a graph. <tt>Select</tt> classes simply represent BQL commands. You cannot read records by using a BQL command without instantiating a data view. For more information on the <tt>Select</tt> classes, see [HelpRoot_Dev_Platform\AD__con_BQL_Commands|The Classes That Compose BQL Statements].
)))
==Types of PXSelect Classes==
The first type parameter of all <tt>PXSelect</tt> classes is a data access class (DAC) generally bound to a database table. The resulting SQL query selects records from this table. Other type parameters (such as <tt>Where</tt>, <tt>OrderBy</tt>, <tt>Join</tt>, and <tt>Aggregate</tt>) are optional and represent clauses that can be added to the basic select statement.{br}

Depending on the clauses that will be used in a query, you select the appropriate variant of the <tt>PXSelect</tt> class.{br}

For example, if you need to use the <tt>Where</tt>, <tt>OrderBy</tt>, and <tt>Join</tt> clauses, you can use the <tt>PXSelectJoin&lt;Table, Join, Where, OrderBy&gt;</tt> class to create the query, as shown in the following BQL sample code.<source lang="csharp">PXSelectJoin&lt;Table1,
    LeftJoin&lt;Table2, On&lt;Table2.field2, Equal&lt;Table1.field1&gt;&gt;&gt;,
    Where&lt;Table1.field3, IsNotNull&gt;,
    OrderBy&lt;Asc&lt;Table1.field1&gt;&gt;&gt;</source>((({S:Warn} Acumatica Framework translates this statement to the following SQL query, where {{[list of columns]}} is the list of columns of the joined tables. {{{{SELECT [list of columns] FROM Table1
    LEFT JOIN Table2 ON Table2.Field2 = Table1.Field1
    WHERE Table1.Field3 IS NOT NULL
    ORDER BY Table1.Field1 
}}}}[anchor|#_d3da060f-c615-4c4f-b48b-e62f5a62751c]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
For more information on how to use the BQL clauses, see [HelpRoot_Dev_Platform\AD__how_Construct_Statement|To Select Records By Using Traditional BQL].{br}

If you need to retrieve data as it is currently stored in the database, you use one of the <tt>PXSelect</tt> classes that has <tt>Readonly</tt> in its name, such as the <tt>PXSelectReadonly&lt;Table&gt;</tt> class, or any of the <tt>PXSelect</tt> classes that use aggregation, such as the <tt>PXSelectGroupBy&lt;Table, Aggregate&gt;</tt> class. Otherwise, the data retrieved from the database can be merged with the data currently stored in the cache. For more information on how the data is merged with the cache, see [HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache].
==The List of PXSelect Classes==
 Acumatica Framework provides the following <tt>PXSelect</tt> classes:[anchor|#_ab5af201-45e1-420e-be2a-38ecd58a9de2]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=82e24896-5ff7-a1fe-a0f8-9bff0ddf27ea|<tt>PXSelect&lt;Table, Where, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5ec6f10c-23ef-14aa-6f01-31a2679baebc| <tt>PXSelect&lt;Table, Where&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=df23e254-51d3-6c56-2532-55f3602c486b| <tt>PXSelect&lt;Table&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=91a0013f-35d6-edeb-0807-74d1754fc756| <tt>PXSelectGroupBy&lt;Table, Aggregate&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=aa1de26d-e076-e380-ef3b-3e4af9e4962a| <tt>PXSelectGroupBy&lt;Table, Where, Aggregate, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ab32e32c-e84e-f3cb-149d-f4790e5cc800| <tt>PXSelectGroupBy&lt;Table, Where, Aggregate&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ad8688e6-5353-143c-7d1f-2d7606c8e393| <tt>PXSelectGroupByOrderBy&lt;Table, Aggregate, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=4fc392e5-99e7-73cc-b526-49ccce3e05c2| <tt>PXSelectGroupByOrderBy&lt;Table, Join, Aggregate, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=49aea5fc-82e2-ca3b-d766-128f52b544b8| <tt>PXSelectJoin&lt;Table, Join, Where, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b3d13bad-ec9d-121e-d0bb-0ddb9c3ed7d1| <tt>PXSelectJoin&lt;Table, Join, Where&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=bc94968c-2642-d512-d7f7-a0d286b59126| <tt>PXSelectJoin&lt;Table, Join&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c4b6e1f7-866e-58b5-a196-5389e0a7bfe6| <tt>PXSelectJoinGroupBy&lt;Table, Join, Aggregate&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e7e783a3-cff9-85da-8681-ecee191db62d| <tt>PXSelectJoinGroupBy&lt;Table, Join, Where, Aggregate, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fcb1550e-f1df-7cb1-fb71-865b4646498d| <tt>PXSelectJoinGroupBy&lt;Table, Join, Where, Aggregate&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b0667493-2ad5-c38a-e80e-e17818841dc5| <tt>PXSelectJoinOrderBy&lt;Table, Join, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fdf23b92-19c4-f2b3-27ec-dd80a240820a| <tt>PXSelectOrderBy&lt;Table, Join, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8e8c6674-d029-5f35-069a-b70a9c3e7938| <tt>PXSelectOrderBy&lt;Table, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d6496092-e1a7-66b7-a1fa-8ab4dee0a035| <tt>PXSelectReadonly&lt;Table, Where, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a0e97d1d-b640-12ee-b6df-54e90d5c73ca| <tt>PXSelectReadonly&lt;Table, Where&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a17a006c-90fe-e3b2-df96-0cbddc84cd5d| <tt>PXSelectReadonly&lt;Table&gt; </tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=549c3942-b680-1c50-3e63-f8cb423956c1| <tt>PXSelectReadonly2&lt;Table, Join, Where, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a0f3fe13-d460-4f0d-b302-4c6fb38a27ae| <tt>PXSelectReadonly2&lt;Table, Join, Where&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5349f5f1-6f58-9ac0-1bdd-cab07e51168b| <tt>PXSelectReadonly2&lt;Table, Join&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=235c9fa2-ca6a-27d2-f6ce-d145b2608e23| <tt>PXSelectReadonly3&lt;Table, Join, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1cb18bdd-100a-d8d0-a81d-ce74c95757e0| <tt>PXSelectReadonly3&lt;Table, OrderBy&gt;</tt>]
]]></column>
			<column name="PlainText"><![CDATA[PXSelect Classes In traditional business query language (BQL), you define a data view or request database         data in code by using one of the  PXSelect  classes (that is, the classes         derived from  PXSelectBase ).  PXSelect Classes The instances of          PXSelect  classes are complex objects containing the following: A reference to the  PXView  object instantiated to process the data           query A reference (through the  PXView  object) to the              Select  object, which is the business query language (BQL) command to           be executed  A reference to the graph A reference to the cache of the data access class (DAC) type that is specified in the           first type parameter of  PXSelect That is, through the  PXSelect  classes, you can execute the BQL         command and interact with the cache, as illustrated in the following diagram. Do not confuse the            PXSelect  classes with the  Select  classes.            PXSelect  is an aggregate of the data view, cache, and graph. You can         use  PXSelect  classes to read, write, update, and delete records in the         scope of a graph.  Select  classes simply represent BQL commands. You         cannot read records by using a BQL command without instantiating a data view. For more         information on the  Select  classes, see  The Classes That Compose BQL Statements. Types of PXSelect Classes The first type parameter of all  PXSelect  classes is a data access class         (DAC) generally bound to a database table. The resulting SQL query selects records from this         table. Other type parameters (such as  Where ,  OrderBy ,            Join , and  Aggregate ) are optional and represent         clauses that can be added to the basic select statement. Depending on the clauses that will be used in a query, you select the appropriate variant         of the  PXSelect  class. For example, if you need to use the  Where ,  OrderBy ,         and  Join  clauses, you can use the  PXSelectJoin<Table, Join,           Where, OrderBy>  class to create the query, as shown in the following BQL         sample code. PXSelectJoin<Table1,
    LeftJoin<Table2, On<Table2.field2, Equal<Table1.field1>>>,
    Where<Table1.field3, IsNotNull>,
    OrderBy<Asc<Table1.field1>>>  Acumatica Framework         translates this statement to the following SQL query, where  [list of           columns]  is the list of columns of the joined tables.            SELECT [list of columns] FROM Table1
    LEFT JOIN Table2 ON Table2.Field2 = Table1.Field1
    WHERE Table1.Field3 IS NOT NULL
    ORDER BY Table1.Field1   Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. For more information on how to use the BQL clauses, see  To Select Records By Using Traditional BQL. If you need to retrieve data as it is currently stored in the database, you use one of the            PXSelect  classes that has  Readonly  in its name, such         as the  PXSelectReadonly<Table>  class, or any of the            PXSelect  classes that use aggregation, such as the            PXSelectGroupBy<Table, Aggregate>  class. Otherwise, the data         retrieved from the database can be merged with the data currently stored in the cache. For         more information on how the data is merged with the cache, see  Merge of the Records with PXCache. The List of PXSelect Classes  Acumatica Framework provides the following  PXSelect  classes: PXSelect<Table,                 Where, OrderBy> <tt>PXSelect&lt;Table, Where, OrderBy&gt;</tt>PXSelect<Table,                 Where>  <tt>PXSelect&lt;Table, Where&gt;</tt>PXSelect<Table>  <tt>PXSelect&lt;Table&gt;</tt>PXSelectGroupBy<Table, Aggregate>  <tt>PXSelectGroupBy&lt;Table, Aggregate&gt;</tt>PXSelectGroupBy<Table, Where, Aggregate,             OrderBy>  <tt>PXSelectGroupBy&lt;Table, Where, Aggregate, OrderBy&gt;</tt>PXSelectGroupBy<Table, Where, Aggregate>  <tt>PXSelectGroupBy&lt;Table, Where, Aggregate&gt;</tt>PXSelectGroupByOrderBy<Table, Aggregate,             OrderBy>  <tt>PXSelectGroupByOrderBy&lt;Table, Aggregate, OrderBy&gt;</tt>PXSelectGroupByOrderBy<Table, Join, Aggregate,               OrderBy>  <tt>PXSelectGroupByOrderBy&lt;Table, Join, Aggregate, OrderBy&gt;</tt>PXSelectJoin<Table, Join, Where, OrderBy>  <tt>PXSelectJoin&lt;Table, Join, Where, OrderBy&gt;</tt>PXSelectJoin<Table, Join, Where>  <tt>PXSelectJoin&lt;Table, Join, Where&gt;</tt>PXSelectJoin<Table, Join>  <tt>PXSelectJoin&lt;Table, Join&gt;</tt>PXSelectJoinGroupBy<Table, Join, Aggregate>  <tt>PXSelectJoinGroupBy&lt;Table, Join, Aggregate&gt;</tt>PXSelectJoinGroupBy<Table, Join, Where, Aggregate,                 OrderBy>  <tt>PXSelectJoinGroupBy&lt;Table, Join, Where, Aggregate, OrderBy&gt;</tt>PXSelectJoinGroupBy<Table, Join, Where,             Aggregate>  <tt>PXSelectJoinGroupBy&lt;Table, Join, Where, Aggregate&gt;</tt>PXSelectJoinOrderBy<Table, Join, OrderBy>  <tt>PXSelectJoinOrderBy&lt;Table, Join, OrderBy&gt;</tt>PXSelectOrderBy<Table, Join, OrderBy>  <tt>PXSelectOrderBy&lt;Table, Join, OrderBy&gt;</tt>PXSelectOrderBy<Table, OrderBy>  <tt>PXSelectOrderBy&lt;Table, OrderBy&gt;</tt>PXSelectReadonly<Table, Where, OrderBy>  <tt>PXSelectReadonly&lt;Table, Where, OrderBy&gt;</tt>PXSelectReadonly<Table, Where>  <tt>PXSelectReadonly&lt;Table, Where&gt;</tt>PXSelectReadonly<Table>   <tt>PXSelectReadonly&lt;Table&gt; </tt>PXSelectReadonly2<Table, Join, Where, OrderBy>  <tt>PXSelectReadonly2&lt;Table, Join, Where, OrderBy&gt;</tt>PXSelectReadonly2<Table, Join, Where>  <tt>PXSelectReadonly2&lt;Table, Join, Where&gt;</tt>PXSelectReadonly2<Table, Join>  <tt>PXSelectReadonly2&lt;Table, Join&gt;</tt>PXSelectReadonly3<Table, Join, OrderBy>  <tt>PXSelectReadonly3&lt;Table, Join, OrderBy&gt;</tt>PXSelectReadonly3<Table, OrderBy>  <tt>PXSelectReadonly3&lt;Table, OrderBy&gt;</tt>]]></column>
		</row>
		<row PageID="5dcf2b9e-ab3a-4ba6-a25d-3f2c28c3cf8a" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e89d74c7-4c0e-53aa-6a75-3e38a2d40a66" RecordSourceID="22377">
			<column name="Content"><![CDATA[
This topic contains an overview of the classes that you use to compose business query language (BQL) statements inside <tt>PXSelect</tt> and to define attributes of DACs.{br}{TOC}
==Overview of the Classes==
Almost all classes that compose BQL statements are derived from the <tt>IBqlCreator</tt> interface, which inherits from the <tt>IBqlVerifier</tt> interface. These interfaces provide the following key methods: [anchor|#_3f6fb5af-1791-4ced-93b3-551c0377d084]
*<tt>IBqlCreator.AppendExpression()</tt>: Used during a BQL command preparation to translate a BQL statement into an SQL tree expression, which is then produces the SQL text to be sent to the database maintenance server. For more information on how this method is used during BQL statement execution, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
*<tt>IBqlVerifier.Verify()</tt>: Used during the merge of the records with <tt>PXCache</tt> to evaluate a condition on a record retrieved from the database or calculate an expression with the record. For details on the merge, see [HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache].
{br}

Depending on the purpose of each BQL class, the class also implements the methods of the interfaces derived from the <tt>IBqlCreator</tt> interface. For example, the aggregation functions—such as <tt>Sum</tt>, <tt>Avg</tt>, <tt>Min</tt>, and <tt>Max</tt>—implement the methods of the <tt>IBqlFunction</tt> interface. {br}

The high-level overview of BQL class inheritance is illustrated in the following diagram. For descriptions of the interfaces and classes, see the API Reference.[anchor|#_2850a196-2b5e-4500-abbe-3aedefe693cd][anchor|#_c9987692-faad-4c84-9387-3861ef7b2195][image:StudioDeveloperGuide/Images/BQLCommands.png|popup|BQL commands|450px]{br}

The sections below describe the classes derived from the <tt>BqlCommand</tt> class.
==Select Classes==
The <tt>Select</tt> classes, which are derived from the <tt>BqlCommand</tt> class, represent BQL commands and select all bound fields of the DAC and the unbound fields with specific attributes, such as <tt>PXDBCalced</tt>. ((({S:Warn}More specific, the <tt>Select</tt> classes select all DAC fields that are decorated with the attributes that subscribe to the <tt>PXCommandPreparing</tt> event. For details on which fields are selected, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
))){br}

In a BQL expression based on <tt>Select</tt>, the first type parameter is a DAC, as shown in the following sample BQL statement. <source lang="csharp">Select&lt;Product&gt;</source>
The <tt>Select</tt> classes can parse themselves into SQL and provide methods for modifying the BQL command. However, you cannot directly use the <tt>Select</tt> class to execute the BQL query. Typically, you use <tt>Select</tt> in attributes in DACs, such as the <tt>PXProjection</tt> attribute.
==Search Classes==
The <tt>Search</tt> classes, which are derived from the <tt>BqlCommand</tt> class, select one field of a DAC (while the <tt>Select</tt> classes select multiple fields). {br}

In a <tt>Search</tt>-based statement, the first type parameter is a DAC field, as shown in the following sample BQL expression. This expression selects the <tt>Product.unitPrice</tt> field.<source lang="csharp">Search&lt;Product.unitPrice&gt;</source>These classes can parse themselves into SQL and provide methods for modifying the BQL command. However, you cannot directly use the <tt>Search</tt> class to execute the BQL query. Typically, you use <tt>Search</tt> in attributes in DACs, such as the <tt>PXSelector</tt> attribute. (<tt>PXSelectorAttribute</tt> requires a <tt>Search</tt> class and not a <tt>Select</tt> because the lookup control, which is configured by this attribute, displays precisely one field (usually a key field), which is what <tt>Search</tt> returns.)
==BqlCommand Classes==
The <tt>BqlCommand</tt> classes represent BQL commands. The system uses the following types of <tt>BqlCommand</tt> classes:[anchor|#_70c4aa70-6941-48e5-b434-ba17028cf6ae]
*<tt>BqlCommand</tt>: This base class for the <tt>Select</tt> and <tt>Search</tt> classes is used by the system during the processing of data queries on the data entry forms.
*<tt>BqlGenericCommand</tt>: This class, which is derived from the <tt>BqlCommand</tt> class, is used by the system during the processing of generic inquiries.
*<tt>BqlSoapCommand</tt>: This class, which is derived from the <tt>BqlCommand</tt> class, is used by the system during the processing of reports. For details on report processing, see [HelpRoot_Dev_Platform\CC__con_Rendering_of_Reports|Display of Reports].

The main purpose of <tt>BqlCommand</tt> classes is to convert BQL commands to SQL text. The <tt>BqlGenericCommand</tt> and <tt>BqlSoapCommand</tt> classes provide additional methods for generic inquiry and report processing.
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL]]]></column>
			<column name="PlainText"><![CDATA[The Classes That Compose BQL Statements This topic contains an overview of the classes that you use to compose business query                 language (BQL) statements inside  PXSelect  and to define                 attributes of DACs. Overview of the Classes Almost all classes that compose BQL statements are derived from the                      IBqlCreator  interface, which inherits from the                      IBqlVerifier  interface. These interfaces provide the                 following key methods:  IBqlCreator.AppendExpression() : Used during a BQL command                         preparation to translate a BQL statement into an SQL tree expression, which                         is then produces the SQL text to be sent to the database maintenance server.                         For more information on how this method is used during BQL statement                         execution, see  Translation of a BQL Command to SQL. IBqlVerifier.Verify() : Used during the merge of the                         records with  PXCache  to evaluate a condition on a record                         retrieved from the database or calculate an expression with the record. For                         details on the merge, see  Merge of the Records with PXCache. Depending on the purpose of each BQL class, the class also implements the methods of                 the interfaces derived from the  IBqlCreator  interface. For                 example, the aggregation functions—such as  Sum ,                      Avg ,  Min , and                  Max —implement the methods of the                      IBqlFunction  interface.  The high-level overview of BQL class inheritance is illustrated in the following                 diagram. For descriptions of the interfaces and classes, see the API Reference. BQL commands The sections below describe the classes derived from the                      BqlCommand  class. Select Classes The  Select  classes, which are derived from the                      BqlCommand  class, represent BQL commands and select all bound                 fields of the DAC and the unbound fields with specific attributes, such as                      PXDBCalced .  More specific, the                          Select  classes select all DAC fields that are decorated                     with the attributes that subscribe to the  PXCommandPreparing                      event. For details on which fields are selected, see  Translation of a BQL Command to SQL. In a BQL expression based on  Select , the first type parameter is a                 DAC, as shown in the following sample BQL statement.  Select<Product> The  Select  classes can parse themselves into SQL and provide                 methods for modifying the BQL command. However, you cannot directly use the                      Select  class to execute the BQL query. Typically, you use                      Select  in attributes in DACs, such as the                      PXProjection  attribute. Search Classes The  Search  classes, which are                 derived from the  BqlCommand  class, select one field of a DAC                 (while the  Select  classes select multiple fields).  In a                      Search -based statement, the first type parameter is a DAC                 field, as shown in the following sample BQL expression. This expression selects the                      Product.unitPrice              field. Search<Product.unitPrice> These             classes can parse themselves into SQL and provide methods for modifying the BQL command.             However, you cannot directly use the  Search  class to execute the BQL             query. Typically, you use  Search  in attributes in DACs, such as the                  PXSelector  attribute. ( PXSelectorAttribute              requires a  Search  class and not a  Select  because             the lookup control, which is configured by this attribute, displays precisely one field             (usually a key field), which is what  Search  returns.) BqlCommand Classes The  BqlCommand  classes represent BQL commands. The system uses the                 following types of  BqlCommand  classes: BqlCommand : This base class for the  Select                      and  Search  classes is used by the system during the                     processing of data queries on the data entry forms. BqlGenericCommand : This class, which is derived from the                          BqlCommand  class, is used by the system during the                     processing of generic inquiries. BqlSoapCommand : This class, which is derived from the                          BqlCommand  class, is used by the system during the                     processing of reports. For details on report processing, see  Display of Reports. The main purpose of  BqlCommand  classes is to convert BQL commands                 to SQL text. The  BqlGenericCommand  and                      BqlSoapCommand  classes provide additional methods for generic                 inquiry and report processing. ]]></column>
		</row>
		<row PageID="546dcc53-3648-4c09-a940-afb5692cdfdf" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="99ff3cc7-ef21-e469-0d4f-a81b915185e1" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you need to specify values in a business query language (BQL) statement, you use BQL parameters, which are replaced with the needed values in the translation to SQL. For details, how BQL statements with parameters are translated to SQL, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL#_ff6436a7-d8a9-43c8-9201-d5ea9afbe2d5|Translation of a BQL Command with Parameters to an SQL Query Tree].{br}

In this topic, you can find the description of the BQL parameters and the difference between them.{br}{TOC}
==Current and Current2==
The <tt>Current</tt> parameter, as well as the <tt>Current2</tt> parameter, inserts the field value of the <tt>Current</tt> object from the <tt>PXCache</tt> object in the SQL query. If the <tt>Current</tt> object from the <tt>PXCache</tt> object is {{null}}, the <tt>Current</tt> parameter retrieves the default value of the field, while the <tt>Current2</tt> parameter doesn&rsquo;t retrieve the default value and inserts {{null}}.{br}

By using the <tt>Current</tt> or <tt>Current2</tt> parameter in the declaration of a data view, you can refer to another view to relate these data views to each other. A typical example is referencing the current master record on master-detail forms. For details on how the <tt>Current</tt> and <tt>Current2</tt> parameters are used, see [HelpRoot_Dev_Platform\AD__how_BQL_Parameters#_def33638-9099-460b-b2d8-b93f75871625|To Relate Data Views to One Another].
==Required==
The <tt>Required</tt> parameter inserts a specific value into the SQL query. {br}

By using the <tt>Required</tt> parameters, you can pass values to the SQL query, as described in [HelpRoot_Dev_Platform\AD__how_BQL_Parameters#_6e19063a-c756-4b7d-88a0-7d0100a187d9|To Pass a Field Value to the SQL Query] and [HelpRoot_Dev_Platform\AD__how_BQL_Parameters#_cc3c4e58-b049-4351-b3c6-ebd9e62a350d|To Pass Multiple Field Values to the SQL Query].
==Optional and Optional2==
The <tt>Optional</tt> parameter works similarly to <tt>Current</tt> (as well as the <tt>Optional2</tt> parameter works similarly to <tt>Current2</tt>) if you don&rsquo;t specify an explicit value for this parameter during BQL statement execution. However, you can also pass an explicit value of the parameter to the SQL query. {br}

By using the <tt>Optional</tt> or <tt>Optional2</tt> parameters, you can pass the external presentations of the values to the SQL query, as described in [HelpRoot_Dev_Platform\AD__how_BQL_Parameters#_4473b629-e9a7-4f41-9041-c0442303d2be|To Provide External Presentation of the Field Value to the SQL Query].{br}

When a DAC includes more than one key field, you may need to use <tt>Optional&lt;&gt;</tt> in the primary data view of the graph. In this case, the primary data view typically filters the data records by all of the key fields except the last one. For example, you can select documents with the same document type as the current data record has and navigate through these documents with different document numbers. In the following example, the {{Document}} DAC has two key fields, {{DocType}} and {{DocNbr}}.<source lang="csharp">public PXSelect&lt;Document,
        Where&lt;Document.docType, Equal&lt;<b>Optional&lt;Document.docType&gt;<b>&gt;&gt;&gt; Receipts;</source>
<tt>Optional&lt;&gt;</tt> could be replaced with <tt>Current&lt;&gt;</tt> in the code above unless you need to execute the {{Receipts}} data view in code to select a document with specific document type and number.((({S:Warn}If a data view contains the <tt>Optional&lt;&gt;</tt> and <tt>Required&lt;&gt;</tt> parameters, you should provide values for all <tt>Optional&lt;&gt;</tt> parameters that go before the <tt>Required&lt;&gt;</tt> parameters. For example, if you have the following operands in the query, the number of parameters is:[anchor|#ul_bzr_j4s_mm]
*{{<Required<A>>.... <Optional<B>>... <Required<C>>}}: Always 3 parameters
*{{<Required<A>>.... <Optional<B>>... <Required<C>>.... <Optional<D>>}}: At least 3 parameters
*{{<Required<A>>....<Required<B>>.... <Optional<C>>}}: At least 2 parameters
)))
==Argument==
The <tt>Argument</tt> parameter passes values from UI controls to the SQL query. {br}

By using the <tt>Argument</tt> parameters, you can pass values to the data view delegates. For more information on how to use the <tt>Argument</tt> parameter, see [HelpRoot_Dev_Platform\AD__how_BQL_Parameters#_1f3bef64-92a7-469f-9fd2-89f0910565fe|To Pass a Value from a UI Control to a Data View].
==Related Articles==
*[HelpRoot_Dev_Platform\AD__how_BQL_Parameters|To Use Parameters in Traditional BQL]]]></column>
			<column name="PlainText"><![CDATA[Parameters in Traditional BQL Statements If you need to specify values in a business query language (BQL) statement, you use BQL     parameters, which are replaced with the needed values in the translation to SQL. For details,     how BQL statements with parameters are translated to SQL, see  Translation of a BQL Command with Parameters to an SQL Query Tree. In this topic, you can find the description of the BQL parameters and the difference between     them. Current and Current2 The  Current  parameter, as well as the  Current2      parameter, inserts the field value of the  Current  object from the       PXCache  object in the SQL query. If the  Current  object     from the  PXCache  object is  null , the       Current  parameter retrieves the default value of the field, while the       Current2  parameter doesn't retrieve the default value and inserts       null . By using the  Current  or  Current2  parameter in the     declaration of a data view, you can refer to another view to relate these data views to each     other. A typical example is referencing the current master record on master-detail forms. For     details on how the  Current  and  Current2  parameters are     used, see  To Relate Data Views to One Another. Required The  Required  parameter inserts a specific value into the SQL query.  By using the  Required  parameters, you can pass values to the SQL query, as     described in  To Pass a Field Value to the SQL Query and  To Pass Multiple Field Values to the SQL Query. Optional and Optional2 The  Optional  parameter works similarly to  Current  (as     well as the  Optional2  parameter works similarly to       Current2 ) if you don't specify an explicit value for this parameter during     BQL statement execution. However, you can also pass an explicit value of the parameter to the     SQL query.  By using the  Optional  or  Optional2  parameters, you can     pass the external presentations of the values to the SQL query, as described in  To Provide External Presentation of the Field Value to the SQL Query. When a DAC includes more than one key field, you may need to use       Optional<>  in the primary data view of the graph. In this case, the     primary data view typically filters the data records by all of the key fields except the last     one. For example, you can select documents with the same document type as the current data     record has and navigate through these documents with different document numbers. In the     following example, the  Document  DAC has two key fields,       DocType  and  DocNbr . public PXSelect<Document,
        Where<Document.docType, Equal< Optional<Document.docType> >>> Receipts; Optional<>  could be replaced with  Current<>  in the     code above unless you need to execute the  Receipts  data view in code to select     a document with specific document type and number. If a data view contains the        Optional<>  and  Required<>  parameters, you should      provide values for all  Optional<>  parameters that go before the        Required<>  parameters. For example, if you have the following operands      in the query, the number of parameters is: <Required<A>>.... <Optional<B>>... <Required<C>> :        Always 3 parameters <Required<A>>.... <Optional<B>>... <Required<C>>....         <Optional<D>> : At least 3 parameters <Required<A>>....<Required<B>>.... <Optional<C>> : At        least 2 parameters Argument The  Argument  parameter passes values from UI controls to the SQL query.  By using the  Argument  parameters, you can pass values to the data view     delegates. For more information on how to use the  Argument  parameter, see       To Pass a Value from a UI Control to a Data View. ]]></column>
		</row>
		<row PageID="5e4ecd15-69fc-4f39-9076-0adb7a928129" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="30f4485f-db91-0865-3252-85562c8e5d67" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The traditional business query language (BQL) library defines the following SQL function equivalents. Note that the use of the BQL equivalents may slightly differ from the use of the corresponding SQL functions. For details on each BQL class, see the API Reference.[anchor|#_43e80f78-d9da-43b1-8aec-dde8ecbf5a50]
===Correspondence Between SQL and BQL===
{| class="checklist" | width="100%" 
|- 
!width="50%" ! SQL
!width="50%" ! Traditional BQL
|- 
| colspan="2" | '''Clauses'''
|- 
| {{WHERE}}
| <tt>Where</tt>
|- 
| {{INNER JOIN}}
| <tt>InnerJoin</tt>
|- 
| {{LEFT JOIN}}
| <tt>LeftJoin</tt>
|- 
| {{RIGHT JOIN}}
| <tt>RightJoin</tt>
|- 
| {{FULL JOIN}}
| <tt>FullJoin</tt>
|- 
| {{CROSS JOIN}}
| <tt>CrossJoin</tt>
|- 
| {{ON}}
| <tt>On</tt>, <tt>On2</tt>
|- 
| {{ORDER BY}}
| <tt>OrderBy</tt>
|- 
| {{ASC}}
| <tt>Asc</tt>
|- 
| {{DESC}}
| <tt>Desc</tt>
|- 
| {{GROUP BY}}
| <tt>Aggregate</tt>, <tt>GroupBy</tt>
|- 
| {{HAVING}}
| <tt>Having</tt>
|- 
| colspan="2" |  '''Aggregation Functions'''
|- 
| {{AVG}}
| <tt>Avg</tt>
|- 
| {{SUM}}
| <tt>Sum</tt>
|- 
| {{MIN}}
| <tt>Min</tt>
|- 
| {{MAX}}
| <tt>Max</tt>
|- 
| {{COUNT}}
| <tt>Count</tt>
|- 
| colspan="2" |  '''Functions'''
|- 
| {{ISNULL}}
| <tt>IsNull&lt;Operand1, Operand2&gt;</tt>
|- 
| {{NULLIF}}
| <tt>NullIf</tt>
|- 
| {{ROUND}}
| <tt>Round</tt>
|- 
| {{SUBSTRING}}
| <tt>Substring</tt>
|- 
| {{CONCAT}}
| <tt>Add</tt>
|- 
| {{RTRIM}}
| <tt>RTrim</tt>
|- 
| {{REPLACE}}
| <tt>Replace</tt>
|- 
| {{DATEDIFF}}
| <tt>DateDiff</tt>
|- 
| {{CASE}}
| <tt>Switch</tt>, <tt>Case</tt>
|- 
| colspan="2" |  '''Arithmetic Operations'''
|- 
| {{(Operand1 + Operand2)}}
| <tt>Add&lt;Operand1, Operand2&gt;</tt>
|- 
| {{(Operand1 - Operand2)}}
| <tt>Sub&lt;Operand1, Operand2&gt;</tt>
|- 
| {{(Operand1 * Operand2)}}
| <tt>Mult&lt;Operand1, Operand2&gt;</tt>
|- 
| {{(Operand1 / Operand2)}}
| <tt>Div&lt;Operand1, Operand2&gt;</tt>
|- 
| {{-Operand}}
| <tt>Minus&lt;Operand&gt;</tt>
|- 
| {{POWER(Operand1, Operand2)}}
| <tt>Power&lt;Operand1, Operand2&gt;</tt>
|- 
| colspan="2" |  '''Comparisons'''
|- 
| {{=}}
| <tt>Equal</tt>
|- 
| {{<>}}
| <tt>NotEqual</tt>
|- 
| {{>}}
| <tt>Greater</tt>
|- 
| {{<}}
| <tt>Less</tt>
|- 
| {{<=}}
| <tt>LessEqual</tt>
|- 
| {{<=}}
| <tt>GreaterEqual</tt>
|- 
| {{LIKE}}
| <tt>Like</tt>
|- 
| {{NOT LIKE}}
| <tt>NotLike</tt>
|- 
| {{BETWEEN}}
| <tt>Between</tt>
|- 
| {{NOT BETWEEN}}
| <tt>NotBetween</tt>
|- 
| {{IS NULL}}
| <tt>IsNull</tt>
|- 
| {{IS NOT NULL}}
| <tt>IsNotNull</tt>
|- 
| {{IN}}
| <tt>In</tt>, <tt>In2</tt>, <tt>In3</tt>
|- 
| {{NOT IN}}
| <tt>NotIn</tt>, <tt>NotIn2</tt>
|- 
| {{EXISTS}}
| <tt>Exists</tt>
|- 
| colspan="2" |  '''Logical Operators'''
|- 
| {{AND}}
| <tt>And</tt>, <tt>And2</tt>
|- 
| {{OR}}
| <tt>Or</tt>, <tt>Or2</tt>
|- 
| {{NOT}}
| <tt>Not</tt>, <tt>Not2</tt>
|- 
| colspan="2" |  '''Constants'''
|- 
| {{NULL}}
| <tt>Null</tt>
|- 
| Other constants
| <tt>Now</tt>, <tt>Today</tt>, <tt>Tomorrow</tt>, <tt>True</tt>, <tt>False</tt>, <tt>Zero</tt>, <tt>StringEmpty</tt>, <tt>MaxDate</tt>
|- 
| colspan="2" |  '''Full-Text Search Functions'''
|- 
| {{FREETEXTTABLE}}
| <tt>FreeText</tt>
|- 
| {{CONTAINSTABLE}}
| <tt>Contains</tt>
|}]]></column>
			<column name="PlainText"><![CDATA[Traditional BQL and SQL Equivalents The traditional business query language (BQL) library defines the following SQL function    equivalents. Note that the use of the BQL equivalents may slightly differ from the use of the    corresponding SQL functions. For details on each BQL class, see the API Reference. Correspondence Between SQL and BQL SQL Traditional BQL Clauses WHERE Where INNER JOIN InnerJoin LEFT JOIN LeftJoin RIGHT JOIN RightJoin FULL JOIN FullJoin CROSS JOIN CrossJoin ON On ,  On2 ORDER BY OrderBy ASC Asc DESC Desc GROUP BY Aggregate ,  GroupBy HAVING Having Aggregation Functions AVG Avg SUM Sum MIN Min MAX Max COUNT Count Functions ISNULL IsNull<Operand1, Operand2> NULLIF NullIf ROUND Round SUBSTRING Substring CONCAT Add RTRIM RTrim REPLACE Replace DATEDIFF DateDiff CASE Switch ,  Case Arithmetic Operations (Operand1 + Operand2) Add<Operand1, Operand2> (Operand1 - Operand2) Sub<Operand1, Operand2> (Operand1 * Operand2) Mult<Operand1, Operand2> (Operand1 / Operand2) Div<Operand1, Operand2> -Operand Minus<Operand> POWER(Operand1, Operand2) Power<Operand1, Operand2> Comparisons = Equal <> NotEqual > Greater < Less <= LessEqual <= GreaterEqual LIKE Like NOT LIKE NotLike BETWEEN Between NOT BETWEEN NotBetween IS NULL IsNull IS NOT NULL IsNotNull IN In ,  In2 ,  In3 NOT IN NotIn ,  NotIn2 EXISTS Exists Logical Operators AND And ,  And2 OR Or ,  Or2 NOT Not ,  Not2 Constants NULL Null Other constants Now ,  Today ,  Tomorrow ,           True ,  False ,  Zero ,           StringEmpty ,  MaxDate Full-Text Search Functions FREETEXTTABLE FreeText CONTAINSTABLE Contains ]]></column>
		</row>
		<row PageID="610ce4e6-85e6-48e1-8a89-317a6a7f0542" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="906cc1a8-c3d4-803c-b49a-e181aadc6b13" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To select records from the database, you can construct a business query language (BQL) statement. To construct a BQL statement, you use one of the generic <tt>PXSelect</tt> classes. You select the needed <tt>PXSelect</tt> class depending on the statement you need to compose, as described in the sections of this topic.((({S:Warn}In a <tt>PXSelect</tt> class, you configure a query to the database. The actual request to the database is performed once you cast the result of the query execution to a DAC or an array of DACs, or iterate through DACs in the result with the {{foreach}} statement. For details, see [HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution].
))){br}{TOC}[anchor|#_1f0a8248-99eb-4897-be95-8bb852d09cbc]
==Before You Proceed==
Make sure that the application database has the database tables from which you are going to request data, and that the application defines the data access classes (DACs) for these tables. For more information on defining DACs, see [HelpRoot_Dev_Platform\AD__con_DACs_in_TraditionalBQL|Data Access Classes in Traditional BQL].[anchor|#_437434b0-16db-4efd-8f2d-51011ed2b6bb]
==To Select All Records from a Database Table==
To select all data from one database table without applying any filtering conditions or ordering, use one of the <tt>PXSelect</tt> classes that has DAC as the only type parameter, such as the <tt>PXSelect&lt;Table&gt;</tt> or <tt>PXSelectReadonly&lt;Table&gt;</tt> class, as shown in the following sample BQL statement. <source lang="csharp">PXSelect&lt;Product&gt;</source>{br}

In this BQL statement, you are selecting all data records (with the values of all bound fields) from the <tt>Product</tt> table.((({S:Warn}For example, suppose that the <tt>Product</tt> table has two columns, {{ProductID}} and {{UnitPrice}}. In this case, Acumatica Framework translates the previous BQL statement to the following SQL query. The framework adds ordering by the DAC key field (in ascending order) to the end of the SQL query because the BQL statement does not specify ordering.{{{{SELECT Product.ProductID, Product.UnitPrice FROM Product 
       ORDERBY Product.ProductID
}}}}
)))[anchor|#_87d6f3c4-7c4a-49d1-bcf7-4ae37c27e7bd]
==To Filter Records==
To filter records in the database table to be retrieved, construct a BQL statement with conditions by doing the following:[anchor|#_3973149d-e87e-41e2-a8e6-3ea95678e257]
#Use one of the <tt>PXSelect</tt> classes that has the <tt>Where</tt> type parameter, such as <tt>PXSelect&lt;Table, Where&gt;</tt>. For the full list of <tt>PXSelect</tt> classes, see [HelpRoot_Dev_Platform\AD__con_BQL_PXSelect|PXSelect Classes].
#Specify the filtering conditions by using the <tt>Where</tt> clause, as described in [HelpRoot_Dev_Platform\AD__how_BQL_Filter|To Filter Records].
#To specify the fields that should be used for filtering, use the class fields defined in the DACs, such as <tt>Product.productID</tt>. (The name of the field class starts with a lowercase letter. Do not confuse it with the property field, which has the same name but starts with uppercase letter.) 
The following sample BQL statement selects all data records from the {{Product}} table that have the specified value in the {{ProductID}} column.<source lang="csharp">PXSelect&lt;Product,
    Where&lt;Product.productID, Equal&lt;Required&lt;Product.productID&gt;&gt;&gt;&gt;</source>((({S:Warn} Acumatica Framework translates the previous BQL statement to the following SQL query. In this SQL query, {{[list of columns]}} is the list of columns of the {{Product}} table; {{[parameter]}} is the value passed to the <tt>Select()</tt> method of the <tt>PXSelect</tt> class, which is called when the BQL query is executed. {{{{SET @P0 = [parameter];

SELECT [list of columns] FROM Product
    WHERE Product.ProductID = @P0
        ORDERBY Product.ProductID
}}}}[anchor|#_2daf7159-76e6-416c-8731-8b25229b768b]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))[anchor|#_5325d553-3534-4c24-953f-e32fca5d2cb3]
==To Order Records==
To order records in the database table to be retrieved, construct a BQL statement with ordering by doing the following:[anchor|#_72c05844-0d84-4787-baeb-6ea7b766f0f3]
#Use one of the <tt>PXSelect</tt> classes that has the <tt>OrderBy</tt> type parameter, such as <tt>PXSelectOrderBy&lt;Table, OrderBy&gt;</tt> or <tt>PXSelect&lt;Table, Where, OrderBy&gt;</tt>. For the full list of <tt>PXSelect</tt> classes, see [HelpRoot_Dev_Platform\AD__con_BQL_PXSelect|PXSelect Classes].
#Use the <tt>OrderBy</tt> clause to order records, as described in [HelpRoot_Dev_Platform\AD__how_BQL_OrderBy|To Order Records].
#To specify the field that should be used for filtering, use the class field defined in the DAC, such as <tt>Product.productID</tt>. (The name of the field class starts with a lowercase letter. Do not confuse it with the property field, which has the same name but starts with uppercase letter.) 
{br}

The following sample BQL statement selects all <tt>Product</tt> data records and sorts them by the <tt>UnitPrice</tt> field in ascending order.{{{{PXSelectOrderBy&lt;Product, OrderBy&lt;Asc&lt;Product.unitPrice&gt;&gt;&gt;
}}}}((({S:Warn} Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice
}}}}[anchor|#_27deb0ea-812d-4521-a423-1a8e9076ced4]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
==To Query Multiple Tables==
To join multiple tables, construct a BQL statement by doing the following:[anchor|#_5783419b-1d0c-4fdb-9088-95f07ad44c23]
#Use one of the <tt>PXSelect</tt> classes that has the <tt>Join</tt> type parameter, such as <tt>PXSelectJoin&lt;Table, Join&gt;</tt> or <tt>PXSelectReadonly2&lt;Table, Join&gt;</tt>.
#In the <tt>Join</tt> type parameter of the <tt>PXSelect</tt> class, use one of the <tt>Join</tt> clauses—such as <tt>InnerJoin</tt>, <tt>LeftJoin</tt>, <tt>RightJoin</tt>, <tt>FullJoin</tt>, or <tt>CrossJoin</tt>—that are directly mapped to SQL <tt>JOIN</tt> clauses, as shown in the following sample BQL statement. For more information on the use of <tt>Join</tt> clauses, see [HelpRoot_Dev_Platform\AD__how_Query_Multiple_Tables|To Query Multiple Tables].<source lang="csharp">PXSelectJoin&lt;SalesOrder,
    InnerJoin&lt;OrderDetail,
        On&lt;OrderDetail.orderNbr, Equal&lt;SalesOrder.orderNbr&gt;&gt;&gt;&gt;</source>
#:((({S:Warn}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the joined tables. {{{{SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr
}}}}[anchor|#_89e71337-549c-4f0d-b8db-5daa94d5ca55] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))

==To Aggregate Records==
To group or aggregate records, construct a BQL statement by doing the following:[anchor|#_b13792db-22a0-4dba-a506-419c05130cbe]
#Use one of the <tt>PXSelect</tt> classes with the <tt>Aggregate</tt> type parameter, such as <tt>PXSelectGroupBy&lt;Table, Aggregate&gt;</tt>.
#In the <tt>Aggregate</tt> type parameter of the <tt>PXSelect</tt> class, specify the grouping conditions and aggregation functions by using the <tt>Aggregate&lt;Function&gt;</tt> class, the <tt>GroupBy</tt> clauses, and the <tt>Min</tt>, <tt>Max</tt>, <tt>Sum</tt>, <tt>Avg</tt>, and <tt>Count</tt> aggregation functions, as shown in the following sample BQL statement. For more information on the use of the grouping conditions and aggregation functions, see [HelpRoot_Dev_Platform\AD__how_BQL_Group_and_Aggregate|To Group and Aggregate Records].<source lang="csharp">PXSelectGroupBy&lt;Product,
    Aggregate&lt;GroupBy&lt;Product.categoryCD&gt;&gt;&gt;</source>
#:((({S:Warn}Acumatica Framework translates the previous BQL statement to the following SQL query. {{{{SELECT Product.CategoryCD,
       [MAX(Field) for other fields]
FROM Product
GROUP BY Product.CategoryCD
}}}}
)))

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_BQL_PXSelect|PXSelect Classes]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=82e24896-5ff7-a1fe-a0f8-9bff0ddf27ea|PXSelect&lt;Table, Where, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5ec6f10c-23ef-14aa-6f01-31a2679baebc|PXSelect&lt;Table, Where&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=df23e254-51d3-6c56-2532-55f3602c486b|PXSelect&lt;Table&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=91a0013f-35d6-edeb-0807-74d1754fc756|PXSelectGroupBy&lt;Table, Aggregate&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=aa1de26d-e076-e380-ef3b-3e4af9e4962a|PXSelectGroupBy&lt;Table, Where, Aggregate, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ab32e32c-e84e-f3cb-149d-f4790e5cc800|PXSelectGroupBy&lt;Table, Where, Aggregate&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ad8688e6-5353-143c-7d1f-2d7606c8e393|PXSelectGroupByOrderBy&lt;Table, Aggregate, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=4fc392e5-99e7-73cc-b526-49ccce3e05c2|PXSelectGroupByOrderBy&lt;Table, Join, Aggregate, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=49aea5fc-82e2-ca3b-d766-128f52b544b8|PXSelectJoin&lt;Table, Join, Where, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b3d13bad-ec9d-121e-d0bb-0ddb9c3ed7d1|PXSelectJoin&lt;Table, Join, Where&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=bc94968c-2642-d512-d7f7-a0d286b59126|PXSelectJoin&lt;Table, Join&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c4b6e1f7-866e-58b5-a196-5389e0a7bfe6|PXSelectJoinGroupBy&lt;Table, Join, Aggregate&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e7e783a3-cff9-85da-8681-ecee191db62d|PXSelectJoinGroupBy&lt;Table, Join, Where, Aggregate, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fcb1550e-f1df-7cb1-fb71-865b4646498d|PXSelectJoinGroupBy&lt;Table, Join, Where, Aggregate&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b0667493-2ad5-c38a-e80e-e17818841dc5|PXSelectJoinOrderBy&lt;Table, Join, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fdf23b92-19c4-f2b3-27ec-dd80a240820a|PXSelectOrderBy&lt;Table, Join, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8e8c6674-d029-5f35-069a-b70a9c3e7938|PXSelectOrderBy&lt;Table, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d6496092-e1a7-66b7-a1fa-8ab4dee0a035|PXSelectReadonly&lt;Table, Where, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a0e97d1d-b640-12ee-b6df-54e90d5c73ca|PXSelectReadonly&lt;Table, Where&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a17a006c-90fe-e3b2-df96-0cbddc84cd5d|PXSelectReadonly&lt;Table&gt; ]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=549c3942-b680-1c50-3e63-f8cb423956c1|PXSelectReadonly2&lt;Table, Join, Where, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a0f3fe13-d460-4f0d-b302-4c6fb38a27ae|PXSelectReadonly2&lt;Table, Join, Where&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5349f5f1-6f58-9ac0-1bdd-cab07e51168b|PXSelectReadonly2&lt;Table, Join&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=235c9fa2-ca6a-27d2-f6ce-d145b2608e23|PXSelectReadonly3&lt;Table, Join, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1cb18bdd-100a-d8d0-a81d-ce74c95757e0|PXSelectReadonly3&lt;Table, OrderBy&gt;]]]></column>
			<column name="PlainText"><![CDATA[To Select Records By Using Traditional BQL To select records from the database, you can construct a business query language (BQL)         statement. To construct a BQL statement, you use one of the generic            PXSelect  classes. You select the needed  PXSelect          class depending on the statement you need to compose, as described in the sections of this           topic. In a  PXSelect  class, you configure a query to the database.           The actual request to the database is performed once you cast the result of the query           execution to a DAC or an array of DACs, or iterate through DACs in the result with the              foreach  statement. For details, see  Data Query Execution. Before You Proceed Make sure that the application database has the database tables from which you are going to         request data, and that the application defines the data access classes (DACs) for these         tables. For more information on defining DACs, see  Data Access Classes in Traditional BQL. To Select All Records from a Database Table To select all data from one database table without applying any filtering conditions or         ordering, use one of the  PXSelect  classes that has DAC as the only type         parameter, such as the  PXSelect<Table>  or            PXSelectReadonly<Table>  class, as shown in the following sample BQL         statement.  PXSelect<Product> In this BQL statement, you are selecting all data records (with the values of all bound         fields) from the  Product  table. For example, suppose that the              Product  table has two columns,  ProductID  and              UnitPrice . In this case,  Acumatica Framework translates the previous BQL statement to the following SQL query. The framework adds           ordering by the DAC key field (in ascending order) to the end of the SQL query because the           BQL statement does not specify           ordering. SELECT Product.ProductID, Product.UnitPrice FROM Product 
       ORDERBY Product.ProductID To Filter Records To filter records in the database table to be retrieved, construct a BQL statement with         conditions by doing the following: Use one of the  PXSelect  classes that has the                Where  type parameter, such as  PXSelect<Table,               Where> . For the full list of  PXSelect  classes, see  PXSelect Classes. Specify the filtering conditions by using the  Where  clause, as             described in  To Filter Records. To specify the fields that should be used for filtering, use the class fields defined             in the DACs, such as  Product.productID . (The name of the field class             starts with a lowercase letter. Do not confuse it with the property field, which has the             same name but starts with uppercase letter.)  The following sample BQL statement selects all data records from the            Product  table that have the specified value in the            ProductID  column. PXSelect<Product,
    Where<Product.productID, Equal<Required<Product.productID>>>>  Acumatica Framework         translates the previous BQL statement to the following SQL query. In this SQL query,            [list of columns]  is the list of columns of the  Product          table;  [parameter]  is the value passed to the  Select()          method of the  PXSelect  class, which is called when the BQL query is         executed.            SET @P0 = [parameter];

SELECT [list of columns] FROM Product
    WHERE Product.ProductID = @P0
        ORDERBY Product.ProductID  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Order Records To order records in the database table to be retrieved, construct a BQL statement with         ordering by doing the following: Use one of the  PXSelect  classes that has the                OrderBy  type parameter, such as  PXSelectOrderBy<Table,               OrderBy>  or  PXSelect<Table, Where, OrderBy> . For the             full list of  PXSelect  classes, see  PXSelect Classes. Use the  OrderBy  clause to order records, as described in  To Order Records. To specify the field that should be used for filtering, use the class field defined in             the DAC, such as  Product.productID . (The name of the field class             starts with a lowercase letter. Do not confuse it with the property field, which has the             same name but starts with uppercase letter.)  The following sample BQL statement selects all  Product  data records and         sorts them by the  UnitPrice  field in ascending order. PXSelectOrderBy<Product, OrderBy<Asc<Product.unitPrice>>>  Acumatica Framework         translates the previous BQL statement to the following SQL query, where  [list of           columns]  is the list of columns of the  Product            table. SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Query Multiple Tables To join multiple tables, construct a BQL statement by doing the following: Use one of the  PXSelect  classes that has the                Join  type parameter, such as  PXSelectJoin<Table,               Join>  or  PXSelectReadonly2<Table, Join> . In the  Join  type parameter of the  PXSelect              class, use one of the  Join  clauses—such as                InnerJoin ,  LeftJoin ,                RightJoin ,  FullJoin , or                CrossJoin —that are directly mapped to SQL                JOIN  clauses, as shown in the following sample BQL statement. For             more information on the use of  Join  clauses, see  To Query Multiple Tables. PXSelectJoin<SalesOrder,
    InnerJoin<OrderDetail,
        On<OrderDetail.orderNbr, Equal<SalesOrder.orderNbr>>>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                  [list of columns]  is the list of columns of the joined tables.                  SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Aggregate Records To group or aggregate records, construct a BQL statement by doing the following: Use one of the  PXSelect  classes with the                Aggregate  type parameter, such as                PXSelectGroupBy<Table, Aggregate> . In the  Aggregate  type parameter of the  PXSelect              class, specify the grouping conditions and aggregation functions by using the                Aggregate<Function>  class, the  GroupBy              clauses, and the  Min ,  Max ,  Sum ,                Avg , and  Count  aggregation functions, as shown             in the following sample BQL statement. For more information on the use of the grouping             conditions and aggregation functions, see  To Group and Aggregate Records. PXSelectGroupBy<Product,
    Aggregate<GroupBy<Product.categoryCD>>> Acumatica Framework translates the previous BQL statement to the following SQL query.                SELECT Product.CategoryCD,
       [MAX(Field) for other fields]
FROM Product
GROUP BY Product.CategoryCD PXSelect<Table,       Where, OrderBy> PXSelect<Table,       Where> PXSelect<Table> PXSelectGroupBy<Table, Aggregate> PXSelectGroupBy<Table, Where, Aggregate,         OrderBy> PXSelectGroupBy<Table, Where, Aggregate> PXSelectGroupByOrderBy<Table, Aggregate,         OrderBy> PXSelectGroupByOrderBy<Table, Join, Aggregate,         OrderBy> PXSelectJoin<Table, Join, Where, OrderBy> PXSelectJoin<Table, Join, Where> PXSelectJoin<Table, Join> PXSelectJoinGroupBy<Table, Join, Aggregate> PXSelectJoinGroupBy<Table, Join, Where, Aggregate,         OrderBy> PXSelectJoinGroupBy<Table, Join, Where,         Aggregate> PXSelectJoinOrderBy<Table, Join, OrderBy> PXSelectOrderBy<Table, Join, OrderBy> PXSelectOrderBy<Table, OrderBy> PXSelectReadonly<Table, Where, OrderBy> PXSelectReadonly<Table, Where> PXSelectReadonly<Table>  PXSelectReadonly2<Table, Join, Where, OrderBy> PXSelectReadonly2<Table, Join, Where> PXSelectReadonly2<Table, Join> PXSelectReadonly3<Table, Join, OrderBy> PXSelectReadonly3<Table, OrderBy> ]]></column>
		</row>
		<row PageID="afd13b51-3676-4cfb-bde6-ff563057014d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="a504e3e1-ff47-8525-4565-91654bc82350" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You construct business query language (BQL) statements with filtering conditions by using the <tt>Where</tt> clause in a <tt>PXSelect</tt> class that has the <tt>Where</tt> type parameter. (For more information on selecting the <tt>PXSelect</tt> class, see [HelpRoot_Dev_Platform\AD__how_Construct_Statement|To Select Records By Using Traditional BQL].) One <tt>Where</tt> clause can contain multiple conditions chained to one another by logical operators (<tt>Or</tt>, <tt>And</tt>, and <tt>Not</tt>) and nested <tt>Where</tt> clauses (these nested clauses are equivalent to placing conditions in brackets). {br}

Typically, you construct a BQL statement with a condition to compare one field with another field or a constant, or to check if the field value has been specified (that is, to compare the field value with null). You can also use multiple conditions in the <tt>Where</tt> clause.{br}{TOC}
==To Compare a Field with Another Field==
To compare one field with another field in the <tt>Where</tt> clause, do the following:[anchor|#_32d8e8ae-fc38-4847-9214-a405d3eff9ba]
#Select the comparison class that you need, such as <tt>NotEqual</tt>, <tt>Greater</tt>, or <tt>Less</tt>.
#Specify the compared field in the first type parameter of the <tt>Where</tt> class and the comparison in the second type parameter, as shown in the following sample BQL statement.<source lang="csharp">PXSelect&lt;Product, Where&lt;Product.bookedQty, Greater&lt;Product.availQty&gt;&gt;&gt;</source>
#:((({S:Warn}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table. {{{{SELECT [list of columns] FROM Product WHERE Product.BookedQty &gt; Product.AvailQty
}}}}[anchor|#_d835bea1-7477-4e42-b328-5469a30a81bd] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
[anchor|#_32d3d633-c741-4cc3-8f49-f4a611f164cb]
==To Compare a Field with a Constant==
To compare a field with a constant in the <tt>Where</tt> clause, do the following:[anchor|#_e36db1ae-33be-43c8-8976-2da98b804a54]
#Select the comparison class that you need, such as <tt>NotEqual</tt>, <tt>Greater</tt>, or <tt>Less</tt>.
#Select one of the predefined constants—that is, the BQL class derived from the <tt>Constant&lt;Type&gt;</tt> class (such as Boolean values <tt>True</tt> and <tt>False</tt>, integer <tt>Zero</tt>, datetime <tt>Now</tt>, <tt>Today</tt>, and <tt>MaxDate</tt>, and string <tt>StringEmpty</tt>), or define your own constant as a class derived from the <tt>Constant&lt;Type&gt;</tt> class.
#Specify the compared field in the first type parameter of the <tt>Where</tt> class and the comparison in the second type parameter, as shown in the following sample BQL statement.<source lang="csharp">PXSelect&lt;Product, Where&lt;Product.active, Equal&lt;True&gt;&gt;&gt;</source>
#:((({S:Warn}Acumatica Framework translates this BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table. {{{{SELECT [list of columns] FROM Product WHERE Product.Active = CONVERT(BIT, 1)
}}}}[anchor|#_12f4e0b3-5c9d-4387-8f93-d5ea07f17b74] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))

==To Compare the Field Value with Null==
To check whether a field value is specified, you compare the field value with null in one of the following ways:[anchor|#_fca7671f-99ff-4728-ac47-691400e8db32]
*To check that the field is null, use the <tt>Where&lt;Operand, Comparison&gt;</tt> class, as shown in the following sample BQL statement.<source lang="csharp">PXSelect&lt;Product, Where&lt;Product.bookedQty, IsNull&gt;&gt;</source>
*:((({S:Warn}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product WHERE Product.BookedQty IS NULL
}}}}[anchor|#_a876d735-97ad-4fc8-9944-d6ca0f61ac60] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
*To check that the field is not null, do one of the following:
**Use the <tt>Where&lt;Operator&gt;</tt> class and the logical operator <tt>Not</tt>, as shown in the following sample BQL statement.{{{{PXSelect&lt;Product, Where&lt;Not&lt;Product.bookedQty, IsNull&gt;&gt;&gt;
}}}}
**:((({S:Warn}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product WHERE NOT (Product.BookedQty IS NULL)
}}}}[anchor|#_77541830-bccc-49c0-b7e9-4422f5e31e61] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
**Use the <tt>Where&lt;Operand, Comparison</tt> class, as shown in the following sample BQL statement..<source lang="csharp">PXSelect&lt;Product, Where&lt;Product.bookedQty, IsNotNull&gt;&gt;</source>
**:((({S:Warn}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product WHERE Product.BookedQty IS NOT NULL
}}}}[anchor|#_1ae11f46-cdb1-4b42-860c-e2a94dd6922c] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
((({S:Danger}The predefined constant <tt>Null</tt> cannot be used in the <tt>Where</tt> clause with <tt>Equal</tt> to select records with null fields. The <tt>Null</tt> constant is used in <tt>Switch</tt> conditions.
)))
==To Use Multiple Conditions in One Where Clause==
To specify multiple comparisons in one <tt>Where</tt> clause, do one of the following:[anchor|#_751e1fb5-9f62-43cb-913c-4d079eba992b]
*To specify multiple comparisons that are connected with the same logical operator, use the <tt>Where&lt;Operand, Comparison, NextOperator&gt;</tt> class and specify its type parameters as follows:
**In the first type parameter, specify the first compared field.
**In the second type parameter, specify the first comparison, such as <tt>NotEqual</tt>, <tt>Greater</tt>, or <tt>Less</tt>.
**In the third type parameter, specify the logical operator, such as <tt>And</tt>, <tt>And2</tt>, <tt>Or</tt>, or <tt>Or2</tt>. You can chain any number of comparisons to one another by using binary operators with three type parameters, as shown in the following sample BQL statement. {{{{PXSelect&lt;Product,
    Where&lt;Product.bookedQty, Greater&lt;Product.availQty&gt;,
        Or&lt;Product.availQty, Less&lt;Product.minAvailQty&gt;,
        Or&lt;Product.availQty, IsNull&gt;&gt;&gt;&gt;
}}}}
**:((({S:Warn}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product
WHERE Product.BookedQty &gt; Product.AvailQty
    OR Product.AvailQty &lt; Product.MinAvailQty
    OR Product.AvailQty IsNull
}}}}[anchor|#_eaca31e1-769f-415b-99fd-a012de3ca227] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
*To write more complex conditional expressions with logical operators of different types, use nested <tt>Where</tt> or <tt>Where2</tt> clauses. For more information on writing complex BQL statements, see [HelpRoot_Dev_Platform\AD__how_Translate_SQL_to_BQL|To Compose a BQL Statement from an SQL Statement].

==Related Articles==
*[HelpRoot_Dev_Platform\AD__how_Translate_SQL_to_BQL|To Compose a BQL Statement from an SQL Statement]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=333f0b35-3b1b-d2e6-9461-7f938893da28|Where&lt;UnaryOperator&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=31772e9f-cf66-a704-5aba-afa93c1b1074|Where&lt;Operand,Comparison&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3d98a29a-0adf-2e77-c70a-d22c06856532|Where&lt;Operand,Comparison,NextOperator&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=f1b7fe99-466c-e596-3f2d-2eb523e662bc|Where2&lt;UnaryOperator,NextOperator&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8a7aea7a-6023-f297-449a-330e36a9039c|Equal&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5bf9cdb1-e01d-017d-0ba2-b67b492c5d2f|NotEqual&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a3abf000-b05d-0e75-92a2-71e51cececd6|Greater&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ed6975a0-18f7-a84d-a18b-6e844092560a|GreaterEqual&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=771c8dec-68ee-7405-f74b-faf963ef68ad|Less&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=24321145-ff89-6dc3-1310-0b4134e646c5|LessEqual&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=afa57f50-1f83-2109-2f45-45d2056fcb09|Like&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1ed13254-585f-8cb0-6f76-c1005248aa40|NotLike&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1ee13f48-868f-608a-6f7f-5657e37d061f|NotBetween&lt;Operand1,Operand2&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d707630b-5c0a-cb8f-3c27-cc7a3f881596|Between&lt;Operand1,Operand2&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1f860331-9959-e8af-becc-4246290d2c1b|IsNull Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=f0f19cfd-5cb8-c7e5-6bca-53a08f590b7b|IsNotNull Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=63727f4d-167e-0024-7ffa-cdac1cb87c80|In&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=72a1d03c-75f1-7edd-907f-5b8a529d61de|In2&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b20a5bf2-a586-3765-1ce3-7e46453e23e9|In3&lt;Operand1,Operand2,Operand3,Operand4&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9f502a96-3342-e27e-f2b9-d229434e39d9|NotIn&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=55bb1526-615a-2121-15fd-fdc4a7b28c8f|NotIn2&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6c4b075f-4754-acec-645a-9ca461d49010|Constant&lt;ConstType&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e573cf27-fd87-936e-1fcc-23f844733e28|Null Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b3883e2d-3778-a813-9443-788407786c86|Now Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5a2e8a1a-f597-3622-a017-48b13896fc35|Today Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e5db984c-9d1e-ba79-156d-29357f89f42f|Tomorrow Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c43895a9-b24d-1b79-6292-4da7f5b36d4c|True Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=39df6834-9221-d605-d840-0acd8a7646f0|False Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fb1b0290-c58d-996b-796f-fa67cc1d7e79|Zero Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7342a4e0-e0dc-5bc5-a903-1647a5a856be|StringEmpty Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d255794d-2885-6556-b3fe-48658cdec8ec|MaxDate Class]]]></column>
			<column name="PlainText"><![CDATA[To Filter Records You construct business query language (BQL) statements with filtering conditions by using         the  Where  clause in a  PXSelect  class that has the            Where  type parameter. (For more information on selecting the            PXSelect  class, see  To Select Records By Using Traditional BQL.) One            Where  clause can contain multiple conditions chained to one another by         logical operators ( Or ,  And , and          Not ) and nested  Where  clauses (these nested clauses         are equivalent to placing conditions in brackets).  Typically, you construct a BQL statement with a condition to compare one field with another         field or a constant, or to check if the field value has been specified (that is, to compare         the field value with null). You can also use multiple conditions in the            Where  clause. To Compare a Field with Another Field To compare one field with another field in the  Where  clause, do the           following: Select the comparison class that you need, such as  NotEqual ,                Greater , or  Less . Specify the compared field in the first type parameter of the  Where              class and the comparison in the second type parameter, as shown in the following sample             BQL                 statement. PXSelect<Product, Where<Product.bookedQty, Greater<Product.availQty>>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                  [list of columns]  is the list of columns of the                  Product  table.                  SELECT [list of columns] FROM Product WHERE Product.BookedQty > Product.AvailQty  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Compare a Field with a Constant To compare a field with a constant in the  Where  clause, do the           following: Select the comparison class that you need, such as  NotEqual ,                Greater , or  Less . Select one of the predefined constants—that is, the BQL class derived from the                Constant<Type>  class (such as Boolean values                True  and  False , integer  Zero ,             datetime  Now ,  Today , and                MaxDate , and string  StringEmpty ), or define your             own constant as a class derived from the  Constant<Type>              class. Specify the compared field in the first type parameter of the  Where              class and the comparison in the second type parameter, as shown in the following sample             BQL                 statement. PXSelect<Product, Where<Product.active, Equal<True>>> Acumatica Framework translates this BQL statement to the following SQL query, where  [list of                 columns]  is the list of columns of the  Product  table.                  SELECT [list of columns] FROM Product WHERE Product.Active = CONVERT(BIT, 1)  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Compare the Field Value with Null To check whether a field value is specified, you compare the field value with null in one         of the following ways: To check that the field is null, use the  Where<Operand,               Comparison>  class, as shown in the following sample BQL                 statement. PXSelect<Product, Where<Product.bookedQty, IsNull>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                  [list of columns]  is the list of columns of the                  Product                  table. SELECT [list of columns] FROM Product WHERE Product.BookedQty IS NULL  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To check that the field is not null, do one of the following: Use the  Where<Operator>  class and the logical operator                    Not , as shown in the following sample BQL                     statement. PXSelect<Product, Where<Not<Product.bookedQty, IsNull>>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                      [list of columns]  is the list of columns of the                      Product                      table. SELECT [list of columns] FROM Product WHERE NOT (Product.BookedQty IS NULL)  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. Use the  Where<Operand, Comparison  class, as shown in the                 following sample BQL                     statement.. PXSelect<Product, Where<Product.bookedQty, IsNotNull>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                      [list of columns]  is the list of columns of the                      Product                      table. SELECT [list of columns] FROM Product WHERE Product.BookedQty IS NOT NULL  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. The predefined constant  Null  cannot be used           in the  Where  clause with  Equal  to select records           with null fields. The  Null  constant is used in              Switch  conditions. To Use Multiple Conditions in One Where Clause To specify multiple comparisons in one  Where  clause, do one of the           following: To specify multiple comparisons that are connected with the same logical operator, use             the  Where<Operand, Comparison, NextOperator>  class and specify             its type parameters as follows: In the first type parameter, specify the first compared field. In the second type parameter, specify the first comparison, such as                    NotEqual ,  Greater , or                    Less . In the third type parameter, specify the logical operator, such as                    And ,  And2 ,  Or , or                    Or2 . You can chain any number of comparisons to one another by                 using binary operators with three type parameters, as shown in the following sample                 BQL statement.                      PXSelect<Product,
    Where<Product.bookedQty, Greater<Product.availQty>,
        Or<Product.availQty, Less<Product.minAvailQty>,
        Or<Product.availQty, IsNull>>>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                      [list of columns]  is the list of columns of the                      Product                      table. SELECT [list of columns] FROM Product
WHERE Product.BookedQty > Product.AvailQty
    OR Product.AvailQty < Product.MinAvailQty
    OR Product.AvailQty IsNull  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To write more complex conditional expressions with logical operators of different             types, use nested  Where  or  Where2  clauses. For             more information on writing complex BQL statements, see  To Compose a BQL Statement from an SQL Statement. Where<UnaryOperator> Class Where<Operand,Comparison> Class Where<Operand,Comparison,NextOperator> Class Where2<UnaryOperator,NextOperator> Class Equal<Operand> Class NotEqual<Operand> Class Greater<Operand> Class GreaterEqual<Operand> Class Less<Operand> Class LessEqual<Operand> Class Like<Operand> Class NotLike<Operand> Class NotBetween<Operand1,Operand2> Class Between<Operand1,Operand2> Class IsNull Class IsNotNull Class In<Operand> Class In2<Operand> Class In3<Operand1,Operand2,Operand3,Operand4> Class NotIn<Operand> Class NotIn2<Operand> Class Constant<ConstType> Class Null Class Now Class Today Class Tomorrow Class True Class False Class Zero Class StringEmpty Class MaxDate Class ]]></column>
		</row>
		<row PageID="fadd819c-7751-438c-b5ee-ede99ef2e4fa" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="443dde5b-6100-ce85-04db-a1c9d1384930" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You construct business query language (BQL) statements that include ordering of records by using the <tt>OrderBy</tt> clause in one of the <tt>PXSelect</tt> classes that has the <tt>OrderBy</tt> type parameter. (For more information on selecting the <tt>PXSelect</tt> class, see [HelpRoot_Dev_Platform\AD__how_Construct_Statement|To Select Records By Using Traditional BQL].) {br}

By default, if the BQL statement does not specify ordering, Acumatica Framework adds ordering by the data access class (DAC) key fields (in the order of field declaration) in ascending order to the end of the SQL query. You can order the records by one column or multiple columns, or by a condition. {br}{TOC}
==To Order Records by One Column==
To order records by one column in ascending or descending order, use the <tt>OrderBy</tt> class and the <tt>Asc&lt;Field&gt;</tt> or <tt>Desc&lt;Field&gt;</tt> class, as shown in the following sample BQL statement. {{{{PXSelectOrderBy&lt;Product, OrderBy&lt;Asc&lt;Product.unitPrice&gt;&gt;&gt;
}}}}{br}

In this statement, all <tt>Product</tt> data records are selected and are sorted by the <tt>UnitPrice</tt> field in ascending order.((({S:Warn}Acumatica Framework translates this BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice
}}}}[anchor|#_482e9188-005b-486c-b058-6283027deb84]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
==To Order Records by Multiple Columns==
To order records by multiple columns, use the <tt>OrderBy</tt> class and the <tt>Asc&lt;Field, NextField&gt;</tt> or <tt>Desc&lt;Field, NextField&gt;</tt> class, as shown in the following sample BQL statement. {{{{PXSelectOrderBy&lt;Product,
    OrderBy&lt;Asc&lt;Product.unitPrice, Desc&lt;Product.availQty&gt;&gt;&gt;&gt;
}}}}((({S:Warn} Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice, Product.AvailQty DESC
}}}}[anchor|#_a7cc72cb-7e65-47bc-be7a-551f2cfe4779]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
==To Order Records by a Condition==
To sort data records according to a condition, put the <tt>Switch</tt> clause inside <tt>Asc</tt> or <tt>Desc</tt> in <tt>OrderBy</tt>, as shown in the following sample BQL statement.<source lang="csharp">PXSelectOrderBy&lt;Product,
   OrderBy&lt;Asc&lt;
       Switch&lt;Case&lt;Where&lt;Product.availQty, Greater&lt;Product.bookedQty&gt;&gt;, True&gt;,
              False&gt;&gt;&gt;&gt;</source>{br}

In this statement, the records with <tt>AvailQty</tt> values less or equal to <tt>BookedQty</tt> values are ordered first.((({S:Warn}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table. {{{{SELECT [list of columns] FROM Product
ORDER BY
    ( CASE
         WHEN Product.AvailQty &gt; Product.BookedQty THEN 1
         ELSE 0
      END )
}}}}[anchor|#_df99181d-1fec-4d45-9deb-4eef3ffc079c]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=03cd827b-ce56-05ff-4df3-2443671b1f49|OrderBy&lt;List&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=0e985725-1b3e-c304-37ac-f11ed8696f6a|Asc&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=61408018-bac6-cfb0-896a-2aa9dcc3fd60|Asc&lt;Field,NextField&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d08ab3e2-14f3-ba13-eef1-338af476acdc|Desc&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d442af4b-1155-584a-77cc-3129391c4531|Desc&lt;Field,NextField&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=4c3d5304-4a27-9a58-44ef-532baf5a7410|Switch&lt;Case&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d7ee3bc8-f28c-3824-d24b-3a723ebcc2c9|Switch&lt;Case,Default&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ac0f4d62-2a52-0bf8-1ed2-da25d5c57dde|Case&lt;Where&#95;,Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=15dd8bb7-047f-f2a6-b2ec-d3f3bef79019|Case&lt;Where&#95;,Operand,NextCase&gt; Class]]]></column>
			<column name="PlainText"><![CDATA[To Order Records You construct business query language (BQL) statements that include ordering of                 records by using the  OrderBy  clause in one of the                      PXSelect  classes that has the  OrderBy  type                 parameter. (For more information on selecting the  PXSelect  class,                 see  To Select Records By Using Traditional BQL.)  By default, if the BQL statement does not specify ordering,  Acumatica Framework adds ordering by the data access class (DAC) key fields (in the order of field                 declaration) in ascending order to the end of the SQL query. You can order the                 records by one column or multiple columns, or by a condition.  To Order Records by One Column To order records by one column in ascending or descending order, use the                      OrderBy  class and the  Asc<Field>  or                      Desc<Field>  class, as shown in the following sample BQL                 statement.                  PXSelectOrderBy<Product, OrderBy<Asc<Product.unitPrice>>> In this statement, all  Product  data records are selected and are                 sorted by the  UnitPrice  field in ascending order. Acumatica Framework translates this BQL statement to the following SQL query, where  [list                         of columns]  is the list of columns of the  Product                          table. SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Order Records by Multiple Columns To order records by multiple columns, use the  OrderBy  class and                 the  Asc<Field, NextField>  or  Desc<Field,                     NextField>  class, as shown in the following sample BQL statement.  PXSelectOrderBy<Product,
    OrderBy<Asc<Product.unitPrice, Desc<Product.availQty>>>>  Acumatica Framework translates the previous BQL statement to the following SQL query, where                      [list of columns]  is the list of columns of the                      Product                      table. SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice, Product.AvailQty DESC  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Order Records by a Condition To sort data records according to a condition, put the  Switch                  clause inside  Asc  or  Desc  in                      OrderBy , as shown in the following sample BQL                 statement. PXSelectOrderBy<Product,
   OrderBy<Asc<
       Switch<Case<Where<Product.availQty, Greater<Product.bookedQty>>, True>,
              False>>>> In this statement, the records with  AvailQty  values less or equal                 to  BookedQty  values are ordered first. Acumatica Framework translates the previous BQL statement to the following SQL query, where                          [list of columns]  is the list of columns of the                          Product  table.                          SELECT [list of columns] FROM Product
ORDER BY
    ( CASE
         WHEN Product.AvailQty > Product.BookedQty THEN 1
         ELSE 0
      END )  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. OrderBy<List> Class Asc<Field> Class Asc<Field,NextField> Class Desc<Field> Class Desc<Field,NextField> Class Switch<Case> Class Switch<Case,Default> Class Case<Where_,Operand> Class Case<Where_,Operand,NextCase> Class ]]></column>
		</row>
		<row PageID="13001ef0-91f0-4094-b924-d1114c3e8e41" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="36a02f27-0bed-e920-0e05-98dec0cf2878" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You construct business query language (BQL) statements that join multiple tables by using one of the <tt>Join</tt> clauses in one of the <tt>PXSelect</tt> classes that has the <tt>Join</tt> type parameter. (For more information on selecting the <tt>PXSelect</tt> class, see [HelpRoot_Dev_Platform\AD__how_Construct_Statement|To Select Records By Using Traditional BQL].) In BQL statements, you can join multiple database tables by using the following clauses directly mapped to SQL <tt>JOIN</tt> clauses:[anchor|#ul_i4m_bjm_kk]
*<tt>InnerJoin</tt> returns all records where there is at least one match in both tables.
*<tt>LeftJoin</tt> returns all records from the left table, and the matched records from the right table. Where there are no matched records from the right table, null values are inserted.
*<tt>RightJoin</tt> returns all records from the right table, and the matched records from the left table. Where there are no matched records from the left table, null values are inserted.
*<tt>FullJoin</tt> returns all records when there is a match in one of the tables.
*<tt>CrossJoin</tt> returns the entire Cartesian product of the two tables.
{br}{TOC}
==To Join Two Tables (Inner Join, Left Join, Right Join, or Full Join)==
To join two tables, use one of the <tt>Join</tt> clauses with two type parameters (such as <tt>InnerJoin&lt;Table, On&gt;</tt>) and the <tt>On&lt;Operand, Comparison&gt;</tt> or <tt>On&lt;Operator&gt;</tt> class to specify a conditional expression for joining, as shown in the following sample BQL statement. <source lang="csharp">PXSelectJoin&lt;SalesOrder,
    InnerJoin&lt;OrderDetail,
        On&lt;OrderDetail.orderNbr, Equal&lt;SalesOrder.orderNbr&gt;&gt;&gt;&gt;</source>((({S:Warn} Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the joined tables.{{{{SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr
}}}}[anchor|#_614d0896-6b5e-4ae4-8a0e-3257ba28d8f4]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
==To Cross-Join Two Tables==
To cross-join two tables, use the <tt>CrossJoin&lt;Table&gt;</tt> class, as shown in the following sample BQL statement.<source lang="csharp">PXSelectJoin&lt;Product, CrossJoin&lt;Supplier&gt;&gt;</source>((({S:Warn} Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the joined tables.{{{{SELECT [list of columns] FROM Product CROSS JOIN Supplier
}}}}[anchor|#_43b0d784-79f9-4507-8f94-c599665a0056]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
==To Join Multiple Tables==
To specify multiple join clauses, use the following instructions:[anchor|#_355eb67e-f1d6-4440-8669-835073b515b5]
*Use a <tt>Join</tt> clause with three type parameters (such as <tt>InnerJoin&lt;Table, On, NextJoin&gt;</tt>). Each subsequent join clause is specified as the last type parameter of the previous join clause, as shown in the following sample BQL statement.{{{{PXSelectJoin&lt;SalesOrder,
    InnerJoin&lt;OrderDetail,
        On&lt;OrderDetail.orderNbr, Equal&lt;SalesOrder.orderNbr&gt;&gt;,
    LeftJoin&lt;Employee,
        On&lt;Employee.employeeID, Equal&lt;SalesOrder.employeeID&gt;&gt;&gt;&gt;&gt;
}}}}
*:((({S:Warn}Acumatica Framework translates this BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the joined tables. {{{{SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr
LEFT JOIN Employee
    ON Employee.EmployeeID = SalesOrder.EmployeeID
}}}}[anchor|#_b190744b-be26-4e8e-b01b-a11bc6fcfdc6] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
*Use the <tt>On</tt> conditions to specify conditional expressions for joining, as shown in the following sample BQL statement. In subsequent join clauses, the <tt>On</tt> conditions can refer to fields from any joined table, and can contain any number of conditions chained by logical operators as in filtering conditions.<source lang="csharp">PXSelectJoin&lt;SalesOrder,
    InnerJoin&lt;OrderDetail,
        On&lt;OrderDetail.orderNbr, Equal&lt;SalesOrder.orderNbr&gt;&gt;,
    LeftJoin&lt;Employee,
        On&lt;Employee.employeeID, Equal&lt;SalesOrder.employeeID&gt;&gt;,
    RightJoin&lt;Product,
        On&lt;Product.productID, Equal&lt;OrderDetail.productID&gt;,
        And&lt;Product.unitPrice, Equal&lt;OrderDetail.unitPrice&gt;&gt;&gt;&gt;&gt;&gt;&gt;</source>
*:((({S:Warn}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the joined tables. {{{{SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr
LEFT JOIN Employee
    ON Employee.EmployeeID = SalesOrder.EmployeeID
RIGHT JOIN Product
    ON (Product.ProductID = OrderDetail.ProductID AND
        Product.UnitPrice = OrderDetail.UnitPrice)
}}}}[anchor|#_1297ecc0-74ee-400b-812d-9fd3fd22ecb0] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))

==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=85ce9501-4545-d16d-80a9-6414e82b891c|InnerJoin&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=0a08f5a5-0d6b-e24a-e97c-c4c7e0aaa8c1|InnerJoin&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d0f3d228-023e-e0b1-c246-2a3cde35be01|InnerJoinSingleTable&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1ccf8c22-2f5c-3a7f-3746-a802a9dbc991|InnerJoinSingleTable&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e223a087-0b26-b098-cb6c-626020c475ac|LeftJoin&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e97f269e-0779-352a-9440-e4897db81b06|LeftJoin&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=0e6f7c63-0618-0415-3700-ce516ff5e4fd|LeftJoinSingleTable&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8e610cde-1958-2250-eb04-0c5db04bc5d5|LeftJoinSingleTable&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=329bd6a9-5e12-6be8-2821-6b6fc767185f|RightJoin&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=124ebf93-5063-2c3c-0811-fcef0f89cab9|RightJoin&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3350adc4-f6d5-5327-dc41-49c33b972bb4|RightJoinSingleTable&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9edbd28d-f03c-a2dd-93f2-117eaee4f090|RightJoinSingleTable&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e9ecfe4b-2478-6655-ed63-f33dc5f1277c|FullJoin&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=53fbedb7-b7de-e478-3dbb-218b14e8247b|FullJoin&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c05e45af-63d5-1f0a-5b1a-72918da7a626|FullJoinSingleTable&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a3b57fc6-df8b-0dd1-5518-13bce71dc7cc|FullJoinSingleTable&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a7c74d92-09e1-6e3c-53ca-395da6483028|CrossJoin&lt;Table&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b99003c9-77b5-147e-aa21-b10e7496a7e0|CrossJoin&lt;Table,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=15053230-2aac-89a2-3f8e-89dd0951fbbc|CrossJoinSingleTable&lt;Table&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=08277fd4-ba8f-312d-e49c-8f366845ec11|CrossJoinSingleTable&lt;Table,NextJoin&gt; Class]]]></column>
			<column name="PlainText"><![CDATA[To Query Multiple Tables You construct business query language (BQL) statements that join multiple tables by using         one of the  Join  clauses in one of the  PXSelect  classes         that has the  Join  type parameter. (For more information on selecting the            PXSelect  class, see  To Select Records By Using Traditional BQL.) In BQL         statements, you can join multiple database tables by using the following clauses directly         mapped to SQL  JOIN  clauses: InnerJoin  returns all records where there is at least one match in           both tables. LeftJoin  returns all records from the left table, and the matched           records from the right table. Where there are no matched records from the right table,           null values are inserted. RightJoin  returns all records from the right table, and the matched           records from the left table. Where there are no matched records from the left table, null           values are inserted. FullJoin  returns all records when there is a match in one of the           tables. CrossJoin  returns the entire Cartesian product of the two           tables. To Join Two Tables (Inner Join, Left Join, Right Join, or Full Join) To join two tables, use one of the  Join  clauses with two type parameters         (such as  InnerJoin<Table, On> ) and the  On<Operand,           Comparison>  or  On<Operator>  class to specify a conditional         expression for joining, as shown in the following sample BQL statement.  PXSelectJoin<SalesOrder,
    InnerJoin<OrderDetail,
        On<OrderDetail.orderNbr, Equal<SalesOrder.orderNbr>>>>  Acumatica Framework         translates the previous BQL statement to the following SQL query, where  [list of           columns]  is the list of columns of the joined           tables. SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Cross-Join Two Tables To cross-join two tables, use the  CrossJoin<Table>  class, as shown in         the following sample BQL statement. PXSelectJoin<Product, CrossJoin<Supplier>>  Acumatica Framework         translates the previous BQL statement to the following SQL query, where  [list of           columns]  is the list of columns of the joined           tables. SELECT [list of columns] FROM Product CROSS JOIN Supplier  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Join Multiple Tables To specify multiple join clauses, use the following instructions: Use a  Join  clause with three type parameters (such as                  InnerJoin<Table, On, NextJoin> ). Each subsequent join clause               is specified as the last type parameter of the previous join clause, as shown in the               following sample BQL statement. PXSelectJoin<SalesOrder,
    InnerJoin<OrderDetail,
        On<OrderDetail.orderNbr, Equal<SalesOrder.orderNbr>>,
    LeftJoin<Employee,
        On<Employee.employeeID, Equal<SalesOrder.employeeID>>>>> Acumatica Framework translates this BQL statement to the following SQL query, where  [list of                   columns]  is the list of columns of the joined tables.                    SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr
LEFT JOIN Employee
    ON Employee.EmployeeID = SalesOrder.EmployeeID  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. Use the  On  conditions to specify conditional expressions for               joining, as shown in the following sample BQL statement. In subsequent join clauses,               the  On  conditions can refer to fields from any joined table, and               can contain any number of conditions chained by logical operators as in filtering               conditions. PXSelectJoin<SalesOrder,
    InnerJoin<OrderDetail,
        On<OrderDetail.orderNbr, Equal<SalesOrder.orderNbr>>,
    LeftJoin<Employee,
        On<Employee.employeeID, Equal<SalesOrder.employeeID>>,
    RightJoin<Product,
        On<Product.productID, Equal<OrderDetail.productID>,
        And<Product.unitPrice, Equal<OrderDetail.unitPrice>>>>>>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                  [list of columns]  is the list of columns of the joined tables.                  SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr
LEFT JOIN Employee
    ON Employee.EmployeeID = SalesOrder.EmployeeID
RIGHT JOIN Product
    ON (Product.ProductID = OrderDetail.ProductID AND
        Product.UnitPrice = OrderDetail.UnitPrice)  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. InnerJoin<Table,On> Class InnerJoin<Table,On,NextJoin> Class InnerJoinSingleTable<Table,On> Class InnerJoinSingleTable<Table,On,NextJoin> Class LeftJoin<Table,On> Class LeftJoin<Table,On,NextJoin> Class LeftJoinSingleTable<Table,On> Class LeftJoinSingleTable<Table,On,NextJoin> Class RightJoin<Table,On> Class RightJoin<Table,On,NextJoin> Class RightJoinSingleTable<Table,On> Class RightJoinSingleTable<Table,On,NextJoin> Class FullJoin<Table,On> Class FullJoin<Table,On,NextJoin> Class FullJoinSingleTable<Table,On> Class FullJoinSingleTable<Table,On,NextJoin> Class CrossJoin<Table> Class CrossJoin<Table,NextJoin> Class CrossJoinSingleTable<Table> Class CrossJoinSingleTable<Table,NextJoin> Class ]]></column>
		</row>
		<row PageID="44827160-45dd-4cfe-82b9-6d4230e4f620" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="9c92ffcc-9189-a8e8-79bc-d8acd06e9f5a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You construct business query language (BQL) statements that group and aggregate records by using the <tt>Aggregate</tt> clause in one of the <tt>PXSelect</tt> classes that has the <tt>Aggregate</tt> type parameter. (For more information on selecting the <tt>PXSelect</tt> class, see [HelpRoot_Dev_Platform\AD__how_Construct_Statement|To Select Records By Using Traditional BQL].) 
==To Group and Aggregate Records==
To group and aggregate records, follow the instructions below:[anchor|#_23e97a66-804a-482f-85be-8d990e41a515]
#Specify all grouping conditions (the <tt>GroupBy</tt> clause) and aggregation functions (such as <tt>Min</tt>, <tt>Max</tt>, <tt>Sum</tt>, <tt>Avg</tt>, and <tt>Count</tt>) in the <tt>Aggregate</tt> clause, as shown in the following sample BQL statement. Fields specified in <tt>GroupBy</tt> clauses are selected as is; an aggregation function is applied to all other fields. The default <tt>Max</tt> function is used if no function is specified for a field. If a data field has the <tt>PXDBScalar</tt> attribute, NULL is inserted for that field.<source lang="csharp">PXSelectGroupBy&lt;Product,
    Aggregate&lt;GroupBy&lt;Product.categoryCD&gt;&gt;&gt;</source>
#:((({S:Warn}Acumatica Framework translates the previous BQL statement to the following SQL query.{{{{SELECT Product.CategoryCD,
       [MAX(Field) for other fields]
FROM Product
GROUP BY Product.CategoryCD
}}}}
)))
#If necessary, insert another <tt>GroupBy</tt> clause or aggregation function as the second type parameter of the previous <tt>GroupBy</tt> clause or aggregation function, as shown in the following sample BQL statement.<source lang="csharp">PXSelectGroupBy&lt;Product,
    Aggregate&lt;GroupBy&lt;Product.categoryCD,
              Sum&lt;Product.availQty,
              Sum&lt;Product.bookedQty,
              GroupBy&lt;Product.stockUnit,
              Min&lt;Product.unitPrice&gt;&gt;&gt;&gt;&gt;&gt;&gt;</source>
#:((({S:Warn}Acumatica Framework translates the previous BQL statement to the following SQL query.{{{{SELECT Product.CategoryCD, Product.StockUnit,
       SUM(Product.AvailQty), SUM(Product.AvailQty), MIN(Product.UnitPrice),
       [MAX(Field) for other fields]
FROM Product
GROUP BY Product.CategoryCD, Product.StockUnit
}}}}
)))

==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a68f8d2b-9917-d62d-bc82-037affc0327b|Aggregate&lt;Function&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=cb1df45b-f23c-f767-749e-88f0fa4c79f2|GroupBy&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=dfabceb1-c8d1-0f8a-02d6-2fd26e5e928f|GroupBy&lt;Field,NextAggregate&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7edc9b63-2102-74f6-fd5a-6d58146cdc16|Min&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=4a691f0e-ce9d-427a-015a-d3eb84fb40fc|Min&lt;Field,NextAggregate&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8ebdb12a-8083-df48-cb90-1f088037fda9|Max&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9922cbdd-9f68-d682-59e1-79f4b29107d5|Max&lt;Field,NextAggregate&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8d6b4bc4-d6b6-d5c6-cc12-25718d84ef16|Sum&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fbe63dbc-715a-d504-4ca3-47e47b849e83|Sum&lt;Field,NextAggregate&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1e7eb237-880e-1582-77ae-bf9c6f9ae5c9|Avg&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d6838e35-7cc3-19af-3b57-4266f15f2737|Avg&lt;Field,NextAggregate&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7cd8b299-8184-6726-af1d-0192167dd87a|Count Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8ce5be95-5414-d507-2fb9-64856cbe10ac|Count&lt;Field&gt; Class]]]></column>
			<column name="PlainText"><![CDATA[To Group and Aggregate Records You construct business query language (BQL) statements that group and aggregate                 records by using the  Aggregate  clause in one of the                      PXSelect  classes that has the  Aggregate                  type parameter. (For more information on selecting the  PXSelect                  class, see  To Select Records By Using Traditional BQL.)  To Group and Aggregate Records To group and aggregate records, follow the instructions below: Specify all grouping conditions (the  GroupBy  clause) and                         aggregation functions (such as  Min ,                              Max ,  Sum ,  Avg ,                         and  Count ) in the  Aggregate  clause, as                         shown in the following sample BQL statement. Fields specified in                              GroupBy  clauses are selected as is; an aggregation                         function is applied to all other fields. The default  Max                          function is used if no function is specified for a field. If a data field                         has the  PXDBScalar  attribute, NULL is inserted for that                                 field. PXSelectGroupBy<Product,
    Aggregate<GroupBy<Product.categoryCD>>> Acumatica Framework                             translates the previous BQL statement to the following SQL                             query. SELECT Product.CategoryCD,
       [MAX(Field) for other fields]
FROM Product
GROUP BY Product.CategoryCD If necessary, insert another  GroupBy  clause or                         aggregation function as the second type parameter of the previous                              GroupBy  clause or aggregation function, as shown in                         the following sample BQL                                 statement. PXSelectGroupBy<Product,
    Aggregate<GroupBy<Product.categoryCD,
              Sum<Product.availQty,
              Sum<Product.bookedQty,
              GroupBy<Product.stockUnit,
              Min<Product.unitPrice>>>>>>> Acumatica Framework                             translates the previous BQL statement to the following SQL                             query. SELECT Product.CategoryCD, Product.StockUnit,
       SUM(Product.AvailQty), SUM(Product.AvailQty), MIN(Product.UnitPrice),
       [MAX(Field) for other fields]
FROM Product
GROUP BY Product.CategoryCD, Product.StockUnit Aggregate<Function> Class GroupBy<Field> Class GroupBy<Field,NextAggregate> Class Min<Field> Class Min<Field,NextAggregate> Class Max<Field> Class Max<Field,NextAggregate> Class Sum<Field> Class Sum<Field,NextAggregate> Class Avg<Field> Class Avg<Field,NextAggregate> Class Count Class Count<Field> Class ]]></column>
		</row>
		<row PageID="d54a07cc-67d0-4ccb-8cf2-5be7210fb8ec" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="4784c0c7-7ed8-9909-fb1f-5f879466a0ef" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You may need to use BQL parameters if you need to relate data views to each other, to pass field values to the SQL query, to pass the external presentations of the values to the SQL query, or to pass values from UI controls to the SQL query. For more information on the BQL parameters, see [HelpRoot_Dev_Platform\AD__con_Parameters|Parameters in Traditional BQL Statements].{br}{TOC}[anchor|#_def33638-9099-460b-b2d8-b93f75871625]
==To Relate Data Views to One Another==
To relate data views to one another, use the <tt>Current</tt> parameter, as shown in the following sample code.{{{{// The view declarations in a graph
PXSelect&lt;Document&gt; Documents;
PXSelect&lt;DocTransaction,
    Where&lt;DocTransaction.docNbr, Equal&lt;Current&lt;Document.docNbr&gt;&gt;,
        And&lt;DocTransaction.docType, Equal&lt;Current&lt;Document.docType&gt;&gt;&gt;&gt;&gt;
            DocTransactions;
}}}}{br}

In this code, there is a many-to-one relationship between the <tt>DocTransaction</tt> and <tt>Document</tt> data access classes (DACs), and this relationship is implemented through the <tt>DocNbr</tt> and <tt>DocType</tt> key fields. The views in the code connect the <tt>Document</tt> and <tt>DocTransaction</tt> records.((({S:Warn}Acumatica Framework translates the BQL query of the second view in the sample BQL code to the following SQL statement. In this SQL query, {{[parameter1]}} is the <tt>DocNbr</tt> value and {{[parameter2]}} is the <tt>DocType</tt> value taken from the <tt>Current</tt> property of the <tt>DocTransaction</tt> cache; {{[list of columns]}} is the list of columns of the {{DocTransaction}} table.{{{{SET @P0 = [parameter1] 
SET @P1 = [parameter2]

SELECT * FROM DocTransaction
WHERE DocTransaction.DocNbr = @P0
    AND DocTransaction.DocType = @P1
}}}}[anchor|#_4f03869b-c3d9-47a0-b34f-b68954830d44]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))[anchor|#_6e19063a-c756-4b7d-88a0-7d0100a187d9]
==To Pass a Field Value to the SQL Query==
To pass a specific value to the SQL query, use the <tt>Required</tt> parameter in the BQL statement and specify the needed value as the <tt>Select()</tt> method argument. The value passed to <tt>Select()</tt> must be of the same type as the type of the specified field.{br}

((({S:Warn}The <tt>Required</tt> parameter should be used only in the BQL statements that are directly executed in the application code. The data views that are queried from the UI will not work if they contain <tt>Required</tt> parameters.
))){br}

The code below shows the execution of a BQL statement with the <tt>Required</tt> parameter.<source lang="csharp">// Suppose an event handler related to the Product DAC
// is being executed
Product product = (Product)e.Row;

// Select the Category record with the specified CategoryCD
Category category =
    PXSelect&lt;Category,
        Where&lt;Category.categoryCD, Equal&lt;Required&lt;Category.categoryCD&gt;&gt;&gt;&gt;
        .Select(this, product.CategoryCD);</source>((({S:Warn} Acumatica Framework translates the previous BQL query to the following SQL statement. In this SQL query, {{[parameter]}} is the value of the {{product.CategoryCD}} variable at the moment the <tt>Select()</tt> method is invoked; {{[list of columns]}} is the list of columns of the {{Category}} table.{{{{SET @P0 = [parameter] 

SELECT * FROM Category
WHERE Category.CategoryCD = @P0
}}}}[anchor|#_fa447553-cd0c-4c16-a3e8-5228e34559f2]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))[anchor|#_cc3c4e58-b049-4351-b3c6-ebd9e62a350d]
==To Pass Multiple Field Values to the SQL Query==
To pass multiple values to the SQL query, use multiple <tt>Required</tt> parameters in the BQL statement and specify the needed values as the <tt>Select()</tt> method arguments in the order in which the parameters are specified in the BQL statement. The number of <tt>Required</tt> parameters must match the number of parameters passed to the <tt>Select()</tt> function. {br}

((({S:Warn}The <tt>Required</tt> parameters should be used in only the BQL statements that are executed in the application code. 
))){br}

The following code shows an example of a BQL statement with two <tt>Required</tt> parameters.<source lang="csharp">// Suppose an event handler related to the DocTransaction DAC
// is being executed
DocTransaction line = (DocTransaction)e.Row;
...
Document doc =
    PXSelect&lt;Document,
        Where&lt;Document.docNbr, Equal&lt;Required&lt;DocTransaction.docNbr&gt;,
            And&lt;Document.docType, Equal&lt;Required&lt;DocTransaction.docType&gt;&gt;&gt;&gt;&gt;
    .Select(this, line.DocNbr, line.DocType);</source>((({S:Warn} Acumatica Framework translates the previous BQL query to the following SQL statement, where {{[list of columns]}} is the list of columns of the {{Document}} table. {{{{SET @P0 = [line.DocNbr value]
SET @P1 = [line.DocType value]

SELECT * FROM Document
WHERE Document.DocNbr = @P0
    AND Document.DocType = @P1
}}}}[anchor|#_f0154f16-6276-49ee-9a63-9f4dce282625]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))[anchor|#_4473b629-e9a7-4f41-9041-c0442303d2be]
==To Provide External Presentation of the Field Value to the SQL Query==
To substitute the value in the SQL query, do the following:[anchor|#_b37d7823-a6d2-4838-8d82-0ef40e364a36]
#Add the <tt>PXSelector</tt> attribute with a substitute key to a DAC field, as shown in the following example.<source lang="csharp">[PXSelector(typeof(Search&lt;Product.productID&gt;),
            new Type [] {
                    typeof(Product.productCD),
                    typeof(Product.productName)
            },
            SubstituteKey = typeof(Product.productCD))]
public virtual int? ProductID { get; set; }</source>
#:In this example, <tt>PXSelector</tt> replaces the <tt>ProductID</tt> field in the user interface with the human-readable <tt>ProductCD</tt> field. In the UI control for this field, the user enters a <tt>ProductCD</tt> value. The <tt>PXSelector</tt> attribute implements the <tt>FieldUpdating</tt> event handler, which replaces the <tt>ProductCD</tt> value with the corresponding <tt>ProductID</tt> value. 
#Use the <tt>Optional</tt> parameter to select records by the external presentation of the field value, as shown in the following code for <tt>OrderDetail</tt> records.<source lang="csharp">// Product data record obtained
Product p = ...
// Selecting OrderDetail records: ProductCD value is passed
// to the Select() method.
PXSelect&lt;OrderDetail,
    Where&lt;OrderDetail.ProductID, Equal&lt;Optional&lt;OrderDetail.ProductID&gt;&gt;&gt;&gt;
        .Select(this, p.ProductCD);</source>
#In the <tt>Select()</tt> method, provide values for all <tt>Optional</tt>, <tt>Required</tt>, and <tt>Argument</tt> parameters up to the last <tt>Required</tt> or <tt>Argument</tt> parameter in the BQL statement, as shown in the following sample code. <source lang="csharp">// Related OrderDetail and Product records obtained
OrderDetail od = ...
Product p = ...

// At least three values (in addition to graph reference) must
// be passed to the Select() method below.
// The second Optional parameter here will be replaced with the
// default UnitPrice value.
PXResultset&lt;OrderDetail&gt; details =
   PXSelect&lt;OrderDetail,
      Where&lt;OrderDetail.productID, Equal&lt;Optional&lt;OrderDetail.productID&gt;&gt;,
          And&lt;OrderDetail.extPrice, Less&lt;Required&lt;OrderDetail.extPrice&gt;&gt;,
          And&lt;OrderDetail.unitPrice, Greater&lt;Required&lt;OrderDetail.unitPrice&gt;&gt;,
          And&lt;OrderDetail.taxRate, Equal&lt;Optional&lt;OrderDetail.taxRate&gt;&gt;&gt;&gt;&gt;&gt;&gt;
      .Select(this, p.ProductCD, od.ExtPrice, od.UnitPrice);</source>
#:((({S:Warn}Acumatica Framework translates the BQL query in the code to the following SQL statement, where {{[list of columns]}} is the list of columns of the {{OrderDetail}} table. {{{{SET @P0 = [line.ProductID value or default]
SET @P1 = [line.ExtPrice value]
SET @P2 = [line.UnitPrice value]
SET @P3 = [Default TaxRate value]

SELECT [list of columns] FROM OrderDetail
WHERE OrderDetail.ProductID = @P0
    AND OrderDetail.ExtPrice &lt; @P1
    AND OrderDetail.UnitPrice &gt; @P2
    AND OrderDetail.TaxRate = @P3
}}}}[anchor|#_1c2eb8d6-619f-4498-b623-2e35d36d0d8c] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
[anchor|#_1f3bef64-92a7-469f-9fd2-89f0910565fe]
==To Pass a Value from a UI Control to a Data View==
To pass a value from a UI control to a data view, do the following:[anchor|#_bd92083d-f390-47ff-89aa-27215c2c0dfd]
#Define the <tt>PXSelect</tt> data view with the <tt>Argument</tt> parameter whose type parameter specifies the data type of the expected value, as shown in the following sample BQL query.<source lang="csharp">PXSelect&lt;TreeViewItem,
    Where&lt;TreeViewItem.parentID, Equal&lt;Argument&lt;int?&gt;&gt;&gt;,
    OrderBy&lt;Asc&lt;TreeViewItem.parentID&gt;&gt;&gt; GridDataSource;</source>
#:((({S:Warn}Acumatica Framework translates the previous BQL query to the following SQL statement. In this SQL query, {{[parameter]}} will contain the value received from the UI control and passed to the <tt>Select()</tt> method; {{[list of columns]}} is the list of columns of the {{TreeViewItem}} table.{{{{SET @P0 = [parameter]

SELECT [list of columns] FROM TreeViewItem
WHERE TreeViewItem.ParentID = @P0
ORDER BY TreeViewItem.ParentID
}}}}[anchor|#_bffb6291-5099-4ea0-b150-ce89ea100ae6] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
#Define the data view delegate with the parameters through which you can access the values passed from the UI. (You can find more information on how to use data view delegates in [HelpRoot_Dev_Platform\AD__how_Execute_BQL_Statement|To Execute BQL Statements].)
#:((({S:Warn}When a BQL statement with the <tt>Argument</tt> parameter is executed in code, the value must be specified in the parameters of the <tt>Select()</tt> method.
)))

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Parameters|Parameters in Traditional BQL Statements]
*[HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c19bd9db-77fe-b066-d303-5264bf213410|Current&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1dac11b6-9a2a-7344-ec63-3c934063e70f|Current2&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ea358533-f102-21d0-d4b5-cc4795a3cbc0|Required&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=97688c34-9fef-b1b3-b3c9-b9303568ffc5|Optional&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5d5ef7c0-cf1c-4ff6-b691-ccb44c7714d9|Optional2&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=21827d74-245c-e10a-0a73-9e9cbcdd1260|Argument&lt;ArgumentType&gt; Class]]]></column>
			<column name="PlainText"><![CDATA[To Use Parameters in Traditional BQL You may need to use BQL parameters if you need to relate data views to each other, to pass         field values to the SQL query, to pass the external presentations of the values to the SQL         query, or to pass values from UI controls to the SQL query. For more information on the BQL         parameters, see  Parameters in Traditional BQL Statements. To Relate Data Views to One Another To relate data views to one another, use the  Current  parameter, as shown         in the following sample         code. // The view declarations in a graph
PXSelect<Document> Documents;
PXSelect<DocTransaction,
    Where<DocTransaction.docNbr, Equal<Current<Document.docNbr>>,
        And<DocTransaction.docType, Equal<Current<Document.docType>>>>>
            DocTransactions; In this code, there is a many-to-one relationship between the            DocTransaction  and  Document  data access classes         (DACs), and this relationship is implemented through the  DocNbr  and            DocType  key fields. The views in the code connect the            Document  and  DocTransaction  records. Acumatica Framework translates the BQL query of the second view in the sample BQL code to the following SQL           statement. In this SQL query,  [parameter1]  is the              DocNbr  value and  [parameter2]  is the              DocType  value taken from the  Current  property of           the  DocTransaction  cache;  [list of columns]  is the           list of columns of the  DocTransaction              table. SET @P0 = [parameter1] 
SET @P1 = [parameter2]

SELECT * FROM DocTransaction
WHERE DocTransaction.DocNbr = @P0
    AND DocTransaction.DocType = @P1  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Pass a Field Value to the SQL Query To pass a specific value to the SQL query, use the  Required  parameter in         the BQL statement and specify the needed value as the  Select()  method         argument. The value passed to  Select()  must be of the same type as the         type of the specified field. The  Required  parameter should be used only in the BQL statements           that are directly executed in the application code. The data views that are queried from           the UI will not work if they contain  Required  parameters. The code below shows the execution of a BQL statement with the  Required          parameter. // Suppose an event handler related to the Product DAC
// is being executed
Product product = (Product)e.Row;

// Select the Category record with the specified CategoryCD
Category category =
    PXSelect<Category,
        Where<Category.categoryCD, Equal<Required<Category.categoryCD>>>>
        .Select(this, product.CategoryCD);  Acumatica Framework         translates the previous BQL query to the following SQL statement. In this SQL query,            [parameter]  is the value of the  product.CategoryCD          variable at the moment the  Select()  method is invoked;  [list of           columns]  is the list of columns of the  Category            table. SET @P0 = [parameter] 

SELECT * FROM Category
WHERE Category.CategoryCD = @P0  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Pass Multiple Field Values to the SQL Query To pass multiple values to the SQL query, use multiple  Required          parameters in the BQL statement and specify the needed values as the            Select()  method arguments in the order in which the parameters are         specified in the BQL statement. The number of  Required  parameters must         match the number of parameters passed to the  Select()  function.  The  Required  parameters should be used in only the BQL statements           that are executed in the application code.  The following code shows an example of a BQL statement with two  Required          parameters. // Suppose an event handler related to the DocTransaction DAC
// is being executed
DocTransaction line = (DocTransaction)e.Row;
...
Document doc =
    PXSelect<Document,
        Where<Document.docNbr, Equal<Required<DocTransaction.docNbr>,
            And<Document.docType, Equal<Required<DocTransaction.docType>>>>>
    .Select(this, line.DocNbr, line.DocType);  Acumatica Framework         translates the previous BQL query to the following SQL statement, where  [list of           columns]  is the list of columns of the  Document  table.            SET @P0 = [line.DocNbr value]
SET @P1 = [line.DocType value]

SELECT * FROM Document
WHERE Document.DocNbr = @P0
    AND Document.DocType = @P1  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Provide External Presentation of the Field Value to the SQL Query To substitute the value in the SQL query, do the following: Add the  PXSelector  attribute with a substitute key to a DAC field,             as shown in the following               example. [PXSelector(typeof(Search<Product.productID>),
            new Type [] {
                    typeof(Product.productCD),
                    typeof(Product.productName)
            },
            SubstituteKey = typeof(Product.productCD))]
public virtual int? ProductID { get; set; } In               this example,  PXSelector  replaces the  ProductID                field in the user interface with the human-readable  ProductCD                field. In the UI control for this field, the user enters a                  ProductCD  value. The  PXSelector  attribute               implements the  FieldUpdating  event handler, which replaces the                  ProductCD  value with the corresponding                  ProductID  value.  Use the  Optional  parameter to select records by the external             presentation of the field value, as shown in the following code for                OrderDetail              records. // Product data record obtained
Product p = ...
// Selecting OrderDetail records: ProductCD value is passed
// to the Select() method.
PXSelect<OrderDetail,
    Where<OrderDetail.ProductID, Equal<Optional<OrderDetail.ProductID>>>>
        .Select(this, p.ProductCD); In the  Select()  method, provide values for all                Optional ,  Required , and                Argument  parameters up to the last  Required  or                Argument  parameter in the BQL statement, as shown in the following             sample code.                  // Related OrderDetail and Product records obtained
OrderDetail od = ...
Product p = ...

// At least three values (in addition to graph reference) must
// be passed to the Select() method below.
// The second Optional parameter here will be replaced with the
// default UnitPrice value.
PXResultset<OrderDetail> details =
   PXSelect<OrderDetail,
      Where<OrderDetail.productID, Equal<Optional<OrderDetail.productID>>,
          And<OrderDetail.extPrice, Less<Required<OrderDetail.extPrice>>,
          And<OrderDetail.unitPrice, Greater<Required<OrderDetail.unitPrice>>,
          And<OrderDetail.taxRate, Equal<Optional<OrderDetail.taxRate>>>>>>>
      .Select(this, p.ProductCD, od.ExtPrice, od.UnitPrice); Acumatica Framework translates the BQL query in the code to the following SQL statement, where                  [list of columns]  is the list of columns of the                  OrderDetail  table.                  SET @P0 = [line.ProductID value or default]
SET @P1 = [line.ExtPrice value]
SET @P2 = [line.UnitPrice value]
SET @P3 = [Default TaxRate value]

SELECT [list of columns] FROM OrderDetail
WHERE OrderDetail.ProductID = @P0
    AND OrderDetail.ExtPrice < @P1
    AND OrderDetail.UnitPrice > @P2
    AND OrderDetail.TaxRate = @P3  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Pass a Value from a UI Control to a Data View To pass a value from a UI control to a data view, do the following: Define the  PXSelect  data view with the  Argument              parameter whose type parameter specifies the data type of the expected value, as shown             in the following sample BQL                 query. PXSelect<TreeViewItem,
    Where<TreeViewItem.parentID, Equal<Argument<int?>>>,
    OrderBy<Asc<TreeViewItem.parentID>>> GridDataSource; Acumatica Framework translates the previous BQL query to the following SQL statement. In this SQL               query,  [parameter]  will contain the value received from the UI               control and passed to the  Select()  method;  [list of                 columns]  is the list of columns of the  TreeViewItem                  table. SET @P0 = [parameter]

SELECT [list of columns] FROM TreeViewItem
WHERE TreeViewItem.ParentID = @P0
ORDER BY TreeViewItem.ParentID  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. Define the data view delegate with the parameters through which you can access the             values passed from the UI. (You can find more information on how to use data view             delegates in  To Execute BQL Statements.) When a BQL statement with the  Argument  parameter is               executed in code, the value must be specified in the parameters of the                  Select()  method. Current<Field> Class Current2<Field> Class Required<Field> Class Optional<Field> Class Optional2<Field> Class Argument<ArgumentType> Class ]]></column>
		</row>
		<row PageID="82cf157e-97f8-42d6-85f9-3774c7ff13ef" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="dd82a34d-7f3a-e8a8-08a0-cf8958b5c467" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Arithmetic operations—such as {{Add<Operand1, Operand2>}}, {{Sub<Operand1, Operand2>}}, {{Mult<Operand1, Operand2>}}, {{Div<Operand1, Operand2>}}, {{Minus<Operand>}}, and {{Power<Operand1, Operand2>}}—are used primarily in attributes to calculate the value of a field from other fields. Arithmetic operations can also be used as operands in <tt>Where</tt> and <tt>OrderBy</tt> clauses in business query language (BQL) statements.{br}{TOC}
==To Use Arithmetic Operations in Attributes==
To calculate an expression in an attribute, do the following:[anchor|#_8e252edc-0358-43a3-8771-5db29bae7e35]
#Compose the expression by using arithmetic operations. For example, you can calculate product reorder discrepancy by using the following BQL expression, where the <tt>decimal&#95;0</tt> constant represents the 0 decimal value. <tt>IsNull</tt> returns the first argument if it is not null or the second argument otherwise.<source lang="csharp">Minus&lt;
    Sub&lt;Sub&lt;IsNull&lt;Product.availQty, decimal_0&gt;, 
            IsNull&lt;Product.bookedQty, decimal_0&gt;&gt;, 
        Product.minAvailQty&gt;&gt;</source>
#:((({S:Warn}Acumatica Framework translates the previous BQL statement to the following SQL query.{{{{ -((ISNULL(Product.AvailQty, .0) - ISNULL(Product.BookedQty, .0))
    - Product.MinAvailQty)
}}}}
)))
#Use the calculated expression in an attribute (such as <tt>PXDBCalced</tt>) to define a calculated field that is not bound to a database column, as shown in the following sample code.<source lang="csharp">// Data field definition in a DAC
[PXDecimal(2)]
[PXDBCalced(typeof(Minus&lt;
                       Sub&lt;Sub&lt;IsNull&lt;Product.availQty, decimal_0&gt;, 
                               IsNull&lt;Product.bookedQty, decimal_0&gt;&gt;, 
                           Product.minAvailQty&gt;&gt;),
            typeof(Decimal))]
public virtual decimal? Discrepancy { get; set; }</source>

==To Use Arithmetic Operations in BQL Statements==
To use arithmetic operations in a conditional expression in a BQL statement, do the following:[anchor|#_d5522ba7-0761-4f06-bb90-bccbebbe263a]
#Compose the expression by using arithmetic operations. For example, you can calculate product reorder discrepancy by using the following BQL expression, where the <tt>decimal&#95;0</tt> constant represents the 0 decimal value. <tt>IsNull</tt> returns the first argument if it is not null or the second argument otherwise.<source lang="csharp">Minus&lt;
    Sub&lt;Sub&lt;IsNull&lt;Product.availQty, decimal_0&gt;, 
            IsNull&lt;Product.bookedQty, decimal_0&gt;&gt;, 
        Product.minAvailQty&gt;&gt;</source>
#:((({S:Warn}Acumatica Framework translates the previous BQL statement to the following SQL query.{{{{ -((ISNULL(Product.AvailQty, .0) - ISNULL(Product.BookedQty, .0))
    - Product.MinAvailQty)
}}}}
)))
#Use the calculated expression in a BQL statement, as shown in the following example.<source lang="csharp">PXSelect&lt;Product,
    Where&lt;Minus&lt;
              Sub&lt;Sub&lt;IsNull&lt;Product.availQty, decimal_0&gt;, 
                      IsNull&lt;Product.bookedQty, decimal_0&gt;&gt;, 
                  Product.minAvailQty&gt;&gt;,
          NotEqual&lt;decimal_0&gt;&gt;&gt;</source>
#:((({S:Warn}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table. {{{{SELECT [list of columns] FROM Product
WHERE -((ISNULL(Product.AvailQty, .0) - ISNULL(Product.BookedQty, .0))
        - Product.MinAvailQty) &lt;&gt; .0
}}}}[anchor|#_6a5863a9-3803-435d-b629-9fd36a98c631] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))

==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=48ad54c9-08d9-e528-69e2-c86697438ce4|Add&lt;Operand1,Operand2&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8b9c612e-4384-79a6-b803-efddb83dc839|Sub&lt;Operand1,Operand2&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=157dfccb-ff63-b322-954b-35bc4f71016c|Mult&lt;Operand1,Operand2&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=272c6239-3e42-328f-29a0-2d56a3db41b0|Div&lt;Operand1,Operand2&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9c92f90d-bbdb-b127-38dc-597ab757c0d7|Minus&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=794038bd-3637-888f-e794-23c7572fdc7d|Power&lt;Operand1,Operand2&gt; Class]]]></column>
			<column name="PlainText"><![CDATA[To Use Arithmetic Operations Arithmetic operations—such as  Add<Operand1, Operand2> ,            Sub<Operand1, Operand2> ,  Mult<Operand1, Operand2> ,            Div<Operand1, Operand2> ,  Minus<Operand> , and            Power<Operand1, Operand2> —are used primarily in attributes to         calculate the value of a field from other fields. Arithmetic operations can also be used as         operands in  Where  and  OrderBy  clauses in business         query language (BQL) statements. To Use Arithmetic Operations in Attributes To calculate an expression in an attribute, do the following: Compose the expression by using arithmetic operations. For example, you can calculate             product reorder discrepancy by using the following BQL expression, where the                decimal_0  constant represents the 0 decimal value.                IsNull  returns the first argument if it is not null or the second             argument                 otherwise. Minus<
    Sub<Sub<IsNull<Product.availQty, decimal_0>, 
            IsNull<Product.bookedQty, decimal_0>>, 
        Product.minAvailQty>> Acumatica Framework translates the previous BQL statement to the following SQL               query.  -((ISNULL(Product.AvailQty, .0) - ISNULL(Product.BookedQty, .0))
    - Product.MinAvailQty) Use the calculated expression in an attribute (such as  PXDBCalced )             to define a calculated field that is not bound to a database column, as shown in the             following sample             code. // Data field definition in a DAC
[PXDecimal(2)]
[PXDBCalced(typeof(Minus<
                       Sub<Sub<IsNull<Product.availQty, decimal_0>, 
                               IsNull<Product.bookedQty, decimal_0>>, 
                           Product.minAvailQty>>),
            typeof(Decimal))]
public virtual decimal? Discrepancy { get; set; } To Use Arithmetic Operations in BQL Statements To use arithmetic operations in a conditional expression in a BQL statement, do the           following: Compose the expression by using arithmetic operations. For example, you can calculate             product reorder discrepancy by using the following BQL expression, where the                decimal_0  constant represents the 0 decimal value.                IsNull  returns the first argument if it is not null or the second             argument                 otherwise. Minus<
    Sub<Sub<IsNull<Product.availQty, decimal_0>, 
            IsNull<Product.bookedQty, decimal_0>>, 
        Product.minAvailQty>> Acumatica Framework translates the previous BQL statement to the following SQL               query.  -((ISNULL(Product.AvailQty, .0) - ISNULL(Product.BookedQty, .0))
    - Product.MinAvailQty) Use the calculated expression in a BQL statement, as shown in the following                 example. PXSelect<Product,
    Where<Minus<
              Sub<Sub<IsNull<Product.availQty, decimal_0>, 
                      IsNull<Product.bookedQty, decimal_0>>, 
                  Product.minAvailQty>>,
          NotEqual<decimal_0>>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                  [list of columns]  is the list of columns of the                  Product  table.                  SELECT [list of columns] FROM Product
WHERE -((ISNULL(Product.AvailQty, .0) - ISNULL(Product.BookedQty, .0))
        - Product.MinAvailQty) <> .0  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. Add<Operand1,Operand2> Class Sub<Operand1,Operand2> Class Mult<Operand1,Operand2> Class Div<Operand1,Operand2> Class Minus<Operand> Class Power<Operand1,Operand2> Class ]]></column>
		</row>
		<row PageID="0c3be5f8-d333-4080-9180-f610b0f14757" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="0fdf2680-8da5-9e2d-1979-e5185d94c86a" RecordSourceID="22377">
			<column name="Content"><![CDATA[If you are familiar with the construction of SQL statements, you may want to first construct an SQL statement and then translate it to business query language (BQL). You can follow the instructions described in this topic to translate SQL statements to BQL statements.
==To Translate an SQL Statement to BQL==
To translate an SQL statement to BQL, do the following:[anchor|#_983f846c-4cd8-4d8a-a84a-6a0e99e56fbf]
#Construct an SQL statement that selects the data you need. 
#:For example, suppose that you need to convert to BQL the following SQL statement. In this SQL query, we use the {{*}} sign to indicate that all columns of the <tt>Product</tt> table should be selected.{{{{SELECT * FROM Product
INNER JOIN SupplierProduct
    ON SupplierProduct.ProductID = Product.ProductID
INNER JOIN Supplier
    ON Supplier.AccountID = SupplierProduct.AccountID
WHERE (Product.BookedQty IS NOT NULL
       AND Product.AvailQty IS NOT NULL
       AND Product.MinAvailQty IS NOT NULL
       AND(Product.Active = 1
           OR Product.Active IS NULL)
       AND(Product.BookedQty &gt; Product.AvailQty
           OR Product.AvailQty &lt; Product.MinAvailQty))
    OR Product.AvailQty IS NOT NULL
ORDER BY Product.UnitPrice, Product.AvailQty DESC
}}}}
#Replace the names of columns with the names of class fields that correspond to the columns in data access classes (DACs). That is, change the uppercase letter in the name of each column to the lowercase, as shown in the following sample code. In this sample code, the changes are shown in bold type.{{{{SELECT * FROM Product
INNER JOIN SupplierProduct
    ON SupplierProduct.<b>productID<b> = Product.<b>productID<b>
INNER JOIN Supplier
    ON Supplier.<b>accountID<b> = SupplierProduct.<b>accountID<b>
WHERE (Product.<b>bookedQty<b> IS NOT NULL
       AND Product.<b>availQty<b> IS NOT NULL
       AND Product.<b>minAvailQty<b> IS NOT NULL
       AND(Product.<b>active<b> = 1
           OR Product.<b>active<b> IS NULL)
       AND(Product.<b>bookedQty<b> &gt; Product.<b>availQty<b>
           OR Product.<b>availQty<b> &lt; Product.<b>minAvailQty<b>))
    OR Product.<b>availQty<b> IS NOT NULL
ORDER BY Product.unitPrice, Product.availQty DESC
}}}}
#If your SQL statement contains constants, replace it with either one of the predefined constants or your own constant. (For details on using constants, see [HelpRoot_Dev_Platform\AD__how_BQL_Filter#_32d3d633-c741-4cc3-8f49-f4a611f164cb|To Compare a Field with a Constant] and the description of the [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6c4b075f-4754-acec-645a-9ca461d49010|<tt>Constant&lt;ConstType&gt;</tt>] class.) If you need to change the values of the constants at runtime, replace the constants with parameters, as described in [HelpRoot_Dev_Platform\AD__how_BQL_Parameters|To Use Parameters in Traditional BQL].
#Find the {{JOIN}}, {{WHERE}}, {{GROUP BY}}, and {{ORDER BY}} clauses that you have in the SQL statement. Depending on the included clauses, select one of the <tt>PXSelect</tt> classes, and replace {{SELECT * FROM}} with this class in your SQL statement. For details on selection of the <tt>PXSelect</tt> class, see [HelpRoot_Dev_Platform\AD__how_Construct_Statement|To Select Records By Using Traditional BQL]. For the list of all <tt>PXSelect</tt> classes, see [HelpRoot_Dev_Platform\AD__con_BQL_PXSelect|PXSelect Classes].
#:In the sample code that has been presented in this topic, you would use the <tt>PXSelectJoin&lt;Table, Join, Where, OrderBy&gt;</tt> class, and you would change the sample code as follows. (The changes are shown in bold type.){{{{<b>PXSelectJoin&lt;Product,<b>
INNER JOIN SupplierProduct
    ON SupplierProduct.productID = Product.productID
INNER JOIN Supplier
    ON Supplier.accountID = SupplierProduct.accountID<b>,<b>
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty &gt; Product.availQty
           OR Product.availQty &lt; Product.minAvailQty))
    OR Product.availQty IS NOT NULL<b>,<b>
ORDER BY Product.unitPrice, Product.availQty DESC<b>&gt;<b>
}}}}
#If your SQL statement includes {{JOIN}} clauses, do the following:
##Replace the last {{JOIN}} clause with the corresponding BQL <tt>Join</tt> clause. You would change the sample code of this topic as follows. (The changes are shown in bold type.){{{{PXSelectJoin&lt;Product,
INNER JOIN SupplierProduct
    ON SupplierProduct.productID = Product.productID
<b>InnerJoin&lt;<b>Supplier<b>,<b>
    ON Supplier.accountID = SupplierProduct.accountID<b>&gt;<b>,
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty &gt; Product.availQty
           OR Product.availQty &lt; Product.minAvailQty))
    OR Product.availQty IS NOT NULL,
ORDER BY Product.unitPrice, Product.availQty DESC&gt;
}}}}
##Chain other {{JOIN}} clauses to one another, as described in [HelpRoot_Dev_Platform\AD__how_Query_Multiple_Tables|To Query Multiple Tables]. You would change the sample code of this topic as follows. (The changes are shown in bold type.){{{{PXSelectJoin&lt;Product,
<b>InnerJoin&lt;<b>SupplierProduct<b>,<b>
    ON SupplierProduct.productID = Product.productID<b>,<b>
InnerJoin&lt;Supplier,
    ON Supplier.accountID = SupplierProduct.accountID&gt;<b>&gt;<b>,
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty &gt; Product.availQty
           OR Product.availQty &lt; Product.minAvailQty))
    OR Product.availQty IS NOT NULL,
ORDER BY Product.unitPrice, Product.availQty DESC&gt;
}}}}
##Replace each {{ON}} clause, as follows:
##*For a single condition or groups that start with a simple condition, replace the {{ON}} clause with <tt>On</tt>. 
##*For groups that start with a group of conditions, replace the {{ON}} clause with <tt>On2</tt>. 
##:With these replacements, the sample code used in this topic would be changed to the following code. (The changes are shown in bold type.){{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    <b>On&lt;<b>SupplierProduct.productID = Product.productID<b>&gt;<b>,
InnerJoin&lt;Supplier,
    <b>On&lt;<b>Supplier.accountID = SupplierProduct.accountID<b>&gt;<b>&gt;&gt;,
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty &gt; Product.availQty
           OR Product.availQty &lt; Product.minAvailQty))
    OR Product.availQty IS NOT NULL,
ORDER BY Product.unitPrice, Product.availQty DESC&gt;
}}}}
#If your SQL statement includes a {{WHERE}} clause, replace the {{WHERE}} clause and each pair of parentheses that encloses each group of conditions in the {{WHERE}} clause with a <tt>Where</tt>, <tt>Where2</tt>, <tt>Not</tt>, or <tt>Not2</tt> clause, as follows:
#*<tt>Where</tt> is used for groups that start with a simple condition. 
#*<tt>Not</tt> is used for groups that start with a simple condition but are preceded with the logical {{NOT}}.
#*<tt>Where2</tt> is used for groups that start with a group of conditions. 
#*<tt>Not2</tt> is used for groups that start with a group of conditions but preceded with the logical {{NOT}}.
#:With these replacements, the sample code used in this topic would be changed to the following code. (The changes are shown in bold type.){{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    On&lt;SupplierProduct.productID = Product.productID&gt;,
InnerJoin&lt;Supplier,
    On&lt;Supplier.accountID = SupplierProduct.accountID&gt;&gt;&gt;,
<b>Where2&lt;<b> <b>Where&lt;<b>Product.bookedQty<b>,<b> IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND <b>Where&lt;<b>Product.active = 1<b>,<b>
           OR Product.active IS NULL<b>&gt;<b>
       AND <b>Where&lt;<b>Product.bookedQty &gt; Product.availQty<b>,<b>
           OR Product.availQty &lt; Product.minAvailQty<b>&gt;<b> <b>&gt;<b> <b>,<b>
    OR Product.availQty IS NOT NULL<b>&gt;<b>,
OrderBy&lt;Asc&lt;Product.unitPrice, Desc&lt;Product.availQty&gt;&gt;&gt;&gt;
}}}}
#In each BQL <tt>Where</tt> or <tt>On</tt> clause, replace the logical operators (either {{AND}} or {{OR}}) to <tt>And</tt>, <tt>Or</tt>, <tt>And2</tt>, or <tt>Or2</tt>, as follows:
##Replace the last {{AND}} or {{OR}} in each BQL <tt>Where</tt> or <tt>On</tt> clause with the <tt>And</tt> or <tt>Or</tt> operator, respectively, as shown in the following code. (The changes are shown in bold type.){{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    On&lt;SupplierProduct.productID = Product.productID&gt;,
InnerJoin&lt;Supplier,
    On&lt;Supplier.accountID = SupplierProduct.accountID&gt;&gt;&gt;,
Where2&lt;Where&lt;Product.bookedQty, IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND Where&lt;Product.active = 1,
           <b>Or&lt;<b>Product.active IS NULL<b>&gt;<b>&gt;
       <b>And&lt;<b>Where&lt;Product.bookedQty &gt; Product.availQty,
           <b>Or&lt;<b>Product.availQty &lt; Product.minAvailQty<b>&gt;<b>&gt;<b>&gt;<b>&gt;,
    <b>Or&lt;<b>Product.availQty IS NOT NULL<b>&gt;<b>&gt;,
OrderBy&lt;Asc&lt;Product.unitPrice, Desc&lt;Product.availQty&gt;&gt;&gt;&gt;
}}}}
##In each BQL <tt>Where</tt> or <tt>On</tt> clause, if the {{AND}} or {{OR}} is located before a simple condition, replace it with <tt>And</tt> or <tt>Or</tt>, respectively. If the condition is preceded by {{NOT}}, wrap it in <tt>Not</tt>. With these replacements, the sample code used in this topic would be changed to the following code. (The changes are shown in bold type.){{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    On&lt;SupplierProduct.productID = Product.productID&gt;,
InnerJoin&lt;Supplier,
    On&lt;Supplier.accountID = SupplierProduct.accountID&gt;&gt;&gt;,
Where2&lt;Where&lt;Product.bookedQty, IS NOT NULL,
       <b>And&lt;<b>Product.availQty IS NOT NULL<b>,<b> <b>And&lt;<b>Product.minAvailQty IS NOT NULL<b>,<b>
       AND Where&lt;Product.active = 1,
           Or&lt;Product.active IS NULL&gt;&gt;
       And&lt;Where&lt;Product.bookedQty &gt; Product.availQty,
           Or&lt;Product.availQty &lt; Product.minAvailQty&gt;&gt;&gt;<b>&gt;<b> <b>&gt;<b>&gt;,
    Or&lt;Product.availQty IS NOT NULL&gt;&gt;,
OrderBy&lt;Asc&lt;Product.unitPrice, Desc&lt;Product.availQty&gt;&gt;&gt;&gt;
}}}}
##In each BQL <tt>Where</tt> or <tt>On</tt> clause, if the {{AND}} or {{OR}} is located before a group of conditions, replace it with <tt>And2&lt;Operator, NextOperator&gt;</tt> or <tt>Or2&lt;Operator, NextOperator&gt;</tt>, respectively. The first parameter in a logical operator is <tt>Where</tt> (or <tt>Where2</tt>). If the condition is preceded by {{NOT}}, place {{Not}} before a group in a <tt>Where</tt> clause. The following sample code implements these changes (shown in bold type).{{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    On&lt;SupplierProduct.productID = Product.productID&gt;,
InnerJoin&lt;Supplier,
    On&lt;Supplier.accountID = SupplierProduct.accountID&gt;&gt;&gt;,
Where2&lt;Where&lt;Product.bookedQty, IS NOT NULL,
       And&lt;Product.availQty IS NOT NULL,
       And&lt;Product.minAvailQty IS NOT NULL,
       <b>And2&lt;<b>Where&lt;Product.active = 1,
           Or&lt;Product.active IS NULL&gt;&gt;,
       And&lt;Where&lt;Product.bookedQty &gt; Product.availQty,
           Or&lt;Product.availQty &lt; Product.minAvailQty&gt;&gt;&gt;<b>&gt;<b>&gt;&gt;&gt;,
    Or&lt;Product.availQty IS NOT NULL&gt;&gt;,
OrderBy&lt;Asc&lt;Product.unitPrice, Desc&lt;Product.availQty&gt;&gt;&gt;&gt;
}}}}
#In each <tt>Where</tt> or <tt>On</tt> clause, replace the groups that use arithmetic operations with the corresponding BQL operators, as described in [HelpRoot_Dev_Platform\AD__how_BQL_Functions|To Use Arithmetic Operations].
#In each <tt>Where</tt> or <tt>On</tt> clause, replace each comparison with the corresponding comparison operator, such as <tt>Equal</tt>, <tt>Greater</tt>, or <tt>IsNull</tt>. For more information on constructing comparisons, see [HelpRoot_Dev_Platform\AD__how_BQL_Filter|To Filter Records].
#:The following sample code includes these changes (shown in bold type).{{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    On&lt;SupplierProduct.productID<b>, Equal&lt;Product.productID&gt;<b>&gt;,
InnerJoin&lt;Supplier,
    On&lt;Supplier.accountID<b>, Equal&lt;SupplierProduct.accountID&gt;<b>&gt;&gt;&gt;,
Where2&lt;Where&lt;Product.bookedQty, <b>IsNotNull<b>,
       And&lt;Product.availQty<b>, IsNotNull<b>,
       And&lt;Product.minAvailQty<b>, IsNotNull<b>,
       And2&lt;Where&lt;Product.active<b>, Equal&lt;True&gt;<b>,
           Or&lt;Product.active<b>, IsNull<b>&gt;&gt;,
       And&lt;Where&lt;Product.bookedQty<b>, Greater&lt;Product.availQty&gt;<b>,
           Or&lt;Product.availQty<b>, Less&lt;Product.minAvailQty&gt;<b>&gt;&gt;&gt;&gt;&gt;&gt;&gt;,
    Or&lt;Product.availQty<b>, IsNotNull<b>&gt;&gt;,
OrderBy&lt;Asc&lt;Product.unitPrice, Desc&lt;Product.availQty&gt;&gt;&gt;&gt;
}}}}
#Align logical operators of the same level so that they have the same indentation and so that each simple condition is placed on a separate line. Do not add line breaks before nested <tt>Where</tt> clauses.
#If your SQL statement includes the {{GROUP BY}} clause, do the following:
##Replace the {{GROUP BY}} clause with the <tt>Aggregate</tt> clause. 
##Chain the <tt>GroupBy</tt> clause and aggregation functions (such as <tt>Min</tt>, <tt>Max</tt>, <tt>Sum</tt>, <tt>Avg</tt>, and <tt>Count</tt>) to one another as described in [HelpRoot_Dev_Platform\AD__how_BQL_Group_and_Aggregate|To Group and Aggregate Records]. 
#If your SQL statement includes the {{ORDER BY}} clause, do the following:
##Replace the {{ORDER BY}} clause with the <tt>OrderBy</tt> clause. The following sample code shows this change (with changes shown in bold type).{{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    On&lt;SupplierProduct.productID, Equal&lt;Product.productID&gt;&gt;,
InnerJoin&lt;Supplier,
    On&lt;Supplier.accountID, Equal&lt;SupplierProduct.accountID&gt;&gt;&gt;&gt;,
Where2&lt;Where&lt;Product.bookedQty, IsNotNull,
       And&lt;Product.availQty, IsNotNull,
       And&lt;Product.minAvailQty, IsNotNull,
       And2&lt;Where&lt;Product.active, Equal&lt;True&gt;,
           Or&lt;Product.active, IsNull&gt;&gt;,
       And&lt;Where&lt;Product.bookedQty, Greater&lt;Product.availQty&gt;,
           Or&lt;Product.availQty, Less&lt;Product.minAvailQty&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;,
    Or&lt;Product.availQty, IsNotNull&gt;&gt;,
<b>OrderBy&lt;<b>Product.unitPrice, Product.availQty DESC<b>&gt;<b>&gt;
}}}}
##Chain the <tt>Asc</tt> and <tt>Desc</tt> operators to one another, as described in [HelpRoot_Dev_Platform\AD__how_BQL_OrderBy|To Order Records]. The following sample code shows this change (with changes shown in bold type).{{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    On&lt;SupplierProduct.productID, Equal&lt;Product.productID&gt;&gt;,
InnerJoin&lt;Supplier,
    On&lt;Supplier.accountID, Equal&lt;SupplierProduct.accountID&gt;&gt;&gt;&gt;,
Where2&lt;Where&lt;Product.bookedQty, IsNotNull,
       And&lt;Product.availQty, IsNotNull,
       And&lt;Product.minAvailQty, IsNotNull,
       And2&lt;Where&lt;Product.active, Equal&lt;True&gt;,
           Or&lt;Product.active, IsNull&gt;&gt;,
       And&lt;Where&lt;Product.bookedQty, Greater&lt;Product.availQty&gt;,
           Or&lt;Product.availQty, Less&lt;Product.minAvailQty&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;,
    Or&lt;Product.availQty, IsNotNull&gt;&gt;,
OrderBy&lt;<b>Asc&lt;<b>Product.unitPrice, <b>Desc&lt;<b>Product.availQty<b>&gt;<b> <b>&gt;<b>&gt;&gt;
}}}}
#Check that the final statement is correct by doing the following:
#*Check that all lines except the last line of the BQL statement end with a comma.
#*Ensure that the number of closing angle brackets equals the number of opening angle brackets.

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Correspondence_BQL_SQL|Traditional BQL and SQL Equivalents]]]></column>
			<column name="PlainText"><![CDATA[To Compose a BQL Statement from an SQL Statement If you are familiar with the construction of SQL statements, you may want to first             construct an SQL statement and then translate it to business query language (BQL). You             can follow the instructions described in this topic to translate SQL statements to BQL             statements. To Translate an SQL Statement to BQL To translate an SQL statement to BQL, do the following: Construct an SQL statement that selects the data you need.  For example,                             suppose that you need to convert to BQL the following SQL statement. In                             this SQL query, we use the  *  sign to indicate that all                             columns of the  Product  table should be                             selected. SELECT * FROM Product
INNER JOIN SupplierProduct
    ON SupplierProduct.ProductID = Product.ProductID
INNER JOIN Supplier
    ON Supplier.AccountID = SupplierProduct.AccountID
WHERE (Product.BookedQty IS NOT NULL
       AND Product.AvailQty IS NOT NULL
       AND Product.MinAvailQty IS NOT NULL
       AND(Product.Active = 1
           OR Product.Active IS NULL)
       AND(Product.BookedQty > Product.AvailQty
           OR Product.AvailQty < Product.MinAvailQty))
    OR Product.AvailQty IS NOT NULL
ORDER BY Product.UnitPrice, Product.AvailQty DESC Replace the names of columns with the names of class fields that correspond                         to the columns in data access classes (DACs). That is, change the uppercase                         letter in the name of each column to the lowercase, as shown in the                         following sample code. In this sample code, the changes are shown in bold                         type. SELECT * FROM Product
INNER JOIN SupplierProduct
    ON SupplierProduct. productID  = Product. productID 
INNER JOIN Supplier
    ON Supplier. accountID  = SupplierProduct. accountID 
WHERE (Product. bookedQty  IS NOT NULL
       AND Product. availQty  IS NOT NULL
       AND Product. minAvailQty  IS NOT NULL
       AND(Product. active  = 1
           OR Product. active  IS NULL)
       AND(Product. bookedQty  > Product. availQty 
           OR Product. availQty  < Product. minAvailQty ))
    OR Product. availQty  IS NOT NULL
ORDER BY Product.unitPrice, Product.availQty DESC If your SQL statement contains constants, replace it with either one of the                         predefined constants or your own constant. (For details on using constants,                         see  To Compare a Field with a Constant and the description of the  Constant<ConstType> <tt>Constant&lt;ConstType&gt;</tt> class.) If you                         need to change the values of the constants at runtime, replace the constants                         with parameters, as described in  To Use Parameters in Traditional BQL. Find the  JOIN ,  WHERE ,  GROUP                             BY , and  ORDER BY  clauses that you have in the                         SQL statement. Depending on the included clauses, select one of the                              PXSelect  classes, and replace  SELECT *                             FROM  with this class in your SQL statement. For details on                         selection of the  PXSelect  class, see  To Select Records By Using Traditional BQL. For the list of all  PXSelect  classes, see  PXSelect Classes. In the sample code that has been presented in this topic, you                             would use the  PXSelectJoin<Table, Join, Where,                                 OrderBy>  class, and you would change the sample code as                             follows. (The changes are shown in bold                             type.) PXSelectJoin<Product, 
INNER JOIN SupplierProduct
    ON SupplierProduct.productID = Product.productID
INNER JOIN Supplier
    ON Supplier.accountID = SupplierProduct.accountID , 
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty > Product.availQty
           OR Product.availQty < Product.minAvailQty))
    OR Product.availQty IS NOT NULL , 
ORDER BY Product.unitPrice, Product.availQty DESC > If your SQL statement includes  JOIN  clauses, do the                             following: Replace the last  JOIN  clause with the corresponding                                 BQL  Join  clause. You would change the sample code                                 of this topic as follows. (The changes are shown in bold                                 type.) PXSelectJoin<Product,
INNER JOIN SupplierProduct
    ON SupplierProduct.productID = Product.productID
 InnerJoin< Supplier , 
    ON Supplier.accountID = SupplierProduct.accountID > ,
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty > Product.availQty
           OR Product.availQty < Product.minAvailQty))
    OR Product.availQty IS NOT NULL,
ORDER BY Product.unitPrice, Product.availQty DESC> Chain other  JOIN  clauses to one another, as                                 described in  To Query Multiple Tables. You would change the sample code of this topic as follows. (The                                 changes are shown in bold                                 type.) PXSelectJoin<Product,
 InnerJoin< SupplierProduct , 
    ON SupplierProduct.productID = Product.productID , 
InnerJoin<Supplier,
    ON Supplier.accountID = SupplierProduct.accountID> > ,
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty > Product.availQty
           OR Product.availQty < Product.minAvailQty))
    OR Product.availQty IS NOT NULL,
ORDER BY Product.unitPrice, Product.availQty DESC> Replace each  ON  clause, as follows: For a single condition or groups that start with a simple                                         condition, replace the  ON  clause with                                              On .  For groups that start with a group of conditions, replace                                         the  ON  clause with  On2 .                                      With these replacements, the sample code used in this topic                                     would be changed to the following code. (The changes are shown                                     in bold                                     type.) PXSelectJoin<Product,
InnerJoin<SupplierProduct,
     On< SupplierProduct.productID = Product.productID > ,
InnerJoin<Supplier,
     On< Supplier.accountID = SupplierProduct.accountID > >>,
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty > Product.availQty
           OR Product.availQty < Product.minAvailQty))
    OR Product.availQty IS NOT NULL,
ORDER BY Product.unitPrice, Product.availQty DESC> If your SQL statement includes a  WHERE  clause, replace the                              WHERE  clause and each pair of parentheses that encloses                         each group of conditions in the  WHERE  clause with a                              Where ,  Where2 ,                              Not , or  Not2  clause, as                             follows: Where  is used for groups that start with a simple                                 condition.  Not  is used for groups that start with a simple                                 condition but are preceded with the logical                                  NOT . Where2  is used for groups that start with a group                                 of conditions.  Not2  is used for groups that start with a group                                 of conditions but preceded with the logical                                  NOT . With these replacements, the sample code used in this topic would be                             changed to the following code. (The changes are shown in bold                             type.) PXSelectJoin<Product,
InnerJoin<SupplierProduct,
    On<SupplierProduct.productID = Product.productID>,
InnerJoin<Supplier,
    On<Supplier.accountID = SupplierProduct.accountID>>>,
 Where2< Where< Product.bookedQty ,  IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND  Where< Product.active = 1 , 
           OR Product.active IS NULL > 
       AND  Where< Product.bookedQty > Product.availQty , 
           OR Product.availQty < Product.minAvailQty > > , 
    OR Product.availQty IS NOT NULL > ,
OrderBy<Asc<Product.unitPrice, Desc<Product.availQty>>>> In each BQL  Where  or  On  clause,                         replace the logical operators (either  AND  or                              OR ) to  And ,  Or ,                              And2 , or  Or2 , as follows: Replace the last  AND  or  OR  in each                                 BQL  Where  or  On  clause with                                 the  And  or  Or  operator,                                 respectively, as shown in the following code. (The changes are shown                                 in bold                                 type.) PXSelectJoin<Product,
InnerJoin<SupplierProduct,
    On<SupplierProduct.productID = Product.productID>,
InnerJoin<Supplier,
    On<Supplier.accountID = SupplierProduct.accountID>>>,
Where2<Where<Product.bookedQty, IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND Where<Product.active = 1,
            Or< Product.active IS NULL > >
        And< Where<Product.bookedQty > Product.availQty,
            Or< Product.availQty < Product.minAvailQty > > > >,
     Or< Product.availQty IS NOT NULL > >,
OrderBy<Asc<Product.unitPrice, Desc<Product.availQty>>>> In each BQL  Where  or  On                                  clause, if the  AND  or  OR  is                                 located before a simple condition, replace it with                                      And  or  Or , respectively.                                 If the condition is preceded by  NOT , wrap it in                                      Not . With these replacements, the sample code                                 used in this topic would be changed to the following code. (The                                 changes are shown in bold                                 type.) PXSelectJoin<Product,
InnerJoin<SupplierProduct,
    On<SupplierProduct.productID = Product.productID>,
InnerJoin<Supplier,
    On<Supplier.accountID = SupplierProduct.accountID>>>,
Where2<Where<Product.bookedQty, IS NOT NULL,
        And< Product.availQty IS NOT NULL , And< Product.minAvailQty IS NOT NULL , 
       AND Where<Product.active = 1,
           Or<Product.active IS NULL>>
       And<Where<Product.bookedQty > Product.availQty,
           Or<Product.availQty < Product.minAvailQty>>> > > >,
    Or<Product.availQty IS NOT NULL>>,
OrderBy<Asc<Product.unitPrice, Desc<Product.availQty>>>> In each BQL  Where  or  On                                  clause, if the  AND  or  OR  is                                 located before a group of conditions, replace it with                                      And2<Operator, NextOperator>  or                                      Or2<Operator, NextOperator> , respectively.                                 The first parameter in a logical operator is                                      Where  (or  Where2 ). If the                                 condition is preceded by  NOT , place                                      Not  before a group in a                                      Where  clause. The following sample code                                 implements these changes (shown in bold                                 type). PXSelectJoin<Product,
InnerJoin<SupplierProduct,
    On<SupplierProduct.productID = Product.productID>,
InnerJoin<Supplier,
    On<Supplier.accountID = SupplierProduct.accountID>>>,
Where2<Where<Product.bookedQty, IS NOT NULL,
       And<Product.availQty IS NOT NULL,
       And<Product.minAvailQty IS NOT NULL,
        And2< Where<Product.active = 1,
           Or<Product.active IS NULL>>,
       And<Where<Product.bookedQty > Product.availQty,
           Or<Product.availQty < Product.minAvailQty>>> > >>>,
    Or<Product.availQty IS NOT NULL>>,
OrderBy<Asc<Product.unitPrice, Desc<Product.availQty>>>> In each  Where  or  On  clause, replace                         the groups that use arithmetic operations with the corresponding BQL                         operators, as described in  To Use Arithmetic Operations. In each  Where  or  On  clause, replace                         each comparison with the corresponding comparison operator, such as                              Equal ,  Greater , or                              IsNull . For more information on constructing                         comparisons, see  To Filter Records. The following sample code includes these changes (shown in bold                             type). PXSelectJoin<Product,
InnerJoin<SupplierProduct,
    On<SupplierProduct.productID , Equal<Product.productID> >,
InnerJoin<Supplier,
    On<Supplier.accountID , Equal<SupplierProduct.accountID> >>>,
Where2<Where<Product.bookedQty,  IsNotNull ,
       And<Product.availQty , IsNotNull ,
       And<Product.minAvailQty , IsNotNull ,
       And2<Where<Product.active , Equal<True> ,
           Or<Product.active , IsNull >>,
       And<Where<Product.bookedQty , Greater<Product.availQty> ,
           Or<Product.availQty , Less<Product.minAvailQty> >>>>>>>,
    Or<Product.availQty , IsNotNull >>,
OrderBy<Asc<Product.unitPrice, Desc<Product.availQty>>>> Align logical operators of the same level so that they have the same                         indentation and so that each simple condition is placed on a separate line.                         Do not add line breaks before nested  Where  clauses. If your SQL statement includes the  GROUP BY  clause, do the                             following: Replace the  GROUP BY  clause with the                                      Aggregate  clause.  Chain the  GroupBy  clause and aggregation                                 functions (such as  Min ,  Max ,                                      Sum ,  Avg , and                                      Count ) to one another as described in  To Group and Aggregate Records.  If your SQL statement includes the  ORDER BY  clause, do the                             following: Replace the  ORDER BY  clause with the                                      OrderBy  clause. The following sample code                                 shows this change (with changes shown in bold                                 type). PXSelectJoin<Product,
InnerJoin<SupplierProduct,
    On<SupplierProduct.productID, Equal<Product.productID>>,
InnerJoin<Supplier,
    On<Supplier.accountID, Equal<SupplierProduct.accountID>>>>,
Where2<Where<Product.bookedQty, IsNotNull,
       And<Product.availQty, IsNotNull,
       And<Product.minAvailQty, IsNotNull,
       And2<Where<Product.active, Equal<True>,
           Or<Product.active, IsNull>>,
       And<Where<Product.bookedQty, Greater<Product.availQty>,
           Or<Product.availQty, Less<Product.minAvailQty>>>>>>>>,
    Or<Product.availQty, IsNotNull>>,
 OrderBy< Product.unitPrice, Product.availQty DESC > > Chain the  Asc  and  Desc                                  operators to one another, as described in  To Order Records. The following sample code shows this change (with changes shown                                 in bold                                 type). PXSelectJoin<Product,
InnerJoin<SupplierProduct,
    On<SupplierProduct.productID, Equal<Product.productID>>,
InnerJoin<Supplier,
    On<Supplier.accountID, Equal<SupplierProduct.accountID>>>>,
Where2<Where<Product.bookedQty, IsNotNull,
       And<Product.availQty, IsNotNull,
       And<Product.minAvailQty, IsNotNull,
       And2<Where<Product.active, Equal<True>,
           Or<Product.active, IsNull>>,
       And<Where<Product.bookedQty, Greater<Product.availQty>,
           Or<Product.availQty, Less<Product.minAvailQty>>>>>>>>,
    Or<Product.availQty, IsNotNull>>,
OrderBy< Asc< Product.unitPrice,  Desc< Product.availQty > > >> Check that the final statement is correct by doing the following: Check that all lines except the last line of the BQL statement end                                 with a comma. Ensure that the number of closing angle brackets equals the number                                 of opening angle brackets. ]]></column>
		</row>
		<row PageID="8f8f3b86-935a-4ba0-bbb8-1e1a01f4ec4f" Language="en-US" PageRevisionID="1" PlainText="Creating LINQ Queries To query data from the database, you can use language-integrated query (LINQ), which is a    part of .NET Framework. In the code of  Acumatica Framework-based    applications, you can use both the standard query operators (provided by LINQ libraries) and the      Acumatica Framework-specific operators that are designed to query database data.  In this chapter, you can find     information on how to create LINQ queries. For the general information about data querying, see       Querying Data in Acumatica Framework.  In This Chapter LINQ in Acumatica FrameworkDeferred LINQ Query ExecutionFallback to the LINQ to Objects ModeTo Select Records by Using LINQTo Append LINQ Expressions to BQL Statements" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="3324a27e-da22-04c4-b079-457a7796cd04" RecordSourceID="22377">
			<column name="Content"><![CDATA[To query data from the database, you can use language-integrated query (LINQ), which is a part of .NET Framework. In the code of Acumatica Framework-based applications, you can use both the standard query operators (provided by LINQ libraries) and the Acumatica Framework-specific operators that are designed to query database data. 
In this chapter, you can find information on how to create LINQ queries. For the general information about data querying, see [HelpRoot_Dev_Platform\AD__mng_Querying_Data|Querying Data in Acumatica Framework]. 
==In This Chapter==[anchor|#_e5997ee2-39b0-4608-a398-44f66e80c097]
{| class="checklist invisiblechecklist" | width="100%" 
|- 
| [anchor|#_93066789-a65a-4bb7-9805-486e06af6175]
*[HelpRoot_Dev_Platform\AD__con_LINQ_in_Acumatica_Framework|LINQ in Acumatica Framework]
*[HelpRoot_Dev_Platform\AD__con_Deferred_LINQ_Query_Execution|Deferred LINQ Query Execution]
*[HelpRoot_Dev_Platform\AD__con_Fallback_to_LINQ2Objects|Fallback to the LINQ to Objects Mode]

| [anchor|#_d3276ca7-2ed8-4591-b7f7-4013682d0055]
*[HelpRoot_Dev_Platform\AD__how_LINQ_Select_Records|To Select Records by Using LINQ]
*[HelpRoot_Dev_Platform\AD__how_LINQ_Filter_BQL|To Append LINQ Expressions to BQL Statements]

|}]]></column>
		</row>
		<row PageID="0964f231-82b9-4b86-bca4-1d26151f8baf" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="429bff7a-5722-67a8-65e6-399bf657c104" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#_3d2065a1-86bd-4a29-8ba5-8f4cd2e6db0b]
You can use language-integrated query (LINQ) provided by the {{System.Linq}} library when you need to select records from the database in the code of Acumatica Framework-based applications or if you want to apply additional filtering to the data of a BQL query. However, you still have to use business query language (BQL) to define the data views in graphs and to specify the data queries in attributes of data fields. {br}

For details about BQL, see [HelpRoot_Dev_Platform\AD__mng_Fluent_BQL|Creating Fluent BQL Queries] and [HelpRoot_Dev_Platform\AD__mng_Traditional_BQL|Creating Traditional BQL Queries]. For more information about the differences between LINQ and BQL, see [HelpRoot_Dev_Platform\AD__con_Comparison_of_TBQL_FBQL_LINQ|Comparison of Fluent BQL, Traditional BQL, and LINQ].{br}{TOC}
==Data Access Classes in LINQ==
In LINQ expressions, to access data from the database tables, you use data access classes (DACs). For details on DACs, see [HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes]. {br}

You use property fields of DACs when you need to specify table columns in LINQ expressions. (The name of the property field starts with an uppercase letter. Do not confuse it with the class field, which has the same name but starts with lowercase letter.)
==Query Syntax==[anchor|#_cfb58c9f-a87c-4c9b-9a81-f9804db10799]
To configure a LINQ query, you can use the following variants of syntax:[anchor|#_d931dafe-baf3-40c0-b01c-65edc15f867c]
*Query expressions, which use standard query operators from the {{System.Linq}} namespace (such as {{where}} or {{orderby}}) or Acumatica Framework-specific operators from the {{PX.Data.SQLTree}} namespace (such as <tt>SQL.BinaryLen</tt>, which is shown in the following example of this syntax). <source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var goods = from p in graph.Select&lt;Product&gt;()
  where 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0
  select new 
  { 
    p.ProductID, 
    p.ProductCD, 
    p.ProductName, 
    Len = p.ProductName.Length, 
    BLen = SQL.BinaryLen( p.ProductName) + 1, 
    p.GroupMask, 
    p.WorkGroupID 
};</source>
*Explicit (method-based) syntax. The arguments of the methods used in this syntax are lambda expressions. In these expressions, you can use the standard C# operators and Acumatica Framework-specific operators from the {{PX.Data.SQLTree}} namespace (such as <tt>SQL.BinaryLen</tt>, which is shown in the following code). The code below is equivalent to the query expression shown above.<source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var goods = graph.Select&lt;Product&gt;()
  .Where( p =&gt; 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0)
  .Select( p =&gt; new     
    { 
      p.ProductID, 
      p.ProductCD, 
      p.ProductName, 
      Len = p.ProductName.Length, 
      BLen = SQL.BinaryLen(p.ProductName) + 1, 
      p.GroupMask, p.WorkGroupID 
    });</source>
{br}

For details about composing LINQ queries, see [HelpRoot_Dev_Platform\AD__how_LINQ_Select_Records|To Select Records by Using LINQ]. In the code examples of this guide, we use explicit syntax.
==Simultaneous Use of LINQ and BQL==
The <tt>Select</tt> method of all <tt>PXSelect</tt> classes of Acumatica Framework return <tt>PXResultset&lt;T0&gt;</tt>, which implements the {{IQueryable<PXResult<T0>>}} interface. That is, you can work with the query expression defined with BQL by using LINQ. The following code shows an example of additional filtering of data of the BQL query.<source lang="csharp">//BQL statement
var Products = new PXSelect&lt;Product, 
  Where&lt;Product.productCD, Like&lt;string_D&gt;&gt;&gt;(graph);
//Use of LINQ for the result of the BQL query
var goods = Products.Select()
  .Where(p =&gt; p.GetItem&lt;Product&gt;().StockUnit == "item");
//Execution of the query
foreach (var good in goods) {
  var prod = good.GetItem&lt;Product&gt;();
}</source>{br}

However, you cannot work with the query defined with LINQ by using BQL.{br}

For details about how to use LINQ and BQL simultaneously, see [HelpRoot_Dev_Platform\AD__how_LINQ_Filter_BQL|To Append LINQ Expressions to BQL Statements].
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Comparison_of_TBQL_FBQL_LINQ|Comparison of Fluent BQL, Traditional BQL, and LINQ]
*[HelpRoot_Dev_Platform\AD__how_LINQ_Select_Records|To Select Records by Using LINQ]
*[HelpRoot_Dev_Platform\AD__how_LINQ_Filter_BQL|To Append LINQ Expressions to BQL Statements]]]></column>
			<column name="PlainText"><![CDATA[LINQ in  Acumatica FrameworkYou can use language-integrated query (LINQ) provided by the  System.Linq  library when you need to select records from the database in the code of  Acumatica Framework-based applications or if you want to apply additional filtering to the data of a BQL query. However, you still have to use business query language (BQL) to define the data views in graphs and to specify the data queries in attributes of data fields.  For details about BQL, see  Creating Fluent BQL Queries and  Creating Traditional BQL Queries. For more information about the differences between         LINQ and BQL, see  Comparison of Fluent BQL, Traditional BQL, and LINQ. Data Access Classes in LINQ In LINQ expressions, to access data from the database tables, you use data access classes         (DACs). For details on DACs, see  Data Access Classes.  You use property fields of DACs when you need to specify table columns in LINQ expressions.         (The name of the property field starts with an uppercase letter. Do not confuse it with the         class field, which has the same name but starts with lowercase letter.) Query Syntax To configure a LINQ query, you can use the following       variants of syntax: Query expressions, which use standard query operators from the              System.Linq  namespace (such as  where  or              orderby ) or  Acumatica Framework-specific           operators from the  PX.Data.SQLTree  namespace (such as              SQL.BinaryLen , which is shown in the following example of this           syntax).            ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var goods = from p in graph.Select<Product>()
  where 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0
  select new 
  { 
    p.ProductID, 
    p.ProductCD, 
    p.ProductName, 
    Len = p.ProductName.Length, 
    BLen = SQL.BinaryLen( p.ProductName) + 1, 
    p.GroupMask, 
    p.WorkGroupID 
}; Explicit (method-based) syntax. The arguments of the methods used in this syntax are           lambda expressions. In these expressions, you can use the standard C# operators and  Acumatica Framework-specific           operators from the  PX.Data.SQLTree  namespace (such as              SQL.BinaryLen , which is shown in the following code). The code below           is equivalent to the query expression shown           above. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var goods = graph.Select<Product>()
  .Where( p => 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0)
  .Select( p => new     
    { 
      p.ProductID, 
      p.ProductCD, 
      p.ProductName, 
      Len = p.ProductName.Length, 
      BLen = SQL.BinaryLen(p.ProductName) + 1, 
      p.GroupMask, p.WorkGroupID 
    }); For details about composing LINQ queries, see  To Select Records by Using LINQ. In the code examples of this guide, we use explicit syntax. Simultaneous Use of LINQ and BQL The  Select  method of all  PXSelect  classes of  Acumatica Framework         return  PXResultset<T0> , which implements the            IQueryable<PXResult<T0>>  interface. That is, you can work with the         query expression defined with BQL by using LINQ. The following code shows an example of         additional filtering of data of the BQL         query. //BQL statement
var Products = new PXSelect<Product, 
  Where<Product.productCD, Like<string_D>>>(graph);
//Use of LINQ for the result of the BQL query
var goods = Products.Select()
  .Where(p => p.GetItem<Product>().StockUnit == "item");
//Execution of the query
foreach (var good in goods) {
  var prod = good.GetItem<Product>();
} However, you cannot work with the query defined with LINQ by using BQL. For details about how to use LINQ and BQL simultaneously, see  To Append LINQ Expressions to BQL Statements. ]]></column>
		</row>
		<row PageID="c086439e-08ff-4812-bc02-abcfc1279bea" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="97aa66ab-0c53-1e46-d7e5-fda7b02a45a8" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Queries defined with LINQ in Acumatica Framework implement the {{IQueryable}} interface—that is, for these queries, the system generates expression trees and executes the queries only when they are iterated over. For details about query execution, see [HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution].{br}{TOC}
==Execution of the LINQ Query in Code==
To execute the query, you do one of the following:[anchor|#_decfb88d-7a14-4b10-b48f-8470b2364b30]
*Call the {{ToList}} or {{ToArray}} method for the query, as shown in the following code.<source lang="csharp">//query is a LINQ expression.
var data = query.ToList();</source>
*Iterate the query by using the {{foreach}} statement, as shown in the following code.<source lang="csharp">//query has the IQueryable&lt;Product&gt; type.
//Product is a DAC.
foreach (Product record in query)
{
    ...
}</source>

==Explicit Merge of Records with PXCache==
The system merges with <tt>PXCache</tt> the records the system has retrieved from the database by using the LINQ queries, as described in [HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache].{br}

You may need to explicitly merge the records retrieved from the database with a particular <tt>PXCache</tt> object. To merge the records with <tt>PXCache</tt> explicitly, you use the <tt>Merge</tt> method, as shown in the following code example.<source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var query = new PXSelectReadonly&lt;Product&gt;(graph).Select()
    .Select(r =&gt; r.GetItem&lt;Product&gt;())
    .Where(p =&gt; SQL.Like(p.ProductName, "%d%") && p.StockUnit != null)
    .OrderBy(p =&gt; p.ProductID);
var result = query.Merge(p =&gt; p).ToArray();</source>{br}

You also can specify that the query should not be merged with <tt>PXCache</tt> by using the <tt>ReadOnly</tt> method, as shown in the following code example.<source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var query = new PXSelect&lt;Product&gt;(graph).Select()
    .Select(r =&gt; r.GetItem&lt;Product&gt;())
    .Where(p =&gt; SQL.Like(p.ProductName, "%d%") && p.StockUnit != null);
    .OrderBy(p =&gt; p.ProductID);
var result = query.ReadOnly().ToArray();</source>
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]
*[HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache]]]></column>
			<column name="PlainText"><![CDATA[Deferred LINQ Query Execution Queries defined with LINQ in  Acumatica Framework         implement the  IQueryable  interface—that is, for these queries, the         system generates expression trees and executes the queries only when they are iterated over.         For details about query execution, see  Data Query Execution. Execution of the LINQ Query in Code To execute the query, you do one of the following: Call the  ToList  or  ToArray  method for the query, as             shown in the following             code. //query is a LINQ expression.
var data = query.ToList(); Iterate the query by using the  foreach  statement, as shown in the             following             code. //query has the IQueryable<Product> type.
//Product is a DAC.
foreach (Product record in query)
{
    ...
} Explicit Merge of Records with PXCache The system merges with  PXCache  the records the system has retrieved from         the database by using the LINQ queries, as described in  Merge of the Records with PXCache. You may need to explicitly merge the records retrieved from the database with a particular            PXCache  object. To merge the records with  PXCache          explicitly, you use the  Merge  method, as shown in the following code         example. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var query = new PXSelectReadonly<Product>(graph).Select()
    .Select(r => r.GetItem<Product>())
    .Where(p => SQL.Like(p.ProductName, "%d%") && p.StockUnit != null)
    .OrderBy(p => p.ProductID);
var result = query.Merge(p => p).ToArray(); You also can specify that the query should not be merged with  PXCache  by         using the  ReadOnly  method, as shown in the following code         example. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var query = new PXSelect<Product>(graph).Select()
    .Select(r => r.GetItem<Product>())
    .Where(p => SQL.Like(p.ProductName, "%d%") && p.StockUnit != null);
    .OrderBy(p => p.ProductID);
var result = query.ReadOnly().ToArray(); ]]></column>
		</row>
		<row PageID="f0785138-5659-413b-9908-814a4891f85b" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="286db9d9-a2b8-a6a3-41ee-d4de959ae25b" RecordSourceID="22377">
			<column name="Content"><![CDATA[
With LINQ, you may not be able to filter records by using custom C# functions. For example, suppose that your C# function filters records by a regular expression, which cannot be converted to standard SQL functions. If the system cannot convert a custom C# function in a LINQ statement to an SQL query tree, the system falls back to LINQ to Objects mode—that is, the system executes the data query in memory, which can lead to degradation of the application&rsquo;s performance.{br}

The following code shows an example of a situation when the system falls back to LINQ to Objects mode. In this example, the system selects from the database all records from the {{CRCase}} table, and then, in memory, orders the retrieved records by the {{Date}} column and selects the records that satisfy the condition specified by using the {{MyHelpers.IsHighPriority}} function.<source lang="csharp">// MyHelpers.IsHighPriority is a custom function.
var results = graph
    .Select&lt;CRCase&gt;()
    .OrderByDescending(c =&gt; c.Date)
    .Where(c =&gt; MyHelpers.IsHighPriority(c));

foreach (CRCase case in results)
{
    ...
}</source>((({S:Warn}If the system falls back to LINQ to Objects, only the results of the base <tt>PXSelectBase</tt> query are merged with <tt>PXCache</tt> as described in [HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache]. The <tt>Merge</tt> and <tt>ReadOnly</tt> methods do not affect the merge of records with <tt>PXCache</tt> for the queries that caused fallback.
)))
The LINQ fallback is supported in Acumatica Framework for compatibility with previous versions. The system writes to the trace log about all situations in which the system falls back to LINQ to Objects mode. Therefore, we strongly recommend that you investigate the trace log for such issues and fix the issues in one of the following ways:[anchor|#_ff6461ad-bf6a-4de5-b3ea-cf14607d52f2]
*Remove the custom C# functions that cause fallback so that the full query is executed in the database.
*Append the <tt>AsEnumerable()</tt> method to the part of the query that can be converted to SQL, and add after it the conditions that include custom C# functions. In this case, the system does not waste resources trying to build the SQL query tree for the whole query. Instead, the system builds the SQL query tree for the part of the query that has <tt>AsEnumerable()</tt> appended and performs the corresponding request to the database, while the custom C# conditions of the query are processed in memory. For example, the code example above can be modified as follows.<source lang="csharp">// MyHelpers.IsHighPriority is a custom function.
var results = graph
    .Select&lt;CRCase&gt;()
    .OrderByDescending(c =&gt; c.Date).AsEnumerable()
    .Where(c =&gt; MyHelpers.IsHighPriority(c));

foreach (CRCase case in results)
{
    ...
}</source>
*:((({S:Warn}The system executes the following SQL query for the code above, where {{[list of columns]}} is the list of columns of the {{CRCase}} table.{{{{SELECT [list of columns] FROM CRCase
    ORDER BY CRCase.Date DESC
}}}}
)))

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_LINQ_in_Acumatica_Framework|LINQ in Acumatica Framework]]]></column>
			<column name="PlainText"><![CDATA[Fallback to the LINQ to Objects Mode With LINQ, you may not be able to filter records by using custom C# functions. For example,     suppose that your C# function filters records by a regular expression, which cannot be converted     to standard SQL functions. If the system cannot convert a custom C# function in a LINQ statement     to an SQL query tree, the system falls back to LINQ to Objects mode—that is, the system     executes the data query in memory, which can lead to degradation of the application's     performance. The following code shows an example of a situation when the system falls back to LINQ to     Objects mode. In this example, the system selects from the database all records from the       CRCase  table, and then, in memory, orders the retrieved records by the       Date  column and selects the records that satisfy the condition specified by     using the  MyHelpers.IsHighPriority      function. // MyHelpers.IsHighPriority is a custom function.
var results = graph
    .Select<CRCase>()
    .OrderByDescending(c => c.Date)
    .Where(c => MyHelpers.IsHighPriority(c));

foreach (CRCase case in results)
{
    ...
} If the system falls back to LINQ to Objects, only the results of the base       PXSelectBase  query are merged with  PXCache  as described     in  Merge of the Records with PXCache. The  Merge  and       ReadOnly  methods do not affect the merge of records with       PXCache  for the queries that caused fallback. The LINQ fallback is supported in  Acumatica Framework for     compatibility with previous versions. The system writes to the trace log about all situations in     which the system falls back to LINQ to Objects mode. Therefore, we strongly recommend that you     investigate the trace log for such issues and fix the issues in one of the following ways: Remove the custom C# functions that cause fallback so that the full query is executed in       the database. Append the  AsEnumerable()  method to the part of the query that can be       converted to SQL, and add after it the conditions that include custom C# functions. In this       case, the system does not waste resources trying to build the SQL query tree for the whole       query. Instead, the system builds the SQL query tree for the part of the query that has         AsEnumerable()  appended and performs the corresponding request to the       database, while the custom C# conditions of the query are processed in memory. For example,       the code example above can be modified as        follows. // MyHelpers.IsHighPriority is a custom function.
var results = graph
    .Select<CRCase>()
    .OrderByDescending(c => c.Date).AsEnumerable()
    .Where(c => MyHelpers.IsHighPriority(c));

foreach (CRCase case in results)
{
    ...
} The        system executes the following SQL query for the code above, where  [list of         columns]  is the list of columns of the  CRCase         table. SELECT [list of columns] FROM CRCase
    ORDER BY CRCase.Date DESC ]]></column>
		</row>
		<row PageID="53571695-dd57-4099-8820-7ea518a28b90" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="845beafe-ef00-8b14-b13e-2ee8d8081004" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To select records from the database by using language-integrated query (LINQ), you use the standard query operators (provided by LINQ libraries), as described in this topic. In the LINQ queries, you use the property fields of DACs to specify the columns of database tables. (The name of the property field starts with an uppercase letter. Do not confuse it with the class field, which has the same name but starts with lowercase letter.)[anchor|#_8f043d8d-b1ec-4c3d-bd2d-d3566c27fed0]((({S:Warn}After you have composed a LINQ expression, to execute the query defined by this expression, you have to call the {{ToList}} or {{ToArray}} method for the query, or iterate the query by using the {{foreach}} statement. For example, the following code executes the query defined by a LINQ expression.{{{{//query is a LINQ expression
var data = query.ToList();
}}}}
For details about the execution of LINQ expressions, see [HelpRoot_Dev_Platform\AD__con_Deferred_LINQ_Query_Execution|Deferred LINQ Query Execution].
))){br}{TOC}[anchor|#_5c395cd0-d259-4a77-9134-211937d3a78e]
==Before You Proceed==
[anchor|#_549e6b74-0178-46cb-adf3-fc771ab6a024]
*Add the {{using}} directives shown below to your code.<source lang="csharp">using PX.Data;
using PX.Data.SQLTree;
using System.Linq;</source>
*Make sure that the application database has the database tables from which you are going to request data, and that the application defines the data access classes (DACs) for these tables. For more information on defining DACs, see [HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes].

==To Filter Records==
To filter records in the database table to be retrieved, construct the LINQ expression by using the {{Where}} LINQ method and the needed conditions. In the conditions, use the property field defined in the DAC, such as <tt>Product.ProductID</tt>. {br}

The following LINQ expression uses the C# logical operators (<tt>||</tt>, <tt>&&</tt>, and <tt>!</tt>) to define multiple conditions.{{{{ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
IQueryable&lt;Product&gt; query = graph.Select&lt;Product&gt;().Where(prod =&gt;
    prod.BookedQty &gt; prod.AvailQty
    || prod.AvailQty &lt; prod.MinAvailQty
    || prod.AvailQty == null);
}}}}((({S:Warn}This LINQ expression is equivalent to the following SQL query. In this SQL query, {{[list of columns]}} is the list of columns of the {{Product}} table. {{{{SELECT [list of columns] FROM Product
WHERE Product.BookedQty &gt; Product.AvailQty
    OR Product.AvailQty &lt; Product.MinAvailQty
    OR Product.AvailQty IsNull
}}}}
)))
==To Order Records==
To order records to be retrieved from the database table, construct the LINQ expression by using the {{OrderBy}} or {{OrderByDescending}} LINQ method and the needed property fields of the DAC, such as <tt>Product.ProductID</tt>. {br}

The following sample LINQ expression selects all <tt>Product</tt> data records and sorts them by the <tt>UnitPrice</tt> field in ascending order.<source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
IQueryable&lt;Product&gt; query = graph.Select&lt;Product&gt;().OrderBy(prod =&gt; prod.UnitPrice)
  .ThenByDescending(prod =&gt; prod.AvailQty);</source>((({S:Warn}This LINQ expression is equivalent to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice, Product.AvailQty DESC
}}}}
)))
==To Query Multiple Tables==
To join multiple tables, construct the LINQ expression by using the {{Join}}, {{LeftJoin}}, {{GroupJoin}}, and {{FullJoin}} LINQ methods and the needed property fields of DACs, such as <tt>SalesOrder.OrderNbr</tt>. {br}

The following sample LINQ expression performs an inner join of the <tt>SalesOrder</tt> and <tt>OrderDetail</tt> DACs by the <tt>OrderNbr</tt> field.<source lang="csharp">SalesOrderEntry graph = PXGraph.CreateInstance&lt;SalesOrderEntry&gt;();
var query = graph.Select&lt;SalesOrder&gt;()
    .Join(graph.Select&lt;OrderLine&gt;(),
          ord =&gt; ord.OrderNbr, ordDet =&gt; ordDet.OrderNbr,
          (ord, ordDet) =&gt; new { SalesOrder = ord, OrderDetail = ordDet });</source>((({S:Warn}This LINQ expression is equivalent to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr
}}}}
)))
==To Group or Aggregate Records==
To group or aggregate records, do the following:[anchor|#_cd2b8cae-d32f-421e-b66d-44d8c7a1618d]
#Construct the LINQ expression by using the {{GroupBy}} LINQ method and the needed property fields of the DAC, such as <tt>Product.CategoryCD</tt>. (The name of the property field starts with an uppercase letter. Do not confuse it with the class field, which has the same name but starts with lowercase letter.) 
#Append to the expression the <tt>Select</tt> LINQ method.
#:((({S:Warn}You have to use the <tt>Select</tt> method after {{GroupBy}} to eliminate the number of requests that the system performs to the database.
)))
{br}

The following sample LINQ expression groups the records of the {{Product}} table by the {{CategoryCD}} field.<source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var query = graph.Select&lt;Product&gt;().GroupBy(prod =&gt; prod.CategoryCD).
  Select(group =&gt; new { CategoryCD = group.Key });</source>((({S:Warn}This LINQ expression is equivalent to the following SQL query.{{{{SELECT Product.CategoryCD
FROM Product
GROUP BY Product.CategoryCD
}}}}
)))
==To Select Particular Columns of Records==
To select particular columns, specify the corresponding property fields of DACs in the {{Select}} clause.{br}

The following example selects the values of the {{ProductCD}} and {{AvailQty}} fields for all records of the {{Product}} table.<source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var results = graph.Select&lt;Product&gt;()
    .Select(p =&gt; new { ProductCD = p.ProductCD, AvailQty = p.AvailQty });</source>((({S:Warn}The system executes the following SQL query for the code above.{{{{SELECT Product.ProductCD, Product.AvailQty FROM Product
}}}}
)))
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_LINQ_in_Acumatica_Framework|LINQ in Acumatica Framework]]]></column>
			<column name="PlainText"><![CDATA[To Select Records by Using LINQ To select records from the database by using language-integrated query (LINQ), you                 use the standard query operators (provided by LINQ libraries), as described in this                 topic. In the LINQ queries, you use the property fields of DACs to specify the                 columns of database tables. (The name of the property field starts with an uppercase                 letter. Do not confuse it with the class field, which has the same name but starts                 with lowercase letter.) After you have composed a LINQ expression, to             execute the query defined by this expression, you have to call the                  ToList  or  ToArray  method for the query, or iterate             the query by using the  foreach  statement. For example, the following             code executes the query defined by a LINQ                 expression. //query is a LINQ expression
var data = query.ToList(); For                 details about the execution of LINQ expressions, see  Deferred LINQ Query Execution. Before You Proceed Add the  using  directives shown below to your                         code. using PX.Data;
using PX.Data.SQLTree;
using System.Linq; Make sure that the application database has the database tables from which you are going to                         request data, and that the application defines the data access classes                         (DACs) for these tables. For more information on defining DACs, see  Data Access Classes. To Filter Records To filter records in the database table to be retrieved, construct the LINQ                 expression by using the  Where  LINQ method and the needed                 conditions. In the conditions, use the property field defined in the DAC, such as                      Product.ProductID .  The following LINQ expression uses the C# logical operators ( || ,                      && , and  ! ) to define multiple                     conditions. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
IQueryable<Product> query = graph.Select<Product>().Where(prod =>
    prod.BookedQty > prod.AvailQty
    || prod.AvailQty < prod.MinAvailQty
    || prod.AvailQty == null); This                     LINQ expression is equivalent to the following SQL query. In this SQL query,                          [list of columns]  is the list of columns of the                          Product  table.                      SELECT [list of columns] FROM Product
WHERE Product.BookedQty > Product.AvailQty
    OR Product.AvailQty < Product.MinAvailQty
    OR Product.AvailQty IsNull To Order Records To order records to be retrieved from the database table, construct the LINQ                 expression by using the  OrderBy  or                      OrderByDescending  LINQ method and the needed property fields of                 the DAC, such as  Product.ProductID .  The following sample LINQ expression selects all  Product  data                 records and sorts them by the  UnitPrice  field in ascending                 order. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
IQueryable<Product> query = graph.Select<Product>().OrderBy(prod => prod.UnitPrice)
  .ThenByDescending(prod => prod.AvailQty); This LINQ expression is equivalent to the following SQL query, where  [list                     of columns]  is the list of columns of the  Product                  table. SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice, Product.AvailQty DESC To Query Multiple Tables To join multiple tables, construct the LINQ expression by using the                      Join ,  LeftJoin ,  GroupJoin ,                 and  FullJoin  LINQ methods and the needed property fields of DACs,                 such as  SalesOrder.OrderNbr .  The following sample LINQ expression performs an inner join of the                      SalesOrder  and  OrderDetail  DACs by the                      OrderNbr  field. SalesOrderEntry graph = PXGraph.CreateInstance<SalesOrderEntry>();
var query = graph.Select<SalesOrder>()
    .Join(graph.Select<OrderLine>(),
          ord => ord.OrderNbr, ordDet => ordDet.OrderNbr,
          (ord, ordDet) => new { SalesOrder = ord, OrderDetail = ordDet }); This LINQ expression is equivalent to the following SQL query, where  [list                     of columns]  is the list of columns of the  Product                  table. SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr To Group or Aggregate Records To group or aggregate records, do the following: Construct the LINQ expression by using the  GroupBy  LINQ                         method and the needed property fields of the DAC, such as                              Product.CategoryCD . (The name of the property field                         starts with an uppercase letter. Do not confuse it with the class field,                         which has the same name but starts with lowercase letter.)  Append to the expression the  Select  LINQ method. You                             have to use the  Select  method after                                  GroupBy  to eliminate the number of requests that                             the system performs to the database. The following sample LINQ expression groups the records of the                      Product  table by the  CategoryCD  field. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var query = graph.Select<Product>().GroupBy(prod => prod.CategoryCD).
  Select(group => new { CategoryCD = group.Key }); This LINQ expression is equivalent to the following SQL                 query. SELECT Product.CategoryCD
FROM Product
GROUP BY Product.CategoryCD To Select Particular Columns of Records To select particular columns, specify the corresponding property fields of DACs in                 the  Select  clause. The following example selects the values of the  ProductCD  and                      AvailQty  fields for all records of the  Product                      table. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var results = graph.Select<Product>()
    .Select(p => new { ProductCD = p.ProductCD, AvailQty = p.AvailQty }); The                     system executes the following SQL query for the code                     above. SELECT Product.ProductCD, Product.AvailQty FROM Product ]]></column>
		</row>
		<row PageID="6e0f7080-d099-4fc3-9cb6-ad15b800546d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="53ec0445-9918-dfc9-f2f9-a393aeadcfab" RecordSourceID="22377">
			<column name="Content"><![CDATA[
By using LINQ, you can work with a query expression that is defined with BQL. In this topic, you can find out how to apply additional filtering to a BQL statement and join a table to a BQL statement by using LINQ.{br}{TOC}[anchor|#_e74b69eb-a534-490f-af3c-31be74f48b85]
==Before You Proceed==
[anchor|#_403da056-e571-4f37-8f71-a3f98868083b]
*Add the {{using}} directives shown below to your code.<source lang="csharp">using PX.Data;
using PX.Data.SQLTree;
using System.Linq;</source>
*Make sure that the application database has the database tables from which you are going to request data, and that the application defines the data access classes (DACs) for these tables. For more information on defining DACs, see [HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes].

==To Append LINQ Expressions to BQL Statements==To append LINQ expressions to BQL statements, do the following:[anchor|#_ef830bfa-a6ca-4ad5-936c-2f1011f50f10]
#Configure a BQL query derived from <tt>PXSelectBase</tt> either in fluent BQL or in traditional BQL.
#Call the <tt>Select()</tt> method of <tt>PXSelectBase</tt>, and append the LINQ query to the result. Because the result of the <tt>Select()</tt> method call is a <tt>PXResultset&lt;&gt;</tt> object, you need to cast it to a DAC type by using the <tt>PXResult.GetItem&lt;DacType&gt;()</tt> method or direct casting.

The following example appends LINQ joining and filtering to a BQL query.<source lang="csharp">using PX.Data;
using PX.Data.SQLTree;
using System.Linq;
using PX.Data.BQL.Fluent;

ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();

//Configure a BQL query
var products = new SelectFrom&lt;Product&gt;.
    Where&lt;Product.productCD.IsLike&lt;string_D&gt;&gt;.View(graph);

//Append joining and filtering by using LINQ
var goods = products.Select().Join(graph.Select&lt;SupplierProduct&gt;(),
    p =&gt; p.GetItem&lt;Product&gt;().ProductID,
    sp =&gt; sp.ProductID,
    (p, sp) =&gt; new { p = p.GetItem&lt;Product&gt;(), sp }
).Where(sp =&gt; sp.p.UnitPrice &gt;= 0 && sp.sp.LastPurchaseDate == null);

//Execute the query
foreach (var item in goods)
{
  ...
}</source>((({S:Warn}The system executes the following SQL query for the code above. In this SQL query, {{[list of columns]}} is the list of columns of the {{Product}} and {{SupplierProduct}} tables. {{{{SELECT [list of columns] FROM Product
INNER JOIN SupplierProduct
    ON Product.ProductID = SupplierProduct.ProductID
WHERE Product.ProductCD LIKE 'D' AND Product.UnitPrice&gt;=0 
    AND SupplierProduct.LastPurchaseDate IS NULL
}}}}
)))]]></column>
			<column name="PlainText"><![CDATA[To Append LINQ Expressions to BQL Statements By using LINQ, you can work with a query expression that is defined with BQL. In this                 topic, you can find out how to apply additional filtering to a BQL statement and                 join a table to a BQL statement by using LINQ. Before You Proceed Add the  using  directives shown below to your                         code. using PX.Data;
using PX.Data.SQLTree;
using System.Linq; Make sure that the application database has the database tables from which you are going to                         request data, and that the application defines the data access classes                         (DACs) for these tables. For more information on defining DACs, see  Data Access Classes. To Append LINQ Expressions to BQL Statements To append LINQ             expressions to BQL statements, do the following: Configure a BQL query derived from  PXSelectBase  either in                     fluent BQL or in traditional BQL. Call the  Select()  method of  PXSelectBase ,                     and append the LINQ query to the result. Because the result of the                          Select()  method call is a                          PXResultset<>  object, you need to cast it to a DAC                     type by using the  PXResult.GetItem<DacType>()  method or                     direct casting. The following example appends LINQ joining and filtering to a BQL                     query. using PX.Data;
using PX.Data.SQLTree;
using System.Linq;
using PX.Data.BQL.Fluent;

ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();

//Configure a BQL query
var products = new SelectFrom<Product>.
    Where<Product.productCD.IsLike<string_D>>.View(graph);

//Append joining and filtering by using LINQ
var goods = products.Select().Join(graph.Select<SupplierProduct>(),
    p => p.GetItem<Product>().ProductID,
    sp => sp.ProductID,
    (p, sp) => new { p = p.GetItem<Product>(), sp }
).Where(sp => sp.p.UnitPrice >= 0 && sp.sp.LastPurchaseDate == null);

//Execute the query
foreach (var item in goods)
{
  ...
} The                     system executes the following SQL query for the code above. In this SQL query,                          [list of columns]  is the list of columns of the                          Product  and  SupplierProduct  tables.                      SELECT [list of columns] FROM Product
INNER JOIN SupplierProduct
    ON Product.ProductID = SupplierProduct.ProductID
WHERE Product.ProductCD LIKE 'D' AND Product.UnitPrice>=0 
    AND SupplierProduct.LastPurchaseDate IS NULL ]]></column>
		</row>
		<row PageID="92c13762-b9c3-4267-b5cf-4b04fdb78e78" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can learn how to define relationships between data access classes (DACs) by using the special classes for primary and foreign keys.&#xA;==In This Chapter==[anchor|#_40926635-a71c-4253-a071-0c5632dfabbc]&#xA;*[HelpRoot_Dev_Platform\AD__con_Master-Detail_with_PXParent|Master-Detail Relationship Between Data with PXDBDefault and PXParent]&#xA;*[HelpRoot_Dev_Platform\AD__con_PK_and_FK_API|Relationship Between Data with PrimaryKeyOf and ForeignKeyOf]&#xA;*[HelpRoot_Dev_Platform\AD__con_Access_LInked_Data_with_Current|Selection of the Linked Data Through the Current Property]&#xA;*[HelpRoot_Dev_Platform\AD__how_Define_Primary_Key|To Define a Primary Key]&#xA;*[HelpRoot_Dev_Platform\AD__how_Define_Foreign_Key|To Define a Foreign Key]&#xA;" PlainText="Defining Relationships Between DACs In this chapter, you can learn how to define relationships between data access classes (DACs)     by using the special classes for primary and foreign keys. In This Chapter Master-Detail Relationship Between Data with PXDBDefault and PXParentRelationship Between Data with PrimaryKeyOf and ForeignKeyOfSelection of the Linked Data Through the Current PropertyTo Define a Primary KeyTo Define a Foreign Key" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="a88592cb-6b00-74c1-45e0-3d13cd346521" RecordSourceID="22377" />
		<row PageID="a8c114c5-de91-41e8-906f-6d88f0842582" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="c7f1a794-ad1b-c802-a54f-1c00d8068077" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To set up the master-detail relationship between data access classes, you have to add two attributes, <tt>PXDBDefault</tt> and <tt>PXParent</tt>, to the DAC fields of the detail class. You can specify these attributes directly in the DAC or within a graph (in the <tt>CacheAttached</tt> event handler).{br}{TOC}[anchor|#section_f4r_3tg_nm]
==PXDBDefault==
The <tt>PXDBDefault</tt> attribute specifies the default value for a data field. You should use this attribute to insert the default value, which is the foreign key to the master DAC.{br}

<tt>PXDBDefault</tt> works similarly to <tt>PXDefault</tt> and obtains its value from the <tt>Current</tt> property of the <tt>PXCache</tt> object that holds data records of the specified class. However, the <tt>PXDBDefault</tt> attribute is specially intended to insert the default value that is the key to the parent record. Unlike <tt>PXDefault</tt>, the <tt>PXDBDefault</tt> attribute supports the identity key field of the master DAC and inserts the actual default value after the parent record is saved to the database.{br}

If you implement a master-detail relationship, you should use the <tt>PXDBDefault</tt> attribute to bind the detail data record fields (foreign key fields) to the master data record key fields. If the master data record is new and uses the identity key generated by the database, its key field will be set to a real value only when the master record is saved to the database. So if a detail data record is created before the master data record is saved for the first time, the detail data record field will be set to the temporary value of the master identity field. However, the <tt>PXDBDefault</tt> attribute will replace the temporary value with the actual one when the detail data record is saved to the database.{br}

As the following example code shows, in the {{SupplierProduct}} class, the <tt>PXDBDefault</tt> attribute obtains the default value for its {{SupplierID}} key field from the {{Supplier.SupplierID}} field of the current master record.<source lang="csharp">//SupplierProduct.SupplierID
...
[PXDBDefault(typeof(Supplier.supplierID))]
public virtual int? SupplierID
{...
}</source>[anchor|#pxparent]
==PXParent==
The <tt>PXParent</tt> attribute specifies the master-detail relationship between classes.((({S:Warn}If you calculate aggregate values by using the <tt>PXFormula</tt> or <tt>PXUnboundFormula</tt> attribute for the master DAC, you also have to add <tt>PXParent</tt> to one of the fields of the detail DAC. 
)))
We recommend that you add the <tt>PXParent</tt> attribute to the first foreign key field of the child DAC (although it is possible to add the attribute to any field). Because the attribute specifies the master-detail relationship between classes, it enables cascading deletion of the child records once a parent record is deleted.{br}

The parent data record is defined by the BQL <tt>Select&lt;&gt;</tt> statement specified in the attribute. Typically, the query includes a <tt>Where&lt;&gt;</tt> clause that adds conditions for the parent’s key fields to equal the child’s key fields. In this case, to specify the values of the key fields of the child data record, you use the <tt>Current</tt> parameter.{br}

In the following code example, <tt>PXParent</tt> specifies the current {{Supplier}} record as the parent for the {{SupplierProduct}} record. The <tt>PXParent</tt> attribute is added on the {{SupplierProduct.SupplierID}} field in the {{SupplierProduct}} DAC.<source lang="csharp">//SupplierProduct.SupplierID
...
[PXParent(
    typeof(SelectFrom&lt;Supplier&gt;.
               Where&lt;Supplier.supplierID.IsEqual&lt;SupplierProduct.supplierID.FromCurrent&gt;&gt;))]
public virtual int? SupplierID
{...
}</source>[anchor|#section_zs3_j5g_nm]
==Selection of the Master-Detail Data==
To select master-detail data, you define two data views in the graph (see the code below). In this code example, the master data view selects data records of the {{Supplier}} class, while the detail data view selects records of the {{SupplierProduct}} class. To select the details for a particular master record, you specify the master key field in the <tt>Current</tt> parameter of the data view type. In the <tt>Current</tt> parameter, Acumatica Framework inserts the value from the <tt>Current</tt> property of the <tt>PXCache</tt> object that works with the specified DAC.{br}

The order of data views in the graph defines the order of the insertion, update, and deletion of data records in the database. The framework inserts and updates data records in the order in which the data views are defined, and deletes the records in the reverse order. Thus, you have to define the master data view before the detail data view to enabledetails to be saved and deleted correctly. (The master data record is the first to be inserted in the database and the detail data records are the first to be deleted from the database.)<source lang="csharp">// Retrieves master records
public SelectFrom&lt;Supplier&gt;.View Suppliers;
// Retrieves detail records by the Supplier.SupplierID of the current master record
public SelectFrom&lt;SupplierProduct&gt;.
    LeftJoin&lt;Product&gt;.On&lt;Product.productID.IsEqual&lt;SupplierProduct.productID&gt;&gt;.
    Where&lt;SupplierProduct.supplierID.IsEqual&lt;Supplier.supplierID.FromCurrent&gt;&gt;.View
    SupplierProducts;</source>]]></column>
			<column name="PlainText"><![CDATA[Master-Detail Relationship Between Data with PXDBDefault and PXParent To set up the master-detail relationship between data access classes, you have to add two         attributes,  PXDBDefault  and  PXParent , to the DAC         fields of the detail class. You can specify these attributes directly in the DAC or within a         graph (in the  CacheAttached  event handler). PXDBDefault The  PXDBDefault  attribute specifies the default value for a data field.         You should use this attribute to insert the default value, which is the foreign key to the         master DAC. PXDBDefault  works similarly to  PXDefault  and obtains         its value from the  Current  property of the  PXCache          object that holds data records of the specified class. However, the            PXDBDefault  attribute is specially intended to insert the default value         that is the key to the parent record. Unlike  PXDefault , the            PXDBDefault  attribute supports the identity key field of the master DAC         and inserts the actual default value after the parent record is saved to the database. If you implement a master-detail relationship, you should use the            PXDBDefault  attribute to bind the detail data record fields (foreign         key fields) to the master data record key fields. If the master data record is new and uses         the identity key generated by the database, its key field will be set to a real value only         when the master record is saved to the database. So if a detail data record is created         before the master data record is saved for the first time, the detail data record field will         be set to the temporary value of the master identity field. However, the            PXDBDefault  attribute will replace the temporary value with the actual         one when the detail data record is saved to the database. As the following example code shows, in the  SupplierProduct  class, the            PXDBDefault  attribute obtains the default value for its            SupplierID  key field from the  Supplier.SupplierID  field         of the current master record. //SupplierProduct.SupplierID
...
[PXDBDefault(typeof(Supplier.supplierID))]
public virtual int? SupplierID
{...
} PXParent The  PXParent  attribute specifies the master-detail relationship between         classes. If you calculate aggregate values by using the  PXFormula  or            PXUnboundFormula  attribute for the master DAC, you also have to add            PXParent  to one of the fields of the detail DAC.  We recommend that you add the  PXParent  attribute to the first foreign         key field of the child DAC (although it is possible to add the attribute to any field).         Because the attribute specifies the master-detail relationship between classes, it enables         cascading deletion of the child records once a parent record is deleted. The parent data record is defined by the BQL  Select<>  statement         specified in the attribute. Typically, the query includes a  Where<>          clause that adds conditions for the parent’s key fields to equal the child’s key fields. In         this case, to specify the values of the key fields of the child data record, you use the            Current  parameter. In the following code example,  PXParent  specifies the current            Supplier  record as the parent for the  SupplierProduct          record. The  PXParent  attribute is added on the            SupplierProduct.SupplierID  field in the  SupplierProduct          DAC. //SupplierProduct.SupplierID
...
[PXParent(
    typeof(SelectFrom<Supplier>.
               Where<Supplier.supplierID.IsEqual<SupplierProduct.supplierID.FromCurrent>>))]
public virtual int? SupplierID
{...
} Selection of the Master-Detail Data To select master-detail data, you define two data views in the graph (see the code below).         In this code example, the master data view selects data records of the            Supplier  class, while the detail data view selects records of the            SupplierProduct  class. To select the details for a particular master         record, you specify the master key field in the  Current  parameter of the         data view type. In the  Current  parameter,  Acumatica Framework         inserts the value from the  Current  property of the            PXCache  object that works with the specified DAC. The order of data views in the graph defines the order of the insertion, update, and         deletion of data records in the database. The framework inserts and updates data records in         the order in which the data views are defined, and deletes the records in the reverse order.         Thus, you have to define the master data view before the detail data view to enabledetails         to be saved and deleted correctly. (The master data record is the first to be inserted in         the database and the detail data records are the first to be deleted from the database.) // Retrieves master records
public SelectFrom<Supplier>.View Suppliers;
// Retrieves detail records by the Supplier.SupplierID of the current master record
public SelectFrom<SupplierProduct>.
    LeftJoin<Product>.On<Product.productID.IsEqual<SupplierProduct.productID>>.
    Where<SupplierProduct.supplierID.IsEqual<Supplier.supplierID.FromCurrent>>.View
    SupplierProducts; ]]></column>
		</row>
		<row PageID="67621706-e4f4-4423-b90f-84b3b6b189c4" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2f2b7af5-1347-3fb0-d99c-efc8af87e73f" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To define a relationship between two tables, you need to define the primary keys of the parent and child tables. Also, in the child table, you need to define the foreign key that refers to the primary key of the parent table. [anchor|#_76d3ec82-5bea-412b-acd3-32e19c10bebf]{br}

In the code of an Acumatica Framework-based application, you can define the relationship between two tables as follows:[anchor|#_e85cfbcb-5d27-4cf3-a255-d333cbaab291]
*To define a primary key of a table, for the set of key fields of the data access class (DAC) that corresponds to the table, you set the <tt>IsKey</tt> property of the data type attribute to {{true}}. 
*To define a foreign key of a table, in the DAC that corresponds to the table, you mark the field that contains the foreign key with one of the following attributes: <tt>PXForeignReference</tt>, <tt>PXSelector</tt>, or <tt>PXParent</tt>. 
{br}

To select a record from the database by its primary or foreign key, you can use a <tt>Select</tt> statement in business query language (BQL) or use the methods of the attributes mentioned above. [anchor|#_bd9e84fa-daca-43ab-96ae-368797e500cf]{br}

Another way to define a relationship between two tables is to use the <tt>PrimaryKeyOf</tt> and <tt>ForeignKeyOf</tt> classes that are specially designed for the definition of primary and foreign keys. {br}

This approach, which is described in this topic, provides the following advantages:[anchor|#_0eff0f63-599c-475c-b497-f60ecad1352e]
*These classes provide static information that a compiler can use to identify errors in the code.
*You can use runtime information about primary keys to select records by their keys.
*These classes and methods have no other meanings and use cases; conversely, the <tt>PXForeignReference</tt>, <tt>PXSelector</tt>, and <tt>PXParent</tt> attributes can be used for other purposes.
*These classes and methods are optimized for the selection of records from the database; therefore, using them improves database access performance on record selection. 
{br}{TOC}
==Definition of a Primary Key==
You define a primary key of a DAC by using the <tt>PrimaryKeyOf&lt;Table&gt;.By&lt;keyFields&gt;</tt> class. With this class, you can define simple keys (with one key field) and compound keys (with up to five key fields). In the primary key definition, you have to define the {{public}}<tt>Find</tt> method, which calls the {{protected}}<tt>FindBy</tt> method. A definition of a compound key is shown in the following example.<source lang="csharp">using PX.Data.ReferentialIntegrity.Attributes;

public partial class SOLine : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf&lt;SOLine&gt;.By&lt;orderType, orderNbr, lineNbr&gt;
    {
        public static SOLine Find(
            PXGraph graph, string orderType, string orderNbr, int lineNbr) 
                =&gt; FindBy(graph, orderType, orderNbr, lineNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
    public abstract class lineNbr : PX.Data.IBqlField { }
}</source>[anchor|#_a65fe2e3-9eb0-4ffe-850d-b704d6111ac3]
==Definition of a Foreign Key==
You can define a foreign key based on the primary key of the referenced table, as shown in the following code.<source lang="csharp">//Definition of the primary key
public partial class SOOrder : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf&lt;SOOrder&gt;.By&lt;orderType, orderNbr&gt;
    {
        public static SOOrder Find(
            PXGraph graph, string orderType, string orderNbr) =&gt; 
            FindBy(graph, orderType, orderNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
} 

//Definition of the foreign key based on the primary key
public partial class SOLine : PX.Data.IBqlTable
{
    public class SOOrderFK : SOOrder.PK.ForeignKeyOf&lt;SOLine&gt;
        .By&lt;orderType, orderNbr&gt; { }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
}</source>
==Selection of a Record by Key Fields==
If a primary key is defined for a DAC, you can select a record by using the values of the key fields of the record, as shown in the following example.<source lang="csharp">SOLine line = SOLine.PK.Find(
    this, split.OrderType, split.OrderNbr, split.LineNbr.Value);</source>{br}

((({S:Warn}The <tt>Find</tt> method encapsulates a {{PXSelectReadonly<Table, Where<...>>.SelectWindowed(graph, 0, 1, keys)}} call. Therefore, the code above can replace the following code written using BQL.<source lang="csharp">SOLine line = PXSelectReadonly&lt;SOLine,
    Where&lt;SOLine.orderType, Equal&lt;Required&lt;SOLine.orderType&gt;&gt;,
        And&lt;SOLine.orderNbr, Equal&lt;Required&lt;SOLine.orderNbr&gt;&gt;,
        And&lt;SOLine.lineNbr, Equal&lt;Required&lt;SOLine.lineNbr&gt;&gt;&gt;&gt;&gt;
    &gt;.Select(this, split.OrderType, split.OrderNbr, split.LineNbr);</source>
)))You can also select a record by using a record of the same type with the key fields specified, as shown in the following example.<source lang="csharp">InventoryItem actualItem = InventoryItem.PK.Find(this, notActualItem);</source>{br}

If a foreign key is defined for a DAC, you can select the parent and child records, as shown in the following code.<source lang="csharp">//Selection of the parent record
SOOrder order = SOLine.SOOrderFK.FindParent(this, soLine);
//Selection of the child records
IEnumerable&lt;SOLine&gt; lines = SOLine.SOOrderFK.SelectChildren(this, soOrder);</source>
==Use of Primary and Foreign Keys in Attributes==
You can use static foreign keys, defined as described in [[#_a65fe2e3-9eb0-4ffe-850d-b704d6111ac3|Definition of a Foreign Key], for the configuration of the <tt>PXForeignReference</tt> and <tt>PXParent</tt> attributes, as shown in the following example.<source lang="csharp">public partial class SOLine : PX.Data.IBqlTable
{
    public class SOOrderFK : SOOrder.PK.ForeignKeyOf&lt;SOLine&gt;
        .By&lt;orderType, orderNbr&gt; { }
    public class InventoryFK : InventoryItem.PK.ForeignKeyOf&lt;SOLine&gt;
        .By&lt;inventoryID&gt; { }

    public abstract class orderType : PX.Data.IBqlField { }

    [...]
    [PXParent(typeof(SOOrderFK))]
    public virtual String OrderNbr { get; set; }
    public abstract class orderNbr : PX.Data.IBqlField { }

    [...]
    [PXForeignReference(typeof(InventoryFK))]
    public virtual Int32? InventoryID { get; set; }
    public abstract class inventoryID : PX.Data.IBqlField { }
}</source>{br}

Because all primary keys, which are defined as described in this topic, implement the <tt>IPrimaryKey</tt> interface, you can use primary and foreign keys in the scope of custom attributes, as shown in the following example.{{{{public class SomeAttribute : PXEventSubscriberAttribute, ...
{
    private readonly IPrimaryKey _pk;
    public SomeAttribute(Type pkType)
    {
        _pk = (IPrimaryKey)Activator.CreateInstance(pkType);
    }

    public void SomeHandler(PXCache cache, PXSomeEventArgs e)
    {
        IBqlTable row = _pk.Find(cache.Graph, e.NewValue);
        ...
        _pk.StoreCached(cache.graph, row);
        ...
        row = _pk.Find(cache.Graph, row);
    }
}
}}}}
==Related Articles==
*[HelpRoot_Dev_Platform\AD__how_Define_Primary_Key|To Define a Primary Key]
*[HelpRoot_Dev_Platform\AD__how_Define_Foreign_Key|To Define a Foreign Key]]]></column>
			<column name="PlainText"><![CDATA[Relationship Between Data with PrimaryKeyOf and ForeignKeyOf To define a relationship between two tables, you need to define the primary keys of                 the parent and child tables. Also, in the child table, you need to define the                 foreign key that refers to the primary key of the parent table.  In the code of an  Acumatica Framework-based application, you can define the relationship between two tables as follows: To define a primary key of a table, for the set of key fields of the data access class (DAC) that corresponds to the table, you set the  IsKey  property of the data type attribute to  true .  To define a foreign key of a table, in the DAC that corresponds to the table, you mark the field that contains the foreign key with one of the following attributes:  PXForeignReference ,  PXSelector , or  PXParent .  To select a record from the database by its primary or foreign key, you can use a                      Select  statement in business query language (BQL) or use the                 methods of the attributes mentioned above.  Another way to define a relationship between two             tables is to use the  PrimaryKeyOf  and  ForeignKeyOf              classes that are specially designed for the definition of primary and foreign keys.  This approach, which is described in this topic, provides the following                 advantages: These classes provide static information that a compiler can use to identify                     errors in the code. You can use runtime information about primary keys to select records by their                     keys. These classes and methods have no other meanings and use cases; conversely, the                          PXForeignReference ,  PXSelector , and                          PXParent  attributes can be used for other purposes. These classes and methods are optimized for the selection of records from the                     database; therefore, using them improves database access performance on record                     selection.  Definition of a Primary Key You define a primary key of a DAC by using the                      PrimaryKeyOf<Table>.By<keyFields>  class. With                 this class, you can define simple keys (with one key field) and compound keys (with                 up to five key fields). In the primary key definition, you have to define the                      public Find  method, which calls the  protected FindBy  method. A definition of a compound key is shown in the                 following                 example. using PX.Data.ReferentialIntegrity.Attributes;

public partial class SOLine : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf<SOLine>.By<orderType, orderNbr, lineNbr>
    {
        public static SOLine Find(
            PXGraph graph, string orderType, string orderNbr, int lineNbr) 
                => FindBy(graph, orderType, orderNbr, lineNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
    public abstract class lineNbr : PX.Data.IBqlField { }
} Definition of a Foreign Key You can define a foreign key based on the primary key of the referenced table, as shown in the                 following                 code. //Definition of the primary key
public partial class SOOrder : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf<SOOrder>.By<orderType, orderNbr>
    {
        public static SOOrder Find(
            PXGraph graph, string orderType, string orderNbr) => 
            FindBy(graph, orderType, orderNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
} 

//Definition of the foreign key based on the primary key
public partial class SOLine : PX.Data.IBqlTable
{
    public class SOOrderFK : SOOrder.PK.ForeignKeyOf<SOLine>
        .By<orderType, orderNbr> { }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
} Selection of a Record by Key Fields If a primary key is defined for a DAC, you can select a record by using the values of the key                 fields of the record, as shown in the following                 example. SOLine line = SOLine.PK.Find(
    this, split.OrderType, split.OrderNbr, split.LineNbr.Value); The  Find  method encapsulates a  PXSelectReadonly<Table,                         Where<...>>.SelectWindowed(graph, 0, 1, keys)  call.                     Therefore, the code above can replace the following code written using                     BQL. SOLine line = PXSelectReadonly<SOLine,
    Where<SOLine.orderType, Equal<Required<SOLine.orderType>>,
        And<SOLine.orderNbr, Equal<Required<SOLine.orderNbr>>,
        And<SOLine.lineNbr, Equal<Required<SOLine.lineNbr>>>>>
    >.Select(this, split.OrderType, split.OrderNbr, split.LineNbr); You                 can also select a record by using a record of the same type with the key fields                 specified, as shown in the following                 example. InventoryItem actualItem = InventoryItem.PK.Find(this, notActualItem); If a foreign key is defined for a DAC, you can select the parent and child records, as shown                 in the following                 code. //Selection of the parent record
SOOrder order = SOLine.SOOrderFK.FindParent(this, soLine);
//Selection of the child records
IEnumerable<SOLine> lines = SOLine.SOOrderFK.SelectChildren(this, soOrder); Use of Primary and Foreign Keys in Attributes You can use static foreign keys, defined as described in  Definition of a Foreign Key Definition of a Foreign Key, for the configuration of the                      PXForeignReference  and  PXParent                  attributes, as shown in the following                 example. public partial class SOLine : PX.Data.IBqlTable
{
    public class SOOrderFK : SOOrder.PK.ForeignKeyOf<SOLine>
        .By<orderType, orderNbr> { }
    public class InventoryFK : InventoryItem.PK.ForeignKeyOf<SOLine>
        .By<inventoryID> { }

    public abstract class orderType : PX.Data.IBqlField { }

    [...]
    [PXParent(typeof(SOOrderFK))]
    public virtual String OrderNbr { get; set; }
    public abstract class orderNbr : PX.Data.IBqlField { }

    [...]
    [PXForeignReference(typeof(InventoryFK))]
    public virtual Int32? InventoryID { get; set; }
    public abstract class inventoryID : PX.Data.IBqlField { }
} Because all primary keys, which are defined as described in this topic, implement the                      IPrimaryKey  interface, you can use primary and foreign keys                 in the scope of custom attributes, as shown in the following                 example. public class SomeAttribute : PXEventSubscriberAttribute, ...
{
    private readonly IPrimaryKey _pk;
    public SomeAttribute(Type pkType)
    {
        _pk = (IPrimaryKey)Activator.CreateInstance(pkType);
    }

    public void SomeHandler(PXCache cache, PXSomeEventArgs e)
    {
        IBqlTable row = _pk.Find(cache.Graph, e.NewValue);
        ...
        _pk.StoreCached(cache.graph, row);
        ...
        row = _pk.Find(cache.Graph, row);
    }
} ]]></column>
		</row>
		<row PageID="3ee067a4-f1f5-4f47-a418-7c4d19091f2b" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="30c81b5a-9d58-867f-c3ce-bf6a6d164c00" RecordSourceID="22377">
			<column name="Content"><![CDATA[
A <tt>PXCache</tt> object has the <tt>Current</tt> property, which is set to the last data record that has been retrieved from the database or inserted or updated in the cache. The <tt>Current</tt> property is often used to select linked data, such as the detail data, by the specified master record key.{br}

BQL includes an operand that you can use to insert the values of the <tt>Current</tt> data record into a BQL query. In the code below, the <tt>Current</tt> property is used in data views to select and retrieve linked data. The {{Suppliers}} and {{SelectedSupplier}} data views retrieve records from the same <tt>PXCache</tt> object, because they have the same main DAC. The {{SupplierProducts}} data view retrieves records of the {{SupplierProduct}} class that have the specified {{SupplierID}}. The {{SupplierID}} is retrieved from the <tt>Current</tt> property of the <tt>PXCache</tt> object for {{Supplier}}.<source lang="csharp">public SelectFrom&lt;Supplier&gt;.View Suppliers;
// Retrieves the same record that is current in the PXCache object for Supplier
public SelectFrom&lt;Supplier&gt;.
    Where&lt;Supplier.supplierID.IsEqual&lt;Supplier.supplierID.FromCurrent&gt;&gt;.View
    SelectedSupplier;
// Retrieves the detail records by the specified SupplierID
public SelectFrom&lt;SupplierProduct&gt;.
    LeftJoin&lt;Product&gt;.On&lt;Product.productID.IsEqual&lt;SupplierProduct.productID&gt;&gt;.
    Where&lt;SupplierProduct.supplierID.IsEqual&lt;Supplier.supplierID.FromCurrent&gt;&gt;.View
    SupplierProducts;</source>{br}{TOC}[anchor|#section_amr_wtd_hm]
==Getting the Current Data Record==
The framework automatically assigns the <tt>Current</tt> property to the following records:[anchor|#ul_h35_l1w_cm]
*Each data record retrieved from the database and displayed in the UI (or requested by the web services APIs)
*The last modified data record that has been inserted or updated from the UI, after the updated data is posted to the server
*The last modified data record that has been inserted or updated from code, after you invoke the <tt>Insert()</tt> or <tt>Update()</tt> method on the cache object

The <tt>Current</tt> property returns the object of the main DAC type of the data view. The <tt>Current</tt> property of the data view and the <tt>Current</tt> property of the <tt>Cache</tt> object of the data view return the same record (see the following code).<source lang="csharp">// Get a Shipment object through the data view
Shipment shipment = Shipments.Current;
// Get a Shipment object through the PXCache object
Shipment currentShipment = (Shipment)Shipments.Cache.Current;</source>((({S:Warn}After you create a graph instance in the code, the <tt>Current</tt> property of all cache objects of the graph returns null.
)))
You can get a value from the current data record and specify it as a BQL parameter in a data view type or in an attribute of a DAC field. In the following code, a DAC field is specified in the <tt>Current</tt> parameter of the BQL statement in a data view.<source lang="csharp">// Select shipment lines through the data view
// where shipmentNbr equals the number of the current shipment
public SelectFrom&lt;ShipmentLine&gt;.
    Where&lt;ShipmentLine.shipmentNbr.IsEqual&lt;Shipment.shipmentNbr.FromCurrent&gt;&gt;.
    OrderBy&lt;ShipmentLine.gift.Desc&gt;.View ShipmentLines;</source>[anchor|#section_yzj_ytd_hm]
==Setting the Current Data Record==
You can set the <tt>Current</tt> property of a data record of the type the <tt>PXCache</tt> object works with. When you assign the <tt>Current</tt> property of a <tt>PXCache&lt;&gt;</tt> object, you should select a data record from the database by using DAC key field values. If a data record with these key field values exists in the database, the <tt>Current</tt> property is assigned to the retrieved record. If no such data record exists in the database, the property is set to {{null}}. Setting the <tt>Current</tt> property gives you the ability to do the following:[anchor|#ul_fmr_ttd_hm]
*Process multiple data records by using a graph
*Open a form displaying the specified data record when you redirect to the form from another one

We don&rsquo;t recommend that you set the <tt>Current</tt> property in other cases, such as in event handlers, because doing this may cause the application to work incorrectly.((({S:Warn}The assignment of the <tt>Current</tt> property raises the <tt>RowSelected</tt> event for the current data record.
)))
You must use the <tt>Search&lt;&gt;()</tt> generic method of a data view object to retrieve a record from the database and assign the retrieved record to the <tt>Current</tt> property, as the following code shows.<source lang="csharp">//The data view works with the PXCache object that holds SalesOrder data records
public SelectFrom&lt;SalesOrder&gt;.OrderBy&lt;SalesOrder.orderNbr.Asc&gt;.View Orders;
...
//To search for the record in the database, 
//you can use the generic Search&lt;&gt; method of the data view
graph.Orders.Current = graph.Orders.Search&lt;SalesOrder.orderNbr&gt;(order.OrderNbr);</source>]]></column>
			<column name="PlainText"><![CDATA[Selection of the Linked Data Through the Current Property A  PXCache  object has the  Current  property, which is         set to the last data record that has been retrieved from the database or inserted or updated         in the cache. The  Current  property is often used to select linked data,         such as the detail data, by the specified master record key. BQL includes an operand that you can use to insert the values of the            Current  data record into a BQL query. In the code below, the            Current  property is used in data views to select and retrieve linked         data. The  Suppliers  and  SelectedSupplier  data views         retrieve records from the same  PXCache  object, because they have the same         main DAC. The  SupplierProducts  data view retrieves records of the            SupplierProduct  class that have the specified          SupplierID . The  SupplierID  is retrieved from the            Current  property of the  PXCache  object for            Supplier . public SelectFrom<Supplier>.View Suppliers;
// Retrieves the same record that is current in the PXCache object for Supplier
public SelectFrom<Supplier>.
    Where<Supplier.supplierID.IsEqual<Supplier.supplierID.FromCurrent>>.View
    SelectedSupplier;
// Retrieves the detail records by the specified SupplierID
public SelectFrom<SupplierProduct>.
    LeftJoin<Product>.On<Product.productID.IsEqual<SupplierProduct.productID>>.
    Where<SupplierProduct.supplierID.IsEqual<Supplier.supplierID.FromCurrent>>.View
    SupplierProducts; Getting the Current Data Record The framework automatically assigns the  Current  property to the         following records: Each data record retrieved from the database and displayed in the UI (or requested by           the web services APIs) The last modified data record that has been inserted or updated from the UI, after the           updated data is posted to the server The last modified data record that has been inserted or updated from code, after you           invoke the  Insert()  or  Update()  method on the cache           object The  Current  property returns the object of the main DAC type of the data         view. The  Current  property of the data view and the            Current  property of the  Cache  object of the data         view return the same record (see the following code). // Get a Shipment object through the data view
Shipment shipment = Shipments.Current;
// Get a Shipment object through the PXCache object
Shipment currentShipment = (Shipment)Shipments.Cache.Current; After you create a graph instance in the code, the  Current  property         of all cache objects of the graph returns null. You can get a value from the current data record and specify it as a BQL parameter in a         data view type or in an attribute of a DAC field. In the following code, a DAC field is         specified in the  Current  parameter of the BQL statement in a data         view. // Select shipment lines through the data view
// where shipmentNbr equals the number of the current shipment
public SelectFrom<ShipmentLine>.
    Where<ShipmentLine.shipmentNbr.IsEqual<Shipment.shipmentNbr.FromCurrent>>.
    OrderBy<ShipmentLine.gift.Desc>.View ShipmentLines; Setting the Current Data Record You can set the  Current  property of a data record of the type the            PXCache  object works with. When you assign the            Current  property of a  PXCache<>  object, you         should select a data record from the database by using DAC key field values. If a data         record with these key field values exists in the database, the  Current          property is assigned to the retrieved record. If no such data record exists in the database,         the property is set to  null . Setting the  Current          property gives you the ability to do the following: Process multiple data records by using a graph Open a form displaying the specified data record when you redirect to the form from           another one We don't recommend that you set the  Current  property in other cases,         such as in event handlers, because doing this may cause the application to work         incorrectly. The assignment of the  Current  property raises the            RowSelected  event for the current data record. You must use the  Search<>()  generic method of a data view object to         retrieve a record from the database and assign the retrieved record to the            Current  property, as the following code shows. //The data view works with the PXCache object that holds SalesOrder data records
public SelectFrom<SalesOrder>.OrderBy<SalesOrder.orderNbr.Asc>.View Orders;
...
//To search for the record in the database, 
//you can use the generic Search<> method of the data view
graph.Orders.Current = graph.Orders.Search<SalesOrder.orderNbr>(order.OrderNbr); ]]></column>
		</row>
		<row PageID="34e875c7-a5c3-496e-9e2b-f7f6f9f20a40" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="dc7469c1-5a1c-eb4d-b8fb-33c22aaf5f4a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can define the primary key of a data access class (DAC) by using the <tt>PrimaryKeyOf&lt;Table&gt;.By&lt;keyFields&gt;</tt> class. With this class, you can define simple keys (with one key field) and compound keys (with up to five key fields) and select records by using these keys, as described in this topic.{br}{TOC}
==To Define a Simple Primary Key and Select a Record by This Key==[anchor|#_528f727b-2037-4948-bde0-b418c0fb28a2]
#In the DAC, declare a <tt>PrimaryKeyOf&lt;Table&gt;</tt> <tt>.By&lt;keyFields&gt;</tt> descendant with the {{public}}<tt>Find</tt> method, which calls the {{protected}}<tt>FindBy</tt> method, as shown in the following code.<source lang="csharp">using PX.Data.ReferentialIntegrity.Attributes;

public partial class InventoryItem : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf&lt;InventoryItem&gt;.By&lt;inventoryID&gt;
    {
        public static InventoryItem Find(PXGraph graph, int inventoryID) 
          =&gt; FindBy(graph, inventoryID);
    }

    public abstract class inventoryID : PX.Data.IBqlField { }
}</source>
#Use the primary key to select a record, as shown in the following code.<source lang="csharp">InventoryItem item = InventoryItem.PK.Find(this, soLine.InventoryID.Value);</source>

==To Define a Compound Primary Key and Select a Record by This Key==[anchor|#_ea6e3b92-93f2-4f77-b340-2a820e18a94f]
#In the data access class (DAC), declare a <tt>PrimaryKeyOf&lt;Table&gt;</tt> <tt>.By&lt;keyFields&gt;</tt> descendant with the {{public}}<tt>Find</tt> method, which has the needed number (up to five) of key fields. The <tt>Find</tt> method must call the {{protected}}<tt>FindBy</tt> method with the same number of key fields, as shown in the following code.<source lang="csharp">using PX.Data.ReferentialIntegrity.Attributes;

public partial class SOLine : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf&lt;SOLine&gt;
        .By&lt;orderType, orderNbr, lineNbr&gt;
    {
        public static SOLine Find(
            PXGraph graph, string orderType, string orderNbr, int lineNbr) 
                =&gt; FindBy(graph, orderType, orderNbr, lineNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
    public abstract class lineNbr : PX.Data.IBqlField { }
}</source>
#Use the compound primary key to select a record, as shown in the following code.<source lang="csharp">SOLine line = SOLine.PK.Find(
    this, split.OrderType, split.OrderNbr, split.LineNbr.Value);</source>

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_PK_and_FK_API|Relationship Between Data with PrimaryKeyOf and ForeignKeyOf]]]></column>
			<column name="PlainText"><![CDATA[To Define a Primary Key You can define the primary key of a data access class (DAC) by using the                      PrimaryKeyOf<Table>.By<keyFields>  class. With                 this class, you can define simple keys (with one key field) and compound keys (with                 up to five key fields) and select records by using these keys, as described in this                 topic. To Define a Simple Primary Key and Select a Record by This Key In the DAC, declare a                          PrimaryKeyOf<Table> .By<keyFields>                      descendant with the  public Find  method, which calls the  protected FindBy  method, as shown in the following                     code. using PX.Data.ReferentialIntegrity.Attributes;

public partial class InventoryItem : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf<InventoryItem>.By<inventoryID>
    {
        public static InventoryItem Find(PXGraph graph, int inventoryID) 
          => FindBy(graph, inventoryID);
    }

    public abstract class inventoryID : PX.Data.IBqlField { }
} Use the primary key to select a record, as shown in the following                     code. InventoryItem item = InventoryItem.PK.Find(this, soLine.InventoryID.Value); To Define a Compound Primary Key and Select a Record by This Key In the data access class (DAC), declare a                          PrimaryKeyOf<Table> .By<keyFields>                      descendant with the  public Find  method, which has the needed number (up to five) of key                     fields. The  Find  method must call the                          protected FindBy  method with the same number of key fields, as shown in                     the following                     code. using PX.Data.ReferentialIntegrity.Attributes;

public partial class SOLine : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf<SOLine>
        .By<orderType, orderNbr, lineNbr>
    {
        public static SOLine Find(
            PXGraph graph, string orderType, string orderNbr, int lineNbr) 
                => FindBy(graph, orderType, orderNbr, lineNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
    public abstract class lineNbr : PX.Data.IBqlField { }
} Use the compound primary key to select a record, as shown in the following                     code. SOLine line = SOLine.PK.Find(
    this, split.OrderType, split.OrderNbr, split.LineNbr.Value); ]]></column>
		</row>
		<row PageID="20b9a017-ff40-42b7-843c-94f2fced764e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e2da509a-0240-ca34-2133-6ecb33d67eb4" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can define a foreign key based on the primary key of the parent data access class (DAC) and select records by this key, as described in this topic.
==To Define a Foreign Key and Use It to Select Records==[anchor|#_c0f37de8-cbde-4a87-826e-5b150e7a712b]
#In the DAC of the parent table, define the primary key, as described in [HelpRoot_Dev_Platform\AD__how_Define_Primary_Key|To Define a Primary Key]. The following code shows an example of the definition of the primary key that is used in the following code examples in this instruction.<source lang="csharp">public partial class SOOrder : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf&lt;SOOrder&gt;.By&lt;orderType, orderNbr&gt;
    {
        public static SOOrder Find(
            PXGraph graph, string orderType, string orderNbr) 
            =&gt; FindBy(graph, orderType, orderNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
} </source>
#In the DAC of the child table, define the foreign key based on the primary key of the parent table, as shown below.<source lang="csharp">public partial class SOLine : PX.Data.IBqlTable
{
    public class SOOrderFK : SOOrder.PK.ForeignKeyOf&lt;SOLine&gt;
        .By&lt;orderType, orderNbr&gt; { }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
}</source>
#Use the foreign key to select the parent record or child records, as shown in the following code.<source lang="csharp">//Select the parent record
SOOrder order = SOLine.SOOrderFK.FindParent(this, soLine);
//Select the child records
IEnumerable&lt;SOLine&gt; lines = SOLine.SOOrderFK.SelectChildren(this, soOrder);</source>

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_PK_and_FK_API|Relationship Between Data with PrimaryKeyOf and ForeignKeyOf]]]></column>
			<column name="PlainText"><![CDATA[To Define a Foreign Key You can define a foreign key based on the primary key of the parent data access class                 (DAC) and select records by this key, as described in this topic. To Define a Foreign Key and Use It to Select Records In the DAC of the parent table, define the primary key, as described in  To Define a Primary Key. The following code shows an example of the definition of the primary key                     that is used in the following code examples in this                     instruction. public partial class SOOrder : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf<SOOrder>.By<orderType, orderNbr>
    {
        public static SOOrder Find(
            PXGraph graph, string orderType, string orderNbr) 
            => FindBy(graph, orderType, orderNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
}  In the DAC of the child table, define the foreign key based on the primary key                     of the parent table, as shown                     below. public partial class SOLine : PX.Data.IBqlTable
{
    public class SOOrderFK : SOOrder.PK.ForeignKeyOf<SOLine>
        .By<orderType, orderNbr> { }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
} Use the foreign key to select the parent record or child records, as shown in                     the following                     code. //Select the parent record
SOOrder order = SOLine.SOOrderFK.FindParent(this, soLine);
//Select the child records
IEnumerable<SOLine> lines = SOLine.SOOrderFK.SelectChildren(this, soOrder); ]]></column>
		</row>
		<row PageID="3ae29586-f0b3-4d86-a0c2-86ed55c4ce54" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can learn how to store graph data in the session and use slots to cache data objects.&#xA;==In This Chapter==[anchor|#_85df8233-e963-40e5-86fe-8f6433e4838b]&#xA;*[HelpRoot_Dev_Platform\AD__con_ModifyData|Modification of Data in a PXCache Object]&#xA;*[HelpRoot_Dev_Platform\AD__con_Session|Session]&#xA;*[HelpRoot_Dev_Platform\AD__con_Session_Sharing|Session Sharing Between Application Servers]&#xA;*[HelpRoot_Dev_Platform\AD__con_Storing_In_Session|Storing of Graph Data in the Session]&#xA;*[HelpRoot_Dev_Platform\AD__con_Using_Slots_to_Cache_Data|Use of Slots to Cache Data Objects]&#xA;" PlainText="Working with Data in Cache and Session In this chapter, you can learn how to store graph data in the session and use slots to cache     data objects. In This Chapter Modification of Data in a PXCache ObjectSessionSession Sharing Between Application ServersStoring of Graph Data in the SessionUse of Slots to Cache Data Objects" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="cb64541b-a218-e5fa-ac97-d6679dade211" RecordSourceID="22377" />
		<row PageID="7098eac5-90f1-4043-aaaf-c64cb2bc95e5" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8988f9db-b854-13e2-96e0-5a5537bee3c2" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To modify data from code, you can use the following methods of a <tt>PXCache</tt> object:[anchor|#ul_mgw_l1v_lm]
*<tt>Insert()</tt> and <tt>Insert(object)</tt>
* <tt>Update(object)</tt>
* <tt>Delete(object)</tt>

For <tt>Insert(object)</tt>, Acumatica Framework checks whether a data record with the specified key values already exists in the cache object. If the record exists, nothing is inserted into the cache, and the existing record isn&rsquo;t modified in the cache; that is, the <tt>Insert(...)</tt> method returns <tt>null</tt>. If the record does not exist, the new record is inserted into the cache object; the method returns the new data record.{br}

On <tt>Update(object)</tt>, the framework checks whether a data record with such key values already exists in the cache object. If the record exists, it is updated. If the record doesn&rsquo;t exist in the cache, the framework retrieves the record with such keys from the database and places it into the cache. If there is no such record in the database, the framework invokes <tt>Insert()</tt> for the record. {br}

On <tt>Delete(object)</tt>, the framework sets the <tt>Deleted</tt> status for the record if it exists in the cache object. It does this in three steps. First, the framework checks whether a data record with the key values of the provided object already exists in the cache. If the record doesn&rsquo;t exist in the cache, the framework retrieves the record with these keys from the database. If the record exists in the cache or in the database, the framework sets its status within the cache to <tt>Deleted</tt>. The record isn&rsquo;t removed from the cache object.{br}

The modified records remain in the cache object until the <tt>Persist()</tt> method of the graph is invoked, or until the <tt>Cache.Clear()</tt> method of the data view is invoked, which removes all records from the cache object. You can remove all records from all cache objects of the graph by invoking the <tt>Clear()</tt> method of the graph object.{br}{TOC}[anchor|#section_vbk_5lw_lm]
==Understanding the Statuses of Data Records in a <tt>PXCache</tt>==
For each of the data modification methods, the framework raises the corresponding sequence of events and changes the status of the record in the cache object as shown in the diagram below. Once it is retrieved from the database, a record has the <tt>Notchanged</tt> status until it is modified. An inserted record maintains the <tt>Inserted</tt> status even if it is updated. When the inserted record is deleted, it is assigned the specific <tt>InsertedDeleted</tt> status. If you want to make sure that a record has been marked as deleted within the current session, you have to check the record for both the <tt>Deleted</tt> status and the <tt>InsertedDeleted</tt> status. To obtain the status of the record, invoke the <tt>GetStatus()</tt> method of the cache object for the needed DAC object. The status of the record is one of the following values of the <tt>PXEntryStatus</tt> enumeration:[anchor|#ul_rwh_hyv_lm]
*<tt>Notchanged</tt>
* <tt>Updated</tt>
* <tt>Inserted</tt>
* <tt>Deleted</tt>
* <tt>InsertedDeleted</tt>
[anchor|#image_slc_wwv_lm][image:StudioDeveloperGuide/Images/DataRecord_Statuses1.png|popup|Transitions between statuses of records|350px]
You can obtain the modified records from the collections of the <tt>PXCache</tt> object that correspond to the type of modification, as follows:[anchor|#ul_o2x_wqv_lm]
*<tt>Cache.Inserted</tt>, which retrieves data records that have the <tt>Inserted</tt> status
*<tt>Cache.Updated</tt>, which retrieves data records that have the <tt>Updated</tt> status
*<tt>Cache.Deleted</tt>, which retrieves data records that have the <tt>Deleted</tt> status.
*:((({S:Warn}The <tt>Cache.Dirty</tt> collection is used to retrieve all data records that have the <tt>Inserted</tt>, <tt>Updated</tt>, or <tt>Deleted</tt> status.
)))

Records that have other statuses (such as <tt>InsertedDeleted</tt>) aren&rsquo;t retrieved by these collections. For more information on these statuses, see [https://help.acumatica.com/(W(69))/Help?ScreenId=ShowWiki&pageid=aaba0ab0-9fd1-2364-b85f-f4ccc834f33a|PXCache&lt;TNode&gt; Class] in the API Reference.((({S:Warn}We don&rsquo;t recommend that you iterate through the <tt>Cached</tt> collection. For performance optimization, this collection may not retrieve all available data records.
)))[anchor|#section_zvd_xlw_lm]
==Updating a Data Record in a <tt>PXCache</tt>==
The framework raises the applicable events and updates the status of the record in the following cases as described:[anchor|#ul_lbp_jmw_lm]
*When you invoke the <tt>Insert()</tt>, <tt>Update()</tt>, or <tt>Delete()</tt> method of a <tt>PXCache</tt> object, the framework raises field-level events for each field when the <tt>Insert()</tt> or <tt>Update()</tt> method is invoked, and for only key fields when the <tt>Delete()</tt> method is invoked; the framework then raises all row-level events for the data record.<source lang="csharp">document.DocNbr = lastNumber;
Documents.Update(document);</source>
*When you invoke the <tt>SetValueExt&lt;Field&gt;()</tt> method of a cache object, the framework raises field-level events for the specified field only. The framework doesn&rsquo;t invoke row-level events and doesn&rsquo;t update the status of the record. You can update the status of the record manually by invoking the <tt>SetStatus()</tt> method of the cache. However, you should be careful with skipped field-level and row-level events because changing the status manually may cause missing logic and incorrect data update.{{{{view.Cache.SetValueExt&lt;Document.docNbr&gt;(row, lastNumber);
}}}}

The framework neither raises any event nor updates the status of the record in the following cases:[anchor|#ul_k2f_d4w_lm]
*If you assign a new value to a field without invoking <tt>Update()</tt><source lang="csharp">document.DocNbr = lastNumber;</source>
*If you assign a new value to a field by invoking the <tt>SetValue&lt;Field&gt;()</tt> method of the cache object<source lang="csharp">view.Cache.SetValue(row, LastNumberField.Name, lastNumber);</source>
[anchor|#section_zgd_zlw_lm]
==Searching for a Data Record in a <tt>PXCache</tt>==
Searching for a data record in the cache is helpful when you want to check whether the data record has already been modified during the current user session. To search for a data record, you can use the <tt>Locate()</tt> method, which returns the data record if it exists in the <tt>PXCache</tt> object. The <tt>Locate()</tt> method searches for the record by key values. If the record doesn&rsquo;t exist, the method returns null. No query is executed to the database in the <tt>Locate()</tt> method.<source lang="csharp">Account account = Accounts.Locate(record);</source>[anchor|#section_ubj_1mw_lm]
==Invoking <tt>PXCache</tt> Methods==
You can invoke data modification methods on a <tt>PXCache</tt> object through a data view. The methods are invoked on the <tt>PXCache</tt> object of the first DAC specified in the data view type (main DAC of the data view). The following code shows equivalent invocations of the <tt>Insert()</tt> method on the <tt>PXCache</tt> object that stores {{ShipmentLine}} data records in a graph.<source lang="csharp">// ShipmentLines is a data view of the PXSelectBase&lt;ShipmentLine&gt; type
// defined in the graph.
// ShipmentLine is the main DAC of the ShipmentLines data view.

// Invocation through the data view
<b>ShipmentLines.Insert(line);<b>
// Invocation directly through the PXCache
<b>ShipmentLines.Cache.Insert(line);<b></source>]]></column>
			<column name="PlainText"><![CDATA[Modification of Data in a PXCache Object To modify data from code, you can use the following methods of a  PXCache          object: Insert()  and  Insert(object) Update(object) Delete(object) For  Insert(object) ,  Acumatica Framework         checks whether a data record with the specified key values already exists in the cache         object. If the record exists, nothing is inserted into the cache, and the existing record         isn't modified in the cache; that is, the  Insert(...)  method returns            null . If the record does not exist, the new record is inserted into the         cache object; the method returns the new data record. On  Update(object) , the framework checks whether a data record with such         key values already exists in the cache object. If the record exists, it is updated. If the         record doesn't exist in the cache, the framework retrieves the record with such keys from         the database and places it into the cache. If there is no such record in the database, the         framework invokes  Insert()  for the record.  On  Delete(object) , the framework sets the  Deleted          status for the record if it exists in the cache object. It does this in three steps. First,         the framework checks whether a data record with the key values of the provided object         already exists in the cache. If the record doesn't exist in the cache, the framework         retrieves the record with these keys from the database. If the record exists in the cache or         in the database, the framework sets its status within the cache to            Deleted . The record isn't removed from the cache object. The modified records remain in the cache object until the  Persist()          method of the graph is invoked, or until the  Cache.Clear()  method of the         data view is invoked, which removes all records from the cache object. You can remove all         records from all cache objects of the graph by invoking the  Clear()          method of the graph object. Understanding the Statuses of Data Records in a  PXCache For each of the data modification methods, the framework raises the corresponding sequence         of events and changes the status of the record in the cache object as shown in the diagram         below. Once it is retrieved from the database, a record has the            Notchanged  status until it is modified. An inserted record maintains         the  Inserted  status even if it is updated. When the inserted record is         deleted, it is assigned the specific  InsertedDeleted  status. If you want         to make sure that a record has been marked as deleted within the current session, you have         to check the record for both the  Deleted  status and the            InsertedDeleted  status. To obtain the status of the record, invoke the            GetStatus()  method of the cache object for the needed DAC object. The         status of the record is one of the following values of the  PXEntryStatus          enumeration: Notchanged Updated Inserted Deleted InsertedDeleted Transitions between statuses of records You can obtain the modified records from the collections of the  PXCache          object that correspond to the type of modification, as follows: Cache.Inserted , which retrieves data records that have the              Inserted  status Cache.Updated , which retrieves data records that have the              Updated  status Cache.Deleted , which retrieves data records that have the              Deleted  status. The  Cache.Dirty  collection is             used to retrieve all data records that have the  Inserted ,                Updated , or  Deleted  status. Records that have other statuses (such as  InsertedDeleted ) aren't         retrieved by these collections. For more information on these statuses, see  PXCache<TNode> Class PXCache&lt;TNode&gt; Class in the API Reference. We don't recommend that you iterate through the  Cached  collection.         For performance optimization, this collection may not retrieve all available data         records. Updating a Data Record in a  PXCache The framework raises the applicable events and updates the status of the record in the         following cases as described: When you invoke the  Insert() ,  Update() , or              Delete()  method of a  PXCache  object, the framework           raises field-level events for each field when the  Insert()  or              Update()  method is invoked, and for only key fields when the              Delete()  method is invoked; the framework then raises all row-level           events for the data           record. document.DocNbr = lastNumber;
Documents.Update(document); When you invoke the  SetValueExt<Field>()  method of a cache object,           the framework raises field-level events for the specified field only. The framework           doesn't invoke row-level events and doesn't update the status of the record. You can           update the status of the record manually by invoking the  SetStatus()            method of the cache. However, you should be careful with skipped field-level and row-level           events because changing the status manually may cause missing logic and incorrect data           update. view.Cache.SetValueExt<Document.docNbr>(row, lastNumber); The framework neither raises any event nor updates the status of the record in the         following cases: If you assign a new value to a field without invoking            Update() document.DocNbr = lastNumber; If you assign a new value to a field by invoking the              SetValue<Field>()  method of the cache           object view.Cache.SetValue(row, LastNumberField.Name, lastNumber); Searching for a Data Record in a  PXCache Searching for a data record in the cache is helpful when you want to check whether the data         record has already been modified during the current user session. To search for a data         record, you can use the  Locate()  method, which returns the data record if         it exists in the  PXCache  object. The  Locate()  method         searches for the record by key values. If the record doesn't exist, the method returns null.         No query is executed to the database in the  Locate()  method. Account account = Accounts.Locate(record); Invoking  PXCache  Methods You can invoke data modification methods on a  PXCache  object through a         data view. The methods are invoked on the  PXCache  object of the first DAC         specified in the data view type (main DAC of the data view). The following code shows         equivalent invocations of the  Insert()  method on the            PXCache  object that stores  ShipmentLine  data records         in a graph. // ShipmentLines is a data view of the PXSelectBase<ShipmentLine> type
// defined in the graph.
// ShipmentLine is the main DAC of the ShipmentLines data view.

// Invocation through the data view
 ShipmentLines.Insert(line); 
// Invocation directly through the PXCache
 ShipmentLines.Cache.Insert(line); ]]></column>
		</row>
		<row PageID="4009fc41-b1ec-4e2d-9940-c92a32d5ca9b" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="6ec1b271-dcfb-51bd-7e8e-f8be202582dc" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The Acumatica ERP server creates a separate session for each browser tab or window that opens an Acumatica ERP form.{br}

The server creates the first session for a user after the user authorization when the starting form is loading. Then the server does the following:[anchor|#_657433bf-123b-4e9b-96b2-c8ca798626d9]
*Saves the user authorization data (<tt>.ASPXAUTH</tt>) and the session ID (<tt>ASP.NET&#95;SessionID</tt>) in the browser cookies for the website URL
*Creates the shared session data to be used for the Acumatica ERP forms opened in new browser tabs and windows
*Saves the shared session data in the storage that is specified in the website configuration
{br}

When the user opens a form of Acumatica ERP in a new browser tab, the server creates a new session that is based on the previous session data. To access the shared data, the server uses the session ID from the cookies, which are added to the request by the browser.{br}

The following diagram shows how the server of Acumatica ERP manages the shared session data that is used for multiple sessions of a single user.[anchor|#_08e0ef00-e124-4945-9880-2942edc76761][anchor|#_e63df35d-20e7-437f-af8b-18a0d33b33b5][image:StudioDeveloperGuide/Images/OV_Architecture_SessionSplit.png|popup|Use of shared data for multiple sessions of a user|450px]{br}

If the session data has been changed during the processing of a request, the server updates the data in the shared session data store. For example, if the user clicks '''Copy''' on a form toolbar to copy the form data, the data is stored in the shared session, so that it is accessible for the '''Paste''' action in another session of the same user.{br}

To distinguish different sessions that have the same <tt>ASP.NET&#95;SessionID</tt>, the server adds to each new session a unique identifier that consists of the ''W'' character and a number value wrapped in parentheses. In the browser, you can see such an identifier in the site URL, as with the bolded part in the following example: ''http://localhost/MySite/'''(W(3))'''/Main.aspx?ScreenId=AR301000''.]]></column>
			<column name="PlainText"><![CDATA[Session The  Acumatica ERP    server creates a separate session for each browser tab or window that opens an  Acumatica ERP    form. The server creates the first session for a user after the user authorization when the starting    form is loading. Then the server does the following: Saves the user authorization data ( .ASPXAUTH ) and the session ID       ( ASP.NET_SessionID ) in the browser cookies for the website URL Creates the shared session data to be used for the  Acumatica ERP      forms opened in new browser tabs and windows Saves the shared session data in the storage that is specified in the website      configuration When the user opens a form of  Acumatica ERP in    a new browser tab, the server creates a new session that is based on the previous session data.    To access the shared data, the server uses the session ID from the cookies, which are added to    the request by the browser. The following diagram shows how the server of  Acumatica ERP    manages the shared session data that is used for multiple sessions of a single user. Use of shared data for multiple sessions of a user If the session data has been changed during the processing of a request, the server updates the    data in the shared session data store. For example, if the user clicks      Copy  on a form toolbar to copy the form data, the data is stored in the    shared session, so that it is accessible for the  Paste  action in another    session of the same user. To distinguish different sessions that have the same  ASP.NET_SessionID , the    server adds to each new session a unique identifier that consists of the  W  character and a    number value wrapped in parentheses. In the browser, you can see such an identifier in the site    URL, as with the bolded part in the following example:      http://localhost/MySite/ (W(3)) /Main.aspx?ScreenId=AR301000 . ]]></column>
		</row>
		<row PageID="18374228-1e14-48e1-bc40-4f3b526928ed" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="9d02fffe-a98c-e673-7442-d2e43d40265a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To achieve horizontal scalability and fault tolerance, an application written with Acumatica Framework can be configured to run in a cluster of application servers behind a load balancer. With this configuration, it is not possible to predict the application server that will receive the next request from the client. In this model, session specific data must be shared between the application servers.{br}

The following diagram shows difference in storing session data on a stand-alone server and in a cluster. On a stand-alone Acumatica ERP server, session data is stored in the server memory. In a cluster of application servers, session data must be serialized and stored in a high-performance remote server, such as Redis or Microsoft SQL.[anchor|#_8bd7a8fb-c020-4236-8203-993df5e8b717][anchor|#_89f3fdb7-659f-4eb9-9d7a-d48f176ac3a0][image:StudioDeveloperGuide/Images/OV_Acumatica_And_Web_SessionOnCluster_01.png|popup|Storing session data on a stand-alone server and in a cluster|445px]{br}

The cost of serialization and the amount of data that need to be shared between application servers is often the main challenge to scaling complex business applications horizontally.{br}

 Acumatica Framework implements the following techniques to address issues related to session-state management without sacrificing performance, fault tolerance, or scalability:[anchor|#_90bde1b7-de6b-4388-bc12-49e04fa99454]
*Objects on the application server are created on each request and disposed after the request execution. The application state is preserved in the session through the serialization mechanism.
*Data serialized into the session is minimized to store only modified data (inserted, deleted, held and modified records). (Serialization and retrieval times are directly proportional to the size of the serialized data.) 
*The rest of the data is extracted from the database on demand and built around the session data. (A custom algorithm that extracts only the data required for the current request execution from the database is implemented.)
*A custom serialization mechanism is implemented to serialize only relevant data and reduce the amount of service information. (The standard serialization mechanism implemented in the Microsoft .NET platform is generic and cannot be optimized when used for a specific task.)
*Hash tables, constraints, relations, and indexes concerned with the execution of business logic are created strictly on demand. This technique allows the user to avoid execution of these operations on each request if not needed. (Creation of indexes, constrains, hash tables, and relations consumes a significant amount of CPU and runtime memory.)
]]></column>
			<column name="PlainText"><![CDATA[Session Sharing Between Application Servers To achieve horizontal scalability and fault tolerance, an application written with  Acumatica Framework can be    configured to run in a cluster of application servers behind a load balancer. With this    configuration, it is not possible to predict the application server that will receive the next    request from the client. In this model, session specific data must be shared between the    application servers. The following diagram shows difference in storing session data on a stand-alone server and in a    cluster. On a stand-alone  Acumatica ERP    server, session data is stored in the server memory. In a cluster of application servers, session    data must be serialized and stored in a high-performance remote server, such as Redis or    Microsoft SQL. Storing session data on a stand-alone server and in a cluster The cost of serialization and the amount of data that need to be shared between application    servers is often the main challenge to scaling complex business applications horizontally.  Acumatica Framework    implements the following techniques to address issues related to session-state management without    sacrificing performance, fault tolerance, or scalability: Objects on the application server are created on each request and disposed after the request     execution. The application state is preserved in the session through the serialization     mechanism. Data serialized into the session is minimized to store only modified data (inserted, deleted,     held and modified records). (Serialization and retrieval times are directly proportional to the     size of the serialized data.)  The rest of the data is extracted from the database on demand and built around the session     data. (A custom algorithm that extracts only the data required for the current request execution     from the database is implemented.) A custom serialization mechanism is implemented to serialize only relevant data and reduce     the amount of service information. (The standard serialization mechanism implemented in the     Microsoft .NET platform is generic and cannot be optimized when used for a specific task.) Hash tables, constraints, relations, and indexes concerned with the execution of business     logic are created strictly on demand. This technique allows the user to avoid execution of these     operations on each request if not needed. (Creation of indexes, constrains, hash tables, and     relations consumes a significant amount of CPU and runtime memory.) ]]></column>
		</row>
		<row PageID="7de20fae-aa20-407b-976d-38f05fb4083c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8a008218-47e7-8f6f-ef3f-b2f6a599eb8d" RecordSourceID="22377">
			<column name="Content"><![CDATA[
 Acumatica ERP keeps all modified data records in the cache. Therefore, you do not change a data record in the database directly when you modify its value in the user interface.{br}

((({S:Warn}The system commits the changes to the database in the following cases:[anchor|#_d084d1f7-53f7-47ca-9776-29e213bf075c]
*The user clicks '''Save'''.
*A request is sent through the web services APIs.
*The <tt>Actions.PressSave</tt> method is invoked on the graph instance.
*The <tt>PXAutoSaveAttribute</tt> attribute is defined for a data access class. As a result, the <tt>PXCache&lt;&gt;.Unload</tt> method automatically stores in the database all the changes of the appropriate data records at the end of each round trip.
))){br}

A graph instance exists on the server only while a user request is being processed, and it is destroyed right after this processing. The following diagram shows that a graph instance is created to process a user request on the Acumatica ERP server and destroyed once processing is completed.[anchor|#_b0e1ca8e-5ccd-46ed-8807-6f4cc058a49f][anchor|#_324bab80-c93c-4b70-bde2-296e93423a4a][image:StudioDeveloperGuide/Images/REF_Graph_RoundTrips.png|popup|Processing of user requests|450px]In the diagram above, the blue rectangles labeled 1, 2, 3, and 4 indicate the lifetime of graph instances. After a graph instance completes the processing of a request, the system stores the graph state in the session. It also stores the inserted, deleted, held, and modified records of the cache that are required to restore the state and data of the graph for the processing of the subsequent user request on the same Acumatica ERP form.((({S:Warn}On a stand-alone Acumatica ERP server, session data is stored in the server memory. In a cluster of Acumatica ERP servers, session data must be serialized and stored in external high-performance session state storage. (For more information on storing session data in a cluster, see [HelpRoot_Dev_Platform\AD__con_Session_Sharing|Session Sharing Between Application Servers].)
))){br}

For a user request on an Acumatica ERP form, the following operations are executed in the system:[anchor|#_2e54d58a-73d7-4728-8a7e-69a985eb9df8]
#The application server creates a graph instance that is specified in the <tt>TypeName</tt> property of the <tt>PXDataSource</tt> control of the form. (For more information about the initialization of graph views, caches, actions, and event handlers, see [HelpRoot_Dev_Platform\BL__con_Execution_of_Event_Handlers#_57644a4b-f2b5-4ff0-bf72-622bf84d90f7|Initialization of an Event Handler Collection].)
#If the user session contains graph data that has been stored during a previous request, the system loads the graph state and the cache data from the session.
#The graph instance processes the requested data on the data view that is specified in the ASPX code in the <tt>DataMember</tt> property of the control container for the data to be processed. To process the data, the system invokes the <tt>ExecuteSelect</tt>, <tt>ExecuteInsert</tt>, <tt>ExecuteUpdate</tt>, or <tt>ExecuteDelete</tt> method of the graph, based on the request type. The invoked method implements the logic of the appropriate scenario to add the request data to the cache and to execute the event handlers defined for the data fields and records in the cache. (See [HelpRoot_Dev_Platform\BL__con_Events_Scenarios|Data Manipulation Scenarios] for details.) The cache then merges the data retrieved from the database with the data restored from the session, and the application accesses the data as if the entire data set had been preserved from the time of the previous request.
#The graph instance returns the request results to the <tt>PXDatasource</tt> control of the form.
#The system stores in the session the graph state and the modified data of the cache.
#:((({S:Warn}Because the graph instance is no longer being used by the application server, the .NET Framework garbage collector then clears the memory allocated for the graph instance.
)))
{br}

While a graph is instantiated, all the cached data of the graph is saved in the appropriate <tt>PXCache</tt> objects that are created in the graph instance based on the data access class (DAC) declarations. To preserve the modified entity data between user requests, the cache controller saves the <tt>Updated</tt>, <tt>Inserted</tt>, <tt>Deleted</tt>, and <tt>Held</tt> collections of each <tt>PXCache</tt> object in the session.{br}

The following diagram shows how the graph state and cache data are stored in the <tt>Session</tt> object.[anchor|#_9fc1db28-f79b-4ce8-a3c3-898a1f0a9add][anchor|#_7a606a7b-0377-405c-97bf-b71eb3460322][image:StudioDeveloperGuide/Images/REF_Graph_Cache_Session.png|popup|The graph data stored in the session|450px]In the diagram above, notice the following:[anchor|#_5432ba5b-89f4-4c0d-b433-6583d36b6587]
*The items of the graph instance are stored in the <tt>GraphInfo</tt> collection of the <tt>Session</tt> object as a key-value pair, where the <tt>key</tt> is equal to the full name of the graph.
*The items of a <tt>PXCache</tt> object are stored in the <tt>CacheInfo</tt> collection of the <tt>Session</tt> object as a key-value pair, where the <tt>key</tt> consists of the following parts separated by the ''$'' symbol:
*#The full name of the graph
*#The full name of the DAC
((({S:Warn}When you instantiate a graph from code, the system will not load data from the session, because you may want to perform redirection or other processing. You can direct the system to load this data by using the <tt>PXPreserveScope</tt> class, as the following code snippet shows.{{{{using (new PXPreserveScope())
{
  GraphName graph = PXGraph.CreateInstance&lt;GraphName&gt;();
  graph.Load();
  ...
}
}}}}
)))]]></column>
			<column name="PlainText"><![CDATA[Storing of Graph Data in the Session  Acumatica ERP keeps all modified data records in the cache. Therefore, you do not change a data record in       the database directly when you modify its value in the user interface. The system commits the changes to the database in the following cases: The user clicks  Save . A request is sent through the web services APIs. The  Actions.PressSave  method is invoked on the graph instance. The  PXAutoSaveAttribute  attribute is defined for a data access             class. As a result, the  PXCache<>.Unload  method automatically             stores in the database all the changes of the appropriate data records at the end of             each round trip. A graph instance exists on the server only while a user request is being processed, and it is       destroyed right after this processing. The following diagram shows that a graph instance is       created to process a user request on the  Acumatica ERP server and destroyed once processing is completed. Processing of user requests In the diagram above, the blue rectangles labeled 1, 2, 3, and 4 indicate the lifetime       of graph instances. After a graph instance completes the processing of a request, the system       stores the graph state in the session. It also stores the inserted, deleted, held, and       modified records of the cache that are required to restore the state and data of the graph for       the processing of the subsequent user request on the same  Acumatica ERP form. On a stand-alone  Acumatica ERP server, session data is stored in the server memory. In a cluster of  Acumatica ERP servers, session data must be serialized and stored in external high-performance session         state storage. (For more information on storing session data in a cluster, see  Session Sharing Between Application Servers.) For a user request on an  Acumatica ERP form, the following operations are executed in the system: The application server creates a graph instance that is specified in the              TypeName  property of the  PXDataSource  control of           the form. (For more information about the initialization of graph views, caches, actions,           and event handlers, see  Initialization of an Event Handler Collection.) If the user session contains graph data that has been stored during a previous request,           the system loads the graph state and the cache data from the session. The graph instance processes the requested data on the data view that is specified in           the ASPX code in the  DataMember  property of the control container for           the data to be processed. To process the data, the system invokes the              ExecuteSelect ,  ExecuteInsert ,              ExecuteUpdate , or  ExecuteDelete  method of the           graph, based on the request type. The invoked method implements the logic of the           appropriate scenario to add the request data to the cache and to execute the event           handlers defined for the data fields and records in the cache. (See  Data Manipulation Scenarios for details.) The cache then merges the data           retrieved from the database with the data restored from the session, and the application           accesses the data as if the entire data set had been preserved from the time of the           previous request. The graph instance returns the request results to the  PXDatasource            control of the form. The system stores in the session the graph state and the modified data of the             cache. Because the graph instance is no longer being used by the application             server, the .NET Framework garbage collector then clears the memory allocated for the             graph instance. While a graph is instantiated, all the cached data of the graph is saved in the appropriate          PXCache  objects that are created in the graph instance based on the data       access class (DAC) declarations. To preserve the modified entity data between user requests,       the cache controller saves the  Updated ,  Inserted ,          Deleted , and  Held  collections of each          PXCache  object in the session. The following diagram shows how the graph state and cache data are stored in the          Session  object. The graph data stored in the session In the diagram above, notice the following: The items of the graph instance are stored in the  GraphInfo            collection of the  Session  object as a key-value pair, where the              key  is equal to the full name of the graph. The items of a  PXCache  object are stored in the              CacheInfo  collection of the  Session  object as a           key-value pair, where the  key  consists of the following parts separated           by the  $  symbol: The full name of the graph The full name of the DAC When you instantiate a graph from code, the system will not load data from the session,         because you may want to perform redirection or other processing. You can direct the system         to load this data by using the  PXPreserveScope  class, as the following         code snippet         shows. using (new PXPreserveScope())
{
  GraphName graph = PXGraph.CreateInstance<GraphName>();
  graph.Load();
  ...
} ]]></column>
		</row>
		<row PageID="7d60ac9e-ff6c-40fc-a593-52e1545493fe" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2d7f5fd6-5336-4ff7-5da4-e03019bb8635" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you have to cache a data object from your code, you can use the slots provided by the <tt>PXContext</tt> and <tt>PXDatabase</tt> classes. By using these slots, you can cache any type of data object without restrictions.{br}

A slot provided by the <tt>PXContext</tt> class exists in the memory of the application server only during the current HTTP request. Therefore, you can use these slots for quick data exchange between different server modules while the server processes a single request.{br}

A slot of the <tt>PXDatabase</tt> class is stored in the server memory until you clear the slot. Therefore, you can use such a slot to cache a data object for a long time—for example, to read the cached data during a future HTTP request.{br}

If a <tt>PXDatabase</tt> slot is used to cache the data that is obtained from the database tables, you can use a special API to automatically update the data in the slot when any of these tables has been changed.{br}

For detailed information on using slots, see the sections of this topic.{br}{TOC}[anchor|#_d38fe24d-5e23-4635-8ade-ede9f4dca92b]
==Caching Data in <tt>PXContext</tt> Slots==
If you need to keep a data object during a single HTTP request, we recommend that you cache the object in a slot provided by the <tt>PXContext</tt> class.{br}

You can use the following public static methods of the class to save a data object in a slot.[anchor|#_7857047f-a58e-4ae3-94a4-c8fb46ff2fb9]
{| class="checklist" | width="100%" 
|- 
!width="33%" ! Method
!width="66%" ! Description
|- 
| {{public static ObjectType SetSlot<ObjectType> (ObjectType value)}}
| Stores the specified data object under the key that is created on the base of the object type.
|- 
| {{public static ObjectType SetSlot<ObjectType> (string key, ObjectType value)}}
| Stores the specified data object under the key that is defined by the first parameter.
|}{br}

The following example shows how you can save the {{MyData}} object in the slot of the current HTTP context under the key that is the same as the object type.{{{{PXContext.SetSlot&lt;MyDataType&gt;(MyData);
}}}}{br}

To get a data object that is cached in the current HTTP context, you can use the following methods of the <tt>PXContext</tt> class.[anchor|#_7fe848ff-33a9-4e7d-96a5-b0093339c27c]
{| class="checklist" | width="100%" 
|- 
!width="33%" ! Method
!width="66%" ! Description
|- 
| {{public static ObjectType GetSlot<ObjectType>()}}
| Returns the data object that is cached under the key that is created on the base of the object type.
|- 
| {{public static ObjectType GetSlot<ObjectType> (string key)}}
| Returns the data object that is cached under the specified key.
|}{br}

The following example shows how you can get from the slot of the current HTTP context the {{MyData}} object that is cached under the ''MyData22'' key.{{{{var MyData = PXContext.GetSlot&lt;MyDataType&gt;("MyData22");
}}}}{br}

The following diagram illustrates how you can use a data object cached by using a slot provided by the <tt>PXContext</tt> class.[anchor|#_8597511b-4063-4c7a-a8fe-c288554bf6e1][anchor|#_6a284050-7ecb-46ff-b8f9-3fb971a39299][image:StudioDeveloperGuide/Images/UsingSlotsToCacheData01.png|popup|Caching data in a slot of the <tt>PXContext</tt> class|355px]{br}

You do not need to delete the data saved in the <tt>PXContext</tt> class slots, because the system deletes these slots from the server memory along with the data of the current HTTP context created for the current request.[anchor|#_020dad6c-309a-4ecf-acd9-684fb03a39b3]
==Caching Data in <tt>PXDatabase</tt> Slots==
If you need to keep a data object in the server memory for a long time, we recommend that you cache the object in a slot provided by the <tt>PXDatabase</tt> class.{br}

You can use the following public static methods of the class to cache a data object in a slot and to get the cached object from the slot.[anchor|#_31a95fcc-9507-4952-bf43-09f403eb4cc4]
{| class="checklist" | width="100%" 
|- 
!width="33%" ! Method
!width="66%" ! Description
|- 
| {{public static ObjectType GetSlot<ObjectType> (string key, params Type[] tables)}}
| If the <tt>PXDatabase</tt> slots contain a valid data object of the specified type saved under the key defined by the first parameter, returns this data object. Otherwise, the method creates a new object of the specified type, saves this empty object in the slot under the key defined by the first parameter, and returns the data object that is used by the calling code to save the needed data. The list of the table types specified in the <tt>params</tt> parameter is used to invalidate the slot if any table of the list has been changed in the database.((({S:Warn}If this method is used to cache a data object of an {{ObjectType}} class inherited from the <tt>IPrefetchable&lt;&gt;</tt> interface, the <tt>GetSlot&lt;&gt;</tt> method invokes the <tt>Prefetch</tt> method of the object without a parameter.
)))
|- 
| {{public static ObjectType GetSlot<ObjectType, Parameter> (string key, Parameter parameter, params Type[] tables)}}
| Is used for caching a data object of an {{ObjectType}} class inherited from the <tt>IPrefetchable&lt;&gt;</tt> interface to provide automatic update of the object in the slot. If the <tt>PXDatabase</tt> slots contain a valid data object of the specified type saved under the key defined by the first parameter, the method returns this data object. Otherwise, the method does the following:[anchor|#_c2a7624f-a620-4099-ae77-cfdb3b5245d3]
#Creates a new object of the specified type
#To create or update data in the object, invokes the <tt>Prefetch</tt> method with the <tt>parameter</tt> specified in the second parameter
#Saves this object in the slot under the key defined by the first parameter
#Returns the data object to the calling method
The list of the table types specified in the <tt>params</tt> parameter is used to invalidate the slot in the case if any table of the list has been changed in the database. The use of this method is described below in the [[#_469c7eaf-0f4b-4cad-97f4-f4676e32419e|Automatically Updating Data in a PXDatabase Slot] section.
|}{br}

The following example shows how you can use the <tt>GetSlot&lt;ObjectType&gt; (string key, params Type&#91;&#93; tables)</tt> method to cache data under the ''MyData'' key in the slot of the <tt>PXDatabase</tt> class.{{{{...
  Dictionary&lt;string, string[]&gt; dict = 
    PXDatabase.GetSlot&lt;Dictionary&lt;string, string[]&gt;&gt;(
      "MyData", typeof(Table1), typeof(Table2), typeof(Table3));
  lock (((System.Collections.ICollection)dict).SyncRoot)
  {
...
    List&lt;string&gt; myList = new List&lt;string&gt;();
...
    string key = "myListKey";
    dict[key] = myList.ToArray();
  }
...
}}}}After the data object has been cached, you can access the object by using the following instruction.{{{{Dictionary&lt;string, string[]&gt; dict = 
          PXDatabase.GetSlot&lt;Dictionary&lt;string, string[]&gt;&gt;(
            "MyData", typeof(Table1), typeof(Table2), typeof(Table3));
}}}}{br}

You can clear a slot provided by the <tt>PXDatabase</tt> class by means of the following public static methods of the class.[anchor|#_794cb613-1f91-42dd-bca0-4b10d8c2bc99]
{| class="checklist" | width="100%" 
|- 
!width="33%" ! Method
!width="66%" ! Description
|- 
| {{public static void ResetSlot<ObjectType> (string key, params Type[] tables)}}
| Sets to ''null'' the value of the slot that has the specified key.
|- 
| {{public static void ResetSlots()}}
| Sets to ''null'' the value of each slot that is provided by the <tt>PXDatabase</tt> class.
|}{br}

The following example shows how you can clear the slot created in the example above.{{{{PXDatabase.ResetSlot&lt;MyDataType&gt;(
            "MyData", typeof(Table1), typeof(Table2), typeof(Table3));
}}}}[anchor|#_469c7eaf-0f4b-4cad-97f4-f4676e32419e]
==Automatically Updating Data in a <tt>PXDatabase</tt> Slot==
If a data object that is to be cached depends on data in the database, we recommend that you inherit the object class from the <tt>IPrefetchable&lt;&gt;</tt> interface and develop in this class the <tt>Prefetch</tt> method, to provide automatic updating of data in the object. Then the {{GetSlot<ObjectType, Parameter>(string key, Parameter parameter, params Type[] tables)}} method of the <tt>PXDatabase</tt> class will use the <tt>Prefetch</tt> method to update the data in the slot, if required. (See the description of the method in [[#_020dad6c-309a-4ecf-acd9-684fb03a39b3|Caching Data in PXDatabase Slots].){br}

For example, suppose that you need to develop a data provider that selects data from multiple tables of the database and caches the data in <tt>PXDatabase</tt> slots. To do this, you can develop the provider class based on the following code.{br}

{{{{public abstract class MyProvider : ProviderBase
{
  // Here you can add abstract definitions for all the methods of 
  // the PXDatabaseMyProvider class
}

public class PXDatabaseMyProvider : MyProvider
{

  private class MyDataObject : IPrefetchable&lt;PXDatabaseMyProvider&gt;
  {
    public MyDataType MyData = new MyData();

    public void Prefetch(PXDatabaseMyProvider provider)
    {
      // Here you can implement the code to generate data of the MyData object.
    }
  }

  private MyDataObject MyDataObj
  {
    get
    {
      return PXDatabase.GetSlot&lt;MyDataObject, PXDatabaseMyProvider&gt;(
        "MYDATA_SLOT_KEY",
               this, typeof(Table1), typeof(Table2), typeof(Table3)
               /* ,... Add here the types of all tables, any change in which 
               should make the slot invalid. */ );
    }
  }

  // Here you need to add the code for all the methods that are defined 
  // in the MyProvider abstract class.
  // These methods can be used to manage the MyData object.
...
}
}}}}{br}

The code above contains declarations of the following classes:[anchor|#_23bf13d3-2799-428a-8975-35a8532ddd5a]
*The {{MyProvider}} abstract class, which derives from the <tt>System.Configuration.Provider.ProviderBase</tt> public abstract class and is used to define implementation of the {{PXDatabaseMyProvider}} class.
*The {{PXDatabaseMyProvider}} class, which contains the following:
**The {{MyDataObject}} private class, which derives from the <tt>IPrefetchable&lt;PXDatabaseMyProvider&gt;</tt> interface and contains the following members:
***The {{MyData}} data object to be cached
***The <tt>Prefetch</tt> method, which creates or updates the data object
**An implementation of the methods that are declared in the {{MyProvider}} abstract class and used to manage to the {{MyData}} object. To access the data object stored in the database slot, in these methods, you can use the {{MyDataObject}} property of the {{PXDatabaseMyProvider}} class, as the following instruction shows.{{{{MyDataObject data = MyDataObj;
}}}}
{br}

For the code above, the following diagram shows how the data object is cached and automatically updated in the <tt>PXDatabase</tt> slot.[anchor|#_bdbae4c8-9113-42ab-bf35-54aa64356e85][anchor|#_8f92b6ac-f6d2-49e0-adf7-53649da04acf][image:StudioDeveloperGuide/Images/UsingSlotsToCacheData02.png|popup|Automatic update of the cached data|450px]{br}

((({S:Warn}If you have discovered that a <tt>PXDatabase</tt> slot returns legacy data, you can invoke the <tt>SelectTimeStamp()</tt> public static method of the <tt>PXDatabase</tt> class to invalidate all the <tt>PXDatabase</tt> slots that contain data obtained from the database tables that have been changed. Then the <tt>GetSlot</tt> method invokes the <tt>Prefetch</tt> method and updates the data in the slot.
)))]]></column>
			<column name="PlainText"><![CDATA[Use of Slots to Cache Data Objects If you have to cache a data object from your code, you can use the slots provided by the            PXContext  and  PXDatabase  classes. By using these         slots, you can cache any type of data object without restrictions. A slot provided by the  PXContext  class exists in the memory of the         application server only during the current HTTP request. Therefore, you can use these slots         for quick data exchange between different server modules while the server processes a single         request. A slot of the  PXDatabase  class is stored in the server memory until you         clear the slot. Therefore, you can use such a slot to cache a data object for a long         time—for example, to read the cached data during a future HTTP request. If a  PXDatabase  slot is used to cache the data that is obtained from the         database tables, you can use a special API to automatically update the data in the slot when         any of these tables has been changed. For detailed information on using slots, see the sections of this topic. Caching Data in  PXContext  Slots If you need to keep a data object during a single HTTP request, we recommend that you cache         the object in a slot provided by the  PXContext  class. You can use the following public static methods of the class to save a data object in a           slot. Method Description public static ObjectType SetSlot<ObjectType> (ObjectType                     value) Stores the specified data object under the key that is created on the base of                   the object type. public static ObjectType SetSlot<ObjectType> (string key,                     ObjectType value) Stores the specified data object under the key that is defined by the first                   parameter. The following example shows how you can save the  MyData  object in the slot         of the current HTTP context under the key that is the same as the object         type. PXContext.SetSlot<MyDataType>(MyData); To get a data object that is cached in the current HTTP context, you can use the following         methods of the  PXContext  class. Method Description public static ObjectType GetSlot<ObjectType>() Returns the data object that is cached under the key that is created on the                   base of the object type. public static ObjectType GetSlot<ObjectType> (string                   key) Returns the data object that is cached under the specified key. The following example shows how you can get from the slot of the current HTTP context the            MyData  object that is cached under the  MyData22          key. var MyData = PXContext.GetSlot<MyDataType>("MyData22"); The following diagram illustrates how you can use a data object cached by using a slot         provided by the  PXContext  class. Caching data in a slot of the  PXContext  class You do not need to delete the data saved in the  PXContext  class slots,         because the system deletes these slots from the server memory along with the data of the         current HTTP context created for the current request. Caching Data in  PXDatabase  Slots If you need to keep a data object in the server memory for a long time, we recommend that         you cache the object in a slot provided by the  PXDatabase  class. You can use the following public static methods of the class to cache a data object in a         slot and to get the cached object from the slot. Method Description public static ObjectType GetSlot<ObjectType> (string key, params                     Type[] tables) If the  PXDatabase  slots contain a valid data object of the                   specified type saved under the key defined by the first parameter, returns this                   data object. Otherwise, the method creates a new object of the specified type,                   saves this empty object in the slot under the key defined by the first parameter,                   and returns the data object that is used by the calling code to save the needed                   data. The list of the table types specified in the  params                    parameter is used to invalidate the slot if any table of the list has been changed                   in the database. If this method is used to cache a data object of an                        ObjectType  class inherited from the                        IPrefetchable<>  interface, the                        GetSlot<>  method invokes the  Prefetch                      method of the object without a parameter. public static ObjectType GetSlot<ObjectType, Parameter> (string                     key, Parameter parameter, params Type[] tables) Is used for caching a data object of an  ObjectType  class                   inherited from the  IPrefetchable<>  interface to provide                   automatic update of the object in the slot. If the  PXDatabase                    slots contain a valid data object of the specified type saved under the key                   defined by the first parameter, the method returns this data object. Otherwise,                   the method does the following: Creates a new object of the specified type To create or update data in the object, invokes the                          Prefetch  method with the  parameter                        specified in the second parameter Saves this object in the slot under the key defined by the first                       parameter Returns the data object to the calling method The list of the table types specified in the  params                    parameter is used to invalidate the slot in the case if any table of the list has                   been changed in the database. The use of this method is described below in the                      Automatically Updating Data in a PXDatabase Slot Automatically Updating Data in a PXDatabase Slot section. The following example shows how you can use the  GetSlot<ObjectType> (string           key, params Type[] tables)  method to cache data under the  MyData  key in         the slot of the  PXDatabase          class. ...
  Dictionary<string, string[]> dict = 
    PXDatabase.GetSlot<Dictionary<string, string[]>>(
      "MyData", typeof(Table1), typeof(Table2), typeof(Table3));
  lock (((System.Collections.ICollection)dict).SyncRoot)
  {
...
    List<string> myList = new List<string>();
...
    string key = "myListKey";
    dict[key] = myList.ToArray();
  }
... After         the data object has been cached, you can access the object by using the following         instruction. Dictionary<string, string[]> dict = 
          PXDatabase.GetSlot<Dictionary<string, string[]>>(
            "MyData", typeof(Table1), typeof(Table2), typeof(Table3)); You can clear a slot provided by the  PXDatabase  class by means of the         following public static methods of the class. Method Description public static void ResetSlot<ObjectType> (string key, params                     Type[] tables) Sets to  null  the value of the slot that has the specified key. public static void ResetSlots() Sets to  null  the value of each slot that is provided by the                      PXDatabase  class. The following example shows how you can clear the slot created in the example         above. PXDatabase.ResetSlot<MyDataType>(
            "MyData", typeof(Table1), typeof(Table2), typeof(Table3)); Automatically Updating Data in a  PXDatabase  Slot If a data object that is to be cached depends on data in the database, we recommend that         you inherit the object class from the  IPrefetchable<>  interface and         develop in this class the  Prefetch  method, to provide automatic updating         of data in the object. Then the  GetSlot<ObjectType, Parameter>(string key,           Parameter parameter, params Type[] tables)  method of the            PXDatabase  class will use the  Prefetch  method to         update the data in the slot, if required. (See the description of the method in  Caching Data in PXDatabase Slots Caching Data in PXDatabase Slots.) For example, suppose that you need to develop a data provider that selects data from         multiple tables of the database and caches the data in  PXDatabase  slots.         To do this, you can develop the provider class based on the following code. public abstract class MyProvider : ProviderBase
{
  // Here you can add abstract definitions for all the methods of 
  // the PXDatabaseMyProvider class
}

public class PXDatabaseMyProvider : MyProvider
{

  private class MyDataObject : IPrefetchable<PXDatabaseMyProvider>
  {
    public MyDataType MyData = new MyData();

    public void Prefetch(PXDatabaseMyProvider provider)
    {
      // Here you can implement the code to generate data of the MyData object.
    }
  }

  private MyDataObject MyDataObj
  {
    get
    {
      return PXDatabase.GetSlot<MyDataObject, PXDatabaseMyProvider>(
        "MYDATA_SLOT_KEY",
               this, typeof(Table1), typeof(Table2), typeof(Table3)
               /* ,... Add here the types of all tables, any change in which 
               should make the slot invalid. */ );
    }
  }

  // Here you need to add the code for all the methods that are defined 
  // in the MyProvider abstract class.
  // These methods can be used to manage the MyData object.
...
} The code above contains declarations of the following classes: The  MyProvider  abstract class, which derives from the                System.Configuration.Provider.ProviderBase  public abstract class             and is used to define implementation of the  PXDatabaseMyProvider              class. The  PXDatabaseMyProvider  class, which contains the following: The  MyDataObject  private class, which derives from the                    IPrefetchable<PXDatabaseMyProvider>  interface and contains                 the following members: The  MyData  data object to be cached The  Prefetch  method, which creates or updates the data                     object An implementation of the methods that are declared in the                    MyProvider  abstract class and used to manage to the                    MyData  object. To access the data object stored in the database                 slot, in these methods, you can use the  MyDataObject  property of                 the  PXDatabaseMyProvider  class, as the following instruction                 shows. MyDataObject data = MyDataObj; For the code above, the following diagram shows how the data object is cached and         automatically updated in the  PXDatabase  slot. Automatic update of the cached data If you have discovered that a  PXDatabase  slot returns legacy data,           you can invoke the  SelectTimeStamp()  public static method of the              PXDatabase  class to invalidate all the  PXDatabase            slots that contain data obtained from the database tables that have been changed. Then the              GetSlot  method invokes the  Prefetch  method and           updates the data in the slot. ]]></column>
		</row>
		<row PageID="6aea8e6f-3cc6-4f61-88a3-d7f49cd6c4b7" Language="en-US" PageRevisionID="1" Content="&#xA;The topics in this part of the guide explain how to implement business logic of an application based on Acumatica Framework.&#xA;==In This Part==[anchor|#ul_m1f_qxh_cl]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Working_With_Events|Working with Events]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Working_With_Attributes|Working with Attributes]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Working_with_Attachments|Working with Attachments]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Configuring_UI_from_Back_End|Configuring the UI from the Back End]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Creating_Forms|Creating Particular Types of Forms]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Executing_Code_Asynchronously|Executing Code Asynchronously]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Localizing_Applications|Localizing Applications]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Reusing_Business_Logic|Reusing Business Logic]&#xA;" PlainText="Implementing Business Logic The topics in this part of the guide explain how to implement business logic of an                 application based on  Acumatica Framework. In This Part Working with EventsWorking with AttributesWorking with AttachmentsConfiguring the UI from the Back EndCreating Particular Types of FormsExecuting Code AsynchronouslyLocalizing ApplicationsReusing Business Logic" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="5bd4a233-df9a-df77-5237-8d3571563ee5" RecordSourceID="22377" />
		<row PageID="106557db-e5f6-416c-8872-5ef3de9bf433" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8ca427e9-12ef-29ff-9b22-07363cd529d6" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The Acumatica Framework provides its own event model in which events related to the manipulation of data records and data fields are raised in a particular order within certain scenarios. An ''event handler'' is a method invoked by the Acumatica Framework once the corresponding event is raised.{br}

By implementing event handlers, application developers can add business logic for the manipulation of data within business logic controllers (BLCs). This business logic includes the validation and calculation of field values, the management of data records (inserting, updating, or deleting), the checks for duplicate records, and the implementation of the presentation logic of the user interface.
==In This Chapter==[anchor|#_0a1f7b39-caa1-44c3-aaba-93a7ce18679f]
*[HelpRoot_Dev_Platform\BL__con_Event_Handler|Event Handlers]
*[HelpRoot_Dev_Platform\BL__con_Events_Types|Types of Graph Event Handlers]
*[HelpRoot_Dev_Platform\BL__con_Execution_of_Event_Handlers|Execution of Event Handlers]
*[HelpRoot_Dev_Platform\BL__con_Override_Handlers|Override of Event Handlers]
*[HelpRoot_Dev_Platform\BL__con_Events_Scenarios|Data Manipulation Scenarios]
*[HelpRoot_Dev_Platform\BL__con_Insertion_of_Record|Insertion of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Update|Update of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Deletion|Removal of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_SavingChangesInDB|Saving of Changes to the Database]
*[HelpRoot_Dev_Platform\BL__con_Events_Insert|Sequence of Events: Insertion of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Update|Sequence of Events: Update of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Delete|Sequence of Events: Deletion of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Display|Sequence of Events: Display of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Persist|Sequence of Events: Saving of Changes to the Database]
*[HelpRoot_Dev_Platform\BL__con_Events_All|List of Events]
*[HelpRoot_Dev_Platform\BL__con_Cancel_Event_Handlers|Cancellation of Attribute Event Handlers]
*[HelpRoot_Dev_Platform\BL__con_Validation_of_Single_Field|Validation of Field Values]
*[HelpRoot_Dev_Platform\BL__con_Validation_of_Data_Record|Validation of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_UpdateRow|Update of a Data Record on Update of a Field Value]
*[HelpRoot_Dev_Platform\BL__con_Internal_and_External_Presentation|Internal and External Presentation of Values]
]]></column>
			<column name="PlainText"><![CDATA[Working with Events The  Acumatica Framework     provides its own event model in which events related to the manipulation of data records and     data fields are raised in a particular order within certain scenarios. An  event handler      is a method invoked by the  Acumatica Framework once     the corresponding event is raised. By implementing event handlers, application developers can add business logic for the     manipulation of data within business logic controllers (BLCs). This business logic includes the     validation and calculation of field values, the management of data records (inserting, updating,     or deleting), the checks for duplicate records, and the implementation of the presentation logic     of the user interface. In This Chapter Event HandlersTypes of Graph Event HandlersExecution of Event HandlersOverride of Event HandlersData Manipulation ScenariosInsertion of a Data RecordUpdate of a Data RecordRemoval of a Data RecordSaving of Changes to the DatabaseSequence of Events: Insertion of a Data RecordSequence of Events: Update of a Data RecordSequence of Events: Deletion of a Data RecordSequence of Events: Display of a Data RecordSequence of Events: Saving of Changes to the DatabaseList of EventsCancellation of Attribute Event HandlersValidation of Field ValuesValidation of a Data RecordUpdate of a Data Record on Update of a Field ValueInternal and External Presentation of Values]]></column>
		</row>
		<row PageID="cd34176b-2ab9-42cc-890c-b6cb42cd433e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="604c1270-b4c7-ed16-4b88-c99f06e724f8" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The Acumatica Framework raises events in the context of a graph. An event handler can be implemented in a graph, as well as in an attribute of a data field.
==Graph and Attribute Event Handlers==
''Graph event handlers'' are defined as methods in a business logic controller (BLC) class for a particular data access class (DAC) or a particular DAC field. See the topics in the [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3ce58733-bf9c-d909-ae69-01db28ec45f6|PX.Data Delegates] section in the API Reference for each event for an example of a graph event handler declaration.{br}

''Attribute event handlers'' are defined as methods in attribute classes. The logic of the event handlers is attached to all DAC objects or data fields annotated with these attributes. The attribute in which an attribute event handler is implemented must be derived from the <tt>PXEventSubscriberAttribute</tt> class and must implement the interface of the {{IPX<EventName>Subscriber}} form (where {{<EventName>}} is replaced with the name of the needed event), as shown in the following example. <source lang="csharp">// The attribute implements handlers for the FieldVerifying
// and RowPersisting events
public class MyAttribute : PXEventSubscriberAttribute,
                           IPXFieldVerifyingSubscriber,
                           IPXRowPersistingSubscriber
{
     public virtual void FieldVerifying(PXCache sender,
                                        PXFieldVerifyingEventArgs e)
     {
         ...
     }

     public virtual void RowPersisting(PXCache sender,
                                       PXRowPersistingEventArgs e)
     {
         ...
     }
}</source>
==Related Articles==
*[HelpRoot_Dev_Platform\DA__con_Event_Handler_Naming|Naming Conventions for Event Handlers Defined in Graphs]]]></column>
			<column name="PlainText"><![CDATA[Event Handlers The  Acumatica Framework         raises events in the context of a graph. An event handler can be implemented in a graph, as         well as in an attribute of a data field. Graph and Attribute Event Handlers Graph event handlers  are defined as methods in a business logic controller (BLC) class     for a particular data access class (DAC) or a particular DAC field. See the topics in the  PX.Data Delegates PX.Data Delegates section in the API Reference for each     event for an example of a graph event handler declaration. Attribute event handlers  are defined as methods in attribute classes. The logic of the     event handlers is attached to all DAC objects or data fields annotated with these attributes.     The attribute in which an attribute event handler is implemented must be derived from the       PXEventSubscriberAttribute  class and must implement the interface of the       IPX<EventName>Subscriber  form (where  <EventName>  is     replaced with the name of the needed event), as shown in the following example.      // The attribute implements handlers for the FieldVerifying
// and RowPersisting events
public class MyAttribute : PXEventSubscriberAttribute,
                           IPXFieldVerifyingSubscriber,
                           IPXRowPersistingSubscriber
{
     public virtual void FieldVerifying(PXCache sender,
                                        PXFieldVerifyingEventArgs e)
     {
         ...
     }

     public virtual void RowPersisting(PXCache sender,
                                       PXRowPersistingEventArgs e)
     {
         ...
     }
} ]]></column>
		</row>
		<row PageID="94d73d75-d469-4a86-8b47-99cf305cc592" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="c995b089-c276-9521-ccdf-a8ffed0b8f5c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
 Acumatica Framework provides two types of graph event handlers: classic and generic. To declare a classic event handler, you specify the DAC name, the field name, and the type of event in the handler name. To declare a generic event handler, you specify the field name and the DAC name as type parameters of the event type. Both types of event handlers work the same.{br}

We recommend using generic event handlers because they are easier to declare, use, and validate in Visual Studio. To refactor classic event handlers into generic event handlers, you can use Acuminator.((({S:Warn}All examples in the subsequent topics demonstrate generic event handlers.
))){br}{TOC}
==Classic Event Handlers==
Classic event handlers have the following signature:[anchor|#_f2b32fac-1148-47d3-abdf-d615472e9ee2]
*For row-level events: {{{{protected virtual void [DACName]_[RowEventName](…)
}}}}
*For field-level events:{{{{public virtual void [DACName]_[FieldName]_[FieldEventName](…)
}}}}

For example, a classic handler for the <tt>RowSelected</tt> event of the {{CROpportunityProducts}} DAC is defined as follows.{{{{protected virtual void CROpportunityProducts_RowSelected(
    PXCache sender, PXRowSelectedEventArgs e) {
…}
}}}}
==Generic Event Handlers==
Generic event handlers have the following signature:[anchor|#_af847442-7cdd-4387-9a22-52fd0defc9c4]
*For the row-level events:{{{{public virtual _(Events.[RowEventName]&lt;[DACName]&gt; e)
}}}}
*:For example, a generic handler for the <tt>RowSelected</tt> event of the {{CROpportunityProducts}} DAC is defined as follows.{{{{protected virtual void _(Events.RowSelected&lt;CROpportunityProducts&gt; e)
}}}}
*For the field-level events:{{{{public virtual _(Events.[FieldEventName]&lt;[DACName], [FieldName]&gt; e)
}}}}
*:For example, a generic handler for the <tt>FieldUpdated</tt> event of the {{CROpportunityProducts.contactID}} field is defined as follows.{{{{protected virtual void _(Events.FieldUpdated&lt;CROpportunityProducts.contactID&gt; e)
}}}}
*:Specifying the DAC name as a parameter is optional because the system determines it automatically based on the field name. You should specify the DAC name explicitly if the field is inherited and you want to declare an event handler for the inherited field. For example, the <tt>FieldDefaulting</tt> event handler for the {{CurrencyInfo.moduleCode}} field looks as follows.{{{{protected override void _(Events.FieldDefaulting&lt;CurrencyInfo, 
  CurrencyInfo.moduleCode&gt; e)
}}}}

You can declare more than one handler for the same event by adding a custom name (for example, a number) after the event name as follows.{{{{public virtual _(Events.[EventName]2&lt;[DACName], [FieldName]&gt; e)
}}}}
The following example shows the second event handler for the <tt>FieldUpdated</tt> event of the {{CROpportunityProducts.contactID}} field.{{{{protected virtual void _(Events.FieldUpdated2&lt;CROpportunityProducts.contactID&gt; e)
}}}}
However, we do not recommend declaring more that one event handler because .NET framework does not determine the call order.]]></column>
			<column name="PlainText"><![CDATA[Types of Graph Event Handlers  Acumatica Framework provides two types of graph event handlers: classic and generic. To declare a classic         event handler, you specify the DAC name, the field name, and the type of event in the         handler name. To declare a generic event handler, you specify the field name and the DAC         name as type parameters of the event type. Both types of event handlers work the same. We recommend using generic event handlers because they are easier to declare, use, and         validate in Visual Studio. To refactor classic event handlers into generic event handlers,         you can use  Acuminator. All examples in the subsequent topics demonstrate generic event handlers. Classic Event Handlers Classic event handlers have the following signature: For row-level           events :            protected virtual void [DACName]_[RowEventName](…) For field-level           events: public virtual void [DACName]_[FieldName]_[FieldEventName](…) For example, a classic handler for the  RowSelected  event of the            CROpportunityProducts  DAC is defined as follows. protected virtual void CROpportunityProducts_RowSelected(
    PXCache sender, PXRowSelectedEventArgs e) {
…} Generic Event Handlers Generic event handlers have the following signature: For the row-level             events: public virtual _(Events.[RowEventName]<[DACName]> e) For             example, a generic handler for the  RowSelected  event of the                CROpportunityProducts  DAC is defined as           follows. protected virtual void _(Events.RowSelected<CROpportunityProducts> e) For the field-level             events: public virtual _(Events.[FieldEventName]<[DACName], [FieldName]> e) For             example, a generic handler for the  FieldUpdated  event of the                CROpportunityProducts.contactID  field is defined as             follows. protected virtual void _(Events.FieldUpdated<CROpportunityProducts.contactID> e) Specifying             the DAC name as a parameter is optional because the system determines it automatically             based on the field name. You should specify the DAC name explicitly if the field is             inherited and you want to declare an event handler for the inherited field. For example,             the  FieldDefaulting  event handler for the                CurrencyInfo.moduleCode  field looks as             follows. protected override void _(Events.FieldDefaulting<CurrencyInfo, 
  CurrencyInfo.moduleCode> e) You can declare more than one handler for the same event by adding a custom name (for         example, a number) after the event name as follows. public virtual _(Events.[EventName]2<[DACName], [FieldName]> e) The following example shows the second event handler for the            FieldUpdated  event of the            CROpportunityProducts.contactID  field. protected virtual void _(Events.FieldUpdated2<CROpportunityProducts.contactID> e) However, we do not recommend declaring more that one event handler because .NET framework         does not determine the call order. ]]></column>
		</row>
		<row PageID="4a062f32-f55b-4e0e-bc04-aa38683a69b5" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="bd145f64-f645-8164-4fc4-e1a632c8aefe" RecordSourceID="22377">
			<column name="Content"><![CDATA[In this topic, you can find information about how event handlers are executed and how to add and remove event handlers at runtime.{br}{TOC}
==Execution of Event Handlers ==
All event handlers for a particular event share the same <tt>PXCache</tt> instance that has raised this event. The system creates a <tt>PXCache</tt> instance to control the modified data records of a particular data access class (DAC) type. The <tt>PXCache</tt> instance is always available as the first argument in an event handler; the second argument provides the specific data that corresponds to the event.{br}

Once an event is raised, the order in which the associated event handlers are executed may differ. For some events, the chain of graph event handlers is executed before the attribute event handlers are; the attribute event handlers are executed only if the <tt>Cancel</tt> property of the event arguments doesn&rsquo;t equal <tt>true</tt> after the execution of the graph event handlers.{br}

For other events, the attribute event handlers are executed first, and the graph event handlers are executed next. The topics in the [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3ce58733-bf9c-d909-ae69-01db28ec45f6|PX.Data Delegates] section in the API Reference for each event shows the order in which the system invokes handlers for a particular event.
==Dynamic Addition of Event Handlers ==
A business logic controller (BLC) includes the collections of graph event handlers for all events except <tt>CacheAttached</tt>. Each of these collections holds event handlers for a particular event and has the same name as the event. (You can find more information about how these collections are initialized in the [[#_57644a4b-f2b5-4ff0-bf72-622bf84d90f7|Initialization of an Event Handler Collection] section in this topic.) By using the methods of these collections, you can add and remove graph event handlers in code at runtime.{br}

A method added as an event handler must have the signature of a graph event handler, but doesn&rsquo;t need to follow the naming convention for graph event handlers. If you want to add a method as an event handler, you invoke the {{AddHandler<>()}} method on the corresponding collection. For example, if the event is related to a row, it is invoked as follows.<source lang="csharp">RowEventName.AddHandler&lt;DACName&gt;(MethodName);</source>
The event is invoked as follows if it is related to a field.{{{{FieldEventName.AddHandler&lt;DACName.fieldName&gt;(MethodName);
}}}}{br}

When the {{AddHandler<>()}} method is invoked, event handlers are added to the collection as follows:[anchor|#ul_knk_frs_3k]
*Event handlers are added to the beginning of the collection for any event whose name ends with ''ing'' except the <tt>RowSelecting</tt> event.
*Event handlers are added to the end of the collection for any event whose name ends with ''ed'' and for the <tt>RowSelecting</tt> event.
{br}

To remove a handler, you should invoke the {{RemoveHandler<>()}} method.[anchor|#_57644a4b-f2b5-4ff0-bf72-622bf84d90f7]
==Initialization of an Event Handler Collection==
On each round trip, the <tt>PXGraph()</tt> constructor does the following while it initializes a graph instance:[anchor|#_a88e41fe-9e2d-418d-8e95-5e90f4b3960a]
#Creates the <tt>Cashes</tt>, <tt>Views</tt>, and <tt>Actions</tt> collections and other required collections. All of these collections are initially empty.
#If the graph instance is being created on the Acumatica ERP server for the first time:
##Obtains the metadata of this graph from the appropriate assembly (which is <tt>PX.Objects</tt> for most graphs in the application).
##By using the metadata, emits the <tt>InitializeDelegate</tt> method, which is designed to subscribe event handlers and to initialize graph views, caches, and actions. To process the metadata for the fields declared in the graph, the constructor invokes the <tt>PXGraph.ProcessFields</tt> static method. To process the metadata of the methods that are defined in the graph, the constructor invokes the <tt>PXGraph.ProcessMethods</tt> static method.
##:((({S:Warn}The <tt>ProcessMethods</tt> method processes the metadata of the methods that are declared in the graph and all extensions of the graph. According to the naming convention for event handlers, the ''&#95;'' symbol is a separator, so this method tries to split the name of each processed method into segments. If the name of the processed method has fewer than two segments or more than three segments, the processed method is skipped.{br}

If the name of the processed method adheres to the naming convention for record event handlers, the processed method is added to the <tt>&#95;EventsRow</tt> collection of the <tt>PXCache&lt;DACName&gt;</tt> object that is instantiated in the graph instance based on the DAC declaration. For example, the <tt>SOOrder&#95;RowSelected</tt> event handler is added to the <tt>&#95;EventsRow</tt> collection of the <tt>PXCache&lt;SOOrder&gt;</tt> cache object as an element with the <tt>RowSelected</tt> key.{br}

If the name of the processed method adheres to the naming convention for field event handlers, the processed method is added to the ''<tt>EventName</tt>'' <tt>Events</tt> collection of the <tt>PXCache&lt;DACName&gt;</tt> object. For example, the <tt>SOOrder&#95;CustomerID&#95;FieldUpdated </tt> event handler is added to the <tt>FieldUpdatedEvents</tt> collection of the <tt>PXCache&lt;SOOrder&gt;</tt> cache object as an element with the <tt>CustomerID</tt> key.
)))
##Saves the graph metadata and the <tt>InitializeDelegate</tt> emitted method in the Acumatica ERP server memory as the <tt>GraphStaticInfo</tt> static object shared for the entire application instance.
#From the <tt>GraphStaticInfo</tt> static object, invokes the <tt>InitializeDelegate</tt> method, which initializes graph views, caches, and actions; the method also adds event handler delegates to the appropriate event handler collections of the relevant <tt>PXCache</tt> objects.
{br}

The following diagram shows how an instance of the <tt>PX.Objects.SO.SOOrderEntry</tt> graph uses the <tt>PX.Objects</tt> assembly metadata to add the <tt>SOOrder&#95;CustomerID&#95;FieldUpdated() </tt> event handler (described in the graph and graph extensions) to the <tt>FieldUpdatedEvents</tt> collection of the <tt>PXCache&lt;SOOrder&gt;</tt> cache object.[anchor|#_6c5e505a-e960-473c-a292-205f398b72fe][anchor|#_059e8d12-89c1-400c-9fe1-cd7564fef1b1][image:StudioDeveloperGuide/Images/REF_Event_Handler_NamingConventions_01.png|popup|Addition of an event handler to the appropriate collection|450px]In the collection, the <tt>CustomerID</tt> field name is used as a key, and the delegate of the event handler sequence for the field processing is used as a value.]]></column>
			<column name="PlainText"><![CDATA[Execution of Event Handlers In this topic, you can find information about how event handlers are    executed and how to add and remove event handlers at runtime. Execution of Event Handlers  All event handlers for a particular event share the same  PXCache  instance     that has raised this event. The system creates a  PXCache  instance to control     the modified data records of a particular data access class (DAC) type. The       PXCache  instance is always available as the first argument in an event     handler; the second argument provides the specific data that corresponds to the event. Once an event is raised, the order in which the associated event handlers are executed may     differ. For some events, the chain of graph event handlers is executed before the attribute     event handlers are; the attribute event handlers are executed only if the       Cancel  property of the event arguments doesn't equal  true      after the execution of the graph event handlers. For other events, the attribute event handlers are executed first, and the graph event     handlers are executed next. The topics in the  PX.Data Delegates PX.Data Delegates section in the API Reference for each     event shows the order in which the system invokes handlers for a particular event. Dynamic Addition of Event Handlers  A business logic controller (BLC) includes the collections of graph event handlers for all     events except  CacheAttached . Each of these collections holds event handlers     for a particular event and has the same name as the event. (You can find more information about     how these collections are initialized in the  Initialization of an Event Handler Collection Initialization of an Event Handler Collection section in this topic.) By using the methods of these collections, you can add     and remove graph event handlers in code at runtime. A method added as an event handler must have the signature of a graph event handler, but     doesn't need to follow the naming convention for graph event handlers. If you want to add a     method as an event handler, you invoke the  AddHandler<>()  method on the     corresponding collection. For example, if the event is related to a row, it is invoked as     follows. RowEventName.AddHandler<DACName>(MethodName); The event is invoked as follows if it is related to a field. FieldEventName.AddHandler<DACName.fieldName>(MethodName); When the  AddHandler<>()  method is invoked, event handlers are added to     the collection as follows: Event handlers are added to the beginning of the collection for any event whose name ends      with  ing  except the  RowSelecting  event. Event handlers are added to the end of the collection for any event whose name ends with        ed  and for the  RowSelecting  event. To remove a handler, you should invoke the  RemoveHandler<>()      method. Initialization of an Event Handler Collection On each round trip, the  PXGraph()  constructor does the following while it     initializes a graph instance: Creates the  Cashes ,  Views , and         Actions  collections and other required collections. All of these       collections are initially empty. If the graph instance is being created on the  Acumatica ERP       server for the first time: Obtains the metadata of this graph from the appropriate assembly (which is           PX.Objects  for most graphs in the application). By using the metadata, emits the  InitializeDelegate  method, which is         designed to subscribe event handlers and to initialize graph views, caches, and actions. To         process the metadata for the fields declared in the graph, the constructor invokes the           PXGraph.ProcessFields  static method. To process the metadata of the         methods that are defined in the graph, the constructor invokes the           PXGraph.ProcessMethods  static method. The  ProcessMethods  method processes the metadata of the methods that           are declared in the graph and all extensions of the graph. According to the naming           convention for event handlers, the  _  symbol is a separator, so this method tries to           split the name of each processed method into segments. If the name of the processed method           has fewer than two segments or more than three segments, the processed method is           skipped. If the name of the processed method adheres to the naming convention for record event           handlers, the processed method is added to the  _EventsRow  collection of           the  PXCache<DACName>  object that is instantiated in the graph           instance based on the DAC declaration. For example, the             SOOrder_RowSelected  event handler is added to the             _EventsRow  collection of the  PXCache<SOOrder>            cache object as an element with the  RowSelected  key. If the name of the processed method adheres to the naming convention for field event           handlers, the processed method is added to the             EventName Events  collection of the             PXCache<DACName>  object. For example, the             SOOrder_CustomerID_FieldUpdated   event handler is added to the             FieldUpdatedEvents  collection of the             PXCache<SOOrder>  cache object as an element with the             CustomerID  key. Saves the graph metadata and the  InitializeDelegate  emitted method in         the  Acumatica ERP server memory as the  GraphStaticInfo  static object shared for the         entire application instance. From the  GraphStaticInfo  static object, invokes the         InitializeDelegate  method, which initializes graph views, caches, and       actions; the method also adds event handler delegates to the appropriate event handler       collections of the relevant  PXCache  objects. The following diagram shows how an instance of the       PX.Objects.SO.SOOrderEntry  graph uses the  PX.Objects      assembly metadata to add the  SOOrder_CustomerID_FieldUpdated()   event     handler (described in the graph and graph extensions) to the       FieldUpdatedEvents  collection of the  PXCache<SOOrder>      cache object. Addition of an event handler to the appropriate collection In the collection, the  CustomerID  field name is used as a key, and the     delegate of the event handler sequence for the field processing is used as a value. ]]></column>
		</row>
		<row PageID="d316d773-1548-4a23-b542-a4bf7aa4ecc6" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="88e8a0f3-343d-69c7-0f01-167f7fa7dcf1" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can override an event handler by calling the base method or without calling it. To override an event handler without invocation of the base method, use code based on the following template.{{{{protected virtual _(Events.[EventName]&lt;[DACName], [FieldName]&gt; e) 
{
  … 
}
}}}}
To override an event handler with invocation of the base method, use code based on the following template.{{{{protected virtual void _(
    Events.[EventName]&lt;[DACName], [FieldName]&gt; e, 
    PX[EventName] baseMethod)
{
  baseMethod(e.Cache, e.Args);
  … 
}
}}}}((({S:Warn}For a base method, you should provide two parameters because a base method is a classic interceptor delegate, not a generic one. For details, see [HelpRoot_Dev_Platform\BL__con_Events_Types|Types of Graph Event Handlers].
)))
For example, to override an event handler for the <tt>RowSelected</tt> event of the {{CurrencyInfo}} class, use the following code. {{{{protected virtual void _(Events.RowSelected&lt;CurrencyInfo&gt; e, PXRowSelected baseMethod)
{
  baseMethod(e.Cache, e.Args);
}
}}}}{br}{TOC}]]></column>
			<column name="PlainText"><![CDATA[Override of Event Handlers You can override an event handler by calling the base method or without calling it. To         override an event handler without invocation of the base method, use code based on the         following template. protected virtual _(Events.[EventName]<[DACName], [FieldName]> e) 
{
  … 
} To override an event handler with invocation of the base method, use code based on the         following template. protected virtual void _(
    Events.[EventName]<[DACName], [FieldName]> e, 
    PX[EventName] baseMethod)
{
  baseMethod(e.Cache, e.Args);
  … 
} For a base method, you should provide two parameters because a base method is a classic     interceptor delegate, not a generic one. For details, see  Types of Graph Event Handlers. For example, to override an event handler for the  RowSelected  event of the            CurrencyInfo  class, use the following code.  protected virtual void _(Events.RowSelected<CurrencyInfo> e, PXRowSelected baseMethod)
{
  baseMethod(e.Cache, e.Args);
} ]]></column>
		</row>
		<row PageID="d9cf6274-f5c8-43e7-9d13-9b423113d67e" Language="en-US" PageRevisionID="1" PlainText="Data Manipulation Scenarios Most events are raised within common scenarios related to the manipulation of data records. The       scenarios are invoked by  Acumatica Framework       when users perform certain actions in the user interface, when the corresponding requests are       made to the web services API, and when special methods are executed within the business logic       controller (BLC). The following diagram shows how different types of event handlers are invoked. Use of event handlers while the basic data operations are processed For details on how  Acumatica Framework       processes the basic data operations, see the following topics: Sequence of Events: Insertion of a Data RecordSequence of Events: Update of a Data RecordSequence of Events: Deletion of a Data RecordSequence of Events: Display of a Data RecordSequence of Events: Saving of Changes to the Database" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="168127ad-706a-c79a-0648-b38e80d2a0a6" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Most events are raised within common scenarios related to the manipulation of data records. The scenarios are invoked by Acumatica Framework when users perform certain actions in the user interface, when the corresponding requests are made to the web services API, and when special methods are executed within the business logic controller (BLC).{br}

The following diagram shows how different types of event handlers are invoked.[anchor|#fig_gby_gwm_4v][anchor|#image_pjq_lwm_4v][image:StudioDeveloperGuide/Images/REF_EventsInScenarios.png|popup|Use of event handlers while the basic data operations are processed|450px]{br}

For details on how Acumatica Framework processes the basic data operations, see the following topics:
*[HelpRoot_Dev_Platform\BL__con_Events_Insert|Sequence of Events: Insertion of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Update|Sequence of Events: Update of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Delete|Sequence of Events: Deletion of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Display|Sequence of Events: Display of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Persist|Sequence of Events: Saving of Changes to the Database]
]]></column>
		</row>
		<row PageID="04839388-1c8f-4d49-888e-d3167ce3578d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="d5f1ddef-9995-4fd7-695d-73bf109aa502" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When a user creates a new data record in the UI, the system inserts it into the <tt>PXCache</tt>. To insert a data record into the <tt>PXCache</tt> in code, you invoke the <tt>Insert()</tt> method of the applicable data view, as shown in the following code example.<source lang="csharp">ShipmentLine line = new ShipmentLine();
line.ProductID = card.ProductID;
...

ShipmentLines.Insert(line);</source>
Keep in mind that calling the <tt>Insert()</tt> method of the data view is just a shortcut for the <tt>Insert()</tt> method of the <tt>Cache</tt> property of the data view.{br}

Also, in the example shown above, this method does not make the shipment line that you insert related to the current shipment; it only inserts the shipment line into the <tt>PXCache</tt> of shipment lines. The master-detail relationship between the new shipment line and the current shipment is created because of the <tt>PXDBDefault</tt> attribute of the <tt>ShipmentNbr</tt> field in the <tt>ShipmentLine</tt> DAC.{br}

The <tt>FieldDefaulting</tt> event, which is raised for each field during the insertion of a new data record, sets the default value for the data field.
==The RowInserting and RowInserted Events==
The <tt>RowInserting</tt> and <tt>RowInserted</tt> events occur during the insertion of a data record in the cache, after the field-related events have occurred. The <tt>RowInserting</tt> event happens right before the new data record is actually inserted into the <tt>PXCache</tt> object, but after all field events happen for this data record. The <tt>RowInserted</tt> event happens after the actual insertion. If, in a <tt>RowInserting</tt> event handler, you change the data fields of the data record that are inserted, no field events will be raised for these data fields.{br}

You use the <tt>RowInserted</tt> event to do something after a data record is inserted into the cache. For example, you can use a <tt>RowInserted</tt> event handler of the master data record to add a default detail data record.{br}

For details on the order in which events are executed during the insertion of a data record into <tt>PXCache</tt>, see [HelpRoot_Dev_Platform\BL__con_Events_Insert|Sequence of Events: Insertion of a Data Record].]]></column>
			<column name="PlainText"><![CDATA[Insertion of a Data Record When a user creates a new data record in the UI, the system inserts it into the            PXCache . To insert a data record into the  PXCache  in         code, you invoke the  Insert()  method of the applicable data view, as         shown in the following code example. ShipmentLine line = new ShipmentLine();
line.ProductID = card.ProductID;
...

ShipmentLines.Insert(line); Keep in mind that calling the  Insert()  method of the data view is just a         shortcut for the  Insert()  method of the  Cache  property         of the data view. Also, in the example shown above, this method does not make the shipment line that you         insert related to the current shipment; it only inserts the shipment line into the            PXCache  of shipment lines. The master-detail relationship between the         new shipment line and the current shipment is created because of the            PXDBDefault  attribute of the  ShipmentNbr  field in         the  ShipmentLine  DAC. The  FieldDefaulting  event, which is raised for each field during the         insertion of a new data record, sets the default value for the data field. The RowInserting and RowInserted Events The  RowInserting  and  RowInserted  events occur during         the insertion of a data record in the cache, after the field-related events have occurred.         The  RowInserting  event happens right before the new data record is         actually inserted into the  PXCache  object, but after all field events         happen for this data record. The  RowInserted  event happens after the         actual insertion. If, in a  RowInserting  event handler, you change the         data fields of the data record that are inserted, no field events will be raised for these         data fields. You use the  RowInserted  event to do something after a data record is         inserted into the cache. For example, you can use a  RowInserted  event         handler of the master data record to add a default detail data record. For details on the order in which events are executed during the insertion of a data record         into  PXCache , see  Sequence of Events: Insertion of a Data Record. ]]></column>
		</row>
		<row PageID="d648f7e1-6680-4252-9a41-2ed03e48ca0a" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ed427b2f-e9f0-57eb-7922-55e64313d33e" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When you modify a data record in code, you should update the data record in the cache by calling the <tt>Update()</tt> method of the data view or cache. When the user modifies data fields in the UI and the modifications are committed to the server, the <tt>Update()</tt> method is called automatically.{br}

During the execution of the <tt>Update()</tt> method, the cache raises a number of events: first the field-level events, and then the row-level events. During the update process, you have access to the modified version of the data record through the <tt>NewRow</tt> property of event arguments in <tt>RowUpdating</tt> event handlers or the <tt>Row</tt> property in other event handlers.((({S:Warn}In a <tt>FieldUpdated</tt> event handler, you can modify a field of the data record passed as <tt>e.Row</tt>. In this case, you don&rsquo;t have to call the <tt>Update()</tt> method; if you do, an infinite loop will occur.
)))
For details on the order in which events are executed during update of a data record, see [HelpRoot_Dev_Platform\BL__con_Events_Update|Sequence of Events: Update of a Data Record].]]></column>
			<column name="PlainText"><![CDATA[Update of a Data Record When you modify a data record in code, you should update the data record in the cache by         calling the  Update()  method of the data view or cache. When the user         modifies data fields in the UI and the modifications are committed to the server, the            Update()  method is called automatically. During the execution of the  Update()  method, the cache raises a number         of events: first the field-level events, and then the row-level events. During the update         process, you have access to the modified version of the data record through the            NewRow  property of event arguments in  RowUpdating          event handlers or the  Row  property in other event handlers. In a  FieldUpdated  event handler, you can modify a field of the data         record passed as  e.Row . In this case, you don't have to call the            Update()  method; if you do, an infinite loop will occur. For details on the order in which events are executed during update of a data record, see            Sequence of Events: Update of a Data Record. ]]></column>
		</row>
		<row PageID="b33fc498-1d8e-45e2-b662-138452599b9d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="361e90ba-007b-04d2-dba2-b107553b9f39" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When a user deletes a data record through the user interface, the system calls the <tt>Delete()</tt> method of the corresponding cache. If you need to delete a data record in code, you should also call the <tt>Delete()</tt> method of <tt>PXCache</tt> or of the data view (which simply calls the <tt>Delete()</tt> method of <tt>PXCache</tt>).{br}

While a data record is being deleted, the cache raises a number of events. Before the <tt>RowDeleting</tt> and <tt>RowDeleted</tt> events are triggered, the data record is placed in the cache and assigned the <tt>Deleted</tt> status or the <tt>InsertedDeleted</tt> status (which means that the data record has been inserted but has not yet been saved to the database). If the delete operation is canceled, the data record will revert to the previous state and the <tt>RowDeleted</tt> event won&rsquo;t be raised.{br}

The sequence of events raised during the deletion of a data record is shown in [HelpRoot_Dev_Platform\BL__con_Events_Delete|Sequence of Events: Deletion of a Data Record]. ]]></column>
			<column name="PlainText"><![CDATA[Removal of a Data Record When a user deletes a data record through the user interface, the system calls the            Delete()  method of the corresponding cache. If you need to delete a         data record in code, you should also call the  Delete()  method of            PXCache  or of the data view (which simply calls the            Delete()  method of  PXCache ). While a data record is being deleted, the cache raises a number of events. Before the            RowDeleting  and  RowDeleted  events are triggered, the         data record is placed in the cache and assigned the  Deleted  status or the            InsertedDeleted  status (which means that the data record has been         inserted but has not yet been saved to the database). If the delete operation is canceled,         the data record will revert to the previous state and the  RowDeleted          event won't be raised. The sequence of events raised during the deletion of a data record is shown in  Sequence of Events: Deletion of a Data Record.  ]]></column>
		</row>
		<row PageID="91f58a54-6929-4a5f-aeba-7f79d16f62db" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="78abcfde-860c-d175-6033-58f0b5039acc" RecordSourceID="22377">
			<column name="Content"><![CDATA[
A graph provides transactional saving of changes from all cache objects to the database. The graph commits the data to the database when you invoke the <tt>Actions.PressSave()</tt> method of the graph or when the user clicks '''Save''' in the UI. In both cases, the <tt>Persist()</tt> method of the graph is invoked. The <tt>Actions.PressSave()</tt> method also verifies that the <tt>Save</tt> action exists in the graph and is enabled. The <tt>Save</tt> action then invokes the <tt>Persist()</tt> method.((({S:Warn}To save changes on the form to the database, you should use the <tt>Actions.PressSave()</tt> method. To save changes without pressing the <tt>Save</tt> button, you can use the <tt>Persist()</tt> method. You should not invoke the <tt>Persist()</tt> method on the current graph instance. (You can invoke this method for only a graph instance created in a background operation.) 
)))
The graph commits changes from all cache objects within a single database transaction. If any row modification fails, the entire transaction is rolled back, and no changes from any cache object are persisted.{br}

In the <tt>Persist()</tt> method, the system starts the database transaction (see the diagram below). Within the transaction, the graph iterates the collection of cache objects three times: for inserted records, for updated records, and for deleted records. First, all new records from all cache objects are inserted, and then all modified records are updated. Finally, within the same transaction, all deleted records are removed from the database. The graph iterates the collection of caches so that all master records are saved and then all detail records are saved.((({S:Warn}For new records and updated records, the graph iterates the collection of caches in the order in which the data views are declared in the graph. That&rsquo;s why in the graph, the master data view must be declared before the detail data view. For deleted records, the graph iterates the collection of caches in the reverse order. The graph access the caches through the <tt>Views.Caches</tt> collection, which is formed from the main DACs of all data views declared in the graph.
)))
In each iteration, the framework raises the <tt>RowPersisting</tt> event for a data record, executes the appropriate SQL command for this data record within the transaction, and then raises the <tt>RowPersisted</tt> event with the ''Open'' transaction status.{br}

When the SQL commands have been executed successfully for all modified (inserted, updated, or deleted) data records, the graph commits the transaction. Regardless of the result of the transaction, the graph raises the <tt>RowPersisted</tt> event, in which you can check the status of the transaction. A successful transaction has the <tt>Completed</tt> status. If an error or exception has occurred during the transaction, the transaction returns the <tt>Aborted</tt> status. If the transaction fails, the modified data remains in cache objects. On the <tt>RowPersisted</tt> event for an aborted transaction, you can revert changed records to the default values.[anchor|#image_c3f_2w5_lm][image:StudioDeveloperGuide/Images/SavingChangestoDB.png|popup|The process of saving changes from cache objects to the database|450px]
When the <tt>RowPersisting</tt> event is raised, you can cancel the saving of a particular row to the database by setting the <tt>e.Cancel</tt> property to {{true}} in the graph handler for the event. For the sequence of events raised for each modified row within the <tt>Persist()</tt> method of the graph, see [HelpRoot_Dev_Platform\BL__con_Events_Persist|Sequence of Events: Saving of Changes to the Database].]]></column>
			<column name="PlainText"><![CDATA[Saving of Changes to the Database A graph provides transactional saving of changes from all cache objects to the database.         The graph commits the data to the database when you invoke the            Actions.PressSave()  method of the graph or when the user clicks            Save  in the UI. In both cases, the  Persist()          method of the graph is invoked. The  Actions.PressSave()  method also         verifies that the  Save  action exists in the graph and is enabled. The            Save  action then invokes the  Persist()  method. To save changes on the form to the database, you should use the            Actions.PressSave()  method. To save changes without pressing the            Save  button, you can use the  Persist()  method. You         should not invoke the  Persist()  method on the current graph instance.         (You can invoke this method for only a graph instance created in a background operation.)  The graph commits changes from all cache objects within a single database transaction. If         any row modification fails, the entire transaction is rolled back, and no changes from any         cache object are persisted. In the  Persist()  method, the system starts the database transaction (see         the diagram below). Within the transaction, the graph iterates the collection of cache         objects three times: for inserted records, for updated records, and for deleted records.         First, all new records from all cache objects are inserted, and then all modified records         are updated. Finally, within the same transaction, all deleted records are removed from the         database. The graph iterates the collection of caches so that all master records are saved         and then all detail records are saved. For new records and updated records, the graph iterates the collection of caches in the         order in which the data views are declared in the graph. That's why in the graph, the master         data view must be declared before the detail data view. For deleted records, the graph         iterates the collection of caches in the reverse order. The graph access the caches through         the  Views.Caches  collection, which is formed from the main DACs of all         data views declared in the graph. In each iteration, the framework raises the  RowPersisting  event for a         data record, executes the appropriate SQL command for this data record within the         transaction, and then raises the  RowPersisted  event with the  Open          transaction status. When the SQL commands have been executed successfully for all modified (inserted, updated,         or deleted) data records, the graph commits the transaction. Regardless of the result of the         transaction, the graph raises the  RowPersisted  event, in which you can         check the status of the transaction. A successful transaction has the            Completed  status. If an error or exception has occurred during the         transaction, the transaction returns the  Aborted  status. If the         transaction fails, the modified data remains in cache objects. On the            RowPersisted  event for an aborted transaction, you can revert changed         records to the default values. The process of saving changes from cache objects to the database When the  RowPersisting  event is raised, you can cancel the saving of a         particular row to the database by setting the  e.Cancel  property to            true  in the graph handler for the event. For the sequence of events         raised for each modified row within the  Persist()  method of the graph,         see  Sequence of Events: Saving of Changes to the Database. ]]></column>
		</row>
		<row PageID="5fb67bf3-6db4-498d-983c-e4fe28a65d11" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="033f8abe-c307-76b8-6fed-ae30c04dff68" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The figure below illustrates the sequence of events raised during the insertion of a data record.[anchor|#image_y35_hl1_ck][image:StudioDeveloperGuide/Images/Ref_Events_Insert.png|popup|Insertion of a data record|390px]
The system inserts a data record as an instance of a data access class (DAC) when a user creates a new data record in the user interface, a request to insert a record is sent to the web services API, or the {{Insert()}} method of a data view is called in code. The data record is actually inserted into the <tt>PXCache</tt> object that corresponds to the DAC of the data record. The inserted data record has the <tt>Inserted</tt> status and is available through the <tt>Inserted</tt> and <tt>Dirty</tt> collections of the <tt>PXCache</tt> object. {br}

When a data record is inserted, data field events are raised for each data field in the following order:[anchor|#ul_fx3_zm2_3k]
#{{FieldDefaulting}}
#{{FieldUpdating}} if the {{e.Cancel}} property equals <tt>true</tt>
#{{FieldVerifying}}
#{{FieldUpdated}}

Next, the following data record events are raised:[anchor|#ul_z5s_vp2_3k]
#{{RowInserting}} (If the {{e.Cancel}} property is {{true}}, no further events are raised.)
#{{RowSelected}}
#{{RowInserted}}

The instance of the inserted data record is available in the {{e.Row}} property of event arguments. ]]></column>
			<column name="PlainText"><![CDATA[Sequence of Events: Insertion of a Data Record The figure below illustrates the sequence of events raised during the insertion of a data         record. Insertion of a data record The system inserts a data record as an instance of a data access class (DAC) when a user         creates a new data record in the user interface, a request to insert a record is sent to the         web services API, or the  Insert()  method of a data view is called in code.         The data record is actually inserted into the  PXCache  object that         corresponds to the DAC of the data record. The inserted data record has the            Inserted  status and is available through the            Inserted  and  Dirty  collections of the            PXCache  object.  When a data record is inserted, data field events are raised for each data field in the         following order: FieldDefaulting FieldUpdating  if the  e.Cancel  property equals              true FieldVerifying FieldUpdated Next, the following data record events are raised: RowInserting  (If the  e.Cancel  property is              true , no further events are raised.) RowSelected RowInserted The instance of the inserted data record is available in the  e.Row          property of event arguments.  ]]></column>
		</row>
		<row PageID="8f77ddc6-374b-4ad9-be20-a282febf88f8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="b663a4d8-e8b9-e0bf-2196-a2386caf3537" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The figure below illustrates the sequence of events raised during the update of a data record. [anchor|#image_byf_3l1_ck][image:StudioDeveloperGuide/Images/Ref_Events_Update.png|popup|Update of a data record|390px]
A data record is updated when a user modifies the data record on the user interface, the request is sent through the Web Service API, or the {{Update()}} method is invoked on the data view. Updated data records, which the system gives the <tt>Updated</tt> status, are later available through the <tt>Updated</tt> and <tt>Dirty</tt> collections of the appropriate <tt>PXCache</tt> object.{br}

The <tt>RowUpdating</tt> event is fired before the update happens, while the <tt>RowUpdated</tt> event is fired after the update. The developer can handle these events and has access to the updated data record and the previous version of the data record that is kept in the <tt>PXCache</tt> object. The actual update happens between these two events when the data record is copied to the <tt>PXCache</tt> object.{br}

When a data record is updated, the following data field events are raised for each updated data field:[anchor|#ul_t1k_sq2_3k]
#{{FieldUpdating}}
#{{FieldVerifying}}
#{{FieldUpdated}}
Next, data record events are raised as follows:[anchor|#ul_tzy_5q2_3k]
#{{RowUpdating}} is raised. At this moment, in the {{e}} variable, which represents event data, {{e.Row}} holds the data record version from the cache, while {{e.NewRow}} holds the updated data record. You can still stop the update by throwing a <tt>PXException</tt> instance.
#If {{e.Cancel}} doesn&rsquo;t equal {{true}}:
##{{RowSelected}} is raised. Only the updated data record can be accessed through {{e.Row}}.
##{{RowUpdated}} is raised. {{e.Row}} now holds the updated instance, while {{e.OldRow}} holds a copy of the old data record with the previous values.
]]></column>
			<column name="PlainText"><![CDATA[Sequence of Events: Update of a Data Record The figure below illustrates the sequence of events raised during the update of a data         record.  Update of a data record A data record is updated when a user modifies the data record on the user interface, the         request is sent through the Web Service API, or the  Update()  method is         invoked on the data view. Updated data records, which the system gives the            Updated  status, are later available through the            Updated  and  Dirty  collections of the appropriate            PXCache  object. The  RowUpdating  event is fired before the update happens, while the            RowUpdated  event is fired after the update. The developer can handle         these events and has access to the updated data record and the previous version of the data         record that is kept in the  PXCache  object. The actual update happens         between these two events when the data record is copied to the  PXCache          object. When a data record is updated, the following data field events are raised for each updated         data field: FieldUpdating FieldVerifying FieldUpdated Next, data record events are raised as follows: RowUpdating  is raised. At this moment, in the  e              variable, which represents event data,  e.Row  holds the data record             version from the cache, while  e.NewRow  holds the updated data record.             You can still stop the update by throwing a  PXException              instance. If  e.Cancel  doesn't equal  true : RowSelected  is raised. Only the updated data record can be                 accessed through  e.Row . RowUpdated  is raised.  e.Row  now holds the                 updated instance, while  e.OldRow  holds a copy of the old data                 record with the previous values. ]]></column>
		</row>
		<row PageID="0d160007-252e-44f8-a9cd-25b40b786dc1" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="d9113c16-08a4-cf7b-90c3-cdb9493e2577" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The figure below illustrates the sequence of events raised during the deletion of a data record.[anchor|#image_g14_3l1_ck][image:StudioDeveloperGuide/Images/Ref_Events_Delete.png|popup|Deletion of a data record|330px]
A data record is deleted when a user deletes the record on the user interface, the deletion request is sent through the Web Service API, or the {{Delete()}} method of a data view is invoked in code. As a result of the deletion, the data record gets the <tt>Deleted</tt> status if it already exists in the database, or the <tt>InsertedDeleted</tt> status if the record has just been inserted into the <tt>PXCache</tt> object and deletion from the database is not required. The data record is later available through the <tt>Deleted</tt> and <tt>Dirty</tt> collections of the <tt>PXCache</tt> object. {br}

If the deletion has been initiated by a user on the UI or through the web services API, the following field events are raised for each key data field before any other events are raised:[anchor|#ul_bd4_qdf_3k]
#{{FieldUpdating}}
#{{FieldUpdated}}

Next, regardless of how the deletion was initiated, data record events are raised as follows:[anchor|#ul_ozf_5df_3k]
#{{RowDeleting}} is raised. At this point, the developer can still stop the deletion by throwing a <tt>PXException</tt> instance. In the {{e}} variable representing event data, {{e.Row}} holds the data record being deleted.
#If {{e.Cancel}} doesn&rsquo;t equal {{true}}:
##{{RowDeleted}} is raised, and {{e.Row}} still holds the data record.
##{{RowSelected}} is raised, and {{e.Row}} equals {{NULL}}.
The data record will be reverted to the previous state and the <tt>RowDeleted</tt> event won&rsquo;t be raised if the delete operation is canceled.]]></column>
			<column name="PlainText"><![CDATA[Sequence of Events: Deletion of a Data Record The figure below illustrates the sequence of events raised during the deletion of a         data record. Deletion of a data record A data record is deleted when a user deletes the record on the user interface, the         deletion request is sent through the Web Service API, or the  Delete()          method of a data view is invoked in code. As a result of the deletion, the data record gets         the  Deleted  status if it already exists in the database, or the            InsertedDeleted  status if the record has just been inserted into the            PXCache  object and deletion from the database is not required. The data         record is later available through the  Deleted  and            Dirty  collections of the  PXCache  object.  If         the deletion has been initiated by a user on the UI or through the web services API, the         following field events are raised for each key data field before any other events are         raised: FieldUpdating FieldUpdated Next, regardless of how the deletion was initiated, data record events are raised as         follows: RowDeleting  is raised. At this point, the developer can still stop the           deletion by throwing a  PXException  instance. In the  e            variable representing event data,  e.Row  holds the data record being           deleted. If  e.Cancel  doesn't equal  true : RowDeleted  is raised, and  e.Row  still holds the               data record. RowSelected  is raised, and  e.Row  equals                  NULL . The data record will be reverted to the previous state and the          RowDeleted  event won't be raised if the delete operation is       canceled. ]]></column>
		</row>
		<row PageID="02e8c036-30e7-4cca-86bd-b0dc47626793" Language="en-US" PageRevisionID="1" Content="&#xA;Each time a data record is displayed in the user interface or retrieved through the Web Service API, the {{RowSelected}} and {{FieldSelecting}} events are raised for each data field. For both events, the {{e.Row}} property of event arguments holds the data record that is being displayed or retrieved. {br}&#xA;&#xA;The diagram below illustrates this process in more detail.[anchor|#image_gy5_3l1_ck][image:StudioDeveloperGuide/Images/Ref_Events_Display.png|popup|Display of a data record|450px]" PlainText="Sequence of Events: Display of a Data Record Each time a data record is displayed in the user interface or retrieved through the Web         Service API, the  RowSelected  and  FieldSelecting  events are         raised for each data field. For both events, the  e.Row  property of event         arguments holds the data record that is being displayed or retrieved.  The diagram below illustrates this process in more detail. Display of a data record " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="0983591c-0cd8-087c-86c1-a1c38a7897f6" RecordSourceID="22377" />
		<row PageID="e08a2496-d5fc-416a-966c-4a8b6332345c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="df2e875f-4b74-0687-c51d-dfb9327e6d61" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The following figure illustrates the sequence of events that are raised when a data record is saved.[anchor|#image_jx3_jl1_ck][image:StudioDeveloperGuide/Images/Ref_Events_Persist.png|popup|Save (commit) of a data record to the database|350px]
While a user is inserting, updating, or deleting a data record, no changes are committed to the database. The system stores the modified data records in the session, and you can access them through the appropriate <tt>PXCache</tt> object. The system commits the changes to the database when the user clicks '''Save''' in the user interface, the save request is sent through the Web Service API, or {{Actions.PressSave()}} is invoked on the business logic controller (BLC) instance. In both cases, the <tt>Persist()</tt> method of the graph is invoked. The <tt>Actions.PressSave()</tt> method additionally checks that the <tt>Save</tt> action exists in the graph and is enabled. The <tt>Save</tt> action then invokes the <tt>Persist()</tt> method.{br}

When changes are saved to the database, events are raised as follows:[anchor|#ul_oqx_g3f_3k]
#{{RowPersisting}} is raised. At this moment, a database transaction has already been opened. If any of the handlers sets {{e.Cancel}} to {{true}}, the process will be canceled for the currently processed data record without an error being reported to the user. To cancel the process of committing changes and indicate the error to the user, you should throw the <tt>PXException</tt> exception.
#If {{e.Cancel}} doesn&rsquo;t equal {{true}}:
##{{RowPersisted}} is raised. The commit operation for the current data record (available through {{e.Row}} in the handler) is completed, but the transaction is still open: {{e.TranStatus}} equals {{Open}}.
##{{RowPersisted}} is raised one more time, either with {{e.TranStatus}} equal to {{Completed}} (if all changes have been saved successfully) or with {{e.TranStatus}} equal to {{Aborted}} if an error has occurred and all changes have been canceled.

==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=05ec8787-e83f-dbf2-228f-d6bb45870781|Persist() Method]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d302caf7-87a4-d7e4-65b3-c463f4d62ee3|PXRowPersisting Delegate]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ac686a56-ea6d-5ece-1063-a2842fb9aaa0|PXRowPersisted Delegate]]]></column>
			<column name="PlainText"><![CDATA[Sequence of Events: Saving of Changes to the Database The following figure illustrates the sequence of events that are raised when a data record         is saved. Save (commit) of a data record to the database While a user is inserting, updating, or deleting a data record, no changes are committed to         the database. The system stores the modified data records in the session, and you can access         them through the appropriate  PXCache  object. The system commits the         changes to the database when the user clicks  Save  in the user         interface, the save request is sent through the Web Service API, or            Actions.PressSave()  is invoked on the business logic controller (BLC)         instance. In both cases, the  Persist()  method of the graph is invoked.         The  Actions.PressSave()  method additionally checks that the            Save  action exists in the graph and is enabled. The            Save  action then invokes the  Persist()  method. When changes are saved to the database, events are raised as follows: RowPersisting  is raised. At this moment, a database transaction has           already been opened. If any of the handlers sets  e.Cancel  to              true , the process will be canceled for the currently processed data           record without an error being reported to the user. To cancel the process of committing           changes and indicate the error to the user, you should throw the              PXException  exception. If  e.Cancel  doesn't equal  true : RowPersisted  is raised. The commit operation for the current data               record (available through  e.Row  in the handler) is completed, but the               transaction is still open:  e.TranStatus  equals                Open . RowPersisted  is raised one more time, either with                  e.TranStatus  equal to  Completed  (if all changes               have been saved successfully) or with  e.TranStatus  equal to                  Aborted  if an error has occurred and all changes have been               canceled. Persist() Method PXRowPersisting Delegate PXRowPersisted Delegate ]]></column>
		</row>
		<row PageID="abe22b44-8111-4069-8a24-fa5c901ec5dd" Language="en-US" PageRevisionID="1" PlainText="List of Events In this topic, you can find the list of all events by category. You can get more         information about any of these events by navigating to the applicable topic in the API         Reference. Data Field Events PXFieldDefaulting PXFieldDefaultingPXFieldVerifying PXFieldVerifyingPXFieldUpdating PXFieldUpdatingPXFieldUpdated PXFieldUpdatedPXFieldSelecting PXFieldSelectingData Record Events PXRowSelected PXRowSelectedPXRowInserting PXRowInsertingPXRowInserted PXRowInsertedPXRowUpdating PXRowUpdatingPXRowUpdated PXRowUpdatedPXRowDeleting PXRowDeletingPXRowDeleted PXRowDeletedDatabase-Related Events PXCommandPreparing PXCommandPreparingPXRowSelecting PXRowSelectingPXRowPersisting PXRowPersistingPXRowPersisted PXRowPersistedException-Handling Event PXExceptionHandling PXExceptionHandlingEvent for Overriding DAC Field Attributes CacheAttached CacheAttached" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="5a3fa117-3676-eb63-ae85-4bb7d1a19999" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can find the list of all events by category. You can get more information about any of these events by navigating to the applicable topic in the API Reference.
==Data Field Events==[anchor|#_e1d0a3a3-e5e7-4c1e-bb88-6866cdb5c617]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6db70fe7-3fc3-4e05-d3a6-5ecb93bea6a9|PXFieldDefaulting]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c7a01517-1072-6780-430f-b89a9d305072|PXFieldVerifying]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=cca7462c-8f4b-9ada-03b0-17fd2832d009|PXFieldUpdating]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9048a6d5-41a0-a5bd-9b78-7ce9833114b2|PXFieldUpdated]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7afeed34-d321-02e8-bc8a-853d66732de3|PXFieldSelecting]

==Data Record Events==[anchor|#_70b54f4a-fc4a-45a5-9119-01185b11b977]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=bf5181e8-fc0f-0386-1871-711e7c29ccc7|PXRowSelected]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a086e293-dd12-789c-386a-7f6cbcd56ca2|PXRowInserting]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=08743ca9-5121-b910-b432-7306ebe02cd2|PXRowInserted]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=787ff1db-8126-07e2-3e17-85bce318589c|PXRowUpdating]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fcb1a36f-0dce-61ca-a67e-7d7bf6117948|PXRowUpdated]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=2e6b60b0-de18-e687-8e33-d8176ea7f2db|PXRowDeleting]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ef249f39-058c-18de-a8f2-9ad965cfb53f|PXRowDeleted]

==Database-Related Events==[anchor|#_c106dc09-3e70-4acd-8d0a-1f58e6acbc76]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b3c881ac-7118-24c7-0a99-4edb98887cd6|PXCommandPreparing]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3914d39a-0394-c506-92b5-3bbe3b044cbb|PXRowSelecting]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d302caf7-87a4-d7e4-65b3-c463f4d62ee3|PXRowPersisting]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ac686a56-ea6d-5ece-1063-a2842fb9aaa0|PXRowPersisted]

==Exception-Handling Event==[anchor|#_2d789a0a-7482-46aa-9d87-aad53e2b8e3f]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=de7f1a9f-8bd0-84e7-3ffa-79f2d3839018|PXExceptionHandling]

==Event for Overriding DAC Field Attributes==[anchor|#_ec0692bf-152b-4502-a125-654ab11c151b]
*[https://help.acumatica.com/(W(2))/Main?ScreenId=ShowWiki&pageid=3af81acb-d7a6-3ebe-2f7d-38cc8abd302d|CacheAttached]
]]></column>
		</row>
		<row PageID="93f78385-4879-433f-808a-96c04a43757d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="d44b898d-cf0b-7a28-538d-f586d605b371" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Event handlers can be defined in a graph and in attributes. Graph event handlers and attribute event handlers may be called in a different order, depending on the event:[anchor|#ul_jvw_fyr_mm]
*For events whose names end with ''ing'', graph event handlers are called first. You can prevent the execution of attribute event handlers by setting <tt>e.Cancel</tt> to <tt>true</tt>.
*For events whose names end with ''ed'', attribute event handlers are called first.

For example, if you need to change the default value set by the <tt>PXDefault</tt> attribute for a field, you can define a <tt>FieldDefaulting</tt> event handler in the graph. In this graph event handler, you can assign a different default value and set <tt>e.Cancel</tt> to <tt>true</tt> to prevent the execution of the <tt>FieldDefaulting</tt> event handler defined in the <tt>PXDefault</tt> attribute (see the following code).<source lang="csharp">protected virtual void ShipmentLine_Gift_FieldDefaulting(
    PXCache sender, PXFieldDefaultingEventArgs e)
{
    ShipmentLine line = e.Row as ShipmentLine;
    if (line == null) return;

    Product card = GiftCard.Select();
    if (card != null && line.ProductID == card.ProductID)
    {
        e.NewValue = true;
        <b>e.Cancel = true;<b>
    }
}</source>]]></column>
			<column name="PlainText"><![CDATA[Cancellation of Attribute Event Handlers Event handlers can be defined in a graph and in attributes. Graph event handlers and         attribute event handlers may be called in a different order, depending on the event: For events whose names end with  ing , graph event handlers are called first. You           can prevent the execution of attribute event handlers by setting              e.Cancel  to  true . For events whose names end with  ed , attribute event handlers are called           first. For example, if you need to change the default value set by the            PXDefault  attribute for a field, you can define a            FieldDefaulting  event handler in the graph. In this graph event         handler, you can assign a different default value and set  e.Cancel  to            true  to prevent the execution of the  FieldDefaulting          event handler defined in the  PXDefault  attribute (see the following         code). protected virtual void ShipmentLine_Gift_FieldDefaulting(
    PXCache sender, PXFieldDefaultingEventArgs e)
{
    ShipmentLine line = e.Row as ShipmentLine;
    if (line == null) return;

    Product card = GiftCard.Select();
    if (card != null && line.ProductID == card.ProductID)
    {
        e.NewValue = true;
         e.Cancel = true; 
    }
} ]]></column>
		</row>
		<row PageID="dc2a0c79-7ba4-4386-9345-2399e662df6f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ba8998e2-a13e-6ba1-1a81-40a95df18778" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you want to independently validate a value inserted by a user, you should implement the <tt>FieldVerifying</tt> event handler for the data field. You can use this approach to check restrictions on the absolute value.{br}

Generally, if validation fails, you can cancel the update of the field and restore the control to its value before the user changed it by throwing an exception of the <tt>PXSetPropertyException</tt> type, as is shown in the following example.<source lang="csharp">if ((decimal)e.NewValue &lt; 0)
{
    throw new PXSetPropertyException("The quantity cannot be negative.");
}</source>
You could instead correct the entered value to a valid value as shown in the following example.<source lang="csharp">if (product != null && (decimal)e.NewValue &lt; product.MinAvailQty)
{
    e.NewValue = product.MinAvailQty;
    ...
}</source>
If you correct the entered value, you shouldn&rsquo;t throw an exception; instead, you should let the method finish normally. However, we recommend that you display a warning indicating that the value has been corrected automatically. To do this, you can invoke the <tt>RaiseExceptionHandling&lt;&gt;()</tt> method of the <tt>PXCache&lt;&gt;</tt> type, as the following code example shows. This method displays a warning for the validated data field but doesn&rsquo;t raise an exception, so the method finishes normally and {{e.NewValue}} is set.<source lang="csharp">sender.RaiseExceptionHandling&lt;ShipmentLine.lineQty&gt;(
    line, e.NewValue,
    new PXSetPropertyException(
        "The quantity has been corrected to the minimum possible value.",
        PXErrorLevel.Warning));</source>
You still have to initialize an instance of the <tt>PXSetPropertyException</tt> type. But this time you do not throw an exception; you provide this instance as a parameter to the <tt>RaiseExceptionHandling&lt;&gt;()</tt> method. You should specify the error level if you want the message attached to the control to not be displayed with the default error sign. To attach a warning to the control, specify <tt>PXErrorLevel.Warning</tt> in the <tt>PXSetPropertyException</tt> constructor.]]></column>
			<column name="PlainText"><![CDATA[Validation of Field Values If you want to independently validate a value inserted by a user, you should implement the            FieldVerifying  event handler for the data field. You can use this         approach to check restrictions on the absolute value. Generally, if validation fails, you can cancel the update of the field and restore the         control to its value before the user changed it by throwing an exception of the            PXSetPropertyException  type, as is shown in the following example. if ((decimal)e.NewValue < 0)
{
    throw new PXSetPropertyException("The quantity cannot be negative.");
} You could instead correct the entered value to a valid value as shown in the following         example. if (product != null && (decimal)e.NewValue < product.MinAvailQty)
{
    e.NewValue = product.MinAvailQty;
    ...
} If you correct the entered value, you shouldn't throw an exception; instead, you should let         the method finish normally. However, we recommend that you display a warning indicating that         the value has been corrected automatically. To do this, you can invoke the            RaiseExceptionHandling<>()  method of the            PXCache<>  type, as the following code example shows. This method         displays a warning for the validated data field but doesn't raise an exception, so the         method finishes normally and  e.NewValue  is set. sender.RaiseExceptionHandling<ShipmentLine.lineQty>(
    line, e.NewValue,
    new PXSetPropertyException(
        "The quantity has been corrected to the minimum possible value.",
        PXErrorLevel.Warning)); You still have to initialize an instance of the  PXSetPropertyException          type. But this time you do not throw an exception; you provide this instance as a parameter         to the  RaiseExceptionHandling<>()  method. You should specify the error         level if you want the message attached to the control to not be displayed with the default         error sign. To attach a warning to the control, specify            PXErrorLevel.Warning  in the  PXSetPropertyException          constructor. ]]></column>
		</row>
		<row PageID="15fa31a5-1468-4290-b5ce-d0002e23be0e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="82eef96d-f043-b01b-e2c9-4fff4855a746" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If the validation of a field value doesn&rsquo;t involve other fields of the same data record, you should use the <tt>FieldVerifying</tt> event handler. For details, see [HelpRoot_Dev_Platform\BL__con_Validation_of_Single_Field|Validation of Field Values].[anchor|#_4d06469a-ea21-48a5-815b-fb806d3d75b2]{br}

If validation depends on other fields of the same data record, you should implement the validation in the <tt>RowUpdating</tt> event handler. The <tt>RowUpdating</tt> event happens during the update of a data record, after all field-related events have occurred. At the moment when the <tt>RowUpdating</tt> event is triggered, the modifications haven&rsquo;t been applied to the data record stored in the cache yet; if needed, you can cancel the update process.{br}

The event arguments give you access to the following data records:[anchor|#ul_s4y_pdh_lm]
*{{e.NewRow}}: The modified version of the data record, which contains all changes made by field-related events
*{{e.Row}}: The copy of the original data record stored in the cache

You can use the <tt>ObjectsEqual&lt;&gt;()</tt> method of the cache to compare these two data records to find out if any of the fields specified in the type parameters of the method has changed. For example, the event handler in the following code uses the <tt>ObjectsEqual&lt;&gt;()</tt> method (in bold type) compares the new and original data records (also in bold type) for the values of three fields.<source lang="csharp">protected virtual void _(Events.RowUpdating&lt;ShipmentLine&gt; e)
{
    ShipmentLine line = <b>e.NewRow<b>;
    ShipmentLine originalLine = <b>e.Row<b>;

    if (!sender.<b>ObjectsEqual&lt;<b>ShipmentLine.shipmentTime,
                            ShipmentLine.shipmentMinTime,
                            ShipmentLine.shipmentMaxTime<b>&gt;(<b>line, originalLine<b>)<b>)
    {
        ...
    }
    ...
}</source>
In this example, the <tt>ObjectsEqual&lt;&gt;()</tt> method returns <tt>false</tt> if any of the following values has changed: <tt>ShipmentTime</tt>, <tt>ShipmentMinTime</tt>, and <tt>ShipmentMaxTime</tt>.{br}

To cancel the update process, you set the <tt>Cancel</tt> property of the event arguments to <tt>true</tt>. We recommend that you generate an error message for any field whose value doesn&rsquo;t pass validation. You do this by calling the <tt>RaiseExceptionHandling&lt;&gt;()</tt> method of the cache, as shown in the following code example.<source lang="csharp">if (line.ShipmentTime != null && line.ShipmentMinTime != null &&
    line.ShipmentTime &lt; line.ShipmentMinTime)
{
    sender.RaiseExceptionHandling&lt;ShipmentLine.shipmentTime&gt;(
        line, line.ShipmentTime,
        new PXSetPropertyException("The delivery time is too early."));
    e.Cancel = true;
}</source>
If the <tt>RowUpdating</tt> event handler finishes with the <tt>e.Cancel</tt> property equal to true, the data record is not updated in the cache.{br}

If the validation of a field depends on the field that is defined ''before'' the validated field in the data access class (DAC), you can use the <tt>FieldVerifying</tt> event handler. The field-related events are raised for fields in the order in which the fields are defined in the DAC. So in this case, the <tt>FieldVerifying</tt> event handler is called for the validated field after all field-related events have been raised for the field the validated field depends on.{br}

In the example shown in the following code, the validation of the <tt>DeliveryDate</tt> field depends on the <tt>ShipmentDate</tt> field. But because <tt>DeliveryDate</tt> is defined after <tt>ShipmentDate</tt> in the <tt>Shipment</tt> DAC, it is correct to use the <tt>FieldVerifying</tt> event handler to validate <tt>DeliveryDate</tt>.<source lang="csharp">protected virtual void _(Events.FieldVerifying&lt;Shipment, Shipment.deliveryDate&gt; e)
{
    Shipment row = e.Row;
    if (e.NewValue == null) return;

    if (row.ShipmentDate != null && row.ShipmentDate &gt; (DateTime)e.NewValue)
    {
        e.NewValue = row.ShipmentDate;
        throw new PXSetPropertyException&lt;Shipment.shipmentDate&gt;(
            "The shipment date cannot be later than the delivery date.");
    }
}</source>]]></column>
			<column name="PlainText"><![CDATA[Validation of a Data Record If the validation of a field value doesn't involve other fields of the same data record,         you should use the  FieldVerifying  event handler. For details, see  Validation of Field Values. If validation depends on other fields of the same data             record, you should implement the validation in the  RowUpdating  event             handler. The  RowUpdating  event happens during the update of a data             record, after all field-related events have occurred. At the moment when the                  RowUpdating  event is triggered, the modifications haven't been             applied to the data record stored in the cache yet; if needed, you can cancel the update             process. The event arguments give you access to the following data records: e.NewRow : The modified version of the data record, which contains all           changes made by field-related events e.Row : The copy of the original data record stored in the cache You can use the  ObjectsEqual<>()  method of the cache to compare these         two data records to find out if any of the fields specified in the type parameters of the         method has changed. For example, the event handler in the following code uses the            ObjectsEqual<>()  method (in bold type) compares the new and original         data records (also in bold type) for the values of three fields. protected virtual void _(Events.RowUpdating<ShipmentLine> e)
{
    ShipmentLine line =  e.NewRow ;
    ShipmentLine originalLine =  e.Row ;

    if (!sender. ObjectsEqual< ShipmentLine.shipmentTime,
                            ShipmentLine.shipmentMinTime,
                            ShipmentLine.shipmentMaxTime >( line, originalLine ) )
    {
        ...
    }
    ...
} In this example, the  ObjectsEqual<>()  method returns            false  if any of the following values has changed:            ShipmentTime ,  ShipmentMinTime , and            ShipmentMaxTime . To cancel the update process, you set the  Cancel  property of the event         arguments to  true . We recommend that you generate an error message for         any field whose value doesn't pass validation. You do this by calling the            RaiseExceptionHandling<>()  method of the cache, as shown in the         following code example. if (line.ShipmentTime != null && line.ShipmentMinTime != null &&
    line.ShipmentTime < line.ShipmentMinTime)
{
    sender.RaiseExceptionHandling<ShipmentLine.shipmentTime>(
        line, line.ShipmentTime,
        new PXSetPropertyException("The delivery time is too early."));
    e.Cancel = true;
} If the  RowUpdating  event handler finishes with the            e.Cancel  property equal to true, the data record is not updated in the         cache. If the validation of a field depends on the field that is defined  before  the         validated field in the data access class (DAC), you can use the            FieldVerifying  event handler. The field-related events are raised for         fields in the order in which the fields are defined in the DAC. So in this case, the            FieldVerifying  event handler is called for the validated field after         all field-related events have been raised for the field the validated field depends on. In the example shown in the following code, the validation of the            DeliveryDate  field depends on the  ShipmentDate          field. But because  DeliveryDate  is defined after            ShipmentDate  in the  Shipment  DAC, it is correct to         use the  FieldVerifying  event handler to validate            DeliveryDate . protected virtual void _(Events.FieldVerifying<Shipment, Shipment.deliveryDate> e)
{
    Shipment row = e.Row;
    if (e.NewValue == null) return;

    if (row.ShipmentDate != null && row.ShipmentDate > (DateTime)e.NewValue)
    {
        e.NewValue = row.ShipmentDate;
        throw new PXSetPropertyException<Shipment.shipmentDate>(
            "The shipment date cannot be later than the delivery date.");
    }
} ]]></column>
		</row>
		<row PageID="2d07589d-4a3a-415a-8bc4-6acc59b0ecd2" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="098b022a-e1cd-d1f2-5dab-dc8bc92444c6" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You should use a <tt>FieldUpdated</tt> event handler to modify a data record when its field is updated. The <tt>FieldUpdated</tt> event is raised when a data record is inserted or updated. When a data record is updated, the <tt>FieldUpdated</tt> event is raised for only the updated fields. The event is raised after other field-level events (<tt>FieldUpdating</tt> and <tt>FieldVerifying</tt>) and before the row-level events (such as <tt>RowInserting</tt> and <tt>RowUpdating</tt>).{br}

You should primarily use the <tt>FieldUpdated</tt> event to modify only the data record itself, because the update (or insertion) of the data record can still be canceled in row-level events (<tt>RowUpdating</tt> or <tt>RowInserting</tt>). If you modify other data records in the <tt>FieldUpdated</tt> event and the update is canceled, your changes to the other data records won&rsquo;t be reverted.{br}

To modify field values in a <tt>FieldUpdated</tt> event handler, follow the rules below:[anchor|#ul_u3v_bns_fm]
*To update a field that is defined ''after'' the current field in the data access class, use the properties of the {{e.Row}} data record as shown in the following code example.<source lang="csharp">ShipmentLine line = e.Row as ShipmentLine;
...
line.Description = product.ProductName;</source>
*:Direct assignment of a value sets it to the given instance of the data record; no field-level events are raised at this point.
*To update a field that is defined ''before'' the current field in the data access class, use one of the following methods:
**<tt>SetValueExt&lt;&gt;()</tt>: You use this method of the cache to assign a specific value to a field. The method raises the same field-level events for the data field as the events raised when a data record is updated. For details about the update of a data record, see [HelpRoot_Dev_Platform\BL__con_Update|Update of a Data Record].
**<tt>SetDefaultExt&lt;&gt;()</tt>: You use this method of the cache to assign the default value to a field. The method raises the same field-level events for the data field as the events raised when a data record is inserted. For details about the insertion of a data record, see [HelpRoot_Dev_Platform\BL__con_Insertion_of_Record|Insertion of a Data Record].
*:The code example below shows an invocation of the <tt>SetValueExt&lt;&gt;</tt> method.<source lang="csharp">sender.SetValueExt&lt;ShipmentLine.ProductID&gt;(e.Row, GiftCardID);</source>
]]></column>
			<column name="PlainText"><![CDATA[Update of a Data Record on Update of a Field Value You should use a  FieldUpdated  event handler to modify a data record when         its field is updated. The  FieldUpdated  event is raised when a data record         is inserted or updated. When a data record is updated, the  FieldUpdated          event is raised for only the updated fields. The event is raised after other field-level         events ( FieldUpdating  and  FieldVerifying ) and before         the row-level events (such as  RowInserting  and            RowUpdating ). You should primarily use the  FieldUpdated  event to modify only the data         record itself, because the update (or insertion) of the data record can still be canceled in         row-level events ( RowUpdating  or  RowInserting ). If you         modify other data records in the  FieldUpdated  event and the update is         canceled, your changes to the other data records won't be reverted. To modify field values in a  FieldUpdated  event handler, follow the rules         below: To update a field that is defined  after  the current field in the data access           class, use the properties of the  e.Row  data record as shown in the           following code             example. ShipmentLine line = e.Row as ShipmentLine;
...
line.Description = product.ProductName; Direct             assignment of a value sets it to the given instance of the data record; no field-level             events are raised at this point. To update a field that is defined  before  the current field in the data access           class, use one of the following methods: SetValueExt<>() : You use this method of the cache to assign a               specific value to a field. The method raises the same field-level events for the data               field as the events raised when a data record is updated. For details about the update               of a data record, see  Update of a Data Record. SetDefaultExt<>() : You use this method of the cache to assign               the default value to a field. The method raises the same  field-level events for the               data field as the events raised when a data record is inserted. For details about the               insertion of a data record, see  Insertion of a Data Record. The code example below shows an invocation of the                SetValueExt<>            method. sender.SetValueExt<ShipmentLine.ProductID>(e.Row, GiftCardID); ]]></column>
		</row>
		<row PageID="0f4f3154-49c0-4d60-865b-448bc49e1b18" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="dd07e629-009b-3ec2-2bd2-d43741bcba97" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The <tt>FieldSelecting</tt> and <tt>FieldUpdating</tt> events transform the field value between the internal and external presentation. To construct the external value presentation that is displayed in the UI, you handle the <tt>FieldSelecting</tt> event. To compose the internal presentation that is held in the data access class (DAC) field, you handle the <tt>FieldUpdating</tt> event. {br}

The following parameters define the value presentation within the <tt>FieldSelecting</tt> event:[anchor|#ul_dhx_h5r_mm]
*<tt>e.ReturnValue</tt> defines the current field value, which is the internal value that is held in the DAC field or the external value that is displayed in the control.
*<tt>e.ReturnState</tt> defines one of the following:
**The ''field state'' (a <tt>PXFieldState</tt> object) that provides the set of UI parameters for the control. The UI control obtains all rendering parameters from the field state.
**The ''button state'' (a <tt>PXButtonState</tt> object) that provides UI parameters for the action. The button state is constructed in the <tt>FieldSelecting</tt> event handlers of the following attributes: the <tt>PXButton</tt> attribute, its successors, and the <tt>PXUIField</tt> attribute defined for the action.

Every type attribute adds the event handlers for these two events, which by default transform the field value between the internal presentation and the external one. However, in the graph, you can define specific event handlers for the <tt>FieldSelecting</tt> and <tt>FieldUpdating</tt> events and cancel the execution of handlers defined in attributes. Many attributes—such as <tt>PXSelector</tt>, <tt>PXDefault</tt>, and <tt>PXUIField</tt>—handle events in which they add specific information to the field state.{br}

To specify the external presentation of the value, assign it to <tt>e.ReturnValue</tt> in the <tt>FieldSelecting</tt> event handler. To specify the internal presentation of the value, assign it to <tt>e.NewValue</tt> in the <tt>FieldUpdating</tt> event handler. For unbound data fields that are displayed only in the UI, you can use only the <tt>FieldSelecting</tt> event that defines the UI presentation of the value.{br}

The <tt>FieldSelecting</tt> event is raised when the client requests the DAC field state to display the field value in the UI.{br}

The <tt>FieldUpdating</tt> event is raised every time the UI posts the updated external value to the server.]]></column>
			<column name="PlainText"><![CDATA[Internal and External Presentation of Values The  FieldSelecting  and  FieldUpdating  events transform         the field value between the internal and external presentation. To construct the external         value presentation that is displayed in the UI, you handle the            FieldSelecting  event. To compose the internal presentation that is held         in the data access class (DAC) field, you handle the  FieldUpdating  event.  The following parameters define the value presentation within the            FieldSelecting  event: e.ReturnValue  defines the current field value, which is the internal           value that is held in the DAC field or the external value that is displayed in the           control. e.ReturnState  defines one of the following: The  field state  (a  PXFieldState  object) that provides the               set of UI parameters for the control. The UI control obtains all rendering parameters               from the field state. The  button state  (a  PXButtonState  object) that provides UI               parameters for the action. The button state is constructed in the                  FieldSelecting  event handlers of the following attributes: the                  PXButton  attribute, its successors, and the                  PXUIField  attribute defined for the action. Every type attribute adds the event handlers for these two events, which by default         transform the field value between the internal presentation and the external one. However,         in the graph, you can define specific event handlers for the            FieldSelecting  and  FieldUpdating  events and cancel         the execution of handlers defined in attributes. Many attributes—such as            PXSelector ,  PXDefault , and            PXUIField —handle events in which they add specific information to         the field state. To specify the external presentation of the value, assign it to            e.ReturnValue  in the  FieldSelecting  event handler.         To specify the internal presentation of the value, assign it to            e.NewValue  in the  FieldUpdating  event handler. For         unbound data fields that are displayed only in the UI, you can use only the            FieldSelecting  event that defines the UI presentation of the value. The  FieldSelecting  event is raised when the client requests the DAC         field state to display the field value in the UI. The  FieldUpdating  event is raised every time the UI posts the updated         external value to the server. ]]></column>
		</row>
		<row PageID="452232d6-60da-4e0e-9fe4-23318464a3b2" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="fa0bf8ea-d864-4b7a-a10e-990aa7d5b80a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In Acumatica Framework, you use attributes to add common business logic to the application components. {br}

Attributes implement business logic by subscribing to events. Each attribute class directly or indirectly derives from the <tt>PXEventSubscriberAttribute</tt> class. In addition, an attribute class derives from the interfaces that correspond to the event handlers it implements. For example, the <tt>PXDefault</tt> attribute derives from the <tt>IPXFieldDefaultingSubscriber</tt>, <tt>IPXRowPersistingSubscriber</tt>, and <tt>IPXFieldSelectingSubscriber</tt> interfaces, which means that it implements its logic in the <tt>FieldDefaulting</tt>, <tt>RowSelecting</tt>, and <tt>FieldSelecting</tt> event handler methods.{br}

Attributes can be added to a data access class (DAC) definition, a data view declaration in a business logic controller (BLC), and the BLC definition itself.{br}

For more information on each attribute, see the [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fd1f3fb5-f5f2-4316-882e-a98232bbfba5|API Reference].
==In This Chapter==[anchor|#ul_ckc_l2r_rk]
*[HelpRoot_Dev_Platform\BL__con_Attributes|Code Reuse Through Attributes]
*[HelpRoot_Dev_Platform\BL__con_Mandatory_Attributes|Mandatory Attributes]
*[HelpRoot_Dev_Platform\BL__con_Use_of_Attributes|Use of Attributes]
*[HelpRoot_Dev_Platform\BL__con_Attr_DB_Types|Bound Field Data Types]
*[HelpRoot_Dev_Platform\BL__con_Attr_Unbound_Data_Types|Unbound Field Data Types]
*[HelpRoot_Dev_Platform\BL__con_PXUIField_Attribute|UI Field Configuration]
*[HelpRoot_Dev_Platform\BL__con_Default_Values|Default Values]
*[HelpRoot_Dev_Platform\BL__con_Attr_Selectors|Complex Input Controls]
*[HelpRoot_Dev_Platform\BL__con_Attr_Referential_Integrity|Referential Integrity]
*[HelpRoot_Dev_Platform\BL__con_Attr_Calculations|Calculation of Field Values]
*[HelpRoot_Dev_Platform\BL__con_Attr_SQL_Adhoc|Ad Hoc SQL for Fields]
*[HelpRoot_Dev_Platform\BL__con_Attr_Audit|Audit Fields]
*[HelpRoot_Dev_Platform\BL__con_Attr_Projection|Data Projection]
*[HelpRoot_Dev_Platform\BL__con_Attr_Access_Control|Access Control]
*[HelpRoot_Dev_Platform\BL__con_Attr_Notes|Notes]
*[HelpRoot_Dev_Platform\BL__con_Attr_Report_Opt|Report Optimization]
*[HelpRoot_Dev_Platform\BL__con_Attr_DAC|Attributes on DACs]
*[HelpRoot_Dev_Platform\BL__con_Attr_Actions| Action Attributes]
*[HelpRoot_Dev_Platform\BL__con_Attr_Views|Attributes on Data Views]
*[HelpRoot_Dev_Platform\BL__con_Replacement_of_Attributes|Replacement of Attributes for DAC Fields in CacheAttached]
*[HelpRoot_Dev_Platform\BL__con_CustomAttr|Custom Attributes]
*[HelpRoot_Dev_Platform\BL__con_UsingPXAccum|Update of Data with PXAccumulator Attributes]
*[HelpRoot_Dev_Platform\BL__con_Restrictions_in_Accumulator|Restrictions in the Accumulator Attribute]
]]></column>
			<column name="PlainText"><![CDATA[Working with Attributes In  Acumatica Framework, you use attributes to add common business logic to the application components.  Attributes implement business logic by subscribing to events. Each attribute class directly or     indirectly derives from the  PXEventSubscriberAttribute  class. In addition, an     attribute class derives from the interfaces that correspond to the event handlers it implements.     For example, the  PXDefault  attribute derives from the       IPXFieldDefaultingSubscriber ,  IPXRowPersistingSubscriber ,     and  IPXFieldSelectingSubscriber  interfaces, which means that it implements     its logic in the  FieldDefaulting ,  RowSelecting , and       FieldSelecting  event handler methods. Attributes can be added to a data access class (DAC) definition, a data view declaration in a     business logic controller (BLC), and the BLC definition itself. For more information on each attribute, see the  API Reference API Reference. In This Chapter Code Reuse Through AttributesMandatory AttributesUse of AttributesBound Field Data TypesUnbound Field Data TypesUI Field ConfigurationDefault ValuesComplex Input ControlsReferential IntegrityCalculation of Field ValuesAd Hoc SQL for FieldsAudit FieldsData ProjectionAccess ControlNotesReport OptimizationAttributes on DACs Action AttributesAttributes on Data ViewsReplacement of Attributes for DAC Fields in CacheAttachedCustom AttributesUpdate of Data with PXAccumulator AttributesRestrictions in the Accumulator Attribute]]></column>
		</row>
		<row PageID="4724097c-0097-40d2-bb80-98b62cf3a7dc" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f015129c-681c-2fab-2c7d-93f25226cb49" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The following code implements the logic of updating a receipt total when a document transaction is updated in the system. <source lang="csharp">public virtual void DocTransation_RowUpdated(PXCache cache,
                                             PXRowUpdatedEventArgs e)
{
    DocTransaction old = e.OldRow as DocTransaction;
    DocTransaction trn = e.Row as DocTransaction;
    if ((trn != null) && (trn.TranQty != old.TranQty ||
                                   trn.UnitPrice != old.UnitPrice))
    {
        Document doc = Receipts.Current;
        if (doc != null)
        {
            doc.TotalAmt -= old.TranQty * old.UnitPrice;
            doc.TotalAmt += trn.TranQty * trn.UnitPrice;
            Receipts.Update(doc);
        }
    }
}</source>{br}

This logic can be used in multiple forms of the application, and therefore can be moved into an <tt>Attribute</tt> class. The attribute is used to annotate a data field in the data access class. Then it can be reused anywhere in the code, as in the example below.<source lang="csharp">public class DocTransaction : PX.Data.IBqlTable
{
    ...
    #region TotalAmt
    public abstract class totalAmt : PX.Data.IBqlField
    {
    }
    [PXDBDecimal(2)]
    [PXDefault(TypeCode.Decimal, "0.00")]
    [PXUIField(DisplayName = "Line Total", Enabled = false)]
    <b>[DeltaMultiply(typeof(DocTransaction.tranQty), typeof(DocTransaction.unitPrice),
                   typeof(Document.totalAmt)]<b>
    public virtual decimal? ExtPrice { get; set; }
    #endregion
    ...
}</source>
In this example, the logic of updating the receipt total on an update of the transaction is implemented inside the {{DeltaMultiply}} attribute. This logic is triggered after each update, delete, or insert operation on the {{DocTransaction}} data access class instance and updates totals on the receipt level in the appropriate {{Document}} data access class instance.{br}

 Acumatica Framework provides a wide range of predefined attributes that can be used for defining data types, database mapping, referential integrity, data format validation, and default values for the field. The following code shows an example of how you can implement the logic from the above example by using the predefined <tt>PXFormula</tt> attribute, which is used for implementing calculations of data fields.<source lang="csharp">public class DocTransaction : PX.Data.IBqlTable
{
    ...
    #region TotalAmt
    public abstract class totalAmt : PX.Data.IBqlField
    {
    }
    [PXDBDecimal(2)]
    [PXDefault(TypeCode.Decimal, "0.00")]
    [PXUIField(DisplayName = "Line Total", Enabled = false)]
    <b>[PXFormula(typeof(Mult&lt;DocTransaction.tranQty, DocTransaction.unitPrice&gt;),
               typeof(SumCalc&lt;Document.totalAmt&gt;))]<b>
    public virtual decimal? ExtPrice { get; set; }
    #endregion
    ...
}</source>{br}

Because the data access classes are shared within an application, formatting, custom logic, and any constraints implemented in attributes are reused in each business logic controller that utilizes each data access class. By reusing code through attributes, you can move shared application functionality into attributes and avoid code duplication, while still enforcing application integrity.]]></column>
			<column name="PlainText"><![CDATA[Code Reuse Through Attributes The following code implements the logic of updating a receipt total when a document                 transaction is updated in the system.                  public virtual void DocTransation_RowUpdated(PXCache cache,
                                             PXRowUpdatedEventArgs e)
{
    DocTransaction old = e.OldRow as DocTransaction;
    DocTransaction trn = e.Row as DocTransaction;
    if ((trn != null) && (trn.TranQty != old.TranQty ||
                                   trn.UnitPrice != old.UnitPrice))
    {
        Document doc = Receipts.Current;
        if (doc != null)
        {
            doc.TotalAmt -= old.TranQty * old.UnitPrice;
            doc.TotalAmt += trn.TranQty * trn.UnitPrice;
            Receipts.Update(doc);
        }
    }
} This logic can be used in multiple forms of the application, and therefore can be moved into     an  Attribute  class. The attribute is used to annotate a data field in the     data access class. Then it can be reused anywhere in the code, as in the example below. public class DocTransaction : PX.Data.IBqlTable
{
    ...
    #region TotalAmt
    public abstract class totalAmt : PX.Data.IBqlField
    {
    }
    [PXDBDecimal(2)]
    [PXDefault(TypeCode.Decimal, "0.00")]
    [PXUIField(DisplayName = "Line Total", Enabled = false)]
     [DeltaMultiply(typeof(DocTransaction.tranQty), typeof(DocTransaction.unitPrice),
                   typeof(Document.totalAmt)] 
    public virtual decimal? ExtPrice { get; set; }
    #endregion
    ...
} In this example, the logic of updating the receipt total on an update of the transaction is                 implemented inside the  DeltaMultiply  attribute. This logic is                 triggered after each update, delete, or insert operation on the                      DocTransaction  data access class instance and updates totals on                 the receipt level in the appropriate  Document  data access class                 instance.  Acumatica Framework                 provides a wide range of predefined attributes that can be used for defining data                 types, database mapping, referential integrity, data format validation, and default                 values for the field. The following code shows an example of how you can implement                 the logic from the above example by using the predefined                      PXFormula  attribute, which is used for implementing                 calculations of data                 fields. public class DocTransaction : PX.Data.IBqlTable
{
    ...
    #region TotalAmt
    public abstract class totalAmt : PX.Data.IBqlField
    {
    }
    [PXDBDecimal(2)]
    [PXDefault(TypeCode.Decimal, "0.00")]
    [PXUIField(DisplayName = "Line Total", Enabled = false)]
     [PXFormula(typeof(Mult<DocTransaction.tranQty, DocTransaction.unitPrice>),
               typeof(SumCalc<Document.totalAmt>))] 
    public virtual decimal? ExtPrice { get; set; }
    #endregion
    ...
} Because the data access classes are shared within an application, formatting, custom logic,                 and any constraints implemented in attributes are reused in each business logic                 controller that utilizes each data access class. By reusing code through attributes,                 you can move shared application functionality into attributes and avoid code                 duplication, while still enforcing application integrity. ]]></column>
		</row>
		<row PageID="a211a689-4bd3-4593-8144-f9ef631c418d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="bb369783-f3c1-ca53-ea1a-7f03d9472e4c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can learn about the mandatory attributes of data access class (DAC) fields and actions.
==Mandatory Attributes of DAC Fields==
For each field defined in a DAC, you must specify the following attributes:[anchor|#ul_djw_hfr_rk]
*A data type attribute, which is either a bound field data type attribute that binds the field to a database column of a particular data type, or an unbound field data type attribute that indicates that the field is unbound. For lists of these attributes, see [HelpRoot_Dev_Platform\BL__con_Attr_DB_Types|Bound Field Data Types] and [HelpRoot_Dev_Platform\BL__con_Attr_Unbound_Data_Types|Unbound Field Data Types].
*The <tt>PXUIField</tt> attribute, which is mandatory for all fields that are displayed in the user interface. For details on the <tt>PXUIField</tt> attribute, see [HelpRoot_Dev_Platform\BL__con_PXUIField_Attribute|UI Field Configuration].

The example below demonstrates a declaration of a DAC field bound to a database column and displayed in the user interface.<source lang="csharp">// The data access class for the POReceiptFilter database table
[Serializable]
public partial class POReceiptFilter : IBqlTable
{
    ...
    // The type declaration of a DAC field
    public abstract class receiptType : PX.Data.IBqlField
    {
    }
    // The value declaration of a DAC field 
    // Put attributes before this declaration
    [PXDBString(2, IsFixed = true)]
    [PXUIField(DisplayName = "Type", Enabled = false)]
    public virtual String ReceiptType { get; set; }
    ...
}</source>
==Mandatory Attributes of Actions==
A declaration of a method that implements an action in a business logic controller must be preceded with the <tt>PXButton</tt> attribute or one of its successors and the <tt>PXUIField</tt> attribute. For details on the <tt>PXUIField</tt> attribute, see [HelpRoot_Dev_Platform\BL__con_PXUIField_Attribute|UI Field Configuration].{br}

The example below demonstrates a declaration of an action handler.{br}

<source lang="csharp">public PXAction&lt;SalesOrder&gt; ViewDocument;

[PXUIField(DisplayName = "View Document",
           MapEnableRights = PXCacheRights.Select,
           MapViewRights = PXCacheRights.Select)]
[PXButton]
public virtual IEnumerable viewDocument(PXAdapter adapter)
{
    ...
}</source>
==Related Articles==
*[HelpRoot_Dev_Platform\BL__con_Attr_DB_Types|Bound Field Data Types]
*[HelpRoot_Dev_Platform\BL__con_Attr_Unbound_Data_Types|Unbound Field Data Types]
*[HelpRoot_Dev_Platform\BL__con_PXUIField_Attribute|UI Field Configuration]
*[https://help.acumatica.com/(W(14))/Main?ScreenId=ShowWiki&pageid=ea7ce94e-4b3e-0f91-df1d-a4ce8023b184|PXUIFieldAttribute]
*[https://help.acumatica.com/(W(14))/Main?ScreenId=ShowWiki&pageid=e1a6f32e-fa9b-010a-b85f-0b2c2ffa0fea|PXButtonAttribute]]]></column>
			<column name="PlainText"><![CDATA[Mandatory Attributes In this topic, you can learn about the mandatory attributes of data         access class (DAC) fields and actions. Mandatory Attributes of DAC Fields For each field defined in a DAC, you must specify the following attributes: A data type attribute, which is either a bound field data type attribute that binds the           field to a database column of a particular data type, or an unbound field data type           attribute that indicates that the field is unbound. For lists of these attributes, see              Bound Field Data Types and  Unbound Field Data Types. The  PXUIField  attribute, which is mandatory for all fields that are           displayed in the user interface. For details on the  PXUIField            attribute, see  UI Field Configuration. The example below demonstrates a declaration of a DAC field bound to a database column and         displayed in the user interface. // The data access class for the POReceiptFilter database table
[Serializable]
public partial class POReceiptFilter : IBqlTable
{
    ...
    // The type declaration of a DAC field
    public abstract class receiptType : PX.Data.IBqlField
    {
    }
    // The value declaration of a DAC field 
    // Put attributes before this declaration
    [PXDBString(2, IsFixed = true)]
    [PXUIField(DisplayName = "Type", Enabled = false)]
    public virtual String ReceiptType { get; set; }
    ...
} Mandatory Attributes of Actions A declaration of a method that implements an action in a business logic controller must be         preceded with the  PXButton  attribute or one of its successors and the            PXUIField  attribute. For details on the  PXUIField          attribute, see  UI Field Configuration. The example below demonstrates a declaration of an action handler. public PXAction<SalesOrder> ViewDocument;

[PXUIField(DisplayName = "View Document",
           MapEnableRights = PXCacheRights.Select,
           MapViewRights = PXCacheRights.Select)]
[PXButton]
public virtual IEnumerable viewDocument(PXAdapter adapter)
{
    ...
} PXUIFieldAttribute PXButtonAttribute ]]></column>
		</row>
		<row PageID="5a036000-ca13-4c75-be1c-ac02d819ddce" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="1dff3dea-4b33-d084-d2ad-c3e424fee3e2" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To apply the attribute business logic to an entity, you should place the attribute on the entity declaration. At runtime, you can call the static methods of a particular attribute to adjust the attribute&rsquo;s behavior.
==Attributes on the Entity Declaration==
An attribute may be placed on a declaration of a class or a class member, with or without parameters. The parameters that are possible for an attribute depend on the constructor parameters and the properties defined in the attribute. The parameters of the selected constructor are placed first without names, and the named property settings follow them, as shown in the following example.<source lang="csharp">[PXDefault(false, PersistingCheck = PXPersistingCheck.Nothing)]
public virtual Boolean? Released { get; set; }</source>
Here the <tt>PXDefault</tt> attribute is created with the constructor that takes a Boolean-type parameter (set to <tt>false</tt>). Additionally, the <tt>PersistingCheck</tt> property is specified.
==Setting of Attribute Properties at Runtime==
You should call static methods defined in the attribute class to change the properties at runtime. The static methods can affect a single attribute instance or multiple attribute instances related to a specific data record or all data records in a particular cache object. The following example shows an invocation of a static method.<source lang="csharp">PXUIFieldAttribute.SetVisible&lt;APInvoice.curyID&gt;(cache, doc, true);</source>
When calling such a method, you typically specify the cache object, a data record related to this cache object, and the data access class (DAC) field. The method affects the attribute instance created for this field and the specified data record. If you pass <tt>null</tt> as the data record, the method affects attribute instances related to all data records in the specified cache object.]]></column>
			<column name="PlainText"><![CDATA[Use of Attributes To apply the attribute business logic to an entity, you should place the attribute on the         entity declaration. At runtime, you can call the static methods of a particular attribute         to adjust the attribute's behavior. Attributes on the Entity Declaration An attribute may be placed on a declaration of a class or a class member, with or without         parameters. The parameters that are possible for an attribute depend on the constructor         parameters and the properties defined in the attribute. The parameters of the selected         constructor are placed first without names, and the named property settings follow them, as         shown in the following example. [PXDefault(false, PersistingCheck = PXPersistingCheck.Nothing)]
public virtual Boolean? Released { get; set; } Here the  PXDefault  attribute is created with the constructor that takes         a Boolean-type parameter (set to  false ). Additionally, the            PersistingCheck  property is specified. Setting of Attribute Properties at Runtime You should call static methods defined in the attribute class to change the properties at         runtime. The static methods can affect a single attribute instance or multiple attribute         instances related to a specific data record or all data records in a particular cache         object. The following example shows an invocation of a static method. PXUIFieldAttribute.SetVisible<APInvoice.curyID>(cache, doc, true); When calling such a method, you typically specify the cache object, a data record related         to this cache object, and the data access class (DAC) field. The method affects the         attribute instance created for this field and the specified data record. If you pass            null  as the data record, the method affects attribute instances related         to all data records in the specified cache object. ]]></column>
		</row>
		<row PageID="61059393-8873-451f-b474-783906330fc6" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f1439f93-c2fb-83a0-398b-4a28cde5f151" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The following attributes bind a data access class (DAC) field to a database column of a specific type.
{| class="checklist" | width="100%" 
|- 
!width="27%" ! Attribute
!width="13%" ! C# Data Type
!width="18%" ! Database Data Type
!width="40%" ! Comment
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6f43bb00-f714-4dd4-3e18-952b10a7d49b|<tt>PXDBBool</tt>]
|  <tt>bool?</tt>
|  <tt>bit</tt>
| Boolean value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=bb912e5d-5582-187a-211c-026832ef3952|<tt>PXDBByte</tt>]
|  <tt>byte?</tt>
|  <tt>tinyint</tt>
| One-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b8abec45-68df-3f25-2661-b48baddf4f2d|<tt>PXDBDate</tt>]
|  <tt>DateTime?</tt>
|  <tt>datetime</tt> or <tt>smalldatetime</tt>
| Date and time
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9cd8c337-f815-e101-4335-56625c37e39e|<tt>PXDBTime</tt>]
|  <tt>DateTime?</tt>
|  <tt>smalldatetime</tt>
| Time without date
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=0fe1d7bb-3452-b2b0-c70c-0de73c8a3c37|<tt>PXDBDateAndTime</tt>]
|  <tt>DateTime?</tt>
|  <tt>datetime</tt> or <tt>smalldatetime</tt>
| Date and time values represented by separate input controls in the user interface
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=82a6bfec-fa58-7622-82b5-84f23e6f6836|<tt>PXDBDecimal</tt>]
|  <tt>decimal?</tt>
|  <tt>decimal</tt>
| Sixteen-byte floating point numeric value with a specific precision
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=bb67f00f-3c3a-8c03-a445-97610d43ab35|<tt>PXDBDecimalString</tt>]
|  <tt>decimal?</tt>
|  <tt>decimal</tt>
| A decimal value with a value selected by a user from the list of predefined values
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7dac4820-527e-5c93-e274-a8f88b968a6a|<tt>PXDBDouble</tt>]
|  <tt>double?</tt>
|  <tt>float</tt>
| Eight-byte floating point value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5b9e3a58-2bac-bcd0-9ab5-cc9ee9da2b1a|<tt>PXDBFloat</tt>]
|  <tt>float?</tt>
|  <tt>real</tt>
| Four-byte floating point value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=05170859-440d-4eb2-15bf-242eb2542452|<tt>PXDBGuid</tt>]
|  <tt>Guid?</tt>
|  <tt>uniqueidentifier</tt>
| Sixteen-byte unique value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=0c0be73a-f67b-7678-5fee-ca1ec59d96a4|<tt>PXDBIdentity</tt>]
|  <tt>int?</tt>
|  <tt>int</tt>
| Four-byte auto-incremented integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a475457c-148e-b8d1-0195-c608b0b4ffe5|<tt>PXDBLongIdentity</tt>]
|  <tt>int64?</tt>
|  <tt>bigint</tt>
| Eight-byte auto-incremented integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1bc72a36-9195-15e5-e630-2a7b3605b7f3|<tt>PXDBShort</tt>]
|  <tt>short?</tt>
|  <tt>smallint</tt>
| Two-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=933686ac-8589-8c13-519f-aa3d9a225e68|<tt>PXDBInt</tt>]
|  <tt>int?</tt>
|  <tt>int</tt>
| Four-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=55c77d76-282f-6911-52f4-0b0e9f890cc6|<tt>PXDBLong</tt>]
|  <tt>int64?</tt>
|  <tt>bigint</tt>
| Eight-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=684c8a76-2fb6-3aac-fcd4-c19eeda8304b|<tt>PXDBString</tt>]
|  <tt>string</tt>
|  <tt>char</tt>, <tt>varchar</tt>, <tt>nchar</tt>, or <tt>nvarchar</tt>
| Common string
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=83c22aa8-e32c-36b7-8603-b649104e43fd|<tt>PXDBEmail</tt>]
|  <tt>string</tt>
|  <tt>nvarchar</tt>
| Email address
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a6ea052d-3b45-f5ca-7dec-5c5f44bd5d40|<tt>PXDBLocalString</tt>]
|  <tt>string</tt>
|  <tt>char</tt>, <tt>varchar</tt>, <tt>nchar</tt>, or <tt>nvarchar</tt>
| Localized string
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=176377a7-4d01-786c-a56d-e17ccbf188f0|<tt>PXDBCryptString</tt>]
|  <tt>string</tt>
|  <tt>char</tt>, <tt>varchar</tt>, <tt>nchar</tt>, or <tt>nvarchar</tt>
| Encrypted string
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5ee7728a-fffb-2010-3992-6c232a162ae2|<tt>PXDBText</tt>]
|  <tt>string</tt>
|  <tt>nvarchar</tt> or <tt>varchar</tt>
| Text
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5432e798-8be3-661d-6e2a-b3bcf0525428|<tt>PXDBTimeSpan</tt>]
|  <tt>int?</tt>
|  <tt>int</tt>
| Date and time value represented by minutes passed from 01/01/1900
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=58e9d3f8-12a0-621c-8088-e26bc875d0cb|<tt>PXDBTimeSpanLong</tt>]
|  <tt>int?</tt>
|  <tt>int</tt>
| Duration in time as a number of minutes
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=f73e9ff3-9ea0-0538-cc43-958dd25b99bc|<tt>PXDBTimestamp</tt>]
|  <tt>byte&#91;&#93;</tt>
|  <tt>timestamp</tt>
| Eight-byte unique, automatically generated binary numbers within a database
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=cc9c8bec-c3c1-d8b5-a909-bfc75598671e|<tt>PXDBBinary</tt>]
|  <tt>byte&#91;&#93;</tt>
| 
| Arbitrary array of bytes
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e1daa7b2-8cbe-1c9e-f810-74133c736988|<tt>PXDBVariant</tt>]
|  <tt>byte&#91;&#93;</tt>
|  <tt>variant</tt>
| Variant data type
|}
 Acumatica Framework also includes other attributes that are used in special cases to bind a DAC field to database columns. ]]></column>
			<column name="PlainText"><![CDATA[Bound Field Data Types The following attributes bind a data access class (DAC) field to a database column of a         specific type. Attribute C# Data Type Database Data Type Comment PXDBBool <tt>PXDBBool</tt>bool? bit Boolean value PXDBByte <tt>PXDBByte</tt>byte? tinyint One-byte integer value PXDBDate <tt>PXDBDate</tt>DateTime? datetime  or  smalldatetime Date and time PXDBTime <tt>PXDBTime</tt>DateTime? smalldatetime Time without date PXDBDateAndTime <tt>PXDBDateAndTime</tt>DateTime? datetime  or  smalldatetime Date and time values represented by separate input controls in the user                 interface PXDBDecimal <tt>PXDBDecimal</tt>decimal? decimal Sixteen-byte floating point numeric value with a specific precision PXDBDecimalString <tt>PXDBDecimalString</tt>decimal? decimal A decimal value with a value selected by a user from the list of predefined                 values PXDBDouble <tt>PXDBDouble</tt>double? float Eight-byte floating point value PXDBFloat <tt>PXDBFloat</tt>float? real Four-byte floating point value PXDBGuid <tt>PXDBGuid</tt>Guid? uniqueidentifier Sixteen-byte unique value PXDBIdentity <tt>PXDBIdentity</tt>int? int Four-byte auto-incremented integer value PXDBLongIdentity <tt>PXDBLongIdentity</tt>int64? bigint Eight-byte auto-incremented integer value PXDBShort <tt>PXDBShort</tt>short? smallint Two-byte integer value PXDBInt <tt>PXDBInt</tt>int? int Four-byte integer value PXDBLong <tt>PXDBLong</tt>int64? bigint Eight-byte integer value PXDBString <tt>PXDBString</tt>string char ,  varchar ,  nchar ,                 or  nvarchar Common string PXDBEmail <tt>PXDBEmail</tt>string nvarchar Email address PXDBLocalString <tt>PXDBLocalString</tt>string char ,  varchar ,  nchar ,                 or  nvarchar Localized string PXDBCryptString <tt>PXDBCryptString</tt>string char ,  varchar ,  nchar ,                 or  nvarchar Encrypted string PXDBText <tt>PXDBText</tt>string nvarchar  or  varchar Text PXDBTimeSpan <tt>PXDBTimeSpan</tt>int? int Date and time value represented by minutes passed from 01/01/1900 PXDBTimeSpanLong <tt>PXDBTimeSpanLong</tt>int? int Duration in time as a number of minutes PXDBTimestamp <tt>PXDBTimestamp</tt>byte[] timestamp Eight-byte unique, automatically generated binary numbers within a                 database PXDBBinary <tt>PXDBBinary</tt>byte[] Arbitrary array of bytes PXDBVariant <tt>PXDBVariant</tt>byte[] variant Variant data type  Acumatica Framework also includes other attributes that are used in special cases to bind a DAC field to         database columns.  ]]></column>
		</row>
		<row PageID="fd0adc27-e163-422d-a74e-057aa10ad2d9" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="54dbff66-b9dd-5430-0df1-7445c05516d1" RecordSourceID="22377">
			<column name="Content"><![CDATA[The following table contains unbound field attributes. You use unbound attributes when you define a custom fields of your own that are not bound to any database fields.[anchor|#table_umg_wfx_qk]
{| class="checklist" | width="100%" 
|- 
!width="28%" ! Attribute
!width="14%" ! C# Data Type
!width="57%" ! Comment
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7d843c14-ade9-d303-f0fc-49834fb4701c|<tt>PXBool</tt>]
|  <tt>bool?</tt>
| Boolean value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=4fb7414c-eeaa-da00-e73f-96012eeb9a8c|<tt>PXByte</tt>]
|  <tt>byte?</tt>
| One-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e13e06c7-dd25-b9ae-6fdb-ca0103b3642b|<tt>PXDate</tt>]
|  <tt>DateTime?</tt>
| Date and time
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b9434f84-8a5d-d88c-ee97-cdb53e48c506|<tt>PXDateAndTime</tt>]
|  <tt>DateTime?</tt>
| Date and time values represented by separate input controls in the user interface
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=2dab17b2-a8b3-3565-03d2-80d4a445451c|<tt>PXDecimal</tt>]
|  <tt>Decimal?</tt>
| Sixteen-byte floating point numeric value with a specific precision
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7e937089-0faf-a1c1-872b-a178164d04d6|<tt>PXDouble</tt>]
|  <tt>double?</tt>
| Eight-byte floating point value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3cce9d22-92a7-3cc4-59da-35b5ab1f66ab|<tt>PXFloat</tt>]
|  <tt>float?</tt>
| Four-byte floating point value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=cccb6cf3-c8b2-378a-cb90-895989f58a90|<tt>PXGuid</tt>]
|  <tt>Guid?</tt>
| Sixteen-byte unique value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ab3d3e23-3c87-9e1f-5d8b-4e77651d6653|<tt>PXShort</tt>]
|  <tt>short?</tt>
| Two-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=91955df3-3ceb-e5c0-27ad-0f336217a147|<tt>PXInt</tt>]
|  <tt>int?</tt>
| Four-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7e0c708e-813b-7cc6-5585-0e4aa57bfe7f|<tt>PXLong</tt>]
|  <tt>int64?</tt>
| Eight-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=54a0e4fd-a521-7de4-2817-7ac59805293d|<tt>PXString</tt>]
|  <tt>string</tt>
| String of characters
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3f010029-4b46-cda7-232d-8338b166d54e|<tt>PXTimeSpan</tt>]
|  <tt>int?</tt>
| Date and time value represented by minutes passed from 01/01/1900
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=0dbbea05-2eba-9bff-2509-6564c8fcb1b2|<tt>PXTimeSpanLong</tt>]
|  <tt>int?</tt>
| Duration in time as a number of minutes
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=92f5623d-eebb-e5e7-db17-5aa98633b219|<tt>PXVariant</tt>]
|  <tt>byte&#91;&#93;</tt>
| Random array of bytes
|}]]></column>
			<column name="PlainText"><![CDATA[Unbound Field Data Types The following table contains unbound field attributes. You use unbound attributes when       you define a custom fields of your own that are not bound to any database fields. Attribute C# Data Type Comment PXBool <tt>PXBool</tt>bool? Boolean value PXByte <tt>PXByte</tt>byte? One-byte integer value PXDate <tt>PXDate</tt>DateTime? Date and time PXDateAndTime <tt>PXDateAndTime</tt>DateTime? Date and time values represented by separate input controls in the user                 interface PXDecimal <tt>PXDecimal</tt>Decimal? Sixteen-byte floating point numeric value with a specific precision PXDouble <tt>PXDouble</tt>double? Eight-byte floating point value PXFloat <tt>PXFloat</tt>float? Four-byte floating point value PXGuid <tt>PXGuid</tt>Guid? Sixteen-byte unique value PXShort <tt>PXShort</tt>short? Two-byte integer value PXInt <tt>PXInt</tt>int? Four-byte integer value PXLong <tt>PXLong</tt>int64? Eight-byte integer value PXString <tt>PXString</tt>string String of characters PXTimeSpan <tt>PXTimeSpan</tt>int? Date and time value represented by minutes passed from 01/01/1900 PXTimeSpanLong <tt>PXTimeSpanLong</tt>int? Duration in time as a number of minutes PXVariant <tt>PXVariant</tt>byte[] Random array of bytes ]]></column>
		</row>
		<row PageID="9fa848ae-704a-4332-95bd-0beac0180ddb" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="a118cd2b-3845-803a-bc1f-a333935b0178" RecordSourceID="22377">
			<column name="Content"><![CDATA[
By using the <tt>PXUIField</tt> attribute, you can configure the layout of input controls and buttons. The attribute is mandatory for all data access class (DAC) fields displayed in the user interface. 
==Setting of the PXUIField Attribute==
You can add the <tt>PXUIField</tt> attribute in the following ways:[anchor|#_1383d627-91b4-4175-b188-c1e5e9573459]
*To a DAC field declaration to configure the field input control, as shown in the following example<source lang="csharp">[PXDBDate()]
[PXUIField(DisplayName = "Pay Date")]
public virtual DateTime? PayDate { get; set; }</source>
*To the declaration of a method that implements an action to configure the action button, as shown in the following sample code<source lang="csharp">[PXUIField(DisplayName = "View Document",
           MapEnableRights = PXCacheRights.Select,
           MapViewRights = PXCacheRights.Select)]
[PXButton]
public virtual IEnumerable viewDocument(PXAdapter adapter)
{
    ...
}</source>

The attribute&rsquo;s properties determine the control layout in the user interface. You can specify the display name, specify whether the control is visible and available, set the error marker, and specify the access rights to view and use the control.
==Setting of the Properties of the PXUIField Attribute at Runtime==
You can use the static methods (such as <tt>SetEnabled</tt> and <tt>SetRequired</tt>) of the <tt>PXUIFieldAttribute</tt> class to set the properties of a control at runtime. The <tt>PXUIFieldAttribute</tt> static methods can be called in the graph constructor or the <tt>RowSelected</tt> event handlers.((({S:Warn}The <tt>RowSelected</tt> event handler is raised when the user interface controls are prepared to be displayed. This happens each time the form sends a request to the server.
)))
If you want to modify the <tt>Visible</tt>, <tt>Enabled</tt>, and <tt>Required</tt> properties for all detail rows in a grid, you use the <tt>RowSelected</tt> event handler of the primary view DAC. If you want to set the <tt>Enabled</tt> property of a field in particular row in a grid, you use the <tt>RowSelected</tt> event handler of the DAC that includes this field.{br}

If the grid column layout is configured at runtime, you set the <tt>data</tt> parameter of the corresponding method to <tt>null</tt>. This indicates that the property should be set for all data records shown in the grid. If a specific data record is passed to the method rather than {{null}}, the method invocation has no effect.((({S:Warn}If you want to change the <tt>Visible</tt> or <tt>Enabled</tt> property of <tt>PXUIFieldAttribute</tt> for a button at runtime, you use the corresponding static methods of <tt>PXAction</tt>. You usually use these methods in the <tt>RowSelected</tt> event handler of the primary view DAC.
)))
==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ea7ce94e-4b3e-0f91-df1d-a4ce8023b184|PXUIFieldAttribute Class]]]></column>
			<column name="PlainText"><![CDATA[UI Field Configuration By using the  PXUIField  attribute, you can configure the layout of input     controls and buttons. The attribute is mandatory for all data access class (DAC) fields     displayed in the user interface.  Setting of the PXUIField Attribute You can add the  PXUIField  attribute in the following ways: To a DAC field declaration to configure the field input control, as shown in the following      example [PXDBDate()]
[PXUIField(DisplayName = "Pay Date")]
public virtual DateTime? PayDate { get; set; } To the declaration of a method that implements an action to configure the action button, as      shown in the following sample      code [PXUIField(DisplayName = "View Document",
           MapEnableRights = PXCacheRights.Select,
           MapViewRights = PXCacheRights.Select)]
[PXButton]
public virtual IEnumerable viewDocument(PXAdapter adapter)
{
    ...
} The attribute's properties determine the control layout in the user interface. You can specify     the display name, specify whether the control is visible and available, set the error marker,     and specify the access rights to view and use the control. Setting of the Properties of the PXUIField Attribute at Runtime You can use the static methods (such as  SetEnabled  and       SetRequired ) of the  PXUIFieldAttribute  class to set the     properties of a control at runtime. The  PXUIFieldAttribute  static methods     can be called in the graph constructor or the  RowSelected  event handlers. The  RowSelected  event handler is raised when the user interface controls     are prepared to be displayed. This happens each time the form sends a request to the     server. If you want to modify the  Visible ,  Enabled , and       Required  properties for all detail rows in a grid, you use the       RowSelected  event handler of the primary view DAC. If you want to set the       Enabled  property of a field in particular row in a grid, you use the       RowSelected  event handler of the DAC that includes this field. If the grid column layout is configured at runtime, you set the  data      parameter of the corresponding method to  null . This indicates that the     property should be set for all data records shown in the grid. If a specific data record is     passed to the method rather than  null , the method invocation has no effect. If you want to change the  Visible  or  Enabled  property     of  PXUIFieldAttribute  for a button at runtime, you use the corresponding     static methods of  PXAction . You usually use these methods in the       RowSelected  event handler of the primary view DAC. PXUIFieldAttribute Class ]]></column>
		</row>
		<row PageID="59a784a5-7663-4031-ab15-594c2ec1c027" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e28c80ce-659e-cd88-86f9-dd1876777367" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can set the default values to data access class (DAC) fields by using the following attributes:[anchor|#ul_xdc_ylz_pk]
*<tt>PXDefault</tt>: This attribute sets the default value and validates the field value when the value is saved to the database. The following attributes are derived from the <tt>PXDefault</tt> attribute:
**<tt>PXUnboundDefault</tt> behaves in the same way as <tt>PXDefault</tt> does, but the default value is assigned to the field when a data record is retrieved from the database.
**<tt>PXDefaultValidate</tt>.
*<tt>PXDBDefault</tt>: This attribute sets the default value by using the value of some source field, and updates the value if the source field value changes in the database before the data record is saved.

==PXDefault Attribute==
The <tt>PXDefault</tt> attribute provides the default value for a DAC field. The default value is assigned to the field when the cache raises the <tt>FieldDefaulting</tt> event. This happens when a new row is inserted in code or through the user interface.{br}

A value specified as a default can be a constant or the result of a BQL query. If you provide a BQL query, the attribute executes it on the <tt>FieldDefaulting</tt> event. You can specify both a constant and a BQL query; the attribute first executes the BQL query and then uses the constant if the BQL query returns an empty set. If you provide a DAC field as the BQL query, the attribute retrieves the value of this field from the <tt>Current</tt> property of the cache object. The attribute uses the cache object of the DAC type in which the field is defined.{br}

The <tt>PXDefault</tt> attribute also checks that the field value is not <tt>null</tt> before saving a record to the database. You can adjust this behavior by using the <tt>PersistingCheck</tt> property. Its value indicates whether the attribute should verify that the value is not <tt>null</tt>, verify that the value is not <tt>null</tt> or a blank string, or not perform any verification.{br}

The attribute can redirect the error that happened on the field to another field if you set the <tt>MapErrorTo</tt> property.{br}

You can use the static methods of the attribute to change the attribute properties for a particular data record in the cache or for all data records in the cache.
==Differences==
You usually set the default value to a DAC field by using the <tt>PXDefault</tt> attribute. You can set a constant as the default value or provide a BQL query to obtain a value from the database or data records from the cache. The default value is assigned to the field when a data record that includes this field is inserted into the cache.{br}

You can use the <tt>PXDefault</tt> attribute just to make the field mandatory for input by using the attribute without parameters.{br}

The <tt>PXDefault</tt> attribute is not suitable when the default value is retrieved from a field that can be auto-generated by the database (such as the identity field). In this case, you should use the <tt>PXDBDefault</tt> attribute. It updates the value assigned to the field as the default with the value generated by the database.{br}

For example, if you implement a master-detail relationship, you should use the <tt>PXDBDefault</tt> attribute to bind the detail data record fields to the master data record key fields. If the master data record is new, its identity field is set to a real value by the database when the master record is saved. So if a detail data record is created before the master data record is saved, the detail data record field is set to the temporary value of the master identity field. However, the <tt>PXDBDefault</tt> attribute replaces the temporary value with the real value when the detail data record is saved to the database.{br}

You can use the <tt>PXUnboundDefault</tt> attribute to set the default value to an unbound field. The value is assigned when a data record is retrieved from the database (on the <tt>RowSelecting</tt> event).
==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c97384f1-fe6e-9c90-c97e-ba2e53af675d|PXDBDefaultAttribute Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=96b4e224-d0d2-e2d8-671e-9ba2ed73c21b|PXDefaultAttribute Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9657f891-5eec-949b-53ee-d700542cb03c|PXUnboundDefaultAttribute Class]]]></column>
			<column name="PlainText"><![CDATA[Default Values You can set the default values to data access class (DAC) fields by using the following     attributes: PXDefault : This attribute sets the default value and validates the field      value when the value is saved to the database. The following attributes are derived from the        PXDefault  attribute: PXUnboundDefault  behaves in the same way as          PXDefault  does, but the default value is assigned to the field when a        data record is retrieved from the database. PXDefaultValidate . PXDBDefault : This attribute sets the default value by using the value of      some source field, and updates the value if the source field value changes in the database      before the data record is saved. PXDefault Attribute The  PXDefault  attribute provides the default value for a DAC field. The     default value is assigned to the field when the cache raises the       FieldDefaulting  event. This happens when a new row is inserted in code or     through the user interface. A value specified as a default can be a constant or the result of a BQL query. If you provide     a BQL query, the attribute executes it on the  FieldDefaulting  event. You can     specify both a constant and a BQL query; the attribute first executes the BQL query and then     uses the constant if the BQL query returns an empty set. If you provide a DAC field as the BQL     query, the attribute retrieves the value of this field from the  Current      property of the cache object. The attribute uses the cache object of the DAC type in which the     field is defined. The  PXDefault  attribute also checks that the field value is not       null  before saving a record to the database. You can adjust this behavior by     using the  PersistingCheck  property. Its value indicates whether the attribute     should verify that the value is not  null , verify that the value is not       null  or a blank string, or not perform any verification. The attribute can redirect the error that happened on the field to another field if you set     the  MapErrorTo  property. You can use the static methods of the attribute to change the attribute properties for a     particular data record in the cache or for all data records in the cache. Differences You usually set the default value to a DAC field by using the  PXDefault      attribute. You can set a constant as the default value or provide a BQL query to obtain a value     from the database or data records from the cache. The default value is assigned to the field     when a data record that includes this field is inserted into the cache. You can use the  PXDefault  attribute just to make the field mandatory for     input by using the attribute without parameters. The  PXDefault  attribute is not suitable when the default value is retrieved     from a field that can be auto-generated by the database (such as the identity field). In this     case, you should use the  PXDBDefault  attribute. It updates the value assigned     to the field as the default with the value generated by the database. For example, if you implement a master-detail relationship, you should use the       PXDBDefault  attribute to bind the detail data record fields to the master     data record key fields. If the master data record is new, its identity field is set to a real     value by the database when the master record is saved. So if a detail data record is created     before the master data record is saved, the detail data record field is set to the temporary     value of the master identity field. However, the  PXDBDefault  attribute     replaces the temporary value with the real value when the detail data record is saved to the     database. You can use the  PXUnboundDefault  attribute to set the default value to an     unbound field. The value is assigned when a data record is retrieved from the database (on the       RowSelecting  event). PXDBDefaultAttribute Class PXDefaultAttribute Class PXUnboundDefaultAttribute Class ]]></column>
		</row>
		<row PageID="e4cb712a-076e-4da4-b7dc-79be3192e8ef" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="621698f2-bec5-fce0-d109-00cecb48a454" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use attributes to configure complex input controls, such as drop-down lists and lookup controls.{br}{TOC}
==Drop-Down Lists==
You can use the following attributes to configure a drop-down list that represents a data access class (DAC) field in the user interface:[anchor|#ul_kgf_hvr_rk]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=426773d0-8861-2fe4-d789-0d7d41f8bae9|<tt>PXStringList</tt>]: Configures a drop-down list from which a user can select from a fixed set of strings.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c09a2a41-bd5d-5633-898c-bda54ae9f933|<tt>PXIntList</tt>]: Configures a drop-down list where a user can select from a fixed set of values. The control displays strings, while the field is assigned the integer value corresponding to the selected string. 
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1694aae7-8afa-7428-2769-9fb9ac51bdf3|<tt>PXDecimalList</tt>]: Configures a drop-down list where a user can select from a fixed set of strings converted to decimal values.
*<tt>PXImagesList</tt>: Configures a drop-down list where a user can select from a fixed set of images.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=0f8c60a8-06ba-bb4e-b501-584ebc1c6327|<tt>PXDBIntList</tt>]: Configures a drop-down control for an integer field. The values and labels for the drop-down control are retrieved from the specified database table.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b2acdca2-7bb3-6ec2-e783-2169f22256d4|<tt>PXDBStringList</tt>]: Configures a drop-down control for a string field. The values and labels for the drop-down control are retrieved from the specified database table.

==Lookup Controls==
You can use the following attributes to configure a lookup control that represents a field in the user interface:[anchor|#ul_sgf_hvr_rk]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6ed489c0-36a3-9790-7bcd-5072e718a728|<tt>PXSelector</tt>]: Defines a lookup control for a DAC field that references a data record from a particular table by holding its key.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=45e2b103-e3ae-d59e-57dc-985bb665181e|<tt>PXCustomSelector</tt>]: Serves as the base class to derive custom attributes used to configure lookup controls.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8b1d5510-5820-f605-78f6-191bf1c89944|<tt>PXRestrictor</tt>]: Adds a restriction to a BQL command that selects data for a lookup control, and displays an error message when the value entered does not fit the restriction. The attribute works only with <tt>PXSelector</tt> and cannot be used with <tt>PXCustomSelector</tt>.

==Segmented Key Controls==
A segmented key value is a string value that identifies a data record in the system and consists of one segment or multiple segments. A segmented key is an entity that is identified by a string (referred to as a ''dimension'') and associated with segments. For each segment, you can define the list of possible values. You can create a new segment when the data records identified by the segmented key already exist in the database.{br}

You can use the following attributes to configure a control to input a segmented key value in the user interface:[anchor|#ul_h5z_jpz_rk]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=60b4d8bd-443c-df2d-19dd-fbe3da498dee|<tt>PXDimension</tt>]: Defines an input control that formats the input as a segmented key value and displays the list of allowed values for each key segment.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=836b2dd0-009b-da18-ac40-019c3c5eb8e3|<tt>PXDimensionSelector</tt>]: Defines an input control that combines the functionality of the <tt>PXDimenstion</tt> attribute and the <tt>PXSelector</tt> attribute. A user can view the data set defined by the attribute and select a data record from this data set to assign its segmented key value to the field or to replace it with the surrogate key.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=70c2d94f-a115-b3c2-ad61-89c48e569114|<tt>PXDimensionWildcard</tt>]: Behaves similarly to the <tt>PXDimensionSelector</tt> attribute, but also allows the ''?'' character to be treated as a wildcard.
]]></column>
			<column name="PlainText"><![CDATA[Complex Input Controls You can use attributes to configure complex input controls, such as drop-down lists and         lookup controls. Drop-Down Lists You can use the following attributes to configure a drop-down list that represents a data         access class (DAC) field in the user interface: PXStringList <tt>PXStringList</tt>: Configures a           drop-down list from which a user can select from a fixed set of strings. PXIntList <tt>PXIntList</tt>: Configures a           drop-down list where a user can select from a fixed set of values. The control displays           strings, while the field is assigned the integer value corresponding to the selected           string.  PXDecimalList <tt>PXDecimalList</tt>: Configures a           drop-down list where a user can select from a fixed set of strings converted to decimal           values. PXImagesList : Configures a drop-down list where a user can select           from a fixed set of images. PXDBIntList <tt>PXDBIntList</tt>: Configures a           drop-down control for an integer field. The values and labels for the drop-down control           are retrieved from the specified database table. PXDBStringList <tt>PXDBStringList</tt>: Configures a           drop-down control for a string field. The values and labels for the drop-down control are           retrieved from the specified database table. Lookup Controls You can use the following attributes to configure a lookup control that represents a field         in the user interface: PXSelector <tt>PXSelector</tt>: Defines a lookup control for a DAC field that           references a data record from a particular table by holding its key. PXCustomSelector <tt>PXCustomSelector</tt>: Serves as the base class to derive custom           attributes used to configure lookup controls. PXRestrictor <tt>PXRestrictor</tt>: Adds a           restriction to a BQL command that selects data for a lookup control, and displays an error           message when the value entered does not fit the restriction. The attribute works only with              PXSelector  and cannot be used with              PXCustomSelector . Segmented Key Controls A segmented key value is a string value that identifies a data record in the system and         consists of one segment or multiple segments. A segmented key is an entity that is         identified by a string (referred to as a  dimension ) and associated with segments. For         each segment, you can define the list of possible values. You can create a new segment when         the data records identified by the segmented key already exist in the database. You can use the following attributes to configure a control to input a segmented key value         in the user interface: PXDimension <tt>PXDimension</tt>: Defines an input control that formats the input           as a segmented key value and displays the list of allowed values for each key           segment. PXDimensionSelector <tt>PXDimensionSelector</tt>: Defines an input control that combines           the functionality of the  PXDimenstion  attribute and the              PXSelector  attribute. A user can view the data set defined by the           attribute and select a data record from this data set to assign its segmented key value to           the field or to replace it with the surrogate key. PXDimensionWildcard <tt>PXDimensionWildcard</tt>: Behaves similarly to the              PXDimensionSelector  attribute, but also allows the  ?  character           to be treated as a wildcard. ]]></column>
		</row>
		<row PageID="5dcd7912-7a39-4d7d-9350-f2d9f19fb83f" Language="en-US" PageRevisionID="1" PlainText="Referential Integrity You can use the following attributes to implement referential integrity at runtime: PXParent &lt;tt&gt;PXParent&lt;/tt&gt;: Creates a reference           to a parent data record. By default, when the parent data record is deleted, all child           data records that reference it are also deleted. (You can change this behavior by using           the  LeaveChildren  property.) PXDBChildIdentity &lt;tt&gt;PXDBChildIdentity&lt;/tt&gt;: Indicates           that a DAC field references an auto-generated key field from another table, and ensures           that the field value is correct after changes have been committed to the database. PXLineNbr &lt;tt&gt;PXLineNbr&lt;/tt&gt;: Generates                                         unique line numbers that identify child data records in the                                         parent-child relationship. Note that all the attributes in the list above add server-side logic used at runtime. The         referential integrity is implemented on the server side. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e65c2f6c-4be5-1d00-2b65-1a3747c5635a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use the following attributes to implement referential integrity at runtime:[anchor|#ul_ezn_l13_sk]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a916cba2-1f12-0c2b-8f70-31b1ecc05b99|<tt>PXParent</tt>]: Creates a reference to a parent data record. By default, when the parent data record is deleted, all child data records that reference it are also deleted. (You can change this behavior by using the <tt>LeaveChildren</tt> property.)
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=52e14c1d-8f10-4eb7-99c7-7ad12c4d9da5|<tt>PXDBChildIdentity</tt>]: Indicates that a DAC field references an auto-generated key field from another table, and ensures that the field value is correct after changes have been committed to the database.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=46ca2072-24fa-e6d7-6914-d56eab4e3c89|<tt>PXLineNbr</tt>]: Generates unique line numbers that identify child data records in the parent-child relationship.

Note that all the attributes in the list above add server-side logic used at runtime. The referential integrity is implemented on the server side.]]></column>
		</row>
		<row PageID="fd20c038-ce71-4429-a84d-f34064263906" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="5d25b537-aa06-b792-7ec4-dcb645505858" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use the predefined attributes <tt>PXFormula</tt> and <tt>PXUnboundFormula</tt> in data access classes (DACs) to calculate field values from the values of the same data record. You can also calculate aggregated values over detail data records and assign an aggregated value to a field of the master data record.{br}

The attributes implement the <tt>RowInserted</tt>, <tt>RowUpdated</tt>, and <tt>RowDeleted</tt> event handlers to calculate aggregates. Also, the attributes use the <tt>FieldUpdated</tt> event handler for dependent fields. The <tt>PXFormula</tt> attribute defines the <tt>RowSelecting</tt> event handler to calculate values for unbound DAC fields. You only need to mark a field in the DAC with an attribute; you don&rsquo;t have to define any event handlers.{br}

You use the <tt>PXFormula</tt> and <tt>PXUnboundFormula</tt> attributes as follows:[anchor|#ul_jhj_rpp_lm]
*To calculate the value of a field from other fields of the same data record, you add the <tt>PXFormula</tt> attribute with one parameter to this field, as shown below.<source lang="csharp">[PXFormula(
    typeof(Mult&lt;DocTransaction.tranQty,DocTransaction.unitPrice&gt;)]
public virtual decimal? ExtPrice
...</source>
*:This code sets <tt>ExtPrice</tt> to the product of <tt>TranQty</tt> and <tt>UnitPrice</tt>.
*To calculate the value of a field from other fields of the same data record and calculate the aggregated value from these values, you add the <tt>PXFormula</tt> attribute with two parameters to this field. You should also add the <tt>PXParent</tt> attribute to identify the master data record. (See the following code.)<source lang="csharp">[PXFormula(
    typeof(Mult&lt;DocTransaction.tranQty, DocTransaction.unitPrice&gt;),
    typeof(SumCalc&lt;Document.totalCost&gt;))]
public virtual decimal? ExtPrice
...

[PXParent(typeof(Select&lt;Document,
    Where&lt;Document.docType, Equal&lt;Current&lt;DocTransaction.docType&gt;&gt;,
        And&lt;Document.docNbr, Equal&lt;Current&lt;DocTransaction.docNbr&gt;&gt;&gt;&gt;&gt;))]
public virtual string DocType
...</source>
*:This code sets <tt>ExtPrice</tt> to the product of <tt>TranQty</tt> by <tt>UnitPrice</tt>, summarizes <tt>ExtPrice</tt> over all detail data records, and assigns the result to the <tt>TotalCost</tt> field of the parent document.
*To calculate an aggregated value by using the value of the field, you add the <tt>PXFormula</tt> attribute to this field with the first parameter set to ''null'', as shown below. The <tt>PXParent</tt> attribute is required.<source lang="csharp">[PXFormula(
    null,
    typeof(SumCalc&lt;Document.totalCost&gt;))]
public virtual decimal? ExtPrice
...</source>
*:This code sets the <tt>TotalCost</tt> field of the parent document to the sum of the <tt>ExtPrice</tt> values.
*To calculate an expression for each detail data record and aggregate the resulting values in a field of the master data record, you add the <tt>PXUnboundFormula</tt> attribute to any field of the detail data record, as shown in the following code. The field marked with the attribute is not set by the attribute. The <tt>PXParent</tt> attribute is required.<source lang="csharp">[PXUnboundFormula(
    typeof(Mult&lt;DocTransaction.tranQty, DocTransaction.unitPrice&gt;),
    typeof(SumCalc&lt;Document.totalCost&gt;))]
public virtual decimal? ExtPrice
...</source>
*:This code sets the <tt>TotalCost</tt> field of the parent document to the sum of the products of the <tt>TranQty</tt> and <tt>UnitPrice</tt> values. The attribute doesn&rsquo;t set the <tt>ExtPrice</tt> field.
*:With <tt>PXUnboundFormula</tt>, you can use <tt>SumCalc&lt;&gt;</tt> and <tt>MaxCalc&lt;&gt;</tt>.

==Functions and Aggregated Functions==
In the first parameter of the <tt>PXFormula</tt> and <tt>PXUnboundFormula</tt> attributes, you can specify an expression built of data fields, BQL constants, and the following BQL functions:[anchor|#ul_psn_cxp_lm]
*<tt>Add&lt;,&gt;</tt> returns the sum of two values.
*<tt>Sub&lt;,&gt;</tt> substracts the second value from the first.
*<tt>Mult&lt;,&gt;</tt> multiplies two values.
*<tt>Div&lt;,&gt;</tt> divides the first value by the second.
*<tt>Minus&lt;&gt;</tt> multiplies a value by -1.
*<tt>Switch&lt;Case&lt;&gt;,&gt;</tt> returns a value selected by a condition.

In the second parameter of the <tt>PXFormula</tt> and attribute, you can specify one of the following aggregation functions with the parent&rsquo;s field to hold the result as the type parameter:[anchor|#ul_w41_ksp_lm]
*<tt>SumCalc&lt;&gt;</tt> calculates the total sum.
*<tt>CountCalc&lt;&gt;</tt> counts the detail data records.
*<tt>MinCalc&lt;&gt;</tt> calculates the minimum values.
*<tt>MaxCalc&lt;&gt;</tt> calculates the maximum value.

The <tt>PXUnboundFormula</tt> attribute supports only <tt>SumCalc&lt;&gt;</tt> and <tt>MaxCalc&lt;&gt;</tt>.]]></column>
			<column name="PlainText"><![CDATA[Calculation of Field Values You can use the predefined attributes  PXFormula  and            PXUnboundFormula  in data access classes (DACs) to calculate field         values from the values of the same data record. You can also calculate aggregated values         over detail data records and assign an aggregated value to a field of the master data         record. The attributes implement the  RowInserted ,  RowUpdated ,         and  RowDeleted  event handlers to calculate aggregates. Also, the         attributes use the  FieldUpdated  event handler for dependent fields. The            PXFormula  attribute defines the  RowSelecting  event         handler to calculate values for unbound DAC fields. You only need to mark a field in the DAC         with an attribute; you don't have to define any event handlers. You use the  PXFormula  and  PXUnboundFormula  attributes         as follows: To calculate the value of a field from other fields of the same data record, you add the              PXFormula  attribute with one parameter to this field, as shown             below. [PXFormula(
    typeof(Mult<DocTransaction.tranQty,DocTransaction.unitPrice>)]
public virtual decimal? ExtPrice
... This             code sets  ExtPrice  to the product of  TranQty  and                UnitPrice . To calculate the value of a field from other fields of the same data record and           calculate the aggregated value from these values, you add the  PXFormula            attribute with two parameters to this field. You should also add the              PXParent  attribute to identify the master data record. (See the           following             code.) [PXFormula(
    typeof(Mult<DocTransaction.tranQty, DocTransaction.unitPrice>),
    typeof(SumCalc<Document.totalCost>))]
public virtual decimal? ExtPrice
...

[PXParent(typeof(Select<Document,
    Where<Document.docType, Equal<Current<DocTransaction.docType>>,
        And<Document.docNbr, Equal<Current<DocTransaction.docNbr>>>>>))]
public virtual string DocType
... This             code sets  ExtPrice  to the product of  TranQty  by                UnitPrice , summarizes  ExtPrice  over all detail             data records, and assigns the result to the  TotalCost  field of the             parent document. To calculate an aggregated value by using the value of the field, you add the              PXFormula  attribute to this field with the first parameter set to              null , as shown below. The  PXParent  attribute is             required. [PXFormula(
    null,
    typeof(SumCalc<Document.totalCost>))]
public virtual decimal? ExtPrice
... This             code sets the  TotalCost  field of the parent document to the sum of             the  ExtPrice  values. To calculate an expression for each detail data record and aggregate the resulting           values in a field of the master data record, you add the              PXUnboundFormula  attribute to any field of the detail data record, as           shown in the following code. The field marked with the attribute is not set by the           attribute. The  PXParent  attribute is             required. [PXUnboundFormula(
    typeof(Mult<DocTransaction.tranQty, DocTransaction.unitPrice>),
    typeof(SumCalc<Document.totalCost>))]
public virtual decimal? ExtPrice
... This             code sets the  TotalCost  field of the parent document to the sum of             the products of the  TranQty  and  UnitPrice  values.             The attribute doesn't set the  ExtPrice  field. With                PXUnboundFormula , you can use  SumCalc<>  and                MaxCalc<> . Functions and Aggregated Functions In the first parameter of the  PXFormula  and            PXUnboundFormula  attributes, you can specify an expression built of         data fields, BQL constants, and the following BQL functions: Add<,>  returns the sum of two values. Sub<,>  substracts the second value from the first. Mult<,>  multiplies two values. Div<,>  divides the first value by the second. Minus<>  multiplies a value by -1. Switch<Case<>,>  returns a value selected by a condition. In the second parameter of the  PXFormula  and attribute, you can specify         one of the following aggregation functions with the parent's field to hold the result as the         type parameter: SumCalc<>  calculates the total sum. CountCalc<>  counts the detail data records. MinCalc<>  calculates the minimum values. MaxCalc<>  calculates the maximum value. The  PXUnboundFormula  attribute supports only            SumCalc<>  and  MaxCalc<> . ]]></column>
		</row>
		<row PageID="95f32fae-7e43-4998-8c17-4236039a9da9" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f14e8a74-a10f-404b-9f30-560c14662d3a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The following attributes define the database-side calculation of data access class (DAC) fields that are not bound to particular database columns:[anchor|#ul_jql_1pz_tk]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=514ddad8-b833-bef0-6eab-389eee1f9f6d|<tt>PXDBCalced</tt>]: Defines an SQL expression that calculates an unbound field from the fields of the same DAC, whose values are taken from the database.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6d5c11d9-def0-db67-945d-17f4d36db5b4|<tt>PXDBScalar</tt>]: Defines an SQL subrequest that retrieves a value for an unbound DAC field. The subrequest can retrieve data from any bound field in any DAC.

The attributes add the provided expression and the subrequest into the SQL query that selects data records of the given DAC.
==PXDBScalar==
The <tt>PXDBScalar</tt> attribute defines a subquery that selects the value assigned to the field on which the attribute is specified. In the code example below, <tt>PXDBScalar</tt> selects the value from the {{ProductQty.AvailQty}} data field and inserts it into the {{ProductReorder.AvailQty}} field.<source lang="csharp">// The ProductReorder class
[PXDecimal(2)]
[PXDBScalar(typeof(Search&lt;ProductQty.availQty,
    Where&lt;ProductQty.productID.IsEqual&lt;ProductReorder.productID&gt;&gt;&gt;))]
[PXUIField(DisplayName = "Available Qty", Enabled = false)]
public virtual decimal? AvailQty { get; set; }</source>((({S:Warn}The BQL expressions specified in the <tt>PXDBScalar</tt> attribute above adds the following subqueries (shown in bold type) to the SQL query that selects {{ProductReorder}} records.{{{{SELECT ...,
   <b> (SELECT TOP (1) ( productqty.availqty ) 
        FROM   productqty ProductQty 
        WHERE  ( productqty.productid = ProductReorder.productid ) 
        ORDER  BY productqty.availqty),<b>
     ...
FROM ...
}}}}
)))
==PXDBCalced==
The <tt>PXDBCalced</tt> attribute defines an expression that is translated into SQL. This expression calculates the field value from other fields of the same data record. An example of the <tt>PXDBCalced</tt> attribute is shown in the following code.<source lang="csharp">[PXDecimal(2)]
[PXUIField(DisplayName = "Discrepancy")]
[PXDBCalced(
    typeof(Minus&lt;
               Sub&lt;IsNull&lt;ProductReorder.availQty, decimal_0&gt;,
               ProductReorder.minAvailQty&gt;&gt;)
    typeof(Decimal))]
public virtual decimal? Discrepancy { get; set; }</source>((({S:Warn}The BQL expression specified in <tt>PXDBCalced</tt> in the previous code adds the following calculation expression to the SQL query that selects {{ProductReorder}} records.{{{{SELECT ...,
     <b>(( -( Isnull((SELECT TOP (1) ( productqty.availqty ) 
                 FROM   productqty ProductQty 
                 WHERE  ( productqty.productid = ProductReorder.productid ) 
                 ORDER  BY productqty.availqty), .0) 
             - ProductReorder.minavailqty ) ))<b>,
    ...   
FROM ...
}}}}
)))
Unlike <tt>PXDBCalced</tt>, the <tt>PXFormula</tt> attribute can be added to either an unbound or bound data field. Also, the <tt>PXFormula</tt> attribute provides calculation of master DAC fields from child DAC fields. For more information on <tt>PXFormula</tt>, see [HelpRoot_Dev_Platform\BL__con_Attr_Calculations|Calculation of Field Values].]]></column>
			<column name="PlainText"><![CDATA[Ad Hoc SQL for Fields The following attributes define the database-side calculation of data access class (DAC)         fields that are not bound to particular database columns: PXDBCalced <tt>PXDBCalced</tt>: Defines an SQL           expression that calculates an unbound field from the fields of the same DAC, whose values           are taken from the database. PXDBScalar <tt>PXDBScalar</tt>: Defines an SQL subrequest that retrieves a value           for an unbound DAC field. The subrequest can retrieve data from any bound field in any           DAC. The attributes add the provided expression and the subrequest into the SQL query that         selects data records of the given DAC. PXDBScalar The  PXDBScalar  attribute defines a subquery that selects the value         assigned to the field on which the attribute is specified. In the code example below,            PXDBScalar  selects the value from the            ProductQty.AvailQty  data field and inserts it into the            ProductReorder.AvailQty  field. // The ProductReorder class
[PXDecimal(2)]
[PXDBScalar(typeof(Search<ProductQty.availQty,
    Where<ProductQty.productID.IsEqual<ProductReorder.productID>>>))]
[PXUIField(DisplayName = "Available Qty", Enabled = false)]
public virtual decimal? AvailQty { get; set; } The BQL expressions specified in the  PXDBScalar  attribute above adds         the following subqueries (shown in bold type) to the SQL query that selects            ProductReorder          records. SELECT ...,
     (SELECT TOP (1) ( productqty.availqty ) 
        FROM   productqty ProductQty 
        WHERE  ( productqty.productid = ProductReorder.productid ) 
        ORDER  BY productqty.availqty), 
     ...
FROM ... PXDBCalced The  PXDBCalced  attribute defines an expression that is translated into         SQL. This expression calculates the field value from other fields of the same data record.         An example of the  PXDBCalced  attribute is shown in the following         code. [PXDecimal(2)]
[PXUIField(DisplayName = "Discrepancy")]
[PXDBCalced(
    typeof(Minus<
               Sub<IsNull<ProductReorder.availQty, decimal_0>,
               ProductReorder.minAvailQty>>)
    typeof(Decimal))]
public virtual decimal? Discrepancy { get; set; } The BQL expression specified in  PXDBCalced  in the previous code adds         the following calculation expression to the SQL query that selects            ProductReorder          records. SELECT ...,
      (( -( Isnull((SELECT TOP (1) ( productqty.availqty ) 
                 FROM   productqty ProductQty 
                 WHERE  ( productqty.productid = ProductReorder.productid ) 
                 ORDER  BY productqty.availqty), .0) 
             - ProductReorder.minavailqty ) )) ,
    ...   
FROM ... Unlike  PXDBCalced , the  PXFormula  attribute can be         added to either an unbound or bound data field. Also, the  PXFormula          attribute provides calculation of master DAC fields from child DAC fields. For more         information on  PXFormula , see  Calculation of Field Values. ]]></column>
		</row>
		<row PageID="259a9d39-e09d-4caf-969c-743f7b32deef" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="9eb043ed-193f-3308-d567-3a7bb19c4e1f" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The following attributes are placed on data access class (DAC) fields used for data audit: 
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=cd35c842-a4e7-e544-6dd1-6fefe379b341|<tt>PXDBLastChangeDateTime</tt>]: Maps a DAC field to the database column and automatically sets the field value to the data record&rsquo;s last modification date and time.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b2ed3b4c-869e-aa78-0440-25e5237d22a0|<tt>PXDBCreatedByID</tt>]: Maps a DAC field to a database column and automatically sets the field value to the ID of the user who created the data record.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7c141c4d-1c51-04d3-6011-c2277ecb2bf9|<tt>PXDBCreatedByScreenID</tt>]: Maps a DAC field to a database column and automatically sets the field value to the string ID of the application screen from which the data record was created.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=77dfd6d6-6050-1a83-2558-0351009241d0|<tt>PXDBCreatedDateTime</tt>]: Maps a DAC field to a database column and automatically sets the field value to the data record&rsquo;s creation date and time.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=62e93d23-636e-57c7-2b4f-6f4fe671e1ae|<tt>PXDBCreatedDateTimeUtc</tt>]: Maps a DAC field to a database column and automatically sets the field value to the data record&rsquo;s creation UTC date and time.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=99f6ff22-674a-629f-c9cb-02c17b6d26e5|<tt>PXDBLastModifiedByID</tt>]: Maps a DAC field to a database column and automatically sets the field value to the ID of the user who last modified the data record.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3575a029-3f68-4972-c950-9fc72b0c137b|<tt>PXDBLastModifiedByScreenID</tt>]: Maps a DAC field to a database column and automatically sets the field value to the string ID of the application screen on which the data record was last modified.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=acfc21ea-e732-de8c-5a29-89695691f22f|<tt>PXDBLastModifiedDateTime</tt>]: Maps a DAC field to a database column and automatically sets the field value to the data record&rsquo;s last modification date and time.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=19f32b15-683b-f8d2-fded-b6caf2475f1d|<tt>PXDBLastModifiedDateTimeUtc</tt>]: Maps a DAC field to a database column and automatically sets the field value to the data record&rsquo;s last modification date and time in UTC.

The framework binds the DAC fields to database columns and automatically assigns field values.]]></column>
			<column name="PlainText"><![CDATA[Audit Fields The following attributes are placed on data access class (DAC) fields                                 used for data audit:  PXDBLastChangeDateTime <tt>PXDBLastChangeDateTime</tt>:                                         Maps a DAC field to the database column and automatically                                         sets the field value to the data record's last modification                                         date and time. PXDBCreatedByID <tt>PXDBCreatedByID</tt>: Maps a                                         DAC field to a database column and automatically sets the                                         field value to the ID of the user who created the data                                         record. PXDBCreatedByScreenID <tt>PXDBCreatedByScreenID</tt>:                                         Maps a DAC field to a database column and automatically sets                                         the field value to the string ID of the application screen                                         from which the data record was created. PXDBCreatedDateTime <tt>PXDBCreatedDateTime</tt>:                                         Maps a DAC field to a database column and automatically sets                                         the field value to the data record's creation date and                                         time. PXDBCreatedDateTimeUtc <tt>PXDBCreatedDateTimeUtc</tt>:                                         Maps a DAC field to a database column and automatically sets                                         the field value to the data record's creation UTC date and                                         time. PXDBLastModifiedByID <tt>PXDBLastModifiedByID</tt>:                                         Maps a DAC field to a database column and automatically sets                                         the field value to the ID of the user who last modified the                                         data record. PXDBLastModifiedByScreenID <tt>PXDBLastModifiedByScreenID</tt>:                                         Maps a DAC field to a database column and automatically sets                                         the field value to the string ID of the application screen                                         on which the data record was last modified. PXDBLastModifiedDateTime <tt>PXDBLastModifiedDateTime</tt>:                                         Maps a DAC field to a database column and automatically sets                                         the field value to the data record's last modification date                                         and time. PXDBLastModifiedDateTimeUtc <tt>PXDBLastModifiedDateTimeUtc</tt>:                                         Maps a DAC field to a database column and automatically sets                                         the field value to the data record's last modification date                                         and time in UTC. The framework binds the DAC fields to database columns and automatically                                 assigns field values. ]]></column>
		</row>
		<row PageID="c41b409d-9580-42a9-9d79-76227ed7aeda" Language="en-US" PageRevisionID="1" Content="&#xA;The following attributes implement the projection of data from one table or multiple tables into a single data access class (DAC):[anchor|#ul_jtw_132_5k]&#xA;*[https://help.acumatica.com/Main?ScreenId=ShowWiki&amp;pageid=2331ae85-d8bc-88a4-a205-d9d41825f447|&lt;tt&gt;PXProjection&lt;/tt&gt;]: Binds the DAC to a random data set. The attribute thus defines a named view, but is implemented by the server side rather than by the database.&#xA;*[https://help.acumatica.com/Main?ScreenId=ShowWiki&amp;pageid=2b648bf4-6cf4-522e-52d7-a2db46f61f17|&lt;tt&gt;PXExtraKey&lt;/tt&gt;]: Indicates that the field implements a relationship between two tables. The use of this attribute enables the update of the referenced table when the projection is updated.&#xA;" PlainText="Data Projection The following attributes implement the projection of data from one table or multiple tables         into a single data access class (DAC): PXProjection &lt;tt&gt;PXProjection&lt;/tt&gt;: Binds the DAC to           a random data set. The attribute thus defines a named view, but is implemented by the           server side rather than by the database. PXExtraKey &lt;tt&gt;PXExtraKey&lt;/tt&gt;: Indicates that the field implements a             relationship between two tables. The use of this attribute enables the update of the             referenced table when the projection is updated. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="574240f8-999a-5e94-1a74-ec2bcde559b7" RecordSourceID="22377" />
		<row PageID="03d5ea15-1d8d-44fc-9c3b-acf797fce811" Language="en-US" PageRevisionID="1" Content="&#xA;The group mask value indicates the access rights a user should have in order to use a data record. To be able to set access rights for particular data records, you should use the &lt;tt&gt;PXDBGroupMask&lt;/tt&gt; attribute to mark the data access class (DAC) field that holds the group mask value.{br}&#xA;&#xA;On a substitute form, to define the inheritance of access rights for an action that is implemented in the corresponding entry form, you can use the &lt;tt&gt;PXEntryScreenRights&lt;/tt&gt; attribute.&#xA;==Related Articles==&#xA;*[https://help.acumatica.com/Main?ScreenId=ShowWiki&amp;pageid=0b26fe07-448a-37c0-7d90-73b6cd8385dc|PXDBGroupMaskAttribute Class]&#xA;*[https://help.acumatica.com/Main?ScreenId=ShowWiki&amp;pageid=ba267379-af16-f332-3ab2-d0c4902aa4da|PXEntryScreenRightsAttribute Class]" PlainText="Access Control The group mask value indicates the access rights a user should have in order to use a data         record. To be able to set access rights for particular data records, you should use the            PXDBGroupMask  attribute to mark the data access class (DAC) field that         holds the group mask value. On a substitute form, to define the inheritance of access rights for an action that is         implemented in the corresponding entry form, you can use the            PXEntryScreenRights  attribute. PXDBGroupMaskAttribute Class PXEntryScreenRightsAttribute Class " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="4cef5290-8a4b-2e92-5dd7-c264b400a87a" RecordSourceID="22377" />
		<row PageID="1206ded4-46ba-4d69-868e-ecf4a1f2ed09" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="da1e7420-531a-6364-a889-3a482613758e" RecordSourceID="22377">
			<column name="Content"><![CDATA[
By using the <tt>PXNote</tt> attribute, you can give users the ability to attach text notes, files, and activity items to data records, and to search for an entity by using the full-text search index.{br}

You should use the <tt>PXNote</tt> attribute in the data access class of these data records to mark the field that stores the identifier of a note in the <tt>Note</tt> table. Notes are used to attach text to a data record. This text is stored in the note data record in the <tt>Note</tt> table. Additionally, you can attach files or other entities to a data record through a note. This feature is implemented through additional tables that store the identifiers of a note and the attached entity.{br}

The <tt>PXNote</tt> attribute can also be configured to save the specified table fields in a note. In this case, by using the Acumatica Framework application website search, the user will be able to search the data records by the values saved in the note.
==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7996b57b-bfd3-ce24-d5dd-495b07254467|PXNoteAttribute Class]
*[HelpRoot_Dev_Platform\BL__how_Work_with_Attachments|To Allow Attachments to a Particular Form]
*[HelpRoot_Dev_Platform\BL__how_Display_Attached_Image|To Display an Attached Image on the Form]]]></column>
			<column name="PlainText"><![CDATA[Notes By using the  PXNote  attribute, you can give users the ability to attach         text notes, files, and activity items to data records, and to search for an entity by using         the full-text search index. You should use the  PXNote  attribute in the data access class of these         data records to mark the field that stores the identifier of a note in the            Note  table. Notes are used to attach text to a data record. This text         is stored in the note data record in the  Note  table. Additionally, you         can attach files or other entities to a data record through a note. This feature is         implemented through additional tables that store the identifiers of a note and the attached         entity. The  PXNote  attribute can also be configured to save the specified table         fields in a note. In this case, by using the  Acumatica Framework         application website search, the user will be able to search the data records by the values         saved in the note. PXNoteAttribute Class ]]></column>
		</row>
		<row PageID="72931747-da3b-4fc2-a766-a60c72b12f8d" Language="en-US" PageRevisionID="1" Content="&#xA;The value of an unbound data access class (DAC) field can be calculated in the property getter. The calculation can involve other fields of the same DAC. However, when the value of the DAC field is requested, other fields are not guaranteed to be calculated or assigned their values. These situations are normal when the integration services are used, copy-paste functionality is used, or the field is used in reports.{br}&#xA;&#xA;To ensure that the fields referenced in the property getter have values when it is executed, you should use the &lt;tt&gt;PXDependsOnFields&lt;/tt&gt; attribute.&#xA;==Related Articles==&#xA;*[https://help.acumatica.com/Main?ScreenId=ShowWiki&amp;pageid=5f2cb583-5aea-a584-786b-79aeb224895c|PXDependsOnFieldsAttribute Class]&#xA;*[HelpRoot_Dev_Platform\CC__con_Rendering_of_Reports|Display of Reports]" PlainText="Report Optimization The value of an unbound data access class (DAC) field can be calculated in the property         getter. The calculation can involve other fields of the same DAC. However, when the value of         the DAC field is requested, other fields are not guaranteed to be calculated or assigned         their values. These situations are normal when the integration services are used, copy-paste         functionality is used, or the field is used in reports. To ensure that the fields referenced in the property getter have values when it is         executed, you should use the  PXDependsOnFields  attribute. PXDependsOnFieldsAttribute Class " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="6fbb4cd5-d33d-f9c7-85bb-bc5f791c30dd" RecordSourceID="22377" />
		<row PageID="feec5367-994f-482c-b662-1006346d61c6" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="1906394f-134b-0040-2e46-b7a0e20573a8" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can place the following attributes on the data access class (DAC) declaration:[anchor|#ul_vgt_1jw_sk]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1dceb511-4e98-3700-7d7f-231688a7ac74|<tt>PXPrimaryGraph</tt>]: Specifies the graph that is used by default to edit a data record.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6e89e21c-b8f4-a16b-d741-2d6e483e9f65|<tt>PXCacheName</tt>]: Specifies the user-friendly name of the DAC. The name is displayed in the user interface.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=4c06b326-4644-cb3c-d502-327d3eb5a905|<tt>PXTable</tt>]: Binds a DAC that derives from another DAC to the table having the name of the derived table. Without the attribute, the derived DAC will be bound to the same table as the DAC that starts the inheritance hierarchy.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=4addf6d6-3ae5-0141-2edf-e44ff68a4a2b|<tt>PXAccumulator</tt>]: Updates the values of a data record in the database according to the policies specified in the attribute parameters.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a57486ae-817e-bfca-8807-baf14eb5d1be|<tt>PXHidden</tt>]: Gives the developer the ability to hide a DAC, graph, or view from the selectors of DACs and graphs, and from generic inquiries, reports, and the web services API.

The <tt>PXProjection</tt> and <tt>PXTable</tt> attributes can also mark a DAC. See [HelpRoot_Dev_Platform\BL__con_Attr_Projection|Data Projection] for more details.]]></column>
			<column name="PlainText"><![CDATA[Attributes on DACs You can place the following attributes on the data access class (DAC)                 declaration: PXPrimaryGraph <tt>PXPrimaryGraph</tt>:                     Specifies the graph that is used by default to edit a data record. PXCacheName <tt>PXCacheName</tt>:                     Specifies the user-friendly name of the DAC. The name is displayed in the user                     interface. PXTable <tt>PXTable</tt>: Binds a DAC that derives from                     another DAC to the table having the name of the derived table. Without the                     attribute, the derived DAC will be bound to the same table as the DAC that                     starts the inheritance hierarchy. PXAccumulator <tt>PXAccumulator</tt>:                     Updates the values of a data record in the database according to the policies                     specified in the attribute parameters. PXHidden <tt>PXHidden</tt>: Gives the                     developer the ability to hide a DAC, graph, or view from the selectors of DACs                     and graphs, and from generic inquiries, reports, and the web services API. The  PXProjection  and  PXTable  attributes can                 also mark a DAC. See  Data Projection for more                 details. ]]></column>
		</row>
		<row PageID="d7f7a53e-2a1b-49a6-be49-d2b1844c5a00" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="228e72ff-6000-ea29-7dc5-51a82e3736fe" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You use the following attributes to configure a button that will represent an action in the user interface:
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=54a2a223-b5ee-4e10-96af-a1a0853b6ce6|<tt>PXButton</tt>]: Serves as the base attribute for all other attributes, which give you the ability to configure buttons. The successor attributes only set the base class properties to specific values.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=32cb704a-5b7d-52c4-382d-07ad96524417|<tt>PXSaveButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3dee11ff-f322-9b6c-ed0e-6d3aa34640c9| <tt>PXSaveCloseButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9cb42733-87b0-b6cd-ae8f-e7beb3934dba| <tt>PXCancelButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8ee33144-6260-f281-aac0-e37030500ea0| <tt>PXCancelCloseButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1e6c3f34-fdce-1c7a-6896-25eab35218ed| <tt>PXInsertButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3531d82d-30ee-5fd7-3e63-7dcb8eb22cce| <tt>PXDeleteButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7a433359-55b8-d164-f531-42af4ca4075b| <tt>PXFirstButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c4fa313c-39e3-6b9a-5e2e-eb8fd5e349c3| <tt>PXPreviousButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=352ef8fb-fb92-97b5-68bb-098fa3a8c484| <tt>PXNextButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a8a501e1-1026-bef1-212b-a9e7e5626408| <tt>PXLastButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=64e89440-831a-5138-a7a9-893fd7c90b39| <tt>PXSendMailButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=096a97f9-23f7-d4e5-3200-04c3a5301f70| <tt>PXReplyMailButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=da3571a5-7790-e382-1f81-fc5f5af8340c| <tt>PXForwardMailButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=2a0013c8-d48a-985b-b140-7d6d1274bc23| <tt>PXTemplateMailButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=802b22a5-4210-bd81-41f2-4e62b3dee1ab| <tt>PXLookupButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6011f104-56a5-2bf8-ba17-4a394831c635| <tt>PXProcessButton</tt>]

Also, you can use the following attributes:[anchor|#_ae4ee79c-5cc1-4f95-a9f5-df1fbafcc4b9]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ea7ce94e-4b3e-0f91-df1d-a4ce8023b184|<tt>PXUIField</tt>]: To configure the button layout and set access rights
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ba267379-af16-f332-3ab2-d0c4902aa4da|<tt>PXEntryScreenRights</tt>]: On a List as Entry Point screen, to define the inheritance of access rights for an action that is implemented in the appropriate entry screen
]]></column>
			<column name="PlainText"><![CDATA[ Action Attributes You use the following attributes to configure a button that will represent an action in the         user interface: PXButton <tt>PXButton</tt>: Serves as the base attribute for all other attributes, which give you the ability to configure buttons. The successor attributes only set the base class properties to specific values. PXSaveButton <tt>PXSaveButton</tt>PXSaveCloseButton  <tt>PXSaveCloseButton</tt>PXCancelButton  <tt>PXCancelButton</tt>PXCancelCloseButton  <tt>PXCancelCloseButton</tt>PXInsertButton  <tt>PXInsertButton</tt>PXDeleteButton  <tt>PXDeleteButton</tt>PXFirstButton  <tt>PXFirstButton</tt>PXPreviousButton  <tt>PXPreviousButton</tt>PXNextButton  <tt>PXNextButton</tt>PXLastButton  <tt>PXLastButton</tt>PXSendMailButton  <tt>PXSendMailButton</tt>PXReplyMailButton  <tt>PXReplyMailButton</tt>PXForwardMailButton  <tt>PXForwardMailButton</tt>PXTemplateMailButton  <tt>PXTemplateMailButton</tt>PXLookupButton  <tt>PXLookupButton</tt>PXProcessButton  <tt>PXProcessButton</tt>Also, you can use the following attributes: PXUIField <tt>PXUIField</tt>: To configure the             button layout and set access rights PXEntryScreenRights <tt>PXEntryScreenRights</tt>: On a             List as Entry Point screen, to define the inheritance of access rights for an action             that is implemented in the appropriate entry screen ]]></column>
		</row>
		<row PageID="3073449e-2746-472f-b834-6d730bfac4fb" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="871c12bb-2882-62c9-bcdd-f2cf62994bff" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can place the following attributes on the declaration of a data view in a graph:
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1700f5aa-9484-5b47-02be-6cc2beaa6b6f|<tt>PXFilterable</tt>]: Adds the control that makes it possible for a user to create filters and save them in the database. The control is added to the grid that uses the data view to retrieve data.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c69d2832-e4b4-2477-928f-8d09762b3b21|<tt>PXImport</tt>]: Adds the grid toolbar button that a user clicks to load data from the file to the grid. The attribute is placed on the data view the grid uses to retrieve the data.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a57486ae-817e-bfca-8807-baf14eb5d1be|<tt>PXHidden</tt>]: Hides the data view from the selectors of data access classes (DACs) and graphs, and from the web service API clients.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=903e4699-206e-bc03-1e4b-d530eb4bb048|<tt>PXCopyPasteHiddenView</tt>]: Indicates that the cache corresponding to the primary DAC of the data view is not copied when the copy-paste feature is used on the form.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1258f435-4bc7-351c-aabc-7e22c6eb4245|<tt>PXCopyPasteHiddenFields</tt>]: Indicates that the specific fields of the primary DAC of the data view are not copied when the copy-paste feature is used on the form.
]]></column>
			<column name="PlainText"><![CDATA[Attributes on Data Views You can place the following attributes on the declaration of a data view in a                 graph: PXFilterable <tt>PXFilterable</tt>: Adds the control that makes it                     possible for a user to create filters and save them in the database. The control                     is added to the grid that uses the data view to retrieve data. PXImport <tt>PXImport</tt>: Adds the                     grid toolbar button that a user clicks to load data from the file to the grid.                     The attribute is placed on the data view the grid uses to retrieve the                     data. PXHidden <tt>PXHidden</tt>: Hides the                     data view from the selectors of data access classes (DACs) and graphs, and from                     the web service API clients. PXCopyPasteHiddenView <tt>PXCopyPasteHiddenView</tt>: Indicates that the cache                     corresponding to the primary DAC of the data view is not copied when the                     copy-paste feature is used on the form. PXCopyPasteHiddenFields <tt>PXCopyPasteHiddenFields</tt>: Indicates that the                     specific fields of the primary DAC of the data view are not copied when the                     copy-paste feature is used on the form. ]]></column>
		</row>
		<row PageID="80e817bd-e70b-45b9-a9b1-2d2d0e2f8ee2" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="14360641-f242-76e9-039e-c11af9e90dc2" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#_a7fe1ca7-ae4c-4b77-be14-035646cc5fba]
The attributes that you add to a data field in the DAC are initialized once, during the startup of the domain. You can replace attributes for a particular field by defining the {{CacheAttached}} event handler for this field in a graph. These attributes are also initialized once, on the first initialization of the graph where you define this method. {br}

The system stores the attributes from the DAC and graphs (''domain-level'' attributes). On each round trip, the system copies the appropriate domain-level attributes to the cache object, creating ''cache-level'' attributes. Attribute constructors are not invoked; instead, the system invokes the <tt>CacheAttached(PXCache)</tt> method for each copy of an attribute. If you modify an attribute&rsquo;s properties in code for a particular data record, the cache object creates a ''data-record'' copy of the attribute.
==Attribute Replacement in a Graph==
Attributes specified in a data access class apply to this class in every graph of the application unless a graph replaces them with other attributes. In some graphs, you may need attributes that differ from what is declared in the DAC. To replace attributes within a particular graph, add new attributes to the {{CacheAttached}} event handler for the particular field defined in the graph, as the following code shows. When you replace attributes, you have to redefine all attributes, including the type attribute.<source lang="csharp">// The CustomerMaint graph
[PXDBString(40, IsUnicode = true)]
// The field label for the form that works with the CustomerMaint graph
// is set to "Company"
[PXUIField(DisplayName = "Company")]
protected virtual void _(Events.CacheAttached&lt;Account.companyName&gt; e)
{ // Empty method
}</source>
In a graph, each <tt>PXCache</tt> object stores attributes for the corresponding DAC (see the diagram below). When a <tt>PXCache</tt> object is created, the framework searches for attributes of <tt>CacheAttached</tt> event handlers in the graph using the DAC field name. Attributes specified for these event handlers are copied to <tt>PXCache</tt> objects. If there is no <tt>CacheAttached</tt> event handler defined for a DAC field, the attributes are copied from the data access class. Attributes of <tt>CacheAttached</tt> event handlers are instantiated once, on the first initialization of the graph in which you define this event handler. In the data access class, the attributes are instantiated when the application domain starts.{br}

When you add an attribute to a DAC field, the attribute subscribes to certain events of Acumatica Framework. In event handlers, the attribute processes the field value based on the purpose of the attribute. For instance, the <tt>PXDefault</tt> attribute subscribes to the <tt>FieldDefaulting</tt> event and sets the default value every time the event is raised for the field. Multiple attributes can subscribe to the same event.[anchor|#image_prc_nhc_qm][image:StudioDeveloperGuide/Images/ReplacingAttrsInGraph.png|popup|Attribute replacement in a graph|400px]]]></column>
			<column name="PlainText"><![CDATA[Replacement of Attributes for DAC Fields in CacheAttached The attributes that you add to a data field in the DAC are initialized once, during the         startup of the domain. You can replace attributes for a particular field by defining the          CacheAttached  event handler for this field in a graph. These attributes         are also initialized once, on the first initialization of the graph where you define this         method.      The system stores the attributes from the DAC and graphs ( domain-level  attributes).         On each round trip, the system copies the appropriate domain-level attributes to the cache         object, creating  cache-level  attributes. Attribute constructors are not invoked;         instead, the system invokes the  CacheAttached(PXCache)  method for each         copy of an attribute. If you modify an attribute's properties in code for a particular data         record, the cache object creates a  data-record  copy of the attribute. Attribute Replacement in a Graph Attributes specified in a data access class apply to this class in every graph of the         application unless a graph replaces them with other attributes. In some graphs, you may need         attributes that differ from what is declared in the DAC. To replace attributes within a         particular graph, add new attributes to the  CacheAttached  event handler for         the particular field defined in the graph, as the following code shows. When you replace         attributes, you have to redefine all attributes, including the type attribute. // The CustomerMaint graph
[PXDBString(40, IsUnicode = true)]
// The field label for the form that works with the CustomerMaint graph
// is set to "Company"
[PXUIField(DisplayName = "Company")]
protected virtual void _(Events.CacheAttached<Account.companyName> e)
{ // Empty method
} In a graph, each  PXCache  object stores attributes for the corresponding         DAC (see the diagram below). When a  PXCache  object is created, the         framework searches for attributes of  CacheAttached  event handlers in the         graph using the DAC field name. Attributes specified for these event handlers are copied to            PXCache  objects. If there is no  CacheAttached  event         handler defined for a DAC field, the attributes are copied from the data access class.         Attributes of  CacheAttached  event handlers are instantiated once, on the         first initialization of the graph in which you define this event handler. In the data access         class, the attributes are instantiated when the application domain starts. When you add an attribute to a DAC field, the attribute subscribes to certain events of  Acumatica Framework.         In event handlers, the attribute processes the field value based on the purpose of the         attribute. For instance, the  PXDefault  attribute subscribes to the            FieldDefaulting  event and sets the default value every time the event         is raised for the field. Multiple attributes can subscribe to the same event. Attribute replacement in a graph ]]></column>
		</row>
		<row PageID="c15d3d56-f7c8-4026-8e06-c72982635451" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="fb8adbd2-3480-5c77-8c8f-dc44d64fc58e" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Typically, you use custom attributes for DAC fields to reuse the same behavior or business logic in multiple places of the application.{br}

If you want to add new functionality that can be used in multiple places of the application (for instance, automatic numbering of documents), you can create a custom attribute from scratch. To implement the new logic, you need to handle the events on which the logic should be performed. Acumatica Framework automatically subscribes attribute methods that implement interfaces to the corresponding events; you don&rsquo;t have to manually subscribe these methods to events. In many cases, you can also add static methods to the attribute class to provide the dynamic API of the attribute. By using these methods, you can change the attribute parameters of DAC fields in a graph at runtime.{br}{TOC}
==Creation of a Custom Attribute==
To create a custom attribute from scratch, you do the following (see the sample code below):[anchor|#ol_yns_zcs_km]
#Derive a new attribute class from <tt>PXEventSubscriberAttribute</tt>.
#Implement the constructor.
#Implement the {{CacheAttached}} method (if you are reading parameters or data from the database).
#Implement interfaces that correspond to the events.
{{{{public class MyFieldAttribute : PXEventSubscriberAttribute,   
                               // The FieldVerifying() method
                               IPXFieldVerifyingSubscriber 
{
    // Create internal objects here.
    // Do not read dynamic parameters or data from the database.
    public MyFieldAttribute()
    {
        // Code
    }
    
    // Process input parameters here; read dynamic parameters and data from
    // the database so that the data is current every time the cache is
    // initialized.
    public override void CacheAttached(PXCache sender)
    {
        // Code
    }
 
    // For instance, implement the IPXFieldVerifyingSubscriber interface.
    // The framework subscribes the method to the FieldVerifying event.
    // You don't have to manually subscribe this method to the event.
    public virtual void FieldVerifying(PXCache sender,
                                       PXFieldVerifyingEventArgs e)
    {
        // Code
    }

    // Add static methods to modify the attribute at runtime.
    // The first and second parameters are always the cache object
    // and data record.
    public virtual Type LastNumberField { get; private set; }
    public static void SetLastNumberField&lt;Field&gt;(
        PXCache sender, object row, Type lastNumberField)
        where Field : IBqlField
    {
        // Search for the attributes in the provided cache object
        foreach (PXEventSubscriberAttribute attribute in
                     sender.GetAttributes&lt;Field&gt;(row))
        {
            if (attribute is AutoNumberAttribute)
            {
                AutoNumberAttribute attr = (AutoNumberAttribute)attribute;
                attr.LastNumberField = lastNumberField;
                attr.CreateLastNumberCommand();
            }
        }
    } 
}
}}}}
==Implementation of the Attribute Constructor and CacheAttached Methods==
In the constructor, you usually validate input parameters and save them to internal objects of the attribute. However, to read data from the database or conditionally configure the attribute, you typically use the <tt>CacheAttached()</tt> method of the attribute. When you create a custom attribute, you should take into account that the attribute constructor is invoked only during domain startup and on the initialization of a graph with the <tt>CacheAttached()</tt> event handler (see [HelpRoot_Dev_Platform\BL__con_Replacement_of_Attributes|Replacement of Attributes for DAC Fields in CacheAttached]).{br}

We recommend that you read the data from the database in the graph execution context. To do this, read the data and set the actual parameters for the attribute in the <tt>CacheAttached()</tt> method that you override in your custom attribute. From the <tt>sender</tt> input parameter of the <tt>CacheAttached()</tt> method, you can get the reference to the graph in whose context the attribute is used. Every time the framework initializes a cache within a graph, the <tt>CacheAttached()</tt> method implemented in the attribute is invoked for each attribute on a DAC field for that particular graph. The graph is created on every round trip, so if you read data in <tt>CacheAttached()</tt>, the attribute retrieves the actual parameters every time. Also, you might need to read data in event handlers just before you use the data in the attribute. For instance, in [[#_42d05654-3d75-459f-89a4-c57f9bb7b602|Example] in this topic, you retrieve the last assigned number in the <tt>RowPersisting()</tt> method just before you calculate the new number and insert it into a document.((({S:Warn}Do not confuse the <tt>CacheAttached()</tt> method that you implement in attributes with the {{CacheAttached()}} event handler that you define in a graph. The {{CacheAttached()}} event handler of the graph has no implementation and is used as a marker to substitute attributes on the specified DAC field in that particular graph. The <tt>CacheAttached()</tt> method implemented in attributes is invoked on attributes that are current for the graph when the appropriate cache is initialized.
)))
==Implementation of a Static Method of an Attribute==
To implement a static method that provides dynamic configuration of the attribute, you can define a static method, taking into account the following considerations:[anchor|#ol_dpv_n4p_lm]
#You should pass a <tt>PXCache</tt> object and a data record as input parameters of the method.
#To be able to get the attribute object on a particular field of a record, you should define the generic method with the {{<Field>}} type parameter. To get the collection of attributes on the field, invoke the {{GetAttributes<Field>(record)}} method of the <tt>PXCache</tt> object that stores the record.
#To find the needed attribute, you should iterate the collection of attributes to find the object of the needed attribute type.

In the following code example, the static {{SetPrefix<Field>}} method of the {{AutoNumberAttribute}} class sets the {{Prefix}} property of the attribute object to the specified prefix.<source lang="csharp">// The static method of the AutoNumberAttribute attribute dynamically sets the number prefix
public static void SetPrefix&lt;Field&gt;(
    PXCache sender, object row, string prefix) where Field : IBqlField
{
    foreach (PXEventSubscriberAttribute attribute in sender.GetAttributes&lt;Field&gt;(row))
    {
        if (attribute is AutoNumberAttribute)
            ((AutoNumberAttribute)attribute).Prefix = prefix;
    }
}
// Assigning the number prefix depending on the document type
public virtual void Document_RowPersisting(PXCache cache, PXRowPersistingEventArgs e)
{
    Document doc = (Document)e.Row;
    if (doc != null)
    {
        switch (doc.DocType)
        {
            case DocType.R: // no prefix
                AutoNumberAttribute.SetPrefix&lt;Document.docNbr&gt;(cache, doc, null);
                break;
            case DocType.N:
                AutoNumberAttribute.SetPrefix&lt;Document.docNbr&gt;(cache, doc, "RET");
                break;
         }
    }
}</source>
==Event Handlers Implemented in Attributes and Graphs==
Event handlers implemented in graphs are stored in separate collections in the graph for each event. The framework determines which attribute handlers an attribute defines based on the interfaces the attribute implements.{br}

The attribute and graph handlers that handle the same event are executed in the defined order. In ''-ing'' events, such as <tt>FieldDefaulting</tt>, the attribute handlers are invoked after the handlers of the graph. So if you generate the default value in a graph handler and don&rsquo;t want attributes to change it, you can cancel the execution of attribute handlers for this field by setting the <tt>e.Cancel</tt> property to {{true}} in the graph handler (see the diagram in [HelpRoot_Dev_Platform\BL__con_Events_Insert|Sequence of Events: Insertion of a Data Record]). {br}

In the ''-ed'' events, such as <tt>RowUpdated</tt>, attribute handlers are executed before handlers implemented in the graph. In ''-ed'' events, you typically implement some additional logic, and you cannot cancel attribute handlers.[anchor|#_42d05654-3d75-459f-89a4-c57f9bb7b602]
==Example==
In this section, you can find an example of the creation of a custom attribute that provides automatic numbering of documents.((({S:Warn}Instead of creating a custom attribute, you can use the predefined auto-numbering attributes of Acumatica ERP, such as <tt>PX.Objects.CS.AutoNumberAttribute</tt>.
))){br}

In this example, the following event handlers are implemented for the attribute:[anchor|#ol_mrc_wyh_lm]
*<tt>FieldDefaulting()</tt>, which inserts the placeholder into a new document.
*<tt>FieldVerifying()</tt>, which prevents users from entering a nonexistent document number into the field. The nonexistent number is replaced with the ''&lt;NEW&gt;'' placeholder.
*<tt>RowPersisting()</tt>, which assigns the new document number before the record is saved to the database and updates the last assigned number stored in the configuration.
*<tt>RowPersisted()</tt>, which checks the database transaction status and resets the default number if the transaction fails.

As the runtime API of the attribute, the following static methods, which enable dynamic setup of the last number field and add a prefix to the number, are implemented:[anchor|#ol_gbm_g13_lm]
*{{SetLastNumberField<Field>}} sets the last number field for the attribute.
*{{SetPrefix<Field>}} sets the number prefix.

To implement the attribute, you would do the following:[anchor|#ol_cq2_brq_jm]
#Define the {{AutoNumber}} attribute as follows.<source lang="csharp">public class AutoNumberAttribute : PXEventSubscriberAttribute, 
                                   IPXFieldVerifyingSubscriber,
                                   IPXFieldDefaultingSubscriber, 
                                   IPXRowPersistingSubscriber,
                                   IPXRowPersistedSubscriber
{
}</source>
#:The declared interfaces correspond to events that you handle in the attribute.
#In the {{AutoNumber}} attribute, define the listed fields for the internal objects (the flag that enables or disables automatic numbering, and the command that retrieves the last number) and two properties (the last number field and the number prefix). See the following code.<source lang="csharp">public const string NewValue = "&lt;NEW&gt;";

private bool _AutoNumbering;
private Type _AutoNumberingField;
private BqlCommand _LastNumberCommand;

public virtual Type LastNumberField { get; private set; }
public virtual string Prefix { get; private set; }</source>
#Define two attribute constructors, one with one {{Type}} parameter and another with two {{Type}} parameters, and define the {{CreateLastNumberCommand()}} method. (See the following code.)<source lang="csharp">public AutoNumberAttribute(Type autoNumbering)
{
    if (autoNumbering != null && 
        (typeof(IBqlSearch).IsAssignableFrom(autoNumbering) ||
            typeof(IBqlField).IsAssignableFrom(autoNumbering) &&
                autoNumbering.IsNested))
    {
        _AutoNumberingField = autoNumbering;
    }
    else
    {
        throw new PXArgumentException("autoNumbering");
    }
}

public AutoNumberAttribute(Type autoNumbering, Type lastNumberField)
    : this(autoNumbering)
{
    LastNumberField = lastNumberField;
    CreateLastNumberCommand();
} 

private void CreateLastNumberCommand()
{
    _LastNumberCommand = null;

    if (LastNumberField != null)
    {
        if (typeof(IBqlSearch).IsAssignableFrom(LastNumberField))
            _LastNumberCommand = BqlCommand.CreateInstance(LastNumberField);
        else if (typeof(IBqlField).IsAssignableFrom(LastNumberField) &&
                 LastNumberField.IsNested)
            _LastNumberCommand = BqlCommand.CreateInstance(
                typeof(Search&lt;&gt;), LastNumberField);
    }

    if (_LastNumberCommand == null)
        throw new PXArgumentException("lastNumberField");
}</source>
#:In the constructor, you validate input parameters and ensure that each of them is a valid DAC field type or a BQL <tt>Search&lt;&gt;</tt> type. The first parameter specifies the auto-numbering flag field that enables or disables automatic numbering of documents. The second parameter specifies the field from which the attribute will take the last assigned number to calculate the next number for a new document. In the {{_LastNumberCommand}} field, you construct the BQL <tt>Search&lt;&gt;</tt> type that selects the last number field from the database. You will use this command to retrieve the last assigned number from the setup parameters in the <tt>RowPersisting</tt> event handler.
#Override the <tt>CacheAttached()</tt> method of the base <tt>PXEventSubscriberAttribute</tt> class, as shown in the following code.<source lang="csharp">public override void CacheAttached(PXCache sender)
{
    BqlCommand command = null;
    Type autoNumberingField = null;
    // Create the BqlCommand from Search&lt;&gt;
    if (typeof(IBqlSearch).IsAssignableFrom(_AutoNumberingField))
    {
        command = BqlCommand.CreateInstance(_AutoNumberingField);
        autoNumberingField = ((IBqlSearch)command).GetField();
    }
    // Otherwise, create the Bql command from the field.
    else
    {
        command = BqlCommand.CreateInstance(
            typeof(Search&lt;&gt;), _AutoNumberingField);
        autoNumberingField = _AutoNumberingField;
    }
    // In CacheAttached, get the reference to the graph.
    PXView view = new PXView(sender.Graph, true, command);
    object row = view.SelectSingle();
    if (row != null)
    {
        _AutoNumbering = (bool)view.Cache.GetValue(
            row, autoNumberingField.Name);
    }
}</source>
#:In the <tt>CacheAttached()</tt> method, you retrieve the auto-numbering flag from the database. To retrieve the flag, you create a <tt>BqlCommand</tt> object that is passed to a <tt>PXView</tt> object. The <tt>BqlCommand</tt> object represents a BQL statement that is translated into an SQL SELECT query and executed in the database by the <tt>PXView</tt> object.
#:To select the data record, you invoke the <tt>SelectSingle()</tt> method of the <tt>PXView</tt> object, which retrieves the data from the database by using the specified command. You use the <tt>SelectSingle()</tt> method, which generates the SQL statement with {{TOP 1}} records to return, which executes faster. You can select a single row because only one record in the setup table has the configuration of the current company. If the retrieved flag is enabled, you set the {{_AutoNumbering}} field of the attribute to {{true}}.
#:((({S:Warn}For details about <tt>PXView</tt>, see [HelpRoot_Dev_Platform\BL__con_Views|PXView Type and Views Collection].
)))
#Add the <tt>FieldDefaulting()</tt> and <tt>FieldVerifying()</tt> methods, as follows.<source lang="csharp">public virtual void FieldDefaulting(
    PXCache sender, PXFieldDefaultingEventArgs e)
{
    if (_AutoNumbering)
    {
        e.NewValue = NewValue;
    }}

public virtual void FieldVerifying(
    PXCache sender, PXFieldVerifyingEventArgs e)
{
    if (_AutoNumbering && 
        PXSelectorAttribute.Select(sender, e.Row, _FieldName, e.NewValue)
            == null)
    {
        e.NewValue = NewValue;
    }
}</source>
#:On the <tt>FieldDefaulting</tt> event, you insert the ''&lt;NEW&gt;'' placeholder into the number field for a new document. On the <tt>FieldVerifying</tt> event, you revert the number to the placeholder if a user has entered a nonexistent document number. If the user has entered the number of a document that exists, the document opens on the form.
#Add the <tt>RowPersisting()</tt> method and the auxiliary {{GetNewNumber()}} method, which is called from <tt>RowPersisting()</tt>, as shown in the following code.<source lang="csharp">protected virtual string GetNewNumber(PXCache sender, Type setupType)
{
    if (_LastNumberCommand == null)
        CreateLastNumberCommand();
    PXView view = new PXView(sender.Graph, false, _LastNumberCommand);

    // Get the record from Setup
    object row = view.SelectSingle();
    if (row == null) return null;

    // Get the last assigned number
    string lastNumber = (string)view.Cache.GetValue(
        row, LastNumberField.Name);
    char[] symbols = lastNumber.ToCharArray();

    // Increment the last number
    for (int i = symbols.Length - 1; i &gt;= 0; i--)
    {
        if (!char.IsDigit(symbols[i])) break;

        if (symbols[i] &lt; '9')
        {
            symbols[i]++;
            break;
        }
        symbols[i] = '0';
    }
    lastNumber = new string(symbols);

    // Update the last number in the PXCache object for Setup
    view.Cache.SetValue(row, LastNumberField.Name, lastNumber);
    PXCache setupCache = sender.Graph.Caches[setupType];
    setupCache.Update(row);
    setupCache.PersistUpdated(row);

    // Insert the document number with the prefix
    if (!string.IsNullOrEmpty(Prefix))
    {
        lastNumber = Prefix + lastNumber;
    }
    return lastNumber;
}

public virtual void RowPersisting(PXCache sender, PXRowPersistingEventArgs e)
{
    // For a new record inserted into the database table
    if ( _AutoNumbering && 
         (e.Operation & PXDBOperation.Command) == PXDBOperation.Insert )
    {
        Type setupType = BqlCommand.GetItemType(_AutoNumberingField);

        string lastNumber = GetNewNumber(sender, setupType);
        if (lastNumber != null)
        {
            // Updating the document number in the PXCache
            // object for the document
            sender.SetValue(e.Row, _FieldOrdinal, lastNumber);
        }
    }
}</source>
#:On the <tt>RowPersisting</tt> event occurs, you retrieve the last number from the setup record, increment the number, insert the new value into the document, and update the last assigned number in the setup record. The <tt>RowPersisting</tt> event is the last event raised before Acumatica Framework commits changed data from cache objects to the database. To avoid duplicate numbers, you calculate the new value just before the data record is saved to the database.
#Define the <tt>RowPersisted()</tt> method as the following code shows.<source lang="csharp">public virtual void RowPersisted(PXCache sender, PXRowPersistedEventArgs e)
{
    // If the database transaction doesn't succeed
    if ( _AutoNumbering && 
         (e.Operation & PXDBOperation.Command) == PXDBOperation.Insert &&
         e.TranStatus == PXTranStatus.Aborted )
    {
        // Roll back the document number to the default value.
        sender.SetValue(e.Row, _FieldOrdinal, NewValue);
        // If transaction isn't successful, remove the setup record;
        // it hasn't been saved because of transaction rollback.
        Type setupType = BqlCommand.GetItemType(_AutoNumberingField);
        sender.Graph.Caches[setupType].Clear();
    }
}</source>
#:The <tt>RowPersisted</tt> event, in which {{e.TranStatus}} may have the {{Completed}} or {{Aborted}} value, is raised after all changes from cache objects of the graph are committed to the database. If any error occurs during the transaction, you remove the new document number, which hasn&rsquo;t been saved for a document, from the <tt>PXCache</tt> object for the {{setupType}} DAC. For details on the process of saving changes to the database, see [HelpRoot_Dev_Platform\BL__con_SavingChangesInDB|Saving of Changes to the Database].
#Define the static {{SetLastNumberField<Field>()}} method, as shown in the following code.<source lang="csharp">public static void SetLastNumberField&lt;Field&gt;(PXCache sender, object row,
                                             Type lastNumberField)
    where Field : IBqlField
{
    foreach (PXEventSubscriberAttribute attribute in
                 sender.GetAttributes&lt;Field&gt;(row))
    {
        if (attribute is AutoNumberAttribute)
        {
            AutoNumberAttribute attr = (AutoNumberAttribute)attribute;
            attr.LastNumberField = lastNumberField;
            attr.CreateLastNumberCommand();
        }
    }
}</source>
#:The {{SetLastNumberField<Field>()}} method provides the API that dynamically configures the attribute in graph handlers. By invoking this method in the <tt>RowPersisting</tt> event handler in the graph, you can dynamically change the last number field depending on some condition (in this example, the document type). In the {{SetLastNumberField<Field>()}} method, you update the {{lastNumberField}} type and command of the attribute. To get the attribute object, you iterate the collection of attributes on the specified field and search for the attribute by its type.
#Define the static {{SetPrefix<Field>()}} method of the attribute, as the following code shows.<source lang="csharp">public static void SetPrefix&lt;Field&gt;(PXCache sender, object row, string prefix)
    where Field : IBqlField
{
    foreach (PXEventSubscriberAttribute attribute in
                 sender.GetAttributes&lt;Field&gt;(row))
    {
        if (attribute is AutoNumberAttribute)
        {
            ((AutoNumberAttribute)attribute).Prefix = prefix;
        }
    }
}</source>
#:The {{SetPrefix<Field>()}} method sets the prefix that is added to the number generated by the {{AutoNumber}} attribute.

Now the {{AutoNumber}} attribute is ready, and you can use it for the numbering of documents and sales orders. To use the attribute, add it to the document number field in the DAC, as shown in the code below. <source lang="csharp">// Enables auto-numbering of sales orders 
// in the SalesOrder.OrderNbr field
[AutoNumber(typeof(Setup.autoNumbering), typeof(Setup.salesOrderLastNbr))]
public virtual string OrderNbr
{...}</source>]]></column>
			<column name="PlainText"><![CDATA[Custom Attributes Typically, you use custom attributes for DAC fields to reuse the same behavior or                 business logic in multiple places of the application. If you want to add new functionality that can be used in multiple places of the                 application (for instance, automatic numbering of documents), you can create a                 custom attribute from scratch. To implement the new logic, you need to handle the                 events on which the logic should be performed.  Acumatica Framework automatically subscribes attribute methods that implement interfaces to the                 corresponding events; you don't have to manually subscribe these methods to events.                 In many cases, you can also add static methods to the attribute class to provide the                 dynamic API of the attribute. By using these methods, you can change the attribute                 parameters of DAC fields in a graph at runtime. Creation of a Custom Attribute To create a custom attribute from scratch, you do the following (see the sample code                 below): Derive a new attribute class from                      PXEventSubscriberAttribute . Implement the constructor. Implement the  CacheAttached  method (if you are reading                     parameters or data from the database). Implement interfaces that correspond to the events. public class MyFieldAttribute : PXEventSubscriberAttribute,   
                               // The FieldVerifying() method
                               IPXFieldVerifyingSubscriber 
{
    // Create internal objects here.
    // Do not read dynamic parameters or data from the database.
    public MyFieldAttribute()
    {
        // Code
    }
    
    // Process input parameters here; read dynamic parameters and data from
    // the database so that the data is current every time the cache is
    // initialized.
    public override void CacheAttached(PXCache sender)
    {
        // Code
    }
 
    // For instance, implement the IPXFieldVerifyingSubscriber interface.
    // The framework subscribes the method to the FieldVerifying event.
    // You don't have to manually subscribe this method to the event.
    public virtual void FieldVerifying(PXCache sender,
                                       PXFieldVerifyingEventArgs e)
    {
        // Code
    }

    // Add static methods to modify the attribute at runtime.
    // The first and second parameters are always the cache object
    // and data record.
    public virtual Type LastNumberField { get; private set; }
    public static void SetLastNumberField<Field>(
        PXCache sender, object row, Type lastNumberField)
        where Field : IBqlField
    {
        // Search for the attributes in the provided cache object
        foreach (PXEventSubscriberAttribute attribute in
                     sender.GetAttributes<Field>(row))
        {
            if (attribute is AutoNumberAttribute)
            {
                AutoNumberAttribute attr = (AutoNumberAttribute)attribute;
                attr.LastNumberField = lastNumberField;
                attr.CreateLastNumberCommand();
            }
        }
    } 
} Implementation of the Attribute Constructor and CacheAttached Methods In the constructor, you usually validate input parameters and save them to internal objects of                 the attribute. However, to read data from the database or conditionally configure                 the attribute, you typically use the  CacheAttached()  method of                 the attribute. When you create a custom attribute, you should take into account that                 the attribute constructor is invoked only during domain startup and on the                 initialization of a graph with the  CacheAttached()  event handler                 (see  Replacement of Attributes for DAC Fields in CacheAttached). We recommend that you read the data from the database in the graph execution context.                 To do this, read the data and set the actual parameters for the attribute in the                      CacheAttached()  method that you override in your custom                 attribute. From the  sender  input parameter of the                      CacheAttached()  method, you can get the reference to the                 graph in whose context the attribute is used. Every time the framework initializes a                 cache within a graph, the  CacheAttached()  method implemented in                 the attribute is invoked for each attribute on a DAC field for that particular                 graph. The graph is created on every round trip, so if you read data in                      CacheAttached() , the attribute retrieves the actual                 parameters every time. Also, you might need to read data in event handlers just                 before you use the data in the attribute. For instance, in  Example Example in this topic, you retrieve the last assigned number in the                      RowPersisting()  method just before you calculate the new                 number and insert it into a document. Do not confuse the  CacheAttached()  method that you implement in                 attributes with the  CacheAttached()  event handler that you define                 in a graph. The  CacheAttached()  event handler of the graph has no                 implementation and is used as a marker to substitute attributes on the specified DAC                 field in that particular graph. The  CacheAttached()  method                 implemented in attributes is invoked on attributes that are current for the graph                 when the appropriate cache is initialized. Implementation of a Static Method of an Attribute To implement a static method that provides dynamic configuration of the attribute,                 you can define a static method, taking into account the following                 considerations: You should pass a  PXCache  object and a data record as input                     parameters of the method. To be able to get the attribute object on a particular field of a record, you                     should define the generic method with the  <Field>  type                     parameter. To get the collection of attributes on the field, invoke the                          GetAttributes<Field>(record)  method of the                          PXCache  object that stores the record. To find the needed attribute, you should iterate the collection of attributes to                     find the object of the needed attribute type. In the following code example, the static  SetPrefix<Field>  method                 of the  AutoNumberAttribute  class sets the  Prefix                  property of the attribute object to the specified prefix. // The static method of the AutoNumberAttribute attribute dynamically sets the number prefix
public static void SetPrefix<Field>(
    PXCache sender, object row, string prefix) where Field : IBqlField
{
    foreach (PXEventSubscriberAttribute attribute in sender.GetAttributes<Field>(row))
    {
        if (attribute is AutoNumberAttribute)
            ((AutoNumberAttribute)attribute).Prefix = prefix;
    }
}
// Assigning the number prefix depending on the document type
public virtual void Document_RowPersisting(PXCache cache, PXRowPersistingEventArgs e)
{
    Document doc = (Document)e.Row;
    if (doc != null)
    {
        switch (doc.DocType)
        {
            case DocType.R: // no prefix
                AutoNumberAttribute.SetPrefix<Document.docNbr>(cache, doc, null);
                break;
            case DocType.N:
                AutoNumberAttribute.SetPrefix<Document.docNbr>(cache, doc, "RET");
                break;
         }
    }
} Event Handlers Implemented in Attributes and Graphs Event handlers implemented in graphs are stored in separate collections in the graph                 for each event. The framework determines which attribute handlers an attribute                 defines based on the interfaces the attribute implements. The attribute and graph handlers that handle the same event are executed in the                 defined order. In  -ing  events, such as  FieldDefaulting ,                 the attribute handlers are invoked after the handlers of the graph. So if you                 generate the default value in a graph handler and don't want attributes to change                 it, you can cancel the execution of attribute handlers for this field by setting the                      e.Cancel  property to  true  in the graph                 handler (see the diagram in  Sequence of Events: Insertion of a Data Record).  In the  -ed  events, such as  RowUpdated , attribute handlers                 are executed before handlers implemented in the graph. In  -ed  events, you                 typically implement some additional logic, and you cannot cancel attribute                 handlers. Example In this section, you can find an example of the creation of a custom attribute that                 provides automatic numbering of documents. Instead of creating a custom                     attribute, you can use the predefined auto-numbering attributes of  Acumatica ERP, such as  PX.Objects.CS.AutoNumberAttribute . In this example, the following event handlers are implemented for the attribute: FieldDefaulting() , which inserts the placeholder into a new                     document. FieldVerifying() , which prevents users from entering a                     nonexistent document number into the field. The nonexistent number is replaced                     with the  <NEW>  placeholder. RowPersisting() , which assigns the new document number before                     the record is saved to the database and updates the last assigned number stored                     in the configuration. RowPersisted() , which checks the database transaction status                     and resets the default number if the transaction fails. As the runtime API of the attribute, the following static methods, which enable                 dynamic setup of the last number field and add a prefix to the number, are                 implemented: SetLastNumberField<Field>  sets the last number field for the                     attribute. SetPrefix<Field>  sets the number prefix. To implement the attribute, you would do the following: Define the  AutoNumber  attribute as                         follows. public class AutoNumberAttribute : PXEventSubscriberAttribute, 
                                   IPXFieldVerifyingSubscriber,
                                   IPXFieldDefaultingSubscriber, 
                                   IPXRowPersistingSubscriber,
                                   IPXRowPersistedSubscriber
{
} The                         declared interfaces correspond to events that you handle in the                         attribute. In the  AutoNumber  attribute, define the listed fields for the                     internal objects (the flag that enables or disables automatic numbering, and the                     command that retrieves the last number) and two properties (the last number                     field and the number prefix). See the following                     code. public const string NewValue = "<NEW>";

private bool _AutoNumbering;
private Type _AutoNumberingField;
private BqlCommand _LastNumberCommand;

public virtual Type LastNumberField { get; private set; }
public virtual string Prefix { get; private set; } Define two attribute constructors, one with one  Type  parameter                     and another with two  Type  parameters, and define the                          CreateLastNumberCommand()  method. (See the following                         code.) public AutoNumberAttribute(Type autoNumbering)
{
    if (autoNumbering != null && 
        (typeof(IBqlSearch).IsAssignableFrom(autoNumbering) ||
            typeof(IBqlField).IsAssignableFrom(autoNumbering) &&
                autoNumbering.IsNested))
    {
        _AutoNumberingField = autoNumbering;
    }
    else
    {
        throw new PXArgumentException("autoNumbering");
    }
}

public AutoNumberAttribute(Type autoNumbering, Type lastNumberField)
    : this(autoNumbering)
{
    LastNumberField = lastNumberField;
    CreateLastNumberCommand();
} 

private void CreateLastNumberCommand()
{
    _LastNumberCommand = null;

    if (LastNumberField != null)
    {
        if (typeof(IBqlSearch).IsAssignableFrom(LastNumberField))
            _LastNumberCommand = BqlCommand.CreateInstance(LastNumberField);
        else if (typeof(IBqlField).IsAssignableFrom(LastNumberField) &&
                 LastNumberField.IsNested)
            _LastNumberCommand = BqlCommand.CreateInstance(
                typeof(Search<>), LastNumberField);
    }

    if (_LastNumberCommand == null)
        throw new PXArgumentException("lastNumberField");
} In                         the constructor, you validate input parameters and ensure that each of them                         is a valid DAC field type or a BQL  Search<>  type.                         The first parameter specifies the auto-numbering flag field that enables or                         disables automatic numbering of documents. The second parameter specifies                         the field from which the attribute will take the last assigned number to                         calculate the next number for a new document. In the                              _LastNumberCommand  field, you construct the BQL                              Search<>  type that selects the last number                         field from the database. You will use this command to retrieve the last                         assigned number from the setup parameters in the                              RowPersisting  event handler. Override the  CacheAttached()  method of the base                          PXEventSubscriberAttribute  class, as shown in the                     following                         code. public override void CacheAttached(PXCache sender)
{
    BqlCommand command = null;
    Type autoNumberingField = null;
    // Create the BqlCommand from Search<>
    if (typeof(IBqlSearch).IsAssignableFrom(_AutoNumberingField))
    {
        command = BqlCommand.CreateInstance(_AutoNumberingField);
        autoNumberingField = ((IBqlSearch)command).GetField();
    }
    // Otherwise, create the Bql command from the field.
    else
    {
        command = BqlCommand.CreateInstance(
            typeof(Search<>), _AutoNumberingField);
        autoNumberingField = _AutoNumberingField;
    }
    // In CacheAttached, get the reference to the graph.
    PXView view = new PXView(sender.Graph, true, command);
    object row = view.SelectSingle();
    if (row != null)
    {
        _AutoNumbering = (bool)view.Cache.GetValue(
            row, autoNumberingField.Name);
    }
} In                         the  CacheAttached()  method, you retrieve the                         auto-numbering flag from the database. To retrieve the flag, you create a                              BqlCommand  object that is passed to a                              PXView  object. The  BqlCommand                          object represents a BQL statement that is translated into an SQL SELECT                         query and executed in the database by the  PXView                          object. To select the data record, you invoke the                              SelectSingle()  method of the                              PXView  object, which retrieves the data from the                         database by using the specified command. You use the                              SelectSingle()  method, which generates the SQL                         statement with  TOP 1  records to return, which executes                         faster. You can select a single row because only one record in the setup                         table has the configuration of the current company. If the retrieved flag is                         enabled, you set the  _AutoNumbering  field of the attribute                         to  true . For details about                              PXView , see  PXView Type and Views Collection. Add the  FieldDefaulting()  and                          FieldVerifying()  methods, as                         follows. public virtual void FieldDefaulting(
    PXCache sender, PXFieldDefaultingEventArgs e)
{
    if (_AutoNumbering)
    {
        e.NewValue = NewValue;
    }}

public virtual void FieldVerifying(
    PXCache sender, PXFieldVerifyingEventArgs e)
{
    if (_AutoNumbering && 
        PXSelectorAttribute.Select(sender, e.Row, _FieldName, e.NewValue)
            == null)
    {
        e.NewValue = NewValue;
    }
} On                         the  FieldDefaulting  event, you insert the  <NEW>                          placeholder into the number field for a new document. On the                              FieldVerifying  event, you revert the number to the                         placeholder if a user has entered a nonexistent document number. If the user                         has entered the number of a document that exists, the document opens on the                         form. Add the  RowPersisting()  method and the auxiliary                          GetNewNumber()  method, which is called from                          RowPersisting() , as shown in the following                         code. protected virtual string GetNewNumber(PXCache sender, Type setupType)
{
    if (_LastNumberCommand == null)
        CreateLastNumberCommand();
    PXView view = new PXView(sender.Graph, false, _LastNumberCommand);

    // Get the record from Setup
    object row = view.SelectSingle();
    if (row == null) return null;

    // Get the last assigned number
    string lastNumber = (string)view.Cache.GetValue(
        row, LastNumberField.Name);
    char[] symbols = lastNumber.ToCharArray();

    // Increment the last number
    for (int i = symbols.Length - 1; i >= 0; i--)
    {
        if (!char.IsDigit(symbols[i])) break;

        if (symbols[i] < '9')
        {
            symbols[i]++;
            break;
        }
        symbols[i] = '0';
    }
    lastNumber = new string(symbols);

    // Update the last number in the PXCache object for Setup
    view.Cache.SetValue(row, LastNumberField.Name, lastNumber);
    PXCache setupCache = sender.Graph.Caches[setupType];
    setupCache.Update(row);
    setupCache.PersistUpdated(row);

    // Insert the document number with the prefix
    if (!string.IsNullOrEmpty(Prefix))
    {
        lastNumber = Prefix + lastNumber;
    }
    return lastNumber;
}

public virtual void RowPersisting(PXCache sender, PXRowPersistingEventArgs e)
{
    // For a new record inserted into the database table
    if ( _AutoNumbering && 
         (e.Operation & PXDBOperation.Command) == PXDBOperation.Insert )
    {
        Type setupType = BqlCommand.GetItemType(_AutoNumberingField);

        string lastNumber = GetNewNumber(sender, setupType);
        if (lastNumber != null)
        {
            // Updating the document number in the PXCache
            // object for the document
            sender.SetValue(e.Row, _FieldOrdinal, lastNumber);
        }
    }
} On                         the  RowPersisting  event occurs, you retrieve the last                         number from the setup record, increment the number, insert the new value                         into the document, and update the last assigned number in the setup record.                         The  RowPersisting  event is the last event raised before                              Acumatica Framework commits changed data from cache objects to the database. To avoid                         duplicate numbers, you calculate the new value just before the data record                         is saved to the database. Define the  RowPersisted()  method as the following code                         shows. public virtual void RowPersisted(PXCache sender, PXRowPersistedEventArgs e)
{
    // If the database transaction doesn't succeed
    if ( _AutoNumbering && 
         (e.Operation & PXDBOperation.Command) == PXDBOperation.Insert &&
         e.TranStatus == PXTranStatus.Aborted )
    {
        // Roll back the document number to the default value.
        sender.SetValue(e.Row, _FieldOrdinal, NewValue);
        // If transaction isn't successful, remove the setup record;
        // it hasn't been saved because of transaction rollback.
        Type setupType = BqlCommand.GetItemType(_AutoNumberingField);
        sender.Graph.Caches[setupType].Clear();
    }
} The                              RowPersisted  event, in which                              e.TranStatus  may have the  Completed  or                              Aborted  value, is raised after all changes from cache                         objects of the graph are committed to the database. If any error occurs                         during the transaction, you remove the new document number, which hasn't                         been saved for a document, from the  PXCache  object for                         the  setupType  DAC. For details on the process of saving                         changes to the database, see  Saving of Changes to the Database. Define the static  SetLastNumberField<Field>()  method, as                     shown in the following                         code. public static void SetLastNumberField<Field>(PXCache sender, object row,
                                             Type lastNumberField)
    where Field : IBqlField
{
    foreach (PXEventSubscriberAttribute attribute in
                 sender.GetAttributes<Field>(row))
    {
        if (attribute is AutoNumberAttribute)
        {
            AutoNumberAttribute attr = (AutoNumberAttribute)attribute;
            attr.LastNumberField = lastNumberField;
            attr.CreateLastNumberCommand();
        }
    }
} The                              SetLastNumberField<Field>()  method provides the API                         that dynamically configures the attribute in graph handlers. By invoking                         this method in the  RowPersisting  event handler in the                         graph, you can dynamically change the last number field depending on some                         condition (in this example, the document type). In the                              SetLastNumberField<Field>()  method, you update the                              lastNumberField  type and command of the attribute. To                         get the attribute object, you iterate the collection of attributes on the                         specified field and search for the attribute by its type. Define the static  SetPrefix<Field>()  method of the                     attribute, as the following code                         shows. public static void SetPrefix<Field>(PXCache sender, object row, string prefix)
    where Field : IBqlField
{
    foreach (PXEventSubscriberAttribute attribute in
                 sender.GetAttributes<Field>(row))
    {
        if (attribute is AutoNumberAttribute)
        {
            ((AutoNumberAttribute)attribute).Prefix = prefix;
        }
    }
} The                              SetPrefix<Field>()  method sets the prefix that is                         added to the number generated by the  AutoNumber                          attribute. Now the  AutoNumber  attribute is ready, and you can use it for the                 numbering of documents and sales orders. To use the attribute, add it to the                 document number field in the DAC, as shown in the code below.  // Enables auto-numbering of sales orders 
// in the SalesOrder.OrderNbr field
[AutoNumber(typeof(Setup.autoNumbering), typeof(Setup.salesOrderLastNbr))]
public virtual string OrderNbr
{...} ]]></column>
		</row>
		<row PageID="f6971bf1-d865-4f98-9127-07d056da2d5e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="5e30ba0a-6f6a-91eb-9c65-8e6553d545cc" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#_fcd0688c-48bb-403e-b8f9-042f0527b9ef]
The use of accumulator attributes is a specific Acumatica Framework technique for fields that are updated frequently (and often concurrently by multiple users). An accumulator attribute changes the SQL query that is executed when the data is updated in the database. You can use an accumulator attribute in either of the following cases: [anchor|#_56942736-d3f1-409e-a947-f6f66463accb]
*To update a field or multiple fields of a data record without checking for the data record version in the database. (In an ordinary update, the framework generates the SQL statement that checks the timestamp column, if this column exists in the table.)
*To define a specific update policy for a column—for instance, to calculate the sum of values in a column on every update. You can also specify restrictions for a column that will be checked by the database during update.
{br}{TOC}[anchor|#section_vyj_3yg_lm]
==Implementing an Accumulator Attribute==
An accumulator attribute is the <tt>PXAccumulator</tt> attribute or an attribute derived from it. When you define a custom accumulator attribute, you typically implement the following members:[anchor|#ul_z4p_lsg_lm]
*The attribute constructor
*The <tt>PrepareInsert()</tt> method
*The <tt>PersistInserted()</tt> method

The base <tt>PXAccumulator</tt> attribute has two parameters in the constructor. This attribute applies the <tt>Summarize</tt> policy to the specified decimal or double fields (on each update, the new value is added to the database value) and the <tt>Initialize</tt> policy to other fields. To override this policy or to set restrictions, you derive a custom attribute from <tt>PXAccumulator</tt>, in which you override the <tt>PrepareInsert()</tt> method.{br}

In the overridden <tt>PrepareInsert()</tt> method, you first have to invoke the base <tt>PrepareInsert()</tt> method to initialize the collection of columns. If the base <tt>PrepareInsert()</tt> method returns <tt>true</tt>, the collection of columns is initialized. Then in the overridden method, you can set restrictions and update policies for specific columns.{br}

If you set any restrictions, you have to override the <tt>PersistInserted()</tt> method. For details, see [[#_fbcaf094-28e6-43ac-8881-526b02674932|Implementing an Update With Restrictions] below.{br}

In the <tt>PrepareInsert()</tt> method, the columns are represented by an object of the <tt>PXAccumulatorCollection</tt> class. To update a value or to set a restriction for a column, you invoke the needed generic method of the {{columns}} collection. Below are the methods that you can use in single record mode ({{SingleRecord = true}}):[anchor|#ol_pmh_q3g_lm]
#{{columns.Update()}}: Sets the update policy for the field.
#{{columns.Restrict()}}: Sets the value restriction for the column. The restriction triggers the <tt>PXLockViolationException</tt> exception, which you should handle in the overridden <tt>PersistInserted()</tt> method of the attribute.

The methods listed above and all the methods listed below can be used in default mode (when {{SingleRecord = false}}):[anchor|#ol_a3s_kjg_lm]
#{{columns.RestrictPast()}}
#{{columns.RestrictFuture()}}
#{{columns.InitializeFrom()}}
#{{columns.UpdateFuture()}}
((({S:Warn}For reference information on methods and properties that you can use in the <tt>PXAccumulator</tt> attribute, see [https://help.acumatica.com/(W(69))/Help?ScreenId=ShowWiki&pageid=4addf6d6-3ae5-0141-2edf-e44ff68a4a2b|PXAccumulatorAttribute Class] in the API Reference.
)))
==Using Single-Record Mode==
If no new values that you assign with the attribute depend on the existing ones or add restrictions to future values, you can enable single-record mode for the attribute. In this case, you can use only the <tt>Update()</tt> and <tt>Restrict()</tt> methods of the {{columns}} collection. In single-record mode, the framework generates the specific SQL statement that updates an independent record in the database. To enable single-record mode, set the <tt>&#95;SingleRecord</tt> field of the attribute (or the <tt>SingleRecord</tt> property in the attribute constructor) to <tt>true</tt>. By default, single-record mode is disabled.
==Understanding Update Policies==
You can use one of the following update policies for columns (values defined in the <tt>PXDataFieldAssign.AssignBehavior</tt> enumeration):[anchor|#ol_gd1_5kh_lm]
#<tt>Replace</tt>: Assigns the specified value to the data field on every update. For this policy, set the new value to the field in your code.
#<tt>Summarize</tt>: Adds the specified delta (with the appropriate sign) to the data field on every update. For this policy, set the delta to the field in your code.
#<tt>Maximize</tt>: Assigns the maximum value in the column to the data field on every update. For this policy, it isn&rsquo;t necessary to set the new value to the field in your code.
#<tt>Minimize</tt>: Assigns the minimum value in the column to the data field on every update. For this policy, it isn&rsquo;t necessary to set the new value to the field in your code.
#<tt>Initialize</tt>: Assigns the specified value to the data field if the old value is null. For this policy, set the new value to the field in your code.

In the code below, the {{SupplierDataAccumulator}} attribute initializes the {{SupplierPrice}}, {{SupplierUnit}}, and {{ConversionFactor}} fields and replaces the values of the {{LastSupplierPrice}} and {{LastPurchaseDate}} fields of the {{SupplierData}} class on every update of a data record of this class.<source lang="csharp">public class SupplierDataAccumulatorAttribute : PXAccumulatorAttribute
{
    public SupplierDataAccumulatorAttribute()
    {
        _SingleRecord = true;
    }

    protected override bool PrepareInsert(
        PXCache sender, object row, PXAccumulatorCollection columns)
    {
        if (!base.PrepareInsert(sender, row, columns))
            return false;

        SupplierData bal = (SupplierData)row;
        // The attribute updates only these fields by the specified policy
        columns.Update&lt;SupplierData.supplierPrice&gt;(
            bal.SupplierPrice, PXDataFieldAssign.AssignBehavior.Initialize);
        columns.Update&lt;SupplierData.supplierUnit&gt;(
            bal.SupplierUnit, PXDataFieldAssign.AssignBehavior.Initialize);
        columns.Update&lt;SupplierData.conversionFactor&gt;(
            bal.ConversionFactor, PXDataFieldAssign.AssignBehavior.Initialize);
        columns.Update&lt;SupplierData.lastSupplierPrice&gt;(
            bal.LastSupplierPrice, PXDataFieldAssign.AssignBehavior.Replace);
        columns.Update&lt;SupplierData.lastPurchaseDate&gt;(
            bal.LastPurchaseDate, PXDataFieldAssign.AssignBehavior.Replace);
        return true;
    }
}</source>[anchor|#_fbcaf094-28e6-43ac-8881-526b02674932]
==Implementing an Update With Restrictions==
When you use an accumulator attribute, you might need to check some restrictions when the data is being updated in the database. You can specify the restriction conditions in the accumulator attribute. The attribute adds the conditions to the WHERE clause of the SQL query. When the framework executes the query, the record is not updated in the database if the condition is false. In this case, the database returns no affected rows, and the framework throws the <tt>PXLockViolationException</tt> exception.{br}

If you update a column with a restriction, you have to override the <tt>PersistInserted()</tt> method in the attribute and handle <tt>PXLockViolationException</tt> in it. In the overridden <tt>PersistInserted()</tt> method, you first have to invoke the base method and then have to catch the <tt>PXLockViolationException</tt> exception that can be thrown in the base method. If the exception is thrown, you have to check the new values for restriction conditions to compose the appropriate error message for the UI. The framework raises the <tt>PXLockViolationException</tt> exception in a general case if the database returns no rows affected by the UPDATE command. When you catch the <tt>PXLockViolationException</tt> exception, you have to check whether the restriction conditions take place. If you have found that a restriction condition is false, throw the <tt>PXRowPersistingException</tt> exception to return the appropriate error message to the UI. Otherwise, rethrow the <tt>PXLockViolationException</tt> exception, because it was caused by another reason. On the <tt>PXRowPersistingException</tt> exception, the transaction is rolled back and no record is updated in the database. If no exceptions occur in <tt>PersistInserted()</tt>, the new value is saved to the database. ((({S:Warn}For an ordinary data update without accumulators, you can check value restrictions at different times before the data is updated in the database. In particular, on the <tt>FieldVerifying</tt> and <tt>RowUpdating</tt> events, you can check the values for restrictions at the model level, before the changes are saved to the <tt>PXCache</tt> object. On these events, you typically implement validation of the values entered by the user. If you need to check a value immediately before it is saved to the database, you can do this on the <tt>RowPersisting</tt> event.
)))[anchor|#section_ws4_hyg_lm]
==Using an Accumulator Attribute==
An accumulator attribute triggers only for data records that have the <tt>Inserted</tt> status in the cache object. Thus, you have to insert a data record into the cache to trigger an update via the accumulator attribute. Once inserted, the data record gets the <tt>Inserted</tt> status and maintains this status until it is saved to the database, even if you update the record in the cache. When a user saves changes to the database, despite of that the record has the <tt>Inserted</tt> status in the cache object, the framework generates the correct SQL statement that updates the record or inserts it into the database. By default, if there is no record with such a key in the database, a new one is inserted. If a record with these key values already exists, it is correctly updated in the database because of the accumulator attribute.((({S:Warn}When you invoke <tt>Update()</tt> on an <tt>Inserted</tt> record (inserted into the cache), the record remains <tt>Inserted</tt>. When you invoke <tt>Update()</tt> on an unchanged record that is retrieved from the database, the record becomes <tt>Updated</tt>, and the accumulator won&rsquo;t trigger on this record. For more information on the statuses of data records, see [HelpRoot_Dev_Platform\AD__con_ModifyData|Modification of Data in a PXCache Object].
)))((({S:Warn}You can insert a data record with unique key values into the cache only once. The framework won&rsquo;t insert the duplicate record. After you have inserted the record, use <tt>Update()</tt> to modify its values in the cache within the current unsaved session.
)))
In an accumulator attribute, you can specify which database operations are allowed. By default, the accumulator attribute inserts a new record if it doesn&rsquo;t exist in the database and updates an existing record, if any. To allow only insert or update operations, set the <tt>InsertOnly</tt> or <tt>UpdateOnly</tt> property of the {{columns}} collection in the <tt>PrepareInsert()</tt> method before invocation of <tt>columns.Update()</tt>.[anchor|#section_m4g_5wj_vm]
==Understanding How an Accumulator Attribute Works==
During the database transaction that applies changes from cache objects to the database, the graph invokes the <tt>PersistInserted()</tt> method of each <tt>PXCache</tt> object. The <tt>PersistInserted()</tt> method that is executed for the <tt>Inserted</tt> records of the cache object checks whether an accumulator attribute is specified on the DAC. If the accumulator exists, the <tt>PersistInserted()</tt> method of the accumulator is invoked. If there is no accumulator on the DAC, the method executes an ordinary INSERT (see the diagram below).{br}

The <tt>PersistInserted()</tt> method of the accumulator invokes the <tt>PrepareInsert()</tt> method, which initializes the collection of columns, sets the restrictions, and composes the SQL query. If the <tt>PrepareInsert()</tt> method returns ''true'', the framework executes the composed query, which can be INSERT or UPDATE depending on the attribute parameters and the record. Otherwise, the framework returns ''false'' and the record isn&rsquo;t updated in the database.[anchor|#image_hbs_2gk_vm][image:StudioDeveloperGuide/Images/SavingChangestoDBWithAcc.png|popup|Saving changes to the database with an accumulator attribute|450px]]]></column>
			<column name="PlainText"><![CDATA[Update of Data with PXAccumulator Attributes The use of accumulator attributes is a specific  Acumatica Framework             technique for fields that are updated frequently (and often concurrently by multiple             users). An accumulator attribute changes the SQL query that is executed when the data is             updated in the database. You can use an accumulator attribute in either of the following             cases:  To update a field or multiple fields of a data record without checking for the                     data record version in the database. (In an ordinary update, the framework                     generates the SQL statement that checks the timestamp column, if this column                     exists in the table.) To define a specific update policy for a column—for instance, to calculate                     the sum of values in a column on every update. You can also specify restrictions                     for a column that will be checked by the database during update. Implementing an Accumulator Attribute An accumulator attribute is the  PXAccumulator  attribute or an attribute         derived from it. When you define a custom accumulator attribute, you typically implement the         following members: The attribute constructor The  PrepareInsert()  method The  PersistInserted()  method The base  PXAccumulator  attribute has two parameters in the constructor.         This attribute applies the  Summarize  policy to the specified decimal or         double fields (on each update, the new value is added to the database value) and the            Initialize  policy to other fields. To override this policy or to set         restrictions, you derive a custom attribute from  PXAccumulator , in which         you override the  PrepareInsert()  method. In the overridden  PrepareInsert()  method, you first have to invoke the         base  PrepareInsert()  method to initialize the collection of columns. If         the base  PrepareInsert()  method returns  true , the         collection of columns is initialized. Then in the overridden method, you can set         restrictions and update policies for specific columns. If you set any restrictions, you have to override the  PersistInserted()          method. For details, see  Implementing an Update With Restrictions Implementing an Update With Restrictions below. In the  PrepareInsert()  method, the columns are represented by an object         of the  PXAccumulatorCollection  class. To update a value or to set a         restriction for a column, you invoke the needed generic method of the            columns  collection. Below are the methods that you can use in single         record mode ( SingleRecord = true ): columns.Update() : Sets the update policy for the field. columns.Restrict() : Sets the value restriction for the column. The           restriction triggers the  PXLockViolationException  exception, which you           should handle in the overridden  PersistInserted()  method of the           attribute. The methods listed above and all the methods listed below can be used in default mode (when            SingleRecord = false ): columns.RestrictPast() columns.RestrictFuture() columns.InitializeFrom() columns.UpdateFuture() For reference information on methods and properties that you can use in the            PXAccumulator  attribute, see  PXAccumulatorAttribute Class PXAccumulatorAttribute Class in the API         Reference. Using Single-Record Mode If no new values that you assign with the attribute depend on the existing ones or add         restrictions to future values, you can enable single-record mode for the attribute. In this         case, you can use only the  Update()  and  Restrict()          methods of the  columns  collection. In single-record mode, the framework         generates the specific SQL statement that updates an independent record in the database. To         enable single-record mode, set the  _SingleRecord  field of the attribute         (or the  SingleRecord  property in the attribute constructor) to            true . By default, single-record mode is disabled. Understanding Update Policies You can use one of the following update policies for columns (values defined in the            PXDataFieldAssign.AssignBehavior  enumeration): Replace : Assigns the specified value to the data field on every           update. For this policy, set the new value to the field in your code. Summarize : Adds the specified delta (with the appropriate sign) to           the data field on every update. For this policy, set the delta to the field in your           code. Maximize : Assigns the maximum value in the column to the data field           on every update. For this policy, it isn't necessary to set the new value to the field in           your code. Minimize : Assigns the minimum value in the column to the data field           on every update. For this policy, it isn't necessary to set the new value to the field in           your code. Initialize : Assigns the specified value to the data field if the old           value is null. For this policy, set the new value to the field in your code. In the code below, the  SupplierDataAccumulator  attribute initializes the            SupplierPrice ,  SupplierUnit , and            ConversionFactor  fields and replaces the values of the            LastSupplierPrice  and  LastPurchaseDate  fields of the            SupplierData  class on every update of a data record of this class. public class SupplierDataAccumulatorAttribute : PXAccumulatorAttribute
{
    public SupplierDataAccumulatorAttribute()
    {
        _SingleRecord = true;
    }

    protected override bool PrepareInsert(
        PXCache sender, object row, PXAccumulatorCollection columns)
    {
        if (!base.PrepareInsert(sender, row, columns))
            return false;

        SupplierData bal = (SupplierData)row;
        // The attribute updates only these fields by the specified policy
        columns.Update<SupplierData.supplierPrice>(
            bal.SupplierPrice, PXDataFieldAssign.AssignBehavior.Initialize);
        columns.Update<SupplierData.supplierUnit>(
            bal.SupplierUnit, PXDataFieldAssign.AssignBehavior.Initialize);
        columns.Update<SupplierData.conversionFactor>(
            bal.ConversionFactor, PXDataFieldAssign.AssignBehavior.Initialize);
        columns.Update<SupplierData.lastSupplierPrice>(
            bal.LastSupplierPrice, PXDataFieldAssign.AssignBehavior.Replace);
        columns.Update<SupplierData.lastPurchaseDate>(
            bal.LastPurchaseDate, PXDataFieldAssign.AssignBehavior.Replace);
        return true;
    }
} Implementing an Update With Restrictions When you use an accumulator attribute, you might need to check some restrictions when the         data is being updated in the database. You can specify the restriction conditions in the         accumulator attribute. The attribute adds the conditions to the WHERE clause of the SQL         query. When the framework executes the query, the record is not updated in the database if         the condition is false. In this case, the database returns no affected rows, and the         framework throws the  PXLockViolationException  exception. If you update a column with a restriction, you have to override the            PersistInserted()  method in the attribute and handle            PXLockViolationException  in it. In the overridden            PersistInserted()  method, you first have to invoke the base method and         then have to catch the  PXLockViolationException  exception that can be         thrown in the base method. If the exception is thrown, you have to check the new values for         restriction conditions to compose the appropriate error message for the UI. The framework         raises the  PXLockViolationException  exception in a general case if the         database returns no rows affected by the UPDATE command. When you catch the            PXLockViolationException  exception, you have to check whether the         restriction conditions take place. If you have found that a restriction condition is false,         throw the  PXRowPersistingException  exception to return the appropriate         error message to the UI. Otherwise, rethrow the  PXLockViolationException          exception, because it was caused by another reason. On the            PXRowPersistingException  exception, the transaction is rolled back and         no record is updated in the database. If no exceptions occur in            PersistInserted() , the new value is saved to the database.  For an ordinary data update without accumulators, you can check value restrictions at         different times before the data is updated in the database. In particular, on the            FieldVerifying  and  RowUpdating  events, you can check         the values for restrictions at the model level, before the changes are saved to the            PXCache  object. On these events, you typically implement validation of         the values entered by the user. If you need to check a value immediately before it is saved         to the database, you can do this on the  RowPersisting  event. Using an Accumulator Attribute An accumulator attribute triggers only for data records that have the            Inserted  status in the cache object. Thus, you have to insert a data         record into the cache to trigger an update via the accumulator attribute. Once inserted, the         data record gets the  Inserted  status and maintains this status until it         is saved to the database, even if you update the record in the cache. When a user saves         changes to the database, despite of that the record has the  Inserted          status in the cache object, the framework generates the correct SQL statement that updates         the record or inserts it into the database. By default, if there is no record with such a         key in the database, a new one is inserted. If a record with these key values already         exists, it is correctly updated in the database because of the accumulator attribute. When you invoke  Update()  on an  Inserted  record         (inserted into the cache), the record remains  Inserted . When you invoke            Update()  on an unchanged record that is retrieved from the database,         the record becomes  Updated , and the accumulator won't trigger on this         record. For more information on the statuses of data records, see  Modification of Data in a PXCache Object. You can insert a data record with unique key values into the cache only once. The         framework won't insert the duplicate record. After you have inserted the record, use            Update()  to modify its values in the cache within the current unsaved         session. In an accumulator attribute, you can specify which database operations are allowed. By         default, the accumulator attribute inserts a new record if it doesn't exist in the database         and updates an existing record, if any. To allow only insert or update operations, set the            InsertOnly  or  UpdateOnly  property of the            columns  collection in the  PrepareInsert()  method         before invocation of  columns.Update() . Understanding How an Accumulator Attribute Works During the database transaction that applies changes from cache objects to the database,         the graph invokes the  PersistInserted()  method of each            PXCache  object. The  PersistInserted()  method that is         executed for the  Inserted  records of the cache object checks whether an         accumulator attribute is specified on the DAC. If the accumulator exists, the            PersistInserted()  method of the accumulator is invoked. If there is no         accumulator on the DAC, the method executes an ordinary INSERT (see the diagram below). The  PersistInserted()  method of the accumulator invokes the            PrepareInsert()  method, which initializes the collection of columns,         sets the restrictions, and composes the SQL query. If the  PrepareInsert()          method returns  true , the framework executes the composed query, which can be INSERT         or UPDATE depending on the attribute parameters and the record. Otherwise, the framework         returns  false  and the record isn't updated in the database. Saving changes to the database with an accumulator attribute ]]></column>
		</row>
		<row PageID="63a1efdb-104e-4c07-b2c9-a9cb08746205" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="c8acc665-3cf8-29a9-11db-48bf3dedf07c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use the following ways of adding a restriction to a field value in the accumulator attribute:[anchor|#ul_qw5_sdr_14]
*Using the <tt>Restrict()</tt> method of the column collection in <tt>PrepareInsert()</tt>. The condition you specify in the <tt>Restrict()</tt> method is checked against the value stored in the database. You need to override the <tt>PersistInserted()</tt> method to throw a more specific exception if a restriction violation occurs.
*Using the <tt>AppendException()</tt> method of the column collection in <tt>PrepareInsert()</tt>. This method actually configures an exception that is thrown when the specified restriction is violated. The condition you specify is checked against the result after the new value is added to the value stored in the database.

The following code example adds a restriction to the {{ProductQty.AvailQty}} field by using the <tt>Restrict()</tt> method.<source lang="csharp">ProductQty newQty = (ProductQty)row;
if (newQty.AvailQty &lt; 0m)
{
    columns.Restrict&lt;ProductQty.availQty&gt;(PXComp.GE, -newQty.AvailQty);
}</source>
The restriction set with the <tt>Restrict()</tt> method doesn&rsquo;t work on insertion of the {{ProductQty}} data record. In the code above, you compare the existing value with {{-newQty.AvailQty}}.{br}

The following code example adds the same restriction to the {{ProductQty.AvailQty}} field by using the <tt>AppendException()</tt> method.<source lang="csharp">ProductQty newQty = (ProductQty)row;
if (newQty.AvailQty &lt; 0m)
{
    columns.AppendException(
        "Updating product quantity in stock will lead to a " + 
        "negative value.",
        new PXAccumulatorRestriction&lt;ProductQty.availQty&gt;(PXComp.GE, 0m));
}</source>
The restriction set with the <tt>AppendException()</tt> method works on both insertion and update of the {{ProductQty}} data record. In the code above, you compare the resulting value, {{-newQty.AvailQty}} plus the existing value, with {{0m}}.]]></column>
			<column name="PlainText"><![CDATA[Restrictions in the Accumulator Attribute You can use the following ways of adding a restriction to a field value in the accumulator         attribute: Using the  Restrict()  method of the column collection in              PrepareInsert() . The condition you specify in the              Restrict()  method is checked against the value stored in the           database. You need to override the  PersistInserted()  method to throw a           more specific exception if a restriction violation occurs. Using the  AppendException()  method of the column collection in              PrepareInsert() . This method actually configures an exception that is           thrown when the specified restriction is violated. The condition you specify is checked           against the result after the new value is added to the value stored in the database. The following code example adds a restriction to the  ProductQty.AvailQty          field by using the  Restrict()  method. ProductQty newQty = (ProductQty)row;
if (newQty.AvailQty < 0m)
{
    columns.Restrict<ProductQty.availQty>(PXComp.GE, -newQty.AvailQty);
} The restriction set with the  Restrict()  method doesn't work on insertion         of the  ProductQty  data record. In the code above, you compare the existing         value with  -newQty.AvailQty . The following code example adds the same restriction to the            ProductQty.AvailQty  field by using the            AppendException()  method. ProductQty newQty = (ProductQty)row;
if (newQty.AvailQty < 0m)
{
    columns.AppendException(
        "Updating product quantity in stock will lead to a " + 
        "negative value.",
        new PXAccumulatorRestriction<ProductQty.availQty>(PXComp.GE, 0m));
} The restriction set with the  AppendException()  method works on both         insertion and update of the  ProductQty  data record. In the code above, you         compare the resulting value,  -newQty.AvailQty  plus the existing value, with            0m . ]]></column>
		</row>
		<row PageID="af86ebcf-0ea1-4c22-b624-99fc14c0b02c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="9986c0ac-6626-5ac1-92a3-3551b83e1c74" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In a graph extension, you can override protected graph members by using the <tt>PXOverride</tt> attribute. To call a protected member of a graph in its extension, you can use the <tt>PXProtectedAccess</tt> attribute.{br}

To be able to access a protected member in a graph extension, you should do the following:[anchor|#_088df631-178c-4e7b-bd79-460b09b10bc1]
#In a graph extension, declare an abstract member with the same signature as the protected member you want to access.
#:((({S:Warn}The graph extension should also be abstract.
)))
#Add the <tt>&#91;PXProtectedAccess&#93;</tt> attribute to the member definition.

The framework replaces the body of the member annotated with <tt>PXProtectedAccess</tt> with the body of the corresponding member in the graph or lower-level graph extension.{br}

The following sections show examples of <tt>PXProtectedAccess</tt> usage.{br}{TOC}
==Calling Protected Members of a Graph==
Suppose that the code of Acumatica ERP includes the following graph.<source lang="csharp">public class MyGraph : PXGraph&lt;MyGraph&gt;
{
    protected void Foo(int param1, string param2) { ... }
    protected static void Foo2() { }
    protected int Bar(MyDac dac) =&gt; dac.IntValue;
    protected decimal Prop { get; set; }
    protected double Field;
}</source>{br}

You can use the members in an extension of the graph, as shown in the following example.<source lang="csharp">public abstract class MyExt : PXGraphExtension&lt;MyGraph&gt;
{
      [PXProtectedAccess]
      protected abstract void Foo(int param1, string param2)
      [PXProtectedAccess]
      protected abstract void Foo2();
      [PXProtectedAccess]
      protected abstract int Bar(MyDac dac);
      [PXProtectedAccess]
      protected abstract decimal Prop { get; set; }
      [PXProtectedAccess]
      protected abstract double Field { get; set; }

      private void Test()
      {
             Foo(42, "23");
             int bar = Bar(new MyDac());
             decimal prop = Prop;
             Prop = prop + 12;
             double field = Field;
             Field = field + 15;
      }
}</source>
==Calling Protected Members of a Graph Extension==
Suppose that the code of Acumatica ERP includes the following graph.<source lang="csharp">public class MyGraph : PXGraph&lt;MyGraph&gt;
{
    protected void Bar() { }
}</source>
Suppose also that custom code includes the following extension of this graph.<source lang="csharp">public class MyExt : PXGraphExtension&lt;MyGraph&gt;
{
    protected void Foo() { }
}</source>
You can use the protected member of the graph extension by specifying the parameter of the attribute, as shown in the following example.<source lang="csharp">public abstract class MySecondLevelExt : PXGraphExtension&lt;MyExt, MyGraph&gt;
{
    [PXProtectedAccess]
    protected abstract void Bar();

    [PXProtectedAccess(typeof(MyExt))]
    protected abstract void Foo();
}</source>]]></column>
			<column name="PlainText"><![CDATA[Access to Protected Graph Members In a graph extension, you can override protected graph members by using the                      PXOverride  attribute. To call a protected member of a graph                 in its extension, you can use the  PXProtectedAccess                  attribute. To be able to access a protected member in a graph extension, you should do the following: In a graph extension, declare an abstract member with the same signature as the protected                     member you want to access. The graph extension should also be                         abstract. Add the  [PXProtectedAccess]  attribute to the member definition. The framework replaces the body of the member annotated with       PXProtectedAccess  with the body of the corresponding member in the graph or     lower-level graph extension. The following sections show examples of  PXProtectedAccess  usage. Calling Protected Members of a Graph Suppose that the code of  Acumatica ERP     includes the following     graph. public class MyGraph : PXGraph<MyGraph>
{
    protected void Foo(int param1, string param2) { ... }
    protected static void Foo2() { }
    protected int Bar(MyDac dac) => dac.IntValue;
    protected decimal Prop { get; set; }
    protected double Field;
} You can use the members in an extension of the graph, as shown in the following example. public abstract class MyExt : PXGraphExtension<MyGraph>
{
      [PXProtectedAccess]
      protected abstract void Foo(int param1, string param2)
      [PXProtectedAccess]
      protected abstract void Foo2();
      [PXProtectedAccess]
      protected abstract int Bar(MyDac dac);
      [PXProtectedAccess]
      protected abstract decimal Prop { get; set; }
      [PXProtectedAccess]
      protected abstract double Field { get; set; }

      private void Test()
      {
             Foo(42, "23");
             int bar = Bar(new MyDac());
             decimal prop = Prop;
             Prop = prop + 12;
             double field = Field;
             Field = field + 15;
      }
} Calling Protected Members of a Graph Extension Suppose that the code of  Acumatica ERP     includes the following graph. public class MyGraph : PXGraph<MyGraph>
{
    protected void Bar() { }
} Suppose also that custom code includes the following extension of this graph. public class MyExt : PXGraphExtension<MyGraph>
{
    protected void Foo() { }
} You can use the protected member of the graph extension by specifying the parameter of the     attribute, as shown in the following example. public abstract class MySecondLevelExt : PXGraphExtension<MyExt, MyGraph>
{
    [PXProtectedAccess]
    protected abstract void Bar();

    [PXProtectedAccess(typeof(MyExt))]
    protected abstract void Foo();
} ]]></column>
		</row>
		<row PageID="2d459c9b-fd53-4edd-8867-b09409b6aac2" Language="en-US" PageRevisionID="1" Content="&#xA;In Acumatica Framework-based and customized Acumatica ERP applications, you can attach files to the records displayed on the forms. This chapter describes how to attach files to the records and display the attached image files on the forms.&#xA;==In This Chapter==[anchor|#_b683173d-f1f8-49ca-914a-115a156201ec]&#xA;*[HelpRoot_Dev_Platform\BL__how_Work_with_Attachments|To Allow Attachments to a Particular Form]&#xA;*[HelpRoot_Dev_Platform\BL__how_Display_Attached_Image|To Display an Attached Image on the Form]&#xA;" PlainText="Working with Attachments In  Acumatica Framework-based and customized  Acumatica ERP     applications, you can attach files to the records displayed on the forms. This chapter     describes how to attach files to the records and display the attached image files on the     forms. In This Chapter To Allow Attachments to a Particular FormTo Display an Attached Image on the Form" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="1f35c5f0-9283-5f53-b4ea-ac790d1e868d" RecordSourceID="22377" />
		<row PageID="70a16c7d-8daa-43dd-a979-739117383229" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2c3fc54a-da4c-838c-64c6-1addc8f51ebe" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Users of Acumatica Framework-based and Acumatica ERP applications can attach files, notes, and activities to master records displayed on forms. They can also attach files and notes to the detail records, which are displayed in table rows on forms. In this topic, you can find information about how to allow attachments to a particular form and the table rows on a specific form.
For more information about how a user can attach files and notes to forms, see [HelpRoot_Interface\Attaching_Files_to_Forms_and_Records|To Attach a File to a Record] and [HelpRoot_Interface\Attaching_Notes_to_Records|To Attach a Note to a Record]. For information about activities, see [HelpRoot_CRM\CRM_Mktg_Managing_Emails_Activities_Mapref|Managing Emails and Activities]. 
((({S:Hint}The extensions of the files that can be uploaded to a form must be registered on the [HelpRoot_FormReference\SM_20_25_50|File Upload Preferences] ([~/?ScreenId=SM202550|SM202550])  form. If the required file types are not registered on this form, you have to add them and save your changes. On this form, you can also define the maximum size of an uploaded file (in kilobytes).
)))
==To Allow Attachments to a Particular Form==[anchor|#_fe1f8714-5da0-40ea-a338-c3fd364fd1e9]
#In the data access class (DAC) that provides data for the form, add the <tt>NoteID</tt> field, as the following code shows.<source lang="csharp">#region NoteID
public abstract class noteID : PX.Data.IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; }
#endregion</source>
#:((({S:Warn}The database table that corresponds to the DAC must contain the {{NoteID}} column with the {{uniqueidentifier}} data type.
)))
#Rebuild the project.
#:Once you have added the <tt>NoteID</tt> field to the DAC and rebuilt the project, the following buttons appear on the title bar of the form:
#*'''Notes''', which users click to attach notes to the form
#*'''Files''', which users click to attach files to the form
#Optional: To change whether each of these elements is displayed on the title bar, in the ASPX code of the form, specify the values of the following properties of the <tt>PXFormView</tt> control:
#*<tt>NoteIndicator</tt>: Indicates (if set to {{True}}) that the '''Notes''' button is displayed on the title bar.
#*<tt>FilesIndicator</tt>: Indicates (if set to {{True}}) that the '''Files''' button is displayed on the title bar.
#*<tt>ActivityIndicator</tt>: Indicates (if set to {{True}}) that the '''Activities''' button is displayed on the title bar. This button, which users click to attach activities to the form, is not displayed by default.
#:((({S:Warn}The <tt>LinkIndicator</tt> property, which controlled whether the '''Help''' > '''Get Link''' element was displayed on the title bar, is now obsolete. '''Help''' > '''Get Link''' is always displayed on the title bar.
)))

==To Allow Attachments to Table Rows on a Form==[anchor|#_47605912-a26f-4d9e-8363-b133a7487819]
#In the data access class (DAC) that provides data for the table rows, add the <tt>NoteID</tt> field, as the following code shows.<source lang="csharp">#region NoteID
public abstract class noteID : PX.Data.IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; }
#endregion</source>
#:((({S:Warn}The database table that corresponds to the DAC must contain the {{NoteID}} column with the {{uniqueidentifier}} data type.
)))
#Rebuild the project.
#:Once you have added the <tt>NoteID</tt> field to the DAC and rebuilt the project, the following columns appear in the table:
#*[image:StudioDeveloperGuide/Images/Note_icon.png]: The Notes column, which users click to attach notes to the form
#*[image:StudioDeveloperGuide/Images/File_Icon.png]: The Files column, which users click to attach files to the form
#Optional: To change whether each of these columns is displayed in the table, in the ASPX code of the form, specify the values of the following properties of the <tt>PXGrid</tt> control that corresponds to the table:
#*<tt>NoteIndicator</tt>: Indicates (if set to {{True}}) that the Notes column is displayed in the table
#*<tt>FilesIndicator</tt>: Indicates (if set to {{True}}) that the Files column is displayed in the table
]]></column>
			<column name="PlainText"><![CDATA[To Allow Attachments to a Particular Form Users of  Acumatica Framework-based and  Acumatica ERP applications can attach files, notes, and activities to master records displayed on         forms. They can also attach files and notes to the detail records, which are displayed in         table rows on forms. In this topic, you can find information about how to allow attachments         to a particular form and the table rows on a specific form. For more information about how a user can attach files and notes to         forms, see  To Attach a File to a Record and            To Attach a Note to a Record. For information about         activities, see  Managing Emails and Activities.          The extensions of the files that can be uploaded to a form must be           registered on the   ([~/?ScreenId=SM202550|SM202550]) File Upload Preferences(SM202550)   form. If the required file types are not registered on this form, you           have to add them and save your changes. On this form, you can also define the maximum size           of an uploaded file (in kilobytes). To Allow Attachments to a Particular Form In the data access class (DAC) that provides data for the form, add the              NoteID  field, as the following code             shows. #region NoteID
public abstract class noteID : PX.Data.IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; }
#endregion The             database table that corresponds to the DAC must contain the  NoteID              column with the  uniqueidentifier  data type. Rebuild the project. Once you have added the  NoteID  field to the DAC             and rebuilt the project, the following buttons appear on the title bar of the             form: Notes , which users click to attach notes to the form Files , which users click to attach files to the form Optional: To change whether each of these elements is displayed on the title bar, in the           ASPX code of the form, specify the values of the following properties of the              PXFormView  control: NoteIndicator : Indicates (if set to  True ) that               the  Notes  button is displayed on the title bar. FilesIndicator : Indicates (if set to  True ) that               the  Files  button is displayed on the title bar. ActivityIndicator : Indicates (if set to  True )               that the  Activities  button is displayed on the title bar. This               button, which users click to attach activities to the form, is not displayed by               default. The  LinkIndicator  property, which controlled whether the  Help Get Link  element was displayed on the title bar, is now obsolete.  Help Get Link  is always displayed on the title bar. To Allow Attachments to Table Rows on a Form In the data access class (DAC) that provides data for the table rows, add the              NoteID  field, as the following code             shows. #region NoteID
public abstract class noteID : PX.Data.IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; }
#endregion The             database table that corresponds to the DAC must contain the  NoteID              column with the  uniqueidentifier  data type. Rebuild the project. Once you have added the  NoteID  field to the             DAC and rebuilt the project, the following columns appear in the table: : The Notes column, which users click to               attach notes to the form : The Files column, which users click to               attach files to the form Optional: To change whether each of these columns is displayed in the table, in the ASPX           code of the form, specify the values of the following properties of the              PXGrid  control that corresponds to the table: NoteIndicator : Indicates (if set to  True ) that               the Notes column is displayed in the table FilesIndicator : Indicates (if set to  True ) that               the Files column is displayed in the table ]]></column>
		</row>
		<row PageID="cfec85eb-0597-4577-b0e6-4e127c38c134" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="3182fb4b-22fc-4d12-4477-655a710b7350" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you will learn how to display an attached image file on the form. In Acumatica ERP, you can find an example of an image file displayed in the UI on the '''Attributes''' tab of the [HelpRoot_FormReference\IN_20_25_00|Stock Items] ([~/?ScreenId=IN202500|IN202500]) form.
==To Display the Attached Image on the Form==
#Add the <tt>NoteID</tt> field and the field that stores the path to the image to the data access class (DAC) that provides data for the form on which you want to display the image, as shown in the following code.<source lang="csharp">#region NoteID
public abstract class noteID : PX.Data.IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; }
#endregion

#region ImageUrl
public abstract class imageUrl : PX.Data.IBqlField { }

[PXDBString(255)]
[PXUIField(DisplayName = "Image")]
public virtual string ImageUrl { get; set; }
#endregion</source>
#:((({S:Warn}The database table that provides data for the form on which you want to display the image must contain the following columns: [anchor|#_2b4ff834-6e28-4319-9555-c9286ee979a6]
*{{NoteID}} with the {{uniqueidentifier}} data type, to make it possible to attach images
*The field (in this example, {{ImageUrl}}) with the {{varchar(255)}} data type, to store the internal path to the attached image
)))
#In the ASPX code of the form that works with this DAC, add the <tt>PXImageUploader</tt> control linked to the <tt>ImageUrl</tt> data field, as shown in the following code. {{{{&lt;px:PXImageUploader Height="320px" Width="430px" 
            ID="imgUploader" runat="server" DataField="ImageUrl" 
            AllowUpload="true" ShowComment="true"
/&gt;
}}}}
#Rebuild the project.
]]></column>
			<column name="PlainText"><![CDATA[To Display an Attached Image on the Form In this topic, you will learn how to display an attached image file on the form. In  Acumatica ERP, you can find an example of an image file displayed in the UI on the            Attributes  tab of the   ([~/?ScreenId=IN202500|IN202500]) Stock Items (IN202500)         form. To Display the Attached Image on the Form Add the  NoteID  field and the field that stores the path to the image           to the data access class (DAC) that provides data for the form on which you want to           display the image, as shown in the following             code. #region NoteID
public abstract class noteID : PX.Data.IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; }
#endregion

#region ImageUrl
public abstract class imageUrl : PX.Data.IBqlField { }

[PXDBString(255)]
[PXUIField(DisplayName = "Image")]
public virtual string ImageUrl { get; set; }
#endregion The             database table that provides data for the form on which you want to display the image             must contain the following columns:  NoteID  with the  uniqueidentifier  data type, to                 make it possible to attach images The field (in this example,  ImageUrl ) with the                    varchar(255)  data type, to store the internal path to the                 attached image In the ASPX code of the form that works with this DAC, add the              PXImageUploader  control linked to the  ImageUrl            data field, as shown in the following code.            <px:PXImageUploader Height="320px" Width="430px" 
            ID="imgUploader" runat="server" DataField="ImageUrl" 
            AllowUpload="true" ShowComment="true"
/> Rebuild the project. ]]></column>
		</row>
		<row PageID="be859525-1515-4b35-8ac4-19250ea1b144" Language="en-US" PageRevisionID="1" PlainText="Configuring the UI from the Back End In this chapter, you can find information about configuration of the user interface of an  Acumatica Framework-based     application that involves not only the changing of the ASPX code of the form (as described in       Configuring ASPX Pages and Reports) but also the implementation of business logic in the corresponding     graph. In This Chapter Data for ControlsConfiguration of the User Interface in CodeStandard Buttons of the Form ToolbarConfiguration of ActionsRequests for User ConfirmationDetermination of Whether an Action Was Initiated in the UIRedirection to WebpagesConfiguration of Drop-Down ListsConfiguration of Selector ControlsCompany/Branch Selection MenuTo Configure an Input Mask and a Display Mask for a FieldTo Display a Dialog Box" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f0d0443a-74ce-722d-1653-412b0eb62ca9" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this chapter, you can find information about configuration of the user interface of an Acumatica Framework-based application that involves not only the changing of the ASPX code of the form (as described in [HelpRoot_Dev_Platform\CW__mng|Configuring ASPX Pages and Reports]) but also the implementation of business logic in the corresponding graph.
==In This Chapter==[anchor|#_4ec2d8d2-1810-473a-a562-37986c659056]
*[HelpRoot_Dev_Platform\BL__con_Data_for_Controls|Data for Controls]
*[HelpRoot_Dev_Platform\BL__con_UI_Presentation_Logic|Configuration of the User Interface in Code]
*[HelpRoot_Dev_Platform\BL__con_Standard_Buttons|Standard Buttons of the Form Toolbar]
*[HelpRoot_Dev_Platform\BL__con_Actions|Configuration of Actions]
*[HelpRoot_Dev_Platform\BL__con_Confirmation_Request|Requests for User Confirmation]
*[HelpRoot_Dev_Platform\BL__con_Identification_of_UI_Actions|Determination of Whether an Action Was Initiated in the UI]
*[HelpRoot_Dev_Platform\BL__con_Redirecting|Redirection to Webpages]
*[HelpRoot_Dev_Platform\BL__con_DropDown|Configuration of Drop-Down Lists]
*[HelpRoot_Dev_Platform\BL__con_SelectorDropDown|Configuration of Selector Controls]
*[HelpRoot_Dev_Platform\BL__con_Company_Branch_Control|Company/Branch Selection Menu]
*[HelpRoot_Dev_Platform\BL__how_Configur_Input_and_Display_Mask|To Configure an Input Mask and a Display Mask for a Field]
*[HelpRoot_Dev_Platform\BL__how_Display_Dialog_Box|To Display a Dialog Box]
]]></column>
		</row>
		<row PageID="16fbe106-2f81-4bd3-8a44-fcca6a0d114e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="21ddc7a6-46cc-0407-9df4-e90b639ceeac" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In a graph, you have to define a separate data view for each container control on the ASPX page, including nested container controls. Each data view should refer to a unique main data access class (DAC) unless you want to display the same data record in multiple container controls.{br}

The two data views defined in the following code example have the same main DAC and work with the same <tt>PXCache</tt> object, which stores the {{Product}} data records.<source lang="csharp">public SelectFrom&lt;Product&gt;.View Products;
public SelectFrom&lt;Product&gt;. 
    Where&lt;Product.productID.IsEqual&lt;Product.productID.FromCurrent&gt;&gt;.View
    ProductDetails;</source>
The two data views in this example can be used as data members for only UI containers that display the same data record at the same time. In this definition of data views, the first one is used to display brief information of a product on a form, and the second one is used to display the detail information of the same product on a tab. For both data views, the <tt>Current</tt> property of the <tt>PXCache</tt> cache object returns the same <tt>Product</tt> data record. If a user selects a data record in one UI container, the same data record appears in the second container.{br}

To bind a container control with a data view, you specify the data view in the <tt>DataMember</tt> property of the container control. Each container control should be bound to a data view. You can bind any number of container controls to the same data view, unless the data view is specified in the <tt>PrimaryView</tt> property of the datasource control.]]></column>
			<column name="PlainText"><![CDATA[Data for Controls In a graph, you have to define a separate data view for each container control on the ASPX         page, including nested container controls. Each data view should refer to a unique main data         access class (DAC) unless you want to display the same data record in multiple container         controls. The two data views defined in the following code example have the same main DAC and work         with the same  PXCache  object, which stores the  Product          data records. public SelectFrom<Product>.View Products;
public SelectFrom<Product>. 
    Where<Product.productID.IsEqual<Product.productID.FromCurrent>>.View
    ProductDetails; The two data views in this example can be used as data members for only UI containers that         display the same data record at the same time. In this definition of data views, the first         one is used to display brief information of a product on a form, and the second one is used         to display the detail information of the same product on a tab. For both data views, the            Current  property of the  PXCache  cache object returns         the same  Product  data record. If a user selects a data record in one UI         container, the same data record appears in the second container. To bind a container control with a data view, you specify the data view in the            DataMember  property of the container control. Each container control         should be bound to a data view. You can bind any number of container controls to the same         data view, unless the data view is specified in the  PrimaryView  property         of the datasource control. ]]></column>
		</row>
		<row PageID="56b2353a-7fe3-4156-aa56-dcd774dba3e2" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="bd010cd1-12fe-c305-b988-9f6c1adfdddf" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To set up the UI presentation, you should use a <tt>RowSelected</tt> event handler or the graph constructor. The <tt>RowSelected</tt> event happens several times during every round trip: at the end of each insertion, update, or deletion of a data record. The graph constructor is called once in the beginning of every round trip (before any data is selected by data views).{br}

To disable, hide, or change a caption of a data field on the form, you use the static methods of the <tt>PXUIFieldAttribute</tt> type, as shown in the following example.<source lang="csharp">PXUIFieldAttribute.SetEnabled&lt;Shipment.deliveryDate&gt;(
    sender, row, row.ShipmentType == ShipmentTypes.Single);</source>
You specify the field as the type parameter. It is mandatory to specify the <tt>PXCache</tt> object ({{sender}} in the example above). You can provide a specific data record ({{row}}) or specify <tt>null</tt> in the second parameter to apply the method to all data records in the cache. If you omit the type parameter, the method will be applied to all fields that are displayed in the UI, as shown in the following example.<source lang="csharp">// Making all fields for all data records
// read-only in the cache object
PXUIFieldAttribute.SetReadOnly(sender, null, true);</source>
You can specify default UI options for a field in the <tt>PXUIField</tt> attribute in the data access class (DAC) and change them if necessary in a <tt>RowSelected</tt> event handler through the static methods of the attribute.((({S:Warn}You shouldn&rsquo;t read anything from the database or write to the database in a <tt>RowSelected</tt> event handler.
)))((({S:Hint}Always implement two states of a UI control (such as enabled and disabled) when you set up the UI. Thus, when you make a data field disabled by some condition, you have to enable the data field in the corresponding opposite condition.
)))
For related data records (in a one-to-many relationship), you place the entire configuration of the UI presentation in the <tt>RowSelected</tt> event handler of the master data record. You can hide columns of the details grid only in the <tt>RowSelected</tt> handler for the master data record. In the <tt>RowSelected</tt> event handler of the detail record displayed in a grid, you can enable or disable data fields, but you cannot modify their visibility.
==Using the Graph Constructor==
The common UI presentation logic, which doesn&rsquo;t depend on particular values of the data record, can be implemented in the constructor of the graph. In the constructor, you cannot check the values of the currently selected data record, because no data records have been loaded yet. To implement the UI presentation specific to a data record, you should use the <tt>RowSelected</tt> event handler of the data record.
==Working with Cache-Level and Record-Level Attributes==
 Acumatica Framework initializes attributes during the startup of the domain or the first initialization of a graph that defines a <tt>CacheAttached</tt> event handler. During cache initialization, the appropriate attributes are copied to the cache level. The system can also create attributes of a data record level by copying cache-level attributes.{br}

To specify the properties of a cache-level attribute, you pass <tt>null</tt> as the second argument to the static methods of the attribute, as the following code example shows. The change to a property will affect all data records of the corresponding cache.<source lang="csharp">PXUIFieldAttribute.SetVisible&lt;ShipmentLine.shipmentDate&gt;(
    ShipmentLines.Cache, <b>null<b>, false);</source>
To specify the properties of a record-level attribute, you pass a data record as the second argument to the static methods of the attribute (see the following code example). The change will affect only the data record that you pass to the method.<source lang="csharp">PXUIFieldAttribute.SetEnabled&lt;Shipment.deliveryDate&gt;(
    sender, <b>row<b>, row.ShipmentType == ShipmentTypes.Single);</source>
When you use record-level attributes for the first time during a round trip, the system creates the record-level attributes by copying cache-level attributes. If some record-level attributes already exist and you pass <tt>null</tt> to an attribute&rsquo;s method, the system applies the change to both cache-level attributes and record-level attributes.]]></column>
			<column name="PlainText"><![CDATA[Configuration of the User Interface in Code To set up the UI presentation, you should use a  RowSelected  event         handler or the graph constructor. The  RowSelected  event happens several         times during every round trip: at the end of each insertion, update, or deletion of a data         record. The graph constructor is called once in the beginning of every round trip (before         any data is selected by data views). To disable, hide, or change a caption of a data field on the form, you use the static         methods of the  PXUIFieldAttribute  type, as shown in the following         example. PXUIFieldAttribute.SetEnabled<Shipment.deliveryDate>(
    sender, row, row.ShipmentType == ShipmentTypes.Single); You specify the field as the type parameter. It is mandatory to specify the            PXCache  object ( sender  in the example above). You can         provide a specific data record ( row ) or specify  null  in         the second parameter to apply the method to all data records in the cache. If you omit the         type parameter, the method will be applied to all fields that are displayed in the UI, as         shown in the following example. // Making all fields for all data records
// read-only in the cache object
PXUIFieldAttribute.SetReadOnly(sender, null, true); You can specify default UI options for a field in the  PXUIField          attribute in the data access class (DAC) and change them if necessary in a            RowSelected  event handler through the static methods of the         attribute. You shouldn't read anything from the database or write to the database in a            RowSelected  event handler. Always implement two states of a UI control (such as enabled and disabled)         when you set up the UI. Thus, when you make a data field disabled by some condition, you         have to enable the data field in the corresponding opposite condition. For related data records (in a one-to-many relationship), you place the entire         configuration of the UI presentation in the  RowSelected  event handler of         the master data record. You can hide columns of the details grid only in the            RowSelected  handler for the master data record. In the            RowSelected  event handler of the detail record displayed in a grid, you         can enable or disable data fields, but you cannot modify their visibility. Using the Graph Constructor The common UI presentation logic, which doesn't depend on particular values of the data         record, can be implemented in the constructor of the graph. In the constructor, you cannot         check the values of the currently selected data record, because no data records have been         loaded yet. To implement the UI presentation specific to a data record, you should use the            RowSelected  event handler of the data record. Working with Cache-Level and Record-Level Attributes  Acumatica Framework initializes attributes during the startup of the domain or the first initialization of a         graph that defines a  CacheAttached  event handler. During cache         initialization, the appropriate attributes are copied to the cache level. The system can         also create attributes of a data record level by copying cache-level attributes. To specify the properties of a cache-level attribute, you pass  null  as         the second argument to the static methods of the attribute, as the following code example         shows. The change to a property will affect all data records of the corresponding cache. PXUIFieldAttribute.SetVisible<ShipmentLine.shipmentDate>(
    ShipmentLines.Cache,  null , false); To specify the properties of a record-level attribute, you pass a data record as the second         argument to the static methods of the attribute (see the following code example). The change         will affect only the data record that you pass to the method. PXUIFieldAttribute.SetEnabled<Shipment.deliveryDate>(
    sender,  row , row.ShipmentType == ShipmentTypes.Single); When you use record-level attributes for the first time during a round trip, the system         creates the record-level attributes by copying cache-level attributes. If some record-level         attributes already exist and you pass  null  to an attribute's method, the         system applies the change to both cache-level attributes and record-level attributes. ]]></column>
		</row>
		<row PageID="8426aecd-5671-4e61-9f61-245110ed1486" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="c9a71894-ad75-a722-30c9-1bdcd2f01dcb" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The standard form toolbar buttons provide the following types of functionality for users:[anchor|#ul_p3x_mrn_djb]
*Data manipulation: '''Insert''', '''Delete''', '''Save''', and '''Cancel'''
*Navigation: '''Next''', '''Previous''', '''First''', and '''Last'''
*Use of the clipboard: '''Copy''' and '''Paste'''

Every toolbar button corresponds to an action declared in the graph. To add standard buttons to the toolbar, you can use explicit or implicit declaration of these actions. {br}

In any declaration, the DAC that you specify for actions must be the same as the main DAC of the primary view of the form. The form toolbar manipulates data records of the main DAC of the primary view. If the DAC specified for an action differs from the main DAC of the primary view, the button will not appear on the toolbar.{br}

Suppose that you are developing the Countries form, where users work with a table of records and need only the '''Cancel''' and '''Save''' toolbar buttons. (The users work with a table of records on the form and don&rsquo;t need the other standard buttons, such as '''Previous''' and '''Next''' for navigation.) In the example of the {{CountryMaint}} graph (shown in the following code), we explicitly declare two actions that correspond to the '''Cancel''' and '''Save''' standard toolbar buttons. <source lang="csharp">// Explicit definition of the required standard buttons
public class CountryMaint : PXGraph&lt;CountryMaint&gt;
{
    <b>public PXCancel&lt;Country&gt; Cancel;
    public PXSave&lt;Country&gt; Save;<b>
    ...
}</source>
To implicitly declare standard buttons, you need to specify the second type parameter in the base <tt>PXGraph</tt> class, as the following code shows in bold type. <source lang="csharp">// Implicit declaration of standard actions
public class CustomerMaint : PXGraph&lt;CustomerMaint, <b>Customer<b>&gt;
{
    public PXSelect&lt;Customer&gt; Customers;
}</source>{br}

The following code shows two equivalent declarations of actions for standard buttons that work with data records of the {{Customer}} DAC. Based on these declarations, the system automatically adds to the form toolbar the standard buttons for manipulating the {{Customer}} records if the main DAC of the primary view specified in the datasource control on the ASPX page is also {{Customer}}. <source lang="csharp">// Implicit declaration of standard actions
public class CustomerMaint : PXGraph&lt;CustomerMaint, Customer&gt;
{
    public PXSelect&lt;Customer&gt; Customers;
}

// Explicit declaration of standard actions
public class CustomerMaint : PXGraph&lt;CustomerMaint&gt;
{
    public PXSave&lt;Customer&gt; Save;
    public PXCancel&lt;Customer&gt; Cancel;
    public PXInsert&lt;Customer&gt; Insert;
    public PXCopyPasteAction&lt;Customer&gt; CopyPaste;
    public PXDelete&lt;Customer&gt; Delete;
    public PXFirst&lt;Customer&gt; First;
    public PXPrevious&lt;Customer&gt; Previous;
    public PXNext&lt;Customer&gt; Next;
    public PXLast&lt;Customer&gt; Last;
   
    public SelectFrom&lt;Customer&gt;.View Customers;
}</source>]]></column>
			<column name="PlainText"><![CDATA[Standard Buttons of the Form Toolbar The standard form toolbar buttons provide the following types of                 functionality for users: Data manipulation:  Insert ,                              Delete ,  Save , and                              Cancel Navigation:  Next ,  Previous ,                              First , and  Last Use of the clipboard:  Copy  and                              Paste Every toolbar button corresponds to an action declared in the                 graph. To add standard buttons to the toolbar, you can use explicit or implicit                 declaration of these actions.  In any declaration, the DAC that you specify for actions must be the same as the main                 DAC of the primary view of the form. The form toolbar manipulates data records of                 the main DAC of the primary view. If the DAC specified for an action differs from                 the main DAC of the primary view, the button will not appear on the toolbar. Suppose that you are developing the Countries form, where users work with a table of                 records and need only the  Cancel  and                      Save  toolbar buttons. (The users work with a table of                 records on the form and don't need the other standard buttons, such as                      Previous  and  Next  for navigation.)                 In the example of the  CountryMaint  graph (shown in the following                 code), we explicitly declare two actions that correspond to the                      Cancel  and  Save  standard toolbar                 buttons.  // Explicit definition of the required standard buttons
public class CountryMaint : PXGraph<CountryMaint>
{
     public PXCancel<Country> Cancel;
    public PXSave<Country> Save; 
    ...
} To implicitly declare standard buttons, you need to specify the second type parameter                 in the base  PXGraph  class, as the following code shows in bold                 type.                  // Implicit declaration of standard actions
public class CustomerMaint : PXGraph<CustomerMaint,  Customer >
{
    public PXSelect<Customer> Customers;
} The following code shows two equivalent declarations of actions for standard buttons                 that work with data records of the  Customer  DAC. Based on these                 declarations, the system automatically adds to the form toolbar the standard buttons                 for manipulating the  Customer  records if the main DAC of the                 primary view specified in the datasource control on the ASPX page is also                      Customer .  // Implicit declaration of standard actions
public class CustomerMaint : PXGraph<CustomerMaint, Customer>
{
    public PXSelect<Customer> Customers;
}

// Explicit declaration of standard actions
public class CustomerMaint : PXGraph<CustomerMaint>
{
    public PXSave<Customer> Save;
    public PXCancel<Customer> Cancel;
    public PXInsert<Customer> Insert;
    public PXCopyPasteAction<Customer> CopyPaste;
    public PXDelete<Customer> Delete;
    public PXFirst<Customer> First;
    public PXPrevious<Customer> Previous;
    public PXNext<Customer> Next;
    public PXLast<Customer> Last;
   
    public SelectFrom<Customer>.View Customers;
} ]]></column>
		</row>
		<row PageID="f1ef4253-f995-43f9-8c2e-86206d75c564" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8e5b7fd1-ab80-7e1f-523e-4d0a37c22057" RecordSourceID="22377">
			<column name="Content"><![CDATA[
''Actions'' are methods that can be invoked from outside of the graph, from the UI, or through the web service API. In the user interface, actions correspond to buttons or menu commands.{br}{TOC}
==Action Declaration==
The declaration of an action in a graph consists of the following:[anchor|#_0e7778ba-6a29-4285-9587-b50e75c60fa2]
*A field of the <tt>PXAction&lt;&gt;</tt> type, which is declared as follows.<source lang="csharp">public PXAction&lt;Shipment&gt; CancelShipment;</source>
*:In the <tt>PXAction&lt;&gt;</tt> type parameter, you should specify the main DAC of the primary data view. Otherwise, the action cannot be displayed on the form toolbar.
*A method that implements the action; this method has the <tt>PXButton</tt> and <tt>PXUIField</tt> attributes. This method has the following forms of declaration:
**Without parameters and returning <tt>void</tt>: This is the usual form of declaration (shown in the following code example).<source lang="csharp">[PXButton(CommitChanges = true)]
[PXUIField(DisplayName = "Cancel Shipment")]
protected virtual void cancelShipment()
{
    ...
}</source>
**:This type of declaration is used for actions that are executed synchronously and are not called from processing forms. 
**With a parameter of the <tt>PXAdapter</tt> type and returning <tt>IEnumerable</tt>: See an example in the following code.<source lang="csharp">[PXButton]
[PXUIField(DisplayName = "Release")]
protected virtual IEnumerable release(PXAdapter adapter)
{
    ...
    return adapter.Get();
}</source>
**:This type of declaration should be used when the action initiates a background operation or is called from processing forms. 

The field and the method should have the same name, differing only in the capitalization of the first letter.((({S:Warn}In the same way as a graph includes methods that invoke actions, the webpage&rsquo;s datasource includes callback commands for all actions defined in the graph. For details, see [https://help.acumatica.com/(W(19))/Help?ScreenId=ShowWiki&pageid=2a23cb2e-82a8-4354-8679-c87dd48b5c6e|Configuration of Callback Commands].
)))((({S:Warn}A graph includes the <tt>Actions</tt> collection of all <tt>PXAction&lt;&gt;</tt> objects defined in the graph.
)))
==Callback on the Action==
When a user invokes an action through the UI, the page sends a request to the server side of the application (that is, it executes the callback). If you need the form to send the recent changes made on the form, set the <tt>CommitChanges</tt> property of the <tt>PXButton</tt> attribute to <tt>true</tt> as follows.<source lang="csharp">[PXButton(<b>CommitChanges = true<b>)]</source>
You should always set the <tt>CommitChanges</tt> property to <tt>true</tt> for the actions that cause changes to be saved to the database.
==Types of Actions==
You typically use actions for the following purposes:[anchor|#_21a28a89-9641-4992-872f-e299bcecd80c]
*To redirect a user to a specific form or report. 
*To modify or validate data records and save changes to the database. Set the <tt>CommitChanges</tt> property of the <tt>PXButton</tt> attribute to <tt>true</tt> for these actions.
*To start a background operation, which is executed on a separate thread.

==Changing Appearance of Actions at Runtime==
You can adjust the appearance of an action in the UI at runtime (for example, to disable or hide the corresponding button on the form). To do this, you should use the methods of the <tt>PXAction&lt;&gt;</tt> class, as the following code example shows.{{{{// Disabling the CancelShipment action
CancelShipment.SetEnabled(false);
}}}}
You don&rsquo;t use the static methods of the <tt>PXUIField</tt> attribute, because these methods work only with the attribute copies stored in cache objects.]]></column>
			<column name="PlainText"><![CDATA[Configuration of Actions Actions  are methods that can be invoked from outside of the graph, from the UI, or through                     the web service API. In the user interface, actions correspond to buttons or                     menu commands. Action Declaration The declaration of an action in a graph consists of the following: A field of the  PXAction<>  type, which is declared as follows. public PXAction<Shipment> CancelShipment; In the  PXAction<>  type parameter, you should specify the main DAC of the primary data view. Otherwise, the action cannot be displayed on the form toolbar. A method that implements the action; this method has the  PXButton  and  PXUIField  attributes. This method has the following forms of declaration: Without parameters and returning  void : This is the usual form of declaration (shown in the following code example). [PXButton(CommitChanges = true)]
[PXUIField(DisplayName = "Cancel Shipment")]
protected virtual void cancelShipment()
{
    ...
} This type of declaration is used for actions that are executed synchronously and are not called from processing forms.  With a parameter of the  PXAdapter  type and returning                                      IEnumerable : See an example in the following                                     code. [PXButton]
[PXUIField(DisplayName = "Release")]
protected virtual IEnumerable release(PXAdapter adapter)
{
    ...
    return adapter.Get();
} This                                     type of declaration should be used when the action initiates a                                     background operation or is called from processing forms.                                  The field and the method should have the same name, differing only in the capitalization of the first letter. In the same way as a graph includes methods that invoke actions, the webpage's datasource                     includes callback commands for all actions defined in the graph. For details,                     see  Configuration of Callback                     Commands Configuration of Callback Commands. A graph includes the  Actions  collection of all  PXAction<>  objects defined in the graph. Callback on the Action When a user invokes an action through the UI, the page sends a request to the server side of the application (that is, it executes the callback). If you need the form to send the recent changes made on the form, set the  CommitChanges  property of the  PXButton  attribute to  true  as follows. [PXButton( CommitChanges = true )] You should always set the  CommitChanges  property to  true  for the actions that cause changes to be saved to the database. Types of Actions You typically use actions for the following purposes: To redirect a user to a specific form or report.  To modify or validate data records and save changes to the database. Set the  CommitChanges  property of the  PXButton  attribute to  true  for these actions. To start a background operation, which is executed on a separate thread. Changing Appearance of Actions at Runtime You can adjust the appearance of an action in the UI at runtime (for example, to                     disable or hide the corresponding button on the form). To do this, you should                     use the methods of the  PXAction<>  class, as the following                     code example shows. // Disabling the CancelShipment action
CancelShipment.SetEnabled(false); You don't use the static methods of the  PXUIField  attribute,                     because these methods work only with the attribute copies stored in cache                     objects. ]]></column>
		</row>
		<row PageID="c4473abb-d197-470d-8e88-de42ce9dbd78" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ef7252f5-3c11-fe66-7435-e17f623b272d" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you want to display a dialog box that requests confirmation from the user, you should use the <tt>Ask()</tt> method of a data view.{br}

For example, if you need the user to confirm that deletion should occur, you should invoke the <tt>Ask()</tt> method in the <tt>RowDeleting</tt> event handler for the data record that the user is trying to delete.<source lang="csharp">if (ShipmentLines.Ask("Confirm Delete",
                      "Are you sure?",
                       MessageButtons.YesNo) != WebDialogResult.Yes)
{
    e.Cancel = true;
}</source>
For details on the deletion process, see [HelpRoot_Dev_Platform\BL__con_Events_Delete|Sequence of Events: Deletion of a Data Record].{br}

You can use the <tt>Ask()</tt> method of a data view everywhere (that is, not only in <tt>RowDeleting</tt>) to display the dialog box requesting the user&rsquo;s confirmation to continue. If the <tt>Ask()</tt> method is used in an event handler, the event handler will be called twice. The first time, the event handler is interrupted on <tt>Ask()</tt> invocation, and the dialog box is displayed. The second time, after the dialog box is closed, the <tt>Ask()</tt> method indicates which button has been clicked, and execution continues.]]></column>
			<column name="PlainText"><![CDATA[Requests for User Confirmation If you want to display a dialog box that requests confirmation from the user, you should         use the  Ask()  method of a data view. For example, if you need the user to confirm that deletion should occur, you should invoke         the  Ask()  method in the  RowDeleting  event handler for         the data record that the user is trying to delete. if (ShipmentLines.Ask("Confirm Delete",
                      "Are you sure?",
                       MessageButtons.YesNo) != WebDialogResult.Yes)
{
    e.Cancel = true;
} For details on the deletion process, see  Sequence of Events: Deletion of a Data Record. You can use the  Ask()  method of a data view everywhere (that is, not         only in  RowDeleting ) to display the dialog box requesting the user's         confirmation to continue. If the  Ask()  method is used in an event         handler, the event handler will be called twice. The first time, the event handler is         interrupted on  Ask()  invocation, and the dialog box is displayed. The         second time, after the dialog box is closed, the  Ask()  method indicates         which button has been clicked, and execution continues. ]]></column>
		</row>
		<row PageID="5b99d9d1-3d36-49fc-8583-d400d30c6f9e" Language="en-US" PageRevisionID="1" Content="&#xA;In the &lt;tt&gt;RowInserting&lt;/tt&gt;, &lt;tt&gt;RowInserted&lt;/tt&gt;, &lt;tt&gt;RowUpdating&lt;/tt&gt;, &lt;tt&gt;RowUpdated&lt;/tt&gt;, &lt;tt&gt;RowDeleting&lt;/tt&gt;, and &lt;tt&gt;RowDeleted&lt;/tt&gt; event handlers, you can check whether the action was initiated in the UI. You should use the &lt;tt&gt;ExternalCall&lt;/tt&gt; property of the event arguments for this.{br}&#xA;&#xA;The &lt;tt&gt;ExternalCall&lt;/tt&gt; property returns &lt;tt&gt;true&lt;/tt&gt; if the deletion has been initialized in the UI or through the web services APIs. If you don&amp;rsquo;t need to invoke particular logic for data modifications made in code (such as the removal of a record), you can exit the method if the &lt;tt&gt;ExternalCall&lt;/tt&gt; property is &lt;tt&gt;false&lt;/tt&gt; as follows.&lt;source lang=&quot;csharp&quot;&gt;if (!e.ExternalCall) return;&lt;/source&gt;" PlainText="Determination of Whether an Action Was Initiated in the UI In the  RowInserting ,  RowInserted ,            RowUpdating ,  RowUpdated ,            RowDeleting , and  RowDeleted  event handlers, you can         check whether the action was initiated in the UI. You should use the            ExternalCall  property of the event arguments for this. The  ExternalCall  property returns  true  if the         deletion has been initialized in the UI or through the web services APIs. If you don't need         to invoke particular logic for data modifications made in code (such as the removal of a         record), you can exit the method if the  ExternalCall  property is            false  as follows. if (!e.ExternalCall) return; " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e87108af-a2c3-5401-78a9-68f6e20c8e9b" RecordSourceID="22377" />
		<row PageID="1fe245c2-b7de-42c7-a16c-217dc369c802" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="b358e535-0f78-3165-1c6c-fdfa889a05be" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You may need to redirect a user to an another webpage. Acumatica Framework supports the following types of redirection:[anchor|#ul_mgh_sfh_qk]
*To an another form of the Acumatica Framework-based application
*To a report created with Acumatica Report                         Designer
*To an inquiry form of the Acumatica Framework-based application
*To any destination URL
{br}

You can add redirection from a selector control declaratively, by adding the attributes to the data access class and to the selector control. Such redirection is often used for opening the data entry form from which the user can edit the record selected in the selector control. In other cases, the code invokes the redirection by throwing one of the exceptions provided by Acumatica Framework.{br}

Once an exception is thrown, it interrupts the current context and propagates up the call stack until it is handled by Acumatica Framework, which performs the redirection. You don&rsquo;t need to implement the handling of the exceptions that are used for redirection. Also, this mechanism doesn&rsquo;t affect the performance of the application.{br}

The following exceptions are used for redirection:[anchor|#ul_irs_hf3_qk]
*<tt>PXRedirectRequiredException</tt> opens the specified form in the same window or a new one. By default, the user is redirected in the same window.
*<tt>PXPopupRedirectException</tt> opens the specified form in a pop-up window.
*<tt>PXReportRequiredException</tt> opens the specified report in the same window or a new one. By default, the report opens in the same window.
*<tt>PXRedirectWithReportException</tt> opens the specified report in a new window, and the specified form in the same window.
*<tt>PXRedirectToUrlException</tt> opens the webpage with the specified external URL in a new window. This exception is also used for opening an inquiry form, which by default is loaded into the same window.
]]></column>
			<column name="PlainText"><![CDATA[Redirection to Webpages You may need to redirect a user to an another webpage.  Acumatica Framework         supports the following types of redirection: To an another form of the  Acumatica Framework-based application To a report created with  Acumatica Report                         DesignerTo an inquiry form of the  Acumatica Framework-based application To any destination URL You can add redirection from a selector control declaratively, by adding the attributes to         the data access class and to the selector control. Such redirection is often used for         opening the data entry form from which the user can edit the record selected in the selector         control. In other cases, the code invokes the redirection by throwing one of the exceptions         provided by  Acumatica Framework. Once an exception is thrown, it interrupts the current context and propagates up the call         stack until it is handled by  Acumatica Framework,         which performs the redirection. You don't need to implement the handling of the exceptions         that are used for redirection. Also, this mechanism doesn't affect the performance of the         application. The following exceptions are used for redirection: PXRedirectRequiredException  opens the specified form in the same           window or a new one. By default, the user is redirected in the same window. PXPopupRedirectException  opens the specified form in a pop-up           window. PXReportRequiredException  opens the specified report in the same           window or a new one. By default, the report opens in the same window. PXRedirectWithReportException  opens the specified report in a new           window, and the specified form in the same window. PXRedirectToUrlException  opens the webpage with the specified           external URL in a new window. This exception is also used for opening an inquiry form,           which by default is loaded into the same window. ]]></column>
		</row>
		<row PageID="7ae228cf-c106-4766-a5fe-d267bfd88779" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="75188cb2-bcd3-6216-fa84-784550b6676a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You use drop-down controls to give users the ability to select a value from the list of predefined values.{br}{TOC}
==Definition of a Drop-Down List==
To configure a drop-down list, you use the <tt>PXStringList</tt> or <tt>PXIntList</tt> attribute in the definition of the data field in the data access class (DAC), as shown in bold type in the following example.<source lang="csharp">[PXDBString(1)]
[PXDefault(ShipmentStatus.OnHold)]
[PXUIField(DisplayName = "Status")]
<b>[PXStringList(
    new string[]
    {
        ShipmentStatus.OnHold, ShipmentStatus.Shipping,
        ShipmentStatus.Cancelled, ShipmentStatus.Delivered
    },
    new string[]
    {
        "On Hold", "Shipping", "Cancelled", "Delivered"
    })]<b>
public virtual string Status
{
    get;
    set;
}</source>((({S:Warn}You use <tt>PXStringList</tt> when the values that are assigned to the field are strings, and you use <tt>PXIntList</tt> when the values are integers.
)))
In this example, <tt>ShipmentStatus</tt> is an enumeration defined in the following way.<source lang="csharp">public static class ShipmentStatus
{
    public const string OnHold = "H";
    public const string Shipping = "S";
    public const string Cancelled = "C";
    public const string Delivered = "D";
}</source>
As parameters, you provide two arrays of strings:[anchor|#ul_iql_p1p_jm]
*The array of values assigned to the field and saved to the database with the data record
*The array of labels displayed in the user interface

==Modifying a Drop-Down List at Run Time==[anchor|#_1dbff0c9-2652-4aeb-92a6-0d0d6811332c]
You can modify a drop-down list at runtime by using the <tt>SetList&lt;&gt;()</tt> static method of the <tt>PXStringList</tt> attribute. You can do this in the <tt>RowSelected</tt> event handler or graph constructor.{br}

The following code example shows the use of the <tt>SetList&lt;&gt;()</tt> method.<source lang="csharp">PXStringListAttribute.SetList&lt;Shipment.status&gt;(
    sender, row,
    new string[]
    {
        ShipmentStatus.OnHold,
        ShipmentStatus.Shipping,
    },
    new string[]
    {
        "On Hold",
        "Shipping",
    });</source>
This code sets a new list of values and labels for the <tt>Status</tt> field.{br}

In the type parameter, you specify the data field associated with the control. You also provide the cache object, the data record that will be affected by the method, the list of values, and the list of labels.{br}

If the list of possible values of a drop-down control is changed dynamically at runtime, you should use the <tt>RowSelected</tt> event handler to manage the list. Otherwise, we recommend that you create the list in the graph constructor.
==Insertion of a Not-Listed Value==
If a drop-down list is configured with the <tt>PXStringList</tt> attribute, you can allow a user to enter values that are not options in the list. You do this by setting the <tt>AllowEdit</tt> property of the <tt>PXDropDown</tt> control to <tt>True</tt> on the ASPX page (see the setting in bold type in the following code).<source lang="csharp">&lt;px:PXDropDown ID="edStatus" runat="server" DataField="Status"
               <b>AllowEdit="True"<b>&gt;
&lt;/px:PXDropDown&gt;</source>
==Selection of Multiple Values==
By default, a user can select one value from a drop-down list. The user will be able to select multiple values if you do all of the following:[anchor|#_3381737a-08fd-46d1-a5f9-bfaa89e391ba]
*Set the <tt>AllowMultiSelect</tt> property of the <tt>PXDropDown</tt> control to <tt>True</tt> on the ASPX page (see the setting in bold type in the following code).<source lang="csharp">&lt;px:PXDropDown ID="edStatus" runat="server" DataField="Status"
               <b>AllowMultiSelect="True"<b>&gt;
&lt;/px:PXDropDown&gt;</source>
*:The selected values are displayed in the control separated by a semicolon.
*Set the <tt>MultiSelect</tt> property of the <tt>PXStringList</tt> attribute to {{true}}, as shown in the following code.<source lang="csharp">[PXString(20)]
[PXUIField(DisplayName = "Priority")]
[PXStringList(
    new string[]
    {
    WorkOrderPriorityConstants.High,
    WorkOrderPriorityConstants.Medium,
    WorkOrderPriorityConstants.Low
    },
    new string[]
    {
    Messages.High,
    Messages.Medium,
    Messages.Low
    },
    <b>MultiSelect = true<b>)]
public virtual string Priority { get; set; }</source>
{br}

The selected values are displayed in the control separated by a semicolon.]]></column>
			<column name="PlainText"><![CDATA[Configuration of Drop-Down Lists You use drop-down controls to give users the ability to select a value from the list of         predefined values. Definition of a Drop-Down List To configure a drop-down list, you use the  PXStringList  or            PXIntList  attribute in the definition of the data field in the data         access class (DAC), as shown in bold type in the following example. [PXDBString(1)]
[PXDefault(ShipmentStatus.OnHold)]
[PXUIField(DisplayName = "Status")]
 [PXStringList(
    new string[]
    {
        ShipmentStatus.OnHold, ShipmentStatus.Shipping,
        ShipmentStatus.Cancelled, ShipmentStatus.Delivered
    },
    new string[]
    {
        "On Hold", "Shipping", "Cancelled", "Delivered"
    })] 
public virtual string Status
{
    get;
    set;
} You use  PXStringList  when the values that are assigned to the field         are strings, and you use  PXIntList  when the values are integers. In this example,  ShipmentStatus  is an enumeration defined in the         following way. public static class ShipmentStatus
{
    public const string OnHold = "H";
    public const string Shipping = "S";
    public const string Cancelled = "C";
    public const string Delivered = "D";
} As parameters, you provide two arrays of strings: The array of values assigned to the field and saved to the database with the data           record The array of labels displayed in the user interface Modifying a Drop-Down List at Run Time You can modify a drop-down list at runtime by using             the  SetList<>()  static method of the                  PXStringList  attribute. You can do this in the                  RowSelected  event handler or graph constructor. The following code example shows the use of the  SetList<>()          method. PXStringListAttribute.SetList<Shipment.status>(
    sender, row,
    new string[]
    {
        ShipmentStatus.OnHold,
        ShipmentStatus.Shipping,
    },
    new string[]
    {
        "On Hold",
        "Shipping",
    }); This code sets a new list of values and labels for the  Status  field. In the type parameter, you specify the data field associated with the control. You also         provide the cache object, the data record that will be affected by the method, the list of         values, and the list of labels. If the list of possible values of a drop-down control is changed dynamically at runtime,         you should use the  RowSelected  event handler to manage the list.         Otherwise, we recommend that you create the list in the graph constructor. Insertion of a Not-Listed Value If a drop-down list is configured with the  PXStringList  attribute, you         can allow a user to enter values that are not options in the list. You do this by setting         the  AllowEdit  property of the  PXDropDown  control to            True  on the ASPX page (see the setting in bold type in the following         code). <px:PXDropDown ID="edStatus" runat="server" DataField="Status"
                AllowEdit="True" >
</px:PXDropDown> Selection of Multiple Values By default, a user can select one value from a drop-down list. The user will be able to         select multiple values if you do all of the following: Set the  AllowMultiSelect  property of the                  PXDropDown  control to  True  on the ASPX page         (see the setting in bold type in the following code). <px:PXDropDown ID="edStatus" runat="server" DataField="Status"
                AllowMultiSelect="True" >
</px:PXDropDown> The selected values are displayed in the control separated by a semicolon. Set the  MultiSelect  property of the  PXStringList              attribute to  true , as shown in the following             code. [PXString(20)]
[PXUIField(DisplayName = "Priority")]
[PXStringList(
    new string[]
    {
    WorkOrderPriorityConstants.High,
    WorkOrderPriorityConstants.Medium,
    WorkOrderPriorityConstants.Low
    },
    new string[]
    {
    Messages.High,
    Messages.Medium,
    Messages.Low
    },
     MultiSelect = true )]
public virtual string Priority { get; set; } The selected values are displayed in the control separated by a semicolon. ]]></column>
		</row>
		<row PageID="fa079f56-6579-4984-88a9-139214a0750e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="161641ed-3d53-b269-3919-8fef567c8dc0" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You use selector controls to provide a list from which the user can select a data record and then to set the ID of the selected data record as the data field value.{br}{TOC}
==Defining a Selector Control==
To configure a selector control, you use the <tt>PXSelector</tt> attribute in the definition of the data field in the data access class (DAC), as shown in bold type in the following example.<source lang="csharp">[PXDBInt(IsKey = true)]
[PXDefault]
[PXUIField(DisplayName = "Product ID")]
<b>[PXSelector(typeof(Search&lt;Product.productID&gt;),
            typeof(Product.productCD),
            typeof(Product.productName),
            typeof(Product.unitPrice),
            SubstituteKey = typeof(Product.productCD))]<b>
public virtual int? ProductID
...</source>
In the first parameter, you specify a <tt>Search&lt;&gt;</tt> BQL query to select data records for the control. The <tt>Search&lt;&gt;</tt> command has the same syntax as the <tt>Select&lt;&gt;</tt> command, except that you specify the data field of the main DAC. In the <tt>Search&lt;&gt;</tt> command, you can specify conditions and join data from other DACs. When a user selects a data record in the control, the control assigns the value of the specified field to the data field.((({S:Warn}You can omit <tt>Search&lt;&gt;</tt> in the first parameter of <tt>PXSelector</tt>, if you specify only a DAC field without a complex expression that may contain {{WHERE}}, {{JOIN}}, {{ORDER BY}}, or {{GROUP BY}} conditions. Thus, in the example above, you can specify {{typeof(Product.productID)}} instead of {{typeof(Search<Product.productID>)}} in the first parameter.
)))
==Defining the List of Columns==
You configure the columns that should be shown in the control by providing the types of the fields after the <tt>Search&lt;&gt;</tt> command; see the code in bold type in the following example.<source lang="csharp">[PXSelector(typeof(Search&lt;Product.productID&gt;),
            <b>typeof(Product.productCD),
            typeof(Product.productName),
            typeof(Product.unitPrice),<b>
            SubstituteKey = typeof(Product.productCD))]
public virtual int? ProductID
...</source>
The code above defines three columns (see the following screenshot).[anchor|#image_dpn_yft_km][image:StudioDeveloperGuide/Images/B_L_AdvLogic_SelectorDropDown.png|popup|The selector control for Product data records|280px]
You can join multiple DACs in the <tt>Search&lt;&gt;</tt> command and specify fields from the joined DACs as columns. The following code example shows in bold type the {{LeftJoin}} clause and the fields from the joined DAC added to the selector control as columns.<source lang="csharp">[PXDBString(10, IsKey = true, IsUnicode = true, InputMask = "")]
[PXDefault]
[PXUIField(DisplayName = "Shipment Nbr.")]
[PXSelector(typeof(
    Search2&lt;Shipment.shipmentNbr,
        <b>LeftJoin&lt;Customer, On&lt;Customer.customerID,
                              Equal&lt;Shipment.customerID&gt;&gt;&gt;<b>&gt;),
            typeof(Shipment.shipmentNbr),
            typeof(Shipment.customerID),
            <b>typeof(Customer.customerCD),
            typeof(Customer.companyName<b>))]
public virtual string ShipmentNbr
...</source>((({S:Warn}If you don&rsquo;t specify any columns, the control will display all columns that have the <tt>Visibility</tt> property of the <tt>PXUIField</tt> attribute set to <tt>PXUIVisibility.SelectorVisible</tt>.
)))
==Replacing the Displayed Key Value==[anchor|#_074046a4-1126-42dd-8705-2bb0b8d61692]
The <tt>SubstituteKey</tt> property specifies the field whose value should be shown in the control in the UI instead of the field that is specified in the <tt>Search&lt;&gt;</tt> command.{br}

The <tt>SubstituteKey</tt> property is shown in the bold type in the following code.<source lang="csharp">[PXSelector(typeof(Search&lt;Product.productID&gt;),
            typeof(Product.productCD),
            typeof(Product.productName),
            typeof(Product.minAvailQty),
            <b>SubstituteKey = typeof(Product.productCD)<b>)]
public virtual int? ProductID
...</source>
In the example above, the <tt>ProductID</tt> field of a shipment line stores the <tt>ProductID</tt> value of the selected product, while in the UI. the control shows the <tt>ProductCD</tt> value. Conversion between the <tt>ProductID</tt> and <tt>ProductCD</tt> values happens in the <tt>FieldUpdating</tt> and <tt>FieldSelecting</tt> event handlers, which are implemented within the <tt>PXSelector</tt> attribute.]]></column>
			<column name="PlainText"><![CDATA[Configuration of Selector Controls You use selector controls to provide a list from which the user can select a data record         and then to set the ID of the selected data record as the data field value. Defining a Selector Control To configure a selector control, you use the  PXSelector  attribute in the         definition of the data field in the data access class (DAC), as shown in bold type in the         following example. [PXDBInt(IsKey = true)]
[PXDefault]
[PXUIField(DisplayName = "Product ID")]
 [PXSelector(typeof(Search<Product.productID>),
            typeof(Product.productCD),
            typeof(Product.productName),
            typeof(Product.unitPrice),
            SubstituteKey = typeof(Product.productCD))] 
public virtual int? ProductID
... In the first parameter, you specify a  Search<>  BQL query to select         data records for the control. The  Search<>  command has the same syntax         as the  Select<>  command, except that you specify the data field of the         main DAC. In the  Search<>  command, you can specify conditions and join         data from other DACs. When a user selects a data record in the control, the control assigns         the value of the specified field to the data field. You can omit  Search<>  in the first parameter of            PXSelector , if you specify only a DAC field without a complex         expression that may contain  WHERE ,  JOIN ,  ORDER           BY , or  GROUP BY  conditions. Thus, in the example above, you can         specify  typeof(Product.productID)  instead of            typeof(Search<Product.productID>)  in the first parameter. Defining the List of Columns You configure the columns that should be shown in the control by providing the types of the         fields after the  Search<>  command; see the code in bold type in the         following example. [PXSelector(typeof(Search<Product.productID>),
             typeof(Product.productCD),
            typeof(Product.productName),
            typeof(Product.unitPrice), 
            SubstituteKey = typeof(Product.productCD))]
public virtual int? ProductID
... The code above defines three columns (see the following screenshot). The selector control for Product data records You can join multiple DACs in the  Search<>  command and specify fields         from the joined DACs as columns. The following code example shows in bold type the            LeftJoin  clause and the fields from the joined DAC added to the selector         control as columns. [PXDBString(10, IsKey = true, IsUnicode = true, InputMask = "")]
[PXDefault]
[PXUIField(DisplayName = "Shipment Nbr.")]
[PXSelector(typeof(
    Search2<Shipment.shipmentNbr,
         LeftJoin<Customer, On<Customer.customerID,
                              Equal<Shipment.customerID>>> >),
            typeof(Shipment.shipmentNbr),
            typeof(Shipment.customerID),
             typeof(Customer.customerCD),
            typeof(Customer.companyName ))]
public virtual string ShipmentNbr
... If you don't specify any columns, the control will display all columns that have the            Visibility  property of the  PXUIField  attribute set         to  PXUIVisibility.SelectorVisible . Replacing the Displayed Key Value The  SubstituteKey  property             specifies the field whose value should be shown in the control in the UI instead of the             field that is specified in the  Search<>  command. The  SubstituteKey  property is shown in the bold type in the following         code. [PXSelector(typeof(Search<Product.productID>),
            typeof(Product.productCD),
            typeof(Product.productName),
            typeof(Product.minAvailQty),
             SubstituteKey = typeof(Product.productCD) )]
public virtual int? ProductID
... In the example above, the  ProductID  field of a shipment line stores the            ProductID  value of the selected product, while in the UI. the control         shows the  ProductCD  value. Conversion between the            ProductID  and  ProductCD  values happens in the            FieldUpdating  and  FieldSelecting  event handlers,         which are implemented within the  PXSelector  attribute. ]]></column>
		</row>
		<row PageID="5323f8d6-bfa0-4f19-8f94-261895f84f93" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f12d7842-15b8-5c75-4eb4-2061ef3b09a0" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The '''Company/Branch''' selection menu displays all the available companies with any branches they have as a tree to reflect the parent-child relations among these organizational entities. This selection menu can be viewed on multiple forms, such as the [HelpRoot_ReportReference\AR_63_25_00|AR Balance by Customer] ([~/?ScreenId=AR632500|AR632500]) form, The companies and branches an individual user can view in the '''Company/Branch''' selection menu depend on the way security has been configured in the system.{br}

The '''Company/Branch''' selection menu consists of two parts: [anchor|#_e64e4840-28a7-43b2-8be6-81870341afb9]
*The <tt>PXBranchSelector</tt> control on the ASPX page, which renders the tree structure of the companies and branches
*The <tt>OrganizationTree</tt> attribute in the data access class, which retrieves the data for the control
{br}

In this topic, you can find information about how to work with the '''Company/Branch''' selection menu in the code of an inquiry or processing form.{br}{TOC}
==Adding the Selection Menu to a Form==
To add the '''Company/Branch''' selection menu to an inquiry or processing form, you do the following:[anchor|#_34ce7537-6046-48de-ab5e-641a5b721537]
#Optional: In the filter DAC, add separate fields to hold the company and branch, which the system can fill with the company and branch identifiers when a value is selected in the '''Company/Branch''' selection menu. The following code shows an example of the field definitions. 
#:((({S:Warn}If the filter DAC does not contain these fields, you can omit the corresponding parameters in the constructor of the <tt>OrganizationTree</tt> attribute, which you will add in the next step.
)))<source lang="csharp">using PX.Objects.GL.Attributes;

#region OrganizationID
public abstract class organizationID : PX.Data.BQL.BqlInt.Field&lt;organizationID&gt; { }

[Organization(false, Required = false)]
public int? OrganizationID { get; set; }
#endregion
#region BranchID
public abstract class branchID : PX.Data.BQL.BqlInt.Field&lt;branchID&gt; { }

[BranchOfOrganization(typeof(ARHistoryFilter.organizationID), false)]
public int? BranchID { get; set; }</source>
#In the filter DAC, create an integer field, and add the <tt>OrganizationTree</tt> attribute to this field, as shown in the following code example. In the constructor of the attribute, specify the following values:
#*<tt>sourceOrganizationID</tt>: The type of the field in this DAC that stores the identifier of the company. The type can be null.
#*<tt>sourceBranchID</tt>: The type of the field in this DAC that stores the identifier of the branch. The type can be null. The value of {{sourceBranchID}} of the attribute can be {{null}} if a company is selected in the '''Company/Branch''' selection menu.
#*<tt>onlyActive</tt>: The Boolean value that (if set to {{true}}, which is the default value) displays only the company and branch records that have the <tt>Active</tt> field set to {{true}}.<source lang="csharp">using PX.Objects.GL.Attributes;

#region OrgBAccountID
public abstract class orgBAccountID : PX.Data.BQL.BqlInt.Field&lt;orgBAccountID&gt; { }

[OrganizationTree(
    sourceOrganizationID: typeof(organizationID), 
    sourceBranchID: typeof(branchID),              
    onlyActive: false)]
public int? OrgBAccountID { get; set; }
#endregion</source>
#:((({S:Warn}Because the objects of the company and branch have different types and their identifiers can overlap, the system identifies the entity that is selected in the '''Company/Branch''' selection menu by the business account identifier.
)))
#In the ASPX code of the form, add the <tt>PXBranchSelector</tt> control, as the following code example shows.{{{{&lt;px:PXBranchSelector CommitChanges="True" ID="edOrgBAccountID" 
       runat="server" DataField="OrgBAccountID"/&gt;
}}}}

==Restricting the Values of Fields That Depend on the Company or Branch==
In a selector control on a form, to display only the records that are available for the branch or company selected in the '''Company/Branch''' selection menu, you can use the following business query language (BQL) functions in the selector condition:[anchor|#_b1df4b98-0385-4ec7-8fbb-c751fd13aad5]
*<tt>Inside&lt;&gt;</tt>: To make sure that the branch specified by <tt>BranchID</tt> matches the entity specified in the '''Company/Branch''' selection menu—that is, to ensure that the branch is the same as the one selected in the selection menu or is a part of the company selected in the selection menu. The following code shows the use of this function.<source lang="csharp">using PX.Data.BQL.Fluent;
using using PX.Objects.GL;

[PXSelector(
    typeof(SearchFor&lt;Ledger.ledgerID&gt;
    .In&lt;SelectFrom&lt;Ledger&gt;
        .LeftJoin&lt;Branch&gt;
            .On&lt;Ledger.ledgerID.IsEqual&lt;Branch.ledgerID&gt;&gt;
        .Where&lt;Ledger.balanceType.IsEqual&lt;LedgerBalanceType.budget&gt;
            .And&lt;Branch.branchID.IsNull
                .Or&lt;Where&lt;Branch.branchID, Inside&lt;Optional&lt;orgBAccountID&gt;&gt;&gt;&gt;&gt;&gt;
        .AggregateTo&lt;GroupBy&lt;Ledger.ledgerID&gt;&gt;&gt;),
    SubstituteKey = typeof(Ledger.ledgerCD))]
public virtual int? BudgetLedgerIDByBAccount { get; set; }</source>
*<tt>Suit&lt;&gt;</tt>: To check that the company specified by <tt>OrganizationID</tt> matches the entity specified in the '''Company/Branch''' selection menu—that is, the company is the same as selected in '''Company/Branch''' or the branch selected in '''Company/Branch''' is a part of this company. The use of this function is shown in the following code example.<source lang="csharp">using PX.Data.BQL.Fluent;
using PX.Objects.GL;
using PX.Objects.GL.FinPeriods;
using PX.Objects.GL.FinPeriods.TableDefinition;

[FinPeriodSelector(
    typeof(Search&lt;OrganizationFinPeriod.finPeriodID,
        Where&lt;FinPeriod.organizationID, Suit&lt;Optional&lt;orgBAccountID&gt;&gt;&gt;&gt;),
    null)]
public string FinPeriodIDByBAccount { get; set; }</source>

==Filling in the Company or Branch During Redirection to a Form==
If you need to select the company or branch on an inquiry or processing form when this form is opened during redirection from another form, you specify the value of the organization&rsquo;s business account ID in the filter DAC of the target form. You do not need to specify the values of the <tt>BranchID</tt> or <tt>OrganizationID</tt> fields, which are specified automatically by <tt>OrganizationTreeAttribute</tt>. The following code shows an example of the code that performs redirection to an inquiry form with the company or branch specified.<source lang="csharp">using PX.Objects.GL;

AccountHistoryBySubEnq graph = 
    PXGraph.CreateInstance&lt;AccountHistoryBySubEnq&gt;();
GLHistoryEnqFilter filter = PXCache&lt;GLHistoryEnqFilter&gt;.CreateCopy(
    graph.Filter.Current);
filter.OrgBAccountID = Filter.Current.OrgBAccountID;
graph.Filter.Update(filter);
throw new PXRedirectRequiredException(graph, "Account by Subaccount");</source>]]></column>
			<column name="PlainText"><![CDATA[Company/Branch Selection Menu The  Company/Branch  selection menu displays all the available companies                 with any branches they have as a tree to reflect the parent-child relations among                 these organizational entities. This selection menu can be viewed on multiple forms,                 such as the   ([~/?ScreenId=AR632500|AR632500]) AR Balance by Customer (AR632500) form, The                 companies and branches an individual user can view in the                      Company/Branch  selection menu depend on the way security                 has been configured in the system. The  Company/Branch  selection menu consists of two parts:  The  PXBranchSelector  control on the ASPX page, which renders the tree                         structure of the companies and branches The  OrganizationTree  attribute in the data access class, which retrieves       the data for the control In this topic, you can find information about how to work with the                      Company/Branch  selection menu in the code of an inquiry                 or processing form. Adding the Selection Menu to a Form To add the  Company/Branch  selection menu to an inquiry or processing                 form, you do the following: Optional: In the filter DAC, add separate fields to hold the company and                         branch, which the system can fill with the company and branch identifiers                         when a value is selected in the  Company/Branch                          selection menu. The following code shows an example of the field                         definitions.  If the filter DAC does not contain these fields, you can                             omit the corresponding parameters in the constructor of the                                  OrganizationTree  attribute, which you will add in                             the next                         step. using PX.Objects.GL.Attributes;

#region OrganizationID
public abstract class organizationID : PX.Data.BQL.BqlInt.Field<organizationID> { }

[Organization(false, Required = false)]
public int? OrganizationID { get; set; }
#endregion
#region BranchID
public abstract class branchID : PX.Data.BQL.BqlInt.Field<branchID> { }

[BranchOfOrganization(typeof(ARHistoryFilter.organizationID), false)]
public int? BranchID { get; set; } In the filter DAC, create an integer field, and add the                              OrganizationTree  attribute to this field, as shown in                         the following code example. In the constructor of the attribute, specify the                         following values: sourceOrganizationID : The type of the field in                                 this DAC that stores the identifier of the company. The type can be                                 null. sourceBranchID : The type of the field in this DAC                                 that stores the identifier of the branch. The type can be null. The                                 value of  sourceBranchID  of the attribute can be                                      null  if a company is selected in the                                      Company/Branch  selection menu. onlyActive : The Boolean value that (if set to                                      true , which is the default value) displays only                                 the company and branch records that have the                                      Active  field set to                                  true . using PX.Objects.GL.Attributes;

#region OrgBAccountID
public abstract class orgBAccountID : PX.Data.BQL.BqlInt.Field<orgBAccountID> { }

[OrganizationTree(
    sourceOrganizationID: typeof(organizationID), 
    sourceBranchID: typeof(branchID),              
    onlyActive: false)]
public int? OrgBAccountID { get; set; }
#endregion Because                             the objects of the company and branch have different types and their                             identifiers can overlap, the system identifies the entity that is                             selected in the  Company/Branch  selection menu by                             the business account identifier. In the ASPX code of the form, add the  PXBranchSelector                          control, as the following code example                         shows. <px:PXBranchSelector CommitChanges="True" ID="edOrgBAccountID" 
       runat="server" DataField="OrgBAccountID"/> Restricting the Values of Fields That Depend on the Company or Branch In a selector control on a form, to display only the records that are available for the branch                 or company selected in the  Company/Branch  selection menu, you                 can use the following business query language (BQL) functions in the selector                     condition: Inside<> : To make sure that the branch specified by                              BranchID  matches the entity specified in the                              Company/Branch  selection menu—that is, to                         ensure that the branch is the same as the one selected in the selection menu                         or is a part of the company selected in the selection menu. The following                         code shows the use of this                         function. using PX.Data.BQL.Fluent;
using using PX.Objects.GL;

[PXSelector(
    typeof(SearchFor<Ledger.ledgerID>
    .In<SelectFrom<Ledger>
        .LeftJoin<Branch>
            .On<Ledger.ledgerID.IsEqual<Branch.ledgerID>>
        .Where<Ledger.balanceType.IsEqual<LedgerBalanceType.budget>
            .And<Branch.branchID.IsNull
                .Or<Where<Branch.branchID, Inside<Optional<orgBAccountID>>>>>>
        .AggregateTo<GroupBy<Ledger.ledgerID>>>),
    SubstituteKey = typeof(Ledger.ledgerCD))]
public virtual int? BudgetLedgerIDByBAccount { get; set; } Suit<> : To check that the company specified by                              OrganizationID  matches the entity specified in the                              Company/Branch  selection menu—that is, the                         company is the same as selected in  Company/Branch  or                         the branch selected in  Company/Branch  is a part of                         this company. The use of this function is shown in the following code                         example. using PX.Data.BQL.Fluent;
using PX.Objects.GL;
using PX.Objects.GL.FinPeriods;
using PX.Objects.GL.FinPeriods.TableDefinition;

[FinPeriodSelector(
    typeof(Search<OrganizationFinPeriod.finPeriodID,
        Where<FinPeriod.organizationID, Suit<Optional<orgBAccountID>>>>),
    null)]
public string FinPeriodIDByBAccount { get; set; } Filling in the Company or Branch During Redirection to a Form If you need to select the company or branch on an inquiry or processing form when this form is                 opened during redirection from another form, you specify the value of the                 organization's business account ID in the filter DAC of the target form. You do not                 need to specify the values of the  BranchID  or                      OrganizationID  fields, which are specified automatically by                      OrganizationTreeAttribute . The following code shows an                 example of the code that performs redirection to an inquiry form with the company or                 branch                 specified. using PX.Objects.GL;

AccountHistoryBySubEnq graph = 
    PXGraph.CreateInstance<AccountHistoryBySubEnq>();
GLHistoryEnqFilter filter = PXCache<GLHistoryEnqFilter>.CreateCopy(
    graph.Filter.Current);
filter.OrgBAccountID = Filter.Current.OrgBAccountID;
graph.Filter.Update(filter);
throw new PXRedirectRequiredException(graph, "Account by Subaccount"); ]]></column>
		</row>
		<row PageID="d0758787-4c73-423b-8566-11c83f3acde8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8b065aef-836b-8cfa-6cb4-92adea926dca" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can learn how to create a field on a form of an Acumatica Framework-based application so that its value is displayed in a specific format and how to govern what a user can enter as a value of this field. You can specify input and display masks for fields of the string and date and time types. For fields of the string type, you specify only the input mask, which defines both the format in which the user enters the value and the way the value is then displayed. For the date and time fields, you can specify different input and display masks. {br}{TOC}[anchor|#_0cc62625-b0fe-49a1-a170-5c17572f1e2d]
==To Specify an Input Mask and a Display Mask for a String Field==
[anchor|#_b9f91a17-bf67-4694-81bb-d81fd5ed32b0]
#In the data access class (DAC), add a new field or modify an existing {{string}} field as follows: 
##Add one of the string attributes ([https://help.acumatica.com/(W(24))/Main?ScreenId=ShowWiki&pageid=684c8a76-2fb6-3aac-fcd4-c19eeda8304b|<tt>PXDBString</tt>] or [https://help.acumatica.com/(W(24))/Main?ScreenId=ShowWiki&pageid=54a0e4fd-a521-7de4-2817-7ac59805293d|<tt>PXString</tt>]) to the property field.
##Specify the value of the <tt>InputMask</tt> property of the attribute. Use the following conventions to define the mask:
##*{{C}} or {{&}}: The user can enter any symbol.
##*{{A}} or {{a}}: The user can enter any letter or digit.
##*{{L}} or {{?}}: The user can enter only a letter.
##*{{#}}, {{0}}, or {{9}}: The user can enter only a digit.
##*{{>}}: All of the characters that follow this symbol should be in uppercase.
##*{{<}}: All of the characters that follow this symbol should be in lowercase.
##:The following example shows the use of the <tt>InputMask</tt> property.<source lang="csharp">//Users can enter only digits.
//If a user enters "1234567890", the value is displayed as "(123) 456-7890".
[PXDBString(10, InputMask = "(###) ###-####")]
[PXUIField(DisplayName = "Parameter 1")]
public virtual string Parameter1 { get; set; }</source>((({S:Warn}The value is stored in the database without any formatting characters. That is, for the code example above, if a user enters <tt>1234567890</tt>, the field in the database for the corresponding record will contain the same value (<tt>1234567890</tt>).
)))
#In the ASPX code of the form, add a new <tt>PXMaskEdit</tt> control or modify the control that corresponds to the field so that it has the <tt>PXMaskEdit</tt> type, as shown in the following code example.{{{{&lt;px:PXMaskEdit ID="edParameter1" runat="server" DataField="Parameter1"/&gt;
}}}}

==To Specify an Input and a Display Mask for a String Field at Runtime==
To specify the input mask for a string field at runtime, use a <tt>SetInputMask</tt> method of the [https://help.acumatica.com/(W(24))/Main?ScreenId=ShowWiki&pageid=684c8a76-2fb6-3aac-fcd4-c19eeda8304b|<tt>PXDBString</tt>] or [https://help.acumatica.com/(W(24))/Main?ScreenId=ShowWiki&pageid=54a0e4fd-a521-7de4-2817-7ac59805293d|<tt>PXString</tt>] attribute. You use the same conventions to define the mask as those described for the <tt>InputMask</tt> property in [[#_0cc62625-b0fe-49a1-a170-5c17572f1e2d|To Specify an Input Mask and a Display Mask for a String Field]. {br}

In the following example, the input mask of the {{AccountMask}} field is changed at run time.<source lang="csharp">protected virtual void GLBudgetTree_IsGroup_FieldSelecting(PXCache sender, 
  PXFieldSelectingEventArgs e)
{
  PXStringState strState = (PXStringState)sender.GetStateExt(
    null, typeof(GLBudgetTree.accountID).Name);
  PXDBStringAttribute.SetInputMask(sender, 
    typeof(GLBudgetTree.accountMask).Name, 
    strState.InputMask.Replace('#', 'C'));
}</source>
==To Specify an Input or a Display Mask for a Date and Time Field==[anchor|#_b0171f89-4cd4-4354-8c7c-67cc1254801e]
#In the data access class (DAC), add a new field or modify an existing data and time field as follows:
##Add one of the date and time attributes ([https://help.acumatica.com/(W(31))/Main?ScreenId=ShowWiki&pageid=e13e06c7-dd25-b9ae-6fdb-ca0103b3642b|<tt>PXDate</tt>], [https://help.acumatica.com/(W(33))/Main?ScreenId=ShowWiki&pageid=b9434f84-8a5d-d88c-ee97-cdb53e48c506|<tt>PXDateAndTime</tt>], [https://help.acumatica.com/(W(31))/Main?ScreenId=ShowWiki&pageid=b8abec45-68df-3f25-2661-b48baddf4f2d|<tt>PXDBDate</tt>], [https://help.acumatica.com/(W(38))/Main?ScreenId=ShowWiki&pageid=9cd8c337-f815-e101-4335-56625c37e39e|<tt>PXDBTime</tt>], or [https://help.acumatica.com/(W(33))/Main?ScreenId=ShowWiki&pageid=0fe1d7bb-3452-b2b0-c70c-0de73c8a3c37|<tt>PXDBDateAndTime</tt>]) to the property field.
## Specify the value of the <tt>InputMask</tt> or <tt>DisplayMask</tt> property of the attribute. Use the [https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings|standard] and [https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings|custom] date and time format strings.
#:The following example shows the use of the <tt>InputMask</tt> and <tt>DisplayMask</tt> properties.<source lang="csharp">[PXDateAndTime(DisplayMask = "D", InputMask ="d")]
[PXUIField(DisplayName = "Parameter 1")]
public virtual DateTime? Parameter1 { get; set; }</source>
#In the ASPX code of the form, add a new <tt>PXDateTimeEdit</tt> control or modify the control that corresponds to the field so that it has the <tt>PXDateTimeEdit</tt> type, as shown in the following code example.{{{{&lt;px:PXDateTimeEdit ID="edParameter1" runat="server" DataField="Parameter1"/&gt;
}}}}
#:((({S:Warn}You can change how the <tt>PXDateTimeEdit</tt> control is displayed (whether the control shows a calendar selector or a drop-down list with time values) by specifying the value of the <tt>TimeMode</tt> property. The following example causes the system to display the list of time values. {{{{&lt;px:PXDateTimeEdit ID="edParameter1" runat="server" DataField="Parameter1" 
  TimeMode="true"/&gt;
}}}}
)))
]]></column>
			<column name="PlainText"><![CDATA[To Configure an Input Mask and a Display Mask for a Field In this topic, you can learn how to create a field on a form of an  Acumatica Framework-based application so that its value is displayed in a specific format and how to govern         what a user can enter as a value of this field. You can specify input and display masks for         fields of the string and date and time types. For fields of the string type, you specify         only the input mask, which defines both the format in which the user enters the value and         the way the value is then displayed. For the date and time fields, you can specify different         input and display masks.  To Specify an Input Mask and a Display Mask for a String Field In the data access class (DAC), add a new field or modify an existing                string  field as follows:  Add one of the string attributes ( PXDBString <tt>PXDBString</tt> or  PXString <tt>PXString</tt>) to the property                 field. Specify the value of the  InputMask  property of the attribute.                 Use the following conventions to define the mask: C  or  & : The user can enter any                     symbol. A  or  a : The user can enter any letter or                     digit. L  or  ? : The user can enter only a                     letter. # ,  0 , or  9 : The user                     can enter only a digit. > : All of the characters that follow this symbol should be in                     uppercase. < : All of the characters that follow this symbol should be                     in lowercase. The following example shows the use of the  InputMask                      property. //Users can enter only digits.
//If a user enters "1234567890", the value is displayed as "(123) 456-7890".
[PXDBString(10, InputMask = "(###) ###-####")]
[PXUIField(DisplayName = "Parameter 1")]
public virtual string Parameter1 { get; set; } The                     value is stored in the database without any formatting characters. That is, for                     the code example above, if a user enters  1234567890 , the                     field in the database for the corresponding record will contain the same value                       ( 1234567890 ). In the ASPX code of the form, add a new  PXMaskEdit  control or             modify the control that corresponds to the field so that it has the                PXMaskEdit  type, as shown in the following code             example. <px:PXMaskEdit ID="edParameter1" runat="server" DataField="Parameter1"/> To Specify an Input and a Display Mask for a String Field at Runtime To specify the input mask for a string field at runtime, use a            SetInputMask  method of the  PXDBString <tt>PXDBString</tt> or  PXString <tt>PXString</tt> attribute. You use the         same conventions to define the mask as those described for the  InputMask          property in  To Specify an Input Mask and a Display Mask for a String Field To Specify an Input Mask and a Display Mask for a String Field.  In the following example, the input mask of the  AccountMask  field is         changed at run         time. protected virtual void GLBudgetTree_IsGroup_FieldSelecting(PXCache sender, 
  PXFieldSelectingEventArgs e)
{
  PXStringState strState = (PXStringState)sender.GetStateExt(
    null, typeof(GLBudgetTree.accountID).Name);
  PXDBStringAttribute.SetInputMask(sender, 
    typeof(GLBudgetTree.accountMask).Name, 
    strState.InputMask.Replace('#', 'C'));
} To Specify an Input or a Display Mask for a Date and Time Field In the data access class (DAC), add a new field or modify an existing data and time           field as follows: Add one of the date and time attributes ( PXDate <tt>PXDate</tt>,  PXDateAndTime <tt>PXDateAndTime</tt>,  PXDBDate <tt>PXDBDate</tt>,  PXDBTime <tt>PXDBTime</tt>, or  PXDBDateAndTime <tt>PXDBDateAndTime</tt>) to the               property field.  Specify the value of the  InputMask  or                  DisplayMask  property of the attribute. Use the  standard standard and  custom custom date and time format strings. The following example shows the use of the  InputMask  and                DisplayMask              properties. [PXDateAndTime(DisplayMask = "D", InputMask ="d")]
[PXUIField(DisplayName = "Parameter 1")]
public virtual DateTime? Parameter1 { get; set; } In the ASPX code of the form, add a new  PXDateTimeEdit  control or           modify the control that corresponds to the field so that it has the              PXDateTimeEdit  type, as shown in the following code             example. <px:PXDateTimeEdit ID="edParameter1" runat="server" DataField="Parameter1"/> You             can change how the  PXDateTimeEdit  control is displayed (whether the             control shows a calendar selector or a drop-down list with time values) by specifying             the value of the  TimeMode  property. The following example causes the             system to display the list of time values.              <px:PXDateTimeEdit ID="edParameter1" runat="server" DataField="Parameter1" 
  TimeMode="true"/> ]]></column>
		</row>
		<row PageID="0893a861-ee7d-49f5-84ea-1740df9f11d6" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="46cf1d55-3143-ed0a-dea0-e9d52f9288d3" RecordSourceID="22377">
			<column name="Content"><![CDATA[When a user clicks a button on a form of an Acumatica Framework-based application, you may need to display a dialog box that displays the settings related to the action to be performed. For example, on the [HelpRoot_FormReference\CS_10_15_00|Companies] ([~/?ScreenId=CS101500|CS101500]) form, if you click '''Create Ledger''', the system opens the '''Create Ledger''' dialog box, where a user can specify the setting related to the action.
==To Display a Dialog Box==[anchor|#_626e5ba5-05f1-41d2-bf4c-a0ac132e74a7]
#In the graph that corresponds to the form, add the action and the delegate for the button that opens the dialog box, as shown in the following example.<source lang="csharp">public PXAction&lt;MainDAC&gt; openDialogBox;

[PXUIField(DisplayName = "Open Dialog Box",
    MapEnableRights = PXCacheRights.Update,
    MapViewRights = PXCacheRights.Update)]
[PXButton]
public virtual IEnumerable OpenDialogBox(PXAdapter adapter)
{
    return adapter.Get();
}</source>
#:In this example, the {{MainDAC}} DAC is the main DAC of the primary view of the graph; therefore, the action is added to the toolbar of the form by default.
#If you want to specify additional properties of the action (such as <tt>CommitChanges</tt>), in the ASPX code of the form, add the <tt>PXDSCallbackCommand</tt> tag for the action and specify the necessary properties of the tag, as shown in the following example.{{{{&lt;px:PXDataSource ID="ds" runat="server" ...&gt;
    &lt;CallbackCommands&gt;
        ...
        &lt;px:PXDSCallbackCommand Name="CreateLedger" CommitChanges="true"/&gt;
    &lt;/CallbackCommands&gt;
&lt;/px:PXDataSource&gt;
}}}}
#In the graph that corresponds to the form, add the data view for the dialog box, as shown in the following code.<source lang="csharp">[Serializable]
public class DialogBoxParameters : IBqlTable
{
    public abstract class parameter1 : IBqlField { }
    [PXString(10, IsUnicode = true)]
    public virtual string Parameter1 { get; set; }

    public abstract class parameter2 : IBqlField { }
    [PXString(10, IsUnicode = true)]
    public virtual string Parameter2 { get; set; }
}

PXFilter&lt;DialogBoxParameters&gt; OpenDialogBoxView;</source>
#:In this code, we add a simple DAC with two unbound fields and use a data view based on the <tt>PXFilter</tt> class.
#In the ASPX code of the form, add the <tt>PXSmartPanel</tt> container with the <tt>Key</tt> property equal to the name of the data view you created for the dialog box, as shown in the following code. In the <tt>PXPanel</tt> container inside <tt>PXSmartPanel</tt>, add the commit buttons of the dialog box (such as '''OK''', '''Cancel'''). {{{{&lt;px:PXSmartPanel ID="pnlOpenDialogBox" runat="server" 
Style="z-index: 108;" Caption="Open Dialog Box" CaptionVisible="True" 
Key="OpenDialogBoxView" LoadOnDemand="true" AutoCallBack-Command="Refresh" 
AutoCallBack-Target="formOpenDialogBox" AutoCallBack-Enabled="true" 
AcceptButtonID="cbOk" CancelButtonID="cbCancel"&gt;
    &lt;px:PXFormView ID="formOpenDialogBox" runat="server" 
      DataSourceID="ds" DataMember="OpenDialogBoxView" 
      SkinID="Transparent"&gt;
        &lt;ContentStyle BorderWidth="0px"&gt;&lt;/ContentStyle&gt;
        &lt;Template&gt;
            &lt;px:PXLayoutRule runat="server" StartColumn="True" 
              LabelsWidth="SM" ControlSize="M" /&gt;
            &lt;px:PXTextEdit  ID="edParameter1" runat="server" 
              DataField="Parameter1" CommitChanges="True"/&gt;
            &lt;px:PXTextEdit  ID="edParameter2" runat="server" 
              DataField="Parameter2" CommitChanges="True" /&gt;
        &lt;/Template&gt;
    &lt;/px:PXFormView&gt;
    &lt;px:PXPanel ID="PXPanel3" runat="server" SkinID="Buttons"&gt;
        &lt;px:PXButton ID="cbOK" runat="server" Text="OK" 
          CommandSourceID="ds" DialogResult="OK" /&gt;
        &lt;px:PXButton ID="cbCancel" runat="server" Text="Cancel" 
          DialogResult="Cancel" /&gt;
    &lt;/px:PXPanel&gt;
&lt;/px:PXSmartPanel&gt;
}}}}
#In the button delegate, perform a call to an [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=df3262ed-e235-8bf0-66c9-8a2a39df4c3c|<tt>AskExt</tt>] method of the view specified in the <tt>Key</tt> property of the <tt>PXSmartPanel</tt> container.{{{{public virtual IEnumerable OpenDialogBox(PXAdapter adapter)
{
    if (OpenDialogBoxView.AskExt() == WebDialogResult.OK &&
        string.IsNullOrEmpty(OpenDialogBoxView.Current.Parameter1) 
        == false)
    {
        ...
    }
    return adapter.Get();
}
}}}}
#:When the user clicks the button on the form, the execution interrupts on the <tt>AskExt</tt> call and the dialog box is displayed. After the user clicks a button in the dialog box, the <tt>AskExt</tt> method returns the dialog box result.
#Rebuild the project.
]]></column>
			<column name="PlainText"><![CDATA[To Display a Dialog Box When a user clicks a button on a form of an  Acumatica Framework-based application, you may need to display a dialog box that displays the settings related       to the action to be performed. For example, on the   ([~/?ScreenId=CS101500|CS101500]) Companies (CS101500) form, if you click  Create Ledger , the system opens the          Create Ledger  dialog box, where a user can specify the setting       related to the action. To Display a Dialog Box In the graph that corresponds to the form, add the action and the delegate for the           button that opens the dialog box, as shown in the following             example. public PXAction<MainDAC> openDialogBox;

[PXUIField(DisplayName = "Open Dialog Box",
    MapEnableRights = PXCacheRights.Update,
    MapViewRights = PXCacheRights.Update)]
[PXButton]
public virtual IEnumerable OpenDialogBox(PXAdapter adapter)
{
    return adapter.Get();
} In             this example, the  MainDAC  DAC is the main DAC of the primary view of             the graph; therefore, the action is added to the toolbar of the form by           default. If you want to specify additional properties of the action (such as              CommitChanges ), in the ASPX code of the form, add the              PXDSCallbackCommand  tag for the action and specify the necessary           properties of the tag, as shown in the following           example. <px:PXDataSource ID="ds" runat="server" ...>
    <CallbackCommands>
        ...
        <px:PXDSCallbackCommand Name="CreateLedger" CommitChanges="true"/>
    </CallbackCommands>
</px:PXDataSource> In the graph that corresponds to the form, add the data view for the dialog box, as           shown in the following             code. [Serializable]
public class DialogBoxParameters : IBqlTable
{
    public abstract class parameter1 : IBqlField { }
    [PXString(10, IsUnicode = true)]
    public virtual string Parameter1 { get; set; }

    public abstract class parameter2 : IBqlField { }
    [PXString(10, IsUnicode = true)]
    public virtual string Parameter2 { get; set; }
}

PXFilter<DialogBoxParameters> OpenDialogBoxView; In             this code, we add a simple DAC with two unbound fields and use a data view based on the                PXFilter  class. In the ASPX code of the form, add the  PXSmartPanel  container with           the  Key  property equal to the name of the data view you created for the           dialog box, as shown in the following code. In the  PXPanel  container           inside  PXSmartPanel , add the commit buttons of the dialog box (such as              OK ,  Cancel ).            <px:PXSmartPanel ID="pnlOpenDialogBox" runat="server" 
Style="z-index: 108;" Caption="Open Dialog Box" CaptionVisible="True" 
Key="OpenDialogBoxView" LoadOnDemand="true" AutoCallBack-Command="Refresh" 
AutoCallBack-Target="formOpenDialogBox" AutoCallBack-Enabled="true" 
AcceptButtonID="cbOk" CancelButtonID="cbCancel">
    <px:PXFormView ID="formOpenDialogBox" runat="server" 
      DataSourceID="ds" DataMember="OpenDialogBoxView" 
      SkinID="Transparent">
        <ContentStyle BorderWidth="0px"></ContentStyle>
        <Template>
            <px:PXLayoutRule runat="server" StartColumn="True" 
              LabelsWidth="SM" ControlSize="M" />
            <px:PXTextEdit  ID="edParameter1" runat="server" 
              DataField="Parameter1" CommitChanges="True"/>
            <px:PXTextEdit  ID="edParameter2" runat="server" 
              DataField="Parameter2" CommitChanges="True" />
        </Template>
    </px:PXFormView>
    <px:PXPanel ID="PXPanel3" runat="server" SkinID="Buttons">
        <px:PXButton ID="cbOK" runat="server" Text="OK" 
          CommandSourceID="ds" DialogResult="OK" />
        <px:PXButton ID="cbCancel" runat="server" Text="Cancel" 
          DialogResult="Cancel" />
    </px:PXPanel>
</px:PXSmartPanel> In the button delegate, perform a call to an  AskExt <tt>AskExt</tt> method of the view           specified in the  Key  property of the  PXSmartPanel              container. public virtual IEnumerable OpenDialogBox(PXAdapter adapter)
{
    if (OpenDialogBoxView.AskExt() == WebDialogResult.OK &&
        string.IsNullOrEmpty(OpenDialogBoxView.Current.Parameter1) 
        == false)
    {
        ...
    }
    return adapter.Get();
} When             the user clicks the button on the form, the execution interrupts on the                AskExt  call and the dialog box is displayed. After the user clicks             a button in the dialog box, the  AskExt  method returns the dialog box             result. Rebuild the project. ]]></column>
		</row>
		<row PageID="884fc64f-bea3-4a0d-a1fa-ece24e5096be" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can find information about how to create specific types of forms, such as setup forms.&#xA;==In This Chapter==[anchor|#_058a6b96-e352-46f4-a6ad-9148f45eb74d]&#xA;*[HelpRoot_Dev_Platform\BL__con_UsingSetup|Configuration Parameters of the Application (Setup Forms)]&#xA;*[HelpRoot_Dev_Platform\BL__con_Filter_Data_View|Data View for the Filtering Parameters]&#xA;*[HelpRoot_Dev_Platform\BL__con_Creating_Processing_Forms|Creation of Processing Forms]&#xA;*[HelpRoot_Dev_Platform\BL__con_Implementation_of_ProcOperations|Implementation of Processing Operations]&#xA;*[HelpRoot_Dev_Platform\BL__how_Add_Button_to_Processing_Dialog_Box|To Add a Button to the Processing Dialog Box]&#xA;*[HelpRoot_Dev_Platform\BL__how_Disable_Processing_Dialog_Box|To Not Display the Processing Dialog Box]&#xA;" PlainText="Creating Particular Types of Forms In this chapter, you can find information about how to create specific types of forms, such as     setup forms. In This Chapter Configuration Parameters of the Application (Setup Forms)Data View for the Filtering ParametersCreation of Processing FormsImplementation of Processing OperationsTo Add a Button to the Processing Dialog BoxTo Not Display the Processing Dialog Box" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="66a25511-34a1-50ca-347b-0f6611c0ae64" RecordSourceID="22377" />
		<row PageID="e8ee0bad-780a-4489-8dce-48395e6757f2" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="9c68200c-1e4b-4e7b-b11d-b673d21465c8" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The configuration parameters of an application may include business settings, initial values, options, and modes that can be enabled or disabled. Configuration parameters are stored in ''setup tables''. Each major part or module of an application can use its own setup tables. For example, in Acumatica ERP, the {{ARSetup}} and {{APSetup}} tables hold the configuration parameters for the accounts receivable and accounts payable modules or parts of the application, respectively. Administrators specify these settings on the [HelpRoot_FormReference\AR_10_10_00|Accounts Receivable Preferences] ([~/?ScreenId=AR101000|AR101000]) and [HelpRoot_FormReference\AP_10_10_00|Accounts Payable Preferences] ([~/?ScreenId=AP101000|AP101000]) forms, respectively.{br}

A setup data access class (DAC) never has key fields. When a user navigates to a setup form, the system displays the first retrieved data record. If no record is retrieved, the framework creates a new record that is saved to the database when the user clicks '''Save''' on the form. The next time the form is opened, the previously inserted record is retrieved. '''Save''' and '''Cancel''' are the only buttons that are necessary on a setup form.{br}

A record from a setup table represents a consistent set of configuration parameters—that is, all fields of the record are specified and cannot be {{null}} (the administrative user cannot save the record without all elements being specified, whether with default settings or those the user has specified). You don&rsquo;t have to verify that each parameter has been specified in the setup record before use of this record. Instead, you just verify the existence of the setup record; its existence implies that all required parameters have been specified. If the configuration parameters have not been specified and a user tries to navigate to a form that uses these configuration parameters, you can return a specific error page that provides the link to the setup form where a user can specify the configuration parameters (see the following screenshot).[anchor|#image_yd1_fgj_jm][image:StudioDeveloperGuide/Images/MissingConfErrorPage.png|popup|Error page for missing configuration data|420px]
In an Acumatica Framework-based application, the configuration parameters are used as data fields of a {{Setup}} class. To define and use a {{Setup}} class, you perform the following steps:[anchor|#ol_nrj_3q3_jm]
#Create a {{Setup}} table in the database. (You add a prefix to the {{Setup}} name according to [HelpRoot_Dev_Platform\DA__con_Table_Column_Naming_Conventions|Table and Column Naming Conventions].) Add to this table columns that represent configuration parameters.
#Define a {{Setup}} data access class with the same name as the name of the {{Setup}} database table. In the data access class, add the <tt>PXDefault</tt> attribute to the required configuration parameters.
#Create an edit form for the {{Setup}} data record.
#:You should configure the UI of the setup form so that an administrative user can insert and edit only one record, which represents the configuration of this part or module of the application. Define only two actions, {{Save}} and {{Cancel}}, for this page.
#Add the <tt>PXPrimaryGraph</tt> attribute to the {{Setup}} DAC. In the attribute, specify the graph used by the setup form.

To display the error page for missing configuration data in the UI when the user tries to navigate to a form that depends on configuration parameters, you do the following:[anchor|#ol_v1q_l2j_jm]
#In the graph where you want to use configuration parameters, define the <tt>PXSetup</tt> data view as follows.<source lang="csharp">public class ReceiptEntry : PXGraph&lt;ReceiptEntry, Document&gt;
{
    public PXSetup&lt;Setup&gt; AutoNumSetup;
    ...
}</source>
#In the graph constructor, obtain the current record from the <tt>PXSetup</tt> data view, as the following code shows.<source lang="csharp">public ReceiptEntry()
{
    Setup setup = AutoNumSetup.Current;
}</source>

==Configuration Parameters in a Multitenant Application==
Each tenant may have its own configuration parameters that are identified by the company ID in the setup table. To support multitenant configuration, the setup table should contain the {{CompanyID}} column as the primary key in the database. The {{CompanyID}} field is not declared in DACs. This column is transparently handled by the framework, which retrieves records by the needed {{CompanyID}} only.{br}

The application template provides two tenants by default: the system one and the active one. The system tenant is read-only and has a {{CompanyID}} of 1. The second tenant, which is active, is used for all new and updated objects. The active tenant has a {{CompanyID}} of 2. The configuration parameters are saved to the setup table with the {{CompanyID}} of 2. Each new tenant that you add to the application gets the next sequential ID: 3, 4, and so on.]]></column>
			<column name="PlainText"><![CDATA[Configuration Parameters of the Application (Setup Forms) The configuration parameters of an application may include business settings, initial         values, options, and modes that can be enabled or disabled. Configuration parameters are         stored in  setup tables . Each major part or module of an application can use its own         setup tables. For example, in  Acumatica ERP, the  ARSetup  and  APSetup  tables hold the configuration         parameters for the accounts receivable and accounts payable modules or parts of the         application, respectively. Administrators specify these settings on the   ([~/?ScreenId=AR101000|AR101000]) Accounts Receivable Preferences (AR101000) and   ([~/?ScreenId=AP101000|AP101000]) Accounts Payable Preferences (AP101000) forms, respectively. A setup data access class (DAC) never has key fields. When a user navigates to a setup         form, the system displays the first retrieved data record. If no record is retrieved, the         framework creates a new record that is saved to the database when the user clicks            Save  on the form. The next time the form is opened, the previously         inserted record is retrieved.  Save  and  Cancel          are the only buttons that are necessary on a setup form. A record from a setup table represents a consistent set of configuration         parameters—that is, all fields of the record are specified and cannot be            null  (the administrative user cannot save the record without all elements         being specified, whether with default settings or those the user has specified). You don't         have to verify that each parameter has been specified in the setup record before use of this         record. Instead, you just verify the existence of the setup record; its existence implies         that all required parameters have been specified. If the configuration parameters have not         been specified and a user tries to navigate to a form that uses these configuration         parameters, you can return a specific error page that provides the link to the setup form         where a user can specify the configuration parameters (see the following screenshot). Error page for missing configuration data In an  Acumatica Framework-based application, the configuration parameters are used as data fields of a            Setup  class. To define and use a  Setup  class, you         perform the following steps: Create a  Setup  table in the database. (You add a prefix to the              Setup  name according to  Table and Column Naming Conventions.) Add to this table columns that           represent configuration parameters. Define a  Setup  data access class with the same name as the name of the              Setup  database table. In the data access class, add the              PXDefault  attribute to the required configuration parameters. Create an edit form for the  Setup  data record. You should configure             the UI of the setup form so that an administrative user can insert and edit only one             record, which represents the configuration of this part or module of the application.             Define only two actions,  Save  and  Cancel , for this             page. Add the  PXPrimaryGraph  attribute to the  Setup  DAC.           In the attribute, specify the graph used by the setup form. To display the error page for missing configuration data in the UI when the user tries to         navigate to a form that depends on configuration parameters, you do the following: In the graph where you want to use configuration parameters, define the              PXSetup  data view as           follows. public class ReceiptEntry : PXGraph<ReceiptEntry, Document>
{
    public PXSetup<Setup> AutoNumSetup;
    ...
} In the graph constructor, obtain the current record from the  PXSetup            data view, as the following code           shows. public ReceiptEntry()
{
    Setup setup = AutoNumSetup.Current;
} Configuration Parameters in a Multitenant Application Each tenant may have its own configuration parameters that are identified by the company ID in         the setup table. To support multitenant configuration, the setup table should contain the            CompanyID  column as the primary key in the database. The            CompanyID  field is not declared in DACs. This column is transparently         handled by the framework, which retrieves records by the needed  CompanyID          only. The application template provides two tenants by default: the system one and the active one. The         system tenant is read-only and has a  CompanyID  of 1. The second tenant,         which is active, is used for all new and updated objects. The active tenant has a            CompanyID  of 2. The configuration parameters are saved to the setup table         with the  CompanyID  of 2. Each new tenant that you add to the application         gets the next sequential ID: 3, 4, and so on. ]]></column>
		</row>
		<row PageID="60c28bba-15da-4f17-aad2-be02e3eef2f8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="455f0791-f21f-4ab1-ed9c-06d74e5ef226" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The generic <tt>PXFilter</tt> type of data view is used to provide filtering parameters on the form for user selection. The <tt>PXFilter</tt> data view always creates a single data record and never retrieves this data record or saves it to the database. The <tt>PXFilter</tt> data view is used to specify values used by the application logic or other data views and should never be stored anywhere except the current user session.{br}

The <tt>PXFilter</tt> data view always returns one record with the current values of the filtering parameters. The <tt>PXFilter</tt> data view works only with the UI and doesn&rsquo;t invoke any requests to the database. The data view object for the filtering parameters is defined in a graph, as the following code shows.<source lang="csharp">public class ProductInq : PXGraph&lt;ProductInq&gt;
{
    //ProductFilter is a special DAC for filtering parameters
    <b>public PXFilter&lt;ProductFilter&gt; Filter;<b>
    ...
}</source>
With the <tt>PXFilter</tt> type, you can use any data access class (DAC) that has the needed data fields. You usually define a specific DAC for the filtering parameters because the filtering parameters are taken from multiple DACs. Since the filter DAC isn&rsquo;t bound to any database table, you define only unbound data fields in the filter DAC. Because <tt>PXFilter</tt> data views are supposed to contain only one data record, you should not specify any key fields within a DAC that is used to store filtering parameters.[anchor|#_f5410c5f-7a6c-4e9d-ac12-05a26a98f109]((({S:Warn}Avoid using the <tt>PXFilter</tt> data view type with DACs that have at least one key field defined—that is, DACs that contain fields having the <tt>IsKey=true</tt> parameter in the type attribute.
)))
Filter data fields are usually displayed on a form. To immediately refresh data records as soon a user updates a filtering parameter, enable the callback for the input control that displays the filtering parameter on the form (see [HelpRoot_Dev_Platform\CW__how_Enable_Callback|To Enable Callback for a Control]).{br}

The <tt>PXFilter</tt> data view is specified in the <tt>PrimaryView</tt> property of the datasource control of the ASPX page where the filtering parameters are used, as shown in the following code example. {{{{&lt;px:PXDataSource ID="ds" ...
        <b>PrimaryView="Filter"<b> TypeName="RB.RapidByte.ProductInq"&gt;
}}}}
To clear the filtering parameters on the form, you define the {{Cancel}} action (which actually clears all data on the form) for the filter DAC; see the following code example.<source lang="csharp">public PXFilter&lt;ProductFilter&gt; Filter;
// Adds the form toolbar button that clears the filtering parameters
<b>public PXCancel&lt;ProductFilter&gt; Cancel;<b></source>[anchor|#section_m4n_2k5_3m]
==Selecting Data with a Filter==
To select data, you should specify filtering conditions in the <tt>Where</tt> clause of the data view type (see the following code). To pass current filter values to the query, you specify the filter DAC fields within the <tt>Current</tt> parameter. You have to define the data view that retrieves filtered records for the UI after the definition of <tt>PXFilter</tt>.<source lang="csharp">public class SupplierInq : PXGraph&lt;SupplierInq&gt;
{
    public PXCancel&lt;SupplierFilter&gt; Cancel;
    public PXFilter&lt;SupplierFilter&gt; Filter;

    // The data view must be defined after PXFilter&lt;FilterDAC&gt; 
    // because Current&lt;FilterDAC.Field&gt; is used. 
    [PXFilterable]
    <b>public PXSelectReadonly2&lt;SupplierProduct,
        InnerJoin&lt;Supplier, On&lt;Supplier.supplierID,
                               Equal&lt;SupplierProduct.supplierID&gt;&gt;&gt;,
        Where2&lt;Where&lt;Current&lt;SupplierFilter.countryCD&gt;, IsNull,
            Or&lt;Supplier.countryCD,
                Equal&lt;Current&lt;SupplierFilter.countryCD&gt;&gt;&gt;&gt;,
        And&lt;Where&lt;Current&lt;SupplierFilter.minOrderQty&gt;, IsNull,
            Or&lt;SupplierProduct.minOrderQty,
                GreaterEqual&lt;Current&lt;SupplierFilter.minOrderQty&gt;&gt;&gt;&gt;&gt;&gt;,
        OrderBy&lt;Asc&lt;SupplierProduct.productID,
            Asc&lt;SupplierProduct.supplierPrice,
            Desc&lt;SupplierProduct.lastPurchaseDate&gt;&gt;&gt;&gt;&gt; SupplierProducts;<b>
}</source>((({S:Warn}You can use a read-only type of the data view that retrieves filtered data records. For a read-only data view, the framework automatically disables the editing of rows in the grid.
)))]]></column>
			<column name="PlainText"><![CDATA[Data View for the Filtering Parameters The generic  PXFilter  type of data view is used to provide filtering         parameters on the form for user selection. The  PXFilter  data view always         creates a single data record and never retrieves this data record or saves it to the         database. The  PXFilter  data view is used to specify values used by the         application logic or other data views and should never be stored anywhere except the current         user session. The  PXFilter  data view always returns one record with the current values         of the filtering parameters. The  PXFilter  data view works only with the         UI and doesn't invoke any requests to the database. The data view object for the filtering         parameters is defined in a graph, as the following code shows. public class ProductInq : PXGraph<ProductInq>
{
    //ProductFilter is a special DAC for filtering parameters
     public PXFilter<ProductFilter> Filter; 
    ...
} With the  PXFilter  type, you can use any data access class (DAC) that has         the needed data fields. You usually define a specific DAC for the filtering parameters         because the filtering parameters are taken from multiple DACs. Since the filter DAC isn't         bound to any database table, you define only unbound data fields in the filter DAC. Because            PXFilter  data views are supposed to contain only one data record, you         should not specify any key fields within a DAC that is used to store filtering         parameters. Avoid using the  PXFilter  data view type with DACs that have at least one key field defined—that is, DACs that contain fields having the  IsKey=true  parameter in the type attribute. Filter data fields are usually displayed on a form. To immediately refresh data records as         soon a user updates a filtering parameter, enable the callback for the input control that         displays the filtering parameter on the form (see  To Enable Callback for a Control). The  PXFilter  data view is specified in the            PrimaryView  property of the datasource control of the ASPX page where         the filtering parameters are used, as shown in the following code example.  <px:PXDataSource ID="ds" ...
         PrimaryView="Filter"  TypeName="RB.RapidByte.ProductInq"> To clear the filtering parameters on the form, you define the  Cancel          action (which actually clears all data on the form) for the filter DAC; see the following         code example. public PXFilter<ProductFilter> Filter;
// Adds the form toolbar button that clears the filtering parameters
 public PXCancel<ProductFilter> Cancel; Selecting Data with a Filter To select data, you should specify filtering conditions in the  Where          clause of the data view type (see the following code). To pass current filter values to the         query, you specify the filter DAC fields within the  Current  parameter.         You have to define the data view that retrieves filtered records for the UI after the         definition of  PXFilter . public class SupplierInq : PXGraph<SupplierInq>
{
    public PXCancel<SupplierFilter> Cancel;
    public PXFilter<SupplierFilter> Filter;

    // The data view must be defined after PXFilter<FilterDAC> 
    // because Current<FilterDAC.Field> is used. 
    [PXFilterable]
     public PXSelectReadonly2<SupplierProduct,
        InnerJoin<Supplier, On<Supplier.supplierID,
                               Equal<SupplierProduct.supplierID>>>,
        Where2<Where<Current<SupplierFilter.countryCD>, IsNull,
            Or<Supplier.countryCD,
                Equal<Current<SupplierFilter.countryCD>>>>,
        And<Where<Current<SupplierFilter.minOrderQty>, IsNull,
            Or<SupplierProduct.minOrderQty,
                GreaterEqual<Current<SupplierFilter.minOrderQty>>>>>>,
        OrderBy<Asc<SupplierProduct.productID,
            Asc<SupplierProduct.supplierPrice,
            Desc<SupplierProduct.lastPurchaseDate>>>>> SupplierProducts; 
} You can use a read-only type of the data view that retrieves filtered data records. For         a read-only data view, the framework automatically disables the editing of rows in the         grid. ]]></column>
		</row>
		<row PageID="a007b57b-af69-4c0f-9fd1-f5d98351035f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ea4e39a7-5ab9-3a4d-34b1-1a9b53078bf6" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Processing forms have a similar appearance to that of inquiry forms. A processing form usually consists of the following components:[anchor|#ul_pts_b14_nm]
*The grid that displays the list of records retrieved by the specific processing data view. In the grid, you also provide the following components:
**A column with a check box, which gives users the ability to select one record or multiple records in the grid for processing. To add the check box, define the unbound {{Selected}} field in the main data access class (DAC) of the processing data view and add the column for this field to the grid.
**:((({S:Warn}{{Selected}} is the default name for this specific check box; you can define the data field with any name and override the default {{Selected}} name in the graph constructor with the <tt>SetSelected()</tt> method of the <tt>PXProcessing</tt> class.
)))
**Optionally, a redirection button or link that can be clicked to open the data entry form for the selected record. 
*A toolbar that includes the '''Process''', '''Process All''', and '''Cancel''' buttons.
*The form that provides selection criteria (for narrowing the records that are listed and may be processed) or configuration parameters (or both) for the processing method.
{br}{TOC}
==Processing Data View and Delegate==
To provide data for the grid, you have to define a processing data view of one of the following types:[anchor|#ul_hnj_c4q_4m]
*<tt>PXProcessing</tt>: Provides data records for processing without filtering. You can use the <tt>Where&lt;&gt;</tt> and <tt>OrderBy&lt;&gt;</tt> clauses in this data view type.
*<tt>PXProcessingJoin</tt>: Provides data records for processing without filtering. You can also use <tt>Join&lt;&gt;</tt> clauses in this data view type.
*<tt>PXFilteredProcessing</tt>: Provides data records for processing with filtering. This data type uses two DACs as type parameters, where the second DAC specifies the filter DAC. You can use the <tt>Where&lt;&gt;</tt> and <tt>OrderBy&lt;&gt;</tt> clauses in this data view type.
*<tt>PXFilteredProcessingJoin</tt>: Provides data records for processing with filtering. This data type uses two DACs as type parameters, where the second DAC specifies the filter DAC. You can also use <tt>Join&lt;&gt;</tt> clauses in this data view type.

Below is an example of the {{SalesOrders}} data view defined for the grid on the a processing form. <source lang="csharp">public class SalesOrderProcess : PXGraph&lt;SalesOrderProcess&gt;
{
    public PXProcessing&lt;SalesOrder&gt; SalesOrders;
}</source>
You can define only one processing data view in a graph. In the graph constructor, you have to define the processing method as the processing delegate for the data view, as the following code shows.<source lang="csharp">public SalesOrderProcess()
{
    SalesOrders.SetProcessDelegate&lt;SalesOrderEntry&gt;(
        delegate(SalesOrderEntry graph, SalesOrder order) 
        {
            graph.Clear();
            graph.ApproveOrder(order, true);
        });
}</source>
Based on the definition of the processing data view, Acumatica Framework automatically adds the '''Process''', and '''Process All''' buttons to the form toolbar. These buttons invoke the processing method specified as the processing delegate for the data view. To add the '''Cancel''' button to the toolbar, you have to define the <tt>PXCancel</tt> action with the needed DAC (see the following code). The '''Cancel''' button completely refreshes the data on the form.<source lang="csharp">// Definition of the Cancel action for filtered processing
public class ReorderProcess : PXGraph&lt;ReorderProcess&gt;
{
    public PXFilter&lt;ProductFilter&gt; Filter;
    // Main DAC of the filter data view
    public PXCancel&lt;<b>ProductFilter<b>&gt; Cancel;
    
    // Filter records in the processing data view
    public PXFilteredProcessingJoin&lt;ProductReorder, ProductFilter, LeftJoin&lt;...&gt;&gt; Records;
}

// Definition of the Cancel button for processing without filtering
public class SalesOrderProcess : PXGraph&lt;SalesOrderProcess&gt;
{
    public PXProcessing&lt;SalesOrder&gt; SalesOrders;
    // Main DAC of the processing data view
    public PXCancel&lt;<b>SalesOrder<b>&gt; Cancel;
}</source>
==Filter on the Processing Form==
To add the filter to the form, you have to define a <tt>PXFilter</tt> data view and set this data view in the <tt>PrimaryView</tt> property of the datasource control on the ASPX page. In the processing data view that provides records for the grid, you have to use the <tt>PXFilteredProcessing</tt> or <tt>PXFilteredProcessingJoin</tt> type and specify the filter DAC in the second type parameter. In the following code example, the {{Filter}} data view provides the {{Discrepancy}} and {{ActiveProducts}} filtering parameters, which are used in the {{Records}} data view. The {{Records}} data view retrieves the list of deficient products that match the filter.{{{{// The filter data view
public PXFilter&lt;ProductFilter&gt; Filter;
    
// Filter records in the processing data view
// Retrieve products of only the specified category (if any)
public PXFilteredProcessingJoin&lt;ProductReorder, ProductReorderFilter,
    LeftJoin&lt;SupplierProduct,
        On&lt;SupplierProduct.productID, Equal&lt;ProductReorder.productID&gt;,
            And&lt;SupplierProduct.supplierID,
                Equal&lt;ProductReorder.supplierID&gt;&gt;&gt;&gt;,
    Where&lt;ProductReorder.discrepancy, Greater&lt;decimal_0&gt;,
        <b>And&lt;ProductReorder.discrepancy,
            GreaterEqual&lt;Current&lt;ProductReorderFilter.discrepancy&gt;&gt;,
        And&lt;Where&lt;Current&lt;ProductReorderFilter.activeProducts&gt;,
                NotEqual&lt;True&gt;,
            Or&lt;ProductReorder.active,
                Equal&lt;Current&lt;ProductReorderFilter.activeProducts&gt;&gt;&gt;&gt;&gt;<b>&gt;&gt;,
    OrderBy&lt;Desc&lt;ProductReorder.discrepancy&gt;&gt;&gt; Records;
}}}}
For a filtered processing form, you can specify a processing method as the processing delegate for the data view in the <tt>RowSelected</tt> event handler for the DAC used in the <tt>PXFilter</tt> data view. This approach can be used to pass the selected filter parameters to the processing method. {br}

If a processing form contains a form area with a control to select a method to process the details, the usage of the <tt>RowSelected</tt> event handler for the main DAC of the primary view is the only way to specify the selected method as the processing delegate in the code.]]></column>
			<column name="PlainText"><![CDATA[Creation of Processing Forms Processing forms have a similar appearance to that of inquiry forms. A processing form         usually consists of the following components: The grid that displays the list of records retrieved by the specific processing data           view. In the grid, you also provide the following components: A column with a check box, which gives users the ability to select one record or               multiple records in the grid for processing. To add the check box, define the unbound                  Selected  field in the main data access class (DAC) of the               processing data view and add the column for this field to the grid. Selected  is the default name for this specific check box; you can                 define the data field with any name and override the default                    Selected  name in the graph constructor with the                    SetSelected()  method of the  PXProcessing                  class. Optionally, a redirection button or link that can be clicked to open the data entry               form for the selected record.  A toolbar that includes the  Process ,  Process             All , and  Cancel  buttons. The form that provides selection criteria (for narrowing the records that are listed and           may be processed) or configuration parameters (or both) for the processing method. Processing Data View and Delegate To provide data for the grid, you have to define a processing data view of one of the         following types: PXProcessing : Provides data records for processing without filtering.           You can use the  Where<>  and  OrderBy<>  clauses           in this data view type. PXProcessingJoin : Provides data records for processing without           filtering. You can also use  Join<>  clauses in this data view           type. PXFilteredProcessing : Provides data records for processing with           filtering. This data type uses two DACs as type parameters, where the second DAC specifies           the filter DAC. You can use the  Where<>  and              OrderBy<>  clauses in this data view type. PXFilteredProcessingJoin : Provides data records for processing with           filtering. This data type uses two DACs as type parameters, where the second DAC specifies           the filter DAC. You can also use  Join<>  clauses in this data view           type. Below is an example of the  SalesOrders  data view defined for the grid on         the a processing form.  public class SalesOrderProcess : PXGraph<SalesOrderProcess>
{
    public PXProcessing<SalesOrder> SalesOrders;
} You can define only one processing data view in a graph. In the graph constructor, you have         to define the processing method as the processing delegate for the data view, as the         following code shows. public SalesOrderProcess()
{
    SalesOrders.SetProcessDelegate<SalesOrderEntry>(
        delegate(SalesOrderEntry graph, SalesOrder order) 
        {
            graph.Clear();
            graph.ApproveOrder(order, true);
        });
} Based on the definition of the processing data view,  Acumatica Framework         automatically adds the  Process , and  Process           All  buttons to the form toolbar. These buttons invoke the processing method         specified as the processing delegate for the data view. To add the            Cancel  button to the toolbar, you have to define the            PXCancel  action with the needed DAC (see the following code). The            Cancel  button completely refreshes the data on the form. // Definition of the Cancel action for filtered processing
public class ReorderProcess : PXGraph<ReorderProcess>
{
    public PXFilter<ProductFilter> Filter;
    // Main DAC of the filter data view
    public PXCancel< ProductFilter > Cancel;
    
    // Filter records in the processing data view
    public PXFilteredProcessingJoin<ProductReorder, ProductFilter, LeftJoin<...>> Records;
}

// Definition of the Cancel button for processing without filtering
public class SalesOrderProcess : PXGraph<SalesOrderProcess>
{
    public PXProcessing<SalesOrder> SalesOrders;
    // Main DAC of the processing data view
    public PXCancel< SalesOrder > Cancel;
} Filter on the Processing Form To add the filter to the form, you have to define a  PXFilter  data view         and set this data view in the  PrimaryView  property of the datasource         control on the ASPX page. In the processing data view that provides records for the grid,         you have to use the  PXFilteredProcessing  or            PXFilteredProcessingJoin  type and specify the filter DAC in the second         type parameter. In the following code example, the  Filter  data view         provides the  Discrepancy  and  ActiveProducts  filtering         parameters, which are used in the  Records  data view. The            Records  data view retrieves the list of deficient products that match the         filter. // The filter data view
public PXFilter<ProductFilter> Filter;
    
// Filter records in the processing data view
// Retrieve products of only the specified category (if any)
public PXFilteredProcessingJoin<ProductReorder, ProductReorderFilter,
    LeftJoin<SupplierProduct,
        On<SupplierProduct.productID, Equal<ProductReorder.productID>,
            And<SupplierProduct.supplierID,
                Equal<ProductReorder.supplierID>>>>,
    Where<ProductReorder.discrepancy, Greater<decimal_0>,
         And<ProductReorder.discrepancy,
            GreaterEqual<Current<ProductReorderFilter.discrepancy>>,
        And<Where<Current<ProductReorderFilter.activeProducts>,
                NotEqual<True>,
            Or<ProductReorder.active,
                Equal<Current<ProductReorderFilter.activeProducts>>>>> >>,
    OrderBy<Desc<ProductReorder.discrepancy>>> Records; For a filtered processing form, you can specify a processing method as the processing         delegate for the data view in the  RowSelected  event handler for the DAC         used in the  PXFilter  data view. This approach can be used to pass the         selected filter parameters to the processing method.  If a processing form contains a form area with a control to select a method to process the         details, the usage of the  RowSelected  event handler for the main DAC of         the primary view is the only way to specify the selected method as the processing delegate         in the code. ]]></column>
		</row>
		<row PageID="731abdaa-c97b-4d00-ba94-54840e4d173f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="6ef826bc-6f2e-5a6b-73b8-fd07d3bd7ed4" RecordSourceID="22377">
			<column name="Content"><![CDATA[
A processing operation is implemented as a method that is invoked from a processing or data entry form. On a processing form, you specify the method that is invoked when a user clicks '''Process''' or '''Process All''' on the toolbar. On the data entry form, you define a button that invokes the processing method on a separate thread.[anchor|#_07a7ab0d-8575-48e5-9af6-b52fc5e18c1b]{br}

You can define a processing method in either of the following ways:[anchor|#_b6228be9-4a7a-474d-a064-c1ac560a97e5]
*Define a non-static method that uses a single record as the input parameter. This way can be used to process a single record independently from other records of the same class.
*Define a static method that uses a list of records as the input parameter. This way can be used to process a list of records. In this method, you can reorder the records in the list before processing, as well as check dependencies between records during processing.

These ways are described in more detail in the sections that follow.((({S:Warn}You don&rsquo;t need to create a dedicated processing form for each processing operation; whether to create a processing form depends on the requirements to the application.
))){br}{TOC}[anchor|#section_whb_fbq_4m]
==Using a Non-Static Processing Method==
In a simple case, to process a single record, you can define a non-static processing method in the data entry graph, as the following code shows.{{{{// The data entry graph
public class SalesOrderEntry : PXGraph&lt;SalesOrderEntry, SalesOrder&gt;
{
    ...
    // A non-static processing method that works with a single record
     <b>public void ApproveOrder(SalesOrder order, bool isMassProcess = false)
     {<b>
         // Process the record here
    <b>}<b>
}
}}}}
To make the system invoke the method on a separate thread, you can use the <tt>PXLongOperation.StartOperation()</tt> method. Within the method that you pass to <tt>StartOperation()</tt>, you have to create a new instance of the graph and invoke the processing method on that instance, as the following code shows.<source lang="csharp">public PXAction&lt;SalesOrder&gt; Approve;
[PXProcessButton]
[PXUIField(DisplayName = "Approve")]
protected virtual IEnumerable approve(PXAdapter adapter)
{
    Actions.PressSave();
    SalesOrder order = Orders.Current;
    <b>PXLongOperation.StartOperation(this, delegate()
    {
        SalesOrderEntry graph = PXGraph.CreateInstance&lt;SalesOrderEntry&gt;();
        graph.ApproveOrder(order);
    });<b>
    return adapter.Get();
}</source>((({S:Warn}Use the <tt>PXGraph.CreateInstance&lt;T&gt;()</tt> method to instantiate a graph from code. Do not use the graph constructor {{new T()}}.
)))
The method passed into <tt>PXLongOperation.StartOperation()</tt> matches the following delegate type, which uses no input parameters.{{{{delegate void PXToggleAsyncDelegate();
}}}}((({S:Warn}The anonymous method definition ({{delegate()}}) is used to shorten the code in the example.
)))
To invoke the non-static method on a processing form, in the graph constructor, set the method as the processing delegate for the data view by using the generic <tt>SetProcessDelegate&lt;Graph&gt;()</tt> method as shown in the following code.{{{{public class SalesOrderProcess : PXGraph&lt;SalesOrderProcess&gt;
{
    public PXProcessing&lt;SalesOrder&gt; SalesOrders;
    ...
        public SalesOrderProcess()
        {
            // Set the processing delegate for a data view of 
            // the PXProcessing or derived type
            <b>SalesOrders.SetProcessDelegate&lt;SalesOrderEntry&gt;(
                delegate(SalesOrderEntry graph, SalesOrder order) 
            {
                graph.Clear();
                graph.ApproveOrder(order, true);
            });<b>
        }
    }

}}}}
In the <tt>SetProcessDelegate&lt;Graph&gt;()</tt> method, the processing method matches the following delegate type.<source lang="csharp">delegate void ProcessItemDelegate&lt;Graph&gt;(Graph graph, Table item)</source>
According to the {{ProcessItemDelegate}} type, you can use the specified graph and item objects within the processing method. When the processing of records is initiated, Acumatica Framework creates a graph instance of the specified type and invokes the delegate for each data record that should be processed. A single graph instance is used for the processing of all records. Therefore, you have to clear the graph state by calling the <tt>Clear()</tt> method before the invocation of the processing method within the delegate, as shown in the code example earlier in this section.[anchor|#section_lzh_wbq_4m]
==Using a Static Processing Method==
In a general case, to process a list of records that may depend on one another, you have to define the static processing method, as the following code shows. {{{{// The processing graph
public class ReorderProcess : PXGraph&lt;ReorderProcess&gt;
{
    ...
    // Static processing method that works with a list of records
    <b>public static void Process(List&lt;ProductReorder&gt; products)
    {
        // Process the records here
    }<b>
}

// The data entry graph
public class SalesOrderEntry : PXGraph&lt;SalesOrderEntry, SalesOrder&gt;
{
    ...
    // Static processing method that works with a list of records
    <b>public static void ReleaseDocs(List&lt;SalesOrder&gt; orders)
    {
        <b>// Process the records here<b>
    }<b>
}
}}}}
You can invoke the static processing method in the data entry graph, within the method passed in the <tt>PXLongOperation.StartOperation()</tt> method, as shown in the following code example.<source lang="csharp">public PXAction&lt;SalesOrder&gt; Release;
[PXProcessButton]
[PXUIField(DisplayName = "Release")]
protected virtual IEnumerable release(PXAdapter adapter)
{
    Actions.PressSave();
    SalesOrder order = Orders.Current;
    List&lt;SalesOrder&gt; list = new List&lt;SalesOrder&gt;();
    list.Add(order);
   <b> PXLongOperation.StartOperation(this, delegate()
    {
        SalesOrderEntry.ReleaseDocs(list);
    });<b>
    return list;
}</source>
The <tt>PXLongOperation.StartOperation()</tt> method creates a separate thread and executes the specified delegate asynchronously on this thread.{br}

To invoke the static method from a processing form, in the graph constructor, set the method as the processing delegate for the data view by using the <tt>SetProcessDelegate()</tt> method, as shown in the code that follows.{{{{public class ReorderProcess : PXGraph&lt;ReorderProcess&gt;
{
    public PXFilteredProcessingJoin&lt;ProductReorder,
                                    ProductFilter, LeftJoin&lt;...&gt;&gt; Records;

    public ReorderProcess()
    {
        <b>Records.SetProcessDelegate(Process);<b>
    }
}
}}}}
In the <tt>SetProcessDelegate()</tt> method, the processing method matches the following delegate type.<source lang="csharp">delegate void ProcessListDelegate(List&lt;Table&gt; list);</source>
Based on the delegate type, you can operate with the list of processed records of the specified <tt>List&lt;Table&gt;</tt> type.{br}

When you use a static processing method, you have to manually create a new graph object once and reuse it throughout the whole static method (see the code below).{{{{public class ReorderProcess : PXGraph&lt;ReorderProcess&gt;
{
    ...
    public static void ReorderProducts(List&lt;ProductReorder&gt; products)
    {
        // Create a new graph object only once
        ReceiptEntry graph = PXGraph.CreateInstance&lt;ReceiptEntry&gt;();
        // Reordered list
        List&lt;ProductReorder&gt; productsToProceed = 
            products.OrderBy(item =&gt; item.SupplierID).ToList();
        // Process records
        foreach (ProductReorder product in productsToProceed)
        {
            graph.Receipts.Insert(doc);
            // Save changes within the created graph object
            graph.Actions.PressSave();
            // Clear the created graph state and reuse the object
            graph.Clear();
        }
    }
}
}}}}((({S:Warn}Use the <tt>PXGraph.CreateInstance&lt;T&gt;()</tt> method to instantiate graphs from code. Do not use the graph constructor {{new T()}}.
)))[anchor|#section_xsh_tdq_4m]
==Displaying Messages and Processing Errors==
To display a message in the UI from a processing method, use the following static methods of the <tt>PXProcessing</tt> class: [anchor|#ul_zzg_b2q_4m]
*<tt>SetInfo()</tt>: Displays a green check mark for the processed row in the grid, which denotes the successful processing of the record.
*<tt>SetWarning()</tt>: Displays an exclamation mark for the processed row in the grid. 
*<tt>SetError()</tt>: Displays a red X for the processed row in the grid, which denotes an error that has occurred during processing.

In each of these methods, you have to specify the initial object index in the list passed to the processing method. You can also specify the message text that appears for the row.((({S:Warn}The same rules are applicable to the processing of errors within the delegate you pass to <tt>PXLongOperation.StartOperation(...)</tt>.
)))
In the following example, you show the green check mark or the X icon that represents an error in the UI for each processed data record and return the error to the UI if processing of at least one record fails. (The code below attempts to process all records from the list.)<source lang="csharp">public static void Process(List&lt;ProductReorder&gt; products)
{
    ReceiptEntry graph = PXGraph.CreateInstance&lt;ReceiptEntry&gt;();
    bool erroroccurred = false;
    // Reordered list
    List&lt;ProductReorder&gt; productsToProceed =
    products.OrderBy(item =&gt; item.SupplierID).ToList();
    ...
    // Process records
    foreach (ProductReorder rec in productsToProceed)
    {
         try
         {
             // Set the green check mark for the item by the initial index in
             // the <b>products<b> list, not in productsToProceed
             <b>PXProcessing&lt;ProductReorder&gt;.SetInfo(
                 products.IndexOf(rec),
                 String.Format("The receipt {0} has been created",
                               doc.DocNbr));<b>
         }
         catch (Exception e)
         {
             // Set the error flag
             <b>erroroccurred = true;<b>
             // Set the error for the item by the initial index in
             // the <b>products<b> list, not in productsToProceed
             <b>PXProcessing&lt;ProductReorder&gt;.SetError(
                 products.IndexOf(rec), "A receipt cannot be created");<b>
             ...
         }
    }
    // Throw the error if at least one record hasn't been processed
    if (erroroccurred)
        throw new PXException("At least one product hasn't been processed.");
}</source>To display the error as a result of processing all records, you have to throw the error at the end of a processing method.]]></column>
			<column name="PlainText"><![CDATA[Implementation of Processing Operations A processing operation is implemented as a method that is invoked from a processing                 or data entry form. On a processing form, you specify the method that is invoked                 when a user clicks  Process  or  Process                     All  on the toolbar. On the data entry form, you define a button that                 invokes the processing method on a separate thread. You can define a processing method in either of the             following ways: Define a non-static method that uses a single record as the input parameter.                     This way can be used to process a single record independently from other records                     of the same class. Define a static method that uses a list of records as the input parameter. This                     way can be used to process a list of records. In this method, you can reorder                     the records in the list before processing, as well as check dependencies between                     records during processing. These ways are described in more detail in the sections that                 follow. You don't need to create a dedicated processing form for each processing                 operation; whether to create a processing form depends on the requirements to the                 application. Using a Non-Static Processing Method In a simple case, to process a single record, you can define a non-static processing method                 in the data entry graph, as the following code shows. // The data entry graph
public class SalesOrderEntry : PXGraph<SalesOrderEntry, SalesOrder>
{
    ...
    // A non-static processing method that works with a single record
      public void ApproveOrder(SalesOrder order, bool isMassProcess = false)
     { 
         // Process the record here
     } 
} To make the system invoke the method on a separate thread, you can use the                      PXLongOperation.StartOperation()  method. Within the method                 that you pass to  StartOperation() , you have to create a new                 instance of the graph and invoke the processing method on that instance, as the                 following code shows. public PXAction<SalesOrder> Approve;
[PXProcessButton]
[PXUIField(DisplayName = "Approve")]
protected virtual IEnumerable approve(PXAdapter adapter)
{
    Actions.PressSave();
    SalesOrder order = Orders.Current;
     PXLongOperation.StartOperation(this, delegate()
    {
        SalesOrderEntry graph = PXGraph.CreateInstance<SalesOrderEntry>();
        graph.ApproveOrder(order);
    }); 
    return adapter.Get();
} Use the  PXGraph.CreateInstance<T>()  method to instantiate a graph                 from code. Do not use the graph constructor  new T() . The method passed into  PXLongOperation.StartOperation()  matches the                 following delegate type, which uses no input parameters. delegate void PXToggleAsyncDelegate(); The anonymous method definition ( delegate() ) is used to shorten the         code in the example. To invoke the non-static method on a processing form, in the graph constructor, set the                 method as the processing delegate for the data view by using the generic                      SetProcessDelegate<Graph>()  method as shown in the                 following code. public class SalesOrderProcess : PXGraph<SalesOrderProcess>
{
    public PXProcessing<SalesOrder> SalesOrders;
    ...
        public SalesOrderProcess()
        {
            // Set the processing delegate for a data view of 
            // the PXProcessing or derived type
             SalesOrders.SetProcessDelegate<SalesOrderEntry>(
                delegate(SalesOrderEntry graph, SalesOrder order) 
            {
                graph.Clear();
                graph.ApproveOrder(order, true);
            }); 
        }
    }
 In the  SetProcessDelegate<Graph>()  method, the processing method         matches the following delegate type. delegate void ProcessItemDelegate<Graph>(Graph graph, Table item) According to the  ProcessItemDelegate  type, you can use the specified graph                 and item objects within the processing method. When the processing of records is                 initiated,  Acumatica Framework creates a graph instance of the specified type and invokes the delegate for each                 data record that should be processed. A single graph instance is used for the                 processing of all records. Therefore, you have to clear the graph state by calling                 the  Clear()  method before the invocation of the processing method                 within the delegate, as shown in the code example earlier in this section. Using a Static Processing Method In a general case, to process a list of records that may depend on one another, you have to                 define the static processing method, as the following code shows.  // The processing graph
public class ReorderProcess : PXGraph<ReorderProcess>
{
    ...
    // Static processing method that works with a list of records
     public static void Process(List<ProductReorder> products)
    {
        // Process the records here
    } 
}

// The data entry graph
public class SalesOrderEntry : PXGraph<SalesOrderEntry, SalesOrder>
{
    ...
    // Static processing method that works with a list of records
     public static void ReleaseDocs(List<SalesOrder> orders)
    {
         // Process the records here 
    } 
} You can invoke the static processing method in the data entry graph, within the method                 passed in the  PXLongOperation.StartOperation()  method, as shown                 in the following code example. public PXAction<SalesOrder> Release;
[PXProcessButton]
[PXUIField(DisplayName = "Release")]
protected virtual IEnumerable release(PXAdapter adapter)
{
    Actions.PressSave();
    SalesOrder order = Orders.Current;
    List<SalesOrder> list = new List<SalesOrder>();
    list.Add(order);
     PXLongOperation.StartOperation(this, delegate()
    {
        SalesOrderEntry.ReleaseDocs(list);
    }); 
    return list;
} The  PXLongOperation.StartOperation()  method creates a separate                 thread and executes the specified delegate asynchronously on this thread. To invoke the static method from a processing form, in the graph constructor, set the                 method as the processing delegate for the data view by using the                      SetProcessDelegate()  method, as shown in the code that                 follows. public class ReorderProcess : PXGraph<ReorderProcess>
{
    public PXFilteredProcessingJoin<ProductReorder,
                                    ProductFilter, LeftJoin<...>> Records;

    public ReorderProcess()
    {
         Records.SetProcessDelegate(Process); 
    }
} In the  SetProcessDelegate()  method, the processing method matches the         following delegate type. delegate void ProcessListDelegate(List<Table> list); Based on the delegate type, you can operate with the list of processed records of the                 specified  List<Table>  type. When you use a static processing method, you have to manually create a new graph object         once and reuse it throughout the whole static method (see the code below). public class ReorderProcess : PXGraph<ReorderProcess>
{
    ...
    public static void ReorderProducts(List<ProductReorder> products)
    {
        // Create a new graph object only once
        ReceiptEntry graph = PXGraph.CreateInstance<ReceiptEntry>();
        // Reordered list
        List<ProductReorder> productsToProceed = 
            products.OrderBy(item => item.SupplierID).ToList();
        // Process records
        foreach (ProductReorder product in productsToProceed)
        {
            graph.Receipts.Insert(doc);
            // Save changes within the created graph object
            graph.Actions.PressSave();
            // Clear the created graph state and reuse the object
            graph.Clear();
        }
    }
} Use the  PXGraph.CreateInstance<T>()  method to instantiate graphs         from code. Do not use the graph constructor  new T() . Displaying Messages and Processing Errors To                 display a message in the UI from a processing method, use the following static                 methods of the  PXProcessing  class:  SetInfo() : Displays a green check mark for the processed row                     in the grid, which denotes the successful processing of the record. SetWarning() : Displays an exclamation mark for the processed                     row in the grid.  SetError() : Displays a red X for the processed row in the                     grid, which denotes an error that has occurred during processing. In each of these methods, you have to specify the initial object index in the                 list passed to the processing method. You can also specify the message text that                 appears for the row. The same rules are applicable to the processing of                 errors within the delegate you pass to                      PXLongOperation.StartOperation(...) . In the                 following example, you show the green check mark or the X icon that represents an                 error in the UI for each processed data record and return the error to the UI if                 processing of at least one record fails. (The code below attempts to process all                 records from the             list.) public static void Process(List<ProductReorder> products)
{
    ReceiptEntry graph = PXGraph.CreateInstance<ReceiptEntry>();
    bool erroroccurred = false;
    // Reordered list
    List<ProductReorder> productsToProceed =
    products.OrderBy(item => item.SupplierID).ToList();
    ...
    // Process records
    foreach (ProductReorder rec in productsToProceed)
    {
         try
         {
             // Set the green check mark for the item by the initial index in
             // the  products  list, not in productsToProceed
              PXProcessing<ProductReorder>.SetInfo(
                 products.IndexOf(rec),
                 String.Format("The receipt {0} has been created",
                               doc.DocNbr)); 
         }
         catch (Exception e)
         {
             // Set the error flag
              erroroccurred = true; 
             // Set the error for the item by the initial index in
             // the  products  list, not in productsToProceed
              PXProcessing<ProductReorder>.SetError(
                 products.IndexOf(rec), "A receipt cannot be created"); 
             ...
         }
    }
    // Throw the error if at least one record hasn't been processed
    if (erroroccurred)
        throw new PXException("At least one product hasn't been processed.");
} To             display the error as a result of processing all records, you have to throw the error at             the end of a processing method. ]]></column>
		</row>
		<row PageID="5561c9af-8f01-43ef-a320-56226b17d9f1" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="1b623a5e-88f8-fb91-a873-d32ea8506e0a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When a user starts a processing operation on a processing form, such as the [HelpRoot_FormReference\AR_50_10_00|Release AR Documents] ([~/?ScreenId=AR501000|AR501000]) form of Acumatica ERP, the '''Processing''' dialog box opens, which displays the status of the processing. When a processing operation is started, all elements of the processing form become unavailable. If you need to make a button from the processing form available during processing, you have to add this button to the processing dialog box, as described in this topic. 
==To Add a Button to the Processing Dialog Box==
To add a button to the processing dialog box, you can use one of the following approaches:[anchor|#_cd1c8262-e790-4132-a183-50626ddd46b2]
*For the action that corresponds to the button, in the graph, set the value of the <tt>VisibleOnProcessingResults</tt> property of <tt>PXButtonAttribute</tt> or its descendant to {{true}}, as shown in the following code example.<source lang="csharp">[PXUIField(DisplayName = Messages.ShowDocuments)]
[PXButton(VisibleOnProcessingResults = true)]
public virtual IEnumerable showDocuments(PXAdapter adapter)
{
    ShowOpenDocuments(SelectedItems);
    return adapter.Get();
}</source>
*In the ASPX file that corresponds to the form, set the value of the <tt>VisibleOnProcessingResults</tt> property of <tt>PXDSCallbackCommand</tt> to {{True}}, as shown in the following example.{{{{&lt;px:PXDataSource ID = "ds" Width="100%" 
    runat="server" Visible="True" PrimaryView="Filter" 
    TypeName="PX.Objects.FA.FAClosingProcess" &gt;
        &lt;CallbackCommands&gt;
            &lt;px:PXDSCallbackCommand Name = "showDocuments" 
                VisibleOnProcessingResults="True"/&gt;
        &lt;/CallbackCommands&gt; 
&lt;/px:PXDataSource&gt;
}}}}
]]></column>
			<column name="PlainText"><![CDATA[To Add a Button to the Processing Dialog Box When a user starts a processing operation on a processing form, such as the   ([~/?ScreenId=AR501000|AR501000]) Release AR Documents (AR501000) form of  Acumatica ERP, the  Processing  dialog box opens, which displays the status of the         processing. When a processing operation is started, all elements of the processing form         become unavailable. If you need to make a button from the processing form available during         processing, you have to add this button to the processing dialog box, as described in this         topic.  To Add a Button to the Processing Dialog Box To add a button to the processing dialog box, you can use one of the following approaches: For the action that corresponds to the button, in the graph, set the value of the         VisibleOnProcessingResults  property of         PXButtonAttribute  or its descendant to  true , as shown in       the following code       example. [PXUIField(DisplayName = Messages.ShowDocuments)]
[PXButton(VisibleOnProcessingResults = true)]
public virtual IEnumerable showDocuments(PXAdapter adapter)
{
    ShowOpenDocuments(SelectedItems);
    return adapter.Get();
} In the ASPX file that corresponds to the form, set the value of the                VisibleOnProcessingResults  property of                PXDSCallbackCommand  to  True , as shown in the             following             example. <px:PXDataSource ID = "ds" Width="100%" 
    runat="server" Visible="True" PrimaryView="Filter" 
    TypeName="PX.Objects.FA.FAClosingProcess" >
        <CallbackCommands>
            <px:PXDSCallbackCommand Name = "showDocuments" 
                VisibleOnProcessingResults="True"/>
        </CallbackCommands> 
</px:PXDataSource> ]]></column>
		</row>
		<row PageID="5cf3c709-9640-4637-8827-e49830c33960" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f0049deb-6f44-a68b-788b-3146b4b222f9" RecordSourceID="22377">
			<column name="Content"><![CDATA[When a user starts a processing operation on a processing form, such as the [HelpRoot_FormReference\AR_50_10_00|Release AR Documents] ([~/?ScreenId=AR501000|AR501000]) form of Acumatica ERP, the '''Processing''' dialog box opens, which displays the status of the processing. You can turn off the displaying of the processing dialog box and instead display the progress and the result of the processing on the form toolbar.
==To Turn Off the Displaying of the Processing Dialog Box==
To not display the processing dialog box on a processing form, you can do one of the following:[anchor|#_5c6b21de-ed7b-4bb5-8e1a-fe5a5370f71c]
*To not display the processing dialog box for a custom form, override the <tt>IsProcessing</tt> property of the graph that corresponds to the form, as shown in the following code.<source lang="csharp">public override bool IsProcessing
{
    get { return false; }
    set { }
}</source>
*To not display the processing dialog box for a customized Acumatica ERP form, configure the <tt>IsProcessing</tt> property of the graph that corresponds to the form in a graph extension as shown in the following code.<source lang="csharp">public class AllocationProcess_Extension : PXGraphExtension&lt;AllocationProcess&gt;  
{
    public override void Initialize()
    {
        Base.IsProcessing = false;
    }
}</source>
*To not display the processing dialog box for all processing forms, add the <tt>ProcessingProgressDialog</tt> key in the {{appSettings}} section of the <tt>web.config</tt> file of the application set to {{False}}, as shown in the following example.{{{{&lt;add key="ProcessingProgressDialog" value="false" /&gt;
}}}}
]]></column>
			<column name="PlainText"><![CDATA[To Not Display the Processing Dialog Box When a user starts a processing operation on a processing form, such as the   ([~/?ScreenId=AR501000|AR501000]) Release AR Documents (AR501000) form of  Acumatica ERP, the  Processing  dialog box opens, which displays the status of             the processing. You can turn off the displaying of the processing dialog box and instead             display the progress and the result of the processing on the form toolbar. To Turn Off the Displaying of the Processing Dialog Box To not display the processing dialog box on a processing form, you can do one of the                     following: To not display the processing dialog box for a custom form, override the                              IsProcessing  property of the graph that corresponds                         to the form, as shown in the following                         code. public override bool IsProcessing
{
    get { return false; }
    set { }
} To not display the processing dialog box for a customized  Acumatica ERP form, configure the  IsProcessing  property of the graph                         that corresponds to the form in a graph extension as shown in the following                         code. public class AllocationProcess_Extension : PXGraphExtension<AllocationProcess>  
{
    public override void Initialize()
    {
        Base.IsProcessing = false;
    }
} To not display the processing dialog box for all processing forms, add the                              ProcessingProgressDialog  key in the                              appSettings  section of the                              web.config  file of the application set to                              False , as shown in the following                         example. <add key="ProcessingProgressDialog" value="false" /> ]]></column>
		</row>
		<row PageID="64ebcd9f-54a8-4372-b4cf-62c39b824f8e" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can find information about how to process operations whose execution takes long time. You execute these operations asynchronously in separate threads.&#xA;==In This Chapter==[anchor|#_ffc0e297-3efc-459a-aebf-2e404648eb0a]&#xA;*[HelpRoot_Dev_Platform\BL__con_Asynchronous_Execution|Asynchronous Execution]&#xA;" PlainText="Executing Code Asynchronously In this chapter, you can find information about how to process operations whose execution     takes long time. You execute these operations asynchronously in separate threads. In This Chapter Asynchronous Execution" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="390f5b63-8e03-a656-dde7-398fa5179dd3" RecordSourceID="22377" />
		<row PageID="3e8c46fa-54a8-4f9c-9353-aa559c346215" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="0b65d616-0b6c-fc47-eb07-050f38e896a5" RecordSourceID="22377">
			<column name="Content"><![CDATA[
An instance of a graph is created on each round trip to process a request created by the user on the appropriate form. After the request is processed, the graph instance must be cleared from the memory of the Acumatica ERP server. If you implement code that might require a long time to execute an action or to process a document or data, you should execute this code asynchronously in a separate thread.{br}{TOC}
==Using the PXLongOperation Class==
To make the system invoke the method in a separate thread, you can use the <tt>PXLongOperation.StartOperation</tt> method. Within the method that you pass to <tt>StartOperation</tt>, you can, for example, create a new instance of a graph and invoke a processing method on that instance. The following code snippet demonstrates how you can execute code asynchronously as a long-running operation in a method of a graph.{{{{public class MyGraph : PXGraph
{
  ...
  public void MyMethod()
  {
    ...
    PXLongOperation.StartOperation(this, delegate()
    {
      // insert the delegate method code here
      ...
      GraphName graph = PXGraph.CreateInstance&lt;GraphName&gt;();
      foreach (... in ...)
      {
        ...
      }
      ...
    });
  ...
  }
  ...
}
}}}}{br}

If you need to start a long-running operation in a method of a graph extension, you have to use the <tt>Base</tt> property instead of the <tt>this</tt> keyword in the first parameter of the <tt>StartOperation</tt> method, as shown in the following code snippet.{{{{public class MyGraph_Extension : PXGraphExtension&lt;MyGraph&gt;
  ...
  public void MyMethod()
  {
    ...
    PXLongOperation.StartOperation(Base, delegate()
    {
      // insert the delegate method code here
      ...
    });
  ...
  }
  ...
}
}}}}
==Using the Custom Information Dictionary==
In the delegate method of a long-running operation, you can store a data object in the <tt>&#95;CustomInfo</tt> dictionary of the long-running operation and get the list of records processed by the method. You can add to the dictionary any data object needed for a long-running operation by using a <tt>SetCustomInfo</tt> method.{br}

The following diagram shows that each long-running operation includes the <tt>&#95;CustomInfo</tt> dictionary, which can contain multiple key-value pairs with custom data.[anchor|#_6646919c-d9a3-471f-88aa-65d831df0082][anchor|#_63005158-97b0-460c-901a-45e2648c3c77][image:StudioDeveloperGuide/Images/REF_PXLongOperation_CustomInfo.png|popup|Location of custom data in the memory of the Acumatica ERP server|450px]{br}

For a processing operation, the system stores the <tt>PXProcessingMessagesCollection&lt;TTable&gt;</tt> list of messages in the dictionary. Each message in the list is of the <tt>PXProcessingMessage</tt> type, which includes a string message and an error level that is of the <tt>PXErrorLevel</tt> type.{br}

See [http://asiablog.acumatica.com/2016/07/new-way-to-work-with-custominfo-of.html#more|New way to work with CustomInfo of PXLongOperation] at [http://asiablog.acumatica.com] for more information about the use of the dictionary.
==Executing a Processing Operation as a Long-Running Operation==
When a user clicks an action button on a form to start a processing operation, the data source control of the form generates a request to the Acumatica ERP server to execute the action delegate defined for the button. The server creates an instance of the graph, which provides the business logic for the form and invokes the action delegate method.{br}

Because a processing operation is a long-running operation, in the action delegate method, the data processing code must be included in the <tt>PXLongOperation.StartOperation</tt> method call as the definition of the long-running operation delegate. When the action delegate method is executed, the <tt>StartOperation</tt> method creates an instance of the <tt>PXAsyncResult</tt> class to hold the data and state of the long-running operation; the method also initiates the execution of the long-running operation delegate asynchronously in a separate thread.{br}

If the duration of the long-running operation is longer than five seconds, the server releases the graph instance. Then the form, which is still opened in the browser, generates requests to the server to get the results of the long-running operation every five seconds. For such a request, the server uses the ID of the long-running operatio to check the operation status. If the operation has completed, the server creates an instance of the graph and restores the graph state and the cache data to finish processing the action delegate and to return results to the form.{br}

The following diagram shows how the server executes an action asynchronously and how it returns the results of the action to the form.[anchor|#_6b32ed79-0f48-4ef0-a624-ab2f994050d5][anchor|#_7e2ff075-2b18-4ca5-950a-e18551ca6b92][image:StudioDeveloperGuide/Images/REF_PXLongOperation_Results.png|popup|Execution of an action that uses a long-running operation|450px][anchor|#_397e929e-f4b4-4441-9688-1e0a4ca7ab33]
==Processing a Report as a Long-Running Operation==
When the user launches a report, either from the report form or by clicking an action button on the maintenance or entry form, the system redirects the user to the report launcher form (<tt>ReportLauncher.aspx</tt>), which is designed to automatically run a report for the received parameters. The ASPX page for this form contains the <tt>PXReportViewer</tt> control, whose Java Scripts objects and functions are designed to get the report data and display the data on the form.{br}

To run the report, the report launcher creates a request to the <tt>PX.Web.UI.PXReportViewer</tt> control on the server. To process the request, the server instantiates the <tt>PX.Reports.Web.WebReport</tt> class and invokes its <tt>Render</tt> method, which launches the report generation as a long-running operation in a separate thread.{br}

The resulting report data is an object of the <tt>PX.Reports.Data.ReportNode</tt> type stored in the <tt>&#95;CustomInfo</tt> dictionary of the current long-running operation under the <tt>DEFAULT&#95;CUSTOM&#95;INFO&#95;KEY</tt> key. To provide quick access to the report data when the user views different pages of the report, the system saves the report data in the session as an object of the <tt>PX.Reports.Web.WebReport</tt> type.{br}

After the long-running operation has completed, the <tt>PXReportViewer</tt> control gets the report data from the dictionary and displays the report on the report launcher form. For details on how the report is displayed and how the report data is retrieved, see [HelpRoot_Dev_Platform\CC__con_Rendering_of_Reports|Display of Reports].{br}

The following diagram shows how the server generates a report asynchronously and how it returns the resulting report data to the report launcher form.[anchor|#_27127ed4-3313-4849-8806-c69600ec2263][anchor|#_8d521e0e-52bb-4bc6-b35b-e36cb0b66fbc][image:StudioDeveloperGuide/Images/REF_PXLongOperation_RunReport.png|popup|Execution of an action that launches the generation of a report |450px]
==Executing a Long-Running Operation in a Cluster==
If Acumatica ERP is configured to run in a cluster of application servers behind a load balancer, it is not possible to predict which application server will receive the next request from the client. In this model, session-specific data is serialized and stored in a high-performance remote server, such as Redis or MS SQL, to be shared between the application servers.{br}

When the user clicks an action button on a form to start a processing operation, the load balancer forwards the request to an Acumatica ERP server to execute the action delegate defined for the button. The server creates an instance of the graph, which provides the business logic for the form, and invokes the action delegate method.{br}

When the action delegate method is executed, the <tt>StartOperation</tt> method creates an instance of the <tt>PXAsyncResult</tt> class to hold the data and state of the long-running operation, initiates the execution of the long-running operation delegate asynchronously in a separate thread, and stores the serialized data of the operation in the remote storage.{br}

If the duration of the long-running operation is longer than five seconds, the server releases the graph instance, stores the serialized data of the graph in the remote storage, and continues processing the long-running operation in a separate thread. When the operation has completed, this server sets the operation status to {{PXLongRunStatus.Completed}} and updates the operation data in the remote session storage.{br}

Until the form that is still opened in the browsers obtains the request results, it generates requests to the site URL every five seconds to get these results. On every such request, the load balancer selects a server to be used to process the request and forwards the request to the server. The server uses the long-running operation ID, which is usually equal to the graph UID, to check the operation&rsquo;s status. If the operation is completed, the server creates an instance of the graph to finish processing the action delegate and to return results to the form.{br}

The following diagram shows how the data of a user session and of a long-running operation are stored in the remote session storage of a cluster.{br}

[anchor|#_e6f04f47-b8fe-47ce-913c-c62854638b4b][anchor|#_194f1e52-413b-428a-a858-d599ee16e33a][image:StudioDeveloperGuide/Images/REF_PXLongOperation_OnCluster.png|popup|Execution of an action that uses a long-running operation in a cluster|450px]]]></column>
			<column name="PlainText"><![CDATA[Asynchronous Execution An instance of a graph is created on each round trip to process a request created by the         user on the appropriate form. After the request is processed, the graph instance must be         cleared from the memory of the  Acumatica ERP server. If you implement code that might require a long time to execute an action or to         process a document or data, you should execute this code asynchronously in a separate         thread. Using the PXLongOperation Class To make the system invoke the method in a separate thread, you can use the       PXLongOperation.StartOperation  method. Within the method that you pass to       StartOperation , you can, for example, create a new instance of a graph and     invoke a processing method on that instance. The following code snippet demonstrates how you can     execute code asynchronously as a long-running operation in a method of a     graph. public class MyGraph : PXGraph
{
  ...
  public void MyMethod()
  {
    ...
    PXLongOperation.StartOperation(this, delegate()
    {
      // insert the delegate method code here
      ...
      GraphName graph = PXGraph.CreateInstance<GraphName>();
      foreach (... in ...)
      {
        ...
      }
      ...
    });
  ...
  }
  ...
} If you need to start a long-running operation in a method of a graph extension, you have to         use the  Base  property instead of the  this  keyword in         the first parameter of the  StartOperation  method, as shown in the         following code         snippet. public class MyGraph_Extension : PXGraphExtension<MyGraph>
  ...
  public void MyMethod()
  {
    ...
    PXLongOperation.StartOperation(Base, delegate()
    {
      // insert the delegate method code here
      ...
    });
  ...
  }
  ...
} Using the Custom Information Dictionary In the delegate method of a long-running operation, you can store a data object in the       _CustomInfo  dictionary of the long-running operation and get the list of     records processed by the method. You can add to the dictionary any data object needed for a     long-running operation by using a  SetCustomInfo  method. The following diagram shows that each long-running operation includes the       _CustomInfo  dictionary, which can contain multiple key-value pairs with     custom data. Location of custom data in the memory of the  Acumatica ERP       server For a processing operation, the system stores the            PXProcessingMessagesCollection<TTable>  list of messages in the         dictionary. Each message in the list is of the  PXProcessingMessage  type,         which includes a string message and an error level that is of the            PXErrorLevel  type. See  New way to work with CustomInfo of PXLongOperation New way to work with CustomInfo of PXLongOperation         at   for more         information about the use of the dictionary. Executing a Processing Operation as a Long-Running Operation When a user clicks an action button on a form to start a processing operation, the data source     control of the form generates a request to the  Acumatica ERP     server to execute the action delegate defined for the button. The server creates an instance of     the graph, which provides the business logic for the form and invokes the action delegate     method. Because a processing operation is a long-running operation, in the action delegate method, the         data processing code must be included in the            PXLongOperation.StartOperation  method call as the definition of the         long-running operation delegate. When the action delegate method is executed, the            StartOperation  method creates an instance of the            PXAsyncResult  class to hold the data and state of the long-running         operation; the method also initiates the execution of the long-running operation delegate         asynchronously in a separate thread. If the duration of the long-running operation is longer than five seconds, the server releases         the graph instance. Then the form, which is still opened in the browser, generates requests         to the server to get the results of the long-running operation every five seconds. For such         a request, the server uses the ID of the long-running operatio to check the operation         status. If the operation has completed, the server creates an instance of the graph and         restores the graph state and the cache data to finish processing the action delegate and to         return results to the form. The following diagram shows how the server executes an action asynchronously and how it         returns the results of the action to the form. Execution of an action that uses a long-running operation Processing a Report as a Long-Running Operation When the user launches a report, either from the report form or by clicking an action         button on the maintenance or entry form, the system redirects the user to the report         launcher form ( ReportLauncher.aspx ), which is designed to automatically         run a report for the received parameters. The ASPX page for this form contains the            PXReportViewer  control, whose Java Scripts objects and functions are         designed to get the report data and display the data on the form. To run the report, the report launcher creates a request to the            PX.Web.UI.PXReportViewer  control on the server. To process the request,         the server instantiates the  PX.Reports.Web.WebReport  class and invokes         its  Render  method, which launches the report generation as a long-running         operation in a separate thread. The resulting report data is an object of the  PX.Reports.Data.ReportNode          type stored in the  _CustomInfo  dictionary of the current long-running         operation under the  DEFAULT_CUSTOM_INFO_KEY  key. To provide quick access         to the report data when the user views different pages of the report, the system saves the         report data in the session as an object of the  PX.Reports.Web.WebReport          type. After the long-running operation has completed, the  PXReportViewer          control gets the report data from the dictionary and displays the report on the report         launcher form. For details on how the report is displayed and how the report data is         retrieved, see  Display of Reports. The following diagram shows how the server generates a report asynchronously and how it         returns the resulting report data to the report launcher form. Execution of an action that launches the generation of a report  Executing a Long-Running Operation in a Cluster If  Acumatica ERP     is configured to run in a cluster of application servers behind a load balancer, it is not     possible to predict which application server will receive the next request from the client. In     this model, session-specific data is serialized and stored in a high-performance remote server,     such as Redis or MS SQL, to be shared between the application servers. When the user clicks an action button on a form to start a processing operation, the load         balancer forwards the request to an  Acumatica ERP server to execute the action delegate defined for the button. The server creates an         instance of the graph, which provides the business logic for the form, and invokes the         action delegate method. When the action delegate method is executed, the  StartOperation  method         creates an instance of the  PXAsyncResult  class to hold the data and state         of the long-running operation, initiates the execution of the long-running operation         delegate asynchronously in a separate thread, and stores the serialized data of the         operation in the remote storage. If the duration of the long-running operation is longer than five seconds, the server releases         the graph instance, stores the serialized data of the graph in the remote storage, and         continues processing the long-running operation in a separate thread. When the operation has         completed, this server sets the operation status to            PXLongRunStatus.Completed  and updates the operation data in the remote         session storage. Until the form that is still opened in the browsers obtains the request results, it generates         requests to the site URL every five seconds to get these results. On every such request, the         load balancer selects a server to be used to process the request and forwards the request to         the server. The server uses the long-running operation ID, which is usually equal to the         graph UID, to check the operation's status. If the operation is completed, the server         creates an instance of the graph to finish processing the action delegate and to return         results to the form. The following diagram shows how the data of a user session and of a long-running operation are     stored in the remote session storage of a cluster. Execution of an action that uses a long-running operation in a cluster ]]></column>
		</row>
		<row PageID="06a993cf-56ad-4785-8dcd-b915ccf32354" Language="en-US" PageRevisionID="1" PlainText="Localizing Applications  Acumatica Framework provides built-in localization tools that you can use to translate the user interface and         application messages to different languages. This chapter provides guidelines on how to         prepare the  Acumatica Framework         application for localization efforts. To prepare an application for localization, you must             prepare data access classes (DACs) and the application code. In This Chapter LocalizationStrings That Can Be LocalizedTo Prepare DACs for LocalizationTo Localize Application MessagesTo Work with Multi-Language FieldsTo Optimize Memory Consumption of Localized Data ([~/?ScreenId=SM200540|SM200540]) " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="560a02bc-38b0-eadc-b21d-a429d92d6a28" RecordSourceID="22377">
			<column name="Content"><![CDATA[
 Acumatica Framework provides built-in localization tools that you can use to translate the user interface and application messages to different languages. This chapter provides guidelines on how to prepare the Acumatica Framework application for localization efforts.[anchor|#_faf91a2a-8360-4bd6-be44-1a6e36d7fe98]{br}

To prepare an application for localization, you must prepare data access classes (DACs) and the application code.
==In This Chapter==[anchor|#_18a2c5c8-aeae-493a-bc41-0c1e7d9e3667]
*[HelpRoot_Dev_Platform\BL__con_Localization|Localization]
*[HelpRoot_Dev_Platform\BL__con_Localizable_Strings|Strings That Can Be Localized]
*[HelpRoot_Dev_Platform\BL__how_Prepare_DAC_for_Localization|To Prepare DACs for Localization]
*[HelpRoot_Dev_Platform\BL__how_Prepare_Code_for_Localization|To Localize Application Messages]
*[HelpRoot_Dev_Platform\BL__how_Localize_Field_Values|To Work with Multi-Language Fields]
*[HelpRoot_Dev_Platform\BL__how_Optimize_Static_Cache|To Optimize Memory Consumption of Localized Data]

==Related Articles==
*[HelpRoot_FormReference\SM_20_05_40|Translation Dictionaries] ([~/?ScreenId=SM200540|SM200540])]]></column>
		</row>
		<row PageID="254a95ce-77fa-4399-9f56-14957aa49dd3" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="6314c598-d2ae-094b-22ce-ecd20fdae3c9" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Applications created with Acumatica Framework can be localized on the presentation, business logic, and database level owing to:[anchor|#_3768b503-aaba-4b27-915a-53d370631313]
*Standard Microsoft.NET localization mechanism is implemented for localizing the presentation layer.
*All messages returned from the business logic layer can be localized through the dictionary mechanism. For details about how to implement message localization in your code, see [HelpRoot_Dev_Platform\BL__how_Prepare_Code_for_Localization|To Localize Application Messages].
*The runtime environment of Acumatica Framework supports the Unicode standard to store and operate with data in a non-ANSI format.
*Information like addresses or product descriptions can be stored in special, language-specific, database fields and presented in the user selected language. For details on implementation of such fields, see [HelpRoot_Dev_Platform\BL__how_Localize_Field_Values|To Work with Multi-Language Fields].
[anchor|#_dc6c6888-adfd-4e9f-bd77-1ba1014d0cfb]
 Acumatica Framework provides a built-in utility that makes it possible for a user to localize the product. Once localization is entered and applied, the application does not require any recompilation or re-installation. Also, localization can be exported, imported, and merged. {br}

For more information about how to use the built-in localization mechanism, see [HelpRoot_Administration\SM__con_Translation_Process|Translation Process] in the System Administration Guide.
==Related Articles==
*[HelpRoot_Administration\SM__con_Translation_Process|Translation Process]
*[HelpRoot_Dev_Platform\BL__con_Localizable_Strings|Strings That Can Be Localized]]]></column>
			<column name="PlainText"><![CDATA[Localization Applications created with  Acumatica Framework can be    localized on the presentation, business logic, and database level owing to: Standard Microsoft.NET localization mechanism is implemented for localizing the presentation     layer. All messages returned from the business logic layer can be localized through the dictionary     mechanism. For details about how to implement message localization in your code, see  To Localize Application Messages. The runtime environment of  Acumatica Framework     supports the Unicode standard to store and operate with data in a non-ANSI format. Information like addresses or product descriptions can be stored in special,     language-specific, database fields and presented in the user selected language. For details on     implementation of such fields, see  To Work with Multi-Language Fields.  Acumatica Framework             provides a built-in utility that makes it possible for a user to localize the product.             Once localization is entered and applied, the application does not require any             recompilation or re-installation. Also, localization can be exported, imported, and             merged.  For more information about how to use the built-in localization mechanism, see  Translation Process in the System Administration       Guide. ]]></column>
		</row>
		<row PageID="85f491d2-f604-45ab-bb1b-efa90392a9bf" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="68efa666-733d-fcb5-a1fa-f543629ad3d0" RecordSourceID="22377">
			<column name="Content"><![CDATA[
By using the [HelpRoot_FormReference\SM_20_05_40|Translation Dictionaries] ([~/?ScreenId=SM200540|SM200540]) form, you can add translations for the string constants that are collected from the code of the application, and save them to the database. When a user signs in with a specific language, the systems loads the translations and displays the translated strings to the user. For more information on localization, see [HelpRoot_Administration\SM__CON_Locales_and_Languages|Locales and Languages].{br}

The system collects for localization the string constants that are specified in the following items of the application:[anchor|#_7863972e-8da1-46e7-a2cd-370d26424f72]
*The <tt>DisplayName</tt> property of the <tt>PXUIField</tt> attribute of the fields of data access classes (DACs)
*The <tt>DisplayName</tt> property of the <tt>PXUIField</tt> attribute of fields and actions of a business logic controller (BLC) object, which override the attributes of the fields and actions of a DAC
*The <tt>AllowedLabels</tt> properte of the <tt>PXStringList</tt> and <tt>PXIntList</tt> attributes
*The <tt>Values</tt> property of the classes that implement the <tt>ILocalizableValues</tt> interface
*Captions of form, grid, and panel controls and labels of input controls, which are specified in ASPX
*Titles of all nodes in the site map
*Report elements (such as text box labels and diagram agendas)
*{{public const string}} fields of the classes marked with the <tt>PXLocalizable</tt> attribute
{br}

You can also translate user input to multiple languages and store translations in the database. For more information on the localization of user input, see [HelpRoot_Dev_Platform\BL__how_Localize_Field_Values|To Work with Multi-Language Fields].
==Related Articles==
*[HelpRoot_Administration\SM__CON_Locales_and_Languages|Locales and Languages]
*[HelpRoot_FormReference\SM_20_05_40|Translation Dictionaries] ([~/?ScreenId=SM200540|SM200540])]]></column>
			<column name="PlainText"><![CDATA[Strings That Can Be Localized By using the   ([~/?ScreenId=SM200540|SM200540]) Translation Dictionaries    (SM200540) form, you can add translations for the string constants that are collected from the    code of the application, and save them to the database. When a user signs in with a specific    language, the systems loads the translations and displays the translated strings to the user. For    more information on localization, see  Locales and Languages. The system collects for localization the string constants that are specified in the following    items of the application: The  DisplayName  property of the  PXUIField  attribute of           the fields of data access classes (DACs) The  DisplayName  property of the  PXUIField  attribute of           fields and actions of a business logic controller (BLC) object, which override the           attributes of the fields and actions of a DAC The  AllowedLabels  properte of the  PXStringList  and              PXIntList  attributes The  Values  property of the classes that implement the              ILocalizableValues  interface Captions of form, grid, and panel controls and labels of input controls, which are specified      in ASPX Titles of all nodes in the site map Report elements (such as text box labels and diagram agendas) public const string  fields of the classes marked with the        PXLocalizable  attribute You can also translate user input to multiple languages and store translations in the database.    For more information on the localization of user input, see  To Work with Multi-Language Fields.  ([~/?ScreenId=SM200540|SM200540]) ]]></column>
		</row>
		<row PageID="6aa5f890-e9fb-49fd-924c-9da852f741f8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="72c6b443-b276-2640-4f67-231801d5891d" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When the system localizes the fields of the data access classes (DACs) and DAC names, it collects the string constants that are specified in the following code elements:[anchor|#_42c66640-1cdc-48c2-acbb-ea7e1c58ab2b]
*The <tt>DisplayName</tt> property of the <tt>PXUIField</tt> attribute of the fields of DACs
*The <tt>AllowedLabels</tt> property of the <tt>PXStringList</tt> attribute or <tt>PXIntList</tt> attribute of the fields of DACs
{br}

To prepare each DAC for localization, you need to perform the steps that are described in this topic. 
==To Prepare Each DAC for Localization==[anchor|#_2bcc5b6a-870f-4252-bba0-2402e9b6896a]
#Make sure the <tt>DisplayName</tt> parameter of the <tt>PXUIField</tt> attribute is specified for each visible field in the DAC, as shown in the following example.
#:((({S:Warn}If you change the <tt>DisplayName</tt> value of the <tt>PXUIField</tt> attribute on the fly (by creating your own <tt>PXFieldState</tt>), you should localize the string independently.
)))<source lang="charp">public new abstract class docType : PX.Data.IBqlField{}
[PXDBString(3, IsKey = true, IsFixed = true)]
[PXDefault()]
[PXUIField(DisplayName = "Document Type")]
public override string DocType { get; set; }</source>
#Specify the values that should be displayed in drop-down lists by using the <tt>PXStringList</tt> attribute, as shown in the following example.<source lang="csharp">public abstract class lineSource : PX.Data.IBqlField{}
[PXString(1, IsFixed = true)]        
[PXStringList(
    new string[] { "D", "R" },
    new string[] { "Draft", "Request" })]
[PXUIField(DisplayName = "Line Source")]
public virtual string LineSource { get; set; }</source>
]]></column>
			<column name="PlainText"><![CDATA[To Prepare DACs for Localization When the system localizes the fields of the data access classes (DACs) and DAC names,                 it collects the string constants that are specified in the following code                     elements: The  DisplayName  property of the                              PXUIField  attribute of the fields of DACs The  AllowedLabels  property of the                              PXStringList  attribute or                              PXIntList  attribute of the fields of DACs To prepare each DAC for localization, you need to perform the steps that are                 described in this topic.  To Prepare Each DAC for Localization Make sure the  DisplayName  parameter of the                          PXUIField  attribute is specified for each visible field                     in the DAC, as shown in the following example. If you change the                              DisplayName  value of the  PXUIField                          attribute on the fly (by creating your own  PXFieldState ),                         you should localize the string                     independently. public new abstract class docType : PX.Data.IBqlField{}
[PXDBString(3, IsKey = true, IsFixed = true)]
[PXDefault()]
[PXUIField(DisplayName = "Document Type")]
public override string DocType { get; set; } Specify the values that should be displayed in drop-down lists by using the                          PXStringList  attribute, as shown in the following                     example. public abstract class lineSource : PX.Data.IBqlField{}
[PXString(1, IsFixed = true)]        
[PXStringList(
    new string[] { "D", "R" },
    new string[] { "Draft", "Request" })]
[PXUIField(DisplayName = "Line Source")]
public virtual string LineSource { get; set; } ]]></column>
		</row>
		<row PageID="49d467e5-7717-4393-a5c6-398d4bcf818c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8b81b7a7-f461-3201-f2ab-a48a60cfc69c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
For localization of the messages in the source code, the system collects the strings from the classes that are marked with the <tt>PXLocalizable</tt> attribute. {br}

To make your application display localized messages, you need to perform the steps, which are described in this topic. 
==To Display Localized Messages in Your Application==[anchor|#_9cf1fbc9-2ba1-4db1-b338-8772290ff372]
#Move all strings that should be translated to the public static {{Messages}} class and specify the <tt>PXLocalizable</tt> attribute for this class, as shown in the following code.
#:((({S:Warn}The exceptions to this requirement are field descriptions and list attributes in the data access classes, which are handled separately. For details on how to make field descriptions and list attributes localizable, see [HelpRoot_Dev_Platform\BL__how_Prepare_DAC_for_Localization|To Prepare DACs for Localization].
)))<source lang="csharp">using System;
using PX.Data;
using PX.Common;

[PXLocalizable()]
public static class Messages
{
   public const string FieldNotFound = "The field is not found.";
   public const string InvalidAddress = "The address is not valid.";
   public const string AdditionalData = "Author's title: {0}; author's name: {1}.";
}</source>
#:((({S:Warn}No hyphenation is provided by the system. During the acquisition process of localizable data, all the new-line symbols (''\n\r'') are to be removed. You can use the reserved symbol (''~'') to cause the insertion of a new line.
)))
#If the message from the {{Messages}} class is used in an error or warning message, which is displayed when an exception of the <tt>PXException</tt> type or of a type derived from <tt>PXException</tt> is thrown, provide a non-localized message, as shown in the following example. The system displays the localized message automatically if there is a translation for this message in the database.<source lang="csharp">if (field == null)
{
        throw new PXException(Messages.FieldNotFound);
}</source>
#If you need to receive the translation of a message from the {{Messages}} class within the application code (for example, if the message is displayed in the confirmation dialog box, which is displayed if you use the <tt>Ask()</tt> method of a data view in the code), use one of the following methods:
#*<tt>PXMessages.Localize()</tt>: The method searches for the translation of the provided string in the database and returns the first translation found.<source lang="csharp">string msg = PXMessages.Localize(Messages.FieldNotFound);</source>
#*<tt>PXMessages.LocalizeFormat()</tt>: The method searches for the translation of the provided string, which includes placeholders (such as ''&#0123;0&#0125;'' or ''&#0123;1&#0125;''), in the database and returns the first translation found. 
#*<tt>PXLocalizer.Localize()</tt>: The method returns the translation with the given key, which you specify in the second parameter. A string may have multiple translations; one translation for each occurrence of the string in the application. For each of the occurrences, a key value is created. For example, if the string is declared in a class marked with the <tt>PXLocalizable</tt> attribute, the full qualified name of the class is the key, as the following code shows.{{{{string localizedMsg = PXLocalizer.Localize(
    ActionsMessages.ChangesWillBeSaved,
    typeof(ActionsMessages).ToString());
}}}}
]]></column>
			<column name="PlainText"><![CDATA[To Localize Application Messages For localization of the messages in the source code, the system collects the strings                 from the classes that are marked with the  PXLocalizable                  attribute.  To make your application display localized messages, you need to perform the steps,                 which are described in this topic.  To Display Localized Messages in Your Application Move all strings that should be translated to the public static                          Messages  class and specify the                          PXLocalizable  attribute for this class, as shown in the                     following code. The exceptions to this requirement are field descriptions                         and list attributes in the data access classes, which are handled                         separately. For details on how to make field descriptions and list                         attributes localizable, see  To Prepare DACs for Localization. using System;
using PX.Data;
using PX.Common;

[PXLocalizable()]
public static class Messages
{
   public const string FieldNotFound = "The field is not found.";
   public const string InvalidAddress = "The address is not valid.";
   public const string AdditionalData = "Author's title: {0}; author's name: {1}.";
} No                         hyphenation is provided by the system. During the acquisition process of                         localizable data, all the new-line symbols ( \n\r ) are to be removed.                         You can use the reserved symbol ( ~ ) to cause the insertion of a new                         line. If the message from the  Messages  class is used in an error or                     warning message, which is displayed when an exception of the                          PXException  type or of a type derived from                          PXException  is thrown, provide a non-localized message,                     as shown in the following example. The system displays the localized message                     automatically if there is a translation for this message in the                     database. if (field == null)
{
        throw new PXException(Messages.FieldNotFound);
} If you need to receive the translation of a message from the                          Messages  class within the application code (for example, if                     the message is displayed in the confirmation dialog box, which is displayed if                     you use the  Ask()  method of a data view in the code), use one                     of the following methods: PXMessages.Localize() : The method searches for the                             translation of the provided string in the database and returns the first                             translation                             found. string msg = PXMessages.Localize(Messages.FieldNotFound); PXMessages.LocalizeFormat() : The method searches for                             the translation of the provided string, which  includes placeholders                             (such as  {0}  or  {1} ), in the database and returns the                             first translation found.  PXLocalizer.Localize() : The method returns the                             translation with the given key, which you specify in the second                             parameter. A string may have multiple translations; one translation for                             each occurrence of the string in the application. For each of the                             occurrences, a key value is created. For example, if the string is                             declared in a class marked with the  PXLocalizable                              attribute, the full qualified name of the class is the key, as the                             following code                             shows. string localizedMsg = PXLocalizer.Localize(
    ActionsMessages.ChangesWillBeSaved,
    typeof(ActionsMessages).ToString()); ]]></column>
		</row>
		<row PageID="a1de7d38-cd06-4497-a5b7-61b1a01b7d16" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e44ad1aa-0e92-0806-b4cf-9b907c7fdf7c" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#_b1c440ea-8285-4b79-a0c9-b001109fb9b4]
With Acumatica Framework, you can create fields into which a user can type values in multiple languages if multiple locales are configured in the applicable Acumatica Framework application. For example, in Acumatica ERP, if an instance works with English and French locales, a user can specify the value of the '''Description''' box on the [HelpRoot_FormReference\IN_20_25_00|Stock Items] ([~/?ScreenId=IN202500|IN202500]) form in English and French. {br}

For details on multi-language fields on Acumatica ERP forms, see [HelpRoot_Administration\SM__mng_Locales|Managing Locales and Languages].{br}{TOC}
==To Configure a Field to Have Values in Multiple Languages==
[anchor|#_86a5b9f6-593a-474a-8629-e8d5b0474f54]
#In the data access class (DAC) that you want to contain a multi-language field, define the <tt>NoteID</tt> field with the <tt>PXNote</tt> attribute, as follows.{{{{public abstract class noteID : IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; }
}}}}
#If you want to configure a field to have values in multiple languages, annotate this field with the <tt>PXDBLocalizableString</tt> attribute. The following code shows an example of the use of the <tt>PXDBLocalizableString</tt> attribute. {{{{[PXDBLocalizableString(60, IsUnicode = true)]
}}}}
#:The <tt>PXDBLocalizableString</tt> attribute works similarly to the <tt>PXDBString</tt> attribute, but unlike the <tt>PXDBString</tt> attribute, the <tt>PXDBLocalizableString</tt> attribute can be used instead of the <tt>PXDBText</tt> and <tt>PXString</tt> attributes.
#If you need to give values in multiple languages to a field with the <tt>PXDBText</tt> attribute, replace this attribute with the <tt>PXDBLocalizableString</tt> attribute and do not specify the length parameter, as shown in the following example. {{{{[PXDBLocalizableString(IsUnicode = true)]
}}}}
#If you need to configure a field that has the <tt>PXString</tt> attribute, which is used in conjunction with the <tt>PXDBCalced</tt> attribute, replace the <tt>PXString</tt> attribute with the <tt>PXDBLocalizableString</tt> attribute and set the value of the <tt>NonDB</tt> parameter to {{true}}, as shown in the following example.{{{{[PXDBLocalizableString(255, IsUnicode = true, NonDB = true, 
   BqlField = typeof(PaymentMethod.descr))] 
[PXDBCalced(typeof(Switch&lt;Case&lt;Where&lt;PaymentMethod.descr, IsNotNull&gt;, 
   PaymentMethod.descr&gt;, CustomerPaymentMethod.descr&gt;), typeof(string))]
}}}}

==To Configure the Default Value of a Multi-Language Field==
If you want a multi-language field to have a default value in a specific language, use the <tt>PXLocalizableDefault</tt> attribute instead of the <tt>PXDefault</tt> attribute and specify in its second parameter either a BQL field or a BQL select that provides language selection. {br}

For example, in Acumatica ERP, the {{SOLine}} line description defaulted to the appropriate {{InventoryItem}} description based on the language that is set for a customer. The {{TransactionDesr}} field of the {{SOLine}} DAC has the <tt>PXLocalizableDefault</tt> attribute with a second parameter that specifies the language as follows: {{typeof(Customer.languageName)}}. See the following example of the use of the <tt>PXLocalizableDefault</tt> attribute.{{{{[PXLocalizableDefault(typeof(Search&lt;InventoryItem.descr,
   Where&lt;InventoryItem.inventoryID, 
   Equal&lt;Current&lt;SOLine.inventoryID&gt;&gt;&gt;&gt;),
   typeof(Customer.languageName), 
   PersistingCheck = PXPersistingCheck.Nothing)]                                      
}}}}
==To Obtain the Value of a Multi-Language Field in the Current Locale==
If you want to obtain the value of a multi-language field in the current locale, use the <tt>PXDatabase.SelectSingle()</tt> or <tt>PXDatabase.SelectMulti()</tt> method, and pass to it the return value of the <tt>PXDBLocalizableStringAttribute.GetValueSelect()</tt> static method instead of passing a new <tt>PXDataField</tt> object to it. (The <tt>PXDBLocalizableStringAttribute.GetValueSelect()</tt> method takes three input parameters: the table name, the field name, and a Boolean flag that indicates whether strings should be returned as text with unlimited length.) {br}

The following code shows an example of the use of the <tt>PXDBLocalizableStringAttribute.GetValueSelect()</tt> method.{{{{foreach (PXDataRecord record in PXDatabase.SelectMulti&lt;Numbering&gt;(
   newPXDataField&lt;Numbering.numberingID&gt;(), 
   PXDBLocalizableStringAttribute.GetValueSelect("Numbering", 
      "NewSymbol", false),
   newPXDataField&lt;Numbering.userNumbering&gt;()))     
{
   ...
}                                             
}}}}((({S:Warn}Generally, you use the <tt>PXDatabase.SelectSingle()</tt> and <tt>PXDatabase.SelectMulti()</tt> methods for retrieving data within the <tt>Prefetch()</tt> method of a database slot. Don&rsquo;t forget to add language code to the slot key when you obtain a slot, as shown in the following example, because with the use of <tt>PXDBLocalizableStringAttribute</tt>, the data becomes language-specific. Therefore, you need different slot instances for different languages.{{{{Numberings items = PXDatabase.GetSlot&lt;Numberings&gt;(
   typeof(Numberings).Name + currentLanguage, typeof(Numbering));
}}}}
)))
==To Obtain the Value of a Multi-Language Field in a Specific Language==
If you want to obtain the value of a multi-language field in a specific language, use the <tt>PXDBLocalizableStringAttribute.GetTranslation()</tt> method. Pass to the method as input parameters a DAC cache, a DAC instance, a field name, and the ISO code of the language. {br}

The following code shows an example of use of the <tt>PXDBLocalizableStringAttribute.GetTranslation()</tt> method.{{{{tran.TranDesc =
   PXDBLocalizableStringAttribute.GetTranslation(
      Caches[typeof(InventoryItem)], item, typeof(InventoryItem.descr).Name,
      customer.Current?.LanguageName);
}}}}]]></column>
			<column name="PlainText"><![CDATA[To Work with Multi-Language Fields With  Acumatica Framework, you             can create fields into which a user can type values in multiple languages if multiple             locales are configured in the applicable  Acumatica Framework             application. For example, in  Acumatica ERP,             if an instance works with English and French locales, a user can specify the value of             the  Description  box on the   ([~/?ScreenId=IN202500|IN202500]) Stock Items             (IN202500) form in English and French.  For details on multi-language fields on  Acumatica ERP forms, see       Managing Locales and Languages. To Configure a Field to Have Values in Multiple Languages In the data access class (DAC) that you want to contain a multi-language field, define the         NoteID  field with the  PXNote  attribute, as       follows. public abstract class noteID : IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; } If you want to configure a field to have values in multiple languages, annotate this field       with the  PXDBLocalizableString  attribute. The following code shows an       example of the use of the  PXDBLocalizableString  attribute.         [PXDBLocalizableString(60, IsUnicode = true)] The          PXDBLocalizableString  attribute works similarly to the          PXDBString  attribute, but unlike the  PXDBString         attribute, the  PXDBLocalizableString  attribute can be used instead of the          PXDBText  and  PXString  attributes. If you need to give values in multiple languages to a field with the         PXDBText  attribute, replace this attribute with the         PXDBLocalizableString  attribute and do not specify the length parameter,       as shown in the following example.        [PXDBLocalizableString(IsUnicode = true)] If you need to configure a field that has the  PXString  attribute, which       is used in conjunction with the  PXDBCalced  attribute, replace the         PXString  attribute with the  PXDBLocalizableString        attribute and set the value of the  NonDB  parameter to        true , as shown in the following       example. [PXDBLocalizableString(255, IsUnicode = true, NonDB = true, 
   BqlField = typeof(PaymentMethod.descr))] 
[PXDBCalced(typeof(Switch<Case<Where<PaymentMethod.descr, IsNotNull>, 
   PaymentMethod.descr>, CustomerPaymentMethod.descr>), typeof(string))] To Configure the Default Value of a Multi-Language Field If you want a multi-language field to have a default value in a specific language, use the       PXLocalizableDefault  attribute instead of the  PXDefault      attribute and specify in its second parameter either a BQL field or a BQL select that provides     language selection.  For example, in  Acumatica ERP,     the  SOLine  line description defaulted to the appropriate       InventoryItem  description based on the language that is set for a customer.     The  TransactionDesr  field of the  SOLine  DAC has the       PXLocalizableDefault  attribute with a second parameter that specifies the     language as follows:  typeof(Customer.languageName) . See the following example     of the use of the  PXLocalizableDefault      attribute. [PXLocalizableDefault(typeof(Search<InventoryItem.descr,
   Where<InventoryItem.inventoryID, 
   Equal<Current<SOLine.inventoryID>>>>),
   typeof(Customer.languageName), 
   PersistingCheck = PXPersistingCheck.Nothing)]                                       To Obtain the Value of a Multi-Language Field in the Current Locale If you want to obtain the value of a multi-language field in the current locale, use the       PXDatabase.SelectSingle()  or  PXDatabase.SelectMulti()      method, and pass to it the return value of the       PXDBLocalizableStringAttribute.GetValueSelect()  static method instead of     passing a new  PXDataField  object to it. (The       PXDBLocalizableStringAttribute.GetValueSelect()  method takes three input     parameters: the table name, the field name, and a Boolean flag that indicates whether strings     should be returned as text with unlimited length.)  The following code shows an example of the use of the       PXDBLocalizableStringAttribute.GetValueSelect()       method. foreach (PXDataRecord record in PXDatabase.SelectMulti<Numbering>(
   newPXDataField<Numbering.numberingID>(), 
   PXDBLocalizableStringAttribute.GetValueSelect("Numbering", 
      "NewSymbol", false),
   newPXDataField<Numbering.userNumbering>()))     
{
   ...
}                                              Generally,      you use the  PXDatabase.SelectSingle()  and        PXDatabase.SelectMulti()  methods for retrieving data within the        Prefetch()  method of a database slot. Don't forget to add language code to      the slot key when you obtain a slot, as shown in the following example, because with the use of        PXDBLocalizableStringAttribute , the data becomes language-specific.      Therefore, you need different slot instances for different      languages. Numberings items = PXDatabase.GetSlot<Numberings>(
   typeof(Numberings).Name + currentLanguage, typeof(Numbering)); To Obtain the Value of a Multi-Language Field in a Specific Language If you want to obtain the value of a multi-language field in a specific language, use the       PXDBLocalizableStringAttribute.GetTranslation()  method. Pass to the method     as input parameters a DAC cache, a DAC instance, a field name, and the ISO code of the language.  The following code shows an example of use of the       PXDBLocalizableStringAttribute.GetTranslation()      method. tran.TranDesc =
   PXDBLocalizableStringAttribute.GetTranslation(
      Caches[typeof(InventoryItem)], item, typeof(InventoryItem.descr).Name,
      customer.Current?.LanguageName); ]]></column>
		</row>
		<row PageID="ac6b5781-1d62-4dab-b153-63b29d138732" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="c83ad543-555d-6746-177a-e303c4e2d9dc" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#_7dee2438-a055-49ba-8ef4-ee63c7f7f7be]
To optimize the memory consumption of static data, you can move the localization data from all customer application instances to centralized storage. By default, the localization data is kept in the database of every Acumatica ERP instance, and the total size of this data therefore equals the number of instances times the size of the data. If you move the localization data to centralized storage, there is only one copy of this data.{br}

Alternatively, you can optimize the consumption of memory by disabling localization.{br}

Whether you set up centralized storage of localization data or disable localization, you should perform the following steps:[anchor|#ul_yrp_tcp_jl]
#Implement a custom translation provider. Follow the instruction in [[#_9fb6a0e2-4efe-4bc7-9fb6-977cdbbf5e62|To Implement a Custom Translation Provider] or [[#_2c321ca4-d3b0-4643-a139-c40480fd3126|To Disable Localization] in this topic depending on which way of optimization of memory consumption you select.
#Place the assembly file with the new provider in the <tt>Bin</tt> directory of the Acumatica ERP instance, and add the assembly to the customization project as a ''File'' element. 
#Register the new provider in the <tt>pxtranslate</tt> element of the <tt>web.config</tt> file, as described in [[#_73ca3eeb-cea0-46ea-b496-0278113298d1|To Register the New Provider in Web.config] in this topic.
{br}{TOC}[anchor|#_9fb6a0e2-4efe-4bc7-9fb6-977cdbbf5e62]
==To Implement a Custom Translation Provider==
To implement a custom translation provider, derive a class from the <tt>PXTranslationProvider</tt> class and override the <tt>LoadCultureDictionary()</tt> method, as the following example shows.<source lang="csharp">public class DemoTranslationProvider : PXTranslationProvider
{
    public override PXCultureDictionary LoadCultureDictionary(
        string locale, bool includeObsolete, bool escapeStrings)
    {
        PXCultureDictionary dictionary = new PXCultureDictionary();
        ...
        // Adding a general translation for some string
        dictionary.Append(
            valueToTranslate,
            new PXCultureValue(locale, translation));
        // Adding a special translation for some string
        dictionary.AppendException(
            valueToTranslate,
            new PXCultureEx(resourceID, locale, translation));
        ...
        return dictionary;
    }
}</source>
The <tt>LoadCultureDictionary()</tt> method returns an instance of the <tt>PXCultureDictionary</tt> type. Values are added to objects of this type through the <tt>Append()</tt> and <tt>AppendException()</tt> methods. <tt>Append()</tt> adds a general translation for a string. <tt>AppendException()</tt> adds a translation for a special case (exception) identified by the resource key.{br}

The code below defines a custom translation provider that loads the localization data from an external Acumatica ERP database by using ADO.NET tools.<source lang="csharp">using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Linq;
using System.Text;
using PX.Data;
using PX.Translation;

namespace Demo.Translation
{
    public class DemoTranslationProvider : PXTranslationProvider
    {
        private struct TranslationKey
        {
            public Guid id;
            public string resKey;
            public string locale;
        }

        // The connection string for the database that stores localization
        // data
        // Specify a specific value of the connection string
        private const string connectionString = "";

        // Overriding the method that returns the dictionary of
        // localization data
        public override PXCultureDictionary LoadCultureDictionary(
            string locale, bool includeObsolete, bool escapeStrings)
        {
            string localizationValueSelect;
            string localizationTranslationSelect;
            InitializeSelectCommand(locale, includeObsolete,
                                    out localizationValueSelect,
                                    out localizationTranslationSelect);

            Dictionary&lt;Guid, string&gt; localizationValue;
            Dictionary&lt;TranslationKey, string&gt; localizationTranslation;
            SelectLocalizationValues(localizationValueSelect,
                                     localizationTranslationSelect,
                                     out localizationValue,
                                     out localizationTranslation);

            return CreateCultureDictionary(escapeStrings, localizationValue,
                                           localizationTranslation);
        }

        // Builds the SQL statement for selecting localization data
        private void InitializeSelectCommand(
            string locale, bool includeObsolete,
            out string localizationValueSelect,
            out string localizationTranslationSelect)
        {
            StringBuilder localizationValueSelectBld = 
                new StringBuilder("Select IDlv, NeutralValue" + 
                                  "From LocalizationValue");
            if (!includeObsolete)
            {
                localizationValueSelectBld.Append(" Where IsObsolete = 0");
            }
            localizationValueSelect = localizationValueSelectBld.ToString();

            StringBuilder localizationTranslationSelectBld =
                new StringBuilder("Select IDlt, ResKey, Value, Locale" + 
                                  "From LocalizationTranslation");
            if (!string.IsNullOrEmpty(locale))
            {
                localizationTranslationSelectBld.AppendFormat(
                    " Where Locale = '{0}'", locale);
            }
            localizationTranslationSelect = 
                localizationTranslationSelectBld.ToString();
        }

        // Retrieves localization data from the database by using the provided
        // SQL statement
        private void SelectLocalizationValues(
            string localizationValueSelect,
            string localizationTranslationSelect,
            out Dictionary&lt;Guid, string&gt; localizationValue,
            out Dictionary&lt;TranslationKey, string&gt; localizationTranslation)
        {
            localizationValue = new Dictionary&lt;Guid, string&gt;();
            localizationTranslation = 
                new Dictionary&lt;TranslationKey, string&gt;();

            using (SqlConnection connection = 
                   new SqlConnection(connectionString))
            {
                connection.Open();

                SqlCommand command = new SqlCommand(localizationValueSelect,
                                                    connection);
                using (SqlDataReader reader = command.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        localizationValue.Add(reader.GetGuid(0),
                                              reader.GetString(1));
                    }
                }

                command.CommandText = localizationTranslationSelect;
                using (SqlDataReader reader = command.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        TranslationKey newTranslationKey = new TranslationKey()
                        {
                            id = reader.GetGuid(0),
                            resKey = reader.GetString(1),
                            locale = reader.GetString(3)
                        };
                        localizationTranslation.Add(newTranslationKey,
                                                    reader.GetString(2));
                    }
                }
            }
        }

        // Fills the PXCultureDictionary object with localization data by using
        // the provided dictionaries of values to translate and the
        // corresponding translations
        private PXCultureDictionary CreateCultureDictionary(
            bool escapeStrings,
            Dictionary&lt;Guid, string&gt; localizationValue,
            Dictionary&lt;TranslationKey, string&gt; localizationTranslation)
        {
            PXCultureDictionary dictionary = new PXCultureDictionary();

            if (localizationTranslation.Count != 0)
            {
                foreach (Guid id in localizationValue.Keys)
                {
                    IEnumerable&lt;TranslationKey&gt; localizationTranslationKeys = 
                        from translationRowKey in localizationTranslation.Keys
                        where translationRowKey.id == id
                        select translationRowKey;
                    foreach (TranslationKey key in localizationTranslationKeys)
                    {
                        string translationResKey = key.resKey;
                        string translationLocale = key.locale;
                        string translationValue = localizationTranslation[key];
                        string value = escapeStrings ?
                            PXLocalizer.EscapeString(translationValue) :
                            translationValue;

                        if (string.IsNullOrEmpty(translationResKey))
                        {
                            dictionary.Append(
                                localizationValue[id],
                                new PXCultureValue(translationLocale, value));
                        }
                        else
                        {
                            dictionary.AppendException(
                                localizationValue[id],
                                new PXCultureEx(translationResKey,
                                                translationLocale, value));
                        }
                    }
                }
            }
            return dictionary;
        }
    }
}</source>[anchor|#_2c321ca4-d3b0-4643-a139-c40480fd3126]
==To Disable Localization==
To disable localization, implement a custom translation provider with the <tt>LoadCultureDictionary()</tt> method that returns <tt>null</tt>, as the following code shows.<source lang="csharp">public class DemoTranslationProvider : PXTranslationProvider
{
    public override PXCultureDictionary LoadCultureDictionary(
        string locale, bool includeObsolete, bool escapeStrings)
    {
        return null;
    }
}</source>[anchor|#_73ca3eeb-cea0-46ea-b496-0278113298d1]
==To Register the New Provider in Web.config==
Once the provider class is defined, register it in the <tt>web.config</tt> file by adding a new key to the <tt>providers</tt> collection of the <tt>pxtranslate</tt> element and specifying the new key in the <tt>defaultProvider</tt> property of <tt>pxtranslate</tt>. Use the <tt>add</tt> element to register the provider. Set the <tt>name</tt> attribute to the key, which can be any unique value, and specify the type of the custom provider in the <tt>type</tt> attribute.{br}

The following code shows the configuration of <tt>DemoTranslationProvider</tt>, introduced in the example above, in the <tt>pxtranslate</tt> element of the <tt>web.config</tt> file.<source lang="csharp">&lt;pxtranslate defaultProvider="DemoTranslationProvider"&gt;
  &lt;providers&gt;
    &lt;!--The default translation provider--&gt;
    &lt;remove name="PXDBTranslatonProvider" /&gt;
    &lt;add name="PXDBTranslatonProvider"
         type="PX.Data.PXDBTranslatonProvider, PX.Data" /&gt;

    &lt;!--The custom translation provider--&gt;
    &lt;remove name="DemoTranslationProvider" /&gt;
    &lt;add name="DemoTranslationProvider"
         type="Demo.Translation.DemoTranslationProvider, TranslationProvider"
         applicationName="/"/&gt;
  &lt;/providers&gt;
&lt;/pxtranslate&gt;</source>]]></column>
			<column name="PlainText"><![CDATA[To Optimize Memory Consumption of Localized Data To optimize the memory consumption of static data, you can move the localization data from all customer application instances to centralized storage. By default, the localization data is kept in the database of every  Acumatica ERP instance, and the total size of this data therefore equals the number of instances times the size of the data. If you move the localization data to centralized storage, there is only one copy of this data. Alternatively, you can optimize the consumption of memory by disabling                 localization. Whether you set up centralized storage of localization data or disable localization,                 you should perform the following steps: Implement a custom translation provider. Follow the instruction in  To Implement a Custom Translation Provider To Implement a Custom Translation Provider or  To Disable Localization To Disable Localization in this topic depending on which way of optimization of                     memory consumption you select. Place the assembly file with the new provider in the  Bin                      directory of the  Acumatica ERP instance, and add the assembly to the customization project as a  File                      element.  Register the new provider in the  pxtranslate  element of the                          web.config  file, as described in  To Register the New Provider in Web.config To Register the New Provider in Web.config in this topic. To Implement a Custom Translation Provider To implement a custom translation provider, derive a class from the                      PXTranslationProvider  class and override the                      LoadCultureDictionary()  method, as the following example                 shows. public class DemoTranslationProvider : PXTranslationProvider
{
    public override PXCultureDictionary LoadCultureDictionary(
        string locale, bool includeObsolete, bool escapeStrings)
    {
        PXCultureDictionary dictionary = new PXCultureDictionary();
        ...
        // Adding a general translation for some string
        dictionary.Append(
            valueToTranslate,
            new PXCultureValue(locale, translation));
        // Adding a special translation for some string
        dictionary.AppendException(
            valueToTranslate,
            new PXCultureEx(resourceID, locale, translation));
        ...
        return dictionary;
    }
} The  LoadCultureDictionary()  method returns an instance of the                      PXCultureDictionary  type. Values are added to objects of this                 type through the  Append()  and                      AppendException()  methods.  Append()  adds a                 general translation for a string.  AppendException()  adds a                 translation for a special case (exception) identified by the resource key. The code below defines a custom translation provider that loads the localization data                 from an external  Acumatica ERP database by using ADO.NET tools. using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Linq;
using System.Text;
using PX.Data;
using PX.Translation;

namespace Demo.Translation
{
    public class DemoTranslationProvider : PXTranslationProvider
    {
        private struct TranslationKey
        {
            public Guid id;
            public string resKey;
            public string locale;
        }

        // The connection string for the database that stores localization
        // data
        // Specify a specific value of the connection string
        private const string connectionString = "";

        // Overriding the method that returns the dictionary of
        // localization data
        public override PXCultureDictionary LoadCultureDictionary(
            string locale, bool includeObsolete, bool escapeStrings)
        {
            string localizationValueSelect;
            string localizationTranslationSelect;
            InitializeSelectCommand(locale, includeObsolete,
                                    out localizationValueSelect,
                                    out localizationTranslationSelect);

            Dictionary<Guid, string> localizationValue;
            Dictionary<TranslationKey, string> localizationTranslation;
            SelectLocalizationValues(localizationValueSelect,
                                     localizationTranslationSelect,
                                     out localizationValue,
                                     out localizationTranslation);

            return CreateCultureDictionary(escapeStrings, localizationValue,
                                           localizationTranslation);
        }

        // Builds the SQL statement for selecting localization data
        private void InitializeSelectCommand(
            string locale, bool includeObsolete,
            out string localizationValueSelect,
            out string localizationTranslationSelect)
        {
            StringBuilder localizationValueSelectBld = 
                new StringBuilder("Select IDlv, NeutralValue" + 
                                  "From LocalizationValue");
            if (!includeObsolete)
            {
                localizationValueSelectBld.Append(" Where IsObsolete = 0");
            }
            localizationValueSelect = localizationValueSelectBld.ToString();

            StringBuilder localizationTranslationSelectBld =
                new StringBuilder("Select IDlt, ResKey, Value, Locale" + 
                                  "From LocalizationTranslation");
            if (!string.IsNullOrEmpty(locale))
            {
                localizationTranslationSelectBld.AppendFormat(
                    " Where Locale = '{0}'", locale);
            }
            localizationTranslationSelect = 
                localizationTranslationSelectBld.ToString();
        }

        // Retrieves localization data from the database by using the provided
        // SQL statement
        private void SelectLocalizationValues(
            string localizationValueSelect,
            string localizationTranslationSelect,
            out Dictionary<Guid, string> localizationValue,
            out Dictionary<TranslationKey, string> localizationTranslation)
        {
            localizationValue = new Dictionary<Guid, string>();
            localizationTranslation = 
                new Dictionary<TranslationKey, string>();

            using (SqlConnection connection = 
                   new SqlConnection(connectionString))
            {
                connection.Open();

                SqlCommand command = new SqlCommand(localizationValueSelect,
                                                    connection);
                using (SqlDataReader reader = command.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        localizationValue.Add(reader.GetGuid(0),
                                              reader.GetString(1));
                    }
                }

                command.CommandText = localizationTranslationSelect;
                using (SqlDataReader reader = command.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        TranslationKey newTranslationKey = new TranslationKey()
                        {
                            id = reader.GetGuid(0),
                            resKey = reader.GetString(1),
                            locale = reader.GetString(3)
                        };
                        localizationTranslation.Add(newTranslationKey,
                                                    reader.GetString(2));
                    }
                }
            }
        }

        // Fills the PXCultureDictionary object with localization data by using
        // the provided dictionaries of values to translate and the
        // corresponding translations
        private PXCultureDictionary CreateCultureDictionary(
            bool escapeStrings,
            Dictionary<Guid, string> localizationValue,
            Dictionary<TranslationKey, string> localizationTranslation)
        {
            PXCultureDictionary dictionary = new PXCultureDictionary();

            if (localizationTranslation.Count != 0)
            {
                foreach (Guid id in localizationValue.Keys)
                {
                    IEnumerable<TranslationKey> localizationTranslationKeys = 
                        from translationRowKey in localizationTranslation.Keys
                        where translationRowKey.id == id
                        select translationRowKey;
                    foreach (TranslationKey key in localizationTranslationKeys)
                    {
                        string translationResKey = key.resKey;
                        string translationLocale = key.locale;
                        string translationValue = localizationTranslation[key];
                        string value = escapeStrings ?
                            PXLocalizer.EscapeString(translationValue) :
                            translationValue;

                        if (string.IsNullOrEmpty(translationResKey))
                        {
                            dictionary.Append(
                                localizationValue[id],
                                new PXCultureValue(translationLocale, value));
                        }
                        else
                        {
                            dictionary.AppendException(
                                localizationValue[id],
                                new PXCultureEx(translationResKey,
                                                translationLocale, value));
                        }
                    }
                }
            }
            return dictionary;
        }
    }
} To Disable Localization To disable localization, implement a custom translation provider with the                      LoadCultureDictionary()  method that returns                      null , as the following code shows. public class DemoTranslationProvider : PXTranslationProvider
{
    public override PXCultureDictionary LoadCultureDictionary(
        string locale, bool includeObsolete, bool escapeStrings)
    {
        return null;
    }
} To Register the New Provider in Web.config Once the provider class is defined, register it in the                      web.config  file by adding a new key to the                      providers  collection of the  pxtranslate                  element and specifying the new key in the  defaultProvider                  property of  pxtranslate . Use the  add  element                 to register the provider. Set the  name  attribute to the key,                 which can be any unique value, and specify the type of the custom provider in the                      type  attribute. The following code shows the configuration of                      DemoTranslationProvider , introduced in the example above, in                 the  pxtranslate  element of the  web.config                  file. <pxtranslate defaultProvider="DemoTranslationProvider">
  <providers>
    <!--The default translation provider-->
    <remove name="PXDBTranslatonProvider" />
    <add name="PXDBTranslatonProvider"
         type="PX.Data.PXDBTranslatonProvider, PX.Data" />

    <!--The custom translation provider-->
    <remove name="DemoTranslationProvider" />
    <add name="DemoTranslationProvider"
         type="Demo.Translation.DemoTranslationProvider, TranslationProvider"
         applicationName="/"/>
  </providers>
</pxtranslate> ]]></column>
		</row>
		<row PageID="76b8c160-89bd-4501-9f9f-1dabc648d417" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="d7d13646-6f1c-f4c2-ca7d-335afaba3635" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In an Acumatica ERP application or an Acumatica Framework-based application, you may need to use the same business logic in multiple places. For example, Acumatica ERP supports the calculation of amounts in multiple currencies. Therefore, the business logic containers (also called ''graphs'') that implement the multicurrency logic are included in different modules of the application. {br}

With the ability to reuse business logic in Acumatica ERP or Acumatica Framework, you can include the main business logic of particular functionality (such as multicurrency processing) in reusable generic graph extensions and use this logic whenever you need to. If you need to adjust this logic for the specifics of a particular module, you can override this business logic in the implementation of this module. For example, you can assign different names for the UI elements that are linked to the same fields of a data access class in different modules.{br}

In code of Acumatica Framework-based applications, you can also use dependency injection. With dependency injection, you can encapsulate particular logic as a service and use this service in any place of your application. {br}

In this section, you can find information about dependency injection and generic graph extensions. 
==In This Chapter==[anchor|#_c7db19f4-1a9d-40b5-80aa-72df8cd8f368]
{| class="checklist invisiblechecklist" | width="100%" 
|- 
| [anchor|#_4d514852-c595-4201-80d9-ca637a06b430]
*[HelpRoot_Dev_Platform\BL__CON_DependencyInjection|Dependency Injection]
*[HelpRoot_Dev_Platform\BL__con_Generic_Extensions|Reusable Business Logic Implementation]
*[HelpRoot_Dev_Platform\BL__con_Reusable_Logic_and_Database|Mapped Cache Extensions and the Application Database]
*[HelpRoot_Dev_Platform\BL__con_Reusable_Logic_and_Website|Reusable Business Logic and the Application Website]
*[HelpRoot_Dev_Platform\BL__con_Use_of_Generic_Graph_Extensions|Use of Generic Graph Extensions by the System]
*[HelpRoot_Dev_Platform\BL__con_Implemented_Generic_Extensions|Generic Graph Extensions Declared in Acumatica ERP]

| [anchor|#_94189ce6-10d1-46e3-bb78-75704a6a0c53]
*[HelpRoot_Dev_Platform\BL__how_Insert_Reusable_Business_Logic|To Insert Reusable Business Logic That Has Already Been Declared]
*[HelpRoot_Dev_Platform\BL__how_Sort_Generic_Graph_Extensions|To Sort Multiple Generic Graph Extensions]
*[HelpRoot_Dev_Platform\BL__how_Create_Reusable_Logic|To Implement Reusable Business Logic]

|}]]></column>
			<column name="PlainText"><![CDATA[Reusing Business Logic In an  Acumatica ERP     application or an  Acumatica Framework-based     application, you may need to use the same business logic in multiple places. For example,  Acumatica ERP     supports the calculation of amounts in multiple currencies. Therefore, the business logic     containers (also called  graphs ) that implement the multicurrency logic are included in     different modules of the application.  With the ability to reuse business logic in  Acumatica ERP     or  Acumatica Framework, you can include the main business logic of particular functionality (such as multicurrency     processing) in reusable generic graph extensions and use this logic whenever you need to. If you     need to adjust this logic for the specifics of a particular module, you can override this     business logic in the implementation of this module. For example, you can assign different names     for the UI elements that are linked to the same fields of a data access class in different     modules. In code of  Acumatica Framework-based     applications, you can also use dependency injection. With dependency injection, you can     encapsulate particular logic as a service and use this service in any place of your application.  In this section, you can find information about dependency injection and generic graph     extensions.  In This Chapter Dependency InjectionReusable Business Logic ImplementationMapped Cache Extensions and the Application DatabaseReusable Business Logic and the Application WebsiteUse of Generic Graph Extensions by the SystemGeneric Graph Extensions Declared in Acumatica ERPTo Insert Reusable Business Logic That Has Already Been DeclaredTo Sort Multiple Generic Graph ExtensionsTo Implement Reusable Business Logic]]></column>
		</row>
		<row PageID="67164f06-37ff-40c1-9f33-55e6aa43b44e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="eaea98e0-9a42-8c4e-8b63-df3547b0b456" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In the code of Acumatica Framework-based applications, you can use dependency injection to encapsulate particular logic as a service, which you can then use anywhere in your application. This technique can be used in graphs, attributes, and custom action classes, as described below.((({S:Danger}Dependency injection in Acumatica Framework-based applications requires the use of the {{Autofac.Module}} class, which is provided by the external {{Autofac}} library. Acumatica does not guarantee the backward compatibility of this library. For details about the {{Autofac}} library, see [https://autofac.readthedocs.io/en/latest/].
))){br}{TOC}
==Definition of the Service for Dependency Injection==
To define the service for dependency injection, you define an interface for the service and a class that implements this interface. The following example shows a definition of a service for dependency injection.<source lang="csharp">using System;
using Autofac;
using PX.Data;

namespace MyNamespace
{
    //An interface for the service
    public interface IMyService
    {
        void ProvideServiceFunctions();
    }
    //A class that implements the interface
    public class MyService : IMyService
    {
        public void ProvideServiceFunctions()
        {
            //An implementation
        }
    }
}</source>
==Registration of the Service==
To register the service in your application, you do the following:[anchor|#_c3627553-efe9-4f8c-82ec-8cfedebb89b1]
#Implement a registration class derived from the <tt>Autofac.Module</tt> class.
#In this registration class, override the <tt>Module.Load()</tt> method. You do not need to call the base method in the overriding method.
((({S:Hint}[anchor|#_518b5789-5dcf-45d3-9d60-fd507dd1fb90]
*You can register multiple implementations of an interface for the service in one registration class or multiple registration classes.
*To make it possible to override the service in a customization project, you should register the service with <tt>PreserveExistingDefaults()</tt>.
))){br}

The following code shows an example of a registration class.<source lang="csharp">using System;
using Autofac;
using PX.Data;
namespace MyNamespace
{
    //A class that registers the implementation class with Autofac
    public class MyServiceRegistrarion : Module
    {
        protected override void Load(ContainerBuilder builder)
        {
            builder.RegisterType&lt;MyService&gt;().As&lt;IMyService&gt;();
        }
    }
}</source>
==Dependency Injection in Graphs==
To use dependency injection in a graph, you define a property of the graph and assign the <tt>InjectDependency</tt> attribute to this property, as shown in the following example.{{{{namespace MyNameSpace
{
    public class MyGraph : PXGraph&lt;MyGraph&gt;
    { 
        [InjectDependency]
        private IMyService MyService { get; set; }

        public PXAction&lt;MyDAC&gt; MyButton;
        [PXButton]
        [PXUIField(DisplayName ="My Action")]
        protected void myButton()
        {
            MyService.ProvideServiceFunctions();
        }

        // Other code of the graph
    }
}
}}}}((({S:Warn}[anchor|#_9e180bcc-d9c8-4c03-9c01-09f4510f6a3d]
*Dependency injection in graph constructors is not supported.
*The properties to which the <tt>InjectDependency</tt> attribute is assigned cannot be used in graph constructors. If you need to use these properties during the initialization of a graph, you need to implement the <tt>IGraphWithInitialization</tt> interface in the graph. In the implementation of the <tt>IGraphWithInitialization.Initialize()</tt> method, you can use the properties.
)))
==Dependency Injection in Attributes==
For an attribute derived from <tt>PXEventSubscriberAttribute</tt>, you use dependency injection in the following way:[anchor|#_fd8b6eea-db30-4b7b-a355-be9f0267e593]
#Define an attribute class and assign to its property the <tt>InjectDependency</tt> attribute, as shown in the following code example.<source lang="csharp">using System;
using PX.Data;

namespace MyNamespace
{
    public class CustomAttribute : PXEventSubscriberAttribute
    {
        [InjectDependency]
        public IMyService Service { get; set; }
    }
}</source>
#To support dependency injection in a constructor of the implementation class of the service, pass <tt>PXEventSubscriberAttribute</tt>, <tt>PXCache</tt>, or <tt>PXGraph</tt> (or any combination of these objects) in the constructor, as shown in the following code example.<source lang="csharp">public class MyService : IMyService
{
    //A constructor with PXEventSubscriberAttribute
    <b>public MyService(PXEventSubscriberAttribute parent) <b>
    { 
        //Code of the constructor
    }

    //A constructor with PXCache
    <b>public MyService(PXCache cache)<b>
    { 
        //Code of the constructor
    }

    //A constructor with PXGraph
    <b>public MyService(PXGraph graph)<b>
    { 
        //Code of the constructor
    }

    //A constructor with PXEventSubscriberAttribute and PXGraph
    <b>public MyService(PXEventSubscriberAttribute parent, PXGraph graph)<b>
    { 
        //Code of the constructor
    }

    //Other code of the implementation class
}</source>

==Dependency Injection in Custom Action Classes==
For a custom action class derived from the <tt>PXAction</tt> class or its descendants, you can use dependency injection as follows:[anchor|#_da9d1f0f-1baa-4399-a142-29b3ebea9d28]
#Define a custom action class as shown in the following code example.<source lang="csharp">using System;
using PX.Data;

namespace MyNamespace
{
    public class CustomCancel&lt;T&gt; : PXCancel&lt;T&gt; 
        where T: class, IBqlTable, new()
    {
        [InjectDependency]
        public IMyService Service { get; set; }

        //Other code of the custom action class
    }
}</source>
#To support dependency injection, in the implementation class of the service, add a constructor with <tt>PXAction</tt> or with both <tt>PXAction</tt> and <tt>PXGraph</tt> as parameters, as shown in the following code example.<source lang="csharp">public class MyService : IMyService
{
    <b>public MyService(PXAction parent) <b>
    { 
        //Code of the constructor
    }

    <b>public MyService(PXAction parent, PXGraph graph) <b>
    { 
        //Code of the constructor
    }

    //Other code of the implementation class
}</source>
]]></column>
			<column name="PlainText"><![CDATA[Dependency Injection In the code of  Acumatica Framework-based applications, you can use dependency injection to encapsulate particular                 logic as a service, which you can then use anywhere in your application. This                 technique can be used in graphs, attributes, and custom action classes, as described                     below. Dependency injection in  Acumatica Framework-based applications requires the use of the  Autofac.Module                      class, which is provided by the external  Autofac  library.  Acumatica does not guarantee the backward compatibility of this library. For details                     about the  Autofac  library, see  . Definition of the Service for Dependency Injection To define the service for dependency injection, you define an interface for the service and a                 class that implements this interface. The following example shows a definition of a                 service for dependency                 injection. using System;
using Autofac;
using PX.Data;

namespace MyNamespace
{
    //An interface for the service
    public interface IMyService
    {
        void ProvideServiceFunctions();
    }
    //A class that implements the interface
    public class MyService : IMyService
    {
        public void ProvideServiceFunctions()
        {
            //An implementation
        }
    }
} Registration of the Service To register the service in your application, you do the following: Implement a registration class derived from the  Autofac.Module        class. In this registration class, override the  Module.Load()  method. You do       not need to call the base method in the overriding method. You can register multiple implementations of an interface for the service in one                             registration class or multiple registration classes. To make it possible to override the service in a customization project, you should        register the service with  PreserveExistingDefaults() . The following code shows an example of a registration                 class. using System;
using Autofac;
using PX.Data;
namespace MyNamespace
{
    //A class that registers the implementation class with Autofac
    public class MyServiceRegistrarion : Module
    {
        protected override void Load(ContainerBuilder builder)
        {
            builder.RegisterType<MyService>().As<IMyService>();
        }
    }
} Dependency Injection in Graphs To use dependency injection in a graph, you define a property of the graph and assign the       InjectDependency  attribute to this property, as shown in the following     example. namespace MyNameSpace
{
    public class MyGraph : PXGraph<MyGraph>
    { 
        [InjectDependency]
        private IMyService MyService { get; set; }

        public PXAction<MyDAC> MyButton;
        [PXButton]
        [PXUIField(DisplayName ="My Action")]
        protected void myButton()
        {
            MyService.ProvideServiceFunctions();
        }

        // Other code of the graph
    }
} Dependency injection in graph constructors is not supported. The properties to which the  InjectDependency  attribute is assigned                         cannot be used in graph constructors. If you need to use these properties                         during the initialization of a graph, you need to implement the                              IGraphWithInitialization  interface in the graph. In                         the implementation of the                              IGraphWithInitialization.Initialize()  method, you can                         use the properties. Dependency Injection in Attributes For an attribute derived from  PXEventSubscriberAttribute , you use     dependency injection in the following way: Define an attribute class and assign to its property the         InjectDependency  attribute, as shown in the following code       example. using System;
using PX.Data;

namespace MyNamespace
{
    public class CustomAttribute : PXEventSubscriberAttribute
    {
        [InjectDependency]
        public IMyService Service { get; set; }
    }
} To support dependency injection in a constructor of the implementation class of the                         service, pass  PXEventSubscriberAttribute ,                              PXCache , or  PXGraph  (or any                         combination of these objects) in the constructor, as shown in the following                         code                         example. public class MyService : IMyService
{
    //A constructor with PXEventSubscriberAttribute
     public MyService(PXEventSubscriberAttribute parent)  
    { 
        //Code of the constructor
    }

    //A constructor with PXCache
     public MyService(PXCache cache) 
    { 
        //Code of the constructor
    }

    //A constructor with PXGraph
     public MyService(PXGraph graph) 
    { 
        //Code of the constructor
    }

    //A constructor with PXEventSubscriberAttribute and PXGraph
     public MyService(PXEventSubscriberAttribute parent, PXGraph graph) 
    { 
        //Code of the constructor
    }

    //Other code of the implementation class
} Dependency Injection in Custom Action Classes For a custom action class derived from the  PXAction  class or its     descendants, you can use dependency injection as follows: Define a custom action class as shown in the following code       example. using System;
using PX.Data;

namespace MyNamespace
{
    public class CustomCancel<T> : PXCancel<T> 
        where T: class, IBqlTable, new()
    {
        [InjectDependency]
        public IMyService Service { get; set; }

        //Other code of the custom action class
    }
} To support dependency injection, in the implementation class of the service, add a                         constructor with  PXAction  or with both                              PXAction  and  PXGraph  as                         parameters, as shown in the following code                         example. public class MyService : IMyService
{
     public MyService(PXAction parent)  
    { 
        //Code of the constructor
    }

     public MyService(PXAction parent, PXGraph graph)  
    { 
        //Code of the constructor
    }

    //Other code of the implementation class
} ]]></column>
		</row>
		<row PageID="bbc04253-7686-41dd-898b-aca47c1c6789" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="dd319429-593f-ad94-780c-6fc3ae61a58e" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Suppose that you want to use the same business logic in multiple places in your application. That is, you have at least two graphs in which you need to insert the logic. The graphs operate with data in the data access classes (DACs) and implement business logic through event handlers, actions, and other methods. {br}

You encapsulate the business logic that you want to reuse in a ''generic graph extension'', which is a graph extension that does not relate to any particular graph and can be used with any base graph. The generic graph extension operates with data by using the ''mapped cache extensions'', which are cache extensions that are not bound to any particular DAC and can extend any DAC.{br}

To connect the mapped cache extensions to a particular DAC, you use a ''mapping class'', which maps the fields of a mapped cache extension to the fields of a DAC. To connect the generic graph extension to a particular base graph, in the base graph, you define an ''implementation class'', which inherits the generic graph extension. The following diagram shows in yellow rectangles the classes that you need to implement to reuse the business logic.[anchor|#_43ec8f0d-cef8-49a4-8f37-ea69850d117c][anchor|#_e15a1ec8-ebfa-417b-89cd-053a2c5d0d31][image:StudioDeveloperGuide/Images/GenericGraphExtensionImplementation.png|popup|Required classes|450px]{br}

These classes are described in detail in the sections below. (For details on the implementation of the classes, see [HelpRoot_Dev_Platform\BL__how_Create_Reusable_Logic|To Implement Reusable Business Logic] and [HelpRoot_Dev_Platform\BL__how_Insert_Reusable_Business_Logic|To Insert Reusable Business Logic That Has Already Been Declared].){br}{TOC}[anchor|#_efcb1dec-e793-4a88-b333-e647c6ff2b5e]
==Mapped Cache Extension==
A mapped cache extension is an analog of a data access class (DAC) for a generic graph extension. In the mapped cache extension, you include the main fields that are used in the reusable business logic implementation. You map the fields of a mapped cache extension to the fields of a base DAC by using the mapping class, which is described in the following section. The mapped cache extension can also include the fields that are not mapped to any base DAC fields. (For details, see [HelpRoot_Dev_Platform\BL__con_Reusable_Logic_and_Database|Mapped Cache Extensions and the Application Database].){br}

The class of a mapped cache extension inherits from the <tt>PXMappedCacheExtension</tt>{{abstract}} class, which derives from <tt>PXCacheExtension</tt> and <tt>IBqlTable</tt>. {br}

The declaration of a field of a mapped cache extension includes the following two required members, which are the same as the required members of a DAC field:[anchor|#_e3cd30ae-59bd-4689-b74c-d85dc4f8af9e]
*A {{public abstract}} class (which is also referred to as ''class field'').
*:You derive the class from the <tt>IBqlField</tt> interface and assign it a name that starts with a lowercase letter. 
*A {{public virtual}} property (which is also referred to as ''property field'').
*:You assign the property a name that starts with an uppercase letter. The system assigns the [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b78b0a53-b9db-0693-66fa-7d2b432b9f38|<tt>PXMergeAttributes</tt>] attribute with <tt>MergeMethod.Merge</tt> to each field of a mapped cache extension automatically. If you define the <tt>PXMergeAttributes</tt> attribute for a field of a mapped cache extension explicitly, the explicitly defined attribute overrides the automatically defined. You can also define any other attributes for the property field of the mapped cache extension, or not define the attributes at all. 
{br}

The following code shows an example of a mapped cache extension.[anchor|#_5400f558-a1f5-4942-83e7-b197175e4ec6]<source lang="csharp">//Mapped cache extension
public class Document : PXMappedCacheExtension
{
  //BAccountID field
  public abstract class bAccountID : IBqlField
  {
  }
  protected Int32? _BAccountID;

  public virtual Int32? BAccountID
  {
    get
    {
      return _BAccountID;
    }
    set
    {
      _BAccountID = value;
    }
  }

  //CuryID field
  public abstract class curyID : IBqlField
  {
  }
  protected String _CuryID;

  public virtual String CuryID
  {
    get
    {
      return _CuryID;
    }
    set
    {
      _CuryID = value;
    }
  }

  ...
}</source>[anchor|#_07af458f-a094-4b51-8859-a8204ccb196e]
==Mapping Class==
A mapping class is a {{protected}} class that defines the mapping between the fields of a mapped cache extension and the fields of a DAC. In a generic graph extension, you declare a mapping class for each mapped cache extension that you need to use in the reusable logic implementation. {br}

A mapping class implements the <tt>IBqlMapping</tt> interface, which has the following two properties:[anchor|#_652c106e-e7ef-4aad-95da-aa2d133d77ae]
*<tt>Extension</tt>: The mapped cache extension
*<tt>Table</tt>: The DAC to which the extension is mapped
{br}

In the declaration of the mapping class, you also include declarations of the properties for each field of the mapped cache extension that you want to map to a field of the DAC, as the following code shows.[anchor|#_ef99d162-977b-4fa3-abdf-1c4868a3aab6]<source lang="csharp">//A mapping class
protected class DocumentMapping : IBqlMapping
{
  public Type Extension =&gt; typeof(Document);
  protected Type _table;
  public Type Table =&gt; _table;

  public DocumentMapping(Type table)
  {
    _table = table;
  }
  public Type BAccountID = typeof(Document.bAccountID);
  public Type CuryInfoID = typeof(Document.curyInfoID);
  public Type CuryID = typeof(Document.curyID);
  public Type DocumentDate = typeof(Document.documentDate);
}</source>{br}

If the name of a property field of the DAC is the same as the name of the mapping class property, the DAC field will be automatically mapped to the field of the mapped cache extension by the implementation class (which is described below). If the name of a property field of the DAC differs from the name of the mapping class field, you redefine the mapping manually in the implementation class. If no field in the DAC has the name of the mapping class field, and no mapping is defined in the implementation class, the field of the mapped cache extension is not mapped to any base DAC field, as shown in the following diagram.[anchor|#_f7b40bd5-e36d-4500-8207-902bd81b0876][anchor|#_914515bb-c9ea-4fac-bed9-cc8c1501171a][image:StudioDeveloperGuide/Images/MappingClass.png|popup|Mapping declaration|450px]
==Generic Graph Extension==
A generic graph extension is a {{public abstract}} class that encapsulates business logic that can be used in multiple places of an Acumatica ERP application or an Acumatica Framework-based application. The class inherits from the <tt>PXGraphExtension&lt;TGraph&gt;</tt> class, as the following code shows.[anchor|#_90e2c681-2fd8-4ad0-be2b-ce020492542a]<source lang="csharp">public abstract class MultiCurrencyGraph&lt;TGraph, TPrimary&gt; : 
  PXGraphExtension&lt;TGraph&gt;
    where TGraph : PXGraph
    where TPrimary : class, IBqlTable, new()
{
}</source>{br}

 In the generic graph extension, you declare the following items:[anchor|#_23fad20f-84ed-4d26-b5ae-8e9b7dcbc686]
*The mapping classes.
*The {{protected abstract}} methods that return the mapping classes. You have to override these methods in the implementation class.
*The views that can have either mapping-based declaration or standard declaration. You declare a mapping-based view by using the <tt>PXSelectExtension&lt;Table&gt;</tt> class.
*The event handlers, actions, and other methods.

==Implementation Class==
An implementation class defines the implementation of a generic graph extension for a particular graph. You declare the implementation class as a class that derives from the generic graph extension class with the following type parameters:[anchor|#_02a7771b-32de-4650-86f1-cbe267d53d30]
*The base graph to which you add reusable logic
*The main DAC of the primary data view of the base graph
{br}

In this class, you can override the mapping defined by the mapping class, override other the methods of the base class, and insert your own views, methods, and event handlers, as the following code shows.[anchor|#_e36e6384-88f7-47cb-9a84-29c87af3c82a]<source lang="csharp">public class MultiCurrency : MultiCurrencyGraph&lt;OpportunityMaint, CROpportunity&gt;
{   
  protected override DocumentMapping GetDocumentMapping()
  {
    return new DocumentMapping(typeof(CROpportunity)) 
    {
      DocumentDate =  typeof(CROpportunity.closeDate)
    };
  }  

  protected override CurySourceMapping GetCurySourceMapping()
  {
    return new CurySourceMapping(typeof(Customer));
  }

  public PXSelect&lt;CRSetup&gt; crCurrency;
  protected PXSelectExtension&lt;CurySource&gt; SourceSetup =&gt; 
   new PXSelectExtension&lt;CurySource&gt;(crCurrency);

  protected virtual CurySourceMapping GetSourceSetupMapping()
  { 
    return new CurySourceMapping(typeof(CRSetup)) 
    {
      CuryID = typeof(CRSetup.defaultCuryID), 
       CuryRateTypeID = typeof(CRSetup.defaultRateTypeID)
    };        
  }

  protected override CurySource CurrentSourceSelect()
  {
    ...
  }
}</source>
==Related Articles==
*[HelpRoot_Dev_Platform\BL__how_Insert_Reusable_Business_Logic|To Insert Reusable Business Logic That Has Already Been Declared]
*[HelpRoot_Dev_Platform\BL__how_Create_Reusable_Logic|To Implement Reusable Business Logic]]]></column>
			<column name="PlainText"><![CDATA[Reusable Business Logic Implementation Suppose that you want to use the same business logic in multiple places in your                 application. That is, you have at least two graphs in which you need to insert the                 logic. The graphs operate with data in the data access classes (DACs) and implement                 business logic through event handlers, actions, and other methods.  You encapsulate the business logic that you want to reuse in a  generic graph                     extension , which is a graph extension that does not relate to any particular                 graph and can be used with any base graph. The generic graph extension operates with                 data by using the  mapped cache extensions , which are cache extensions that                 are not bound to any particular DAC and can extend any DAC. To connect the mapped cache extensions to a particular DAC, you use a  mapping                     class , which maps the fields of a mapped cache extension to the fields of a                 DAC. To connect the generic graph extension to a particular base graph, in the base                 graph, you define an  implementation class , which inherits the generic graph                 extension. The following diagram shows in yellow rectangles the classes that you                 need to implement to reuse the business logic. Required classes These classes are described in detail in the sections below. (For details on the                 implementation of the classes, see  To Implement Reusable Business Logic and  To Insert Reusable Business Logic That Has Already Been Declared.) Mapped Cache Extension A mapped cache extension is an analog of a data access class (DAC) for a generic                 graph extension. In the mapped cache extension, you include the main fields that are                 used in the reusable business logic implementation. You map the fields of a mapped                 cache extension to the fields of a base DAC by using the mapping class, which is                 described in the following section. The mapped cache extension can also include the                 fields that are not mapped to any base DAC fields. (For details, see  Mapped Cache Extensions and the Application Database.) The class of a mapped cache extension inherits from the                      PXMappedCacheExtension abstract  class, which derives from                      PXCacheExtension  and  IBqlTable .  The declaration of a field of a mapped cache extension includes the following two                 required members, which are the same as the required members of a DAC field: A  public abstract  class (which is also referred to as                              class field ). You derive the class from the                                  IBqlField  interface and assign it a name that                             starts with a lowercase letter.  A  public virtual  property (which is also referred to as                              property field ). You assign the property a name that starts                                 with an uppercase letter. The system assigns the  PXMergeAttributes <tt>PXMergeAttributes</tt>                             attribute with  MergeMethod.Merge  to each field of a                             mapped cache extension automatically. If you define the                                  PXMergeAttributes  attribute for a field of a                             mapped cache extension explicitly, the explicitly defined attribute                             overrides the automatically defined. You can also define any other                             attributes for the property field of the mapped cache extension, or not                             define the attributes at all.  The following code shows an example of a mapped cache                 extension. //Mapped cache extension
public class Document : PXMappedCacheExtension
{
  //BAccountID field
  public abstract class bAccountID : IBqlField
  {
  }
  protected Int32? _BAccountID;

  public virtual Int32? BAccountID
  {
    get
    {
      return _BAccountID;
    }
    set
    {
      _BAccountID = value;
    }
  }

  //CuryID field
  public abstract class curyID : IBqlField
  {
  }
  protected String _CuryID;

  public virtual String CuryID
  {
    get
    {
      return _CuryID;
    }
    set
    {
      _CuryID = value;
    }
  }

  ...
} Mapping Class A mapping class is a  protected  class that defines the mapping                 between the fields of a mapped cache extension and the fields of a DAC. In a generic                 graph extension, you declare a mapping class for each mapped cache extension that                 you need to use in the reusable logic implementation.  A mapping class implements the  IBqlMapping  interface, which has                 the following two properties: Extension : The mapped cache extension Table : The DAC to which the extension is mapped In the declaration of the mapping class, you also include declarations of the                 properties for each field of the mapped cache extension that you want to map to a                 field of the DAC, as the following code                 shows. //A mapping class
protected class DocumentMapping : IBqlMapping
{
  public Type Extension => typeof(Document);
  protected Type _table;
  public Type Table => _table;

  public DocumentMapping(Type table)
  {
    _table = table;
  }
  public Type BAccountID = typeof(Document.bAccountID);
  public Type CuryInfoID = typeof(Document.curyInfoID);
  public Type CuryID = typeof(Document.curyID);
  public Type DocumentDate = typeof(Document.documentDate);
} If the name of a property field of the DAC is the same as the name of the mapping                 class property, the DAC field will be automatically mapped to the field of the                 mapped cache extension by the implementation class (which is described below). If                 the name of a property field of the DAC differs from the name of the mapping class                 field, you redefine the mapping manually in the implementation class. If no field in                 the DAC has the name of the mapping class field, and no mapping is defined in the                 implementation class, the field of the mapped cache extension is not mapped to any                 base DAC field, as shown in the following diagram. Mapping declaration Generic Graph Extension A generic graph extension is a  public abstract  class that                 encapsulates business logic that can be used in multiple places of an  Acumatica ERP application or an  Acumatica Framework-based application. The class inherits from the                      PXGraphExtension<TGraph>  class, as the following code                 shows. public abstract class MultiCurrencyGraph<TGraph, TPrimary> : 
  PXGraphExtension<TGraph>
    where TGraph : PXGraph
    where TPrimary : class, IBqlTable, new()
{
}  In the generic graph extension, you declare the following items: The mapping classes. The  protected abstract  methods that return the mapping                         classes. You have to override these methods in the implementation                         class. The views that can have either mapping-based declaration or standard                         declaration. You declare a mapping-based view by using the                              PXSelectExtension<Table>  class. The event handlers, actions, and other methods. Implementation Class An implementation class defines the implementation of a generic graph extension for a                 particular graph. You declare the implementation class as a class that derives from                 the generic graph extension class with the following type parameters: The base graph to which you add reusable logic The main DAC of the primary data view of the base graph In this class, you can override the mapping defined by the mapping class, override                 other the methods of the base class, and insert your own views, methods, and event                 handlers, as the following code                 shows. public class MultiCurrency : MultiCurrencyGraph<OpportunityMaint, CROpportunity>
{   
  protected override DocumentMapping GetDocumentMapping()
  {
    return new DocumentMapping(typeof(CROpportunity)) 
    {
      DocumentDate =  typeof(CROpportunity.closeDate)
    };
  }  

  protected override CurySourceMapping GetCurySourceMapping()
  {
    return new CurySourceMapping(typeof(Customer));
  }

  public PXSelect<CRSetup> crCurrency;
  protected PXSelectExtension<CurySource> SourceSetup => 
   new PXSelectExtension<CurySource>(crCurrency);

  protected virtual CurySourceMapping GetSourceSetupMapping()
  { 
    return new CurySourceMapping(typeof(CRSetup)) 
    {
      CuryID = typeof(CRSetup.defaultCuryID), 
       CuryRateTypeID = typeof(CRSetup.defaultRateTypeID)
    };        
  }

  protected override CurySource CurrentSourceSelect()
  {
    ...
  }
} ]]></column>
		</row>
		<row PageID="cda07180-43aa-4b2e-9370-534336beb620" Language="en-US" PageRevisionID="1" PlainText="Mapped Cache Extensions and the Application Database The fields of a mapped cache extension that are mapped to the fields of a base data access    class (DAC) are used by the system to work with the database columns to which the fields of the    base DAC are bound.  If a mapped cache extension includes fields that are bound to database columns (with the type    attributes that are derived from the  PXDBFieldAttribute  class, such as      PXDBString ), the database table that corresponds to the base DAC must contain    these fields of the mapped cache extension. That is, the database table must include the fields    bound to a database column that are defined both in the base DAC and the mapped cache extension,    as shown in the following diagram. Database schema for a DAC and mapped cache extension " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="a592056a-e99b-9508-b36a-8a965c7b913f" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The fields of a mapped cache extension that are mapped to the fields of a base data access class (DAC) are used by the system to work with the database columns to which the fields of the base DAC are bound. {br}

If a mapped cache extension includes fields that are bound to database columns (with the type attributes that are derived from the <tt>PXDBFieldAttribute</tt> class, such as <tt>PXDBString</tt>), the database table that corresponds to the base DAC must contain these fields of the mapped cache extension. That is, the database table must include the fields bound to a database column that are defined both in the base DAC and the mapped cache extension, as shown in the following diagram.[anchor|#_c6c94e56-bb23-4c22-9586-9c5fa9a782c7][anchor|#_ad79f500-d887-4c35-8a0a-b9a00c44369d][image:StudioDeveloperGuide/Images/DatabaseSchemaForDACwithMCE.png|popup|Database schema for a DAC and mapped cache extension|450px]
==Related Articles==
*[HelpRoot_Dev_Platform\BL__con_Generic_Extensions|Reusable Business Logic Implementation]]]></column>
		</row>
		<row PageID="56b9b5ae-bc64-4e91-8aa5-8b17894d886a" Language="en-US" PageRevisionID="1" PlainText="Reusable Business Logic and the Application Website If the field of a mapped cache extension is mapped to a field of the base data access class             (DAC), you can use the merged field (that is, the base field that has merged attributes             of the base field and the mapped cache extension field) to configure the UI elements of             the website page. If the field of the mapped cache extension is not mapped to a field of             the base DAC, you can use the field of the mapped cache extension in the website page,             as shown in the following diagram. Fields on the website page The actions that are defined in the base graph, generic graph extension, and implementation       class are automatically added by the system on the website page, as shown in the following       diagram. The implementation class can override the actions declared in the generic graph         extension. Actions on a website page " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ae4a33d1-ce42-4085-a957-d4cbd0ad00bb" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If the field of a mapped cache extension is mapped to a field of the base data access class (DAC), you can use the merged field (that is, the base field that has merged attributes of the base field and the mapped cache extension field) to configure the UI elements of the website page. If the field of the mapped cache extension is not mapped to a field of the base DAC, you can use the field of the mapped cache extension in the website page, as shown in the following diagram.[anchor|#_60f05de4-dcc9-403c-b735-4155b3615734][anchor|#_b45e1e98-3b40-40d0-84d7-0ccf0243c62f][image:StudioDeveloperGuide/Images/GenericGraphExtensions_FieldsOnWebPage.png|popup|Fields on the website page|450px]{br}

The actions that are defined in the base graph, generic graph extension, and implementation class are automatically added by the system on the website page, as shown in the following diagram. The implementation class can override the actions declared in the generic graph extension.[anchor|#_e41a7eee-e129-448e-a0c0-0763d2f0b046][anchor|#_cc6a313c-1057-49a8-96a1-af60780f64ba][image:StudioDeveloperGuide/Images/GenericGraphExtensions_ActionsOnWebPage.png|popup|Actions on a website page|450px]]]></column>
		</row>
		<row PageID="eece8358-f6ea-47e8-899a-d466eccbc14e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="3015d5bd-55a3-d021-0f52-e2b4b792e7c4" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you will learn how Acumatica ERP or an Acumatica Framework-based application works with generic graph extensions. 
==Initialization of a Graph Instance That Includes Reusable Logic==
During the initialization of a graph instance that includes reusable logic, the system adds to the collection of data views the data views that are declared in the base graph, including those that are declared in the implementation class or the generic graph extension from which the implementation class inherits. The mapping classes define the <tt>PXCache&lt;Table&gt;</tt> objects in which the mapping-based views keep data records.{br}

Event handlers that are declared in the base graph, implementation class, and generic graph extension are added by the system to the collections of event handlers in the corresponding <tt>PXCache</tt> object. The event handlers defined for the fields or rows of the mapped cache extension are added to the <tt>PXCache</tt> object of the base DAC type to which the mapped cache extension is mapped. {br}

The following diagram illustrates the initialization of a sample {{OpportunityMaint}} graph instance that includes reusable logic.[anchor|#_7ab9179e-c6fc-44be-a48a-939e955baa38][anchor|#_d3b46784-57fb-4047-b0eb-587d56bc3faf][image:StudioDeveloperGuide/Images/GenericGraphExtension_GraphInstance.png|popup|Intitialization of a graph instance|450px]]]></column>
			<column name="PlainText"><![CDATA[Use of Generic Graph Extensions by the System In this topic, you will learn how  Acumatica ERP     or an  Acumatica Framework-based     application works with generic graph extensions.  Initialization of a Graph Instance That Includes Reusable Logic During the initialization of a graph instance that includes reusable logic, the system adds to         the collection of data views the data views that are declared in the base graph, including         those that are declared in the implementation class or the generic graph extension from         which the implementation class inherits. The mapping classes define the            PXCache<Table>  objects in which the mapping-based views keep data         records. Event handlers that are declared in the base graph, implementation class, and generic graph         extension are added by the system to the collections of event handlers in the corresponding            PXCache  object. The event handlers defined for the fields or rows of         the mapped cache extension are added to the  PXCache  object of the base         DAC type to which the mapped cache extension is mapped.  The following diagram illustrates the initialization of a sample            OpportunityMaint  graph instance that includes reusable logic. Intitialization of a graph instance ]]></column>
		</row>
		<row PageID="0fd80806-d566-405c-b8cf-58ec58336b1f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="29b2b892-7a32-8e73-6d78-72bf0b72a465" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The source code of Acumatica ERP includes the definitions of the generic graph extensions, which are described in detail in the following sections. These graph extensions are declared in the <tt>PX.Objects.Extensions</tt> namespace. You can use these generic graph extensions if you want to include the implemented functionality in the forms of your application. For details on how to include this functionality in your application, see [HelpRoot_Dev_Platform\BL__how_Insert_Reusable_Business_Logic|To Insert Reusable Business Logic That Has Already Been Declared].{br}{TOC}
==Multicurrency Extension==
If you need to work with multiple currencies on a form, you can insert an implementation of the <tt>MultiCurrencyGraph&lt;TGraph, TPrimary&gt;</tt>{{abstract}} class in the graph that provides business logic for the form. For more information on the use of multiple currencies in the system, see [HelpRoot_Financials\CM_00_00_00|Currency Management] in the Financial Management Guide.{br}

The <tt>MultiCurrencyGraph&lt;TGraph, TPrimary&gt;</tt> class works with the following mapped cache extensions:[anchor|#_5f840836-aecb-4cfb-b648-1ee0679cda9d]
*<tt>Document</tt>: Represents a document that supports multicurrency
*<tt>CurySource</tt>: Contains the information on the currency source
{br}

For more information on these classes, see the API Reference.
==Sales Price Extension==
If you need to work with multiple price lists on a form, you can insert an implementation of the <tt>SalesPriceGraph&lt;TGraph, TPrimary&gt;</tt>{{abstract}} class in the graph that provides business logic for the form. For more information on sales prices, see [HelpRoot_PricesAndDiscounts\PriceDiscount_Review_Sales_Prices_Mapref|Reviewing Sales Prices] in the Prices and Discounts Guide.{br}

The <tt>SalesPriceGraph&lt;TGraph, TPrimary&gt;</tt> class works with the following mapped cache extensions:[anchor|#_1efc97ac-24c9-441f-bd77-4ed82147b252]
*<tt>Document</tt>: Represents a document that supports multiple price lists
*<tt>Detail</tt>: Represents a detail line of the document
*<tt>PriceClassSource</tt>: Provides information about the source of the price class
 For more information on these classes, see the API Reference.
==Discount Extension==
If you need to work with discounts on a form, you can insert an implementation of the <tt>DiscountGraph&lt;TGraph, TPrimary&gt;</tt>{{abstract}} class in the graph that provides business logic for the form. For more information on discounts, see [HelpRoot_PricesAndDiscounts\PriceDiscount_Review_Customer_Discounts_Mapref|Configuring and Applying Customer Discounts] in the Prices and Discounts Guide.{br}

The <tt>DiscountGraph&lt;TGraph, TPrimary&gt;</tt> class works with the following mapped cache extensions:[anchor|#_8412b85f-e324-4624-b493-1e57b495d7a4]
*<tt>Document</tt>: Represents a document that supports discounts
*<tt>Detail</tt>: Represents a detail line of the document
*<tt>Discount</tt>: Provides information about the discount
{br}

For details on these classes, see the API Reference.
==Sales Tax Extension==
If you need to apply sales taxes to amounts of a form, you can insert an implementation of the <tt>TaxGraph&lt;TGraph, TPrimary&gt;</tt>{{abstract}} class in the graph that provides business logic for the form. For more information on taxes in the system, see [HelpRoot_Financials\TX_00_00_00|Taxes] in the Financial Management Guide.{br}

The <tt>TaxGraph&lt;TGraph, TPrimary&gt;</tt> class works with the following mapped cache extensions:[anchor|#_1442e3e4-724e-480b-97eb-c18a07fb57e6]
*<tt>Document</tt>: Represents a document that supports sales taxes.
*<tt>Detail</tt>: Represents a detail line of the document.
*<tt>TaxTotal</tt>: Represents the tax total amount
*<tt>TaxDetail</tt>: Represents a tax detail line
{br}

For detailed descriptions of the classes, see the API Reference.
==Related Articles==
*[HelpRoot_Dev_Platform\BL__how_Insert_Reusable_Business_Logic|To Insert Reusable Business Logic That Has Already Been Declared]]]></column>
			<column name="PlainText"><![CDATA[Generic Graph Extensions Declared in  Acumatica ERPThe source code of  Acumatica ERP includes the definitions of the generic graph extensions, which are described in detail         in the following sections. These graph extensions are declared in the            PX.Objects.Extensions  namespace. You can use these generic graph         extensions if you want to include the implemented functionality in the forms of your         application. For details on how to include this functionality in your application, see  To Insert Reusable Business Logic That Has Already Been Declared. Multicurrency Extension If you need to work with multiple currencies on a form, you can insert an implementation of         the  MultiCurrencyGraph<TGraph, TPrimary> abstract  class in the graph that provides business logic for the form. For         more information on the use of multiple currencies in the system, see   ([~/?ScreenId=CM000000|CM000000]) Currency Management in the Financial Management Guide. The  MultiCurrencyGraph<TGraph, TPrimary>  class works with the         following mapped cache extensions: Document : Represents a document that supports multicurrency CurySource : Contains the information on the currency source For more information on these classes, see the API Reference. Sales Price Extension If you need to work with multiple price lists on a form, you can insert an implementation         of the  SalesPriceGraph<TGraph, TPrimary> abstract  class in the graph that provides business logic for the form. For         more information on sales prices, see  Reviewing Sales Prices in the Prices and         Discounts Guide. The  SalesPriceGraph<TGraph, TPrimary>  class works with the following         mapped cache extensions: Document : Represents a document that supports multiple price             lists Detail : Represents a detail line of the document PriceClassSource : Provides information about the source of the             price class  For more information on these classes, see the API Reference. Discount Extension If you need to work with discounts on a form, you can insert an implementation of the            DiscountGraph<TGraph, TPrimary> abstract  class in the graph that provides business logic for the form. For         more information on discounts, see  Configuring and Applying Customer Discounts in the Prices         and Discounts Guide. The  DiscountGraph<TGraph, TPrimary>  class works with the following         mapped cache extensions: Document : Represents a document that supports discounts Detail : Represents a detail line of the document Discount : Provides information about the discount For details on these classes, see the API Reference. Sales Tax Extension If you need to apply sales taxes to amounts of a form, you can insert an implementation of         the  TaxGraph<TGraph, TPrimary> abstract  class in the graph that provides business logic for the form. For         more information on taxes in the system, see   ([~/?ScreenId=TX000000|TX000000]) Taxes in         the Financial Management Guide. The  TaxGraph<TGraph, TPrimary>  class works with the following mapped         cache extensions: Document : Represents a document that supports sales taxes. Detail : Represents a detail line of the document. TaxTotal : Represents the tax total amount TaxDetail : Represents a tax detail line For detailed descriptions of the classes, see the API Reference. ]]></column>
		</row>
		<row PageID="c9249c85-d703-4124-a376-bea0dd56c54e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="1a8e35be-f002-e985-0751-b2bd104203ae" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can find information about how to insert an already-declared generic graph extension in the application code.
==To Add a Generic Graph Extension to a Graph==[anchor|#_359459df-c5aa-4d02-8c9f-cdf1e2c4ec2b]
#Review the generic graph extension that provides the business logic that you want to reuse as follows:
##Identify the mapped cache extensions the generic graph extension works with and the list of their fields, and decide whether the default mapping (which is defined by the mapping class of the generic graph extension) is suitable for the base data access class (DAC) that you are going to use.
##Identify the fields of the mapped cache extension that are bound to columns of a database table, and make sure the database table that corresponds to the base DAC includes the columns to store the data from the mapped cache extension.
#In the code of the graph you need to add the reusable business logic to, add the public implementation class that derives from the generic graph extension of the needed type. Use the following types in the type parameters of the generic graph extension:
#*The base graph to which you add reusable logic
#*The main DAC of the primary data view of the base graphIn the following code, the {{MultiCurrency}} class extends the {{OpportunityMaint}} graph. The {{MultiCurrency}} class derives from {{public abstract class MultiCurrencyGraph<TGraph, TPrimary> : PXGraphExtension<TGraph>}}.<source lang="csharp">public class MultiCurrency : MultiCurrencyGraph&lt;OpportunityMaint, CROpportunity&gt;
{
}</source>
#In the added class, override the {{abstract}} methods of the generic graph extension as follows:
#*In the overridden methods of the generic graph extension that return the mapping classes, either use the default mapping of the fields of the mapped cache extension to the fields of the base DAC or adjust the mapping. 
#*In the other overridden methods, implement the required business logic. For details on the implementation of the methods in the generic graph extension declared in Acumatica ERP, see API Reference.
#In the added class, adjust the reused business logic by doing any of the following:
#*Override other methods of the base class.
#*Add your own views, methods, and event handlers.
#:The following code shows a sample implementation of the {{MultiCurrency}} class, which reuses the multicurrency business logic defined in the <tt>MultiCurrencyGraph</tt> generic graph extension.[anchor|#_db089089-2442-419c-8a30-a897a6e9fcd4]<source lang="csharp">public class MultiCurrency : MultiCurrencyGraph&lt;OpportunityMaint, CROpportunity&gt;
{   
  protected override DocumentMapping GetDocumentMapping()
  {
    return new DocumentMapping(typeof(CROpportunity)) 
    {
      DocumentDate =  typeof(CROpportunity.closeDate)
    };
  }  

  protected override CurySourceMapping GetCurySourceMapping()
  {
    return new CurySourceMapping(typeof(Customer));
  }

  public PXSelect&lt;CRSetup&gt; crCurrency;
  protected PXSelectExtension&lt;CurySource&gt; SourceSetup =&gt; 
   new PXSelectExtension&lt;CurySource&gt;(crCurrency);

  protected virtual CurySourceMapping GetSourceSetupMapping()
  { 
    return new CurySourceMapping(typeof(CRSetup)) 
    {
      CuryID = typeof(CRSetup.defaultCuryID), 
       CuryRateTypeID = typeof(CRSetup.defaultRateTypeID)
    };        
  }

  protected override CurySource CurrentSourceSelect()
  {
    ...
  }
}</source>
]]></column>
			<column name="PlainText"><![CDATA[To Insert Reusable Business Logic That Has Already Been Declared In this topic, you can find information about how to insert an already-declared                 generic graph extension in the application code. To Add a Generic Graph Extension to a Graph Review the generic graph extension that provides the business logic that you                     want to reuse as follows: Identify the mapped cache extensions the generic graph extension works                             with and the list of their fields, and decide whether the default                             mapping (which is defined by the mapping class of the generic graph                             extension) is suitable for the base data access class (DAC) that you are                             going to use. Identify the fields of the mapped cache extension that are bound to                             columns of a database table, and make sure the database table that                             corresponds to the base DAC includes the columns to store the data from                             the mapped cache extension. In the code of the graph you need to add the reusable business logic to, add the                     public implementation class that derives from the generic graph extension of the                     needed type. Use the following types in the type parameters of the generic graph                         extension: The base graph to which you add reusable logic The main DAC of the primary data view of the base graph In the following code, the  MultiCurrency  class extends the                          OpportunityMaint  graph. The  MultiCurrency                      class derives from  public abstract class MultiCurrencyGraph<TGraph,                         TPrimary> :                     PXGraphExtension<TGraph> . public class MultiCurrency : MultiCurrencyGraph<OpportunityMaint, CROpportunity>
{
} In the added class, override the  abstract  methods of the                     generic graph extension as follows: In the overridden methods of the generic graph extension that return the                             mapping classes, either use the default mapping of the fields of the                             mapped cache extension to the fields of the base DAC or adjust the                             mapping.  In the other overridden methods, implement the required business logic.                             For details on the implementation of the methods in the generic graph                             extension declared in  Acumatica ERP, see API Reference. In the added class, adjust the reused business logic by doing any of the                         following: Override other methods of the base class. Add your own views, methods, and event handlers. The following code shows a sample implementation of the                              MultiCurrency  class, which reuses the multicurrency                         business logic defined in the  MultiCurrencyGraph  generic                         graph                         extension. public class MultiCurrency : MultiCurrencyGraph<OpportunityMaint, CROpportunity>
{   
  protected override DocumentMapping GetDocumentMapping()
  {
    return new DocumentMapping(typeof(CROpportunity)) 
    {
      DocumentDate =  typeof(CROpportunity.closeDate)
    };
  }  

  protected override CurySourceMapping GetCurySourceMapping()
  {
    return new CurySourceMapping(typeof(Customer));
  }

  public PXSelect<CRSetup> crCurrency;
  protected PXSelectExtension<CurySource> SourceSetup => 
   new PXSelectExtension<CurySource>(crCurrency);

  protected virtual CurySourceMapping GetSourceSetupMapping()
  { 
    return new CurySourceMapping(typeof(CRSetup)) 
    {
      CuryID = typeof(CRSetup.defaultCuryID), 
       CuryRateTypeID = typeof(CRSetup.defaultRateTypeID)
    };        
  }

  protected override CurySource CurrentSourceSelect()
  {
    ...
  }
} ]]></column>
		</row>
		<row PageID="28785249-a875-492f-bca9-82da9cd5c0b4" Language="en-US" PageRevisionID="1" Content="&#xA;If you need to add multiple generic graph extensions to a graph, you need to define the order in which the extensions are applied.{br}&#xA;&#xA;To define the order in which the generic graph extensions are applied, add the class inherited from the {{Autofac.Module}} class and implement the sorting of the generic class extensions, as the following code shows.&lt;source lang=&quot;csharp&quot;&gt;public class ServiceRegistration : Module&#xA;{&#xA;  protected override void Load(ContainerBuilder builder)&#xA;  {&#xA;    builder.ActivateOnApplicationStart&amp;lt;ExtensionSorting&amp;gt;();&#xA;  }&#xA;  private class ExtensionSorting&#xA;  {&#xA;    private static readonly Dictionary&amp;lt;Type, int&amp;gt; _order = new Dictionary&amp;lt;Type, int&amp;gt;&#xA;    {&#xA;      {typeof(MultiCurrency), 4},&#xA;      {typeof(SalesPrice), 3},&#xA;      {typeof(Discount), 2},&#xA;      {typeof(SalesTax), 1},&#xA;    };&#xA;    public ExtensionSorting()&#xA;    {&#xA;      ...&#xA;    }&#xA;  }&#xA;}&lt;/source&gt;" PlainText="To Sort Multiple Generic Graph Extensions If you need to add multiple generic graph extensions to a graph, you need to define the order     in which the extensions are applied. To define the order in which the generic graph extensions are applied, add the class inherited         from the  Autofac.Module  class and implement the sorting of the generic         class extensions, as the following code         shows. public class ServiceRegistration : Module&#xA;{&#xA;  protected override void Load(ContainerBuilder builder)&#xA;  {&#xA;    builder.ActivateOnApplicationStart&lt;ExtensionSorting&gt;();&#xA;  }&#xA;  private class ExtensionSorting&#xA;  {&#xA;    private static readonly Dictionary&lt;Type, int&gt; _order = new Dictionary&lt;Type, int&gt;&#xA;    {&#xA;      {typeof(MultiCurrency), 4},&#xA;      {typeof(SalesPrice), 3},&#xA;      {typeof(Discount), 2},&#xA;      {typeof(SalesTax), 1},&#xA;    };&#xA;    public ExtensionSorting()&#xA;    {&#xA;      ...&#xA;    }&#xA;  }&#xA;} " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="47820c73-8e1d-abc1-2f5b-18c412259bfd" RecordSourceID="22377" />
		<row PageID="0ff30b0e-e5a6-4211-ac29-85d996824d9d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="5e9a577e-038a-edb1-9b16-dae21425db52" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you need to use the same business logic in multiple modules of your Acumatica ERP application or an Acumatica Framework-based application and this logic is not included in the source code of Acumatica ERP, you can define your own generic graph extensions, as described in this topic. For the list of the predefined generic graph extensions, see [HelpRoot_Dev_Platform\BL__con_Implemented_Generic_Extensions|Generic Graph Extensions Declared in Acumatica ERP].
==To Create a Generic Graph Extension==[anchor|#_8dd8ad90-5da9-470d-b74d-11cfb26d1e27]
#In the code of your application, define the mapped cache extensions, which inherit from the <tt>PXMappedCacheExtension</tt>{{abstract}} class. For details on the mapped cache extensions, see [HelpRoot_Dev_Platform\BL__con_Generic_Extensions#_efcb1dec-e793-4a88-b333-e647c6ff2b5e|Mapped Cache Extension].<source lang="csharp">//Mapped cache extension
public class Document : PXMappedCacheExtension
{
  //BAccountID field
  public abstract class bAccountID : IBqlField
  {
  }
  protected Int32? _BAccountID;

  public virtual Int32? BAccountID
  {
    get
    {
      return _BAccountID;
    }
    set
    {
      _BAccountID = value;
    }
  }

  //CuryID field
  public abstract class curyID : IBqlField
  {
  }
  protected String _CuryID;

  public virtual String CuryID
  {
    get
    {
      return _CuryID;
    }
    set
    {
      _CuryID = value;
    }
  }

  ...
}</source>
#In the code of your application, define the generic graph extension as follows:
##Define a class inherited from the <tt>PXGraphExtension&lt;TGraph&gt;</tt> class. The following code shows a declaration of a generic graph extension. <source lang="csharp">public abstract class MultiCurrencyGraph&lt;TGraph, TPrimary&gt; : 
  PXGraphExtension&lt;TGraph&gt;
    where TGraph : PXGraph
    where TPrimary : class, IBqlTable, new()
{
}</source>
##In the generic graph extension, for each mapped cache extension that you defined in the first step, declare the {{protected}} mapping class, as shown in the following code. For details on the mapping classes, see [HelpRoot_Dev_Platform\BL__con_Generic_Extensions#_07af458f-a094-4b51-8859-a8204ccb196e|Mapping Class].<source lang="csharp">//A mapping class
protected class DocumentMapping : IBqlMapping
{
  public Type Extension =&gt; typeof(Document);
  protected Type _table;
  public Type Table =&gt; _table;

  public DocumentMapping(Type table)
  {
    _table = table;
  }
  public Type BAccountID = typeof(Document.bAccountID);
  public Type CuryInfoID = typeof(Document.curyInfoID);
  public Type CuryID = typeof(Document.curyID);
  public Type DocumentDate = typeof(Document.documentDate);
}</source>
##In the generic graph extension, for each mapping class, declare the {{protected abstract}} method that returns the mapping class, as shown in the following code.<source lang="charp">protected abstract DocumentMapping GetDocumentMapping();</source>
##In the generic graph extension, define the views that use the mapped cache extensions, as the following code shows. To define each view, you use the <tt>PXSelectExtension&lt;Table&gt; : PXSelectBase&lt;Table&gt;</tt> class, where <tt>Table</tt> is a mapped cache extension.<source lang="csharp">//A view that uses the mapped cache extension
public PXSelectExtension&lt;Document&gt; Documents;</source>
##:((({S:Warn}In the generic graph extension, you can define standard views as well as the views that use the mapped cache extensions.
)))
##In the generic graph extension, define the reusable event handlers, as the following code shows.<source lang="csharp">protected virtual void _(
  Events.FieldUpdated2&lt;Document.documentDate, Document&gt; e)
{
  if (e.Row == null) return;
  CurrencyInfoAttribute.SetEffectiveDate&lt;Document.documentDate&gt;(
    Documents.Cache, 
    new PXFieldUpdatedEventArgs(e.Row, e.OldValue, e.ExternalCall));            
}</source>
##In the generic graph extension, implement any other business logic that you want to reuse, such as filters and actions.

Once you have defined the mapped cache extensions and the generic graph extension, you can insert reusable business logic to any part of your application, as described in [HelpRoot_Dev_Platform\BL__how_Insert_Reusable_Business_Logic|To Insert Reusable Business Logic That Has Already Been Declared].]]></column>
			<column name="PlainText"><![CDATA[To Implement Reusable Business Logic If you need to use the same business logic in multiple modules of your  Acumatica ERP application or an  Acumatica Framework-based application and this logic is not included in the source code of  Acumatica ERP, you can define your own generic graph extensions, as described in this topic.                 For the list of the predefined generic graph extensions, see  Generic Graph Extensions Declared in Acumatica ERP. To Create a Generic Graph Extension In the code of your application, define the mapped cache extensions, which                     inherit from the  PXMappedCacheExtension abstract  class. For details on the mapped cache extensions, see                          Mapped Cache Extension. //Mapped cache extension
public class Document : PXMappedCacheExtension
{
  //BAccountID field
  public abstract class bAccountID : IBqlField
  {
  }
  protected Int32? _BAccountID;

  public virtual Int32? BAccountID
  {
    get
    {
      return _BAccountID;
    }
    set
    {
      _BAccountID = value;
    }
  }

  //CuryID field
  public abstract class curyID : IBqlField
  {
  }
  protected String _CuryID;

  public virtual String CuryID
  {
    get
    {
      return _CuryID;
    }
    set
    {
      _CuryID = value;
    }
  }

  ...
} In the code of your application, define the generic graph extension as                         follows: Define a class inherited from the                                  PXGraphExtension<TGraph>  class. The following                             code shows a declaration of a generic graph extension.                              public abstract class MultiCurrencyGraph<TGraph, TPrimary> : 
  PXGraphExtension<TGraph>
    where TGraph : PXGraph
    where TPrimary : class, IBqlTable, new()
{
} In the generic graph extension, for each mapped cache extension that you                             defined in the first step, declare the  protected                              mapping class, as shown in the following code. For details on the                             mapping classes, see  Mapping Class. //A mapping class
protected class DocumentMapping : IBqlMapping
{
  public Type Extension => typeof(Document);
  protected Type _table;
  public Type Table => _table;

  public DocumentMapping(Type table)
  {
    _table = table;
  }
  public Type BAccountID = typeof(Document.bAccountID);
  public Type CuryInfoID = typeof(Document.curyInfoID);
  public Type CuryID = typeof(Document.curyID);
  public Type DocumentDate = typeof(Document.documentDate);
} In the generic graph extension, for each mapping class, declare the                                  protected abstract  method that returns the mapping                             class, as shown in the following                             code. protected abstract DocumentMapping GetDocumentMapping(); In the generic graph extension, define the views that use the mapped                             cache extensions, as the following code shows. To define each view, you                             use the  PXSelectExtension<Table> :                                 PXSelectBase<Table>  class, where                                  Table  is a mapped cache                                 extension. //A view that uses the mapped cache extension
public PXSelectExtension<Document> Documents; In                                 the generic graph extension, you can define standard views as well                                 as the views that use the mapped cache extensions. In the generic graph extension, define the reusable event handlers, as                             the following code                             shows. protected virtual void _(
  Events.FieldUpdated2<Document.documentDate, Document> e)
{
  if (e.Row == null) return;
  CurrencyInfoAttribute.SetEffectiveDate<Document.documentDate>(
    Documents.Cache, 
    new PXFieldUpdatedEventArgs(e.Row, e.OldValue, e.ExternalCall));            
} In the generic graph extension, implement any other business logic that                             you want to reuse, such as filters and actions. Once you have defined the mapped cache extensions and the generic graph extension,                 you can insert reusable business logic to any part of your application, as described                 in  To Insert Reusable Business Logic That Has Already Been Declared. ]]></column>
		</row>
		<row PageID="171000fe-a5ab-4c1f-b61b-7b1f6b0eadcd" Language="en-US" PageRevisionID="1" Content="In this part of the guide, you can find information about troubleshooting the applications based on Acumatica Framework.&#xA;==In This Part==[anchor|#_18673b71-74f1-4b41-9d06-4b2806d1d36e]&#xA;*[HelpRoot_Dev_Platform\TS__how_Debug_Application|To Debug Acumatica Framework-Based Applications]&#xA;" PlainText="Troubleshooting  Acumatica Framework-Based   Applications In this part of the guide, you can find information about troubleshooting the    applications based on  Acumatica Framework. In This Part To Debug Acumatica Framework-Based Applications" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f4d825da-5060-6818-46b6-1cfac1d00c8a" RecordSourceID="22377" />
		<row PageID="17394b71-06d5-41d4-86ca-e677a148f317" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="c02a22ac-788f-9586-5288-28d39735c5b1" RecordSourceID="22377">
			<column name="Content"><![CDATA[
This topic describes how to link an Acumatica Framework-based application site to the database and start the Acumatica Framework application in debug mode.
==To Debug an Application from Visual Studio==[anchor|#_639abd1c-c1b7-4445-9149-6d74b85ae351]
#In Visual Studio, open the solution of your Acumatica Framework-based application.
#In the <tt>Site</tt> folder of the solution, open the <tt>web.config</tt> file.
#In the {{connectionStrings}} section of the file, modify the connection string by specifying the credentials to your development database as follows:
#*For a locally installed Microsoft SQL Server that uses SQL Server authentication (line breaks are for display purposes only){{{{&lt;connectionStrings&gt;
    &lt;remove name="ProjectX" /&gt;
    &lt;add name="ProjectX" providerName="System.Data.SqlClient" 
        connectionString="Data Source=(local);Initial Catalog=Project_Catalog; 
                          User Id=User_ID; Password=User_Password"
&lt;/connectionStrings&gt;
}}}}
#*For a locally installed Microsoft SQL Server that uses Windows authentication (line breaks are for display purposes only){{{{&lt;connectionStrings&gt;
    &lt;remove name="ProjectX" /&gt;
    &lt;add name="ProjectX" providerName="System.Data.SqlClient" 
        connectionString="Data Source=(local);Initial Catalog=Project_Catalog; 
                          Integrated Security=True"/&gt;
&lt;/connectionStrings&gt;
}}}}
#*For a remote Microsoft SQL Server that uses SQL Server authentication (line breaks are for display purposes only){{{{connectionStrings&gt;
    &lt;remove name="ProjectX" /&gt;
    &lt;add name="ProjectX" providerName="System.Data.SqlClient" 
        connectionString="Data Source=Server_Name; Initial Catalog=Project_Catalog; 
                          User Id=User_ID; Password=User_Password"
&lt;/connectionStrings&gt;
}}}}
#In the {{system.web}} section of the file, set the {{debug}} attribute of the {{compilation}} element to {{True}}, as shown in the following example.{{{{&lt;compilation debug="True" defaultLanguage="c#" 
    numRecompilesBeforeAppRestart="9999" targetFramework="4.7.1"&gt;
}}}}
#In Visual Studio, right-click the <tt>Site</tt> folder of the solution, and click '''Set as StartUp Project'''. 
#Right-click the <tt>Main.aspx</tt> file in the <tt>Site</tt> folder, and click '''Set as Start Page'''.
#Optional: If you need to debug a server error that throws an exception, do the following:
##On the toolbar, click '''Debug''' > '''Windows''' > '''Exception Settings'''.
##In the '''Exception Settings''' panel, which opens, expand '''Common Language Runtime Exceptions''', and select the check box for the exception that is thrown (such as '''System.ArgumentOutOfRangeException'''). 
#Run the solution in the Debug mode.
]]></column>
			<column name="PlainText"><![CDATA[To Debug  Acumatica Framework-Based Applications This topic describes how to link an  Acumatica Framework-based application site to the database and start the  Acumatica Framework application in debug mode. To Debug an Application from Visual Studio In Visual Studio, open the solution of your  Acumatica Framework-based application. In the  Site  folder of the solution, open the                          web.config  file. In the  connectionStrings  section of the file, modify the                     connection string by specifying the credentials to your development database as                         follows: For a locally installed Microsoft SQL Server that uses SQL Server                             authentication (line breaks are for display purposes                             only) <connectionStrings>
    <remove name="ProjectX" />
    <add name="ProjectX" providerName="System.Data.SqlClient" 
        connectionString="Data Source=(local);Initial Catalog=Project_Catalog; 
                          User Id=User_ID; Password=User_Password"
</connectionStrings> For a locally installed Microsoft SQL Server that uses Windows                             authentication (line breaks are for display purposes                             only) <connectionStrings>
    <remove name="ProjectX" />
    <add name="ProjectX" providerName="System.Data.SqlClient" 
        connectionString="Data Source=(local);Initial Catalog=Project_Catalog; 
                          Integrated Security=True"/>
</connectionStrings> For a remote Microsoft SQL Server that uses SQL Server authentication                             (line breaks are for display purposes                             only) connectionStrings>
    <remove name="ProjectX" />
    <add name="ProjectX" providerName="System.Data.SqlClient" 
        connectionString="Data Source=Server_Name; Initial Catalog=Project_Catalog; 
                          User Id=User_ID; Password=User_Password"
</connectionStrings> In the  system.web  section of the file, set the                          debug  attribute of the  compilation  element                     to  True , as shown in the following                     example. <compilation debug="True" defaultLanguage="c#" 
    numRecompilesBeforeAppRestart="9999" targetFramework="4.7.1"> In Visual Studio, right-click the  Site  folder of the                     solution, and click  Set as StartUp Project .  Right-click the  Main.aspx  file in the                          Site  folder, and click  Set as Start                         Page . Optional: If you need to debug a server error that throws an exception, do the                         following: On the toolbar, click  Debug Windows Exception Settings . In the  Exception Settings  panel, which opens,                             expand  Common Language Runtime Exceptions , and                             select the check box for the exception that is thrown (such as                                  System.ArgumentOutOfRangeException ).  Run the solution in the Debug mode. ]]></column>
		</row>
		<row PageID="f9e20abb-20c0-4df7-b959-7c7307533849" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="30bbaa28-b93d-bc93-8490-05e8260fcb40" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The following table contains definitions of the basic terms used in Acumatica Framework.[anchor|#table_kxq_lr2_gk]
{| class="checklist" | width="100%" 
|- 
| '''Term'''
|  '''Definition'''
|- 
|  '''Action'''
| An interface for executing a specific operation with data that is implemented in a graph. An action is represented by the corresponding button on the user interface.
|- 
| ''' Acumatica Cloud xRP                         Platform'''
| The platform for the development of cloud ERP applications (such as Acumatica ERP and customizations of it), the mobile application for Acumatica ERP, and applications integrated with Acumatica ERP by means of the web services API.
|- 
| ''' Acumatica Customization           Platform'''
| The part of the Acumatica Cloud xRP                         Platform that provides customization tools for the development of applications embedded in Acumatica ERP (also called customizations of Acumatica ERP).
|- 
| ''' Acumatica Framework'''
| The part of the Acumatica Cloud xRP                         Platform that provides the platform API, web controls, and other tools for building ERP applications.
|- 
| ''' Acumatica Framework                         Templates'''
| A set of Visual Studio templates provided as a part of Acumatica Framework for creating ASPX pages and business logic controllers.
|- 
| ''' Acumatica Framework-based application'''
| An application created by means of Acumatica Framework tools.
|- 
| '''Analytical report'''
| A report created with the Analytical Report Manager. For details on this tool, see [HelpRoot_ReportingTools\CS__ARM_Analytical_Report_Parameters|Analytical Report Manager].
|- 
| '''Bound field'''
| A data field that represents a column from a database table. Compare to '''Unbound field'''.
|- 
| '''BQL statement'''
| A generic BQL class specialization that represents a specific query to the database. The type parameters specified in the BQL statement are BQL operator classes and DACs.
|- 
| '''Business logic controller''' ('''BLC''')
| See '''Graph'''.
|- 
| '''Business query language''' ('''BQL''')
| A set of generic classes for querying data records from the database.
|- 
| '''Cache'''
| A collection of modified data records from the same table stored in the user session and shared between requests.
|- 
| '''Custom report'''
| A report created on the custom report form.
|- 
| '''Customization of Acumatica ERP'''
| A modification of the user interface, business logic, and the database scheme without recompilation and re-installation of Acumatica ERP. This modification is packed in a customization project.
|- 
| '''Customization project'''
| A container that holds the changes you have made during a particular customization of Acumatica ERP.
|- 
| '''DAC field'''
| See '''Field'''.
|- 
| '''Data access class''' ('''DAC''')
| A class that represents a database table.
|- 
| '''Data entry form'''
| A form that is used for the input of business documents.
|- 
| '''Data member'''
| A data view specified as the data source for a container of UI controls (a form, a tab, or a grid).
|- 
| '''Data record'''
| A specific record retrieved from the database or created in code and wrapped in a DAC instance.
|- 
| '''Data view'''
| A BQL statement that the graph uses to access and manipulate data. A developer defines a data view in code by using [HelpRoot_Dev_Platform\AD__con_BQL_PXSelect|<tt>PXSelect</tt>] classes.
|- 
| '''Datasource control'''
| A service control on an ASPX page that is used to bind the ASPX page to a particular graph. This control represents the form toolbar, which contains action buttons.
|- 
| '''Embedded application'''
| See '''Customization of Acumatica ERP'''.
|- 
| '''Event'''
| A way to provide notifications from Acumatica Framework to the application. Most business logic is implemented in event handlers.
|- 
| '''Event handler'''
| A method that is invoked by Acumatica Framework when the corresponding event is raised.
|- 
| '''Field (DAC field)'''
| A part of the DAC definition that typically represents a database column. A DAC field consists of an abstract class that is used to refer to the field in BQL and a property holding the actual field value.
|- 
| '''Form'''
| An application page that provides the UI and business logic of the application. Each form used in the application consists of a declarative ASPX page created from one of the Acumatica Framework                         Templates or a report form and the business logic defined for this form in the corresponding graph.
|- 
| '''Form template'''
| A Visual Studio template that is provided by Acumatica Framework and used for creating ASPX pages.
|- 
| '''Graph'''
| A stateless controller class that is intended for the execution of business logic on a particular application form. A graph (also called a ''business logic controller'') is derived from the <tt>PXGraph</tt> generic class.
|- 
| '''Inquiry form'''
| A form that displays a list of data records selected by the specified filter.
|- 
| '''Integrated application'''
| A third-party application integrated with Acumatica ERP by means of web services API.
|- 
| '''Maintenance form'''
| A helper form that is used for the input of data on the data entry and processing forms.
|- 
| 
'''Mobile API'''
| The API that is used for customization of the Acumatica mobile application. For a description of the API, see [HelpRoot_Dev_Mobile\MOBILE_Reference|Mobile Site Map Reference].
|- 
| '''Multitenant application'''
| An application in which multiple tenants use the same Acumatica Framework-based application. For each tenant, the website looks identical and provides the same business logic. However, each tenant has exclusive access to the tenant&rsquo;s individual data and can have restricted access to the data of other tenants.
|- 
| '''Platform API'''
| The API that is used to develop Acumatica Framework-based applications and customizations of Acumatica ERP.
|- 
| '''Primary graph'''
| The graph that corresponds to the default editing form of the data record. This graph is specified in the [https://help.acumatica.com/(W(15))/Main?ScreenId=ShowWiki&pageid=1dceb511-4e98-3700-7d7f-231688a7ac74|<tt>PXPrimaryGraph</tt>] attribute.
|- 
| '''Primary DAC'''
| The first data access class specified in a BQL statement.
|- 
| '''Primary data view'''
| The first data view defined in a business logic controller.
|- 
| '''Processing form'''
| A form that provides mass processing operations.
|- 
| ''' Report Designer'''
| A visual editor for creating report forms and printable pages.
|- 
| '''Report form'''
| An RPX page created in Report Designer that defines the form used for generating reports in the application.
|- 
| '''Screen'''
| See '''Form'''.
|- 
| '''Setup form'''
| A form that provides the configuration parameters for the application.
|- 
| '''Unbound field'''
| A data field that exists only on the model level in a DAC definition, and that is not bound to a column of the database table. Compare to '''Bound field'''.
|- 
| '''Webpage'''
| See '''Form'''.
|- 
| '''Web services API'''
| The API for development of applications integrated with Acumatica ERP through SOAP or REST.
|}]]></column>
			<column name="PlainText"><![CDATA[Glossary The following table contains definitions of the basic terms used in  Acumatica Framework. Term Definition Action An interface for executing a specific operation with data that is implemented in               a graph. An action is represented by the corresponding button on the user               interface.  Acumatica Cloud xRP                         PlatformThe platform for the development of cloud ERP applications (such as  Acumatica ERP and customizations of it), the mobile application for  Acumatica ERP, and applications integrated with  Acumatica ERP by means of the web services API.  Acumatica Customization           PlatformThe part of the  Acumatica Cloud xRP                         Platform that provides customization tools for the development of applications embedded in                  Acumatica ERP (also called customizations of  Acumatica ERP).  Acumatica FrameworkThe part of the  Acumatica Cloud xRP                         Platform that provides the platform API, web controls, and other tools for building ERP               applications.  Acumatica Framework                         TemplatesA set of Visual Studio templates provided as a part of  Acumatica Framework for creating ASPX pages and business logic controllers.  Acumatica Framework-based application An application created by means of  Acumatica Framework tools. Analytical report A report created with the Analytical Report Manager. For details on this tool,               see  Analytical Report Manager. Bound field A data field that represents a column from a database table. Compare to                  Unbound field . BQL statement A generic BQL class specialization that represents a specific query to the               database. The type parameters specified in the BQL statement are BQL operator classes               and DACs. Business logic controller  ( BLC ) See  Graph . Business query language  ( BQL ) A set of generic classes for querying data records from the database. Cache A collection of modified data records from the same table stored in the user               session and shared between requests. Custom report A report created on the custom report form. Customization of  Acumatica ERPA modification of the user interface, business logic, and the database scheme               without recompilation and re-installation of  Acumatica ERP. This modification is packed in a customization project. Customization project A container that holds the changes you have made during a particular               customization of  Acumatica ERP. DAC field See  Field . Data access class  ( DAC ) A class that represents a database table. Data entry form A form that is used for the input of business documents. Data member A data view specified as the data source for a container of UI controls (a form,               a tab, or a grid). Data record A specific record retrieved from the database or created in code and wrapped in a               DAC instance. Data view A BQL statement that the graph uses to access and manipulate data. A developer               defines a data view in code by using  PXSelect <tt>PXSelect</tt> classes. Datasource control A service control on an ASPX page that is used to bind the ASPX page to a               particular graph. This control represents the form toolbar, which contains action               buttons. Embedded application See  Customization of  Acumatica ERP. Event A way to provide notifications from  Acumatica Framework to the application. Most business logic is implemented in event handlers. Event handler A method that is invoked by  Acumatica Framework when the corresponding event is raised. Field (DAC field) A part of the DAC definition that typically represents a database column. A DAC               field consists of an abstract class that is used to refer to the field in BQL and a               property holding the actual field value. Form An application page that provides the UI and business logic of the application.               Each form used in the application consists of a declarative ASPX page created from one               of the  Acumatica Framework                         Templates or a report form and the business logic defined for this form in the corresponding               graph. Form template A Visual Studio template that is provided by  Acumatica Framework and used for creating ASPX pages. Graph A stateless controller class that is intended for the execution of business logic               on a particular application form. A graph (also called a  business logic                 controller ) is derived from the  PXGraph  generic               class. Inquiry form A form that displays a list of data records selected by the specified               filter. Integrated application A third-party application integrated with  Acumatica ERP by means of web services API. Maintenance form A helper form that is used for the input of data on the data entry and processing               forms. Mobile API The API that is used for customization of the  Acumatica mobile application. For a description of the API, see  Mobile Site Map Reference. Multitenant application An application in which multiple tenants use the same  Acumatica Framework-based application. For each tenant, the website looks identical and provides the               same business logic. However, each tenant has exclusive access to the tenant's               individual data and can have restricted access to the data of other tenants. Platform API The API that is used to develop  Acumatica Framework-based applications and customizations of  Acumatica ERP. Primary graph The graph that corresponds to the default editing form of the data record. This               graph is specified in the  PXPrimaryGraph <tt>PXPrimaryGraph</tt>               attribute. Primary DAC The first data access class specified in a BQL statement. Primary data view The first data view defined in a business logic controller. Processing form A form that provides mass processing operations.  Report DesignerA visual editor for creating report forms and printable pages. Report form An RPX page created in  Report Designer that defines the form used for generating reports in the application. Screen See  Form . Setup form A form that provides the configuration parameters for the application. Unbound field A data field that exists only on the model level in a DAC definition, and that is               not bound to a column of the database table. Compare to  Bound field . Webpage See  Form . Web services API The API for development of applications integrated with  Acumatica ERP through SOAP or REST. ]]></column>
		</row>
	</rows>
</data>