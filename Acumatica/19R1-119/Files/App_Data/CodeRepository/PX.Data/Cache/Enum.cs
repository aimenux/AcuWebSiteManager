// This File is Distributed as Part of Acumatica Shared Source Code 
/* ---------------------------------------------------------------------*
*                               Acumatica Inc.                          *
*              Copyright (c) 1994-2011 All rights reserved.             *
*                                                                       *
*                                                                       *
* This file and its contents are protected by United States and         *
* International copyright laws.  Unauthorized reproduction and/or       *
* distribution of all or any portion of the code contained herein       *
* is strictly prohibited and will result in severe civil and criminal   *
* penalties.  Any violations of this copyright will be prosecuted       *
* to the fullest extent possible under law.                             *
*                                                                       *
* UNDER NO CIRCUMSTANCES MAY THE SOURCE CODE BE USED IN WHOLE OR IN     *
* PART, AS THE BASIS FOR CREATING A PRODUCT THAT PROVIDES THE SAME, OR  *
* SUBSTANTIALLY THE SAME, FUNCTIONALITY AS ANY ProjectX PRODUCT.        *
*                                                                       *
* THIS COPYRIGHT NOTICE MAY NOT BE REMOVED FROM THIS FILE.              *
* ---------------------------------------------------------------------*/

using System;

namespace PX.Data
{
    /// <summary>This enumeration specifies the type of a T-SQL statement generated by the Acumatica Data Access Layer. 
    /// The enumeration is used to indicate the type of the operation and the option set for the operation. 
    /// <code>PXDBOperation</code> supports the <code>FlagsAttribute</code> attribute, which allows <code>PXDBOperation</code> members to be represented as bit fields in the enumeration value.
    /// </summary>
    /// <example>
    /// 	<para></para>
    /// 	<code title="Example" description="Getting the type of an operation:" lang="CS">
    /// protected virtual void DACName_FieldName_CommandPreparing(
    ///     PXCache sender, PXCommandPreparingEventArgs e)
    /// {
    ///     PXDBOperation operationKind = e.Operation &amp; PXDBOperation.Command;
    /// }</code>
    /// 	<code title="Example2" description="Getting the option set for an operation:" groupname="Example" lang="CS">
    /// protected virtual void DACName_FieldName_CommandPreparing(
    ///     PXCache sender, 
    ///     PXCommandPreparingEventArgs e)
    /// {
    ///     PXDBOperation operationOptions = e.Operation &amp; PXDBOperation.Option;
    /// }</code>
    /// </example>
	[Flags]
	public enum PXDBOperation
	{
		// Command uses the lowest 2 bits
		/// <summary>SELECT operation</summary>
		Select = 0,
		/// <summary>UPDATE operation</summary>
		Update = 1,
		/// <summary>INSERT operation</summary>
		Insert = 2,
		/// <summary>DELETE operation</summary>
		Delete = 3,
        /// <exclude/>
        Command = 0x03,

		// Option uses bits from third to seventh
		/// <summary>The operation has no options set.</summary>
		Normal = 0 << 2,
		/// <summary>This specifies an aggregate operation.</summary>
		GroupBy = 1 << 2,
		/// <summary>The result of the operation cannot be used to prepare
		/// the external representation.</summary>
		Internal = 2 << 2,
		/// <summary>The operation contains a sorting, filter, or search query across
		/// any DAC field visible in the UI.</summary>
		External = 4 << 2,
		/// <summary>The operation is changing system data visibility and transferring
		/// it from the system data segment to the customer data segment.</summary>
		Second = 8 << 2,
        /// <exclude/>
		ReadOnly = 16 << 2,
        ///<summary>The operation is select in massdataexport scenario and subselect for field required</summary>
        SubselectForExport = ReadOnly|External,
		/// <exclude/>
		Option = 31 << 2,

        // Place uses bits from eigth to twelveth
        /// <exclude />
        SelectClause = 1 << 7,
        /// <exclude />
        WhereClause = 2 << 7,
        /// <exclude />
        OrderByClause = 4 << 7,
        /// <exclude />
        GroupByClause = 8 << 7,
        /// <exclude />
        NestedSelectInReport = 16 << 7,
        /// <exclude />
        Place = 31 << 7,

		//Place uses bits from thirteenth
		/// <exclude />
		ReadItem = 1 << 12

    }

	public static class PXDBOperationExt
	{
		public static PXDBOperation Command(this PXDBOperation self) => self & PXDBOperation.Command;
		public static PXDBOperation Option(this PXDBOperation self) => self & PXDBOperation.Option;
		public static PXDBOperation Place(this PXDBOperation self) => self & PXDBOperation.Place;
	}

    //public enum PXDBAggregate
    //{
    //    None,
    //    Sum,
    //    Min,
    //    Max,
    //    Avg,
    //    GroupBy
    //}

    /// <exclude/>
    public enum PXAttributeLevel
	{
		/// <summary>
		/// Original attributes of a DAC.
		/// Cannot be obtained directly.<para/>
		/// Are instantiated once for each type on 
		/// first instantiating of its <see cref="PXCache"/><para/>
		/// Attributes of this level cannot be modified in runtime.
		/// </summary>
		Type,

		/// <summary>
		/// Attributes that copied from attributes of <see cref="Type"/>,
		/// merged with <see cref="PXGraph"/> attributes, relevant to the DAC, 
		/// and then linked to a certain <see cref="PXCache"/> instance.<para/>
		/// Are instantiated on every <see cref="PXCache"/> instantiating 
		/// by copying of <see cref="Type"/> attributes.<para/>
		/// Attributes of this level can be modified in runtime, usually by calling
		/// attributes static methods that have signature corresponding to
		/// <code>"AttributeName.SetSomeValue(PXCache sender, object row, SomeType someValue)"</code>
		/// and passing <code>null</code> as a second parameter.
		/// </summary>
		Cache,

		/// <summary>
		/// Attributes that copied from attributes of <see cref="Cache"/>,
		/// and then linked to a certain row instance in a <see cref="PXCache"/>.<para/>
		/// Are instantiated by copying of <see cref="Cache"/> attributes 
		/// at certain data row attributes demanding.<para/>
		/// Attributes of this level can be modified in runtime, usually by calling
		/// attributes static methods that have signature corresponding to
		/// <code>"AttributeName.SetSomeValue(PXCache sender, object row, SomeType someValue)"</code>
		/// and passing a certain row as a second parameter.
		/// </summary>
		Item
	}

    /// <summary>Maps the user role's access rights for a specific
    /// <tt>PXCache&lt;&gt;</tt> object.</summary>
    /// <example>
    /// The following example uses the enumeration value to configure access rights for the button,
    /// which represents a graph action in the user interface. The user with the <tt>Select</tt> rights
    /// for the <tt>ApproveBillsFilter</tt> cache can see the <b>View Document</b> button in the user interface. 
    /// For the user with the <tt>Update</tt> rights for the <tt>ApproveBillsFilter</tt> cache, the <b>View Document</b> button is also available.
    /// <code>
    /// public PXAction&lt;ApproveBillsFilter&gt; ViewDocument;
    /// [PXUIField(DisplayName = "View Document",
    ///     MapEnableRights = PXCacheRights.Update,
    ///     MapViewRights = PXCacheRights.Select)]
    /// [PXButton]
    /// public virtual IEnumerable viewDocument(PXAdapter adapter)
    /// {
    /// ...
    /// }</code>
    /// </example>
	public enum PXCacheRights : byte
	{
        /// <summary>Matches the roles for whom access to a <tt>PXCache</tt>
        /// object is denied.</summary>
		Denied,
        /// <summary>Matches the roles that are allowed to read data records of
        /// the DAC type corresponding to the <tt>PXCache&lt;&gt;</tt> object.</summary>
		Select,
        /// <summary>Matches the roles that are allowed to update data records of
        /// the DAC type corresponding to the <tt>PXCache&lt;&gt;</tt> object.</summary>
		Update,
        /// <summary>Matches the roles that are allowed to insert data records of
        /// the DAC type corresponding to the <tt>PXCache&lt;&gt;</tt> object.</summary>
		Insert,
        /// <summary>Matches the roles that are allowed to delete data records of
        /// the DAC type corresponding to the <tt>PXCache&lt;&gt;</tt> object.</summary>
		Delete
	}

    /// <exclude/>
	public struct PXCacheRightsPrioritized
	{
		public readonly bool Prioritized;
		public readonly PXCacheRights Rights;
		public PXCacheRightsPrioritized(bool prioritized, PXCacheRights rights)
		{
			Prioritized = prioritized;
			Rights = rights;
		}

		private bool EqualsIntern(PXCacheRightsPrioritized other)
		{
			return Prioritized == other.Prioritized && Rights == other.Rights;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is PXCacheRightsPrioritized))
				return false;

			//if (ReferenceEquals(null, obj)) return false;
			//if (ReferenceEquals(this, obj)) return true;
			//if (obj.GetType() != this.GetType()) return false;
			return EqualsIntern((PXCacheRightsPrioritized)obj);
		}


		public override int GetHashCode()
		{
			return (Prioritized.GetHashCode() * 397) ^ Rights.GetHashCode();
		}

	}

    /// <exclude/>
	public enum PXMemberRights : byte
	{
		Denied,
		Visible,
		Enabled
	}

	public struct PXMemberRightsPrioritized
	{
		public readonly bool Prioritized;
		public readonly PXMemberRights Rights;
		public PXMemberRightsPrioritized(bool prioritized, PXMemberRights rights)
		{
			Prioritized = prioritized;
			Rights = rights;
		}

		private bool EqualsIntern(PXMemberRightsPrioritized other)
		{
			return Prioritized == other.Prioritized && Rights == other.Rights;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is PXMemberRightsPrioritized))
				return false;

			//if (ReferenceEquals(null, obj)) return false;
			//if (ReferenceEquals(this, obj)) return true;
			//if (obj.GetType() != this.GetType()) return false;
			return EqualsIntern((PXMemberRightsPrioritized)obj);
		}


		public override int GetHashCode()
		{
			return (Prioritized.GetHashCode() * 397) ^ Rights.GetHashCode();
		}

	}

    /// <exclude/>
	internal enum PXCacheOperation
	{
		Insert,
		Update,
		Delete
	}

    /// <summary>Describes the current status of a transaction
    /// scope.</summary>
	public enum PXTranStatus
	{
        /// <summary>The status of the transaction is unknown, because some
        /// participants still have to be polled.</summary>
		Open,
        /// <summary>The changes associated with the transaction scope have been
        /// successfully committed to the database.</summary>
		Completed,
        /// <summary>The changes within the transaction scope have been dropped
        /// because of an error.</summary>
		Aborted
	}

    /// <summary>Defines possible options of clearing the graph data through
    /// the <see cref="PXGraph.Clear(PXClearOption)">Clear(PXClearOption)</see>
    /// method.</summary>
	public enum PXClearOption
	{
        /// <summary>Data records are preserved.</summary>
		PreserveData,
        /// <summary>The timestamp is preserved.</summary>
		PreserveTimeStamp,
        /// <summary>The query cache is preserved.</summary>
		PreserveQueries,
        /// <summary>Everything is removed.</summary>
		ClearAll,
        /// <summary>Only the query cache is cleared.</summary>
		ClearQueriesOnly
	}

    /// <summary>Defines possible special types of a button. The enumeration
    /// is used to set <tt>PXButton</tt> attribute properties.</summary>
	public enum PXSpecialButtonType
	{
        /// <summary>The button does not have a special type.</summary>
		Default,
        /// <summary>The button has the <b>Save</b> button type. In particular, a graph searches buttons of this type when the graph's <tt>Actions.PressSave()</tt> method is
        /// invoked.</summary>
        Save,
        /// <summary>The button has the <b>Save &amp; Close</b> button type.</summary>
        SaveNotClose,
        /// <summary>The button has the <b>Cancel</b> button type. In particular,
        /// a graph searches buttons of this type when the graph's
        /// <tt>Actions.PressCancel()</tt> method is invoked.</summary>
		Cancel,
        /// <summary>The button has the <b>Refresh</b> button type.</summary>
		Refresh,
        /// <summary>The button has the <b>CopyPaste</b> button type.</summary>
        CopyPaste,
        /// <summary>The button has the <b>Report</b> button type.</summary>
        Report,
        /// <summary>The button has the <strong>Go to First Record </strong>button type.</summary>
        First,
        /// <summary>The button has the <strong>Go to Next Record</strong> button type.</summary>
        Next,
        /// <summary>The button has the <b>Go to Previous Record </b>button type.</summary>
        Prev,
        /// <summary>The button has the <strong>Go to Last Record</strong> button type.</summary>
        Last,
        /// <summary>The button has the <b>Add New Record </b>button type.</summary>
        Insert,
        /// <summary>The button has the <b>Delete</b> button type.</summary>
        Delete,
        /// <summary>The button has the <b>Approve</b> button type.</summary>
        Approve,
        /// <summary>The button has the <b>Approve All</b> button type.</summary>
        ApproveAll,
        /// <summary>The button has the <b>Process</b> button type.</summary>
        Process,
        /// <summary>The button has the <b>Process All</b> button type.</summary>
        ProcessAll,
        /// <summary>The button has the <b>Schedule</b> button type.</summary>
        Schedule,
        /// <summary>The button has the <b>Switch Between Grid and Form </b>button type.</summary>
        EditDetail,
        /// <summary>The button has the <b>ActionsFolder</b>button type.</summary>
        ActionsFolder,
        /// <summary>The button has the <b>InquiriesFolder</b>button type.</summary>
        InquiriesFolder,
        /// <summary>The button has the <b>ReportsFolder</b>button type.</summary>
        ReportsFolder,
        /// <summary>The button has the <b>ToolbarFolder</b>button type.</summary>
        ToolbarFolder
    }
}
