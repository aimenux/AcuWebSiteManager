<?xml version="1.0" encoding="utf-8"?>
<data>
	<table name="WikiRevision">
		<col name="CompanyID" type="Int" default="Zero" />
		<col name="PageID" type="UniqueIdentifier" />
		<col name="Language" type="VarChar(50)" />
		<col name="PageRevisionID" type="Int" />
		<col name="Content" type="NVarChar(MAX)" />
		<col name="ContentHtml" type="NVarChar(MAX)" nullable="true" />
		<col name="PlainText" type="NVarChar(MAX)" />
		<col name="ApprovalByID" type="UniqueIdentifier" nullable="true" />
		<col name="ApprovalDateTime" type="DateTime" nullable="true" />
		<col name="CreatedByID" type="UniqueIdentifier" />
		<col name="CreatedDateTime" type="DateTime" />
		<col name="CompanyMask" type="VarBinary(32)" default="CompanyMaskReadOnly" />
		<col name="UID" type="UniqueIdentifier" />
		<col name="RecordSourceID" type="SmallInt" nullable="true" />
	</table>
	<rows>
		<row PageID="2e919932-c74e-48ff-b85a-bc5d76360367" Language="en-US" PageRevisionID="1" Content="In this guide, you can find information about how to develop applications based on Acumatica Framework.&#xA;==In This Guide==[anchor|#_917d1e43-ded8-41ed-b16b-9ec1f6ea0eb7]&#xA;*[HelpRoot_Dev_Platform\OV__mng| Acumatica Framework Overview]&#xA;*[HelpRoot_Dev_Platform\FGS__mng|Getting Started with Acumatica Framework]&#xA;*[HelpRoot_Dev_Platform\DA__mng|Designing the Application]&#xA;*[HelpRoot_Dev_Platform\CW__mng|Configuring ASPX Webpages and Reports]&#xA;*[HelpRoot_Dev_Platform\AD__mng|Accessing Data]&#xA;*[HelpRoot_Dev_Platform\BL__mng|Implementing Business Logic]&#xA;*[HelpRoot_Dev_Platform\TS__mng|Troubleshooting Acumatica Framework-Based Applications]&#xA;*[HelpRoot_Dev_Platform\GLO__mng_Glossary|Glossary]&#xA;" PlainText=" Acumatica Framework Guide In this guide, you can find information about how to develop applications based on  Acumatica Framework. In This Guide  Acumatica Framework OverviewGetting Started with Acumatica FrameworkDesigning the ApplicationConfiguring ASPX Webpages and ReportsAccessing DataImplementing Business LogicTroubleshooting Acumatica Framework-Based ApplicationsGlossary" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2b3f8ebf-8da7-7326-7f8f-944901e6d274" RecordSourceID="22377" />
		<row PageID="a8c57de7-0cc6-4e09-ba7e-476b9a397f28" Language="en-US" PageRevisionID="1" PlainText=" Acumatica Framework Overview  Acumatica Framework provides the application programming interface (API) and tools for developing cloud business applications.  Acumatica Framework is a part of the  Acumatica Cloud xRP Platform, which provides various opportunities for developing add-on applications that interact with  Acumatica ERP through the web services API, applications embedded into  Acumatica ERP through the built-in customization tools, and completely new applications based purely on  Acumatica Framework. In this part of the guide, you can find an overview of the  Acumatica Cloud xRP Platform and the place of  Acumatica Framework in this platform. This part also includes an overview of  Acumatica Framework tools and a high-level overview of the runtime architecture of applications based on  Acumatica Framework. In This Part  Acumatica Cloud xRP Platform Acumatica Framework Development ToolsRuntime Architecture of an Application Based on Acumatica Framework" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="031c2057-f3de-8ad3-dcb8-71962c0e3544" RecordSourceID="22377">
			<column name="Content"><![CDATA[
 Acumatica Framework provides the application programming interface (API) and tools for developing cloud business applications. Acumatica Framework is a part of the Acumatica Cloud xRP Platform, which provides various opportunities for developing add-on applications that interact with Acumatica ERP through the web services API, applications embedded into Acumatica ERP through the built-in customization tools, and completely new applications based purely on Acumatica Framework.{br}

In this part of the guide, you can find an overview of the Acumatica Cloud xRP Platform and the place of Acumatica Framework in this platform. This part also includes an overview of Acumatica Framework tools and a high-level overview of the runtime architecture of applications based on Acumatica Framework.
==In This Part==[anchor|#_cac0218c-99b6-4fc1-86bc-afad47e18069]
*[HelpRoot_Dev_Platform\OV__con_xRP_Platform| Acumatica Cloud xRP Platform]
*[HelpRoot_Dev_Platform\OV__con_Development_Tools| Acumatica Framework Development Tools]
*[HelpRoot_Dev_Platform\OV__con_Architecture|Runtime Architecture of an Application Based on Acumatica Framework]
]]></column>
		</row>
		<row PageID="a296caef-aee5-4190-90d0-e43c6378c1b5" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="9deea65f-8e44-04a4-09fe-996c5a75edb5" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The Acumatica Cloud xRP Platform is the platform provided by Acumatica that is used to build the Acumatica ERP application itself, any customizations of Acumatica ERP, the mobile application for Acumatica ERP, and applications integrated with Acumatica ERP through the web services API.{br}

The Acumatica Cloud xRP Platform consists of a number of components, which are highlighted with light blue in the following diagram. These components serve different purposes, which are described in detail in this topic, and can be used either separately or combined to achieve your business purposes. [anchor|#_5e87a512-709f-4f19-97dd-297695881bc0][anchor|#_0a7f6124-bedf-46fc-a073-760a78ae81f6][image:StudioDeveloperGuide/Images/AcumaticaCloudXrpPlatform.png|popup|Acumatica Cloud xRP Platform|450px]
==Basic Components and Tools==
The base of the Acumatica Cloud xRP Platform is formed by the components and tools that provide the basic application functionality, such as multitenancy support, role-based access, and localization tools. These components and tools are available out-of-the-box in Acumatica ERP, any embedded in Acumatica ERP applications, or applications based purely on Acumatica Framework applications. This means that you do not need to worry about implementing mechanisms similar to these components during the design or programming of your application based on the Acumatica Cloud xRP Platform. {br}

 Acumatica Cloud xRP Platform contains the basic components and tools listed in the following table.[anchor|#_85d91eb0-f188-4afa-a9d7-c2d5966022d9]
{| class="checklist" | width="100%" 
|- 
!width="25%" ! Component or Tool
!width="75%" ! Description
|- 
| Role-based access
| A set of components responsible for user authorization, access rights verification, and audit on the data access and business logic levels. For more information, see [HelpRoot_Administration\SM__con_Role-Based_Access|Role-Based Access] in the System Administration Guide.
|- 
| Multitenancy
| A component responsible for hosting multiple tenants on a single application server. For details about multitenancy, see [HelpRoot_Administration\SM__con_Support_of_Multiple_Companies|Support of Multiple Tenants] in the User Guide.
|- 
| Localization tools
| The tools that help you to perform the localization of the application to multiple languages. For more information about localization, see [HelpRoot_Administration\SM__con_Translation_Process|Translation Process].
|- 
| Help management system
| The integrated wiki-based help content editing, management, and search system. For details about the help management system, see [HelpRoot_Administration\SM__con_Wiki_Management|Wiki Overview].
|- 
| Document management system
| The integrated document storage and management system. For details, see [HelpRoot_Administration\DM__mng_File_Attachements|Managing Attached Files].
|- 
|  Report Designer
| A separate utility (which can be installed along with Acumatica ERP or Acumatica Framework) that you can use to design custom reports. For details on this tool, see [HelpRoot_ReportingTools\ReportDesigner_Main| Acumatica Report                         Designer Guide]. 
|}
== Acumatica Framework==
 Acumatica Framework provides the platform API, web controls, and other tools for the development of the UI and business logic of an ERP application. The platform API is used for the development of Acumatica ERP and any embedded applications (that is, customizations of Acumatica ERP). Acumatica Framework can also be used to develop an ERP application from scratch. You can find detailed information about the development of applications with Acumatica Framework in this guide.{br}

 Acumatica Framework consists of the development tools listed in the following table.[anchor|#_97a00707-41d3-4be5-9162-6c5ae64d41ff]
{| class="checklist" | width="100%" 
|- 
!width="25%" ! Component
!width="75%" ! Description
|- 
| Platform API
| The API for implementing application business logic.
|- 
| Web controls
| A set of web controls implementing access to business logic through the web UI.
|- 
| Template application
| The application and database structures providing frameset, layout, and navigation services. You can deploy a template application along with the template website by using the Acumatica Framework                             Configuration Wizard.
|- 
| Visual Studio templates
| The project template for the creation of a new application and a set of page templates that automate the creation of typical page layouts.
|- 
| Application creation wizards
| A set of components to automate the creation of the application data access classes from the database tables and the web forms during application development.
|}{br}

For details about the development tools, see [HelpRoot_Dev_Platform\OV__con_Development_Tools| Acumatica Framework Development Tools]. 
==Acuminator==
Acuminator is a static code analysis and colorizer tool for Visual Studio that simplifies development with Acumatica Frameworkthe P. Acuminator provides diagnostics and code fixes for common developer challenges related to the platform API. Also, Acuminator can colorize and format business query language (BQL) statements, and can collapse attributes and parts of BQL queries. You can find related information and download Acuminator at [https://marketplace.visualstudio.com/items?itemName=V-for-Volodymyr.Acuminator#overview|Visual Studio Marketplace]. 
== Acumatica Customization           Platform==
 Acumatica Customization           Platform provides customization tools for the development of applications embedded in Acumatica ERP. Developers that work with Acumatica Customization           Platform use the platform API provided by Acumatica Framework. {br}

With Acumatica Customization           Platform, you can perform end-customer customizations and create complex solutions for multiple customers. In these customizations, you can modify the user interface, business logic, and database schema without recompilation and re-installation of the application. Customizations are stored separately from the core application code as metadata and can be modified, exported, or imported. Because customizations are stored separately, they are preserved with the updates and upgrades of the core application.{br}

For details on Acumatica Customization           Platform, see [HelpRoot_Dev_Customization\CG_Platform| Acumatica Customization             Platform].
==Web Services APIs==
The Acumatica Cloud xRP Platform provides multiple types of web services APIs for development of applications integrated with Acumatica ERP. These applications can perform data migration and data import, integration of Acumatica ERP with external systems, and execution of long-running operations. {br}

You can use the contract-based REST API, contract-based SOAP API, or screen-based SOAP API to access the same business logic as is accessed in the UI. All types of the web services APIs can be used with any customization applied to Acumatica ERP. The contract-based REST API supports the OpenAPI 2.0 (formerly known as Swagger 2.0) specification.{br}

For details on the web services APIs, see [HelpRoot_Dev_Integration\IS__con_CB_API|Contract-Based Web Services API] and [HelpRoot_Dev_Integration\IS__con_SB_API|Screen-Based Web Services API].{br}

 Acumatica ERP supports the OAuth 2.0 mechanism of authorization for add-on applications that interact with Acumatica ERP through application programming interfaces (APIs). For details on the authorization of applications, see [HelpRoot_Dev_Integration\IS__mng_Authorizing_with_OAuth2|Authorizing Client Applications to Work with Acumatica ERP].
==Mobile API==
 Acumatica ERP provides the Acumatica mobile application, which allows a user to work with Acumatica ERP through the mobile devices. You can customize the mobile application by using the mobile API. For details on the mobile API, see [HelpRoot_Dev_Mobile\Mobile_Framework_Guide|Working with Mobile Framework].
==Related Articles==
*[https://adn.acumatica.com/| Acumatica Developer Network]]]></column>
			<column name="PlainText"><![CDATA[ Acumatica Cloud xRP PlatformThe  Acumatica Cloud xRP Platform         is the platform provided by  Acumatica that is used to build the  Acumatica ERP application itself, any customizations of  Acumatica ERP, the mobile application for  Acumatica ERP, and applications integrated with  Acumatica ERP through the web services API. The  Acumatica Cloud xRP Platform         consists of a number of components, which are highlighted with light blue in the following         diagram. These components serve different purposes, which are described in detail in this         topic, and can be used either separately or combined to achieve your business purposes.  Acumatica Cloud xRP PlatformBasic Components and Tools The base of the  Acumatica Cloud xRP Platform         is formed by the components and tools that provide the basic application functionality, such         as multitenancy support, role-based access, and localization tools. These components and         tools are available out-of-the-box in  Acumatica ERP, any embedded in  Acumatica ERP applications, or applications based purely on  Acumatica Framework         applications. This means that you do not need to worry about implementing mechanisms similar         to these components during the design or programming of your application based on the  Acumatica Cloud xRP Platform.   Acumatica Cloud xRP Platform         contains the basic components and tools listed in the following table. Component or Tool Description Role-based access A set of components responsible for user authorization, access rights                   verification, and audit on the data access and business logic levels. For more                   information, see  Role-Based Access in the                   System Administration Guide. Multitenancy A component responsible for hosting multiple tenants on a single application                   server. For details about multitenancy, see  Support of Multiple Tenants in the User                   Guide. Localization tools The tools that help you to perform the localization of the application to                   multiple languages. For more information about localization, see  Translation Process. Help management system The integrated wiki-based help content editing, management, and search                   system. For details about the help management system, see  Wiki Overview. Document management system The integrated document storage and management system. For details, see  Managing Attached Files.  Report DesignerA separate utility (which can be installed along with  Acumatica ERP or  Acumatica Framework) that you can use to design custom reports. For details on this tool, see   Acumatica Report                         Designer Guide.   Acumatica Framework Acumatica Framework         provides the platform API, web controls, and other tools for the development of the UI and         business logic of an ERP application. The platform API is used for the development of  Acumatica ERP and any embedded applications (that is, customizations of  Acumatica ERP).  Acumatica Framework         can also be used to develop an ERP application from scratch. You can find detailed         information about the development of applications with  Acumatica Framework         in this guide.  Acumatica Framework consists of the development tools listed in the following table. Component Description Platform API The API for implementing application business logic. Web controls A set of web controls implementing access to business logic through the web                   UI. Template application The application and database structures providing frameset, layout, and                   navigation services. You can deploy a template application along with the template                   website by using the  Acumatica Framework                             Configuration Wizard. Visual Studio templates The project template for the creation of a new application and a set of page                   templates that automate the creation of typical page layouts. Application creation wizards A set of components to automate the creation of the application data access                   classes from the database tables and the web forms during application                   development. For details about the development tools, see   Acumatica Framework Development Tools.  Acuminator Acuminator is a static code analysis and colorizer tool for Visual Studio that simplifies         development with  Acumatica Frameworkthe P . Acuminator provides diagnostics and code fixes for common developer         challenges related to the platform API. Also, Acuminator can colorize and format business         query language (BQL) statements, and can collapse attributes and parts of BQL queries. You         can find related information and download Acuminator at  Visual Studio Marketplace Visual Studio Marketplace.   Acumatica Customization           Platform Acumatica Customization           Platform provides customization tools for the development of applications embedded in  Acumatica ERP. Developers that work with  Acumatica Customization           Platform use the platform API provided by  Acumatica Framework.  With  Acumatica Customization           Platform, you can perform end-customer customizations and create complex solutions for multiple         customers. In these customizations, you can modify the user interface, business logic, and         database schema without recompilation and re-installation of the application. Customizations         are stored separately from the core application code as metadata and can be modified,         exported, or imported. Because customizations are stored separately, they are preserved with         the updates and upgrades of the core application. For details on  Acumatica Customization           Platform, see   Acumatica Customization             Platform. Web Services APIs The  Acumatica Cloud xRP Platform         provides multiple types of web services APIs for development of applications integrated with            Acumatica ERP. These applications can perform data migration and data import, integration of  Acumatica ERP with external systems, and execution of long-running operations.  You can use the contract-based REST API, contract-based SOAP API, or screen-based SOAP API         to access the same business logic as is accessed in the UI. All types of the web services         APIs can be used with any customization applied to  Acumatica ERP. The contract-based REST API supports the OpenAPI 2.0 (formerly known as Swagger 2.0)         specification. For details on the web services APIs, see  Contract-Based Web Services API         and  Screen-Based Web Services API.  Acumatica ERP supports the OAuth 2.0 mechanism of authorization for add-on applications that interact         with  Acumatica ERP through application programming interfaces (APIs). For details on the authorization of         applications, see  Authorizing Client Applications to Work with Acumatica ERP. Mobile API  Acumatica ERP provides the  Acumatica mobile application, which allows a user to work with  Acumatica ERP through the mobile devices. You can customize the mobile application by using the mobile         API. For details on the mobile API, see  Working with Mobile Framework.  Acumatica Developer Network ]]></column>
		</row>
		<row PageID="b9392b01-5b47-4cce-b498-7aa08bcdf9fb" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="df3dc4b3-e400-05cc-50e6-b3d53c8f0b1a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can find a detailed description of the development tools provided with Acumatica Framework.{br}{TOC}
==Platform API==
The Platform API provided with Acumatica Framework is an event-driven programming API, which is traditional in rich GUI applications. This model covers database access, business logic, GUI behavior, and error handling. All coding is done with only C#.{br}

The following code gives an example of the business logic implemented in the business logic controller: The code updates the receipt total when one of the transactions related to the receipt is updated.<source lang="csharp">public virtual void DocTransation_RowUpdated(PXCache cache,
                                             PXRowUpdatedEventArgs e)
{
    DocTransaction old = e.OldRow as DocTransaction;
    DocTransaction trn = e.Row as DocTransaction;
    if ((trn != null) && (trn.TranQty != old.TranQty ||
                                   trn.UnitPrice != old.UnitPrice))
    {
        Document doc = Receipts.Current;
        if (doc != null)
        {
            doc.TotalAmt -= old.TranQty * old.UnitPrice;
            doc.TotalAmt += trn.TranQty * trn.UnitPrice;
            Receipts.Update(doc);
        }
    }
}</source>
When a user selects a document transaction in the table on a webpage and updates the settings of the transaction, the <tt>RowUpdated</tt> event is triggered, and the code above is executed and updates the receipt total, as shown in the following screenshots. [anchor|#_cebc9952-0bb1-4ca0-88fd-4e7a814cfce7][anchor|#_1f50b1e7-4d61-485b-88a4-56a6b68f2ff1][image:StudioDeveloperGuide/Images/OV_Total_Update_Code.png|popup|Update of document transaction details|450px]
==Visual Web Designer Support==
The Acumatica Framework Integrated Development Environment (IDE) is built on top of Microsoft Visual Studio. However, the Acumatica Framework IDE implements its own set of web controls to generate an advanced GUI in a web browser.{br}

All of Acumatica Framework&rsquo;s web controls have the same rendering and a similar appearance in design mode in the IDE and runtime mode in a web browser. Thus, the developer can utilize all the facilities of the Visual Web Designer component of Visual Studio. The application developer can use the convenient drag-and-drop mechanism to create an application form layout, to perform form visual editing, and to set a control&rsquo;s properties and behavior through an intuitive graphical interface. This approach does not require any knowledge of HTML or Java Script, yet allows the developer to create a professional and appealing web GUI.{br}

The following screenshots illustrate the design (left) and runtime (right) rendering.[image:StudioDeveloperGuide/Images/OV_WebForm_Desing_vs_Runtime.png|popup|Webpage in design and runtime mode|450px]
==Master Pages, Templates, and CSS Support==
The Visual Studio project and item templates provide reusable and customizable project and item stubs that accelerate the development process, removing the need to create new projects and items from scratch. Project templates provide the basic files needed for a particular project type, include standard assembly references, and set the default project properties and compiler options.{br}

 Acumatica Framework distribution includes the following:
*The project template for the creation of a new application
*A set of page templates that automate the creation of typical page layouts

The master pages mechanism in ASP.NET allows for the creation of an application that looks and feels consistent. Master pages define the standard appearance and behavior that is common in all application pages. You create individual content pages that refer to the master page. When a content page is requested, it merges with the master page to produce output that combines the layout and base functionality of the master page with the content of the requested page.{br}

 Acumatica Framework fully supports the master pages mechanism and provides you with a set of predefined master pages. You can design your own master pages or modify existing ones.{br}

A web application written with Acumatica Framework supports style modification through Cascading Style Sheets (CSS).
==Application Creation Wizards==
 Acumatica Framework provides a set of wizards for automating the creation of data access classes and webpages. The use of these wizards eliminates the manual steps associated with data access class creation and data binding configuration.{br}

The Data Access Class Generator, which is shown in the following screenshot, provides the application developer with a way to create and modify data access classes. It implements the following functionality:
*Reading the data structure from a table, SQL query, or external data source
*Creating a data access class based on the data structure received from external data source
*Reading the data access class structure from its definition and merging this structure with the data structure received from the external data source
*Automatic mapping of application-specific attributes based on the names of the properties of the external data source 
[anchor|#_f3a94ebc-6d36-4807-8b04-2d4f3ec2f8e7][anchor|#_f5a9563e-a781-4f18-a1b0-18a2a2641b26][image:StudioDeveloperGuide/Images/OV_DAC_Generator.png|popup|Data Access Class Generator|300px]
The Layout Editor, which is shown in the following screenshot, automates the creation of new web forms. It uses metadata stored in the business logic controller and data access class to help the application developer create new web forms or to modify existing ones. The '''Layout Editor''' wizard implements the following features:
*Reading metadata from the business logic controller and the data access class and creating a list of controls that could be added to the webpage
*Adding the controls selected by the programmer to the webpage
*Updating the webpage controls with the changed business logic controller and the data access class metadata
[anchor|#_636c8110-aa22-48ee-853a-0584b5fb1f7a][anchor|#_a1010986-a148-4a1a-93b2-d58499a619af][image:StudioDeveloperGuide/Images/OV_Layout_Editor.png|popup|Layout Editor|300px]]]></column>
			<column name="PlainText"><![CDATA[ Acumatica Framework         Development Tools In this topic, you can find a detailed description of the development tools provided                 with  Acumatica Framework. Platform API The Platform API provided with  Acumatica Framework is an event-driven programming API, which is traditional in rich GUI                 applications. This model covers database access, business logic, GUI behavior, and                 error handling. All coding is done with only C#. The following code gives an example of the business logic implemented in the business                 logic controller: The code updates the receipt total when one of the transactions                 related to the receipt is updated. public virtual void DocTransation_RowUpdated(PXCache cache,
                                             PXRowUpdatedEventArgs e)
{
    DocTransaction old = e.OldRow as DocTransaction;
    DocTransaction trn = e.Row as DocTransaction;
    if ((trn != null) && (trn.TranQty != old.TranQty ||
                                   trn.UnitPrice != old.UnitPrice))
    {
        Document doc = Receipts.Current;
        if (doc != null)
        {
            doc.TotalAmt -= old.TranQty * old.UnitPrice;
            doc.TotalAmt += trn.TranQty * trn.UnitPrice;
            Receipts.Update(doc);
        }
    }
} When a user selects a document transaction in the table on a webpage and updates the                 settings of the transaction, the  RowUpdated  event is triggered,                 and the code above is executed and updates the receipt total, as shown in the                 following screenshots.  Update of document transaction details Visual Web Designer Support The  Acumatica Framework Integrated Development Environment (IDE) is built on top of Microsoft Visual                 Studio. However, the  Acumatica Framework IDE implements its own set of web controls to generate an advanced GUI in a web                 browser. All of  Acumatica Framework's web controls have the same rendering and a similar appearance in design mode in                 the IDE and runtime mode in a web browser. Thus, the developer can utilize all the                 facilities of the Visual Web Designer component of Visual Studio. The application                 developer can use the convenient drag-and-drop mechanism to create an application                 form layout, to perform form visual editing, and to set a control's properties and                 behavior through an intuitive graphical interface. This approach does not require                 any knowledge of HTML or Java Script, yet allows the developer to create a                 professional and appealing web GUI. The following screenshots illustrate the design (left) and runtime (right) rendering. Webpage in design and runtime mode Master Pages, Templates, and CSS Support The Visual Studio project and item templates provide reusable and customizable project and                 item stubs that accelerate the development process, removing the need to create new                 projects and items from scratch. Project templates provide the basic files needed                 for a particular project type, include standard assembly references, and set the                 default project properties and compiler options.  Acumatica Framework distribution includes the following: The project template for the creation of a new application A set of page templates that automate the creation of typical page layouts The master pages mechanism in ASP.NET allows for the creation of an application that looks                 and feels consistent. Master pages define the standard appearance and behavior that                 is common in all application pages. You create individual content pages that refer                 to the master page. When a content page is requested, it merges with the master page                 to produce output that combines the layout and base functionality of the master page                 with the content of the requested page.  Acumatica Framework fully supports the master pages mechanism and provides you with a set of                 predefined master pages. You can design your own master pages or modify existing                 ones. A web application written with  Acumatica Framework         supports style modification through Cascading Style Sheets (CSS). Application Creation Wizards  Acumatica Framework                 provides a set of wizards for automating the creation of data access classes and                 webpages. The use of these wizards eliminates the manual steps associated with data                 access class creation and data binding configuration. The Data Access Class Generator, which is shown in the following screenshot, provides the                 application developer with a way to create and modify data access classes. It                 implements the following functionality: Reading the data structure from a table, SQL query, or external data source Creating a data access class based on the data structure received from external data                     source Reading the data access class structure from its definition and merging this structure                     with the data structure received from the external data source Automatic mapping of application-specific attributes based on the names of the properties                     of the external data source  Data Access Class Generator The Layout Editor, which is shown in the following screenshot, automates the creation of new                 web forms. It uses metadata stored in the business logic controller and data access                 class to help the application developer create new web forms or to modify existing                 ones. The  Layout Editor  wizard implements the following                 features: Reading metadata from the business logic controller and the data access class and creating a                     list of controls that could be added to the webpage Adding the controls selected by the programmer to the webpage Updating the webpage controls with the changed business logic controller and the data                     access class metadata Layout Editor ]]></column>
		</row>
		<row PageID="6c91a5d7-70d6-4a7e-9cfd-7d59faeae258" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="48bac540-05c2-573d-93fa-4959e7418f64" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can review the architecture of an application created based on Acumatica Framework, such as Acumatica ERP, customizations of Acumatica ERP, and applications based purely on Acumatica Framework.{br}

An application written with Acumatica Framework has ''n''-tier architecture with a clear separation of the presentation, business, and data access layers, as shown in the following diagram. You can find details about each layer in the sections below.[anchor|#_d080a75d-b6b1-487c-941c-a75aacb3f27f][anchor|#_da4afe73-67f3-49db-b4e1-b22c92bdfc63][image:StudioDeveloperGuide/Images/ApplicationArchitecture.png|popup|Application architecture|450px]{br}{TOC}
==Data Access Layer==
The data access layer is implemented as a set of data access classes (DACs) that wrap data from database tables or data received through other external sources (such as Amazon Web Services). You can generate a data access class associated with a database table with the help of the Data Access Class Generator, which reads database metadata. When you use it, you select a table and specify the columns that should be reflected in the data access class. {br}

The instances of data access classes are maintained by the business logic layer. Between requests, these instances are stored in the session. On a standalone Acumatica ERP server, session data is stored in the server memory. In a cluster of application servers, session data is serialized and stored in a high-performance remote server through a custom optimized serialization mechanism. For details about data storage in session, see [HelpRoot_Dev_Platform\AD__con_Session|Session].{br}

For details on working with the data access layer, see [HelpRoot_Dev_Platform\AD__mng|Accessing Data].
==Business Logic Layer==
The business logic is implemented though the business logic controller (also called ''graph''). Business logic controllers are classes that you derive from the special API class (<tt>PXGraph</tt>) and that are tied to one or more data access classes.{br}

Each business logic controller conceptually consists of two parts: [anchor|#_97c851cb-a1c7-4f84-86c0-fdbaa50af40f]
*Data views, which include the references to the required data access classes, their relationships, and other meta information 
*Business logic, which consists of actions and events associated with the modified data. 
{br}

Each business logic controller can be accessed from the presentation layer or from the application code that is implemented within another business logic controller. When the business logic controller receives an execution request, it extracts the data required for request execution from the data access classes included in the data views, triggers business logic execution, returns the result of the execution to the requesting party, and updates the data access classes instances with the modified data.{br}

For details on working with the business logic layer, see [HelpRoot_Dev_Platform\BL__mng|Implementing Business Logic].
==Presentation Layer==
The presentation layer provides access to the application business logic through the UI, web services, and Acumatica mobile application. The presentation layer is completely declarative and contains no business logic.{br}

The UI consists of ASPX webpages (which are based on the ASP.NET Web Forms technology) and reports created with Acumatica Report                         Designer. The ASPX webpages are bound to particular business logic controllers. You create webpages from the templates provided with Acumatica Framework and modify them with the help of the Layout Editor, which utilizes metadata information extracted from the business logic controller. Reports created with Acumatica Report                         Designer are loaded and executed by using the predefined business logic controller included in Acumatica Framework. For details about processing of the reports in the system, see [HelpRoot_Dev_Platform\CC__con_Rendering_of_Reports|Display of Reports].{br}

When the user requests a new webpage, the presentation layer is responsible for processing this request. Webpages are used for generating static HTML page content and providing additional service information required for the dynamic configuration of the web controls. When the user receives the requested page and starts browsing or entering data, the presentation layer is responsible for handling asynchronous HTTP requests. During processing, the presentation layer submits a request to the business logic layer for execution. Once execution is completed, the business logic layer analyzes any changes in the business logic container state and generates the response that is sent back to the browser as an XML document.{br}

For details on the configuration of ASPX webpages, see [HelpRoot_Dev_Platform\CW__mng|Configuring ASPX Webpages and Reports].{br}

Web services and mobile app pages provide alternative interfaces to the application business logic. From the side of the business logic controller, a request from a webpage, the web services, or an mobile app page are identical and, thus, cause the execution of exactly the same business logic. ]]></column>
			<column name="PlainText"><![CDATA[Runtime Architecture of an Application Based on  Acumatica FrameworkIn this topic, you can review the architecture of an application created based on  Acumatica Framework, such as  Acumatica ERP, customizations of  Acumatica ERP, and applications based purely on  Acumatica Framework. An application written with  Acumatica Framework has  n -tier architecture with a clear separation of the presentation,                 business, and data access layers, as shown in the following diagram. You can find                 details about each layer in the sections below. Application architecture Data Access Layer The data access layer is implemented as a set of data access classes (DACs) that wrap                 data from database tables or data received through other external sources (such as                 Amazon Web Services). You can generate a data access class associated with a                 database table with the help of the Data Access Class Generator, which reads                 database metadata. When you use it, you select a table and specify the columns that                 should be reflected in the data access class.  The instances of data access classes are maintained by the business logic layer.                 Between requests, these instances are stored in the session. On a standalone  Acumatica ERP server, session data is stored in the server memory. In a cluster of application                 servers, session data is serialized and stored in a high-performance remote server                 through a custom optimized serialization mechanism. For details about data storage                 in session, see  Session. For details on working with the data access layer, see  Accessing Data. Business Logic Layer The business logic is implemented though the business logic controller (also called                      graph ). Business logic controllers are classes that you derive from the                 special API class ( PXGraph ) and that are tied to one or more data                 access classes. Each business logic controller conceptually consists of two parts:  Data views, which include the references to the required data access                         classes, their relationships, and other meta information  Business logic, which consists of actions and events associated with the                         modified data.  Each business logic controller can be accessed from the presentation layer or from                 the application code that is implemented within another business logic controller.                 When the business logic controller receives an execution request, it extracts the                 data required for request execution from the data access classes included in the                 data views, triggers business logic execution, returns the result of the execution                 to the requesting party, and updates the data access classes instances with the                 modified data. For details on working with the business logic layer, see  Implementing Business Logic. Presentation Layer The presentation layer provides access to the application business logic through the UI, web                 services, and  Acumatica mobile application. The presentation layer is completely declarative and contains                 no business logic. The UI consists of ASPX webpages (which are based on the ASP.NET Web Forms                 technology) and reports created with  Acumatica Report                         Designer. The ASPX webpages are bound to particular business logic controllers. You create                 webpages from the templates provided with  Acumatica Framework and modify them with the help of the Layout Editor, which utilizes metadata                 information extracted from the business logic controller. Reports created with  Acumatica Report                         Designer are loaded and executed by using the predefined business logic controller                 included in  Acumatica Framework. For details about processing of the reports in the system, see  Display of Reports. When the user requests a new webpage, the presentation layer is responsible for processing                 this request. Webpages are used for generating static HTML page content and                 providing additional service information required for the dynamic configuration of                 the web controls. When the user receives the requested page and starts browsing or                 entering data, the presentation layer is responsible for handling asynchronous HTTP                 requests. During processing, the presentation layer submits a request to the                 business logic layer for execution. Once execution is completed, the business logic                 layer analyzes any changes in the business logic container state and generates the                 response that is sent back to the browser as an XML document. For details on the configuration of ASPX webpages, see  Configuring ASPX Webpages and Reports. Web services and mobile app pages provide alternative interfaces to the application business                 logic. From the side of the business logic controller, a request from a webpage, the                 web services, or an mobile app page are identical and, thus, cause the execution of                 exactly the same business logic.  ]]></column>
		</row>
		<row PageID="009b7519-160a-4a00-9524-c74fa925b851" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="9bbb8e46-ae2d-3531-ea39-3790b03a3ed7" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this part of the guide, you can find the information that you may need to start development with Acumatica Framework.{br}{TOC}
==System Requirements==
You can find the full list of system requirements in [HelpRoot_Install\System_Requirements_Studio|System Requirements for Acumatica Framework 2019 R1] in the Installation Guide.
==Installation==
For detailed information about the installation of Acumatica Framework, see [HelpRoot_Install\Installing_Acumatica_Studio|Installing Acumatica Framework] in the Installation Guide.
==Application Design==
For the information about the design of the database structure and user interface of applications based on Acumatica Framework, see [HelpRoot_Dev_Platform\DA__mng|Designing the Application] in this guide.
==Development of the Application Code==
Before you begin developing application code, we recommend that you complete the following training courses:[anchor|#_c4b09d91-5ae4-4016-9910-7c17c6bde71f]
*[https://openuni.acumatica.com/courses/development/t100-introduction-to-acumatica-framework/|T100 Development: Introduction to Acumatica Framework]
* [https://openuni.acumatica.com/courses/development/t200-acumatica-framework-fundamentals/|T200 Development: Acumatica Framework Fundamentals]
{br}

For a quick overview of application programming, refer to the topics in this part of the guide.{br}

In the Acumatica Framework Guide, you can find reference information and additional information that is not covered in the training courses. This information is provided in the following parts of the guide:[anchor|#_d5347901-332e-44c9-912c-8fa0d71bd5f6]
*[HelpRoot_Dev_Platform\CW__mng|Configuring ASPX Webpages and Reports]: About the development of ASPX pages 
*[HelpRoot_Dev_Platform\AD__mng|Accessing Data]: About business query language (BQL) and working with data in cache and session
*[HelpRoot_Dev_Platform\BL__mng|Implementing Business Logic]: About events, attributes, long-running operations, and other topics related to business logic development
*[HelpRoot_Dev_Platform\TS__mng|Troubleshooting Acumatica Framework-Based Applications]: About debugging the Acumatica Framework-based applications and fixing the common errors
{br}

For a detailed description of the Acumatica Framework API, see [https://help.acumatica.com/(W(16))/Main?ScreenId=ShowWiki&pageid=41f852ad-6736-e6fa-d080-006a9776ed78|API Reference].[anchor|#_d87022d9-2f30-4116-b673-c4ff24617483]
==Website Management==
For the classic UI, if you want to adjust the position of a webpage in the site map, add a new page to the site map, or remove a page from the site map, you configure the site map of the website, as described in [HelpRoot_Administration\SM__con_Site_Map_Management|Managing the Site Map] in the System Administration Guide.{br}

If you want to modify the position of a webpage in the modern UI, add a page to a workspace, or remove a page in the modern UI, you configure the modern UI as described in [HelpRoot_Administration\AS__mng_User_Interface_Configuration|Customizing the User Interface] in the System Administration Guide.{br}

You need to grant access rights to each new page. For details on the configuration of access rights, see [HelpRoot_Administration\US__mng_Roles|Managing User Access Rights] in the System Administration Guide.{br}

You can create help topics for any application you have developed with Acumatica Framework by using the built-in wiki-based content management system. For details on creating help topics, see [HelpRoot_Administration\DM__mng_Wikis|Managing Wikis].
==In This Part==[anchor|#_e01ad0b2-335f-442c-8afb-1d82964abed9]
*[HelpRoot_Dev_Platform\FGS__con_Data_Query|Data Querying]
*[HelpRoot_Dev_Platform\FGS__con_BLC_Declaration|Business Logic Controller Declaration]
*[HelpRoot_Dev_Platform\FGS__con_Data_View_and_Cache|Data View and Cache]
*[HelpRoot_Dev_Platform\FGS__con_Data_Modification_Scenarios|Data Modification Scenarios]
*[HelpRoot_Dev_Platform\FGS__con_Business_Logic_Implementation|Business Logic Implementation]
]]></column>
			<column name="PlainText"><![CDATA[Getting Started with  Acumatica FrameworkIn this part of the guide, you can find the information that you may need to start         development with  Acumatica Framework. System Requirements You can find the full list of system requirements in  System Requirements for Acumatica Framework 2019 R1 in the Installation         Guide. Installation For detailed information about the installation of  Acumatica Framework,         see  Installing Acumatica Framework in the Installation         Guide. Application Design For the information about the design of the database structure and user interface of         applications based on  Acumatica Framework,         see  Designing the Application in this guide. Development of the Application Code Before you begin developing application code, we recommend that you complete the following         training courses: T100 Development: Introduction to  Acumatica FrameworkT100 Development: Introduction to Acumatica FrameworkT200 Development:  Acumatica Framework Fundamentals T200 Development: Acumatica Framework FundamentalsFor a quick overview of application programming, refer to the topics in this part of the         guide. In the  Acumatica Framework         Guide, you can find reference information and additional information that is not covered in         the training courses. This information is provided in the following parts of the guide: Configuring ASPX Webpages and Reports: About the development of ASPX pages  Accessing Data: About business query language (BQL) and working with data             in cache and session Implementing Business Logic: About events, attributes, long-running operations, and             other topics related to business logic development Troubleshooting Acumatica Framework-Based Applications: About debugging the  Acumatica Framework-based applications and fixing the common errors For a detailed description of the  Acumatica Framework         API, see  API Reference API Reference. Website Management For the classic UI, if you want to adjust the position of a webpage in the site map, add a         new page to the site map, or remove a page from the site map, you configure the site map of         the website, as described in  Managing the Site Map in         the System Administration Guide. If you want to modify the position of a webpage in the modern UI, add a page to a         workspace, or remove a page in the modern UI, you configure the modern UI as described in            Customizing the User Interface in the System         Administration Guide. You need to grant access rights to each new page. For details on the configuration of         access rights, see  Managing User Access Rights in the System         Administration Guide. You can create help topics for any application you have developed with  Acumatica Framework         by using the built-in wiki-based content management system. For details on creating help         topics, see  Managing Wikis. In This Part Data QueryingBusiness Logic Controller DeclarationData View and CacheData Modification ScenariosBusiness Logic Implementation]]></column>
		</row>
		<row PageID="9241a976-e062-4978-be14-2c1135642be2" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="d3cd0de3-99d2-7b11-df3b-01cd04aaf5de" RecordSourceID="22377">
			<column name="Content"><![CDATA[
This system implements a custom language for writing database queries called BQL (business query language). It is not LINQ and doesn&rsquo;t use it. BQL is written in C# and based on generic classes syntax, but still is very similar to SQL syntax. It has almost the same keywords placed in the order they are used in SQL, as shown in the following example.<source lang="csharp">PXSelect&lt;Product,
    Where&lt;Product.availQty, IsNotNull,
        And&lt;Product.availQty, Greater&lt;Product.bookedQty&gt;&gt;&gt;&gt;</source>
If the database provider is MIcrosoft SQL Server, the framework translates this expression into the following SQL query.{{{{SELECT * FROM Product
WHERE Product.AvailQty IS NOT NULL
    AND Product.AvailQty &gt; Product.BookedQty 
}}}}
BQL gives several benefits to the application developer. It does not depend on database-provider specifics, is object-oriented and extendable. An important benefit is compile-time syntax validation, which helps to prevent SQL syntax errors.{br}

Since BQL is implemented on top of generic classes, you need types that would represent database tables. In the context of Acumatica Framework, they are called data access classes (DACs).{br}

For example, to execute the SQL query from the example above, you should define the <tt>Product</tt> data access class as shown in the following code fragment.<source lang="csharp">using System;
using PX.Data;

// Types used in BQL statements should derive from special interfaces:
// table - IBqlTable, column - IBqlField.
[System.SerializableAttribute()]
public class Product : PX.Data.IBqlTable
{
    // The type used in BQL statements to reference the ProductID column
    public abstract class productID : PX.Data.IBqlField
    {
    }
    // The property holding ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }

    // The type used in BQL statements to reference the AvailQty column
    public abstract class availQty : PX.Data.IBqlField
    {
    }
    // The property holding AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }

    // The type used in BQL statements to reference the BookedQty column
    public abstract class bookedQty : PX.Data.IBqlField
    {
    }
    // The property holding BookedQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? BookedQty { get; set; }
}</source>
Each table field is declared in a data access class twice:[anchor|#ul_ijc_z2j_4k]
*A {{public abstract}} class (which is also referred to as ''class field'') to reference a field in the BQL command
*A {{public virtual}} property (which is also referred to as ''property field'') to hold the table field data

If the DAC is bound to the database, it must have the same class name as the database table. Fields are bound to the database by means of data mapping attributes (such as <tt>PXDBIdentity</tt> and <tt>PXDBDecimal</tt>), using the same naming convention.{br}

The code below demonstrates an example of how to get data records from the database.{{{{// Select Product records
PXResultset&lt;Product&gt; res = PXSelect&lt;Product, Where&lt;Product.availQty, IsNotNull,
                           And&lt;Product.availQty, Greater&lt;Product.bookedQty&gt;&gt;&gt;&gt;
                     .Select(new PXGraph());
// You can iterate through the result set
foreach(PXResult&lt;Product&gt; rec in res)
{
    // A record from the result set can be cast to the DAC
    Product p = (Product)rec;
    ...
}
}}}}
==Related Articles==
*[HelpRoot_Dev_Platform\AD__mng_Traditional_BQL|Creating Traditional BQL Queries]]]></column>
			<column name="PlainText"><![CDATA[Data Querying This system implements a custom language for writing database queries called BQL (business         query language). It is not LINQ and doesn't use it. BQL is written in C# and based on         generic classes syntax, but still is very similar to SQL syntax. It has almost the same         keywords placed in the order they are used in SQL, as shown in the following example. PXSelect<Product,
    Where<Product.availQty, IsNotNull,
        And<Product.availQty, Greater<Product.bookedQty>>>> If the database provider is MIcrosoft SQL Server, the framework translates this expression         into the following SQL query. SELECT * FROM Product
WHERE Product.AvailQty IS NOT NULL
    AND Product.AvailQty > Product.BookedQty  BQL gives several benefits to the application developer. It does not depend on         database-provider specifics, is object-oriented and extendable. An important benefit is         compile-time syntax validation, which helps to prevent SQL syntax errors. Since BQL is implemented on top of generic classes, you need types that would represent         database tables. In the context of  Acumatica Framework,         they are called data access classes (DACs). For example, to execute the SQL query from the example above, you should define the            Product  data access class as shown in the following code fragment. using System;
using PX.Data;

// Types used in BQL statements should derive from special interfaces:
// table - IBqlTable, column - IBqlField.
[System.SerializableAttribute()]
public class Product : PX.Data.IBqlTable
{
    // The type used in BQL statements to reference the ProductID column
    public abstract class productID : PX.Data.IBqlField
    {
    }
    // The property holding ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }

    // The type used in BQL statements to reference the AvailQty column
    public abstract class availQty : PX.Data.IBqlField
    {
    }
    // The property holding AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }

    // The type used in BQL statements to reference the BookedQty column
    public abstract class bookedQty : PX.Data.IBqlField
    {
    }
    // The property holding BookedQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? BookedQty { get; set; }
} Each table field is declared in a data access class twice: A  public abstract  class (which is also referred to as  class             field ) to reference a field in the BQL command A  public virtual  property (which is also referred to as  property             field ) to hold the table field data If the DAC is bound to the database, it must have the same class name as the database         table. Fields are bound to the database by means of data mapping attributes (such as            PXDBIdentity  and  PXDBDecimal ), using the same naming         convention. The code below demonstrates an example of how to get data records from the database. // Select Product records
PXResultset<Product> res = PXSelect<Product, Where<Product.availQty, IsNotNull,
                           And<Product.availQty, Greater<Product.bookedQty>>>>
                     .Select(new PXGraph());
// You can iterate through the result set
foreach(PXResult<Product> rec in res)
{
    // A record from the result set can be cast to the DAC
    Product p = (Product)rec;
    ...
} ]]></column>
		</row>
		<row PageID="61e0a0e8-78e2-4ebf-a0f1-eae124a6283e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="29949027-afbc-13cb-e792-c4e7e0c3721c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Working with the business data in Acumatica Framework is implemented through the ''business logic controller'' object also referred as ''graph '' (graph is a mathematical term for a set of objects where some pairs of objects are connected by links). A graph provides the interface for the presentation logic to operate with the business data and relies on Data Access Layer components to store and retrieve the business data from the database.{br}

The following example shows the declaration of a simple business logic controller.<source lang="csharp">//Declaration of the graph
public class ProductMaint : PXGraph&lt;ProductMaint&gt;
{
    //Declaration of the data view
    public PXSelect&lt;Product&gt; Products;

    //Declaration of the actions
    public PXCancel&lt;Product&gt; Cancel;
    public PXSave&lt;Product&gt; Save;
}</source>
In this example, the graph implements the following interfaces:[anchor|#ul_orv_lfq_tk]
*'''Products''' – the ''data view'' that can be used for querying and modifying the data 
*'''Cancel''' – the ''action'' that discard all the changes made to the data and reloads it from the database
*'''Save''' – the ''action'' that commits the changes made to the data to the database and then reloads the committed data
]]></column>
			<column name="PlainText"><![CDATA[Business Logic Controller Declaration Working with the business data in  Acumatica Framework         is implemented through the  business logic controller  object also referred as  graph           (graph is a mathematical term for a set of objects where some pairs of objects are         connected by links). A graph provides the interface for the presentation logic to operate         with the business data and relies on Data Access Layer components to store and retrieve the         business data from the database. The following example shows the declaration of a simple business logic controller. //Declaration of the graph
public class ProductMaint : PXGraph<ProductMaint>
{
    //Declaration of the data view
    public PXSelect<Product> Products;

    //Declaration of the actions
    public PXCancel<Product> Cancel;
    public PXSave<Product> Save;
} In this example, the graph implements the following interfaces: Products  – the  data view  that can be used for querying and modifying the           data  Cancel  – the  action  that discard all the changes made to the data and           reloads it from the database Save  – the  action  that commits the changes made to the data to the           database and then reloads the committed data ]]></column>
		</row>
		<row PageID="cd8f9db9-2965-4ce4-9ae8-4714898fdc44" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ebed89d0-80c7-09d4-1d25-ca44f0fbfc1b" RecordSourceID="22377">
			<column name="Content"><![CDATA[Data views implement the interfaces for querying the data from the database and submitting modified data to the cache. 
Data views are declared in business logic controllers as public fields of <tt>PXSelect</tt> command type, as shown in the following code.<source lang="csharp">public PXSelect&lt;Product&gt; Products;</source>
Based on this declaration, the system automatically instantiates the DAC cache.{br}

A ''DAC cache'' object in the Acumatica Framework is the primary interface for working with individual records from the graph business logic. It has two components and two primary responsibilities:[anchor|#ul_f3y_4fq_tk]
*The <tt>Cached</tt> collection: In-memory cache that contains modified entity records. The <tt>Cached</tt> collection is instantiated based on the corresponding DAC declaration and managed by the cache.
*The controller: The cache component that implements basic CRUD (create, read, update, delete) operations on the <tt>Cached</tt> collection and triggers a sequence of data manipulation events when modifying or accessing the data in the <tt>Cached</tt> collection. These events can be later subscribed from the graph to implement the business logic associated with the data modification.

The diagram below shows the internal graph structure and responsibilities of the data view and the cache.[anchor|#_95dbe30c-8feb-4f68-88f4-6093a92ffa5a][anchor|#image_t3d_csq_tk][image:StudioDeveloperGuide/Images/GraphStructure.png|popup|The graph structure|320px]]]></column>
			<column name="PlainText"><![CDATA[Data View and Cache Data views implement the interfaces for querying the data from the database and       submitting modified data to the cache.  Data views are declared in business logic         controllers as public fields of  PXSelect  command type, as shown in the         following         code. public PXSelect<Product> Products; Based         on this declaration, the system automatically instantiates the DAC cache. A  DAC           cache  object in the  Acumatica Framework         is the primary interface for working with individual records from the graph business logic.         It has two components and two primary responsibilities: The  Cached  collection: In-memory cache that contains modified entity           records. The  Cached  collection is instantiated based on the           corresponding DAC declaration and managed by the cache. The controller: The cache component that implements basic CRUD (create, read, update,           delete) operations on the  Cached  collection and triggers a sequence of           data manipulation events when modifying or accessing the data in the              Cached  collection. These events can be later subscribed from the           graph to implement the business logic associated with the data modification. The diagram below shows the internal graph structure and responsibilities of the data         view and the cache. The graph structure ]]></column>
		</row>
		<row PageID="e6fb8c00-e144-489a-9648-d66ada46e67f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="80d516c9-aa7a-f9e8-7828-a02a3a0f8c0d" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can find the basic data manipulation scenarios that can be executed from the graph business logic or from the user interface. Entity data manipulation through the user interface indirectly invokes the same methods as the direct call from the business logic controller.{br}{TOC}
==Querying the Data for the First Time==
The data can be requested through the <tt>Select</tt> method of the data view. During this operation, the systems executes BQL command from the data view declaration. The data returned by the BQL command is passed to the requester. The following diagram illustrates this process.[anchor|#image_sry_k1r_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_FirstQuery.png|popup|Querying the data for the first time|450px]
==Updating an Existing Record==
An existing record can be updated through the <tt>Update(record)</tt> method of the data view. This method places the modified record into the cache. {br}

If the data record is not found in the <tt>Cached</tt> collection, the cache controller loads the data record from the database, adds it to the <tt>Cached</tt> collection, marks it as updated, and updates it with the new values. The search of the data record in the <tt>Cached</tt> collection and loading of the data record from the database is based on the DAC key fields. The diagram below illustrates this scenario.[anchor|#image_tyk_c3r_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_UpdateFirstTime.png|popup|Updating the record for the first time|450px]
If the updated record exists in the <tt>Cached</tt> collection the cache controller locates it and updates it with the new values. The diagram below illustrates this scenario.[anchor|#image_f3s_l3r_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_UpdateCached.png|popup|Updating the cached (previously modified) record|450px]
==Inserting a New Record==
A new record can be inserted into the cache through the <tt>Insert(record)</tt> method of the data view. The new inserted record is added to the <tt>Cached</tt> collection and marked as inserted. The diagram below illustrates this scenario.[anchor|#image_h2z_lkr_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_InsertNewRecord.png|popup|Inserting the new record|450px]
==Deleting an Existing Record==
An existing record can be deleted from the cache using the <tt>Delete(record)</tt> method, of the data view. {br}

If the data record is not found in the <tt>Cached</tt> collection, the cache controller loads the data record from the database, adds it to the <tt>Cached</tt> collection, and marks it as deleted. The search of the data record in the <tt>Cached</tt> collection and loading of the data record from the database is based on the DAC key fields. The diagram below illustrates this scenario.[anchor|#image_obg_4lr_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_DeleteNotCached.png|popup|Deleting the non-cached (unmodified) record|450px]
If the deleted record is found in the <tt>Cached</tt> collection, the cache controller locates it and marks as deleted. The diagram below illustrates this scenario.[anchor|#image_ghj_rlr_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_DeleteCached.png|popup|Deleting of the cached (previously modified) record|450px]
==Querying Updated Data==
The data can be modified and then queried again. In this scenario, the data records stored in the cache memory are merged with the result of the BQL command execution. Data record merge is based on DAC key fields. The final result of the <tt>Select()</tt> execution incorporates all the earlier record modifications that have not been preserved to the database yet. The diagram below illustrates this scenario.[anchor|#image_hk2_h4r_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_QueryUpdated.png|popup|Querying the modified data |450px]
==Persisting Changes to the Database==
When the data is modified, the system has two different versions of the data: the new one stored in the caches memory and the original one persisted in the database. At this point you have two options:[anchor|#ul_yg4_vfq_tk]
*Save the new version of data to the database using the <tt>Persist()</tt> method of the graph
*Discard all in-memory changes and load the original data version using the <tt>Clear()</tt> method of the graph

From the user interface these methods are called by invocation of the <tt>Save</tt> and <tt>Cancel</tt> actions. These actions are predefined and mapped to the <tt>Persist()</tt> and <tt>Clear()</tt> methods.{br}

The diagram below illustrated saving of the changes to the database.[anchor|#image_cjd_zqr_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_SaveChanges.png|popup|Saving the changes to the database|450px]
The diagram below illustrates discarding of all in-memory entity changes.[anchor|#image_xkc_gsr_tk][image:StudioDeveloperGuide/Images/DataModificationScenarios_DiscardChanges.png|popup|Discarding the changes and loading the original data|450px]
==Preserving the Data Version Between the Round Trips and Handling the Subsequent Selects from the Views==
It is important to understand that a graph is a stateless object. It is discarded after each data request. In order to preserve the modified data version between the requests, the cache controller serializes the <tt>Cached</tt> collection into the session state and restores it later when the graph is instantiated on the subsequent request. In this scenario, it is very important that the cache contains only the modified entity records, not the complete entity record set.
==Related Articles==
*[HelpRoot_Dev_Platform\AD__mng_Working_with_Cache_and_Session|Working with Data in Cache and Session]]]></column>
			<column name="PlainText"><![CDATA[Data Modification Scenarios In this topic, you can find the basic data manipulation scenarios that can be executed from         the graph business logic or from the user interface. Entity data manipulation through the         user interface indirectly invokes the same methods as the direct call from the business         logic controller. Querying the Data for the First Time The data can be requested through the  Select  method of the data view.         During this operation, the systems executes BQL command from the data view declaration. The         data returned by the BQL command is passed to the requester. The following diagram         illustrates this process. Querying the data for the first time Updating an Existing Record An existing record can be updated through the  Update(record)  method of the         data view. This method places the modified record into the cache.  If the data record is not found in the  Cached  collection, the cache         controller loads the data record from the database, adds it to the  Cached          collection, marks it as updated, and updates it with the new values. The search of the data         record in the  Cached  collection and loading of the data record from the         database is based on the DAC key fields. The diagram below illustrates this scenario. Updating the record for the first time If the updated record exists in the  Cached  collection the cache         controller locates it and updates it with the new values. The diagram below illustrates this         scenario. Updating the cached (previously modified) record Inserting a New Record A new record can be inserted into the cache through the  Insert(record)          method of the data view. The new inserted record is added to the  Cached          collection and marked as inserted. The diagram below illustrates this scenario. Inserting the new record Deleting an Existing Record An existing record can be deleted from the cache using the  Delete(record)          method, of the data view.  If the data record is not found in the  Cached  collection, the cache         controller loads the data record from the database, adds it to the  Cached          collection, and marks it as deleted. The search of the data record in the            Cached  collection and loading of the data record from the database is         based on the DAC key fields. The diagram below illustrates this scenario. Deleting the non-cached (unmodified) record If the deleted record is found in the  Cached  collection, the cache         controller locates it and marks as deleted. The diagram below illustrates this scenario. Deleting of the cached (previously modified) record Querying Updated Data The data can be modified and then queried again. In this scenario, the data records stored in         the cache memory are merged with the result of the BQL command execution. Data record merge         is based on DAC key fields. The final result of the  Select()  execution         incorporates all the earlier record modifications that have not been preserved to the         database yet. The diagram below illustrates this scenario. Querying the modified data  Persisting Changes to the Database When the data is modified, the system has two different versions of the data: the new one stored         in the caches memory and the original one persisted in the database. At this point you have         two options: Save the new version of data to the database using the  Persist()            method of the graph Discard all in-memory changes and load the original data version using the              Clear()  method of the graph From the user interface these methods are called by invocation of the  Save  and            Cancel  actions. These actions are predefined and mapped to the            Persist()  and  Clear()  methods. The diagram below illustrated saving of the changes to the database. Saving the changes to the database The diagram below illustrates discarding of all in-memory entity changes. Discarding the changes and loading the original data Preserving the Data Version Between the Round Trips and Handling the Subsequent Selects         from the Views It is important to understand that a graph is a stateless object. It is discarded after each         data request. In order to preserve the modified data version between the requests, the cache         controller serializes the  Cached  collection into the session state and         restores it later when the graph is instantiated on the subsequent request. In this         scenario, it is very important that the cache contains only the modified entity records, not         the complete entity record set. ]]></column>
		</row>
		<row PageID="b02bd27f-3e86-4210-9e0f-c0df7aa701d9" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="4c3eb8d0-4e76-bcb5-8ccc-ae4b044d68af" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Business logic is implemented by overloading certain methods invoked by the system in the process of manipulating data. For such procedures as inserting a data record or updating a data record, the <tt>PXCache</tt> controllers generate series of events causing invocation of the methods called event handlers. The application is able to interfere in the series of events on different stages. For this purpose, the application implements methods that are executed as event handlers.{br}

Business logic can be divided into common logic relevant to different parts of the application and the logic specific to an application screen (webpage). The common logic is implemented through event handler methods defined in attributes, while the screen-specific logic is implemented as methods in the associated graph. {br}{TOC}
==Common Business Logic==
You implement the common business logic by defining event handlers in attributes. If such attribute is added to the declaration of a data access class, attribute logic is applied to the data records of this type for any graph used to access this table.{br}

There are a number of predefined attributes implemented in the framework. For example, in the following declaration of a data field for a column, the <tt>PXDBDecimal</tt> attribute binds this field to a database column of the decimal type. <source lang="csharp">[PXDBDecimal(2)]
public virtual string AvailQty { get; set; }</source>
The attributes that bind a field to a specific data type exist for most database data types.{br}

Another typical example of an attribute is <tt>PXUIField</tt>. It is used to configure the input control for the column in the user interface. This allows having the same visual representation of the column on all application screens (unless a screen redefines it). The following example shows the use of the <tt>PXUIField</tt> attribute.<source lang="csharp">[PXDBDecimal(2)]
[PXUIField(DisplayName = "Available Qty", Enabled = false)]
public virtual string AvailQty { get; set; }</source>
You can also defined your own attributes, as shown in the following code.<source lang="csharp">// Application-defined attribute that implements common business logic
public class MyAttribute : PXEventSubscriberAttribute,
                           IPX''EventName''Subscriber
{
    // An event handler
    protected virtual void ''EventName''(PXCache sender,
                                     PX''RowEventName''EventArgs e)
    {
        ...
    }
    ...
}</source>
These custom attributes can also be added to the DAC declaration, as shown in the following example.<source lang="csharp">[PXDBDecimal(2)]
[PXUIField(DisplayName = "Available Qty", Enabled = false)]
[MyAttribute]
public virtual string AvailQty { get; set; }</source>
For details about attributes, see [HelpRoot_Dev_Platform\BL__mng_Working_With_Attributes|Working with Attributes].
==Screen-Specific Business Logic==
For a specific screen, the application can redefine the common logic or extend it. For this purpose, you should define event handlers in the graph associated with the screen. Each event handler method is tied to a particular table or a table field via the naming convention.{br}

For example, you can verify a value of a column as shown in the following code.<source lang="csharp">public class ProductRecalc : PXGraph&lt;ProductRecalc&gt;
{
    ...
    // Event handler verifying that the value of the AvailQty column
    // in Product records is greater than 0.
    // It is triggered when, for instance, a Product record is updated.
    protected virtual void Product_AvailQty_FieldVerifying(
        PXCache sender, 
        PXFieldVerifyingEventArgs e)
    {
        Product p = (Product)e.Row;
        if (p != null && p.AvailQty != null)
        {
            if (p.AvailQty &lt; 0)
                throw new PXSetPropertyException&lt;Product.availQty&gt;(
                    "Value must be greater than 0.");
        }
    }
}</source>
For details about events, see [HelpRoot_Dev_Platform\BL__mng_Working_With_Events|Working with Events].
==Related Articles==
*[HelpRoot_Dev_Platform\BL__mng|Implementing Business Logic]]]></column>
			<column name="PlainText"><![CDATA[Business Logic Implementation Business logic is implemented by overloading certain methods invoked by the system in the         process of manipulating data. For such procedures as inserting a data record or updating a         data record, the  PXCache  controllers generate series of events causing         invocation of the methods called event handlers. The application is able to interfere in the         series of events on different stages. For this purpose, the application implements methods         that are executed as event handlers. Business logic can be divided into common logic relevant to different parts of the         application and the logic specific to an application screen (webpage). The common logic is         implemented through event handler methods defined in attributes, while the screen-specific         logic is implemented as methods in the associated graph.  Common Business Logic You implement the common business logic by defining event handlers in attributes. If such         attribute is added to the declaration of a data access class, attribute logic is applied to         the data records of this type for any graph used to access this table. There are a number of predefined attributes implemented in the framework. For example, in         the following declaration of a data field for a column, the  PXDBDecimal          attribute binds this field to a database column of the decimal type.  [PXDBDecimal(2)]
public virtual string AvailQty { get; set; } The attributes that bind a field to a specific data type exist for most database data         types. Another typical example of an attribute is  PXUIField . It is used to         configure the input control for the column in the user interface. This allows having the         same visual representation of the column on all application screens (unless a screen         redefines it). The following example shows the use of the  PXUIField          attribute. [PXDBDecimal(2)]
[PXUIField(DisplayName = "Available Qty", Enabled = false)]
public virtual string AvailQty { get; set; } You can also defined your own attributes, as shown in the following code. // Application-defined attribute that implements common business logic
public class MyAttribute : PXEventSubscriberAttribute,
                           IPX EventName Subscriber
{
    // An event handler
    protected virtual void  EventName (PXCache sender,
                                     PX RowEventName EventArgs e)
    {
        ...
    }
    ...
} These custom attributes can also be added to the DAC declaration, as shown in the following         example. [PXDBDecimal(2)]
[PXUIField(DisplayName = "Available Qty", Enabled = false)]
[MyAttribute]
public virtual string AvailQty { get; set; } For details about attributes, see  Working with Attributes. Screen-Specific Business Logic For a specific screen, the application can redefine the common logic or extend it. For this         purpose, you should define event handlers in the graph associated with the screen. Each         event handler method is tied to a particular table or a table field via the naming         convention. For example, you can verify a value of a column as shown in the following code. public class ProductRecalc : PXGraph<ProductRecalc>
{
    ...
    // Event handler verifying that the value of the AvailQty column
    // in Product records is greater than 0.
    // It is triggered when, for instance, a Product record is updated.
    protected virtual void Product_AvailQty_FieldVerifying(
        PXCache sender, 
        PXFieldVerifyingEventArgs e)
    {
        Product p = (Product)e.Row;
        if (p != null && p.AvailQty != null)
        {
            if (p.AvailQty < 0)
                throw new PXSetPropertyException<Product.availQty>(
                    "Value must be greater than 0.");
        }
    }
} For details about events, see  Working with Events. ]]></column>
		</row>
		<row PageID="7e631d16-e6c2-4d16-bc39-10d2d6780110" Language="en-US" PageRevisionID="1" Content="&#xA;This part of the guide contains the design guidelines for the database schema and applications built on Acumatica Framework.&#xA;==In This Part==[anchor|#ul_rkc_brc_kk]&#xA;*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]&#xA;*[HelpRoot_Dev_Platform\DA__mng_Designing_UI|Designing the User Interface]&#xA;*[HelpRoot_Dev_Platform\DA__mng_Code_Guidelines|Naming the Graphs and Event Handlers]&#xA;" PlainText="Designing the Application This part of the guide contains the design guidelines for the database schema and applications     built on  Acumatica Framework. In This Part Designing the Database Structure and DACsDesigning the User InterfaceNaming the Graphs and Event Handlers" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="5eac4e09-0542-aec3-7a84-78fed97eae44" RecordSourceID="22377" />
		<row PageID="5659adfe-3e4a-45a6-a94a-a33c2f955194" Language="en-US" PageRevisionID="1" PlainText="Designing the Database Structure and DACs This chapter covers the main aspects of database design used in  Acumatica Framework. In This Chapter System and Application TablesTable and Column Naming ConventionsCommon Columns and Data TypesPrimary KeyForeign Keys and Nullable ColumnsAudit FieldsConcurrent Update ControlAttachment of Additional Objects to Data RecordsPreservation of Deleted RecordsMultitenancy Support" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="4a9f5caa-387c-4f27-1355-606d47f23eee" RecordSourceID="22377">
			<column name="Content"><![CDATA[
This chapter covers the main aspects of database design used in Acumatica Framework.
==In This Chapter==[anchor|#_79f1288c-0301-40f8-bdb3-721fc20ca34c]
*[HelpRoot_Dev_Platform\DA__con_System_Application_Tables|System and Application Tables]
*[HelpRoot_Dev_Platform\DA__con_Table_Column_Naming_Conventions|Table and Column Naming Conventions]
*[HelpRoot_Dev_Platform\DA__con_Common_Columns_and_Types|Common Columns and Data Types]
*[HelpRoot_Dev_Platform\DA__con_Primary_Key|Primary Key]
*[HelpRoot_Dev_Platform\DA__con_Foreign_Keys|Foreign Keys and Nullable Columns]
*[HelpRoot_Dev_Platform\DA__con_Audit_Fields|Audit Fields]
*[HelpRoot_Dev_Platform\DA__con_Concurrent_Update_Control|Concurrent Update Control]
*[HelpRoot_Dev_Platform\DA__con_Attachment_of_Objects_to_Records|Attachment of Additional Objects to Data Records]
*[HelpRoot_Dev_Platform\DA__con_Preservation_of_Deleted_Records|Preservation of Deleted Records]
*[HelpRoot_Dev_Platform\DA__con_Multitenancy_Support|Multitenancy Support]

==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_UI|Designing the User Interface]
*[HelpRoot_Dev_Platform\DA__mng_Code_Guidelines|Naming the Graphs and Event Handlers]]]></column>
		</row>
		<row PageID="509aefc2-387b-4284-8ff8-ad5fc9b725be" Language="en-US" PageRevisionID="1" PlainText="System and Application Tables The database of your  Acumatica Framework-based     application consists of the following tables: System tables: Those that are created by default for the application template and not used      to store your application data Application tables:  Acumatica ERP tables (which exist if you have implemented customization) and your own tables Do not add columns to system tables or modify them in any other way. Such modifications could     corrupt the application and would be lost during the next database upgrade.  Regarding your own application tables, you have to design and create the needed tables that     store your application data. You then map these application tables to data access classes (DACs)     that define the object model of the application. In one table, you can keep data records of     multiple entities, each of which is defined as a separate data access class in the application     object model. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="21057bac-d7a1-23fe-f1cc-284043629865" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The database of your Acumatica Framework-based application consists of the following tables:[anchor|#ul_orw_f2j_ml]
*System tables: Those that are created by default for the application template and not used to store your application data
*Application tables: Acumatica ERP tables (which exist if you have implemented customization) and your own tables

Do not add columns to system tables or modify them in any other way. Such modifications could corrupt the application and would be lost during the next database upgrade. {br}

Regarding your own application tables, you have to design and create the needed tables that store your application data. You then map these application tables to data access classes (DACs) that define the object model of the application. In one table, you can keep data records of multiple entities, each of which is defined as a separate data access class in the application object model.
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
		</row>
		<row PageID="74ee714c-b70a-4f67-8647-329c5b774b2c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="4dbde5de-d0ab-21cc-4ff1-e80a74b37b4e" RecordSourceID="22377">
			<column name="Content"><![CDATA[In this topic, you can learn how you should name tables and columns in a database that is used by an Acumatica Framework-based application.{br}{TOC}
==Table Naming Conventions==
When you are creating a table, you should consider the following suggestions regarding naming conventions:[anchor|#ul_bqq_gs4_ll]
*Make sure that table and column names are valid C# identifiers, because these names match the names of the classes and properties you declare in the application. Do not start a table or column name with a digit.
*Do not use the underscore symbol (&#95;) in table or column names, because it is a reserved symbol in Acumatica Framework. For example, {{TenantType}} is a valid column name, while {{Tenant_Type}} is invalid.
*Use singular nouns for table names. Typically, a table is mapped to a data access class that represents the entity. For instance, the {{SOShipment}} table contains data records that represent instances of the <tt>SOShipment</tt> entity. 
*:((({S:Hint}Acumatica Framework generates SQL statements with table and column names in the same letter case (that is, uppercase or lowercase) as the corresponding data access classes and fields are declared in the application. Also, the DAC Generator tool produces data access class declarations in the same letter case as the tables and columns are defined in the database schema.
)))
*Use two prefixes in table names: a two-letter tenant name and then a two-letter application module prefix. For example, the {{MTSVAppointment}} table can be used in the Services (SV) module for the MyTenant tenant (which corresponds to the ''MT'' prefix). These prefixes help to distinguish your application tables from Acumatica ERP tables and tables of other vendors if you create an add-on project or extension library.
*If you add a column to an Acumatica ERP table, start the column name with the ''Usr'' prefix followed by the two-letter tenant name. For instance, you could use {{UsrMTColumn}} for the column of the MyTenant tenant. In this case, the column will be preserved during upgrades. In your own application tables, there are no strict requirements to start column names with any prefixes.
*Be sure that custom indexes on Acumatica ERP tables start with the ''Usr'' prefix followed by the two-letter tenant name, so that the indexes will be preserved during upgrades.

==Column Naming Conventions==
We recommend that you use the following suffixes in column names:[anchor|#ul_bdq_14v_nl]
*''ID'' for surrogate keys, including database identity columns, such as {{CustomerID}}
*''CD'' for natural keys, such as {{CustomerCD}}
*''Nbr'' for numbering identifiers, such as {{OrderNbr}}
*''Price'' for prices, such as {{UnitPrice}}
*''Cost'' for costs, such as {{UnitCost}}
*''Amt'' for amounts, such as {{FreightAmt}}
*''Total'' for totals, such as {{OrderTotal}}
*''Qty'', ''QtyMin'', and ''QtyMax'' for quantities, such as {{OrderQty}}
*''Date'' for dates, such as {{OrderDate}}
*''Time'' for time points and time spans, such as {{BillableTime}}
*''Pct'' for percents, such as {{DiscountPct}}

==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Table and Column Naming Conventions In this topic, you can learn how you should name tables and columns    in a database that is used by an  Acumatica Framework-based    application. Table Naming Conventions When you are creating a table, you should consider the following suggestions regarding naming     conventions: Make sure that table and column names are valid C# identifiers, because these names match      the names of the classes and properties you declare in the application. Do not start a table or      column name with a digit. Do not use the underscore symbol (_) in table or column names, because it is a reserved      symbol in  Acumatica Framework. For      example,  TenantType  is a valid column name, while  Tenant_Type       is invalid. Use singular nouns for table names. Typically, a table is mapped to a data access class that      represents the entity. For instance, the  SOShipment  table contains data      records that represent instances of the  SOShipment  entity.  Acumatica Framework       generates SQL statements with table and column names in the same letter case (that is,       uppercase or lowercase) as the corresponding data access classes and fields are declared in       the application. Also, the DAC Generator tool produces data access class declarations in the       same letter case as the tables and columns are defined in the database schema. Use two prefixes in table names: a two-letter tenant name and then a two-letter application      module prefix. For example, the  MTSVAppointment  table can be used in the      Services (SV) module for the MyTenant tenant (which corresponds to the  MT  prefix). These      prefixes help to distinguish your application tables from  Acumatica ERP      tables and tables of other vendors if you create an add-on project or extension library. If you add a column to an  Acumatica ERP      table, start the column name with the  Usr  prefix followed by the two-letter tenant name.      For instance, you could use  UsrMTColumn  for the column of the MyTenant tenant.      In this case, the column will be preserved during upgrades. In your own application tables,      there are no strict requirements to start column names with any prefixes. Be sure that custom indexes on  Acumatica ERP      tables start with the  Usr  prefix followed by the two-letter tenant name, so that the      indexes will be preserved during upgrades. Column Naming Conventions We recommend that you use the following suffixes in column names: ID  for surrogate keys, including database identity columns, such as        CustomerID CD  for natural keys, such as  CustomerCD Nbr  for numbering identifiers, such as  OrderNbr Price  for prices, such as  UnitPrice Cost  for costs, such as  UnitCost Amt  for amounts, such as  FreightAmt Total  for totals, such as  OrderTotal Qty ,  QtyMin , and  QtyMax  for quantities, such as        OrderQty Date  for dates, such as  OrderDate Time  for time points and time spans, such as  BillableTime Pct  for percents, such as  DiscountPct ]]></column>
		</row>
		<row PageID="3323a8a3-1736-498a-bf87-55617532c91c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="85ef1dea-ffb4-6cad-da5f-7538d1b45dd8" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#section_nnl_jqr_dm]
You should use the following data types for columns. In the '''Type Attribute on the Data Field''' column in the table below, you can find the most common type attributes that are added to the corresponding data fields in the data access class declaration.[anchor|#table_gl1_ns4_ll]
===Common Data Types===
{| class="checklist" | width="100%" 
|- 
!width="26%" ! Value
!width="21%" ! Data Type (SQL Server)
!width="21%" ! Data Type (MySQL)
!width="31%" ! Type Attribute on the Data Field
|- 
| Database identity
| int
| INT
| {{[PXDBIdentity]}}
|- 
| Natural key (for example, document number)
| nvarchar(15)
| VARCHAR(15) with utf8mb4 character set
| {{[PXDBString(15, IsKey = true, IsUnicode = true)]}}
|- 
| Line number
| int
| INT
| {{[PXDBInt]}}
|- 
| Short string (for example, a name or unit of measure)
| nvarchar(20), nvarchar(50)
| VARCHAR(20), VARCHAR(50) with utf8mb4 character set
| {{[PXDBString(20, IsUnicode = true)]}}
|- 
| Long string (such as a description)
| nvarchar(255)
| VARCHAR(255) with utf8mb4 character set
| {{[PXDBString(255, IsUnicode = true)]}}
|- 
| Type or status identifier (for instance, a document type)
| int or char(1)
| INT or CHAR(1)
| {{[PXDBInt]}} or {{[PXDBString(1, IsFixed = true)]}} respectively
|- 
| Boolean flag (for example, active/inactive)
| bit
| TINYINT(1)
| {{[PXDBBool]}}
|- 
| Price or cost, monetary units
| decimal(19, 6)
| DECIMAL(19, 6)
| {{[PXDBDecimal(6)]}}
|- 
| Amount or total, monetary units
| decimal(19, 4)
| DECIMAL(19, 4)
| {{[PXDBDecimal(4)]}}
|- 
| Quantity, pieces
| decimal(25, 6)
| DECIMAL(25, 6)
| {{[PXDBDecimal(6)]}}
|- 
| Maximum, minimum, or threshold quantity, pieces
| decimal(9, 6)
| DECIMAL(9, 6)
| {{[PXDBDecimal(2)]}}
|- 
| Percent, rate (for example, discount percent)
| decimal(9, 6)
| DECIMAL(9, 6)
| {{[PXDBDecimal(2)]}}
|- 
| Weight or volume
| decimal(25, 6) 
| DECIMAL(25, 6)
| {{[PXDBDecimal(6)]}}
|- 
| Date
| smalldatetime
| DATETIME
| {{[PXDBDate]}}
|- 
| Time span
| int
| INT
| {{[PXDBTimeSpan(DisplayMask = "t", InputMask = "t")]}}
|- 
| Coefficient (such as a conversion factor)
| decimal(9, 6)
| DECIMAL(9, 6)
| {{[PXDBDecimal(1)]}}
|}
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Common Columns and Data Types You should use the following data types for columns. In the  Type Attribute on the      Data Field  column in the table below, you can find the most common type attributes     that are added to the corresponding data fields in the data access class declaration. Common Data Types Value Data Type (SQL Server) Data Type (MySQL) Type Attribute on the Data Field Database identity int INT [PXDBIdentity] Natural key (for example, document number) nvarchar(15) VARCHAR(15) with utf8mb4 character set [PXDBString(15, IsKey = true, IsUnicode = true)] Line number int INT [PXDBInt] Short string (for example, a name or unit of measure) nvarchar(20), nvarchar(50) VARCHAR(20), VARCHAR(50) with utf8mb4 character set [PXDBString(20, IsUnicode = true)] Long string (such as a description) nvarchar(255) VARCHAR(255) with utf8mb4 character set [PXDBString(255, IsUnicode = true)] Type or status identifier (for instance, a document type) int or char(1) INT or CHAR(1) [PXDBInt]  or  [PXDBString(1, IsFixed = true)]          respectively Boolean flag (for example, active/inactive) bit TINYINT(1) [PXDBBool] Price or cost, monetary units decimal(19, 6) DECIMAL(19, 6) [PXDBDecimal(6)] Amount or total, monetary units decimal(19, 4) DECIMAL(19, 4) [PXDBDecimal(4)] Quantity, pieces decimal(25, 6) DECIMAL(25, 6) [PXDBDecimal(6)] Maximum, minimum, or threshold quantity, pieces decimal(9, 6) DECIMAL(9, 6) [PXDBDecimal(2)] Percent, rate (for example, discount percent) decimal(9, 6) DECIMAL(9, 6) [PXDBDecimal(2)] Weight or volume decimal(25, 6)  DECIMAL(25, 6) [PXDBDecimal(6)] Date smalldatetime DATETIME [PXDBDate] Time span int INT [PXDBTimeSpan(DisplayMask = "t", InputMask = "t")] Coefficient (such as a conversion factor) decimal(9, 6) DECIMAL(9, 6) [PXDBDecimal(1)] ]]></column>
		</row>
		<row PageID="9e533998-5a08-452d-9490-a02db1cf4c19" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="aa0d4bf2-33ec-45f0-f8ea-565ff0416c36" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You have to define the primary key in each application table that you create. The primary key may consist of one column or multiple columns. The primary key must include the {{CompanyID}} column if one is defined in the table. For details on the {{CompanyID}} column, see [HelpRoot_Dev_Platform\DA__con_Multitenancy_Support|Multitenancy Support].{br}

For each table, you can use one of the following typical variants of primary keys:[anchor|#ul_fl2_lvf_pl]
*One key column included in the primary key in the table and set as the key in the data access class
*A pair of columns, with one column included in the primary key in the table and the other column set as the key in the data access class
*Multiple columns that are included in the primary key and set as the compound key in the data access class
((({S:Hint}In a setup table, only the {{CompanyID}} column must be included in the primary key.
))){br}{TOC}
==One Key Column==
You may use one key column for rather short tables. For instance, you can use the two-letter country code from ISO 3166 as the key in the {{Country}} table.
==A Pair of Columns with Key Substitution in the UI==
If you want to represent a user-friendly key in the user interface (UI) that corresponds to a surrogate key in the database, you can use a pair of columns and the key substitution mechanism provided by Acumatica Framework. You can define two columns in a table, one for the surrogate key (typically the database identity column) and one for the natural key, and set only the surrogate key as primary in the table. In the application object model, you set the key to only the data field that is a natural key. In this case, Acumatica Framework provides the ability to transparently work with different keys at the database and application levels. In the UI, users work with only the natural key while the database operates with the surrogate key (see the graphic below, which illustrates key substitution).[anchor|#_bcf09c83-658b-4ea8-a637-60f700456bf0][anchor|#image_kdc_lzv_nl][image:StudioDeveloperGuide/Images/Conc_KeySubstitutionScheme.png|popup|Key substitution in Acumatica Framework|300px]
For instance, you can define two columns in the {{Product}} table, {{ProductID}} and {{ProductCD}}. {{ProductID}} is the identity column that is the only column included in the primary key of the table. {{ProductCD}} is the string key of a product instance, which is entered by the user through the UI. The {{ProductCD}} column isn&rsquo;t included in the primary key and is handled as the unique key column by Acumatica Framework.
==Multiple Column Key==
A compound key consisting of multiple columns may be used for complex entities. For instance, you can include two columns, {{DocType}} and {{DocNbr}}, in the primary key for the {{Document}} table. In the {{DocDetail}} table, you may use {{DocNbr}} and {{DocDetailNbr}} as the compound primary key. The corresponding data fields should be also set as the key fields in the data access class.
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Primary Key You have to define the primary key in each application table that you create. The primary key     may consist of one column or multiple columns. The primary key must include the       CompanyID  column if one is defined in the table. For details on the       CompanyID  column, see  Multitenancy Support. For each table, you can use one of the following typical variants of primary keys: One key column included in the primary key in the table and set as the key in the data      access class A pair of columns, with one column included in the primary key in the table and the other      column set as the key in the data access class Multiple columns that are included in the primary key and set as the compound key in the      data access class In a setup table, only the  CompanyID  column must be included in the     primary key. One Key Column You may use one key column for rather short tables. For instance, you can use the two-letter     country code from ISO 3166 as the key in the  Country  table. A Pair of Columns with Key Substitution in the UI If you want to represent a user-friendly key in the user interface (UI) that corresponds to a     surrogate key in the database, you can use a pair of columns and the key substitution mechanism     provided by  Acumatica Framework. You     can define two columns in a table, one for the surrogate key (typically the database identity     column) and one for the natural key, and set only the surrogate key as primary in the table. In     the application object model, you set the key to only the data field that is a natural key. In     this case,  Acumatica Framework     provides the ability to transparently work with different keys at the database and application     levels. In the UI, users work with only the natural key while the database operates with the     surrogate key (see the graphic below, which illustrates key substitution). Key substitution in  Acumatica FrameworkFor instance, you can define two columns in the  Product  table,       ProductID  and  ProductCD .  ProductID  is the     identity column that is the only column included in the primary key of the table.       ProductCD  is the string key of a product instance, which is entered by the     user through the UI. The  ProductCD  column isn't included in the primary key and     is handled as the unique key column by  Acumatica Framework. Multiple Column Key A compound key consisting of multiple columns may be used for complex entities. For instance,     you can include two columns,  DocType  and  DocNbr , in the     primary key for the  Document  table. In the  DocDetail  table,     you may use  DocNbr  and  DocDetailNbr  as the compound primary     key. The corresponding data fields should be also set as the key fields in the data access     class. ]]></column>
		</row>
		<row PageID="8da9e9c6-ebbf-409a-b43d-a13d2081a62e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ef328cac-6542-8070-fafb-b6c02cc3fc8e" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In the database, you have to define the primary key in each application table that you create. The primary key defines the unique data record identifier, which provides table-level integrity of data.{br}

There are no strict requirements to define column-level constraints and foreign keys in application tables. Whether you define the constraints at the database level depends on the design approach you use. At a higher level of the application object model, which is represented by data access classes, you can flexibly define any level of constraints, including default values, nullable fields, and parent-child relationships between data access classes. If you aren&rsquo;t sure whether a column should allow a null value, you can allow null values for it in the database. Later, in the data access class, you can make the data field either required or nullable; you can even make the field required on one page and optional on another.((({S:Hint}For Boolean and decimal columns, we recommend that you define default values either in the database or in data access classes. This simplifies the application code by helping to avoid checking of values for nulls multiple times.
)))
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Foreign Keys and Nullable Columns In the database, you have to define the primary key in each application table that you create.     The primary key defines the unique data record identifier, which provides table-level integrity     of data. There are no strict requirements to define column-level constraints and foreign keys in     application tables. Whether you define the constraints at the database level depends on the     design approach you use. At a higher level of the application object model, which is represented     by data access classes, you can flexibly define any level of constraints, including default     values, nullable fields, and parent-child relationships between data access classes. If you     aren't sure whether a column should allow a null value, you can allow null values for it in the     database. Later, in the data access class, you can make the data field either required or     nullable; you can even make the field required on one page and optional on another. For Boolean and decimal columns, we recommend that you define default values either in the     database or in data access classes. This simplifies the application code by helping to avoid     checking of values for nulls multiple times. ]]></column>
		</row>
		<row PageID="9dd06906-0b2f-498c-a333-cfd641bfbd9e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="cfa2fedc-265e-a426-5f08-f2d7c1134d4a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Audit fields keep meta information on the creation and the last change of a database record. Audit fields are updated automatically by the framework.{br}

To enable the tracking of audit data for a particular table, you should add the columns listed below to the table and declare the corresponding audit data fields in the data access class. You have to add the corresponding type attribute to each audit field. If the audit columns are properly created in the database table and the corresponding data fields are declared in the data access class, Acumatica Framework automatically updates audit data in these fields every time a data record is modified from the application. The audit column parameters and DAC attributes are given below.[anchor|#table_lbr_dgg_pl]
===Audit Columns===
{| class="checklist" | width="100%" 
|- 
!width="26%" ! Database Column Name
!width="21%" ! Data Type (SQL Server)
!width="21%" ! Data Type (MySQL)
!width="31%" ! Type Attribute on the Data Field
|- 
| {{CreatedByID}}
| {{uniqueidentifier}}; not null
| {{CHAR(36)}} with ASCII character set; not null
| {{[PXDBCreatedByID]}}
|- 
| {{CreatedByScreenID}}
| {{char(8)}}; not null
| {{CHAR(8)}} with ASCII character set; not null
| {{[PXDBCreatedByScreenID]}}
|- 
| {{CreatedDateTime}}
| {{smalldatetime}}; not null
| {{DATETIME}}; not null
| {{[PXDBCreatedDateTime]}}
|- 
| {{LastModifiedByID}}
| {{uniqueidentifier}}; not null
| {{CHAR(36)}} with ASCII character set; not null
| {{[PXDBLastModifiedByID]}}
|- 
| {{LastModifiedByScreenID}}
| {{char(8)}}; not null
| {{CHAR(8)}} with ASCII character set; not null
| {{[PXDBLastModifiedByScreenID]}}
|- 
| {{LastModifiedDateTime}}
| {{smalldatetime}}; not null
| {{DATETIME}}; not null
| {{[PXDBLastModifiedDateTime]}}
|}
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Audit Fields Audit fields keep meta information on the creation and the last change of a database record.     Audit fields are updated automatically by the framework. To enable the tracking of audit data for a particular table, you should add the columns listed     below to the table and declare the corresponding audit data fields in the data access class. You     have to add the corresponding type attribute to each audit field. If the audit columns are     properly created in the database table and the corresponding data fields are declared in the     data access class,  Acumatica Framework     automatically updates audit data in these fields every time a data record is modified from the     application. The audit column parameters and DAC attributes are given below. Audit Columns Database Column Name Data Type (SQL Server) Data Type (MySQL) Type Attribute on the Data Field CreatedByID uniqueidentifier ; not null CHAR(36)  with ASCII character set; not null [PXDBCreatedByID] CreatedByScreenID char(8) ; not null CHAR(8)  with ASCII character set; not null [PXDBCreatedByScreenID] CreatedDateTime smalldatetime ; not null DATETIME ; not null [PXDBCreatedDateTime] LastModifiedByID uniqueidentifier ; not null CHAR(36)  with ASCII character set; not null [PXDBLastModifiedByID] LastModifiedByScreenID char(8) ; not null CHAR(8)  with ASCII character set; not null [PXDBLastModifiedByScreenID] LastModifiedDateTime smalldatetime ; not null DATETIME ; not null [PXDBLastModifiedDateTime] ]]></column>
		</row>
		<row PageID="8d904e5f-2b8c-4d82-a8f5-bc863f8ffc8f" Language="en-US" PageRevisionID="1" PlainText="Concurrent Update Control You can add the SQL Server time stamp column to a table to make  Acumatica Framework able     to handle concurrent updates. The corresponding time stamp data field should be declared in the     data access class. If the time stamp data field is declared,  Acumatica Framework     handles the time stamp column automatically.  Acumatica Framework     checks the row version every time the row is modified. We recommend that you add the time stamp     column, with the parameters shown in the following table, to all tables of your application. The Time Stamp Column Database Column Name Data Type (SQL Server) Data Type (MySQL) Type Attribute on the Data Field TStamp timestamp ; not null TIMESTAMP(6) ; not null [PXDBTimestamp] " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="69e9915c-9600-c563-edb6-760b408cdca8" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#section_kmd_qqr_dm]
You can add the SQL Server time stamp column to a table to make Acumatica Framework able to handle concurrent updates. The corresponding time stamp data field should be declared in the data access class. If the time stamp data field is declared, Acumatica Framework handles the time stamp column automatically. Acumatica Framework checks the row version every time the row is modified. We recommend that you add the time stamp column, with the parameters shown in the following table, to all tables of your application.[anchor|#table_ewz_fzf_pl]
===The Time Stamp Column===
{| class="checklist" | width="100%" 
|- 
!width="26%" ! Database Column Name
!width="21%" ! Data Type (SQL Server)
!width="21%" ! Data Type (MySQL)
!width="31%" ! Type Attribute on the Data Field
|- 
| {{TStamp}}
| {{timestamp}}; not null
| {{TIMESTAMP(6)}}; not null
| {{[PXDBTimestamp]}}
|}
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
		</row>
		<row PageID="2c5495c0-4705-4a38-8ea9-532b0ba1724a" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="dcf3e03f-65bc-7966-0924-d7a2d5c74e13" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#section_jtw_rqr_dm]
You can attach additional objects to a data record—for instance, attach a text note or an uploaded file or multiple uploaded files to a data record. {br}

You turn on or off support for data record attachments for each particular table individually. To turn on support for data record attachments, add a column that stores the global data record identifier (typically, {{NoteID}}) to the table and declare the corresponding field in the data access class. For more information on uploading files through an application page, see [HelpRoot_Dev_Platform\BL__how_Display_Attached_Image|To Display an Attached Image on the Webpage]. See below for the parameters of the global identifier column and the attribute that should be added to the corresponding DAC field.[anchor|#table_yml_2fg_pl]
===The Global Data Record Identifier Column (NoteID)===
{| class="checklist" | width="100%" 
|- 
!width="26%" ! Database Column
!width="21%" ! Data Type (SQL Server)
!width="21%" ! Data Type (MySQL)
!width="31%" ! Type Attribute on the Data Field
|- 
| Global data record identifier (typically named {{NoteID}})
| 
{{uniqueidentifier}}; null
| {{CHAR(36)}}
| {{[PXNote]}}
|}
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Attachment of Additional Objects to Data Records You can attach additional objects to a data record—for instance, attach a text note or     an uploaded file or multiple uploaded files to a data record.  You turn on or off support for data record attachments for each particular table individually.     To turn on support for data record attachments, add a column that stores the global data record     identifier (typically,  NoteID ) to the table and declare the corresponding field     in the data access class. For more information on uploading files through an application page,     see  To Display an Attached Image on the Webpage. See below for the parameters of the     global identifier column and the attribute that should be added to the corresponding DAC     field. The Global Data Record Identifier Column (NoteID) Database Column Data Type (SQL Server) Data Type (MySQL) Type Attribute on the Data Field Global data record identifier (typically named  NoteID ) uniqueidentifier ; null CHAR(36) [PXNote] ]]></column>
		</row>
		<row PageID="4a1939a3-26aa-49e3-83c6-5bcc884e66b9" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e63d8635-4d98-ef36-ccb4-fd113ffce98d" RecordSourceID="22377">
			<column name="Content"><![CDATA[[anchor|#section_b5g_tqr_dm]
 Acumatica Framework provides a low-level mechanism (which is performed on the database level) for preserving deleted data records in the database. With this mechanism, when an application initiates the deletion of a data record, the data access layer generates an SQL query that marks the data record as deleted but does not permanently remove the data record from the table. When data records are selected from the table, the data access layer generates the SQL query, which returns only data records that are not marked as deleted. The data records that are preserved in this way can be restored. {br}

You can turn on or off the preservation of deleted data records for each table individually. To preserve data records in a particular table, add the {{DeletedDatabaseRecord}} column to the table and do not declare the data field in the data access class. When a data record is deleted in the table, the framework automatically preserves the deleted data record transparently to the application developer.[anchor|#table_q4s_ygg_pl]
===The DeletedDatabaseRecord Column===
{| class="checklist" | width="100%" 
|- 
!width="26%" ! Database Column
!width="21%" ! Data Type (SQL Server)
!width="21%" ! Data Type (MySQL)
!width="31%" ! Type Attribute on the Data Field
|- 
| {{DeletedDatabaseRecord}}
| {{bit}}; not null
| {{TINYINT(1)}}; not null
| Not declared in DAC
|}
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Preservation of Deleted Records  Acumatica Framework     provides a low-level mechanism (which is performed on the database level) for preserving deleted     data records in the database. With this mechanism, when an application initiates the deletion of     a data record, the data access layer generates an SQL query that marks the data record as     deleted but does not permanently remove the data record from the table. When data records are     selected from the table, the data access layer generates the SQL query, which returns only data     records that are not marked as deleted. The data records that are preserved in this way can be     restored.  You can turn on or off the preservation of deleted data records for each table individually.     To preserve data records in a particular table, add the  DeletedDatabaseRecord      column to the table and do not declare the data field in the data access class. When a data     record is deleted in the table, the framework automatically preserves the deleted data record     transparently to the application developer. The DeletedDatabaseRecord Column Database Column Data Type (SQL Server) Data Type (MySQL) Type Attribute on the Data Field DeletedDatabaseRecord bit ; not null TINYINT(1) ; not null Not declared in DAC ]]></column>
		</row>
		<row PageID="d0945e20-1949-40b1-bd0f-92c7c432aa24" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ceb0db61-d782-9047-f4cf-31a0ccabf396" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Multiple tenants can work on the same instance of an Acumatica Framework-based application with completely isolated data. The application looks identical to all tenants, but each tenant has exclusive access to its data only. Data is isolated at the lowest level of the application, in the data access layer that executes SQL queries for the tenant of the user who is currently signed in.{br}{TOC}[anchor|#section_wmd_vqr_dm]
==Multitenancy Support==The following graphic illustrates how different logical tenants work with the Acumatica Framework-based application in a multitenant configuration. They work with the same application but have isolated data access, as if they are working with different database instances.[anchor|#_cd5360a2-8c0e-4791-a459-30a971e9a3e8][anchor|#image_s2g_plb_4l][image:StudioDeveloperGuide/Images/Conc_Multiten_NoSharing.png|popup|Multitenant Acumatica Framework-based application|300px]
Multitenancy support is turned on or off for each particular table individually. To turn on multitenancy support for a table, add the {{CompanyID}} column to it and include the column in the primary key (see the column parameters in the table below) and all indexes. The {{CompanyID}} column is handled automatically by the framework and should not be declared in data access classes. If a table doesn&rsquo;t have the {{CompanyID}} column, all data from the table is fully accessible to all tenants that exist in the database. For more information, see [HelpRoot_Administration\SM__con_Support_of_Multiple_Companies|Support of Multiple Tenants].[anchor|#table_s4d_s3g_pl]
===The CompanyID Column===
{| class="checklist" | width="100%" 
|- 
!width="26%" ! Database Column Name
!width="21%" ! Data Type (SQL Server)
!width="21%" ! Data Type (MySQL)
!width="31%" ! Type Attribute on the Data Field
|- 
| {{CompanyID}}
| {{int}}; not null; included in primary key and all indexes
| {{INT}}; not null; included in primary key and all indexes
| Not declared in DAC
|}
==Support for Shared Data Access Between Tenants==
 Acumatica Framework provides shared data access in a multitenant configuration. Acumatica Framework supports a hierarchy of logical tenants that may work with a combination of shared and individual data. In shared access mode, every tenant may work with its individual copy of a data record; copies differ by {{CompanyID}}. All copies represent the same logical object in the application but different data records in the database. For instance, each tenant may use the individual settings of the application.{br}

The graphic below shows a possible multitenant configuration with shared data access between Tenant 1, Tenant 2, and Tenant 3. The users of Tenant 2 have access to the data of all three tenants. The users from each of the other two tenants have access to their company&rsquo;s individual data only. Physically, the data of all three tenants is stored in a single database instance.[anchor|#_8ea08c8e-8043-4ef2-bc9a-beb6a5e812a1][anchor|#image_udh_wlb_4l][image:StudioDeveloperGuide/Images/Conc_Multiten_Sharing.png|popup|Shared data access in a multitenant Acumatica Framework-based application|300px]
Support for shared data access is turned on or off for each particular table individually. To turn on support for shared data access for a table, add the {{CompanyMask}} column to the table (see the column parameters in the table below). The {{CompanyMask}} column is handled automatically by the framework and should not be declared in data access classes. If a table doesn&rsquo;t have the {{CompanyMask}} column, shared data access is not available for this table.[anchor|#table_ijy_zkg_pl]
===The CompanyMask Column===
{| class="checklist" | width="100%" 
|- 
!width="26%" ! Database Column Name
!width="21%" ! Data Type (SQL Server)
!width="21%" ! Data Type (MySQL)
!width="31%" ! Type Attribute on the Data Field
|- 
| {{CompanyMask}}
| {{varbinary(32)}}, not null, default 0xAA
| {{VARBINARY(32)}}, not null, default 0xAA
| Not declared in DAC
|}
{{CompanyMask}} is a 32-bit mask. In this mask, each two bits correspond to each tenant. The first of these two bits specifies whether the record may be read by this tenant, and the second bit specifies whether the record may be written to by this tenant. For example, suppose that {{CompanyMask}} is set to 0xBE02 for a record. That is, it specifies the following mask: {{10 11 11 10 00 00 00 10}}, which designates that the record may be both read and written to by the tenants with company IDs 2 and 3, the record may be read by the tenants with IDs 4 and 5 and the system tenant (which has ID 1), and the record may not be read or written to by other tenants. {{{{CompanyMask:  10 11 11 10 00 00 00 10
CompanyID:     4  3  2  1  8  7  6  5
}}}}{br}

The default value of {{CompanyMask}} is 0xAA, which means that the record may be read by all tenants.
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]]]></column>
			<column name="PlainText"><![CDATA[Multitenancy Support Multiple tenants can work on the same instance of an  Acumatica Framework-based     application with completely isolated data. The application looks identical to all tenants, but     each tenant has exclusive access to its data only. Data is isolated at the lowest level of the     application, in the data access layer that executes SQL queries for the tenant of the user who     is currently signed in. Multitenancy Support The following graphic    illustrates how different logical tenants work with the  Acumatica Framework-based    application in a multitenant configuration. They work with the same application but have isolated    data access, as if they are working with different database instances. Multitenant  Acumatica Framework-based application Multitenancy support is turned on or off for each particular table individually. To turn     on multitenancy support for a table, add the  CompanyID  column to it and include     the column in the primary key (see the column parameters in the table below) and all indexes.     The  CompanyID  column is handled automatically by the framework and should not     be declared in data access classes. If a table doesn't have the  CompanyID      column, all data from the table is fully accessible to all tenants that exist in the database.     For more information, see  Support of Multiple Tenants. The CompanyID Column Database Column Name Data Type (SQL Server) Data Type (MySQL) Type Attribute on the Data Field CompanyID int ; not null; included in primary key and all indexes INT ; not null; included in primary key and all indexes Not declared in DAC Support for Shared Data Access Between Tenants  Acumatica Framework     provides shared data access in a multitenant configuration.  Acumatica Framework     supports a hierarchy of logical tenants that may work with a combination of shared and     individual data. In shared access mode, every tenant may work with its individual copy of a data     record; copies differ by  CompanyID . All copies represent the same logical     object in the application but different data records in the database. For instance, each tenant     may use the individual settings of the application. The graphic below shows a possible multitenant configuration with shared data access between     Tenant 1, Tenant 2, and Tenant 3. The users of Tenant 2 have access to the data of all three     tenants. The users from each of the other two tenants have access to their company's individual     data only. Physically, the data of all three tenants is stored in a single database     instance. Shared data access in a multitenant  Acumatica Framework-based application Support for shared data access is turned on or off for each particular table individually. To     turn on support for shared data access for a table, add the  CompanyMask  column     to the table (see the column parameters in the table below). The  CompanyMask      column is handled automatically by the framework and should not be declared in data access     classes. If a table doesn't have the  CompanyMask  column, shared data access is     not available for this table. The CompanyMask Column Database Column Name Data Type (SQL Server) Data Type (MySQL) Type Attribute on the Data Field CompanyMask varbinary(32) , not null, default 0xAA VARBINARY(32) , not null, default 0xAA Not declared in DAC CompanyMask  is a 32-bit mask. In this mask, each two bits correspond to each     tenant. The first of these two bits specifies whether the record may be read by this tenant, and     the second bit specifies whether the record may be written to by this tenant. For example,     suppose that  CompanyMask  is set to 0xBE02 for a record. That is, it specifies     the following mask:  10 11 11 10 00 00 00 10 ,     which designates that the record may be both read and written to by the tenants with company IDs     2 and 3, the record may be read by the tenants with IDs 4 and 5 and the system tenant (which has     ID 1), and the record may not be read or written to by other tenants.      CompanyMask:  10 11 11 10 00 00 00 10
CompanyID:     4  3  2  1  8  7  6  5 The default value of  CompanyMask  is 0xAA, which means that the record may be     read by all tenants. ]]></column>
		</row>
		<row PageID="a40f4ed8-2f7f-4894-8bb7-71aa5402792c" Language="en-US" PageRevisionID="1" Content="This chapter summarizes the webpage design and style conventions used in Acumatica Framework.&#xA;==In This Chapter==[anchor|#_aa957432-43fa-40f6-a279-a70eecff8d3b]&#xA;*[HelpRoot_Dev_Platform\DA__con_Development_Environment_Options|Development Environment Options]&#xA;*[HelpRoot_Dev_Platform\DA__con_Form_Numbering|Form and Report Numbering]&#xA;*[HelpRoot_Dev_Platform\DA__con_Item_Grouping_on_Form_Toolbar|Item Grouping on the Form Toolbar]&#xA;&#xA;==Related Articles==&#xA;*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]&#xA;*[HelpRoot_Dev_Platform\DA__mng_Code_Guidelines|Naming the Graphs and Event Handlers]" PlainText="Designing the User Interface This chapter summarizes the webpage design and style conventions used in  Acumatica Framework. In This Chapter Development Environment OptionsForm and Report NumberingItem Grouping on the Form Toolbar" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="6f536ec6-48bb-9c6b-f14f-65a8a6b4c788" RecordSourceID="22377" />
		<row PageID="f1be73a7-1b99-4609-a6e0-4ac489edad5d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="bda9911e-b07c-755e-3ce9-8096df7d61cd" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To create stand-alone applications with Acumatica Framework or develop customizations for Acumatica ERP, the environment where you install and use Acumatica Framework, should meet particular requirements that are described in [HelpRoot_Install\System_Requirements_Studio|System Requirements for Acumatica Framework 2019 R1].
==Web Forms Designer Settings==
We recommend the following settings for the Microsoft Visual Studio environment to ensure a uniform webpage appearance: [anchor|#ol_uvc_glx_2t]
#Under the '''Tools''' > '''Options''' > '''Web Forms Designer''' > '''CSS''' section, set the following options: 
#*'''Font and text''': ''CSS (classes)''
#* '''Padding and borders''': ''CSS (classes)''
#* '''Floating, positioning, and sizing''': ''CSS (inline styles)''
#* '''Bullets and numbering''': ''CSS (classes)''
#* '''Background''': ''CSS (classes)''
#* '''Margins''': ''CSS (classes)''
#Under the '''Tools''' > '''Options''' > '''Web Forms Designer''' > '''CSS Styling''' section, select '''Auto Style Application''', and specify the following settings:
#*'''Only reuse classes with the prefix &ldquo;auto-style&ldquo;''': Selected
#*'''Use width and height attributes for image instead of CSS''': Selected
#*'''Use &lt;strong&gt; and &lt;em&gt; for bold and italic text''': Cleared
#*'''Use shorthand properties when generating styles''': Selected
#*'''Change positioning to absolute for controls added using Toolbox, paste, or drag and drop''': Selected
{br}{TOC}
==Design Mode Settings==
We also recommended that you use the following settings of the Design mode of ASPX pages in Visual Studio: [anchor|#ul_xvc_glx_2t]
*'''View''' > '''Visual Aids''' > '''CSS Display:none Elements''': Cleared
*'''View''' > '''Visual Aids''' > '''CSS Visibility:hidden Elements''': Cleared
{br}{TOC}
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_UI|Designing the User Interface]]]></column>
			<column name="PlainText"><![CDATA[Development Environment Options To create stand-alone applications with  Acumatica Framework or     develop customizations for  Acumatica ERP,     the environment where you install and use  Acumatica Framework,     should meet particular requirements that are described in  System Requirements for Acumatica Framework 2019 R1. Web Forms Designer Settings We recommend the following settings for the Microsoft Visual Studio environment to ensure a     uniform webpage appearance:  Under the  Tools Options Web Forms Designer CSS  section, set the following options:  Font and text :  CSS (classes) Padding and borders :  CSS (classes) Floating, positioning, and sizing :  CSS (inline styles) Bullets and numbering :  CSS (classes) Background :  CSS (classes) Margins :  CSS (classes) Under the  Tools Options Web Forms Designer CSS Styling  section, select  Auto Style Application , and specify the following       settings: Only reuse classes with the prefix "auto-style" : Selected Use width and height attributes for image instead of CSS :        Selected Use <strong> and <em> for bold and italic text : Cleared Use shorthand properties when generating styles : Selected Change positioning to absolute for controls added using Toolbox, paste, or drag         and drop : Selected Design Mode Settings We also recommended that you use the following settings of the Design mode of ASPX pages in     Visual Studio:  View Visual Aids CSS Display:none Elements : Cleared View Visual Aids CSS Visibility:hidden Elements : Cleared ]]></column>
		</row>
		<row PageID="4a5e6db8-cbba-4cbe-b0f1-1d774381c1b4" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="a94db220-084b-1c05-5ee0-3312b923fb1c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can find the guidelines for form and report numbering in Acumatica ERP.{br}{TOC}[anchor|#section_k2p_vlx_2t]
==Form Numbering==When you are numbering forms in Acumatica ERP, use the following conventions: {{{{  XX999999
   |  |  |  |_ Subscreen Sequential Number
   | | |___ Screen Sequential Number
   | |_____ Screen Type: 
   |                    10: Setup
   |                    20: Maintenance
   |                    30: Data Entry
   |                    40: Inquiry 
   |                    50: Processing
   |                    60: Reports
   |_______ Two-Letter Module Code
}}}}[anchor|#section_dp5_vlx_2t]
==Report Numbering==When you are numbering reports in Acumatica ERP, use the following conventions in addition to those outlined above: {{{{  XX6X9999
      |  
      |____ Report Type: 
             61: Review Reports (Reports for document review prior to release) 
             62: Register Reports (Reports used to print audit information 
                                        on processed documents or entities)
             63: Balance Reports (Reports reflecting current or historical
                                                       balance information)
             64: Forms (Printed webpages)
             65: Inquiry Reports (Reports that provide status information
                                       required for operational management)
             66: Statistical Reports (Reports that provide statistical or 
                                                    historical information)
}}}}
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_UI|Designing the User Interface]]]></column>
			<column name="PlainText"><![CDATA[Form and Report Numbering In this topic, you can find the guidelines for form and report numbering in  Acumatica ERP. Form Numbering When you are numbering forms in  Acumatica ERP,    use the following conventions:       XX999999
   |  |  |  |_ Subscreen Sequential Number
   | | |___ Screen Sequential Number
   | |_____ Screen Type: 
   |                    10: Setup
   |                    20: Maintenance
   |                    30: Data Entry
   |                    40: Inquiry 
   |                    50: Processing
   |                    60: Reports
   |_______ Two-Letter Module Code Report Numbering When you are numbering reports in      Acumatica ERP, use the following conventions in addition to those outlined above:       XX6X9999
      |  
      |____ Report Type: 
             61: Review Reports (Reports for document review prior to release) 
             62: Register Reports (Reports used to print audit information 
                                        on processed documents or entities)
             63: Balance Reports (Reports reflecting current or historical
                                                       balance information)
             64: Forms (Printed webpages)
             65: Inquiry Reports (Reports that provide status information
                                       required for operational management)
             66: Statistical Reports (Reports that provide statistical or 
                                                    historical information) ]]></column>
		</row>
		<row PageID="abf2bced-c926-4f27-a408-66fe223418ed" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e8c385b5-7db1-0d5a-d1ef-ab7af33d449b" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Menu items can be grouped on the form toolbar to keep a reasonable number of buttons on the toolbar. When you are building the menu structure, use the menus described below.{br}{TOC}
==Data Entry Forms==[anchor|#ul_ytr_lnx_2t]
*'''Actions''': Use this menu to group the operations that give the user the ability to process the document, including the actions that navigate to related data entry forms (with the system filling in appropriate settings) so users can quickly create linked documents. For example, see the '''Enter Payment/Apply Memo''' action on the [HelpRoot_FormReference\AR_30_10_00|Invoices and Memos] ([~/?ScreenId=AR301000|AR301000]) form. The most frequently used operations can be placed on the toolbar outside any groups as separate buttons that provide quick access to the actions. For example, notice the '''Release''' action on the [HelpRoot_FormReference\AR_30_10_00|Invoices and Memos] form.
*'''Reports''': Use this menu to group the actions that open related Report Designer reports and printable forms of documents.
*'''Inquiries''': Use this menu to group the actions that navigate to related inquiry forms.

==Inquiry Forms==[anchor|#ul_bl5_b4x_2t]
*'''Actions:''' Use this menu to group the operations that give the user the ability to navigate to related data entry forms.
*'''Reports:''' Use this menu to group the actions that open the related Report Designer reports.

==Maintenance Forms==[anchor|#ul_bbq_dsx_2t]
*'''Actions''': Use this menu to group the operations that update the settings of the master record and navigate to related data entry forms.
*'''Reports''': Use this menu to group the actions that open related Report Designer reports.
*'''Inquiries''': Use this menu to group the actions that navigate to related inquiry forms.

==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Designing_UI|Designing the User Interface]]]></column>
			<column name="PlainText"><![CDATA[Item Grouping on the Form Toolbar Menu items can be grouped on the form toolbar to keep a reasonable number of buttons on the     toolbar. When you are building the menu structure, use the menus described below. Data Entry Forms Actions : Use this menu to group the operations that give the user the      ability to process the document, including the actions that navigate to related data entry      forms (with the system filling in appropriate settings) so users can quickly create linked      documents. For example, see the  Enter Payment/Apply Memo  action on the         ([~/?ScreenId=AR301000|AR301000]) Invoices and Memos(AR301000)  form. The most frequently used operations can be placed on the toolbar      outside any groups as separate buttons that provide quick access to the actions. For example,      notice the  Release  action on the   ([~/?ScreenId=AR301000|AR301000]) Invoices and Memos form. Reports : Use this menu to group the actions that open related Report      Designer reports and printable forms of documents. Inquiries : Use this menu to group the actions that navigate to      related inquiry forms. Inquiry Forms Actions:  Use this menu to group the operations that give the user the      ability to navigate to related data entry forms. Reports:  Use this menu to group the actions that open the related      Report Designer reports. Maintenance Forms Actions : Use this menu to group the operations that update the      settings of the master record and navigate to related data entry forms. Reports : Use this menu to group the actions that open related Report      Designer reports. Inquiries : Use this menu to group the actions that navigate to      related inquiry forms. ]]></column>
		</row>
		<row PageID="aa5bcc83-1246-45e3-bd29-2e8a619eb27f" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can find the naming conventions for the graphs and event handlers.&#xA;==In This Chapter==[anchor|#_758b7053-4ae7-455e-bdc3-a74f1162ae84]&#xA;*[HelpRoot_Dev_Platform\DA__con_Graph_Naming|Graph Naming]&#xA;*[HelpRoot_Dev_Platform\DA__con_Event_Handler_Naming|Naming Conventions for Event Handlers Defined in Graphs]&#xA;&#xA;==Related Articles==&#xA;*[HelpRoot_Dev_Platform\DA__mng_Designing_Database_Structure|Designing the Database Structure and DACs]&#xA;*[HelpRoot_Dev_Platform\DA__mng_Designing_UI|Designing the User Interface]" PlainText="Naming the Graphs and Event Handlers In this chapter, you can find the naming conventions for the graphs and event handlers. In This Chapter Graph NamingNaming Conventions for Event Handlers Defined in Graphs" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f0e5a63e-56e0-5ed3-0942-8c29b1d1da96" RecordSourceID="22377" />
		<row PageID="100693b9-cf45-47aa-a653-24e03f7a93e8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="feb63c44-1212-1ce3-a396-beaa4ede526f" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When you are creating business logic controllers (graphs), use the following suffixes in the names of the graphs, depending on the types of the webpages they are used for:[anchor|#_724a1004-a756-4a6b-bfcc-e002275e3d74]
*{{Maint}}: For the graphs for maintenance pages that are helper pages used for the input of data on the data entry and processing pages, and for the graphs for the setup pages that provide the configuration parameters for the application. For example, {{CountryMaint}} can be the name of the graph for the Countries maintenance page, which provides editing of the list of countries.
*{{Entry}}: For the graphs for data entry pages that are used for the input of business documents. For example, {{SalesOrderEntry}} can be the name of the graph for the Sales Order data entry page, which provides the basic functionality for working with sales orders.
*{{Inq}}: For the graphs for inquiry pages, which display a list of data records selected by the specified filter. For example, {{SalesOrderInq}} can be the name of the inquiry page named Sales Order Inquiry, which provides the list of documents selected by the specified customer.
*{{Process}}: For the graphs for processing pages that provide mass processing operations. For example, {{SalesOrderProcess}} can be the name of the Approve Sales Orders processing page, which provides mass approval of sales orders.

==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Code_Guidelines|Naming the Graphs and Event Handlers]]]></column>
			<column name="PlainText"><![CDATA[Graph Naming When you are creating business logic controllers (graphs), use the following suffixes in the     names of the graphs, depending on the types of the webpages they are used for: Maint : For the graphs for maintenance pages that are helper pages used for       the input of data on the data entry and processing pages, and for the graphs for the setup       pages that provide the configuration parameters for the application. For example,         CountryMaint  can be the name of the graph for the Countries maintenance       page, which provides editing of the list of countries. Entry : For the graphs for data entry pages that are used for the input of       business documents. For example,  SalesOrderEntry  can be the name of the graph       for the Sales Order data entry page, which provides the basic functionality for working with       sales orders. Inq : For the graphs for inquiry pages, which display a list of data       records selected by the specified filter. For example,  SalesOrderInq  can be       the name of the inquiry page named Sales Order Inquiry, which provides the list of documents       selected by the specified customer. Process : For the graphs for processing pages that provide mass processing       operations. For example,  SalesOrderProcess  can be the name of the Approve       Sales Orders processing page, which provides mass approval of sales orders. ]]></column>
		</row>
		<row PageID="b6ff1ff7-5bf6-4ce2-a164-7d1cc7baecd5" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2a2d8562-38c3-fdb2-3b08-a1af05ede45c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In Acumatica Framework, you must adhere to the naming conventions for an event handler to be implemented in a graph or graph extension. The name of the event handler must include the event type and the object to be processed by the handler.{br}

The name of a data record event handler must have the following segments, which are separated by the ''&#95;'' symbol:[anchor|#_3345d3a3-0237-42b2-b8b3-571f2bb56b92]
#The name of the DAC declared in the server
#The name of the record event supported by the server
{br}

Therefore, the name of a data record event handler must be in the following format: ''DACName&#95;EventName'' (such as <tt>SOOrder&#95;RowSelected</tt>).{br}

The name of a data field event handler must have the following segments, which are separated by the ''&#95;'' symbol:[anchor|#_7a3118f4-63bb-4791-80c8-6c5bb3d20b80]
#The name of the DAC declared in the server
#The name of the data field declared within the DAC whose name is specified in the first segment
# The name of the field event supported by the server
{br}

Therefore, for a field event handler, the name must be in the following format: ''DACName&#95;FieldName&#95;EventName'' (such as <tt>SOOrder&#95;CustomerID&#95;FieldUpdated</tt>).
==Related Articles==
*[HelpRoot_Dev_Platform\DA__mng_Code_Guidelines|Naming the Graphs and Event Handlers]]]></column>
			<column name="PlainText"><![CDATA[Naming Conventions for Event Handlers Defined in Graphs In  Acumatica Framework, you must adhere to the naming conventions for an event handler to be implemented in a graph     or graph extension. The name of the event handler must include the event type and the object to     be processed by the handler. The name of a data record event handler must have the following segments, which are separated     by the  _  symbol: The name of the DAC declared in the server The name of the record event supported by the server Therefore, the name of a data record event handler must be in the following format:       DACName_EventName  (such as  SOOrder_RowSelected ). The name of a data field event handler must have the following segments, which are separated     by the  _  symbol: The name of the DAC declared in the server The name of the data field declared within the DAC whose name is specified in the first       segment  The name of the field event supported by the server Therefore, for a field event handler, the name must be in the following format:       DACName_FieldName_EventName  (such as      SOOrder_CustomerID_FieldUpdated ). ]]></column>
		</row>
		<row PageID="ca6d5149-db7a-42b9-bce1-d6f26a5c2ca7" Language="en-US" PageRevisionID="1" Content="&#xA;In this part of the guide, you can find information about how the webpages of Acumatica ERP or an Acumatica Framework-based application work and how to configure the ASPX code of these webpages. You can also find a brief overview of reports.&#xA;==In This Part==[anchor|#_830e0de5-8399-4921-9886-ab953b546fa0]&#xA;*[HelpRoot_Dev_Platform\CW__mng_Overview|Overview of ASPX Webpages in Acumatica Framework]&#xA;*[HelpRoot_Dev_Platform\CW__mng_Configuring_Containers|Configuring Containers]&#xA;*[HelpRoot_Dev_Platform\CW__mng_Configuring_Tables|Configuring Tables]&#xA;*[HelpRoot_Dev_Platform\CW__mng_Configuring_Tabs|Configuring Tabs]&#xA;*[HelpRoot_Dev_Platform\CW__mng_Configuring_Boxes|Configuring Boxes]&#xA;*[HelpRoot_Dev_Platform\CW__mng_Configuring_Layout|Configuring Layout and Size]&#xA;*[HelpRoot_Dev_Platform\CC__mng_Working_with_Reports|Maintaining Reports]&#xA;" PlainText="Configuring ASPX Webpages and Reports In this part of the guide, you can find information about how the webpages of  Acumatica ERP     or an  Acumatica Framework-based     application work and how to configure the ASPX code of these webpages. You can also find a brief     overview of reports. In This Part Overview of ASPX Webpages in Acumatica FrameworkConfiguring ContainersConfiguring TablesConfiguring TabsConfiguring BoxesConfiguring Layout and SizeMaintaining Reports" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="b2df624f-d508-4cdb-679a-310a38fb2c07" RecordSourceID="22377" />
		<row PageID="c5b04643-bdef-43ed-aa69-2d72e396c899" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f7cebfbf-328c-28e7-27e2-10aef4e6c78a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In Acumatica Framework-based applications, you can configure the appearance of webpages from the front end (that is, by configuring ASPX pages) and from the back end (that is, by using the attributes and events provided by the Acumatica platform). {br}

In this chapter of the guide, you can find information about how to create the ASPX code of the webpages. This chapter also includes a technical overview of the user interface of an Acumatica Framework-based application. For information about the configuration of the UI from the back end, see [HelpRoot_Dev_Platform\BL__mng_Configuring_UI_from_Back_End|Configuring the UI from the Back End].{br}{TOC}
==Technical Overview of the User Interface==
The user interface of Acumatica ERP or an Acumatica Framework-based application uses the same core technologies. To learn how the user interface works, see [HelpRoot_Dev_Platform\CW__con_Button_Click|Processing of a Button Click] and [HelpRoot_Dev_Platform\CW__con_Modern_UI|Technical Overview of the Modern UI]. You can find a detailed description of the user interface in [HelpRoot_Interface\InterfaceBasics| Acumatica ERP Interface Guide].
==Configuration of ASPX Webpages==
You can configure the appearance and behavior of webpages by using the properties of the ASPX objects that can be used on the Acumatica ERP or Acumatica Framework webpages. For details on how to work with the ASPX code of the webpages, see the following topics:[anchor|#_6d951934-2331-486f-a5f6-73a16af6b638]
*To configure containers, such as <tt>PXFormView</tt>, <tt>PXGrid</tt>, <tt>PXTab</tt>, <tt>PXTreeView</tt>, and <tt>PXPanel</tt>: [HelpRoot_Dev_Platform\CW__mng_Configuring_Containers|Configuring Containers]
*To configure tables (<tt>PXGrid</tt> and <tt>PXGridColumn</tt>): [HelpRoot_Dev_Platform\CW__mng_Configuring_Tables|Configuring Tables]
*To configure tabs (<tt>PXTab</tt> and <tt>PXTabItem</tt>): [HelpRoot_Dev_Platform\CW__mng_Configuring_Tabs|Configuring Tabs]
*To configure boxes, such as <tt>PXTextEdit</tt>, <tt>PXCheckBox</tt>, and <tt>PXGroupBox</tt>): [HelpRoot_Dev_Platform\CW__mng_Configuring_Boxes|Configuring Boxes]
*To configure the layout (<tt>PXLayoutRule</tt>) and size of controls: [HelpRoot_Dev_Platform\CW__mng_Configuring_Layout|Configuring Layout and Size]
]]></column>
			<column name="PlainText"><![CDATA[Overview of ASPX Webpages in  Acumatica FrameworkIn  Acumatica Framework-based applications, you can configure the appearance of webpages from the front end (that         is, by configuring ASPX pages) and from the back end (that is, by using the attributes and         events provided by the  Acumatica platform).  In this chapter of the guide, you can find information about how to create the ASPX code of         the webpages. This chapter also includes a technical overview of the user interface of an            Acumatica Framework-based application. For information about the configuration of the UI from the back end,         see  Configuring the UI from the Back End. Technical Overview of the User Interface The user interface of  Acumatica ERP or an  Acumatica Framework-based application uses the same core technologies. To learn how the user interface works,         see  Processing of a Button Click and  Technical Overview of the Modern UI. You         can find a detailed description of the user interface in   Acumatica ERP Interface Guide. Configuration of ASPX Webpages You can configure the appearance and behavior of webpages by using the properties of the ASPX         objects that can be used on the  Acumatica ERP or  Acumatica Framework     webpages. For details on how to work with the ASPX code of the webpages, see the following      topics: To configure containers, such as  PXFormView ,                PXGrid ,  PXTab ,  PXTreeView ,             and  PXPanel :  Configuring ContainersTo configure tables ( PXGrid  and  PXGridColumn ):                Configuring TablesTo configure tabs ( PXTab  and  PXTabItem ):  Configuring TabsTo configure boxes, such as  PXTextEdit ,                PXCheckBox , and  PXGroupBox ):  Configuring BoxesTo configure the layout ( PXLayoutRule ) and size of controls:  Configuring Layout and Size]]></column>
		</row>
		<row PageID="a23d3b80-e763-46da-9beb-c1447ceae4b3" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="7359e9b0-922b-2c35-1b34-842dc6b850c3" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When a user clicks a button on an ASPX page, such as the '''Save''' button on the toolbar of a form, the webpage creates a postback HTTP request to the server. When processing the request, the application server does the following: commits changes (if required by the operation initiated by the user), executes the operation, and collects data for the response. Then the application server sends the response to the webpage, which renders the new data. The following diagram illustrates this process, which is described in more detail in the sections of this topic.[anchor|#_15312659-29b2-4e45-8316-64f644c76ee4][anchor|#_fed9ed72-0610-465a-bb7c-6d062791a4df][image:StudioDeveloperGuide/Images/ButtonClick_MainSteps.png|popup|Processing a button click|450px]{br}{TOC}
==Sending of the HTTP Request==
When the user clicks a button on a webpage, the page creates an HTTP request to the server. The request includes the following information:[anchor|#_cb2ef695-7782-43d6-8965-9ec9f2130912]
*The values of the key fields of the record currently displayed on the page
*The changes that have been made to the data on the page
*The information on the command that was initiated by the user—the data source ID and the callback name
{br}

The <tt>PXDataSource.TypeName</tt> property defines the graph that processes data for the page. When the application server receives the request, the server creates a new instance of the graph to process the data of the request. The properties of <tt>PXDSCallbackCommand</tt>, such as <tt>CommitChanges</tt> and <tt>RepaintControls</tt>, indicate which operations should be performed on the server in addition to the operation initiated by the user.{br}

The diagram below shows how the HTTP request is sent to the server.[anchor|#_842226d5-628b-4305-beea-c12b0f77a62b][anchor|#_1d9b4e1b-ceed-4aec-a076-308a4d0a03d1][image:StudioDeveloperGuide/Images/ButtonClick_SendHttpRequest.png|popup|Sending the HTTP request|450px]
==Commitment of Changes to the Cache==
If the callback command initiated by the user has the <tt>CommitChanges</tt> property set to {{true}} or the <tt>CommitChangesIDs</tt> property specified, the server commits the changes before executing the command. The graph instance commits the changes to the cache in the order in which the data views are defined in the graph, as shown in the following diagram.[anchor|#_a42d4ba4-d42a-45cd-aecd-8d61adac57eb][anchor|#_69ef7714-050b-4c27-a914-a820afc05ce3][image:StudioDeveloperGuide/Images/ButtonClick_CommitChanges.png|popup|Committing changes|450px]
==Execution of the Command==
After the changes have been committed, the graph instance executes the operation initiated by the user, such as saving data to the database. You can find details on the sequence of events raised when data is inserted, updated, deleted, or saved to the database in [HelpRoot_Dev_Platform\BL__con_Events_Scenarios|Data Manipulation Scenarios].
==Collection of the Data for the Response==
When the command execution is completed, the application server does the following:[anchor|#_c6965c6f-5c32-4c54-a67d-d5b5f3a1a3df]
#If the <tt>RepaintControls</tt> or <tt>RepaintControlIDs</tt> property of <tt>PXDSCallbackCommand</tt> specifies any controls to be repainted after the command is executed, the application server includes in the response all information that is necessary to repaint these controls on the webpage. (By default, the value of the <tt>PXDSCallbackCommand.RepaintControls</tt> property is <tt>All</tt>, which means that all controls on the page are repainted.)
#The application server executes the <tt>Select</tt> method for each data view of the graph.

==Sending of the HTTP Response and Rendering of the Controls==
The application server sends the response to the page. The response includes data in XML format; the parameters that are necessary for the controls to be repainted are specified in JSON format, as shown in the following fragment of the response.{{{{&lt;Controls&gt;
  &lt;Control ID="ctl00_phF_form_edDocType" 
           Props="{items:&quot;INV|Invoice|1;DRM|Debit Memo|1;CRM|
                   Credit Memo|1;FCH|Overdue Charge|1;SMC|Credit WO|1&quot;,
                   value:&quot;FCH&quot;}" /&gt;
  &lt;Control ID="ctl00_phF_form_edRefNbr" Props="{value:&quot;AR005254&quot;}" /&gt;
  ...
&lt;/Controls&gt;
}}}}{br}

The scripts in the browser (the scripts from <tt>PX.Web.UI.Scripts</tt>) find the controls to be repainted by IDs and repaint these controls by using the data provided in the response. Most of the scripts in <tt>PX.Web.UI.Scripts</tt> contain a class that works with one control. For example, <tt>px&#95;textEdit.js</tt> includes the <tt>PXTextEdit</tt> class, which works with the <tt>PXTextEdit</tt> control. 
==Exceptions to the Process==
For the buttons not found on the main toolbar, the process described in this topic may slightly differ. {br}

For example, for the table toolbar buttons, which perform actions on particular rows of grids, the scripts translate the data in XML format, which is returned in the response, to HTML format by using XSLT. {br}

For the buttons in dialog boxes (the <tt>PXSmartPanel</tt> control), no commit of changes is performed. Whether data is selected from the database depends on the particular dialog box. The data that is returned from the server is in HTML format. ]]></column>
			<column name="PlainText"><![CDATA[Processing of a Button Click When a user clicks a button on an ASPX page, such as the  Save  button on the toolbar         of a form, the webpage creates a postback HTTP request to the server. When processing the         request, the application server does the following: commits changes (if required by the         operation initiated by the user), executes the operation, and collects data for the         response. Then the application server sends the response to the webpage, which renders the         new data. The following diagram illustrates this process, which is described in more detail         in the sections of this topic. Processing a button click Sending of the HTTP Request When the user clicks a button on a webpage, the page creates an HTTP request to the server.         The request includes the following information: The values of the key fields of the record currently displayed on the page The changes that have been made to the data on the page The information on the command that was initiated by the user—the data source ID             and the callback name The  PXDataSource.TypeName  property defines the graph that processes data         for the page. When the application server receives the request, the server creates a new         instance of the graph to process the data of the request. The properties of            PXDSCallbackCommand , such as  CommitChanges  and            RepaintControls , indicate which operations should be performed on the         server in addition to the operation initiated by the user. The diagram below shows how the HTTP request is sent to the server. Sending the HTTP request Commitment of Changes to the Cache If the callback command initiated by the user has the  CommitChanges          property set to  true  or the  CommitChangesIDs  property         specified, the server commits the changes before executing the command. The graph instance         commits the changes to the cache in the order in which the data views are defined in the         graph, as shown in the following diagram. Committing changes Execution of the Command After the changes have been committed, the graph instance executes the operation initiated         by the user, such as saving data to the database. You can find details on the sequence of         events raised when data is inserted, updated, deleted, or saved to the database in  Data Manipulation Scenarios. Collection of the Data for the Response When the command execution is completed, the application server does the following: If the  RepaintControls  or  RepaintControlIDs              property of  PXDSCallbackCommand  specifies any controls to be             repainted after the command is executed, the application server includes in the response             all information that is necessary to repaint these controls on the webpage. (By default,             the value of the  PXDSCallbackCommand.RepaintControls  property is                All , which means that all controls on the page are repainted.) The application server executes the  Select  method for each data             view of the graph. Sending of the HTTP Response and Rendering of the Controls The application server sends the response to the page. The response includes data in XML         format; the parameters that are necessary for the controls to be repainted are specified in         JSON format, as shown in the following fragment of the         response. <Controls>
  <Control ID="ctl00_phF_form_edDocType" 
           Props="{items:&quot;INV|Invoice|1;DRM|Debit Memo|1;CRM|
                   Credit Memo|1;FCH|Overdue Charge|1;SMC|Credit WO|1&quot;,
                   value:&quot;FCH&quot;}" />
  <Control ID="ctl00_phF_form_edRefNbr" Props="{value:&quot;AR005254&quot;}" />
  ...
</Controls> The scripts in the browser (the scripts from  PX.Web.UI.Scripts ) find the         controls to be repainted by IDs and repaint these controls by using the data provided in the         response. Most of the scripts in  PX.Web.UI.Scripts  contain a class that         works with one control. For example,  px_textEdit.js  includes the            PXTextEdit  class, which works with the  PXTextEdit          control.  Exceptions to the Process For the buttons not found on the main toolbar, the process described in this topic may         slightly differ.  For example, for the table toolbar buttons, which perform actions on particular rows of         grids, the scripts translate the data in XML format, which is returned in the response, to         HTML format by using XSLT.  For the buttons in dialog boxes (the  PXSmartPanel  control), no commit of         changes is performed. Whether data is selected from the database depends on the particular         dialog box. The data that is returned from the server is in HTML format.  ]]></column>
		</row>
		<row PageID="28874cf9-a344-4590-9f3d-70a67318b7c4" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="14dfe5a7-8bac-5bf1-bb08-e6c7528264b5" RecordSourceID="22377">
			<column name="Content"><![CDATA[
 Acumatica ERP provides two versions of its user interface: the modern UI, which is introduced in Acumatica ERP 2017R1, and the classic UI, which was available in previous versions. In this topic, you can find a technical overview of the modern UI. {br}

For more details on the elements of the modern UI, see [HelpRoot_Interface\UIG__con_New_UI|Modern Acumatica ERP User Interface] in the Interface Guide.{br}{TOC}
==Technologies in the Modern UI==
The modern UI is a new webpage frame that can be used for navigation between Acumatica ERP forms instead of the classic UI navigation, which provides the site map that users use to navigate between pages. {br}

With the modern UI, the Acumatica ERP form is located in the inner frame, which is completely independent of the modern UI frame. The webpage renders the navigation elements of the modern UI and the forms separately by using different technologies. The work of Acumatica ERP forms is based on the ASP.NET Web Forms technology, while the modern UI uses the ASP.NET MVC technology with the Razor view engine. Therefore, regardless of whether a user selects the modern UI or the classic UI for navigation between Acumatica ERP forms, the forms themselves work in the same way and use the same business logic.{br}

The server side of the modern UI uses the ASP.NET Web API framework. The client side uses the React library, which is a JavaScript library, to render main menu items, workspaces, tiles, and other navigation elements of the modern UI.
==Work of the Modern UI==
The following diagram shows how the browser renders the modern UI elements. This process is described in more detail in the remaining sections of this topic.[anchor|#_df0ccf5c-0b54-45a7-8809-59087d3f2c98][anchor|#_dde9dd0b-91b7-490b-bcbb-694f746988f6][image:StudioDeveloperGuide/Images/ModernUIRequests.png|popup|Rendering of the Modern UI|450px]
==Request of main.cshtml==
The browser retrieves <tt>main.cshtml</tt>, which is an ASP.NET MVC view, by sending the HTTP GET request. On the server side, this request is processed by the <tt>MainController.Main()</tt> method (<tt>PX.Web.UI.Frameset.Controllers</tt>), which creates a <tt>System.Web.Mvc.ViewResult</tt> object that renders a view to the response. The returned view contains the basic skeleton of the webpage, which includes the calendar control, the search control, and the empty menu.
==Request of the Menu Structure==
The <tt>getSiteMap</tt> function in <tt>site.js</tt> uses jQuery to send an AJAX request to ASP.NET Web API of the application server. On the server side, this request is processed by the <tt>SiteMapController</tt> class (<tt>PX.Web.UI.Frameset.WebApi.Controllers</tt>). ((({S:Hint}To match the incoming request to the appropriate processing classes, the system uses the ASP.NET MVC attribute routing. For example, the <tt>SiteMapController</tt> class is annotated with the {{[FramesetRoutePrefix("sitemap")]}} attribute, which defines the {{"frameset/sitemap"}} route.
))){br}

To get the site map structure, the <tt>SiteMapController</tt> class uses the <tt>SiteMapRepository</tt> class, which implements the <tt>ISiteMapRepository</tt> interface. The <tt>SiteMapRepository</tt> class fetches different entities of the modern UI and assembles them in one structure, which is then passed to the browser. The system serializes the structure to JSON format by using the standard ASP.NET Web API classes.{br}

The <tt>SiteMapRepository</tt> class uses other classes that have the <tt>Repository</tt> suffix in their names, such as <tt>TileRepository</tt> and <tt>WorkspaceRepository</tt>, to retrieve the entities that are used in the modern UI. These classes are completely independent from the database. To fetch the entities from the database, the <tt>Repository</tt> classes use the classes that implement the <tt>IEntitySet</tt> interface (<tt>PX.Web.UI.Frameset.Model</tt>), such as <tt>ScreenEntitySet</tt>. The classes use the <tt>MUIGraph</tt> graph to fetch data from the database. (The graph performs only simple data operations, and does not contain any complicated business logic). For each entity, there is a DAC that is used to access data in the database. The DACs correspond to the following database tables, which are used to store data for the elements of the modern UI. [anchor|#_96b5e227-c50f-40c1-86cb-3f35d2efb484]
===Database Tables===
{| class="checklist" | width="100%" 
|- 
!width="20%" ! Table
!width="80%" ! Description
|- 
| <tt>MUIWorkspace</tt>
| Stores information about the workspaces in the application. For more information on the workspaces, see [HelpRoot_Interface\UIG__con_New_UI_Workspaces|Workspaces in the Modern UI] in the Interface Guide.
|- 
| <tt>MUIFavoriteWorkspace</tt>
| Stores information about the workspaces that have been pinned to the main menu. The workspaces that are not included in this list are displayed when a user clicks the '''More Items''' menu item. For details about the main menu, see [HelpRoot_Interface\UIG__con_New_UI_Main_Menu|Main Menu in the Modern UI] in the Interface Guide.
|- 
| <tt>MUIArea</tt>
| Stores information about the areas to which workspaces belong. Areas are used to group workspaces in the '''More Items''' menu by types.
|- 
| <tt>MUISubcategory</tt>
| Stores information about the categories of Acumatica ERP forms. Categories are used to group forms in a workspace by types. For details on the categories, see [HelpRoot_Interface\UIG__con_New_UI_Workspaces#_f0e79a7c-3693-4497-bf83-9763e12a7536|Categories].
|- 
| <tt>MUIScreen</tt>
| Stores information about the locations of the Acumatica ERP forms in the modern UI. The table is connected to the <tt>SiteMap</tt> table by the <tt>NoteID</tt> column.
|- 
| <tt>MUIPinnedScreen</tt>
| Stores information about the Acumatica ERP forms pinned to workspaces.
|- 
| <tt>MUIFavoriteScreen</tt>
| Stores information about the Acumatica ERP forms that have been added to favorites.
|- 
| <tt>MUITile</tt>
| Stores information about the tiles in workspaces. A tile is a special button on a workspace that you click to open a form or report with predefined settings. For details on the tiles, see [HelpRoot_Interface\UIG__con_New_UI_Workspaces#_61d15fc8-4657-43b1-9f84-5df65deea3c8|Tiles].
|- 
| <tt>MUIFavoriteTile</tt>
| Stores information about the tiles that have been added to favorites.
|- 
| <tt>MUIUserPreferences</tt>
| Stores information about the position of the main menu, which can be on the left of the browser page (default) or on the top of the browser page.
|}
The following diagram illustrates the process of retrieving data for the modern UI.[anchor|#_b9e26643-5fe3-4b5e-a127-63a7f3e451ef][anchor|#_5f02afa1-7335-4759-b8b1-ca294c546cf5][image:StudioDeveloperGuide/Images/ModernUI_SiteMapRetrieval.png|popup|Retrieval of the site map|450px]
==Rendering of the Modern UI Elements==
The main script that is used to render the modern UI is <tt>site.js</tt>. It contains classes that use the React library to render modern UI elements. Each such class includes the <tt>render</tt> method, which uses React classes to render the element. The following tables lists the main classes and their methods.[anchor|#_d87e3ff3-bec8-44e0-9113-bdcfacd0beda]
===The Classes for Rendering the Modern UI===
{| class="checklist" | width="100%" 
|- 
!width="20%" ! Class
!width="80%" ! Description
|- 
| <tt>MenuModules</tt>
| 
Renders the main menu (which contains the list of workspaces). For more information on the main menu, see [HelpRoot_Interface\UIG__con_New_UI_Main_Menu|Main Menu in the Modern UI] in the Interface Guide. {br}

In addition to the <tt>render</tt> method, the class has the following methods:[anchor|#_a8bdc958-d688-4480-bc51-cef8670fdff8]
*<tt>onClick</tt>: Processes the clicking of the Edit and Delete buttons for the items of the main menu in Menu Editing mode.
*<tt>onClickFav</tt>: Processes the clicking of the Pin button in a workspace.
*<tt>onDragStart</tt>, <tt>onDragOver</tt>, <tt>onDragLeave</tt>, and <tt>onDrop</tt>: Process operations related to dragging the items of the main menu in Menu Editing mode.
For details on menu editing, see [HelpRoot_Interface\UIG__con_New_UI_Edit_Menu_Mode|Menu Editing Mode in the Modern UI].
|- 
| <tt>TopLinks</tt>
| 
Renders the tiles in the workspaces. For details about the tiles, see [HelpRoot_Interface\UIG__con_New_UI_Workspaces#_61d15fc8-4657-43b1-9f84-5df65deea3c8|Tiles] in the Interface Guide.{br}

In addition to the <tt>render</tt> method, the class has the following methods:[anchor|#_6b2d176e-0e4f-4dbf-bd1d-2f08d21f2302]
*<tt>onClick</tt>: Processes the clicking of the Edit and Delete buttons for the tiles in Menu Editing mode and clicking of the Favorite button.
*<tt>onDragStart</tt>, <tt>onDragOver</tt>, <tt>onDragLeave</tt>, and <tt>onDrop</tt>: Process operations related to dragging the tiles in Menu Editing mode.
For details on menu editing, see [HelpRoot_Interface\UIG__con_New_UI_Edit_Menu_Mode|Menu Editing Mode in the Modern UI].
|- 
| <tt>MenuColumn</tt>
| 
Renders a list of forms in a workspace. For the information about workspaces, see [HelpRoot_Interface\UIG__con_New_UI_Workspaces|Workspaces in the Modern UI] in the Interface Guide.{br}

In addition to the <tt>render</tt> method, the class has the following methods:[anchor|#_c0c55751-bca8-4afc-9197-d30e827d1c65]
*<tt>onClick</tt>: Processes the clicking of the Edit and Delete buttons for a form in a workspace in Menu Editing mode.
*<tt>onClickFav</tt>: Processes the clicking of the Favorite icon for a form in a workspace.
*<tt>onClickPin</tt>: Processes the clicking of a check box when a user selects a form in a workspace in Menu Editing mode.
{br}

For more information on menu editing, see [HelpRoot_Interface\UIG__con_New_UI_Edit_Menu_Mode|Menu Editing Mode in the Modern UI]. 
|- 
| <tt>ModuleMenu</tt>
| 
Renders all lists of forms in a workspace. For details about workspaces, see [HelpRoot_Interface\UIG__con_New_UI_Workspaces|Workspaces in the Modern UI] in the Interface Guide. {br}

In addition to the <tt>render</tt> method, the class has the following methods:[anchor|#_62dae416-365a-4bea-983e-777e6fb67a62]
*<tt>getItemsInCol</tt>, <tt>arrangeLinks</tt>, and <tt>arrangeLinks2</tt>: Arrange links to forms in lists.
*<tt>onDragStart</tt>, <tt>onDragOver</tt>, <tt>onDragLeave</tt>, and <tt>onDrop</tt>: Process operations related to dragging the links to forms in a workspace in Menu Editing mode.

|}{br}

The <tt>site.js</tt> script also contains webpage event handlers, such as handlers for button-clicking events, which use jQuery to handle the events.
==Customization of the Modern UI==
An administrator can configure the modern UI to fit the work purposes of the organization, as described in [HelpRoot_Administration\AS__mng_User_Interface_Configuration|Customizing the User Interface] in the System Administration Guide.{br}

To change the styles of the elements of the modern UI, the developer can change the CSS related to these elements. {br}

If a developer has added a new form or report to the Acumatica ERP site in a customization project, the location of the form in the modern UI is included in the customization project along with the ''SiteMap'' customization project item, which is created either automatically or manually for the new item. For details, see [HelpRoot_Dev_Customization\CG_GL_Items_Screens_AddingCustom|To Add a New Custom Form to a Project] and [HelpRoot_Dev_Customization\CG_GL_Items_AnaliticalReports_Adding|To Add a Custom Analytical Report to a Project] in the Customization Guide. For the custom generic inquiries and dashboards, the information about the location in the modern UI is included in the ''GenericInquiryScreen'' and ''Dashboard'' customization project items, respectively.
==Related Articles==
*[HelpRoot_Interface\UIG__con_New_UI|Modern Acumatica ERP User Interface]]]></column>
			<column name="PlainText"><![CDATA[Technical Overview of the Modern UI  Acumatica ERP provides two versions of its user interface: the modern UI, which is introduced in  Acumatica ERP 2017R1, and the classic UI, which was available in previous versions. In this topic, you         can find a technical overview of the modern UI.  For more details on the elements of the modern UI, see  Modern Acumatica ERP User Interface in the Interface Guide. Technologies in the Modern UI The modern UI is a new webpage frame that can be used for navigation between  Acumatica ERP forms instead of the classic UI navigation, which provides the site map that users use to         navigate between pages.  With the modern UI, the  Acumatica ERP form is located in the inner frame, which is completely independent of the modern UI         frame. The webpage renders the navigation elements of the modern UI and the forms separately         by using different technologies. The work of  Acumatica ERP forms is based on the ASP.NET Web Forms technology, while the modern UI uses the ASP.NET         MVC technology with the Razor view engine. Therefore, regardless of whether a user selects         the modern UI or the classic UI for navigation between  Acumatica ERP forms, the forms themselves work in the same way and use the same business logic. The server side of the modern UI uses the ASP.NET Web API framework. The client side uses the         React library, which is a JavaScript library, to render main menu items, workspaces, tiles,         and other navigation elements of the modern UI. Work of the Modern UI The following diagram shows how the browser renders the modern UI elements. This process is         described in more detail in the remaining sections of this topic. Rendering of the Modern UI Request of main.cshtml The browser retrieves  main.cshtml , which is an ASP.NET MVC view, by     sending the HTTP GET request. On the server side, this request is processed by the       MainController.Main()  method      ( PX.Web.UI.Frameset.Controllers ), which creates a       System.Web.Mvc.ViewResult  object that renders a view to the response. The     returned view contains the basic skeleton of the webpage, which includes the calendar control,     the search control, and the empty menu. Request of the Menu Structure The  getSiteMap  function in  site.js  uses jQuery to send         an AJAX request to ASP.NET Web API of the application server. On the server side, this         request is processed by the  SiteMapController  class           ( PX.Web.UI.Frameset.WebApi.Controllers ).  To match the incoming           request to the appropriate processing classes, the system uses the ASP.NET MVC attribute           routing. For example, the  SiteMapController  class is annotated with the              [FramesetRoutePrefix("sitemap")]  attribute, which defines the              "frameset/sitemap"  route. To get the site map structure, the  SiteMapController  class uses the            SiteMapRepository  class, which implements the            ISiteMapRepository  interface. The  SiteMapRepository          class fetches different entities of the modern UI and assembles them in one structure, which         is then passed to the browser. The system serializes the structure to JSON format by using         the standard ASP.NET Web API classes. The  SiteMapRepository  class uses other classes that have the            Repository  suffix in their names, such as            TileRepository  and  WorkspaceRepository , to retrieve         the entities that are used in the modern UI. These classes are completely independent from         the database. To fetch the entities from the database, the  Repository          classes use the classes that implement the  IEntitySet  interface           ( PX.Web.UI.Frameset.Model ), such as  ScreenEntitySet .         The classes use the  MUIGraph  graph to fetch data from the database. (The         graph performs only simple data operations, and does not contain any complicated business         logic). For each entity, there is a DAC that is used to access data in the database. The         DACs correspond to the following database tables, which are used to store data for the         elements of the modern UI.  Database Tables Table Description MUIWorkspace Stores information about the workspaces in the application. For more                   information on the workspaces, see  Workspaces in the Modern UI in the Interface                   Guide. MUIFavoriteWorkspace Stores information about the workspaces that have been pinned to the main                   menu. The workspaces that are not included in this list are displayed when a user                   clicks the  More Items  menu item. For details about the main                   menu, see  Main Menu in the Modern UI in the                   Interface Guide. MUIArea Stores information about the areas to which workspaces belong. Areas are used                   to group workspaces in the  More Items  menu by                   types. MUISubcategory Stores information about the categories of  Acumatica ERP forms. Categories are used to group forms in a workspace by types. For details                   on the categories, see  Categories. MUIScreen Stores information about the locations of the  Acumatica ERP forms in the modern UI. The table is connected to the                      SiteMap  table by the  NoteID                    column. MUIPinnedScreen Stores information about the  Acumatica ERP forms pinned to workspaces. MUIFavoriteScreen Stores information about the  Acumatica ERP forms that have been added to favorites. MUITile Stores information about the tiles in workspaces. A tile is a special button                   on a workspace that you click to open a form or report with predefined settings.                   For details on the tiles, see  Tiles. MUIFavoriteTile Stores information about the tiles that have been added to favorites. MUIUserPreferences Stores information about the position of the main menu, which can be on the                   left of the browser page (default) or on the top of the browser page. The following diagram illustrates the process of retrieving data for the modern UI. Retrieval of the site map Rendering of the Modern UI Elements The main script that is used to render the modern UI is  site.js . It         contains classes that use the React library to render modern UI elements. Each such class         includes the  render  method, which uses React classes to render the         element. The following tables lists the main classes and their methods. The Classes for Rendering the Modern UI Class Description MenuModules Renders the main menu (which contains the list of workspaces). For more                     information on the main menu, see  Main Menu in the Modern UI in the Interface                     Guide.  In addition to the  render  method, the class has the                     following methods: onClick : Processes the clicking of the Edit and Delete                         buttons for the items of the main menu in Menu Editing mode. onClickFav : Processes the clicking of the Pin button in                         a workspace. onDragStart ,  onDragOver ,                            onDragLeave , and  onDrop : Process                         operations related to dragging the items of the main menu in Menu Editing                         mode. For details on menu editing, see  Menu Editing Mode in the Modern UI. TopLinks Renders the tiles in the workspaces. For details about the tiles, see   Tiles in the Interface Guide. In addition to the  render  method, the class has the                     following methods: onClick : Processes the clicking of the Edit and Delete                         buttons for the tiles in Menu Editing mode and clicking of the Favorite                         button. onDragStart ,  onDragOver ,                            onDragLeave , and  onDrop : Process                         operations related to dragging the tiles in Menu Editing mode. For details on menu editing, see  Menu Editing Mode in the Modern UI. MenuColumn Renders a list of forms in a workspace. For the information about workspaces,                     see  Workspaces in the Modern UI in the                     Interface Guide. In addition to the  render  method, the class has the                     following methods: onClick : Processes the clicking of the Edit and Delete                         buttons for a form in a workspace in Menu Editing mode. onClickFav : Processes the clicking of the Favorite icon                         for a form in a workspace. onClickPin : Processes the clicking of a check box when                         a user selects a form in a workspace in Menu Editing mode. For more information on menu editing, see  Menu Editing Mode in the Modern UI.  ModuleMenu Renders all lists of forms in a workspace. For details about workspaces, see                        Workspaces in the Modern UI in the                     Interface Guide.  In addition to the  render  method, the class has the                     following methods: getItemsInCol ,  arrangeLinks , and                            arrangeLinks2 : Arrange links to forms in lists. onDragStart ,  onDragOver ,                            onDragLeave , and  onDrop : Process                         operations related to dragging the links to forms in a workspace in Menu                         Editing mode. The  site.js  script also contains webpage event handlers, such as handlers         for button-clicking events, which use jQuery to handle the events. Customization of the Modern UI An administrator can configure the modern UI to fit the work purposes of the organization, as         described in  Customizing the User Interface in the System Administration Guide. To change the styles of the elements of the modern UI, the developer can change the CSS         related to these elements.  If a developer has added a new form or report to the  Acumatica ERP site in a customization project, the location of the form in the modern UI is included in         the customization project along with the  SiteMap  customization project item, which is         created either automatically or manually for the new item. For details, see  To Add a New Custom Form to a Project and  To Add a Custom Analytical Report to a Project in the         Customization Guide. For the custom generic inquiries and dashboards, the information about         the location in the modern UI is included in the  GenericInquiryScreen  and            Dashboard  customization project items, respectively. ]]></column>
		</row>
		<row PageID="e62f99c6-20a7-4f27-929b-b5743c1d0d67" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can find information about the configuration of different types of containers, such as &lt;tt&gt;PXFormView&lt;/tt&gt;, &lt;tt&gt;PXGrid&lt;/tt&gt;, &lt;tt&gt;PXTab&lt;/tt&gt;, &lt;tt&gt;PXTreeView&lt;/tt&gt;, and &lt;tt&gt;PXPanel&lt;/tt&gt;.&#xA;==In This Chapter==[anchor|#_8dbb4e58-ef22-4928-86e9-ed1aab41fd64]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXForm_Properties_DataMember|Use of the DataMember Property of Containers]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXForm_Properties_SkinID|Use of the SkinID Property of Containers]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXForm_Properties_Caption|Use of the Caption Property of Containers]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXForm_AddBox_DataViews|Use of Multiple Data Views for Boxes in Containers]&#xA;" PlainText="Configuring Containers In this chapter, you can find information about the configuration of different types of     containers, such as  PXFormView ,  PXGrid ,       PXTab ,  PXTreeView , and  PXPanel . In This Chapter Use of the DataMember Property of ContainersUse of the SkinID Property of ContainersUse of the Caption Property of ContainersUse of Multiple Data Views for Boxes in Containers" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="70b69e81-afee-d675-d2d3-1d2fd5cce2e1" RecordSourceID="22377" />
		<row PageID="f4e4f1df-64bd-40b9-b487-bdc099ee952c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="90bff23c-e828-5c2c-a68b-fedd07c39146" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you need to find out which data view provides data for a control container on a form, perform a search to find the ''DataMember'' string in the appropriate ASPX code. The <tt>DataMember</tt> property is used to bind a control container of a form to a data view defined in the business logic controller (BLC, also referred as ''graph'') of the form. The property value is the name of the data view. 
==Container Types That Have the DataMember Property==
In Acumatica Framework, <tt>DataMember</tt> is used to specify a data view for the following container types:[anchor|#_c9049869-3c3c-4b36-9248-24214d562b81]
*<tt>PXFormView</tt>
* <tt>PXGrid</tt>
* <tt>PXTab</tt>
* <tt>PXTreeView</tt>
*:((({S:Hint}The <tt>PXTreeView</tt> container is not supported by the tools of the Acumatica Customization           Platform.
)))

By default, a nested container inherits the <tt>DataMember</tt> property from the parent container. If a nested container is <tt>PXFormView</tt>, <tt>PXGrid</tt>, or <tt>PXTab</tt>, it can be bound to another data view.{br}

If the <tt>DataMember</tt> property is available for other ASPX objects, it has a special purpose. For example, you can specify the <tt>DataMember</tt> property for a <tt>PXSelector</tt> lookup control to define the appropriate data view for the grid of the lookup window.
==Property Value==
Each <tt>DataMember</tt> property value can correspond to any data view name of the BLC. Any data view except for the main data view can be used by an unlimited number of containers. The main data view must be bound to a single container.{br}

For a container to contain a box for a data field, the container must be bound to a data view declared within a BLC for the following reasons:[anchor|#_c847b090-d4c7-442a-af1c-bd6dd13db0d2]
*A data field is declared in a data access class (DAC). An instance of the DAC record can exist in the cache of a BLC that contains the declaration of a data view with the DAC reference in the BQL statement.
*Each time a data record is selected in the container, the container creates a callback to the <tt>PXDataSource</tt> control that is specified in the <tt>DataSourceID</tt> property of the container. The data source control creates a remote procedure call to the application server to execute the ''Display'' operation on the data view that is specified as the <tt>DataMember</tt> for the container. The data view checks the existence of the record in the cache; if the check fails, the data view executes the BQL request and stores the obtained record in the cache.
*The data view provides all data exchange operations with the database, cache, and <tt>PXDataSource</tt> control.
]]></column>
			<column name="PlainText"><![CDATA[Use of the DataMember Property of Containers If you need to find out which data view provides data for a control     container on a form, perform a search to find the  DataMember  string in the appropriate     ASPX code. The  DataMember  property is used to bind a control container of a     form to a data view defined in the business logic controller (BLC, also referred as      graph ) of the form. The property value is the name of the data view.  Container Types That Have the DataMember Property In  Acumatica Framework,  DataMember  is used to specify a data view for the following container     types: PXFormView PXGrid PXTab PXTreeView The  PXTreeView  container is not       supported by the tools of the  Acumatica Customization           Platform. By default, a nested container inherits the  DataMember  property from the     parent container. If a nested container is  PXFormView ,       PXGrid , or  PXTab , it can be bound to another data     view. If the  DataMember  property is available for other ASPX objects, it has a     special purpose. For example, you can specify the  DataMember  property for a       PXSelector  lookup control to define the appropriate data view for the grid     of the lookup window. Property Value Each  DataMember  property value can correspond to any data view name of the     BLC. Any data view except for the main data view can be used by an unlimited number of     containers. The main data view must be bound to a single container. For a container to contain a box for a data field, the container must be bound to a data view     declared within a BLC for the following reasons: A data field is declared in a data access class (DAC). An instance of the DAC record can      exist in the cache of a BLC that contains the declaration of a data view with the DAC reference      in the BQL statement. Each time a data record is selected in the container, the container creates a callback to      the  PXDataSource  control that is specified in the        DataSourceID  property of the container. The data source control creates a      remote procedure call to the application server to execute the  Display  operation on the      data view that is specified as the  DataMember  for the container. The data      view checks the existence of the record in the cache; if the check fails, the data view      executes the BQL request and stores the obtained record in the cache. The data view provides all data exchange operations with the database, cache, and        PXDataSource  control. ]]></column>
		</row>
		<row PageID="ce75ce73-a264-41a6-9545-68ffe2003d45" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="3792fd1f-fd7d-15ee-f464-52990dd1afc0" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In the code of Acumatica ERP, predefined skins are used to assign a style and a set of toolbar buttons to a container. The <tt>SkinID</tt> property of a container specifies which of these skins the system should apply to the container. A skin is specific to a particular container; you cannot share a skin setting between containers of different types. If you do not set the <tt>SkinID</tt> property, the container uses the default skin, if one is defined.
==Predefined Skins==
The following table lists and describes the predefined skins that are recommended to use for the <tt>PXFormView</tt>, <tt>PXGrid</tt>, and <tt>PXPanel</tt> containers.[anchor|#_67307219-dbee-440f-a18e-24613a9a35e4]
{| class="checklist" | width="100%" 
|- 
!width="12%" ! UI Element
!width="12%" ! SkinID
!width="50%" ! Description
!width="25%" ! Example
|- 
| <tt>PXFormView</tt>
|  ''Transparent''
| Is used to display a simple form container that has no caption and cannot be collapsed.
| The form container on the '''Financial Details''' tab item of the [HelpRoot_FormReference\AP_30_10_00|Bills and Adjustments] ([~/?ScreenId=AP301000|AP301000]) form
|- 
| <tt>PXGrid</tt>
|  ''Attributes''
| Is used to display a simple grid without a toolbar. The grid contains a predefined set of rows, which can be edited.
| The '''Attributes''' grid on the Attributes tab item of the [HelpRoot_FormReference\IN_20_20_00|Non-Stock Items] ([~/?ScreenId=IN202000|IN202000]) form
|- 
| 
| ''Details''
| Is used to render a detail grid in a master-detail data entry page. The grid has a toolbar that holds the default actions, such as '''Refresh''', '''Add''', '''Remove''', '''Fit to Screen''', and '''Export to Excel'''; it can also hold custom actions. The grid has no caption and paging is allowed.
| The grid on the '''1099 Settings''' tab item of the [HelpRoot_FormReference\AP_10_10_00|Accounts Payable Preferences] ([~/?ScreenId=AP101000|AP101000]) form
|- 
| 
| ''Inquire''
| Is used to display data without rows being added or removed. The grid has a toolbar that contains the '''Refresh''', '''Fit to Screen''', and '''Export to Excel''' default actions and can contain custom actions. The grid has no caption, and paging is allowed.
| The grid on the '''Attributes''' tab item of the [HelpRoot_FormReference\AR_30_30_00|Customers] ([~/?ScreenId=AR303000|AR303000]) form
|- 
| 
| ''Primary''
| Is used to display an editable primary grid that does not contain its own toolbar. To work with the grid, the user applies the action buttons of the form toolbar. The grid has no caption, and paging is allowed.
| The grid on the [HelpRoot_FormReference\CA_20_30_00|Entry Types] ([~/?ScreenId=CA203000|CA203000]) form
|- 
| 
| ''PrimaryInquire''
| Is used to display a primary grid without the availability to edit data. The grid does not contain its own toolbar. To work with the grid, the user applies the action buttons of the form toolbar, which does not contain the '''Add''', '''Delete''', and '''Switch Between Grid and Form''' buttons. The grid has no caption, and paging and filtering are allowed.
| The grid on the [HelpRoot_FormReference\AP_50_10_00|Release AP Documents] ([~/?ScreenId=AP501000|AP501000]) form
|- 
| 
| ''ShortList''
| Is used to display a small grid with a few records inside a form view. The grid has a toolbar that contains the '''Refresh''', '''Add''', and '''Remove''' default actions.
| The '''Sales Categories''' grid on the Attributes tab item of the [HelpRoot_FormReference\IN_20_20_00|Non-Stock Items] ([~/?ScreenId=IN202000|IN202000]) form
|- 
| <tt>PXPanel</tt>
|  ''Buttons''
| Is used in dialog boxes to display a horizontal row of buttons with right alignment.
| The group of buttons in the '''Add PO Receipt''' dialog box, which opens if you click the '''Add PO Receipt''' button in the toolbar of the '''Document Details''' tab item of the [HelpRoot_FormReference\AP_30_10_00|Bills and Adjustments] ([~/?ScreenId=AP301000|AP301000]) form
|- 
| 
| ''Transparent''
| Is used to group controls in a form container. The panel has no caption.
| The group of controls on the '''Template Settings''' tab item of the [HelpRoot_FormReference\SO_20_10_00|Order Types] ([~/?ScreenId=SO201000|SO201000]) form
|}]]></column>
			<column name="PlainText"><![CDATA[Use of the SkinID Property of Containers In the code of  Acumatica ERP,     predefined skins are used to assign a style and a set of toolbar buttons to a container. The       SkinID  property of a container specifies which of these skins the system     should apply to the container. A skin is specific to a particular container; you cannot share a     skin setting between containers of different types. If you do not set the       SkinID  property, the container uses the default skin, if one is defined. Predefined Skins The following table lists and describes the predefined skins that are recommended to use for     the  PXFormView ,  PXGrid , and  PXPanel      containers. UI Element SkinID Description Example PXFormView Transparent Is used to display a simple form container that has no caption and cannot be         collapsed. The form container on the  Financial Details  tab item of the            ([~/?ScreenId=AP301000|AP301000]) Bills and Adjustments (AP301000) form PXGrid Attributes Is used to display a simple grid without a toolbar. The grid contains a predefined set         of rows, which can be edited. The  Attributes  grid on the Attributes tab item of the   ([~/?ScreenId=IN202000|IN202000]) Non-Stock Items (IN202000) form Details Is used to render a detail grid in a master-detail data entry page. The grid has a         toolbar that holds the default actions, such as  Refresh ,           Add ,  Remove ,  Fit to          Screen , and  Export to Excel ; it can also hold custom         actions. The grid has no caption and paging is allowed. The grid on the  1099 Settings  tab item of the   ([~/?ScreenId=AP101000|AP101000]) Accounts Payable Preferences (AP101000) form Inquire Is used to display data without rows being added or removed. The grid has a toolbar         that contains the  Refresh ,  Fit to Screen , and           Export to Excel  default actions and can contain custom actions. The         grid has no         caption ,          and paging is allowed. The grid on the  Attributes  tab item of the   ([~/?ScreenId=AR303000|AR303000]) Customers (AR303000) form Primary Is used to display an editable primary grid that does not contain its own toolbar. To         work with the grid, the user applies the action buttons of the form toolbar. The grid has no         caption ,          and paging is allowed. The grid on the   ([~/?ScreenId=CA203000|CA203000]) Entry Types (CA203000) form PrimaryInquire Is used to display a primary grid without the availability to edit data. The grid does         not contain its own toolbar. To work with the grid, the user applies the action buttons of         the form toolbar, which does not contain the  Add ,           Delete , and  Switch Between Grid and Form          buttons. The grid has no         caption ,          and paging and filtering are allowed. The grid on the   ([~/?ScreenId=AP501000|AP501000]) Release AP Documents (AP501000) form ShortList Is used to display a small grid with a few records inside a form view. The grid has a         toolbar that contains the  Refresh ,  Add , and           Remove  default actions. The  Sales Categories  grid on the Attributes tab item of the            ([~/?ScreenId=IN202000|IN202000]) Non-Stock Items (IN202000) form PXPanel Buttons Is used in dialog boxes to display a horizontal row of buttons with right         alignment. The group of buttons in the  Add PO Receipt  dialog box, which         opens if you click the  Add PO Receipt  button in the toolbar of the           Document Details  tab item of the   ([~/?ScreenId=AP301000|AP301000]) Bills and Adjustments (AP301000) form Transparent Is used to group controls in a form container. The panel has no caption. The group of controls on the  Template Settings  tab item of the            ([~/?ScreenId=SO201000|SO201000]) Order Types (SO201000) form ]]></column>
		</row>
		<row PageID="16edab7b-9ec3-4383-a92d-253fe8eee07d" Language="en-US" PageRevisionID="1" Content="&#xA;If you plan to use a container in the mobile site map, we recommend that you specify a unique name for the &lt;tt&gt;Caption&lt;/tt&gt; property of the container. Then in the mobile site map, you can refer to the container by the specified caption in the &lt;tt&gt;Name&lt;/tt&gt; attribute of the &lt;tt&gt;&amp;lt;sm:Container&amp;gt;&lt;/tt&gt; tag, as the following code shows.{{{{&amp;lt;sm:Container Name=&quot;ValueOfTheCaptionProperty&quot;&amp;gt;&#xA;...&#xA;&amp;lt;/sm:Container&amp;gt;&#xA;}}}}{br}&#xA;&#xA;Otherwise, in the WSDL schema, the API web service assigns to the container the name of the first child element. If you use this name in the mobile site map, an error may occur after the container content is reordered because the container name might be changed in the WSDL schema." PlainText="Use of the Caption Property of Containers If you plan to use a container in the mobile site map, we recommend that you specify a unique       name for the  Caption  property of the container. Then in the mobile site       map, you can refer to the container by the specified caption in the  Name        attribute of the  &lt;sm:Container&gt;  tag, as the following code       shows. &lt;sm:Container Name=&quot;ValueOfTheCaptionProperty&quot;&gt;&#xA;...&#xA;&lt;/sm:Container&gt; Otherwise, in the WSDL schema, the API web service assigns to the container the name of the             first child element. If you use this name in the mobile site map, an error may occur             after the container content is reordered because the container name might be changed in             the WSDL schema. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="65b7334b-b545-e9e6-ac2e-a48af037f4f7" RecordSourceID="22377" />
		<row PageID="837c9078-dcd9-48f4-bb8b-d3a1fec7fb82" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="98a315b3-e3b4-ff35-4a04-d3395f88e918" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The Acumatica Customization           Platform supports the use of multiple data views for controls in the same container of an ASPX page.{br}

For example, you can create a container and set the <tt>DataMember</tt> property to the name of the data view that provides most of the fields for boxes in the container. If you also want to create a control for a data field that cannot be accessible through that data view but can be accessible through another data view of the same graph specified in the <tt>TypeName</tt> property of the <tt>PXDataSource</tt> control, you can specify the required data view immediately in the <tt>DataField</tt> property, as follows.{{{{&lt;px:PXField ... DataField="DataViewName.FieldName" /&gt;
}}}}{br}

The following code snippet shows how to use the {{MyDataView}}, {{AnotherDataView}}, and {{OnceMoreDataView}} data views declared in the same graph or in extensions for the graph to define boxes for data fields in a <tt>PXFormView</tt> container on an Acumatica ERP form.{{{{&lt;px:PXFormView ... DataMember="MyDataView" ...&gt;
  ...
    &lt;px:PXNumberEdit ... DataField="MyField_01" /&gt;
    &lt;px:PXSegmentMask ... DataField="MyField_02" /&gt;
    &lt;px:PXDateTimeEdit ... DataField="AnotherDataView.FieldName" /&gt;
    &lt;px:PXTextEdit ... DataField="MyField_05" /&gt;
    &lt;px:PXSelector ... DataField="OnceMoreDataView.OtherFieldName" /&gt;
  ...
&lt;/px:PXFormView&gt;

}}}}]]></column>
			<column name="PlainText"><![CDATA[Use of Multiple Data Views for Boxes in Containers The  Acumatica Customization           Platform supports the use of multiple data views for controls in the same container of an ASPX    page. For example, you can create a container and set the  DataMember  property to       the name of the data view that provides most of the fields for boxes in the container. If you       also want to create a control for a data field that cannot be accessible through that data       view but can be accessible through another data view of the same graph specified in the          TypeName  property of the  PXDataSource  control, you can       specify the required data view immediately in the  DataField  property, as       follows. <px:PXField ... DataField="DataViewName.FieldName" /> The following code snippet shows how to use the  MyDataView ,          AnotherDataView , and  OnceMoreDataView  data views declared       in the same graph or in extensions for the graph to define boxes for data fields in a          PXFormView  container on an  Acumatica ERP       form. <px:PXFormView ... DataMember="MyDataView" ...>
  ...
    <px:PXNumberEdit ... DataField="MyField_01" />
    <px:PXSegmentMask ... DataField="MyField_02" />
    <px:PXDateTimeEdit ... DataField="AnotherDataView.FieldName" />
    <px:PXTextEdit ... DataField="MyField_05" />
    <px:PXSelector ... DataField="OnceMoreDataView.OtherFieldName" />
  ...
</px:PXFormView>
 ]]></column>
		</row>
		<row PageID="32679a53-e50a-4321-929c-6596712fb754" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can learn how to configure tables (grids) on webpages by using the &lt;tt&gt;PXGrid&lt;/tt&gt; and &lt;tt&gt;PXGridColumn&lt;/tt&gt; ASPX objects.&#xA;==In This Chapter==[anchor|#_7eb9c2b3-f022-4732-bcb3-637d81ba78ac]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXForm_Properties_SyncPosition|Use of the SyncPosition Property of PXGrid]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXGrid_AddColumn_DistplayModeProperty|Use of the DisplayMode Property of PXGridColumn]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXGrid_AddColumn_TypeProperty|Use of the Type Property of PXGridColumn]&#xA;" PlainText="Configuring Tables In this chapter, you can learn how to configure tables (grids) on webpages by using the       PXGrid  and  PXGridColumn  ASPX objects. In This Chapter Use of the SyncPosition Property of PXGridUse of the DisplayMode Property of PXGridColumnUse of the Type Property of PXGridColumn" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ca8a9c73-57ed-efc6-db0c-31418124199f" RecordSourceID="22377" />
		<row PageID="a0f8f9e9-7997-4325-bc69-b58039dd3699" Language="en-US" PageRevisionID="1" Content="&#xA;If a form contains a grid and the form toolbar includes an action to process a single record that is highlighted in the grid, the action delegate method must have a reference to the highlighted record in the cache.{br}&#xA;&#xA;To use the &lt;tt&gt;Current&lt;/tt&gt; property of a &lt;tt&gt;PXCache&lt;/tt&gt; object to access the record highlighted in a grid, the &lt;tt&gt;Current&lt;/tt&gt; property must be synchronized with record highlighting in the grid. To force the system to provide this synchronization, you have to set the &lt;tt&gt;SyncPosition&lt;/tt&gt; property of the &lt;tt&gt;PXGrid&lt;/tt&gt; container to ''True''.((({S:Hint}If you need to make an action button on the toolbar unavailable, when a grid is empty, you should set the &lt;tt&gt;DependOnGrid&lt;/tt&gt; property of the appropriate &lt;tt&gt;PXDSCallbackCommand&lt;/tt&gt; object in the &lt;tt&gt;PXDataSource&lt;/tt&gt; control to the value that is specified in the &lt;tt&gt;ID&lt;/tt&gt; property of the &lt;tt&gt;PXGrid&lt;/tt&gt; element.&#xA;)))" PlainText="Use of the SyncPosition Property of PXGrid If a form contains a grid and the form toolbar includes an action to process a single record    that is highlighted in the grid, the action delegate method must have a reference to the    highlighted record in the cache. To use the  Current  property of a  PXCache  object to access    the record highlighted in a grid, the  Current  property must be synchronized    with record highlighting in the grid. To force the system to provide this synchronization, you    have to set the  SyncPosition  property of the  PXGrid     container to  True . If you need to make an action button on the toolbar unavailable,     when a grid is empty, you should set the  DependOnGrid  property of the     appropriate  PXDSCallbackCommand  object in the  PXDataSource      control to the value that is specified in the  ID  property of the       PXGrid  element. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2e2cf4ab-8468-9c1b-06b9-02542c079c3a" RecordSourceID="22377" />
		<row PageID="e375e4ed-73e6-47bc-a8e2-7366bc6eaf5d" Language="en-US" PageRevisionID="1" Content="&#xA;The Acumatica Customization           Platform supports the following values for the &lt;tt&gt;DisplayMode&lt;/tt&gt; property of a column in a grid.[anchor|#_764ddf1c-4806-42f6-9880-8b6d22ace0f6]&#xA;{| class=&quot;checklist&quot; | width=&quot;100%&quot; &#xA;|- &#xA;!width=&quot;20%&quot; ! Value&#xA;!width=&quot;80%&quot; ! Description&#xA;|- &#xA;| ''Value''&#xA;| Default value. An indicator that the column cell contains the value of the field.&#xA;|- &#xA;| ''Text''&#xA;| If there is a description defined for the field, an indicator that the column cell contains the description of the field.&#xA;|- &#xA;| ''Hint''&#xA;| If there is a description defined for the field, an indicator that the column cell contains both the value and the description of the field.&#xA;|}((({S:Hint}The priority of the &lt;tt&gt;Type&lt;/tt&gt; property is higher than the priority of the &lt;tt&gt;DisplayMode&lt;/tt&gt; property. If the &lt;tt&gt;Type&lt;/tt&gt; property is set, for example, to ''CheckBox'', the &lt;tt&gt;DisplayMode&lt;/tt&gt; property is ignored.&#xA;)))" PlainText="Use of the DisplayMode Property of PXGridColumn The  Acumatica Customization           Platform supports the following values for the  DisplayMode  property of a column       in a grid. Value Description Value Default value. An indicator that the column cell contains the value of the                 field. Text If there is a description defined for the field, an indicator that the column                 cell contains the description of the field. Hint If there is a description defined for the field, an indicator that the column                 cell contains both the value and the description of the field. The priority of the  Type  property is higher than the priority         of the  DisplayMode  property. If the  Type  property is         set, for example, to  CheckBox , the  DisplayMode  property is         ignored. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="528137e5-cecd-7d17-b5e8-6a7712b1dbe3" RecordSourceID="22377" />
		<row PageID="01146ab8-cc7a-4142-a626-95fbb3de4b50" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="931f5a51-26d6-b13d-e0d8-8479ae56ec35" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The Acumatica Customization           Platform supports the following values for the <tt>Type</tt> property of a column in a grid.[anchor|#_764ddf1c-4806-42f6-9880-8b6d22ace0f6]
{| class="checklist" | width="100%" 
|- 
!width="20%" ! Value
!width="80%" ! Description
|- 
| ''NotSet''
| The default value. An indicator that the field value is displayed in the column as a plain string that is formed based on the field data format.
|- 
| ''CheckBox''
| An indicator that the field value is displayed in the column as a check box, which is selected if the field value is ''True''.
|- 
| ''HyperLink''
| An indicator that the field value is displayed in the column as a hyperlink.
|- 
| ''DropDownList''
| An indicator that the column cell is rendered as a drop-down list that contains all the values specified for the referred data field.
|- 
| ''Icon''
| An indicator that the field value contains an image URL and is displayed in the column as the referred image.
|}
==Example==
The following code fragment defines the grid columns on the [HelpRoot_FormReference\SM_20_50_30|Automation Schedule Statuses] ([~/?ScreenId=SM205030|SM205030]) form.{{{{...
&lt;px:PXGridColumn AllowUpdate="False" DataField="LastRunStatus" Width="40px"
  Type="Icon" TextAlign="Center" /&gt;
&lt;px:PXGridColumn DataField="ScreenID" DisplayFormat="CC.CC.CC.CC" 
  Label="Screen ID" LinkCommand="AUScheduleExt_View" /&gt;
&lt;px:PXGridColumn DataField="Description" Label="Description" Width="200px" /&gt;
&lt;px:PXGridColumn AllowNull="False" DataField="IsActive" Label="Active" 
  TextAlign="Center" Type="CheckBox" Width="60px" /&gt;
...
}}}}In the code, the <tt>Type</tt> property for the ''LastRunStatus'' data field (which corresponds to the '''Status''' column shown in the screenshot below) is set to ''Icon''. Because the field value contains the image URL, the column cell displays the referred image.{br}

For the ''IsActive'' data field (which corresponds to the '''Active''' column), the <tt>Type</tt> property is set to ''CheckBox''. As you can see in the screenshot, the column cells are rendered as check boxes.[anchor|#_c633a483-2c8c-4e2b-b10a-5e959dc57fb6][anchor|#_1003b596-db56-44ae-8f45-84a5e7e3b028][image:StudioDeveloperGuide/Images/CG_GL_UI_PXGrid_AddColumn_TypeProperty.png|popup|Viewing different types of columns on the Automation Schedules form|302px]]]></column>
			<column name="PlainText"><![CDATA[Use of the Type Property of PXGridColumn The  Acumatica Customization           Platform supports the following values for the  Type  property of a column in a           grid. Value Description NotSet The default value. An indicator that the field value is displayed in the                   column as a plain string that is formed based on the field data format. CheckBox An indicator that the field value is displayed in the column as a check box,                   which is selected if the field value is  True . HyperLink An indicator that the field value is displayed in the column as a                   hyperlink. DropDownList An indicator that the column cell is rendered as a drop-down list that                   contains all the values specified for the referred data field. Icon An indicator that the field value contains an image URL and is displayed in                   the column as the referred image. Example The following code fragment defines the grid columns on the   ([~/?ScreenId=SM205030|SM205030]) Automation Schedule Statuses (SM205030)         form. ...
<px:PXGridColumn AllowUpdate="False" DataField="LastRunStatus" Width="40px"
  Type="Icon" TextAlign="Center" />
<px:PXGridColumn DataField="ScreenID" DisplayFormat="CC.CC.CC.CC" 
  Label="Screen ID" LinkCommand="AUScheduleExt_View" />
<px:PXGridColumn DataField="Description" Label="Description" Width="200px" />
<px:PXGridColumn AllowNull="False" DataField="IsActive" Label="Active" 
  TextAlign="Center" Type="CheckBox" Width="60px" />
... In         the code, the  Type  property for the  LastRunStatus  data field         (which corresponds to the  Status  column shown in the screenshot         below) is set to  Icon . Because the field value contains the image URL, the column         cell displays the referred image. For the  IsActive  data field (which corresponds to the  Active          column), the  Type  property is set to  CheckBox . As you can see in         the screenshot, the column cells are rendered as check boxes. Viewing different types of columns on the Automation Schedules form ]]></column>
		</row>
		<row PageID="dc9be8ff-f4bc-4975-9ca9-ff6a2c2d0fed" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can learn how to configure tables on webpages by using the &lt;tt&gt;PXTab&lt;/tt&gt; and &lt;tt&gt;PXTabItem&lt;/tt&gt; ASPX objects.&#xA;==In This Chapter==[anchor|#_15ae7396-cbff-48b7-9588-52da7bae2bb7]&#xA;*[HelpRoot_Dev_Platform\CW__con_PXTabItem_Properties_VisibleExp|Conditional Hiding of a Tab Item]&#xA;" PlainText="Configuring Tabs In this chapter, you can learn how to configure tables on webpages by using the       PXTab  and  PXTabItem  ASPX objects. In This Chapter Conditional Hiding of a Tab Item" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="b4049d3f-b90f-9db7-12c3-fe89b159f75e" RecordSourceID="22377" />
		<row PageID="5e6701bc-1107-42f8-b9c6-9c5a586bc6ab" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2b596f1a-8aab-80f3-a6a4-0d2594a64d45" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use the <tt>Visible</tt> property of the <tt>PXTabItem</tt> element to set the visibility of the tab item. However, if you need to set the dependency of a tab item&rsquo;s visibility from a condition, you should use the <tt>VisibleExp</tt> and <tt>BindingContext</tt> properties of the <tt>PXTabItem</tt> element.
==VisibleExp Property==
The <tt>VisibleExp</tt> property contains a condition expression that defines a <tt>Boolean</tt> value used to set the visibility of the tab item. The expression must consist of two parts and an operator to compare these parts. The expression can contain the values of controls that belong to the container specified in the <tt>BindingContext</tt> property.
==BindingContext Property==
The <tt>BindingContext</tt> property defines the ID of the container of the controls whose values can be used in the expression of the <tt>VisibleExp</tt> property.
==Example==
As an example of the conditional hiding of a tab item, on a form with form and tab containers, if you need to set the visibility of a tab item to depend on a check box of the form container, you can define the <tt>VisibleExp</tt> and <tt>BindingContext</tt> properties of the <tt>PXTabItem</tt> element, as illustrated in the following ASPX code snippet.{br}

{{{{&lt;px:PXFormView ID="form" ...&gt;
...
  px:PXCheckBox ... ID="myControlID" ... /&gt;
...
&lt;/px:PXFormView&gt;
...
&lt;px:PXTab ...&gt;
...
  &lt;px:PXTabItem ... BindingContext="form" ...
    VisibleExp="DataControls[&quot;myControlID&quot;].Value == true"&gt;
...
&lt;/px:PXTab&gt;
}}}}In the code above, the expression uses the <tt>DataControls</tt> .NET property of the {{form}} object as a dictionary to find the needed control by the specified ID.]]></column>
			<column name="PlainText"><![CDATA[Conditional Hiding of a Tab Item You can use the  Visible  property of the  PXTabItem          element to set the visibility of the tab item. However, if you need to set the dependency of         a tab item's visibility from a condition, you should use the  VisibleExp          and  BindingContext  properties of the  PXTabItem          element. VisibleExp Property The  VisibleExp  property contains a condition expression that defines a            Boolean  value used to set the visibility of the tab item. The         expression must consist of two parts and an operator to compare these parts. The expression         can contain the values of controls that belong to the container specified in the            BindingContext  property. BindingContext Property The  BindingContext  property defines the ID of the container of the         controls whose values can be used in the expression of the  VisibleExp          property. Example As an example of the conditional hiding of a tab item, on a form with form and tab         containers, if you need to set the visibility of a tab item to depend on a check box of the         form container, you can define the  VisibleExp  and            BindingContext  properties of the  PXTabItem  element,         as illustrated in the following ASPX code snippet. <px:PXFormView ID="form" ...>
...
  px:PXCheckBox ... ID="myControlID" ... />
...
</px:PXFormView>
...
<px:PXTab ...>
...
  <px:PXTabItem ... BindingContext="form" ...
    VisibleExp="DataControls[&quot;myControlID&quot;].Value == true">
...
</px:PXTab> In         the code above, the expression uses the  DataControls  .NET property of the            form  object as a dictionary to find the needed control by the specified         ID. ]]></column>
		</row>
		<row PageID="0219b2be-e34c-4b99-ad34-a03653f4d0ab" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can find information about the configuration of different types of boxes, such as &lt;tt&gt;PXTextEdit&lt;/tt&gt;, &lt;tt&gt;PXCheckBox&lt;/tt&gt;, and &lt;tt&gt;PXGroupBox&lt;/tt&gt;.&#xA;==In This Chapter==[anchor|#_6f8b7b09-fe62-4dcb-8886-fd6628033c83]&#xA;*[HelpRoot_Dev_Platform\CW__con_CommitChanges|Use of the CommitChanges Property of Boxes]&#xA;*[HelpRoot_Dev_Platform\CW__con_GroupBoxes_Property_DataField|Use of the DataField Property of PXGroupBox]&#xA;*[HelpRoot_Dev_Platform\CW__con_GroupBoxes_Property_Caption|Use of the Caption Property of PXGroupBox]&#xA;*[HelpRoot_Dev_Platform\CW__con_GroupBoxes_Property_RenderStyle|Use of the RenderStyle Property of PXGroupBox]&#xA;" PlainText="Configuring Boxes In this chapter, you can find information about the configuration of different types of boxes,     such as  PXTextEdit ,  PXCheckBox , and       PXGroupBox . In This Chapter Use of the CommitChanges Property of BoxesUse of the DataField Property of PXGroupBoxUse of the Caption Property of PXGroupBoxUse of the RenderStyle Property of PXGroupBox" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="309dbe59-7ef7-57b6-76f7-86e6ea15a579" RecordSourceID="22377" />
		<row PageID="596c3620-e3d5-4d2f-9c19-3b65486a2761" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8a4e9c84-4876-2ba1-7f85-92d2ec7b13f5" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you need to process the value in a box every time the user changes this value, you need to set the <tt>CommitChanges</tt> property of the box to ''True'' to enable callbacks for the box.{br}

If callback is enabled for a box in a container on a page, the user has changed the box value, and focus is no longer on the box on the page, the container immediately collects all the modified data and a callback is created to pass the data to the <tt>PXDataSource</tt> control of the page (see the diagram below). {br}

The <tt>PXDataSource</tt> control creates a remote procedure call to the application server to execute the ''Update'' operation with the modified data on the data view that is specified as the <tt>DataMember</tt> property for the container. The data view executes the sequence of events for update of a data record (for details, see [HelpRoot_Dev_Platform\BL__con_Events_Update|Sequence of Events: Update of a Data Record]) on the data in the cache object of the business logic controller. The cache object raises the events that you can handle to process the modified data.[anchor|#_5151b1ac-8079-4f3d-b813-4994db87e50c][anchor|#_fa391871-4272-4618-a7d1-ec1ca6ce30fb][image:StudioDeveloperGuide/Images/CG_GL_UI_Box_Properties_CommitChanges.png|popup|Usage of the CommitChanges property to process a modified data|450px]]]></column>
			<column name="PlainText"><![CDATA[Use of the CommitChanges Property of Boxes If you need to process the value in a box every time the user changes this value, you need to    set the  CommitChanges  property of the box to  True  to enable callbacks    for the box. If callback is enabled for a box in a container on a page, the user has changed the box value,    and focus is no longer on the box on the page, the container immediately collects all the    modified data and a callback is created to pass the data to the  PXDataSource     control of the page (see the diagram below).  The  PXDataSource  control creates a remote procedure call to the application    server to execute the  Update  operation with the modified data on the data view that is    specified as the  DataMember  property for the container. The data view executes    the sequence of events for update of a data record (for details, see  Sequence of Events: Update of a Data Record) on the data in the cache object of    the business logic controller. The cache object raises the events that you can handle to process    the modified data. Usage of the CommitChanges property to process a modified data ]]></column>
		</row>
		<row PageID="b3d384a1-ada5-4ff1-bf21-ec19eb903f90" Language="en-US" PageRevisionID="1" Content="&#xA;You use a group box to display a data field with a list attribute as a set of radio buttons, where one radio button is used to display and select each single constant value of the field. To bind a group box to a data field, you have to specify the name of the data field in the &lt;tt&gt;DataField&lt;/tt&gt; property of the &lt;tt&gt;PXGroupBox&lt;/tt&gt; element in the ASPX code, as follows.{{{{&amp;lt;px:PXGroupBox ... DataField=&quot;&amp;lt;Field Name&amp;gt;&quot; ...&amp;gt;&#xA;}}}}((({S:Warn}The group box must contain a radio button for each value defined in the list of the field.&#xA;))){br}&#xA;&#xA;In the &lt;tt&gt;DataField&lt;/tt&gt; property of the &lt;tt&gt;PXGroupBox&lt;/tt&gt; element, you can specify the name of a data field that is accessible through another data view of the same graph. See [HelpRoot_Dev_Platform\CW__con_PXForm_AddBox_DataViews|Use of Multiple Data Views for Boxes in Containers] for details." PlainText="Use of the DataField Property of PXGroupBox You use a group box to display a data field with a list attribute as a set of radio buttons,             where one radio button is used to display and select each single constant value of the             field. To bind a group box to a data field, you have to specify the name of the data             field in the  DataField  property of the  PXGroupBox              element in the ASPX code, as                 follows. &lt;px:PXGroupBox ... DataField=&quot;&lt;Field Name&gt;&quot; ...&gt; The group box must contain a radio button for each value defined in                 the list of the field. In the  DataField  property of the  PXGroupBox  element, you             can specify the name of a data field that is accessible through another data view of the             same graph. See  Use of Multiple Data Views for Boxes in Containers for details. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="63f3b0e9-3775-772a-63fe-da0162f5ec64" RecordSourceID="22377" />
		<row PageID="1a889473-d65d-41a8-aaaa-f58cee7cf133" Language="en-US" PageRevisionID="1" Content="&#xA;You can define a caption for a group box by using the &lt;tt&gt;Caption&lt;/tt&gt; property of the &lt;tt&gt;PXGroupBox&lt;/tt&gt; element in the ASPX code as follows.{{{{&amp;lt;px:PXGroupBox ... Caption=&quot;Example of Group Box Caption&quot; ...&amp;gt;&#xA;}}}}{br}&#xA;&#xA;If the &lt;tt&gt;RenderStyle&lt;/tt&gt; property of a &lt;tt&gt;PXGroupBox&lt;/tt&gt; element is set to ''Simple'', the &lt;tt&gt;Caption&lt;/tt&gt; property is ignored. See [HelpRoot_Dev_Platform\CW__con_GroupBoxes_Property_RenderStyle|Use of the RenderStyle Property of PXGroupBox] for details." PlainText="Use of the Caption Property of PXGroupBox You can define a caption for a group box by using the  Caption  property of    the  PXGroupBox  element in the ASPX code as    follows. &lt;px:PXGroupBox ... Caption=&quot;Example of Group Box Caption&quot; ...&gt; If the  RenderStyle  property of a  PXGroupBox  element is    set to  Simple , the  Caption  property is ignored. See  Use of the RenderStyle Property of PXGroupBox for details. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="7d3e8185-a5f7-690d-148a-16e877210e70" RecordSourceID="22377" />
		<row PageID="a06a9841-555c-4622-963d-642f096b8ca3" Language="en-US" PageRevisionID="1" PlainText="Use of the RenderStyle Property of PXGroupBox To define the style of a group box on the form, you have to select a value of the      RenderStyle  property of the  PXGroupBox  element in the ASPX    code, as follows. &lt;px:PXGroupBox ... RenderStyle=&quot;StyleName&quot; ...&gt; The  Acumatica Framework supports the following  RenderStyle  values for the      PXGroupBox  element. Name Description Example Fieldset Indicates that the group of radio buttons can be displayed with a caption in the same         style as in a grouping layout rule. RoundBorder The default value. Indicates that the group of radio buttons can be displayed with a         caption in a rounded border. Simple Indicates that the group of radio buttons can be displayed without a caption and         border. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="1871dc6a-2bfb-1f0f-5c48-4d8e0d6806ed" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To define the style of a group box on the form, you have to select a value of the <tt>RenderStyle</tt> property of the <tt>PXGroupBox</tt> element in the ASPX code, as follows.{{{{&lt;px:PXGroupBox ... RenderStyle="StyleName" ...&gt;
}}}}{br}

The Acumatica Framework supports the following <tt>RenderStyle</tt> values for the <tt>PXGroupBox</tt> element.[anchor|#_8fd8ef67-9b72-4ae3-947e-3269f46a149b]
{| class="checklist" | width="100%" 
|- 
!width="20%" ! Name
!width="40%" ! Description
!width="40%" ! Example
|- 
| <tt>Fieldset</tt>
| Indicates that the group of radio buttons can be displayed with a caption in the same style as in a grouping layout rule.
| [anchor|#_58fa9f73-47d5-4e0d-a7bf-53b3e677528f][image:StudioDeveloperGuide/Images/CG_GL_UI_GroupBoxes_Property_RenderStyle_Fieldset.png|200px]
|- 
| <tt>RoundBorder</tt>
| The default value. Indicates that the group of radio buttons can be displayed with a caption in a rounded border.
| [anchor|#_81bb5591-6351-404d-aac5-cca2322dc996][image:StudioDeveloperGuide/Images/CG_GL_UI_GroupBoxes_Property_RenderStyle_RoundBorder.png|200px]
|- 
| <tt>Simple</tt>
| Indicates that the group of radio buttons can be displayed without a caption and border.
| [anchor|#_c34b2ffa-6073-48d1-8fd1-25654fe9b14e][image:StudioDeveloperGuide/Images/CG_GL_UI_GroupBoxes_Property_RenderStyle_Simple.png|200px]
|}]]></column>
		</row>
		<row PageID="655b9a92-b944-4863-b392-42a26c79f2eb" Language="en-US" PageRevisionID="1" PlainText="Configuring Layout and Size In this chapter, you can learn how to configure the layout of webpages by using the       PXLayoutRule  ASPX object and how to configure the size of ASPX controls. In This Chapter Predefined Size ValuesUse of the StartRow and StartColumn Properties of PXLayoutRuleUse of the ColumnWidth, ControlSize, and LabelsWidth Properties of PXLayoutRuleUse of the ColumnSpan Property of PXLayoutRuleUse of the Merge Property of PXLayoutRuleUse of the GroupCaption, StartGroup, and EndGroup Properties of PXLayoutRuleUse of the SuppressLabel Property of PXLayoutRule" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2f4a0eb5-b3ea-fdd3-063e-3b1a1b466a45" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this chapter, you can learn how to configure the layout of webpages by using the <tt>PXLayoutRule</tt> ASPX object and how to configure the size of ASPX controls.
==In This Chapter==[anchor|#_44293be8-0b35-4a38-ba7c-fdf6649e8156]
*[HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_Predefined|Predefined Size Values]
*[HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_StartRowColumn|Use of the StartRow and StartColumn Properties of PXLayoutRule]
*[HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_Sizes|Use of the ColumnWidth, ControlSize, and LabelsWidth Properties of PXLayoutRule]
*[HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_ColumnSpan|Use of the ColumnSpan Property of PXLayoutRule]
*[HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_Merge|Use of the Merge Property of PXLayoutRule]
*[HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_Group|Use of the GroupCaption, StartGroup, and EndGroup Properties of PXLayoutRule]
*[HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_SuppressLabel|Use of the SuppressLabel Property of PXLayoutRule]
]]></column>
		</row>
		<row PageID="ffb4d55f-ef65-4aad-bc01-52bd3df47c6a" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="dc5f8b92-ff7d-07ef-782b-d0d4af734aeb" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use the predefined values described in the table below for the following properties:[anchor|#_607a3d93-ee90-4c69-ad7d-f4fea648221f]
*<tt>ColumnWidth</tt>, <tt>LabelsWidth</tt>, and <tt>ControlSize</tt> of the <tt>PXLayoutRule</tt> component
*<tt>LabelsWidth</tt> and <tt>Size</tt> of a control

==Predefined Values==
The following table shows the values in pixels that correspond to the predefined constants.[anchor|#_592a81dd-5379-4414-8726-f3b8118af34d]
{| class="checklist" | width="100%" 
|- 
!width="25%" ! Predefined Value
!width="25%" ! <tt>ColumnWidth</tt>
!width="50%" !  <tt>LabelsWidth</tt> and <tt>ControlSize</tt> of a Layout Rule; <tt>LabelsWidth</tt> and <tt>Size</tt> Properties of a Control
|- 
| ''XXS''
| 100px
| 40px
|- 
| ''XS''
| 150px
| 70px
|- 
| ''S''
| 200px
| 100px
|- 
| ''SM''
| -
| 150px
|- 
| ''M''
| 250px
| 200px
|- 
| ''XM''
| 300px
| 250px
|- 
| ''L''
| 350px
| 300px
|- 
| ''XL''
| 400px
| 350px
|- 
| ''XXL''
| 450px
| 400px
|}
==Setting of Predefined Values==
Note the following points about setting the predefined sizes of controls and their labels:[anchor|#ol_uzf_mrj_fm]
*For any property for which there are predefined values, you can specify a value in pixels, such as ''55px''. (This format is mandatory if you don&rsquo;t use abbreviations, because the property value can be defined only in pixels.)
*There is no predefined value for the <tt>Width</tt> property of a control. Therefore, you can specify a value for this property by typing any value in pixels, such as ''55px''. Before specifying the <tt>Width</tt> property value for a control, you must define the <tt>Size</tt> property value for the control as ''Empty''.
*:((({S:Hint}The <tt>Width</tt> property is declared in ASP.NET. The <tt>Size</tt> property is declared in Acumatica Framework, so you can use the predefined values.
)))
]]></column>
			<column name="PlainText"><![CDATA[Predefined Size Values You can use the predefined values described in the table below for the following      properties: ColumnWidth ,  LabelsWidth , and         ControlSize  of the  PXLayoutRule  component LabelsWidth  and  Size  of a control Predefined Values The following table shows the values in pixels that correspond to the predefined      constants. Predefined Value ColumnWidth LabelsWidth  and  ControlSize  of a Layout Rule;            LabelsWidth  and  Size  Properties of a Control XXS 100px 40px XS 150px 70px S 200px 100px SM - 150px M 250px 200px XM 300px 250px L 350px 300px XL 400px 350px XXL 450px 400px Setting of Predefined Values Note the following points about setting the predefined sizes of controls and their labels: For any property for which there are predefined values, you can specify a value in pixels,       such as  55px . (This format is mandatory if you don't use abbreviations, because the       property value can be defined only in pixels.) There is no predefined value for the  Width  property of a control.       Therefore, you can specify a value for this property by typing any value in pixels, such as         55px . Before specifying the  Width  property value for a control, you       must define the  Size  property value for the control as         Empty . The  Width  property is declared in ASP.NET. The          Size  property is declared in  Acumatica Framework,        so you can use the predefined values. ]]></column>
		</row>
		<row PageID="0edb26d6-414d-4bbb-8c30-ed1d2e65e0b8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="9f14626b-e61f-476f-bbbc-84b911ffc4ad" RecordSourceID="22377">
			<column name="Content"><![CDATA[In this topic, you can find information how to organize controls on a webpage into rows and columns.{br}{TOC}
==Default Layout==
By default, the system places all the controls of a container into a column within the first row, as shown in the diagram below. To do this, the system initially sets to ''True'' the <tt>StartRow</tt> property value for the uppermost <tt>PXLayoutRule</tt> component in a container.[anchor|#_118e5cc8-9e84-426d-8925-325991e03f29][anchor|#_995345b5-2bb6-4433-8fd0-d7cea97f0e86][image:StudioDeveloperGuide/Images/CG_GL_UI_LayoutRules_Properties_StartRowColumn.png|popup|The default layout of controls of a container on a form|450px]The controls continue to be placed within a single column until you add a layout rule with the <tt>StartColumn</tt> or <tt>Merge</tt> property value set to ''True''.((({S:Hint}For the proper layout, the <tt>StartRow</tt> property value must be set to ''True'' for the uppermost <tt>PXLayoutRule</tt> component of a container.
)))
==Splitting of Controls into Columns==
You can place controls in multiple columns within a row by adding <tt>PXLayoutRule</tt> components with the <tt>StartColumn</tt> property value set to ''True''. This property creates a new column of controls within the current layout row, as the following diagram shows.[anchor|#_5941e156-1d18-41eb-85b1-b7595a3eebca][anchor|#_deab242c-b488-4bda-9ae8-027f096186e4][image:StudioDeveloperGuide/Images/CG_GL_UI_LayoutRules_Properties_StartRowColumn_1.png|popup|Creation of a new column|450px]The first control under this rule is the highest control in the column.
==Splitting of Controls into Rows==
Every new <tt>PXLayoutRule</tt> component that has the <tt>StartRow</tt> property value set to ''True'' initializes a new independent placeholder of controls, which are placed in a single column by default. To place controls in multiple columns within the new row, you should include in the placeholder a new layout rule with the <tt>StartColumn</tt> property value set to ''True'', as shown in the following diagram.[anchor|#_4c1a047d-2c0e-4177-ab77-7545f981e9cd][anchor|#_6cfc9a15-5ce1-4c28-95d7-45a39b244842][image:StudioDeveloperGuide/Images/CG_GL_UI_LayoutRules_Properties_StartRowColumn_2.png|popup|Creation of a new row|450px]
==Sizes of Rows and Columns==
Because the values of the <tt>ColumnWidth</tt>, <tt>ControlSize</tt>, and <tt>LabelsWidth</tt> properties are never inherited from the previously declared <tt>PXLayoutRule</tt> component, you might need to define these properties exclusively for every new row and column.]]></column>
			<column name="PlainText"><![CDATA[Use of the StartRow and StartColumn Properties of PXLayoutRule In this topic, you can find information how to organize controls       on a webpage into rows and columns. Default Layout By default, the system places all the controls of a container into a column within the         first row, as shown in the diagram below. To do this, the system initially sets to            True  the  StartRow  property value for the uppermost            PXLayoutRule  component in a container. The default layout of controls of a container on a form The controls continue to be placed within a single column until you add a layout rule         with the  StartColumn  or  Merge  property value set to            True . For the proper layout, the  StartRow            property value must be set to  True  for the uppermost              PXLayoutRule  component of a container. Splitting of Controls into Columns You can place controls in multiple columns within a row by adding            PXLayoutRule  components with the  StartColumn          property value set to  True . This property creates a new column of controls within the         current layout row, as the following diagram shows. Creation of a new column The first control under this rule is the highest control in the column. Splitting of Controls into Rows Every new  PXLayoutRule  component that has the            StartRow  property value set to  True  initializes a new         independent placeholder of controls, which are placed in a single column by default. To         place controls in multiple columns within the new row, you should include in the placeholder         a new layout rule with the  StartColumn  property value set to  True ,         as shown in the following diagram. Creation of a new row Sizes of Rows and Columns Because the values of the  ColumnWidth ,  ControlSize ,         and  LabelsWidth  properties are never inherited from the previously         declared  PXLayoutRule  component, you might need to define these         properties exclusively for every new row and column. ]]></column>
		</row>
		<row PageID="40e018a5-16cc-4395-a59f-481b53a5254f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2bc8a37b-1653-0e3c-4ceb-af83a6e143fa" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use the <tt>PXLayoutRule</tt> components to define the sizes for every control (that is, its input area) and its label within a column, group, or merged set of controls. 
==Required Properties==
Every <tt>PXLayoutRule</tt> component that has the <tt>StartRow</tt> or <tt>StartColumn</tt> property value set to ''True'' must have one of the following sets of properties defined:[anchor|#ul_dv2_r4z_fm]
*<tt>LabelsWidth</tt> and <tt>ControlSize</tt>
* <tt>LabelsWidth</tt> and <tt>ColumnWidth</tt>
{br}

The following diagram illustrates the meaning of the <tt>LabelsWidth</tt>, <tt>ControlSize</tt>, and <tt>ColumnWidth</tt> properties.[anchor|#_2d810c1b-4b35-446a-8b17-780ace2f53d0][anchor|#_7fbd314e-ccbc-489c-9034-7a0a27cc7901][image:StudioDeveloperGuide/Images/CG_GL_Forms_ASPX_LayoutRule_ColumnWidth.png|popup|Use of the layout rule properties to define control sizes|332px]((({S:Hint}You should not set property values for both <tt>ColumnWidth</tt> and <tt>ControlSize</tt> for the same <tt>PXLayoutRule</tt> component; in this case, the system would use the value of the <tt>ControlSize</tt> property.
)))
==Setting of the Size==
Please note the following points about setting the sizes of controls and their labels:[anchor|#ol_uzf_mrj_fm]
*The values of the <tt>ColumnWidth</tt>, <tt>ControlSize</tt>, and <tt>LabelsWidth</tt> properties must be defined exclusively for every <tt>PXLayoutRule</tt> component; they are never inherited from the previously declared one.
*You can change the size of a single control or its label by defining values for the <tt>Size</tt>, <tt>Width</tt>, and <tt>LabelsWidth</tt> properties of the control. Property values that are set for a control have a higher priority than the property values of the <tt>PXLayoutRule</tt> component.
*You can assign a predefined size abbreviation (such as ''XXS'', ''L'', or ''XL'') for the <tt>ColumnWidth</tt>, <tt>LabelsWidth</tt>, and <tt>ControlSize</tt> properties of a layout rule and the <tt>LabelsWidth</tt> and <tt>Size</tt> properties of a control. (See [HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_Predefined|Predefined Size Values] for details.)
*The <tt>PXDateTimeEdit</tt> and <tt>PXNumberEdit</tt> control types have a predefined <tt>Width</tt> property value, which you cannot change by setting the <tt>ColumnWidth</tt> or <tt>ControlSize</tt> property values for the appropriate <tt>PXLayoutRule</tt> component. To change the width of this control, set a value for the <tt>Size</tt> or <tt>Width</tt> property of the control.
]]></column>
			<column name="PlainText"><![CDATA[Use of the ColumnWidth, ControlSize, and LabelsWidth Properties of PXLayoutRule You can use the  PXLayoutRule  components to define the sizes for every       control (that is, its input area) and its label within a column, group, or merged set of       controls.  Required Properties Every  PXLayoutRule  component that has the  StartRow  or            StartColumn  property value set to  True  must have one of the         following sets of properties defined: LabelsWidth  and  ControlSize LabelsWidth  and  ColumnWidth The following diagram illustrates the meaning of the  LabelsWidth ,            ControlSize , and  ColumnWidth  properties. Use of the layout rule properties to define control sizes You should not set property values for both  ColumnWidth  and              ControlSize  for the same  PXLayoutRule  component;           in this case, the system would use the value of the  ControlSize            property. Setting of the Size Please note the following points about setting the sizes of controls and their labels: The values of the  ColumnWidth ,  ControlSize , and                LabelsWidth  properties must be defined exclusively for every                PXLayoutRule  component; they are never inherited from the             previously declared one. You can change the size of a single control or its label by defining values for the                Size ,  Width , and  LabelsWidth              properties of the control. Property values that are set for a control have a higher             priority than the property values of the  PXLayoutRule  component. You can assign a predefined size abbreviation (such as  XXS ,  L , or                XL ) for the  ColumnWidth ,  LabelsWidth , and                ControlSize  properties of a layout rule and the                LabelsWidth  and  Size  properties of a control.             (See  Predefined Size Values for details.) The  PXDateTimeEdit  and  PXNumberEdit  control             types have a predefined  Width  property value, which you cannot change             by setting the  ColumnWidth  or  ControlSize  property             values for the appropriate  PXLayoutRule  component. To change the             width of this control, set a value for the  Size  or                Width  property of the control. ]]></column>
		</row>
		<row PageID="41c31abf-2297-4c31-b5c2-848b95f9288f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2425aaf4-c6dc-8742-7e05-0f2ddc10ac16" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You specify the <tt>ColumnSpan</tt> property value for a <tt>PXLayoutRule</tt> component by manually typing the number of columns spanned by the first control placed below the rule.
==Example==
As an example of the use of the <tt>ColumnSpan</tt> property, the form container on the [HelpRoot_FormReference\AR_30_30_00|Customers] ([~/?ScreenId=AR303000|AR303000]) form has three columns of boxes, and there is a layout rule with the <tt>ColumnSpan</tt> property set to ''2'' in the first column. This property forces the system to make the box span two columns, as shown in the following screenshot.[anchor|#_7c86fe22-cda4-4d9d-8d30-591fe6fcc11c][anchor|#_8789fcfb-b3f4-426a-b705-f31c8315accb][image:StudioDeveloperGuide/Images/CG_GL_UI_LayoutRules_Properties_ColumnSpan_02.png|popup|The box that spans two columns on the form|450px]
==Dependencies==
A <tt>PXLayoutRule</tt> component with the <tt>ColumnSpan</tt> property value specified is handled as follows:[anchor|#ul_wlc_hpz_fm]
*The <tt>LabelsWidth</tt> property value is always inherited from the previously declared <tt>PXLayoutRule</tt> component that has the <tt>StartRow</tt> or <tt>StartColumn</tt> property value set to ''True''.
*If a value for the <tt>ColumnWidth</tt> or <tt>ControlSize</tt> property is specified for the component, this value is ignored.
]]></column>
			<column name="PlainText"><![CDATA[Use of the ColumnSpan Property of PXLayoutRule You specify the  ColumnSpan  property value for a            PXLayoutRule  component by manually typing the number of columns spanned         by the first control placed below the rule. Example As an example of the use of the  ColumnSpan  property, the form container         on the   ([~/?ScreenId=AR303000|AR303000]) Customers (AR303000) form has three         columns of boxes, and there is a layout rule with the  ColumnSpan  property         set to  2  in the first column. This property forces the system to make the box span         two columns, as shown in the following screenshot. The box that spans two columns on the form Dependencies A  PXLayoutRule  component with the  ColumnSpan  property         value specified is handled as follows: The  LabelsWidth  property value is always inherited from the             previously declared  PXLayoutRule  component that has the                StartRow  or  StartColumn  property value set to                True . If a value for the  ColumnWidth  or  ControlSize              property is specified for the component, this value is ignored. ]]></column>
		</row>
		<row PageID="325b7979-f32d-40eb-920b-7880245e8a26" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f93b8996-0826-a855-2ecb-9c8e4fc671f1" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Merging means placing controls so that they are horizontally aligned. Horizontal alignment is performed for the controls that are placed between a layout rule with the <tt>Merge</tt> property set to ''True'' and any other subsequent layout rule. Therefore, to cancel merging for all of the following controls, you have to add a <tt>PXLayoutRule</tt> component with or without the <tt>Merge</tt> property specified.
==Example==
As an example of the use of the <tt>Merge</tt> property, the '''Billing Settings''' tab item on the [HelpRoot_FormReference\AR_30_30_00|Customers] ([~/?ScreenId=AR303000|AR303000]) form has three pairs of merged check boxes in the '''Print and Email Settings''' group. This property forces the system to render the boxes in one column, as shown in the following screenshot.[anchor|#_7c86fe22-cda4-4d9d-8d30-591fe6fcc11c][anchor|#_8789fcfb-b3f4-426a-b705-f31c8315accb][image:StudioDeveloperGuide/Images/CG_GL_UI_LayoutRules_Properties_Merge_02.png|popup|The boxes merged into a single column on the form|450px]
==Dependencies==
A <tt>PXLayoutRule</tt> component with the <tt>Merge</tt> property value set to ''True'' is handled as follows:[anchor|#ul_ugn_qqz_fm]
*If the <tt>ColumnWidth</tt> property value is set for the same <tt>PXLayoutRule</tt> component, the value is ignored.
*The default values for the <tt>ControlSize</tt> and <tt>LabelsWidth</tt> properties are inherited from the previously declared <tt>PXLayoutRule</tt> component with the <tt>StartRow</tt> or <tt>StartColumn</tt> property value set to ''True''. You can override these property values, if necessary, by specifying the <tt>ControlSize</tt> and <tt>LabelsWidth</tt> property values from the predefined list of options. (See [HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_Predefined|Predefined Size Values] for details.)
]]></column>
			<column name="PlainText"><![CDATA[Use of the Merge Property of PXLayoutRule Merging means placing controls so that they are horizontally aligned. Horizontal alignment         is performed for the controls that are placed between a layout rule with the            Merge  property set to  True  and any other subsequent layout rule.         Therefore, to cancel merging for all of the following controls, you have to add a            PXLayoutRule  component with or without the  Merge          property specified. Example As an example of the use of the  Merge  property, the  Billing           Settings  tab item on the   ([~/?ScreenId=AR303000|AR303000]) Customers (AR303000) form has three pairs of merged check boxes in the            Print and Email Settings  group. This property forces the system to         render the boxes in one column, as shown in the following screenshot. The boxes merged into a single column on the form Dependencies A  PXLayoutRule  component with the  Merge  property         value set to  True  is handled as follows: If the  ColumnWidth  property value is set for the same              PXLayoutRule  component, the value is ignored. The default values for the  ControlSize  and              LabelsWidth  properties are inherited from the previously declared              PXLayoutRule  component with the  StartRow  or              StartColumn  property value set to  True . You can override these           property values, if necessary, by specifying the  ControlSize  and              LabelsWidth  property values from the predefined list of options. (See              Predefined Size Values for details.) ]]></column>
		</row>
		<row PageID="1341b9b1-1868-4544-9737-6c521506965f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="b7828f61-0178-d567-8b7f-21bd543be9f4" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can organize controls in a container within groups to make users&rsquo; work more logical. 
==Grouping of Controls==
To group multiple controls within a column, generally you have to add two <tt>PXLayoutRule</tt> components that have the following properties set to define the first and the last controls in the group, respectively:[anchor|#ul_dv2_r4z_fm]
*<tt>GroupCaption</tt> and <tt>EndGroup</tt>: To create a group with the caption specified in the <tt>GroupCaption</tt> property
*<tt>StartGroup</tt> and <tt>EndGroup</tt>: To create a group without a caption
((({S:Hint}You can specify both the <tt>GroupCaption</tt> property and the <tt>StartGroup</tt> property for a <tt>PXLayoutRule</tt> component that starts a group.
))){br}

For example, by specifying the <tt>GroupCaption</tt> property value for the corresponding <tt>PXLayoutRule</tt> components placed above a control, you start the group of controls and set up the header for the group. You should also add a <tt>PXLayoutRule</tt> component with the <tt>EndGroup</tt> property value set to ''True'' below (in the code) the last control that is included in the group.You end a group by using a <tt>PXLayoutRule</tt> component with a <tt>GroupCaption</tt>, <tt>StartGroup</tt>, or <tt>EndGroup</tt> property specified. Therefore, if there is another group that starts immediately below a group, you can omit the layout rule that ends the upper group, as shown in the third column of the row displayed in the example in following diagram.[anchor|#_7e54b810-3ca4-4a2c-ae5d-10db9b7f5af7][anchor|#_d48daed5-0fd4-4f8f-b39b-20fc42c76a04][image:StudioDeveloperGuide/Images/CG_GL_UI_LayoutRules_Properties_Group.png|popup|Possible use of layout rules with grouping properties|450px]
==Dependencies==
The system works as follows for all <tt>PXLayoutRule</tt> components with the <tt>GroupCaption</tt> or <tt>StartGroup</tt> property value specified:[anchor|#ul_cvl_4rz_fm]
*If the <tt>GroupCaption</tt>, <tt>StartGroup</tt>, or <tt>EndGroup</tt> property is set for a <tt>PXLayoutRule</tt> component, the system ignores the <tt>ColumnWidth</tt> property value specified for the component.
*The default values for the <tt>ControlSize</tt> and <tt>LabelsWidth</tt> properties are inherited from the previously declared <tt>PXLayoutRule</tt> component with the <tt>StartRow</tt> or <tt>StartColumn</tt> property value set to ''True''. You can override these property values, if necessary, by specifying the <tt>ControlSize</tt> and <tt>LabelsWidth</tt> property values in the layout rule that starts a group. (See [HelpRoot_Dev_Platform\CW__con_LayoutRules_Properties_Predefined|Predefined Size Values] for details.)
]]></column>
			<column name="PlainText"><![CDATA[Use of the GroupCaption, StartGroup, and EndGroup Properties of PXLayoutRule You can organize controls in a container within groups to make users' work more logical.        Grouping of Controls To group multiple controls within a column,         generally you have to add two  PXLayoutRule  components that have the         following properties set to define the first and the last controls in the group,           respectively: GroupCaption  and  EndGroup : To create a group             with the caption specified in the  GroupCaption  property StartGroup  and  EndGroup : To create a group             without a caption You can specify both the  GroupCaption  property and the              StartGroup  property for a  PXLayoutRule  component           that starts a group. For example, by specifying the            GroupCaption  property value for the corresponding            PXLayoutRule  components placed above a control, you start the group of         controls and set up the header for the group. You should also add a            PXLayoutRule  component with the  EndGroup  property         value set to  True  below (in the code) the last control that is included in the         group. You end a group by using a  PXLayoutRule  component with a          GroupCaption ,  StartGroup , or          EndGroup  property specified. Therefore, if there is another group that       starts immediately below a group, you can omit the layout rule that ends the upper group, as       shown in the third column of the row displayed in the example in following diagram. Possible use of layout rules with grouping properties Dependencies The system works as follows for all  PXLayoutRule  components with the            GroupCaption  or  StartGroup  property value           specified: If the  GroupCaption ,  StartGroup , or                EndGroup  property is set for a  PXLayoutRule              component, the system ignores the  ColumnWidth  property value             specified for the component. The default values for the  ControlSize  and                LabelsWidth  properties are inherited from the previously declared                PXLayoutRule  component with the  StartRow  or                StartColumn  property value set to  True . You can override             these property values, if necessary, by specifying the  ControlSize              and  LabelsWidth  property values in the layout rule that starts a             group. (See  Predefined Size Values for             details.) ]]></column>
		</row>
		<row PageID="618baa6a-524a-4e0b-bf1a-dfe28c1205e8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="c862ca89-8d73-ab3b-f8fa-2ca1fdc9e00c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Every control for a data field contains both a label and the input area of the control. The label is displayed left of the input area, except with check boxes; the label of a check box is displayed right of the input area of the check box. When you add a check box to a form, the check box control is automatically aligned both left and right with other input controls in the appropriate column. As a result, the area of the form left of a check box is empty.
==SuppressLabel Property==
To hide the labels of the controls placed within a column, you should set the <tt>SuppressLabel</tt> property value of the <tt>PXLayoutRule</tt> component of the column to ''True''. Then within the column, all check boxes are placed without any space to the left of the input control.((({S:Hint}If needed, you can left-align a check box in the column by setting to ''True'' the <tt>AlignLeft</tt> property of the control. Also, you can set the <tt>SuppressLabel</tt> property value to ''True'' for any other control to hide its label.
))){br}

The <tt>SuppressLabel</tt> property affects all of the controls of the group that are placed under the <tt>PXLayoutRule</tt> component with the ''True'' value of this property. The <tt>SuppressLabel</tt> property value must be defined for every <tt>PXLayoutRule</tt> component for the controls placed beneath the component and included in the same column; this property is never inherited from the previously declared property. ((({S:Hint}The <tt>SuppressLabel</tt> property value is never applied to <tt>PXLayoutRule</tt> components that have the <tt>ColumnSpan</tt> property value specified.
)))
==Example==
The '''Parent Info''' group on the '''Billing Settings''' tab item on the [HelpRoot_FormReference\AR_30_30_00|Customers] ([~/?ScreenId=AR303000|AR303000]) form is initially displayed with '''Parent Account''' displayed, as shown in the following screenshot.[anchor|#_73c29e59-1e54-416e-ba35-59360a840e2d]If you set the <tt>SuppressLabel</tt> property of the group layout rule to ''True'', the label of the '''Parent Account''' box is hidden and all check boxes are displayed without any space to the left of the check boxes, as shown in the following screenshot.[anchor|#_7c86fe22-cda4-4d9d-8d30-591fe6fcc11c][anchor|#_8789fcfb-b3f4-426a-b705-f31c8315accb][image:StudioDeveloperGuide/Images/CG_GL_UI_LayoutRules_Properties_SuppressLabel_02.png|popup|The same group of controls after applying the <tt>SuppressLabel</tt> property to the group|270px]]]></column>
			<column name="PlainText"><![CDATA[Use of the SuppressLabel Property of PXLayoutRule Every control for a data field contains both a label and the input area of the control. The         label is displayed left of the input area, except with check boxes; the label of a check box         is displayed right of the input area of the check box. When you add a check box to a form,         the check box control is automatically aligned both left and right with other input controls         in the appropriate column. As a result, the area of the form left of a check box is         empty. SuppressLabel Property To hide the labels of the controls placed within a column, you should set the            SuppressLabel  property value of the  PXLayoutRule          component of the column to  True . Then within the column, all check boxes are placed         without any space to the left of the input control. If needed, you can left-align a           check box in the column by setting to  True  the  AlignLeft            property of the control. Also, you can set the  SuppressLabel  property           value to  True  for any other control to hide its label. The  SuppressLabel  property affects all of the controls of the group that         are placed under the  PXLayoutRule  component with the  True  value of         this property. The  SuppressLabel  property value must be defined for every            PXLayoutRule  component for the controls placed beneath the component         and included in the same column; this property is never inherited from the previously         declared property.  The  SuppressLabel  property value is never           applied to  PXLayoutRule  components that have the              ColumnSpan  property value specified. Example The  Parent Info  group on the  Billing Settings          tab item on the   ([~/?ScreenId=AR303000|AR303000]) Customers (AR303000) form         is initially displayed with  Parent Account  displayed, as shown in the         following screenshot. A group of controls with labels If you set the  SuppressLabel  property of the group layout rule to            True , the label of the  Parent Account  box is hidden and all         check boxes are displayed without any space to the left of the check boxes, as shown in the         following screenshot. The same group of controls after applying the  SuppressLabel              property to the group ]]></column>
		</row>
		<row PageID="1978cf80-0ff3-4da3-b390-d86be7148caa" Language="en-US" PageRevisionID="1" Content="&#xA;In Acumatica Report                         Designer, you can create custom reports or modify existing reports and then use these reports in Acumatica ERP or an Acumatica Framework-based application. For more information on the creation of the custom reports with the Report Designer, see [HelpRoot_ReportingTools\ReportDesigner_Main| Acumatica Report                         Designer Guide].{br}&#xA;&#xA;In this chapter, you can find details about how the system renders reports in Acumatica ERP.&#xA;==In This Chapter==[anchor|#_8be57193-ee67-4d5a-ab9f-1c605c307a25]&#xA;*[HelpRoot_Dev_Platform\CC__con_Rendering_of_Reports|Display of Reports]&#xA;*[HelpRoot_Dev_Platform\CC__con_Rendering_of_Analytical_Reports|Display of Analytical Reports]&#xA;" PlainText="Maintaining Reports In  Acumatica Report                         Designer, you can create custom reports or modify existing reports and then use these reports in  Acumatica ERP     or an  Acumatica Framework-based     application. For more information on the creation of the custom reports with the  Report Designer, see   Acumatica Report                         Designer Guide. In this chapter, you can find details about how the system renders reports in  Acumatica ERP. In This Chapter Display of ReportsDisplay of Analytical Reports" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="d4e35713-e84c-8262-44b4-f902bb6bc77a" RecordSourceID="22377" />
		<row PageID="45dbe9ed-94a0-4183-80f8-eede0415b5ae" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2c5286d8-5914-cf75-e54c-7c0aebcb6304" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can find information about how Acumatica ERP displays reports that are created with the Acumatica Report                         Designer.{br}{TOC}
==What a Report Is==
A report is an RPX file (which is created with the Acumatica Report                         Designer) that contains the report schema in XML format—that is, the description of the data that should be displayed in the report and the description of the report layout.(See the following diagram.) The description of the data of the report includes the following: the database tables that provide data for the report, the relationships between these tables, the parameters that can be specified before the report is run, and the filtering and grouping parameters. The report layout is a tree of headers, details, and footers. [anchor|#_9a518189-d4df-41a2-b15e-62cdf7f8ac11][anchor|#_6137aa26-c90a-48cf-8952-2b5386d820c4][image:StudioDeveloperGuide/Images/ReportTree.png|Report schema|450px]{br}

Reports can be saved in files on disk, or in the <tt>UserReport</tt> table of the database of an Acumatica ERP instance. (The <tt>UserReport</tt> table uses the file name of the report as a key and stores the schema of the report in XML format in the <tt>Xml</tt> column.){br}

The saved report can be published on an Acumatica ERP site—that is, added to the site map and to any applicable workspaces so that the users can work with the report. {br}

For details on creating reports with the Acumatica Report                         Designer, see the [https://openuni.acumatica.com/courses/reporting/s130-inquiries-reports-and-dashboards/|S130 Reporting: Inquiry, Report Writing, Dashboards] training course.{br}

 Acumatica ERP provides the following ways to run a report that you have created by using the Acumatica Report                         Designer:[anchor|#_eca6a93e-b569-49cf-a079-05e99888e2a7]
*From a report form, which is added to the site map, when the user clicks the '''Run Report''' button on the form toolbar
*From a maintenance or entry form, when the user clicks the action button whose name is associated with the report name
[anchor|#_ae3acf88-4440-4fac-a524-4fe7e8a7f0ac]
==How the Report Is Launched from the Report Form==
When a user opens the report form, the webpage performs the POST HTTP request to the <tt>ReportLauncher.aspx</tt> page, passing the name of the report file as the <tt>ID</tt> query string parameter of the request, as shown in the following example. {{{{http://localhost/AcumaticaDB/frames/ReportLauncher.aspx?id=YF123456.rpx&HideScript=On
}}}}{br}

The <tt>ReportLauncher.aspx</tt> page contains the <tt>PXReportViewer</tt> control, whose JavaScript objects and functions are designed to obtain the report data and display the data on the form, and the <tt>PXSoapDataSource</tt> control, which is used to retrieve data for the report.{br}

On the server side, an instance of the <tt>PX.Web.UI.PXReportViewer</tt> class processes the request as follows:[anchor|#_852edc5a-172a-4177-97d6-844ed74ee407]
#Loads the report schema from the file on disk or from the database (by using the <tt>LoadReport</tt> method) to a <tt>PX.Reports.Controls.Report</tt> object (which stores the report schema in memory and provides the methods for working with this schema).
#If the report schema is loaded successfully, performs the following:
##Instantiates a <tt>PX.Reports.Web.WebReport</tt> object that will store data of the launched report and assigns an instance ID to <tt>WebReport</tt>.
##Binds the <tt>Report</tt> object to the data source that is specified by the <tt>PXSoapDataSource</tt> control of the ASPX page. The <tt>PX.Web.UI.PXSoapDataSource</tt> class instantiates a <tt>SoapNavigator</tt> object, which will be then used to retrieve data for the report from the database. 
{br}

The server returns an XML response with the report parameters to display and with the ID of the instance of <tt>WebReport</tt> in the session. The browser displays the report parameters and other options on the report form.{br}

The following diagram illustrates how the report form is launched.[anchor|#_ca0105ff-235e-4e71-a31e-6020f39c0466][anchor|#_f87a99ba-2839-45d0-b05b-49e2494e7ad9][image:StudioDeveloperGuide/Images/LaunchOfReportForm.png|popup|Launch of the report form|450px][anchor|#_84960e46-15bb-492e-b167-a5a09b8e7163]
==How the Report Data Is Retrieved==
After the user has selected the values of the parameters of the report and clicked the '''Run Report''' button on the form toolbar of the report form, the webpage sends the GET request to <tt>PX.ReportViewer.axd</tt> on the server with the ID of the <tt>WebReport</tt> instance in the session (which was created when the report was launched), as shown in the following example.{{{{http://localhost/AcumaticaDB/PX.ReportViewer.axd?
  InstanceID=10bf4a13a38c4af39cafc80926e407f2&OpType=Report
  &PageIndex=0&Refresh=True
}}}}{br}

To process the request, the server invokes the <tt>Render</tt> method of the <tt>WebReport</tt> class, which launches the generation of the report as a long-running operation in a separate thread. For details on how the long-running operation is processed for a report, see [HelpRoot_Dev_Platform\BL__con_Asynchronous_Execution#_397e929e-f4b4-4441-9688-1e0a4ca7ab33|Processing a Report as a Long-Running Operation].{br}

To retrieve the data of the report from the database, the system uses the <tt>PX.Data.Reports.SoapNavigator</tt> object (to which a reference is stored in the <tt>Report</tt> object). <tt>SoapNavigator</tt> instantiates a <tt>PXGraph</tt> object (without a type parameter) and composes a BQL command as an instance of the <tt>PX.Data.Reports.BqlSoapCommand</tt> class. <tt>BqlSoapCommand</tt> inherits from the <tt>PX.Data.BqlCommand</tt> class and is optimized for retrieving data for the reports. <tt>BqlSoapCommand</tt> has the <tt>IndexReportFields</tt> method, which uses the [https://help.acumatica.com/(W(1))/Main?ScreenId=ShowWiki&pageid=5f2cb583-5aea-a584-786b-79aeb224895c|<tt>PX.Data.PXDependsOnFieldsAttribute</tt>] attribute to get the dependent fields of the report recursively. For details on how BQL commands are used to retrieve data from the database, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].{br}

The system processes the data and creates a <tt>ReportNode</tt> object. That is, the system creates the sections of the report based on the data retrieved from the database and on the report schema from the <tt>Report</tt> object, and calculates all formulas inside the sections. Then the system uses the resulting <tt>ReportNode</tt> object, which contains all sections with all needed values, to render data in the needed format.
==How the Report Data Is Displayed==
After the long-running operation has completed, the <tt>PXReportViewer</tt> control displays the report on the report form. {br}

If a report is displayed in HTML format and the user turns the pages of the report, the webpage sends the GET request to <tt>PX.ReportViewer.axd</tt>. The query string parameters of the request are the ID of the report in the session and the number of the page, as shown in the following request URL.{{{{http://localhost/AcumaticaERP/PX.ReportViewer.axd?
  InstanceID=008f2a8afb1a4998ade98bc64fc30ad9&OpType=Report
  &PageIndex=0
}}}}{br}

The format in which the report is displayed (either PDF or HTML) is specified in the <tt>OpType</tt> query string parameter of the request, as shown in the following request URL.{{{{http://localhost/AcumaticaERP/PX.ReportViewer.axd?
  InstanceID=008f2a8afb1a4998ade98bc64fc30ad9&OpType=PdfReport&Refresh=True
}}}}{br}

If a user turns the pages of the report or changes the format of the report, the system creates the results of the report from the <tt>ReportNode</tt> object stored in the session by using the renderer for the needed format. That is, the system does not retrieve the data of the report from the database and does not processes this data to create a <tt>ReportNode</tt> object once again. [anchor|#_1535b822-2515-4dd0-a31e-c527b7317ff0]
==How the Report Is Launched from the Maintenance or Entry Form==
On a form, when a user clicks the action button to generate a report, the data source control of the form creates a request to the Acumatica ERP server to execute the action delegate defined for the button. The server creates an instance of the graph, which provides the business logic for the form and invokes the action delegate method. The action delegate obtains from the form the data required to define the report parameters and throws an exception of the <tt>PX.Data.PXReportRequiredException</tt> type with the report ID and these parameters. The system processes the exception, saves the report parameters to the session, and redirects the user to the <tt>ReportLauncher.aspx</tt> page.{br}

The <tt>ReportLauncher.aspx</tt> page loads the report schema and instantiates a <tt>WebReport</tt> object, as described in [[#_ae3acf88-4440-4fac-a524-4fe7e8a7f0ac|How the Report Is Launched from the Report Form]. Instead of retrieving the values of report parameters from the webpage, the system opens the report with the parameters stored in the session. The system retrieves data for the report, as described in [[#_84960e46-15bb-492e-b167-a5a09b8e7163|How the Report Data Is Retrieved].
==Related Articles==
*[HelpRoot_ReportingTools\ReportDesigner_Main| Acumatica Report                         Designer Guide]
*[HelpRoot_Dev_Platform\BL__con_Asynchronous_Execution|Asynchronous Execution]]]></column>
			<column name="PlainText"><![CDATA[Display of Reports In this topic, you can find information about how  Acumatica ERP displays reports that are created with the  Acumatica Report                         Designer. What a Report Is A report is an RPX file (which is created with the  Acumatica Report                         Designer) that contains the report schema in XML format—that is, the description of the data         that should be displayed in the report and the description of the report layout.(See the         following diagram.) The description of the data of the report includes the following: the         database tables that provide data for the report, the relationships between these tables,         the parameters that can be specified before the report is run, and the filtering and         grouping parameters. The report layout is a tree of headers, details, and footers.  Report schema Reports can be saved in files on disk, or in the  UserReport  table of the         database of an  Acumatica ERP instance. (The  UserReport  table uses the file name of the report as a         key and stores the schema of the report in XML format in the  Xml          column.) The saved report can be published on an  Acumatica ERP site—that is, added to the site map and to any applicable workspaces so that the         users can work with the report.  For details on creating reports with the  Acumatica Report                         Designer, see the  S130 Reporting: Inquiry, Report Writing, Dashboards S130 Reporting: Inquiry, Report Writing, Dashboards         training course.  Acumatica ERP provides the following ways to run a report that you have created by using the  Acumatica Report                         Designer: From a report form, which is added to the site map, when the user clicks the                Run Report  button on the form toolbar From a maintenance or entry form, when the user clicks the action button whose name is             associated with the report name How the Report Is Launched from the Report Form When a user opens the report form, the webpage performs the POST HTTP request to the            ReportLauncher.aspx  page, passing the name of the report file as the            ID  query string parameter of the request, as shown in the following         example.          http://localhost/AcumaticaDB/frames/ReportLauncher.aspx?id=YF123456.rpx&HideScript=On The  ReportLauncher.aspx  page contains the            PXReportViewer  control, whose JavaScript objects and functions are         designed to obtain the report data and display the data on the form, and the            PXSoapDataSource  control, which is used to retrieve data for the         report. On the server side, an instance of the  PX.Web.UI.PXReportViewer  class         processes the request as follows: Loads the report schema from the file on disk or from the database (by using the                LoadReport  method) to a                PX.Reports.Controls.Report  object (which stores the report schema             in memory and provides the methods for working with this schema). If the report schema is loaded successfully, performs the following: Instantiates a  PX.Reports.Web.WebReport  object that will store                 data of the launched report and assigns an instance ID to                    WebReport . Binds the  Report  object to the data source that is specified by                 the  PXSoapDataSource  control of the ASPX page. The                    PX.Web.UI.PXSoapDataSource  class instantiates a                    SoapNavigator  object, which will be then used to retrieve data                 for the report from the database.  The server returns an XML response with the report parameters to display and with the ID of         the instance of  WebReport  in the session. The browser displays the report         parameters and other options on the report form. The following diagram illustrates how the report form is launched. Launch of the report form How the Report Data Is Retrieved After the user has selected the values of the parameters of the report and clicked the            Run Report  button on the form toolbar of the report form, the         webpage sends the GET request to  PX.ReportViewer.axd  on the server with         the ID of the  WebReport  instance in the session (which was created when         the report was launched), as shown in the following         example. http://localhost/AcumaticaDB/PX.ReportViewer.axd?
  InstanceID=10bf4a13a38c4af39cafc80926e407f2&OpType=Report
  &PageIndex=0&Refresh=True To process the request, the server invokes the  Render  method of the            WebReport  class, which launches the generation of the report as a         long-running operation in a separate thread. For details on how the long-running operation         is processed for a report, see  Processing a Report as a Long-Running Operation. To retrieve the data of the report from the database, the system uses the            PX.Data.Reports.SoapNavigator  object (to which a reference is stored in         the  Report  object).  SoapNavigator  instantiates a            PXGraph  object (without a type parameter) and composes a BQL command as         an instance of the  PX.Data.Reports.BqlSoapCommand  class.            BqlSoapCommand  inherits from the  PX.Data.BqlCommand          class and is optimized for retrieving data for the reports.            BqlSoapCommand  has the  IndexReportFields  method,         which uses the  PX.Data.PXDependsOnFieldsAttribute <tt>PX.Data.PXDependsOnFieldsAttribute</tt> attribute to get the         dependent fields of the report recursively. For details on how BQL commands are used to         retrieve data from the database, see  Translation of a BQL Command to SQL. The system processes the data and creates a  ReportNode  object. That is,         the system creates the sections of the report based on the data retrieved from the database         and on the report schema from the  Report  object, and calculates all         formulas inside the sections. Then the system uses the resulting            ReportNode  object, which contains all sections with all needed values,         to render data in the needed format. How the Report Data Is Displayed After the long-running operation has completed, the  PXReportViewer          control displays the report on the report form.  If a report is displayed in HTML format and the user turns the pages of the report, the         webpage sends the GET request to  PX.ReportViewer.axd . The query string         parameters of the request are the ID of the report in the session and the number of the         page, as shown in the following request         URL. http://localhost/AcumaticaERP/PX.ReportViewer.axd?
  InstanceID=008f2a8afb1a4998ade98bc64fc30ad9&OpType=Report
  &PageIndex=0 The format in which the report is displayed (either PDF or HTML) is specified in the            OpType  query string parameter of the request, as shown in the following         request         URL. http://localhost/AcumaticaERP/PX.ReportViewer.axd?
  InstanceID=008f2a8afb1a4998ade98bc64fc30ad9&OpType=PdfReport&Refresh=True If a user turns the pages of the report or changes the format of the report, the system         creates the results of the report from the  ReportNode  object stored in         the session by using the renderer for the needed format. That is, the system does not         retrieve the data of the report from the database and does not processes this data to create         a  ReportNode  object once again.  How the Report Is Launched from the Maintenance or Entry Form On a form, when a user clicks the action button to generate a report, the data source         control of the form creates a request to the  Acumatica ERP server to execute the action delegate defined for the button. The server creates an         instance of the graph, which provides the business logic for the form and invokes the action         delegate method. The action delegate obtains from the form the data required to define the         report parameters and throws an exception of the            PX.Data.PXReportRequiredException  type with the report ID and these         parameters. The system processes the exception, saves the report parameters to the session,         and redirects the user to the  ReportLauncher.aspx  page. The  ReportLauncher.aspx  page loads the report schema and instantiates         a  WebReport  object, as described in  How the Report Is Launched from the Report Form How the Report Is Launched from the Report Form. Instead of retrieving the values of report parameters from the webpage,         the system opens the report with the parameters stored in the session. The system retrieves         data for the report, as described in  How the Report Data Is Retrieved How the Report Data Is Retrieved. ]]></column>
		</row>
		<row PageID="948e10a2-13c1-42f7-9673-ec145858fc1f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="d0b43d7b-1072-cd33-a420-983959911b8e" RecordSourceID="22377">
			<column name="Content"><![CDATA[In this topic, you can find information about how Acumatica ERP displays analytical reports.{br}{TOC}
==What an Analytical Report Is==
An analytical report is a specific type of report that you can construct in Acumatica ERP by using the Analytical Report Manager (ARM) toolkit. You will likely want to use the ARM toolkit rather than the Acumatica Report                         Designer to create the following types of reports:[anchor|#_4792b4d2-bdd0-4c93-ae60-7875afdf8256]
*Financial reports that display data that is posted to the general ledger accounts and accumulated in the General Ledger module. The system gets the data of the general ledger accounts from the <tt>GLHistory</tt> table of the database. 
*Project accounting reports that display data that is accumulated in the Project module. The system gets the data for these reports from the <tt>PMHistory</tt> table of the database.
{br}

For details on analytical reports, see the [https://openuni.acumatica.com/courses/reporting/f350-financials-analytical-reports/|F350 Reporting: Analytical Reports] training course.{br}

The schema of analytical reports are stored in a set of database tables that have <tt>RM</tt> prefix in their names, such as <tt>RMReport</tt>, <tt>RMRowSet</tt>, and <tt>RMColumnSet</tt>. The analytical report is identified in the system by its code, which you specify in the '''Code''' box on the [HelpRoot_FormReference\CS_20_60_00|Report Definitions] ([~/?ScreenId=CS206000|CS206000]) form. The report code is stored in the <tt>ReportCode</tt> column of the <tt>RMReport</tt> table.{br}

The schema of an analytical report can include the position of the report in the site map so that the users can work with the report. To run the report, a user clicks the '''Run Report''' button on the form toolbar of the report form.
==How the Analytical Report Is Launched from the Report Form==
When a user opens the report form of an analytical report, the webpage performs the POST HTTP request to the <tt>RMLauncher.aspx</tt> page, passing the report code with {{.rpx}} appended as the <tt>ID</tt> query string parameter of the request, as shown in the following example.{{{{http://localhost/AcumaticaDB/frames/rmlauncher.aspx?id=dbsp.rpx&HideScript=On
}}}}{br}

The <tt>RMLauncher.aspx</tt> page contains the <tt>PXReportViewer</tt> control, whose JavaScript objects and functions are designed to obtain the report data and display the data on the form, and the <tt>ARmDataSource</tt> control, which is used to retrieve data for the analytical report.{br}

On the server side, the system (by using an instance of the <tt>PX.Web.UI.PXReportViewer</tt> class) processes the request as follows:[anchor|#_5508573f-4fbd-486e-aa16-95e306a78dcd]
#Loads the parameters of the analytical report from the database (by using the <tt>LoadReport</tt> method) to a <tt>PX.Reports.Controls.Report</tt> object as follows: 
##The system retrieves the data source of the report viewer as an instance of the <tt>PX.CS.RMReportReader</tt> class, which is a graph (derived from <tt>PXGraph&lt;RMReportMaint, RMReport&gt;</tt>) that implements the <tt>PX.Report.ARm.Data.IARmDataSource</tt> interface. 
##By using the <tt>GetReport</tt> method of <tt>IARmDataSource</tt>, the system retrieves the parameters of the analytical report from the database to the <tt>PX.Reports.ARm.ARmReport</tt> object.
##By using the <tt>CreateReport</tt> method of the <tt>PX.Reports.ARm.Data.ARmProcessor</tt> class, the system creates a <tt>Report</tt> object with the parameters retrieved from the <tt>ARmReport</tt> object.
#If the report parameters are loaded successfully, performs the following:
##The system instantiates a <tt>PX.Reports.Web.WebReport</tt> object that will store data of the launched report and assigns an instance ID to <tt>WebReport</tt>.
##The system initializes the <tt>ProcessMethod</tt> field of the <tt>WebReport</tt> object with the processing function for analytical reports.
{br}

The server returns an XML response with the report parameters to display and with the ID of the instance of <tt>WebReport</tt> in the session. The browser displays the report parameters on the report form.
==How the Data of the Analytical Report Is Retrieved==
After the user has selected the values of the parameters of the analytical report and clicked the '''Run Report''' button on the form toolbar of the report form, the webpage sends the GET request to <tt>PX.ReportViewer.axd</tt> on the server with the ID of the <tt>WebReport</tt> instance in the session (which was created when the report was launched). {br}

To process the request, the server invokes the <tt>Render</tt> method of the <tt>WebReport</tt> class, which launches the generation of the report as a long-running operation in a separate thread. For details on how the long-running operation is processed for a report, see [HelpRoot_Dev_Platform\BL__con_Asynchronous_Execution#_397e929e-f4b4-4441-9688-1e0a4ca7ab33|Processing a Report as a Long-Running Operation].{br}

To retrieve the data of the analytical report from the database, the system uses the <tt>PX.Objects.CS.RMReportReaderGL</tt> (for financial reports) and <tt>PX.Objects.CS.RMReportReaderPM</tt> (for project accounting reports) extensions of the <tt>PX.CS.RMReportReader</tt> graph. 
==How the Report Data Is Displayed==
After the long-running operation has completed, the <tt>PXReportViewer</tt> control displays the analytical report on the report form. 
==Related Articles==
*[HelpRoot_ReportingTools\GL__GL_ARM_Reports|Managing Analytical Reports]
*[HelpRoot_Dev_Platform\BL__con_Asynchronous_Execution|Asynchronous Execution]]]></column>
			<column name="PlainText"><![CDATA[Display of Analytical Reports In this topic, you can find information about how  Acumatica ERP displays analytical reports. What an Analytical Report Is An analytical report is a specific type of report that you can construct in  Acumatica ERP by using the Analytical Report Manager (ARM) toolkit. You will likely want to use                 the ARM toolkit rather than the  Acumatica Report                         Designer to create the following types of reports: Financial reports that display data that is posted to the general ledger                         accounts and accumulated in the General Ledger module. The system gets the                         data of the general ledger accounts from the  GLHistory                          table of the database.  Project accounting reports that display data that is accumulated in the                         Project module. The system gets the data for these reports from the                              PMHistory  table of the database. For details on analytical reports, see the  F350 Reporting: Analytical Reports F350 Reporting: Analytical Reports                 training course. The schema of analytical reports are stored in a set of database tables that have                      RM  prefix in their names, such as                  RMReport ,  RMRowSet , and                      RMColumnSet . The analytical report is identified in the                 system by its code, which you specify in the  Code  box on the                       ([~/?ScreenId=CS206000|CS206000]) Report Definitions (CS206000) form. The report code is stored in the                      ReportCode  column of the  RMReport                  table. The schema of an analytical report can include the position of the report in the site                 map so that the users can work with the report. To run the report, a user clicks the                      Run Report  button on the form toolbar of the report                 form. How the Analytical Report Is Launched from the Report Form When a user opens the report form of an analytical report, the webpage performs the                 POST HTTP request to the  RMLauncher.aspx  page, passing the                 report code with  .rpx  appended as the  ID  query                 string parameter of the request, as shown in the following                 example. http://localhost/AcumaticaDB/frames/rmlauncher.aspx?id=dbsp.rpx&HideScript=On The  RMLauncher.aspx  page contains the                      PXReportViewer  control, whose JavaScript objects and                 functions are designed to obtain the report data and display the data on the form,                 and the  ARmDataSource  control, which is used to retrieve data for                 the analytical report. On the server side, the system (by using an instance of the                      PX.Web.UI.PXReportViewer  class) processes the request as                     follows: Loads the parameters of the analytical report from the database (by using                         the  LoadReport  method) to a                              PX.Reports.Controls.Report  object as follows:  The system retrieves the data source of the report viewer as an                                 instance of the  PX.CS.RMReportReader  class, which                                 is a graph (derived from  PXGraph<RMReportMaint,                                     RMReport> ) that implements the                                      PX.Report.ARm.Data.IARmDataSource  interface.  By using the  GetReport  method of                                      IARmDataSource , the system retrieves the                                 parameters of the analytical report from the database to the                                      PX.Reports.ARm.ARmReport  object. By using the  CreateReport  method of the                                      PX.Reports.ARm.Data.ARmProcessor  class, the                                 system creates a  Report  object with the                                 parameters retrieved from the  ARmReport                                  object. If the report parameters are loaded successfully, performs the following: The system instantiates a                                      PX.Reports.Web.WebReport  object that will                                 store data of the launched report and assigns an instance ID to                                      WebReport . The system initializes the  ProcessMethod  field of                                 the  WebReport  object with the processing function                                 for analytical reports. The server returns an XML response with the report parameters to display and with the                 ID of the instance of  WebReport  in the session. The browser                 displays the report parameters on the report form. How the Data of the Analytical Report Is Retrieved After the user has selected the values of the parameters of the analytical report and                 clicked the  Run Report  button on the form toolbar of the                 report form, the webpage sends the GET request to                      PX.ReportViewer.axd  on the server with the ID of the                      WebReport  instance in the session (which was created when the                 report was launched).  To process the request, the server invokes the  Render  method of                 the  WebReport  class, which launches the generation of the report                 as a long-running operation in a separate thread. For details on how the                 long-running operation is processed for a report, see  Processing a Report as a Long-Running Operation. To retrieve the data of the analytical report from the database, the system uses the                      PX.Objects.CS.RMReportReaderGL  (for financial reports) and                      PX.Objects.CS.RMReportReaderPM  (for project accounting                 reports) extensions of the  PX.CS.RMReportReader  graph.  How the Report Data Is Displayed After the long-running operation has completed, the  PXReportViewer                  control displays the analytical report on the report form.  ]]></column>
		</row>
		<row PageID="cc602399-bac4-46bf-b23c-79e86251c521" Language="en-US" PageRevisionID="1" Content="&#xA;The topics in this part of the guide explain how an application based on Acumatica Framework can access data from the application database and the data stored in the session.&#xA;==In This Part==[anchor|#_14801a9b-e3f4-4e28-a65a-c03b44851ea2]&#xA;*[HelpRoot_Dev_Platform\AD__mng_Querying_Data|Querying Data in Acumatica Framework]&#xA;*[HelpRoot_Dev_Platform\AD__mng_Fluent_BQL|Creating Fluent BQL Queries]&#xA;*[HelpRoot_Dev_Platform\AD__mng_Traditional_BQL|Creating Traditional BQL Queries]&#xA;*[HelpRoot_Dev_Platform\AD__mng_LINQ|Creating LINQ Queries]&#xA;*[HelpRoot_Dev_Platform\AD__mng_Defining_PK_and_FK|Defining Relationships Between DACs]&#xA;*[HelpRoot_Dev_Platform\AD__mng_Working_with_Cache_and_Session|Working with Data in Cache and Session]&#xA;" PlainText="Accessing Data The topics in this part of the guide explain how an application based on  Acumatica Framework can     access data from the application database and the data stored in the session. In This Part Querying Data in Acumatica FrameworkCreating Fluent BQL QueriesCreating Traditional BQL QueriesCreating LINQ QueriesDefining Relationships Between DACsWorking with Data in Cache and Session" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="0dd5ceb6-d6ed-ee32-d1bc-3f2228981e6a" RecordSourceID="22377" />
		<row PageID="5978bf0a-e65c-47ca-8fec-40aa733ae2b8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="403178df-3969-1989-4e04-cfcc9d960fb7" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In Acumatica Framework, you generally use business query language (BQL) to query data from the database. BQL statements represent specific SQL queries and are translated into SQL by Acumatica Framework, which helps you to avoid the specifics of the database provider and validate the queries at the time of compilation. Acumatica Framework provides two dialects of BQL: traditional BQL and fluent BQL. For details about these dialects, see [HelpRoot_Dev_Platform\AD__mng_Traditional_BQL|Creating Traditional BQL Queries] and [HelpRoot_Dev_Platform\AD__mng_Fluent_BQL|Creating Fluent BQL Queries]. {br}

To query data from the database, you can also use language-integrated query (LINQ), which is a part of .NET Framework. In the code of Acumatica Framework-based applications, you can use both the standard query operators (provided by LINQ libraries) and the Acumatica Framework-specific operators that are designed to query database data. {br}

This chapter explains the aspects that are common to traditional BQL, fluent BQL, and LINQ and provides a high-level comparison of the approaches for querying data in Acumatica Framework.
==In This Chapter==[anchor|#_6140616f-ee44-4f3a-8ec1-2c609cd80d6c]
{| class="checklist invisiblechecklist" | width="100%" 
|- 
| [anchor|#_cbe0ecf8-ac56-4a4d-b0f0-d06da70c7493]
*[HelpRoot_Dev_Platform\AD__con_BQL_and_LINQ|BQL and LINQ]
*[HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes]
*[HelpRoot_Dev_Platform\AD__con_PXView_and_PXCache|PXView and PXCache of the Data View]
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]
*[HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL]
*[HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache]
*[HelpRoot_Dev_Platform\AD__con_Comparison_of_TBQL_FBQL_LINQ|Comparison of Fluent BQL, Traditional BQL, and LINQ]
*[HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents]

| [anchor|#_0482456b-4645-4497-92aa-2658dd32dda5]
*[HelpRoot_Dev_Platform\AD__how_Execute_BQL_Statement|To Execute BQL Statements]
*[HelpRoot_Dev_Platform\AD__how_Process_Resultset|To Process the Result of the Execution of the BQL Statement]

|}]]></column>
			<column name="PlainText"><![CDATA[Querying Data in  Acumatica FrameworkIn  Acumatica Framework, you generally use business query language (BQL) to query data from the database. BQL     statements represent specific SQL queries and are translated into SQL by  Acumatica Framework,     which helps you to avoid the specifics of the database provider and validate the queries at the     time of compilation.  Acumatica Framework     provides two dialects of BQL: traditional BQL and fluent BQL. For details about these dialects,     see  Creating Traditional BQL Queries and  Creating Fluent BQL Queries.  To query data from the database, you can also use language-integrated query (LINQ), which is a     part of .NET Framework. In the code of  Acumatica Framework-based     applications, you can use both the standard query operators (provided by LINQ libraries) and the       Acumatica Framework-specific operators that are designed to query database data.  This chapter explains the aspects that are common to traditional BQL, fluent BQL, and LINQ and     provides a high-level comparison of the approaches for querying data in  Acumatica Framework. In This Chapter BQL and LINQData Access ClassesPXView and PXCache of the Data ViewData Query ExecutionTranslation of a BQL Command to SQLMerge of the Records with PXCacheComparison of Fluent BQL, Traditional BQL, and LINQFluent BQL and Traditional BQL EquivalentsTo Execute BQL StatementsTo Process the Result of the Execution of the BQL Statement]]></column>
		</row>
		<row PageID="63ce6aaa-0620-4993-a9a3-a49469eb906a" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="0f9ac0b3-1bf5-9c64-b0e4-4db3c58ccad0" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When a data request occurs, the system creates an instance of a business logic controller (also referred as a ''graph''). The graph contains the data views that you define in code. In these data views, you define the queries to be executed to retrieve the requested data by using business query language (BQL), which is provided by Acumatica Framework. You also use BQL to define the data queries directly in code and in attributes.{br}

BQL is written in C#; it is based on generic class syntax, which is similar to SQL syntax. Thus, BQL has almost the same keywords as SQL does, placed in the order in which they are used in SQL. BQL offers several benefits to the application developer. BQL does not depend on the specifics of the database provider, and it is object-oriented and extendable. Also, BQL provides compile-time syntax validation, which helps to prevent SQL syntax errors.{br}

You can also use language-integrated query (LINQ) provided by the {{System.Linq}} library when you need to select records from the database in the code of Acumatica Framework-based applications or if you want to apply additional filtering to the data of a BQL query. However, you still have to use BQL to define the data views in graphs and to specify the data queries in the attributes of data fields.{br}{TOC}
==Fluent BQL and Traditional BQL==
 Acumatica Framework provides two dialects of BQL: fluent BQL and traditional BQL. Traditional BQL was the initial language for data queries in Acumatica Framework; it provides the benefits described above. Fluent BQL provides the following advantages as compared to traditional BQL:[anchor|#_08883d04-3e68-4119-ac8b-b55bb2f524a7]
*It is easier to read and edit fluent BQL queries than traditional BQL queries because each section of a fluent BQL query does not depend on the others and can appear in only specific places of the query. Also, fluent BQL queries contain fewer commas and angle brackets and do not use numbered classes (such as <tt>Select2</tt> or <tt>Select6</tt>).
*You do not need to select a suitable class for a fluent BQL query (such as <tt>PXSelectOrderBy&lt;,&gt;</tt> or <tt>PXSelectJoinOrderBy&lt;,,&gt;</tt>); instead, you simply start typing the command, and IntelliSense in Visual Studio offers continuations that are relevant for the current query state.
{br}

For a detailed list of differences between the dialects, see [HelpRoot_Dev_Platform\AD__con_Comparison_of_TBQL_FBQL_LINQ|Comparison of Fluent BQL, Traditional BQL, and LINQ].{br}

The following code shows an example of a data view written in fluent BQL.{{{{SelectFrom&lt;Product&gt;.
    Where&lt;Product.availQty.IsNotNull.
          And&lt;Product.availQty.IsGreater&lt;Product.bookedQty&gt;&gt;&gt;.View products;
}}}}{br}

The following code shows the same data view written in traditional BQL.<source lang="csharp">PXSelect&lt;Product,
    Where&lt;Product.availQty, IsNotNull,
        And&lt;Product.availQty, Greater&lt;Product.bookedQty&gt;&gt;&gt;&gt; products;</source>
Suppose the database provider is Microsoft SQL Server. Acumatica Framework translates the fluent and traditional BQL queries shown above into the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table. {{{{SELECT [list of columns] FROM Product
WHERE Product.AvailQty IS NOT NULL
    AND Product.AvailQty &gt; Product.BookedQty 
}}}}[anchor|#_e802a35a-499b-405b-b252-d894e5595b67]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
==LINQ==[anchor|#_ce164ae1-7159-45ff-9f22-668caf5ede79]
To configure a LINQ query, you can use the following variants of syntax:[anchor|#_bd9f98d7-a022-4dab-8acd-8dcc8379f531]
*Query expressions, which use standard query operators from the {{System.Linq}} namespace (such as {{where}} or {{orderby}}) or Acumatica Framework-specific operators from the {{PX.Data.SQLTree}} namespace (such as <tt>SQL.BinaryLen</tt>, which is shown in the following example of this syntax). <source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var goods = from p in graph.Select&lt;Product&gt;()
  where 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0
  select new 
  { 
    p.ProductID, 
    p.ProductCD, 
    p.ProductName, 
    Len = p.ProductName.Length, 
    BLen = SQL.BinaryLen( p.ProductName) + 1, 
    p.GroupMask, 
    p.WorkGroupID 
};</source>
*Explicit (method-based) syntax. The arguments of the methods used in this syntax are lambda expressions. In these expressions, you can use the standard C# operators and Acumatica Framework-specific operators from the {{PX.Data.SQLTree}} namespace (such as <tt>SQL.BinaryLen</tt>, which is shown in the following code). The code below is equivalent to the query expression shown above.<source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var goods = graph.Select&lt;Product&gt;()
  .Where( p =&gt; 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0)
  .Select( p =&gt; new     
    { 
      p.ProductID, 
      p.ProductCD, 
      p.ProductName, 
      Len = p.ProductName.Length, 
      BLen = SQL.BinaryLen(p.ProductName) + 1, 
      p.GroupMask, p.WorkGroupID 
    });</source>

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Fluent_BQL|Fluent Business Query Language]
*[HelpRoot_Dev_Platform\AD__con_Traditional_BQL|Traditional Business Query Language]
*[HelpRoot_Dev_Platform\AD__con_LINQ_in_Acumatica_Framework|LINQ in Acumatica Framework]
*[HelpRoot_Dev_Platform\AD__con_Comparison_of_TBQL_FBQL_LINQ|Comparison of Fluent BQL, Traditional BQL, and LINQ]]]></column>
			<column name="PlainText"><![CDATA[BQL and LINQ When a data request occurs, the system creates an instance of a business logic controller         (also referred as a  graph ). The graph contains the data views that you define in         code. In these data views, you define the queries to be executed to retrieve the requested         data by using business query language (BQL), which is provided by  Acumatica Framework.         You also use BQL to define the data queries directly in code and in attributes. BQL is written in C#; it is based on generic class syntax, which is similar to SQL syntax.         Thus, BQL has almost the same keywords as SQL does, placed in the order in which they are         used in SQL. BQL offers several benefits to the application developer. BQL does not depend         on the specifics of the database provider, and it is object-oriented and extendable. Also,         BQL provides compile-time syntax validation, which helps to prevent SQL syntax errors. You can also use language-integrated query (LINQ) provided by the            System.Linq  library when you need to select records from the database in         the code of  Acumatica Framework-based applications or if you want to apply additional filtering to the data of a BQL         query. However, you still have to use BQL to define the data views in graphs and to specify         the data queries in the attributes of data fields. Fluent BQL and Traditional BQL  Acumatica Framework provides two dialects of BQL: fluent BQL and traditional BQL. Traditional BQL was the         initial language for data queries in  Acumatica Framework;         it provides the benefits described above. Fluent BQL provides the following advantages as         compared to traditional BQL: It is easier to read and edit fluent BQL queries than traditional BQL queries because             each section of a fluent BQL query does not depend on the others and can appear in only             specific places of the query. Also, fluent BQL queries contain fewer commas and angle             brackets and do not use numbered classes (such as  Select2  or                Select6 ). You do not need to select a suitable class for a fluent BQL query (such as                PXSelectOrderBy<,>  or                PXSelectJoinOrderBy<,,> ); instead, you simply start typing the             command, and IntelliSense in Visual Studio offers continuations that are relevant for             the current query state. For a detailed list of differences between the dialects, see  Comparison of Fluent BQL, Traditional BQL, and LINQ. The following code shows an example of a data view written in fluent         BQL. SelectFrom<Product>.
    Where<Product.availQty.IsNotNull.
          And<Product.availQty.IsGreater<Product.bookedQty>>>.View products; The following code shows the same data view written in traditional BQL. PXSelect<Product,
    Where<Product.availQty, IsNotNull,
        And<Product.availQty, Greater<Product.bookedQty>>>> products; Suppose the database provider is Microsoft SQL Server.  Acumatica Framework         translates the fluent and traditional BQL queries shown above into the following SQL query,         where  [list of columns]  is the list of columns of the            Product  table.  SELECT [list of columns] FROM Product
WHERE Product.AvailQty IS NOT NULL
    AND Product.AvailQty > Product.BookedQty   Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. LINQ To configure a LINQ query, you can use the following       variants of syntax: Query expressions, which use standard query operators from the              System.Linq  namespace (such as  where  or              orderby ) or  Acumatica Framework-specific           operators from the  PX.Data.SQLTree  namespace (such as              SQL.BinaryLen , which is shown in the following example of this           syntax).            ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var goods = from p in graph.Select<Product>()
  where 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0
  select new 
  { 
    p.ProductID, 
    p.ProductCD, 
    p.ProductName, 
    Len = p.ProductName.Length, 
    BLen = SQL.BinaryLen( p.ProductName) + 1, 
    p.GroupMask, 
    p.WorkGroupID 
}; Explicit (method-based) syntax. The arguments of the methods used in this syntax are           lambda expressions. In these expressions, you can use the standard C# operators and  Acumatica Framework-specific           operators from the  PX.Data.SQLTree  namespace (such as              SQL.BinaryLen , which is shown in the following code). The code below           is equivalent to the query expression shown           above. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var goods = graph.Select<Product>()
  .Where( p => 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0)
  .Select( p => new     
    { 
      p.ProductID, 
      p.ProductCD, 
      p.ProductName, 
      Len = p.ProductName.Length, 
      BLen = SQL.BinaryLen(p.ProductName) + 1, 
      p.GroupMask, p.WorkGroupID 
    }); ]]></column>
		</row>
		<row PageID="3f6ee8e9-b29e-4dab-b4f8-4406c3ef101d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f61570ce-3f39-909d-f7fe-120afe8c749b" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The classes that represent database tables in Acumatica Framework are called ''data access classes (DACs)''. You derive these classes from the <tt>PX.Data.IBqlTable</tt> interface. The name of a class is usually the same as the name of the database table to which it provides access (except with the DACs that have the <tt>PXTable</tt> or <tt>PXProjection</tt> attributes, which change the default binding of DACs to database tables). We recommend that you add to each DAC the <tt>PXCacheName</tt> or <tt>PXHidden</tt> attribute to specify whether and how the DAC is available in generic inquiries and reports.{br}

For each table column, you add a data field to the corresponding data access class by declaring the following members:[anchor|#ul_ijc_z2j_4k]
*A {{public abstract}} class (which is also referred to as a ''class field'')
*:You use this class to reference the table column in a business query language (BQL) statement. The declaration of the class field is different in the fluent BQL dialect than it is in the traditional BQL dialect. For details about the declaration, see [HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL] and [HelpRoot_Dev_Platform\AD__con_DACs_in_TraditionalBQL|Data Access Classes in Traditional BQL]. We recommend that you use the fluent BQL style of DAC declaration because it can be used both in fluent BQL and in traditional BQL. The style of class field declaration is not important for queries defined with language-integrated query (LINQ).
*A {{public virtual}} property (which is also referred to as ''property field'')
*:You bind the data field to the table column by specifying the type attribute that is derived from the <tt>PXDBFieldAttribute</tt> class, such as <tt>PXDBString</tt>, and specifying the name of the column as the name of the property. If you don&rsquo;t need to bind the property to a database column (for example, if you want the value of the property to be calculated from the database fields), you specify an unbound type attribute, such as <tt>PXDBCalced</tt>. You assign the property a name that starts with an uppercase letter. For the lists of bound and unbound type attributes, see [HelpRoot_Dev_Platform\BL__con_Attr_DB_Types|Bound Field Data Types] and [HelpRoot_Dev_Platform\BL__con_Attr_Unbound_Data_Types|Unbound Field Data Types].
*:You use the property, which, in the system, holds the column data of the table, in the queries defined with LINQ. In the SQL command generated from BQL, the framework explicitly lists columns for all bound data fields defined in the DAC. For the unbound data fields whose property attribute defines a BQL command, if this data field is used in a BQL query, the system translates the BQL command of the property to SQL when the BQL query is translated to SQL. For more information on the translation of BQL to SQL, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
The following code shows an example of the <tt>Product</tt> DAC declaration in the fluent BQL style.<source lang="csharp">using System;
using PX.Data;

[Serializable]
public class Product : PX.Data.IBqlTable
{
    // The class used in BQL statements to refer to the ProductID column
    public abstract class productID : PX.Data.BQL.BqlInt.Field&lt;productID&gt;
    {
    }
    // The property holding the ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }

    // The class used in BQL statements to refer to the AvailQty column
    public abstract class availQty : PX.Data.BQL.BqlDecimal.Field&lt;availQty&gt;
    {
    }
    // The property holding the AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
}</source>
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL]
*[HelpRoot_Dev_Platform\AD__con_DACs_in_TraditionalBQL|Data Access Classes in Traditional BQL]
*[HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL]]]></column>
			<column name="PlainText"><![CDATA[Data Access Classes The classes that represent database tables in  Acumatica Framework         are called  data access classes (DACs) . You derive these classes from the            PX.Data.IBqlTable  interface. The name of a class is usually the same as         the name of the database table to which it provides access (except with the DACs that have         the  PXTable  or  PXProjection  attributes, which change         the default binding of DACs to database tables). We recommend that you add to each DAC the            PXCacheName  or  PXHidden  attribute to specify whether         and how the DAC is available in generic inquiries and reports. For each table column,         you add a data field to the corresponding data access class by declaring the following         members: A  public abstract  class (which is also referred to as a  class             field ) You use this class to reference the table column in a business query             language (BQL) statement. The declaration of the class field is different in the fluent             BQL dialect than it is in the traditional BQL dialect. For details about the             declaration, see  Data Access Classes in Fluent BQL and  Data Access Classes in Traditional BQL. We recommend that you use the fluent BQL             style of DAC declaration because it can be used both in fluent BQL and in traditional             BQL. The style of class field declaration is not important for queries defined with             language-integrated query (LINQ). A  public virtual  property (which is also referred to as  property             field ) You bind the data field to the table column by specifying the type             attribute that is derived from the  PXDBFieldAttribute  class, such as                PXDBString , and specifying the name of the column as the name of             the property. If you don't need to bind the property to a database column (for example,             if you want the value of the property to be calculated from the database fields), you             specify an unbound type attribute, such as  PXDBCalced . You assign the             property a name that starts with an uppercase letter. For the lists of bound and unbound             type attributes, see  Bound Field Data Types and  Unbound Field Data Types. You use the property, which, in             the system, holds the column data of the table, in the queries defined with LINQ. In the             SQL command generated from BQL, the framework explicitly lists columns for all bound             data fields defined in the DAC. For the unbound data fields whose property attribute             defines a BQL command, if this data field is used in a BQL query, the system translates             the BQL command of the property to SQL when the BQL query is translated to SQL. For more             information on the translation of BQL to SQL, see  Translation of a BQL Command to SQL. The following code shows an example of the  Product  DAC declaration in       the fluent BQL       style. using System;
using PX.Data;

[Serializable]
public class Product : PX.Data.IBqlTable
{
    // The class used in BQL statements to refer to the ProductID column
    public abstract class productID : PX.Data.BQL.BqlInt.Field<productID>
    {
    }
    // The property holding the ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }

    // The class used in BQL statements to refer to the AvailQty column
    public abstract class availQty : PX.Data.BQL.BqlDecimal.Field<availQty>
    {
    }
    // The property holding the AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
} ]]></column>
		</row>
		<row PageID="ce8ee369-bc71-4e32-8969-067b26c63c00" Language="en-US" PageRevisionID="1" PlainText="PXView and PXCache of the Data View You define a data view with a class derived from the  PXSelectBase  class,         such as  SelectFrom&lt;&gt;.View  in fluent BQL and            PXSelect&lt;&gt;  in traditional BQL. When a graph executes a data view,         the graph creates the following objects: The  PXView  object, which contains the BQL command that corresponds             to the data view The  PXCache&lt;Node&gt;  objects whose type parameter is defined by the             data access classes (DACs) that are used in the BQL command The  PXView  object uses the BQL command to retrieve data from the         database and stores the retrieved data in the  PXCache  object. The data         view stores references to the corresponding  PXView  object and the            PXCache  object of the main DAC of the data view, as shown in the         following diagram. Example of relationships between classes " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="367300b5-647d-fdb4-7093-e2fc9c59b33c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You define a data view with a class derived from the <tt>PXSelectBase</tt> class, such as <tt>SelectFrom&lt;&gt;.View</tt> in fluent BQL and <tt>PXSelect&lt;&gt;</tt> in traditional BQL. When a graph executes a data view, the graph creates the following objects:[anchor|#_e66ab36e-c0b7-4537-8e07-1c21913cc144]
*The <tt>PXView</tt> object, which contains the BQL command that corresponds to the data view
*The <tt>PXCache&lt;Node&gt;</tt> objects whose type parameter is defined by the data access classes (DACs) that are used in the BQL command
The <tt>PXView</tt> object uses the BQL command to retrieve data from the database and stores the retrieved data in the <tt>PXCache</tt> object. The data view stores references to the corresponding <tt>PXView</tt> object and the <tt>PXCache</tt> object of the main DAC of the data view, as shown in the following diagram.[anchor|#_a82d0b44-8749-4cc7-910c-001f4d596762][anchor|#_d09b3994-4d5c-4062-af21-ac44d8654955][image:StudioDeveloperGuide/Images/Graph_View_BQL.png|popup|Example of relationships between classes|450px]]]></column>
		</row>
		<row PageID="acbf0567-2330-4b64-880d-fbe467d80e17" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e4fd176d-3535-dbea-393c-f055cf36f84f" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The system executes a data query in the following stages, which are described in detail below:[anchor|#_b16b6757-7f73-438e-a8c2-3dc22c9da0fb]
*Stage 1: When a developer executes a BQL statement in code, Acumatica Framework configures a delayed query. 
*Stage 2: If a language-integrated query (LINQ) statement is appended to the BQL statement, Microsoft LINQ configures the expression tree, which includes the delayed query.
*Stage 3: When the developer casts the result of the query to a data access class (DAC) or an array of DACs, the system does the following:
**3a: If the result of the query contains the expression tree created by LINQ, the system configures the SQL query tree that corresponds to the LINQ expression tree, and executes the SQL query tree.
**3b: If the result of the query is created only by BQL, the system configures the SQL query tree for the delayed query and executes this query tree.

The whole process is illustrated in the following diagram.[anchor|#_9ca897b3-bb16-4521-a3bb-50eb48492c19][anchor|#_1c04a30b-0a6c-46f4-95b3-ba653aad68bc][image:StudioDeveloperGuide/Images/BqlQueryExecution.png|popup|Data query execution|450px]
==Configuration of a Delayed Query==
In code, you execute a business query language (BQL) statement in one of the following ways:[anchor|#_63d869d0-9116-45b9-ab58-289537eaf763]
*You declare a data view (a <tt>PXSelectBase</tt>-derived class) as a member in a graph, and you specify this data view as the data member of the webpage control. The system uses this data view for basic data manipulation (inserting a data record, updating a data record, and deleting a data record) and executes the data view by calling the <tt>Select()</tt> method.
*You use the {{static}}<tt>Select()</tt> method of a <tt>PXSelectBase</tt>-derived class with a graph object as the parameter.
*You dynamically instantiate a <tt>PXSelectBase</tt>-derived class in code and execute it by using its <tt>Select()</tt> method. (You provide the graph object as a parameter to the class constructor.)
*You instantiate a class derived from the <tt>BqlCommand</tt> class (such as a <tt>Select</tt> class in traditional BQL or <tt>FromSelect</tt> in fluent BQL), create a <tt>PXView</tt> object that uses this <tt>BqlCommand</tt> class, create a graph object, and call one of the view&rsquo;s <tt>Select()</tt> methods.
{br}

When the <tt>Select()</tt> method is executed, Acumatica Framework does the following: [anchor|#_de1559ab-16bb-41cb-b196-d391dd3c8eed]
#Configures a delayed query by creating a <tt>PXDelayedQuery</tt> instance. The <tt>PXDelayedQuery</tt> instance contains a reference to a <tt>PXView</tt> object, which contains references to <tt>PXGraph</tt> and the <tt>BqlCommand</tt> object to be executed.
#Caches the delayed query by using the <tt>PXContext.SetSlot</tt> method. (For details on the slots, see [HelpRoot_Dev_Platform\AD__con_Using_Slots_to_Cache_Data|Use of Slots to Cache Data Objects].)
#Returns a <tt>PXResultset&lt;T&gt;</tt> object whose type parameter is set to the DAC specified as the type parameter of the <tt>SelectFrom</tt> class (in fluent BQL) or as the first type parameter of the <tt>PXSelect</tt> class (in traditional BQL). This result set contains information about the delayed query.
{br}

You can iterate through the result set in a {{foreach}} loop, obtaining either DAC instances or <tt>PXResult&lt;&gt;</tt> instances. A <tt>PXResult&lt;&gt;</tt> instance represents a tuple of joined records from the result set. <tt>PXResult&lt;&gt;</tt> can be cast to any of the DAC types joined in the BQL statement. For more information on the use of the <tt>PXResultset&lt;T&gt;</tt> class, see [HelpRoot_Dev_Platform\AD__how_Process_Resultset|To Process the Result of the Execution of the BQL Statement].
==Configuration of the LINQ Expression Tree==
Because the <tt>PXResultset&lt;T&gt;</tt> class implements the <tt>IQueryable&lt;T&gt;</tt> interface, developers can modify <tt>PXResultset&lt;T&gt;</tt> by using LINQ. If the developer appends LINQ statements to a result set, Microsoft LINQ incorporates the result set as an instance of the <tt>SQLQueryable&lt;T&gt;</tt> class in the LINQ expression tree. The resulting expression tree is an instance of the <tt>SQLQueryable&lt;T&gt;</tt> class, which contains references to an instance of <tt>PXGraph</tt>, Microsoft LINQ expression tree, the base <tt>PXResultset&lt;T&gt;</tt>, and an instance of <tt>PX.Data.SQLTree.SQLQueryProvider</tt>.
==Execution of the Delayed Query==
Once you cast the result of the execution of the <tt>Select()</tt> method to a DAC or an array of DACs, or if you iterate through the DACs in the result by using the {{foreach}} statement, the system performs the following steps:[anchor|#_8a76596f-6fac-4f22-97c5-8a88425f984f]
#The system calls the <tt>PXDelayedQuery.GetRows</tt> method for the delayed query of the result set. This method internally calls the <tt>PXView.Select()</tt> method for the data view referred to in the delayed query.
#If the select delegate is provided, inside the <tt>PXView.Select()</tt> method, the system invokes the select delegate by using the <tt>PXView.InvokeDelegate</tt> method and saves the result in the query cache of the graph. (The query cache stores the result set obtained by the execution of a specific BQL command.)
#Inside the <tt>PXView.Select()</tt> method, the system searches for the requested records in the query cache by using the <tt>PXView.LookupCache</tt> method. If no records are found, the system requests data from the database by using the <tt>PXView.GetResult</tt> method. For details on the retrieval of records from the database, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL]. 
#The system merges the records retrieved from the database or from the query cache with the modified records stored in <tt>PXCache</tt> by using the <tt>PXView.MergeCache</tt> method. For details about the merge, see [HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache].
#The system saves the result of the query in the query cache by using the <tt>PXView.StoreCached</tt> method.
#The system returns the result as a {{List<T>}} type.

==Execution of the LINQ Expression Tree==
Once you iterate over the LINQ expression tree, the system performs the following steps:[anchor|#_730d0ba1-a332-410a-bd14-614fbef710e0]
#The system calls the <tt>SQLQueryProvider.Execute()</tt> method, which builds the {{Remotion.Linq}} expression tree based on the Microsoft LINQ expression tree and calls <tt>Remotion.Linq.QueryModel.Execute()</tt> method with the <tt>PX.Data.SQLTree.SQLinqExecutor</tt> instance as a parameter.
#The system builds the SQL query tree from the <tt>Remotion.Linq.QueryModel</tt> by calling the <tt>SQLinqExecutor.ExecuteCollection&lt;T&gt;()</tt> method. In this method, the system executes the <tt>SQLinqQueryModelVisitor.VisitQueryModel()</tt> method, which does the following:
##Calls the <tt>SQLinqQueryModelVisitor.VisitMainFromClause()</tt> method, which builds the SQL query tree for the BQL statement that corresponds to the base <tt>PXResultset&lt;T&gt;</tt> of the query. This method internally calls the <tt>BqlCommand.GetQueryInternal</tt> method, which is described in [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL#_04b426bc-32b9-4925-8f60-cdad274abeb6|Translation of a BQL Command to an SQL Query Tree].
##Builds the SQL query tree for the rest of the {{Remotion.Linq}} expression tree by calling the methods of <tt>SQLinqQueryModelVisitor</tt> for particular clauses and the columns included in the result of the query. If the system cannot build the SQL query tree for particular elements of the {{Remotion.Linq}} expression tree, the system falls back to the execution of the delayed query for the base BQL statement. For details about the fallback, see [HelpRoot_Dev_Platform\AD__con_Fallback_to_LINQ2Objects|Fallback to the LINQ to Objects Mode].
#Within the <tt>SQLinqExecutor.ExecuteCollection&lt;T&gt;()</tt> method, the system uses the built SQL query tree to request the data from the database. For details about how the SQL query tree is translated to the SQL text that is passed to the database, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL#_7334dc34-5bb3-4884-9b58-20054413bd59|Translation of the SQL Query Tree to
        SQL Text].
#The system merges the records retrieved from the database with the modified records stored in <tt>PXCache</tt>. For details about the merge, see [HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache].
#The system returns the result as a {{List<T>}} type.

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL]
*[HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache]]]></column>
			<column name="PlainText"><![CDATA[Data Query Execution The system executes a data query in the following stages, which are described in detail         below: Stage 1: When a developer executes a BQL statement in code,  Acumatica Framework configures a delayed query.  Stage 2: If a language-integrated query (LINQ) statement is appended to the BQL           statement, Microsoft LINQ configures the expression tree, which includes the delayed           query. Stage 3: When the developer casts the result of the query to a data access class (DAC)           or an array of DACs, the system does the following: 3a: If the result of the query contains the expression tree created by LINQ, the               system configures the SQL query tree that corresponds to the LINQ expression tree, and               executes the SQL query tree. 3b: If the result of the query is created only by BQL, the system configures the SQL               query tree for the delayed query and executes this query tree. The whole process is illustrated in the following diagram. Data query execution Configuration of a Delayed Query In code, you execute a business query language (BQL) statement in one of the following      ways: You declare a data view (a  PXSelectBase -derived class) as a member in a             graph, and you specify this data view as the data member of the webpage control. The             system uses this data view for basic data manipulation (inserting a data record,             updating a data record, and deleting a data record) and executes the data view by             calling the  Select()  method. You use the  static Select()  method of a  PXSelectBase -derived class             with a graph object as the parameter. You dynamically instantiate a  PXSelectBase -derived class in code and             execute it by using its  Select()  method. (You provide the graph             object as a parameter to the class constructor.) You instantiate a class derived from the  BqlCommand  class (such as a                Select  class in traditional BQL or  FromSelect  in             fluent BQL), create a  PXView  object that uses this                BqlCommand  class, create a graph object, and call one of the view's                Select()  methods. When the  Select()  method is executed,  Acumatica Framework         does the following:  Configures a delayed query by creating a  PXDelayedQuery  instance.             The  PXDelayedQuery  instance contains a reference to a                PXView  object, which contains references to                PXGraph  and the  BqlCommand  object to be             executed. Caches the delayed query by using the  PXContext.SetSlot  method.             (For details on the slots, see  Use of Slots to Cache Data Objects.) Returns a  PXResultset<T>  object whose type parameter is set             to the DAC specified as the type parameter of the  SelectFrom  class             (in fluent BQL) or as the first type parameter of the  PXSelect  class             (in traditional BQL). This result set contains information about the delayed query. You can iterate through the result set in a  foreach  loop, obtaining either         DAC instances or  PXResult<>  instances. A            PXResult<>  instance represents a tuple of joined records from the         result set.  PXResult<>  can be cast to any of the DAC types joined         in the BQL statement. For more information on the use of the            PXResultset<T>  class, see  To Process the Result of the Execution of the BQL Statement. Configuration of the LINQ Expression Tree Because the  PXResultset<T>  class implements the            IQueryable<T>  interface, developers can modify            PXResultset<T>  by using LINQ. If the developer appends LINQ         statements to a result set, Microsoft LINQ incorporates the result set as an instance of the            SQLQueryable<T>  class in the LINQ expression tree. The resulting         expression tree is an instance of the  SQLQueryable<T>  class, which         contains references to an instance of  PXGraph , Microsoft LINQ expression         tree, the base  PXResultset<T> , and an instance of            PX.Data.SQLTree.SQLQueryProvider . Execution of the Delayed Query Once you cast the result of the execution of the  Select()  method to a DAC         or an array of DACs, or if you iterate through the DACs in the result by using the            foreach  statement, the system performs the following steps: The system calls the  PXDelayedQuery.GetRows  method for the delayed             query of the result set. This method internally calls the                PXView.Select()  method for the data view referred to in the delayed             query. If the select delegate is provided, inside the  PXView.Select()              method, the system invokes the select delegate by using the                PXView.InvokeDelegate  method and saves the result in the query             cache of the graph. (The query cache stores the result set obtained by the execution of             a specific BQL command.) Inside the  PXView.Select()  method, the system searches for the             requested records in the query cache by using the  PXView.LookupCache              method. If no records are found, the system requests data from the database by using the                PXView.GetResult  method. For details on the retrieval of records             from the database, see  Translation of a BQL Command to SQL.  The system merges the records retrieved from the database or from the query cache with             the modified records stored in  PXCache  by using the                PXView.MergeCache  method. For details about the merge, see  Merge of the Records with PXCache. The system saves the result of the query in the query cache by using the                PXView.StoreCached  method. The system returns the result as a  List<T>  type. Execution of the LINQ Expression Tree Once you iterate over the LINQ expression tree, the system performs the following steps: The system calls the  SQLQueryProvider.Execute()  method, which             builds the  Remotion.Linq  expression tree based on the Microsoft LINQ             expression tree and calls  Remotion.Linq.QueryModel.Execute()  method             with the  PX.Data.SQLTree.SQLinqExecutor  instance as a parameter. The system builds the SQL query tree from the                Remotion.Linq.QueryModel  by calling the                SQLinqExecutor.ExecuteCollection<T>()  method. In this method,             the system executes the  SQLinqQueryModelVisitor.VisitQueryModel()              method, which does the following: Calls the  SQLinqQueryModelVisitor.VisitMainFromClause()  method,                 which builds the SQL query tree for the BQL statement that corresponds to the base                    PXResultset<T>  of the query. This method internally calls                 the  BqlCommand.GetQueryInternal  method, which is described in                    Translation of a BQL Command to an SQL Query Tree. Builds the SQL query tree for the rest of the  Remotion.Linq                  expression tree by calling the methods of  SQLinqQueryModelVisitor                  for particular clauses and the columns included in the result of the query. If the                 system cannot build the SQL query tree for particular elements of the                    Remotion.Linq  expression tree, the system falls back to the                 execution of the delayed query for the base BQL statement. For details about the                 fallback, see  Fallback to the LINQ to Objects Mode. Within the  SQLinqExecutor.ExecuteCollection<T>()  method, the             system uses the built SQL query tree to request the data from the database. For details             about how the SQL query tree is translated to the SQL text that is passed to the             database, see  Translation of the SQL Query Tree to
        SQL Text. The system merges the records retrieved from the database with the modified records             stored in  PXCache . For details about the merge, see  Merge of the Records with PXCache. The system returns the result as a  List<T>  type. ]]></column>
		</row>
		<row PageID="5bc68600-61ab-4a49-958c-da5d732b2ac2" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="b2a4f25e-7b2f-5473-4ce9-3c6eefdb8460" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When the system executes a delayed query and calls the <tt>PXView.GetResult</tt> method to retrieve the data from the database, the system converts the business query language (BQL) command (<tt>PX.Data.BqlCommand</tt>) to the SQL query tree (<tt>PX.Data.SQLTree.Query</tt>), applies the needed restrictions on the SQL query tree (such as company and branch restrictions), and then converts the SQL query tree to the text of the SQL command for the target database type. This process is described in detail in the following sections.{br}{TOC}[anchor|#_04b426bc-32b9-4925-8f60-cdad274abeb6]
==Translation of a BQL Command to an SQL Query Tree==
To request the SQL query tree of the command, the system recursively calls the following methods:[anchor|#_d692456b-ded5-4e14-8612-2f70ed86e140]
#<tt>PXView.GetResult</tt>
# <tt>PXGraph.ProviderSelect</tt>
# <tt>PXDatabaseProviderBase.Select</tt>
# <tt>BqlCommand.GetQuery</tt>
{br}

The <tt>BqlCommand.GetQuery</tt> method calls the <tt>BqlCommand.GetQueryInternal</tt> method, which uses other methods as follows to prepare the SQL query tree: {br}

[anchor|#_6ca0d24a-f7fd-4587-8927-270dfc3120e6]
#If the BQL command contains aggregation, the <tt>BqlCommand.AppendAggregatedFields</tt> method appends to a new <tt>Query</tt> instance the SQL expressions (<tt>PX.Data.SQL.SQLExpression</tt>) that correspond to the fields that are surrounded with appropriate aggregation functions. If the BQL command does not contain aggregation, the <tt>BqlCommand.AppendFields</tt> method appends to a new <tt>Query</tt> instance the SQL expressions that correspond to the fields to be selected. The fields to be selected are the DAC fields that subscribe to the <tt>OnCommandPreparing</tt> event and are not restricted by <tt>PXFieldScope</tt>. 
#For each {{Join}} clause, the <tt>IBqlJoin.AppendQuery</tt> method adds to the <tt>Query</tt> instance the <tt>Joiner</tt> instance that corresponds to the {{Join}} clause.
#:The <tt>IBqlJoin.AppendQuery</tt> method obtains the type of {{Join}} and, for all classes in the <tt>On</tt> clause that implement the <tt>IBqlCreator</tt> interface, successively executes the <tt>IBqlCreator.AppendExpression</tt> method, starting from the <tt>On</tt> class and then proceeding with enclosed classes, such as the <tt>Where</tt> classes and comparison classes. For the DAC fields (<tt>IBqlField</tt>-derived classes), the <tt>BqlCommand.GetSingleExpression</tt> method obtains the SQL expression.
#For all classes in the {{Where}} and {{GroupBy}} clauses that implement the <tt>IBqlCreator</tt> interface, the system successively executes the <tt>IBqlCreator.AppendExpression</tt> method, which appends to the <tt>Query</tt> instance the SQL expression that corresponds to the classes. For the DAC fields (<tt>IBqlField</tt>-derived classes), the <tt>BqlCommand.GetSingleExpression</tt> method obtains the SQL expression.
#The <tt>IBqlOrderBy.AppendQuery</tt> method adds to the <tt>Query</tt> instance the list of <tt>OrderSegment</tt> instances that corresponds to the {{OrderBy}} clause.
#:For each sorting class (a <tt>IBqlSortColumn</tt>-derived class) in the <tt>OrderBy</tt> clause, the <tt>IBqlSortColumn.AppendQuery</tt> method adds to the <tt>Query</tt> instance the <tt>OrderSegment</tt> instance that corresponds to the sorting column. For the DAC fields (<tt>IBqlField</tt>-derived classes), the <tt>BqlCommand.GetSingleExpression</tt> method obtains the SQL expression. If the original BQL statement does not specify ordering, the system adds to the <tt>Query</tt> instance sorting by the DAC key fields (in ascending order).
{br}

The following diagram shows the conversion of a BQL command to an SQL query tree.[anchor|#_acc0abf0-a2b9-4a82-9284-b425849e51bb][anchor|#_e32946e7-fd14-4c5b-86a1-7287c6a2f569][image:StudioDeveloperGuide/Images/BqlToSqlTreeQuery.png|popup|Conversion of a BQL command to an SQL query tree|450px]
==SQL Tree Expression of a Field==
To obtain the SQL tree expression of each field of the BQL command, the <tt>BqlCommand</tt> instance creates a <tt>PXCache</tt> instance that corresponds to the data access class (DAC) to which the field belongs. The <tt>PXCache</tt> instance generates the <tt>OnCommandPreparing</tt> event with the specified <tt>PXDBOperation</tt> type (which specifies the type of the database operation). The attribute assigned to the DAC field (that is, the attribute that implements the <tt>IPXCommandPreparingSubscriber</tt> interface) handles the event and returns the <tt>PX.Data.SQLTree.SQLExpression</tt> instance that corresponds to the field or to the BQL statement that is defined by the field attribute. (For example, the <tt>PXDBCalced</tt> and <tt>PXDBScalar</tt> attributes define BQL statements.){br}

The following diagram shows how <tt>BqlCommand</tt> obtains the SQL tree expression for the fields of a BQL command.[anchor|#_dfd9cbea-2bde-41b1-a0e2-3d771f9087aa][anchor|#_960e6fff-dcdc-479d-9698-2e70da40b2be][image:StudioDeveloperGuide/Images/BQL_RequestSqlExpression.png|popup|Retrieval of the SQL tree expression for the fields of a BQL command|450px][anchor|#_ff6436a7-d8a9-43c8-9201-d5ea9afbe2d5]
==Translation of a BQL Command with Parameters to an SQL Query Tree==
Before the system requests the SQL query tree of a BQL command, the <tt>PXView</tt> object retrieves the values of the parameters used in the query as follows:[anchor|#_6a1fd88a-b93d-4d66-823d-ae975c513191]
*For a field with <tt>FromCurrent</tt> appended (in fluent BQL) or specified in the <tt>Current</tt> parameter (in traditional BQL), the <tt>PXView</tt> object retrieves the field value from the <tt>Current</tt> object of the <tt>PXCache</tt> object. If the current field value is {{null}}, the <tt>PXView</tt> object triggers the <tt>FieldDefaulting</tt> event handlers and retrieves the default value from the <tt>PXDefault</tt> attribute value (if any). 
*:((({S:Hint}The default value is not retrieved if <tt>FromCurrent.NoDefault</tt> is appended to the field (in fluent BQL) or if the <tt>Current2</tt> parameter is used (in traditional BQL).
)))
*For a field with <tt>AsOptional</tt> appended (in fluent BQL) or specified in the <tt>Optional</tt> parameter, if the explicit field value is specified, the <tt>PXView</tt> object triggers the <tt>FieldUpdating</tt> event, whose handlers can transform the external presentation of the field value to an internal value (for example, transform {{ProductCD}} to {{ProductID}}). If the field value is not specified, the <tt>PXView</tt> object retrieves the field value from the <tt>Current</tt> object of the <tt>PXCache</tt> object. If the current field value is {{null}}, the <tt>PXView</tt> object triggers the <tt>FieldDefaulting</tt> event and retrieves the default value from the <tt>PXDefault</tt> attribute value (if any).
*:((({S:Hint}The default value is not retrieved if <tt>AsOptional.NoDefault</tt> is appended to the field (in fluent BQL) or if the <tt>Optional2</tt> parameter is used.
)))
{br}

When <tt>BqlCommand</tt> creates the SQL query tree that corresponds to the BQL command, <tt>IBqlCreator.AppendExpression</tt> (which is implemented by the <tt>ParameterBase&lt;Field&gt;</tt> class) includes the parameters in the SQL query tree. After <tt>BqlCommand</tt> has created the SQL query tree that corresponds to the BQL command, the system inserts into the SQL query tree the actual values of the parameters retrieved by <tt>PXView</tt>. [anchor|#_7334dc34-5bb3-4884-9b58-20054413bd59]
==Translation of the SQL Query Tree to SQL Text==A <tt>PXGraph</tt> instance stores information about the target database type in its <tt>SqlDialect</tt> property. <tt>SQLTree.Query</tt> has the <tt>Connection</tt> property, which is responsible for the conversion of the SQL query tree to the SQL text in the format of the target database. To convert the SQL query tree to text, the system does the following:[anchor|#_1e5d0daa-4f7d-4176-aee3-223f767a4f55]
#Calls the <tt>SQLDialect.GetConnection</tt> method of the graph instance to retrieve the needed <tt>SQLTree.Connection</tt>.
#Passes this <tt>Connection</tt> instance to the <tt>SQLTree.Query.SQLQuery</tt> method, which converts the SQL query tree to the text for Microsoft SQL or MySQL, depending on the passed <tt>Connection</tt>.

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]]]></column>
			<column name="PlainText"><![CDATA[Translation of a BQL Command to SQL When the system executes a delayed query and calls the  PXView.GetResult          method to retrieve the data from the database, the system converts the business query         language (BQL) command ( PX.Data.BqlCommand ) to the SQL query tree           ( PX.Data.SQLTree.Query ), applies the needed restrictions on the SQL         query tree (such as company and branch restrictions), and then converts the SQL query tree         to the text of the SQL command for the target database type. This process is described in         detail in the following sections. Translation of a BQL Command to an SQL Query Tree To request the SQL query tree of the command, the system recursively calls the following           methods: PXView.GetResult PXGraph.ProviderSelect PXDatabaseProviderBase.Select BqlCommand.GetQuery The  BqlCommand.GetQuery  method calls the            BqlCommand.GetQueryInternal  method, which uses other methods as follows         to prepare the SQL query tree:  If the BQL command contains aggregation, the                BqlCommand.AppendAggregatedFields  method appends to a new                Query  instance the SQL  expressions               ( PX.Data.SQL.SQLExpression ) that correspond to the fields that are             surrounded with appropriate aggregation functions. If the BQL command does not contain             aggregation, the  BqlCommand.AppendFields  method appends to a new                Query  instance the SQL  expressions that correspond to the fields             to be selected. The fields to be selected are the DAC fields that subscribe to the                OnCommandPreparing  event and are not restricted by                PXFieldScope .  For each  Join  clause, the  IBqlJoin.AppendQuery              method adds to the  Query  instance the  Joiner              instance that corresponds to the  Join  clause. The                  IBqlJoin.AppendQuery  method obtains the type of                  Join  and, for all classes in the  On  clause that               implement the  IBqlCreator  interface, successively executes the                  IBqlCreator.AppendExpression  method, starting from the                  On  class and then proceeding with enclosed classes, such as the                  Where  classes and comparison classes. For the DAC fields                 ( IBqlField -derived classes), the                  BqlCommand.GetSingleExpression  method obtains the SQL               expression. For all classes in the  Where  and  GroupBy  clauses             that implement the  IBqlCreator  interface, the system successively             executes the  IBqlCreator.AppendExpression  method, which appends to             the  Query  instance the SQL  expression that corresponds to the             classes. For the DAC fields ( IBqlField -derived classes), the                BqlCommand.GetSingleExpression  method obtains the SQL             expression. The  IBqlOrderBy.AppendQuery  method adds to the                Query  instance the list of  OrderSegment              instances that corresponds to the  OrderBy  clause. For each sorting               class (a  IBqlSortColumn -derived class) in the                  OrderBy  clause, the  IBqlSortColumn.AppendQuery                method adds to the  Query  instance the                  OrderSegment  instance that corresponds to the sorting column. For               the DAC fields ( IBqlField -derived classes), the                  BqlCommand.GetSingleExpression  method obtains the SQL expression.               If the original BQL statement does not specify ordering, the system adds to the                  Query  instance sorting by the DAC key fields (in ascending               order). The following diagram shows the conversion of a BQL command to an SQL query tree. Conversion of a BQL command to an SQL query tree SQL Tree Expression of a Field To obtain the SQL tree expression of each field of the BQL command, the            BqlCommand  instance creates a  PXCache  instance that         corresponds to the data access class (DAC) to which the field belongs. The            PXCache  instance generates the  OnCommandPreparing          event with the specified  PXDBOperation  type (which specifies the type of         the database operation). The attribute assigned to the DAC field (that is, the attribute         that implements the  IPXCommandPreparingSubscriber  interface) handles the         event and returns the  PX.Data.SQLTree.SQLExpression  instance that         corresponds to the field or to the BQL statement that is defined by the field attribute.         (For example, the  PXDBCalced  and  PXDBScalar  attributes         define BQL statements.) The following diagram shows how  BqlCommand  obtains the SQL tree         expression for the fields of a BQL command. Retrieval of the SQL tree expression for the fields of a BQL command Translation of a BQL Command with Parameters to an SQL Query Tree Before the system requests the SQL query tree of a BQL command, the            PXView  object retrieves the values of the parameters used in the query         as follows: For a field with  FromCurrent  appended (in fluent BQL) or specified             in the  Current  parameter (in traditional BQL), the                PXView  object retrieves the field value from the                Current  object of the  PXCache  object. If the             current field value is  null , the  PXView  object             triggers the  FieldDefaulting  event handlers and retrieves the default             value from the  PXDefault  attribute value (if any).  The default               value is not retrieved if  FromCurrent.NoDefault  is appended to the               field (in fluent BQL) or if the  Current2  parameter is used (in               traditional BQL). For a field with  AsOptional  appended (in fluent BQL) or specified             in the  Optional  parameter, if the explicit field value is specified,             the  PXView  object triggers the  FieldUpdating              event, whose handlers can transform the external presentation of the field value to an             internal value (for example, transform  ProductCD  to                ProductID ). If the field value is not specified, the                PXView  object retrieves the field value from the                Current  object of the  PXCache  object. If the             current field value is  null , the  PXView  object             triggers the  FieldDefaulting  event and retrieves the default value             from the  PXDefault  attribute value (if any). The default value               is not retrieved if  AsOptional.NoDefault  is appended to the field               (in fluent BQL) or if the  Optional2  parameter is used. When  BqlCommand  creates the SQL query tree that corresponds to the BQL         command,  IBqlCreator.AppendExpression  (which is implemented by the            ParameterBase<Field>  class) includes the parameters in the SQL query         tree. After  BqlCommand  has created the SQL query tree that corresponds to         the BQL command, the system inserts into the SQL query tree the actual values of the         parameters retrieved by  PXView .  Translation of the SQL Query Tree to         SQL Text A  PXGraph  instance stores information about the target       database type in its  SqlDialect  property.  SQLTree.Query        has the  Connection  property, which is responsible for the conversion of the       SQL query tree to the SQL text in the format of the target database. To convert the SQL query       tree to text, the system does the following: Calls the  SQLDialect.GetConnection  method of the graph instance to           retrieve the needed  SQLTree.Connection . Passes this  Connection  instance to the              SQLTree.Query.SQLQuery  method, which converts the SQL query tree to           the text for Microsoft SQL or MySQL, depending on the passed            Connection . ]]></column>
		</row>
		<row PageID="0ff0b223-66ff-4b55-af97-fe88580ec6e5" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="55bb37d7-6e0a-434d-2303-9e44f395683a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
For the queries defined with business query language (BQL) or with BQL and LINQ, the system merges the records retrieved from the database with the modified records stored in <tt>PXCache</tt> as follows:{br}

[anchor|#_6eda37be-fde0-4a41-998b-c92941627892]
#If the query is read-only, the result set is not merged with any <tt>PXCache</tt> object. The system returns the data records as they are currently stored in the database.
#:((({S:Hint}A query is read-only if the <tt>IsReadOnly</tt> property of the underlying <tt>PXView</tt> object is {{true}}. For example, the traditional BQL statements that use aggregation or are based on one of the <tt>PXSelectReadonly</tt> classes are read-only. The fluent BQL statements that have <tt>.ReadOnly</tt> appended are read-only.
)))
#If the query is not read-only and contains filtering by data access class (DAC) fields by using LINQ (that is, only the values in specific columns of the database tables are returned in the results of the query), the system checks whether the primary key fields of the primary DAC (the first DAC in the BQL statement) are returned in the results of the query. If the primary key fields are not in the results, no merge with any <tt>PXCache</tt> object is performed. If all primary key fields are in the results, the result set is merged with the <tt>PXCache</tt> object that corresponds to the primary DAC.
#If the query is not read-only, does not contain filtering of DAC fields by using LINQ, and does not contain joins, the result set is merged with the contents of the appropriate <tt>PXCache</tt> object, and the system returns the result set updated with the modifications stored in <tt>PXCache</tt>.
#If the query is not read-only, does not contain filtering by DAC fields by using LINQ, and joins data from multiple tables, the result set is merged with only the <tt>PXCache</tt> object that corresponds to the first table of the BQL statement. The <tt>PXResultset&lt;&gt;</tt> object, which represents the result set, contains objects of the generic <tt>PXResult&lt;&gt;</tt> type. This type can be cast to the data access classes (DACs) that represent the joined tables. The instance of the primary DAC to which <tt>PXResult&lt;&gt;</tt> is cast contains the records from the database that are updated with the modifications stored in <tt>PXCache</tt>. Casting <tt>PXResult&lt;&gt;</tt> to a joined DAC returns the instance that contains values from the database and has no relation with the <tt>PXCache</tt> instances of the corresponding DAC types.
{br}

The following diagram illustrates the database records being merged with <tt>PXCache</tt>.[anchor|#_4f4366d6-763c-4ef8-8d14-c4edcd1e6108][anchor|#_08b99e51-d44a-403f-88ce-d51db37bba2c][image:StudioDeveloperGuide/Images/BQL_MergeWithDB.png|popup|Merge with <tt>PXCache</tt>|450px]
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]]]></column>
			<column name="PlainText"><![CDATA[Merge of the Records with PXCache For the queries defined with business query language (BQL) or with BQL and LINQ, the system         merges the records retrieved from the database with the modified records stored in            PXCache  as follows: If the query is read-only, the result set is not merged with any                PXCache  object. The system returns the data records as they are             currently stored in the database. A query is read-only if the                  IsReadOnly  property of the underlying  PXView                object is  true . For example, the traditional BQL statements that use               aggregation or are based on one of the  PXSelectReadonly  classes are               read-only. The fluent BQL statements that have  .ReadOnly  appended               are read-only. If the query is not read-only and contains filtering by data access class (DAC) fields             by using LINQ (that is, only the values in specific columns of the database tables are             returned in the results of the query), the system checks whether the primary key fields             of the primary DAC (the first DAC in the BQL statement) are returned in the results of             the query. If the primary key fields are not in the results, no merge with any                PXCache  object is performed. If all primary key fields are in the             results, the result set is merged with the  PXCache  object that             corresponds to the primary DAC. If the query is not read-only, does not contain filtering of DAC fields by using LINQ,             and does not contain joins, the result set is merged with the contents of the             appropriate  PXCache  object, and the system returns the result set             updated with the modifications stored in  PXCache . If the query is not read-only, does not contain filtering by DAC fields by using LINQ,             and joins data from multiple tables, the result set is merged with only the                PXCache  object that corresponds to the first table of the BQL             statement. The  PXResultset<>  object, which represents the             result set, contains objects of the generic  PXResult<>  type.             This type can be cast to the data access classes (DACs) that represent the joined             tables. The instance of the primary DAC to which  PXResult<>  is             cast contains the records from the database that are updated with the modifications             stored in  PXCache . Casting  PXResult<>  to a             joined DAC returns the instance that contains values from the database and has no             relation with the  PXCache  instances of the corresponding DAC             types. The following diagram illustrates the database records being merged with            PXCache . Merge with  PXCache ]]></column>
		</row>
		<row PageID="b5126e1e-70d9-408d-bcf9-e625a38a052e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ae88f49b-a073-8388-eeb5-86c4e7cd2e3c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can learn the main differences between the queries defined with fluent business query language (BQL), traditional BQL, and language-integrated query (LINQ).[anchor|#_ecd2097d-c0da-40cf-9f3f-dd49b282272b]
===Comparison of Fluent BQL, Traditional BQL, and LINQ===
{| class="checklist" | width="100%" 
|- 
!width="40%" ! Characteristic
!width="20%" ! Fluent BQL
!width="20%" ! Traditional BQL
!width="20%" ! LINQ
|- 
| The queries can be used to define data views in graphs.
| Yes
| Yes
| No
|- 
| The queries can be defined in code.
| Yes
| Yes
| Yes
|- 
| The queries can be defined in DAC field attributes.
| Yes
| Yes
| No
|- 
| DACs are used to define database tables in the queries.
| Yes
| Yes
| Yes
|- 
| The queries can be used for dynamic query building.
| Yes
| Yes
| Yes
|- 
| The queries can be parsed and modified by the direct use of reflection—that is, by {{Type.GetGenericArguments()}}.
| No
| Yes
| No
|- 
| Clauses (such as <tt>Join</tt>, <tt>Where</tt>, <tt>Aggregate</tt>, <tt>OrderBy</tt>, and <tt>On</tt>) can be used separately of the query.
| No
| Yes
| No
|- 
| The query language includes numbered classes (such as <tt>Select2</tt> and <tt>Select6</tt>).
| No
| Yes
| No
|- 
| Each subsequent element of the query is passed as a generic parameter of the previous one.
| No
| Yes
| No
|- 
| To create a query, a developer needs to select a suitable command overload.
| No
| Yes
| No
|- 
| IntelliSense can offer continuations that are relevant for the current query state.
| Yes
| No
| Yes
|- 
| The queries use strongly typed expressions, which makes compile-time type checks possible.
| Yes
| No
| Yes
|- 
| The queries can contain explicit brackets in conditions.
| Yes
| No; the <tt>Where</tt> clause can be used instead
| Yes
|- 
| You can specify particular columns of the tables to be selected.
| Yes; you have to use <tt>PXFieldScope</tt>
| Yes; you have to use <tt>PXFieldScope</tt>
| Yes
|- 
| The query is not executed until it is iterated over.
| Yes
| Yes
| Yes
|}
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents]
*[HelpRoot_Dev_Platform\AD__mng_Fluent_BQL|Creating Fluent BQL Queries]
*[HelpRoot_Dev_Platform\AD__mng_Traditional_BQL|Creating Traditional BQL Queries]]]></column>
			<column name="PlainText"><![CDATA[Comparison of Fluent BQL, Traditional BQL, and LINQ In this topic, you can learn the main differences between the queries defined with fluent     business query language (BQL), traditional BQL, and language-integrated query (LINQ). Comparison of Fluent BQL, Traditional BQL, and LINQ Characteristic Fluent BQL Traditional BQL LINQ The queries can be used to define data views in graphs. Yes Yes No The queries can be defined in code. Yes Yes Yes The queries can be defined in DAC field attributes. Yes Yes No DACs are used to define database tables in the queries. Yes Yes Yes The queries can be used for dynamic query building. Yes Yes Yes The queries can be parsed and modified by the direct use of reflection—that is, by            Type.GetGenericArguments() . No Yes No Clauses (such as  Join ,  Where ,            Aggregate ,  OrderBy , and  On ) can          be used separately of the query. No Yes No The query language includes numbered classes (such as  Select2  and            Select6 ). No Yes No Each subsequent element of the query is passed as a generic parameter of the previous          one. No Yes No To create a query, a developer needs to select a suitable command overload. No Yes No IntelliSense can offer continuations that are relevant for the current query          state. Yes No Yes The queries use strongly typed expressions, which makes compile-time type checks          possible. Yes No Yes The queries can contain explicit brackets in conditions. Yes No; the  Where  clause can be used instead Yes You can specify particular columns of the tables to be selected. Yes; you have to use  PXFieldScope Yes; you have to use  PXFieldScope Yes The query is not executed until it is iterated over. Yes Yes Yes ]]></column>
		</row>
		<row PageID="67456943-7705-4522-9e0a-967251cc841c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="dadf9326-b3e8-62a1-8f8f-f6270df03679" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The fluent business query language (BQL) library defines the equivalents of traditional BQL classes listed in the following tables.{br}

You can use the converter from BQL to fluent BQL available on GitHub ([https://github.com/Acumatica/]) to convert the previously defined BQL queries to fluent BQL.{br}{TOC}
==Data View Declarations==((({S:Hint}All data views that contain aggregating are read-only.
)))[anchor|#_4bb6d246-b083-44b0-a826-b60d00f39575]
{| class="checklist" | width="100%" 
|- 
!width="66%" ! Fluent BQL
!width="33%" ! Traditional BQL
|- 
| <tt>SelectFrom&lt;&gt;.View</tt>
|  <tt>PXSelect&lt;&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly&lt;&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.OrderBy&lt;&gt;.View</tt>
|  <tt>PXSelectOrderBy&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly3&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.AggregateTo&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectGroupBy&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectGroupByOrderBy&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.View</tt>
|  <tt>PXSelect&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.OrderBy&lt;&gt;.View</tt>
|  <tt>PXSelect&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.AggregateTo&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectGroupBy&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectGroupBy&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.View</tt>
|  <tt>PXSelectJoin&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly2&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.OrderBy&lt;&gt;.View</tt>
|  <tt>PXSelectJoinOrderBy&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly3&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.AggregateTo&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectJoinGroupBy&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectGroupByOrderBy&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.View</tt>
|  <tt>PXSelectJoin&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly2&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.OrderBy&lt;&gt;.View</tt>
|  <tt>PXSelectJoin&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectReadonly2&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.AggregateTo&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectJoinGroupBy&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.View.ReadOnly</tt>
|  <tt>PXSelectJoinGroupBy&lt;,,,,&gt;</tt>
|}
==Select Commands==[anchor|#_6254712c-00c6-4fe4-8dec-8a5d923fc29f]
{| class="checklist" | width="100%" 
|- 
!width="66%" ! Fluent BQL
!width="33%" ! Traditional BQL
|- 
| <tt>SelectFrom&lt;&gt;</tt>
|  <tt>Select&lt;&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.OrderBy&lt;&gt;</tt>
|  <tt>Select3&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.AggregateTo&lt;&gt;</tt>
|  <tt>Select4&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;</tt>
|  <tt>Select6&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;</tt>
|  <tt>Select&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.OrderBy&lt;&gt;</tt>
|  <tt>Select&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.AggregateTo&lt;&gt;</tt>
|  <tt>Select4&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;</tt>
|  <tt>Select4&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;</tt>
|  <tt>Select2&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.OrderBy&lt;&gt;</tt>
|  <tt>Select3&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.AggregateTo&lt;&gt;</tt>
|  <tt>Select5&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;</tt>
|  <tt>Select6&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;</tt>
|  <tt>Select2&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.OrderBy&lt;&gt;</tt>
|  <tt>Select2&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.AggregateTo&lt;&gt;</tt>
|  <tt>Select5&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;</tt>
|  <tt>Select5&lt;,,,,&gt;</tt>
|}
==Search Commands==[anchor|#_95502182-e7ad-4e71-8ebe-cc946d58f211]
{| class="checklist" | width="100%" 
|- 
!width="66%" ! Fluent BQL
!width="33%" ! Traditional BQL
|- 
| <tt>SelectFrom&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search&lt;&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search3&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.AggregateTo&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search4&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search6&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.AggregateTo&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search4&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.Where&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search4&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.SearchFor&lt;&gt;</tt>
|  <tt>Search2&lt;,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search3&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.AggregateTo&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search5&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search6&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search2&lt;,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search2&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.AggregateTo&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search5&lt;,,,&gt;</tt>
|- 
|  <tt>SelectFrom&lt;&gt;.&#91;Joins&#93;.Where&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;.SearchFor&lt;&gt;</tt>
|  <tt>Search5&lt;,,,,&gt;</tt>
|}
==Join Clauses==[anchor|#_81971327-222f-4386-a0b4-c9d14304ad54]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>.InnerJoin&lt;Table&gt;.On&lt;&gt;</tt>
|  <tt>InnerJoin&lt;Table,On&gt;</tt>
|- 
|  <tt>.InnerJoin&lt;Table&gt;.On&lt;&gt;.NextJoin</tt>
|  <tt>InnerJoin&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.InnerJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly</tt>
|  <tt>InnerJoinSingleTable&lt;Table,On&gt;</tt>
|- 
|  <tt>.InnerJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly.NextJoin</tt>
|  <tt>InnerJoinSingleTable&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.LeftJoin&lt;Table&gt;.On&lt;&gt;</tt>
|  <tt>LeftJoin&lt;Table,On&gt;</tt>
|- 
|  <tt>.LeftJoin&lt;Table&gt;.On&lt;&gt;.NextJoin</tt>
|  <tt>LeftJoin&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.LeftJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly</tt>
|  <tt>LeftJoinSingleTable&lt;Table,On&gt;</tt>
|- 
|  <tt>.LeftJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly.NextJoin</tt>
|  <tt>LeftJoinSingleTable&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.RightJoin&lt;Table&gt;.On&lt;&gt;</tt>
|  <tt>RightJoin&lt;Table,On&gt;</tt>
|- 
|  <tt>.RightJoin&lt;Table&gt;.On&lt;&gt;.NextJoin</tt>
|  <tt>RightJoin&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.RightJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly</tt>
|  <tt>RightJoinSingleTable&lt;Table,On&gt;</tt>
|- 
|  <tt>.RightJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly.NextJoin</tt>
|  <tt>RightJoinSingleTable&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.FullJoin&lt;Table&gt;.On&lt;&gt;</tt>
|  <tt>FullJoin&lt;Table,On&gt;</tt>
|- 
|  <tt>.FullJoin&lt;Table&gt;.On&lt;&gt;.NextJoin</tt>
|  <tt>FullJoin&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.FullJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly</tt>
|  <tt>FullJoinSingleTable&lt;Table,On&gt;</tt>
|- 
|  <tt>.FullJoin&lt;Table&gt;.On&lt;&gt;.SingleTableOnly.NextJoin</tt>
|  <tt>FullJoinSingleTable&lt;Table,On,NextJoin&gt;</tt>
|- 
|  <tt>.CrossJoin&lt;Table&gt;</tt>
|  <tt>CrossJoin&lt;Table&gt;</tt>
|- 
|  <tt>.CrossJoin&lt;Table&gt;.NextJoin</tt>
|  <tt>CrossJoin&lt;Table,NextJoin&gt;</tt>
|- 
|  <tt>.CrossJoin&lt;Table&gt;.SingleTableOnly</tt>
|  <tt>CrossJoinSingleTable&lt;Table&gt;</tt>
|- 
|  <tt>.CrossJoin&lt;Table&gt;.SingleTableOnly.NextJoin</tt>
|  <tt>CrossJoinSingleTable&lt;Table,NextJoin&gt;</tt>
|}
==Where Clause==[anchor|#_033169a9-03e8-490c-b557-0b6110a6f0c0]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>.Where&lt;UnaryOperator&gt;</tt>
|  <tt>Where&lt;UnaryOperator&gt;</tt>
|- 
|  <tt>.Where&lt;Operand.Comparison&gt;</tt>
|  <tt>Where&lt;Operand,Comparison&gt;</tt>
|- 
|  <tt>.Where&lt;Operand.Comparison.NextOperator&gt;</tt>
|  <tt>Where&lt;Operand,Comparison,NextOperator&gt;</tt>
|- 
|  <tt>.Where&lt;UnaryOperator.NextOperator&gt;</tt>
|  <tt>Where2&lt;UnaryOperator,NextOperator&gt;</tt>
|}
==Aggregate Clause==[anchor|#_8a9ba045-c388-4181-b8e9-d2698bda79f7]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>.AggregateTo&lt;Function&gt;</tt>
|  <tt>Aggregate&lt;Function&gt;</tt>
|- 
|  <tt>.AggregateTo&lt;TFunctions&gt;.THaving</tt>
|  <tt>Aggregate&lt;TFunctions,THaving&gt;</tt>
|- 
|  <tt>.Having&lt;TCondition&gt;</tt>
|  <tt>Having&lt;TCondition&gt;</tt>
|- 
|  <tt>GroupBy&lt;Field&gt;</tt>
|  <tt>GroupBy&lt;Field&gt;</tt>
|- 
|  <tt>GroupBy&lt;Field&gt;, NextAggregate</tt>
|  <tt>GroupBy&lt;Field,NextAggregate&gt;</tt>
|- 
|  <tt>Max&lt;Field&gt;</tt>
|  <tt>Max&lt;Field&gt;</tt>
|- 
|  <tt>Max&lt;Field&gt;, NextAggregate</tt>
|  <tt>Max&lt;Field,NextAggregate&gt;</tt>
|- 
|  <tt>Min&lt;Field&gt;</tt>
|  <tt>Min&lt;Field&gt;</tt>
|- 
|  <tt>Min&lt;Field&gt;, NextAggregate</tt>
|  <tt>Min&lt;Field,NextAggregate&gt;</tt>
|- 
|  <tt>Sum&lt;Field&gt;</tt>
|  <tt>Sum&lt;Field&gt;</tt>
|- 
|  <tt>Sum&lt;Field&gt;, NextAggregate</tt>
|  <tt>Sum&lt;Field,NextAggregate&gt;</tt>
|- 
|  <tt>Avg&lt;Field&gt;</tt>
|  <tt>Avg&lt;Field&gt;</tt>
|- 
|  <tt>Avg&lt;Field&gt;, NextAggregate</tt>
|  <tt>Avg&lt;Field,NextAggregate&gt;</tt>
|- 
|  <tt>Count</tt>
|  <tt>Count</tt>
|- 
|  <tt>Count&lt;Field&gt;</tt>
|  <tt>Count&lt;Field&gt;</tt>
|}
==OrderBy Clause==[anchor|#_60f4a753-c02b-403e-be39-14378aa7a8f0]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>.OrderBy&lt;List&gt;</tt>
|  <tt>OrderBy&lt;List&gt;</tt>
|- 
|  <tt>Field.Asc</tt>
|  <tt>Asc&lt;Field&gt;</tt>
|- 
|  <tt>Field.Asc, NextSort</tt>
|  <tt>Asc&lt;Field,NextSort&gt;</tt>
|- 
|  <tt>Field.Desc</tt>
|  <tt>Desc&lt;Field&gt;</tt>
|- 
|  <tt>Field.Desc, NextSort</tt>
|  <tt>Desc&lt;Field,NextSort&gt;</tt>
|}
==Parameters==[anchor|#_26d4df1b-49a8-4ccf-9969-e88ffca8ba5d]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>Field.FromCurrent</tt>
|  <tt>Current&lt;Field&gt;</tt>
|- 
|  <tt>Field.FromCurrent.NoDefault</tt>
|  <tt>Current2&lt;Field&gt;</tt>
|- 
|  <tt>Field.AsOptional</tt>
|  <tt>Optional&lt;Field&gt;</tt>
|- 
|  <tt>Field.AsOptional.NoDefault</tt>
|  <tt>Optional2&lt;Field&gt;</tt>
|- 
|  <tt>@P.AsBool</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{bool}} type
|- 
| <tt>@P.AsByte</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{byte}} type
|- 
| <tt>@P.AsShort</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{short}} type
|- 
| <tt>@P.AsInt</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{int}} type
|- 
| <tt>@P.AsLong</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{long}} type
|- 
| <tt>@P.AsFloat</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{float}} type
|- 
| <tt>@P.AsDouble</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{double}} type
|- 
| <tt>@P.AsDecimal</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{decimal}} type
|- 
| <tt>@P.AsGuid</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{Guid}} type
|- 
| <tt>@P.AsDateTime</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{DateTime}} type
|- 
| <tt>@P.AsString</tt>
|  <tt>Required&lt;Field&gt;</tt>, where the property field of <tt>Field</tt> has the {{string}} type
|- 
| <tt>Argument.AsBool</tt>
|  <tt>Argument&lt;bool?&gt;</tt>
|- 
|  <tt>Argument.AsByte</tt>
|  <tt>Argument&lt;byte?&gt;</tt>
|- 
|  <tt>Argument.AsShort</tt>
|  <tt>Argument&lt;short?&gt;</tt>
|- 
|  <tt>Argument.AsInt</tt>
|  <tt>Argument&lt;int?&gt;</tt>
|- 
|  <tt>Argument.AsLong</tt>
|  <tt>Argument&lt;long?&gt;</tt>
|- 
|  <tt>Argument.AsFloat</tt>
|  <tt>Argument&lt;float?&gt;</tt>
|- 
|  <tt>Argument.AsDouble</tt>
|  <tt>Argument&lt;double?&gt;</tt>
|- 
|  <tt>Argument.AsDecimal</tt>
|  <tt>Argument&lt;decimal?&gt;</tt>
|- 
|  <tt>Argument.AsGuid</tt>
|  <tt>Argument&lt;Guid?&gt;</tt>
|- 
|  <tt>Argument.AsDateTime</tt>
|  <tt>Argument&lt;DateTime?&gt;</tt>
|- 
|  <tt>Argument.AsString</tt>
|  <tt>Argument&lt;string&gt;</tt>
|}
==Logical Operators and Brackets==[anchor|#_0ccc8bcc-ab61-4fbd-a31e-883e79b7d474]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>And&lt;UnaryOperator&gt;</tt>
|  <tt>And&lt;UnaryOperator&gt;</tt>
|- 
|  <tt>And&lt;Operand.Comparison&gt;</tt>
|  <tt>And&lt;Operand,Comparison&gt;</tt>
|- 
|  <tt>And&lt;Operand.Comparison&gt;.NextOperator</tt>
|  <tt>And&lt;Operand,Comparison,NextOperator&gt;</tt>
|- 
|  <tt>And&lt;UnaryOperator.NextOperator&gt;</tt>
|  <tt>And2&lt;UnaryOperator,NextOperator&gt;</tt>
|- 
|  <tt>Or&lt;UnaryOperator&gt;</tt>
|  <tt>Or&lt;UnaryOperator&gt;</tt>
|- 
|  <tt>Or&lt;Operand.Comparison&gt;</tt>
|  <tt>Or&lt;Operand,Comparison&gt;</tt>
|- 
|  <tt>Or&lt;Operand.Comparison&gt;.NextOperator</tt>
|  <tt>Or&lt;Operand,Comparison,NextOperator&gt;</tt>
|- 
|  <tt>Or&lt;UnaryOperator.NextOperator&gt;</tt>
|  <tt>Or2&lt;UnaryOperator,NextOperator&gt;</tt>
|- 
|  <tt>Not&lt;UnaryOperator&gt;</tt>
|  <tt>Not&lt;UnaryOperator&gt;</tt>
|- 
|  <tt>Not&lt;Operand.Comparison&gt;</tt>
|  <tt>Not&lt;Operand,Comparison&gt;</tt>
|- 
|  <tt>Not&lt;Operand.Comparison.NextOperator&gt;</tt>
|  <tt>Not&lt;Operand,Comparison,NextOperator&gt;</tt>
|- 
|  <tt>Not&lt;UnaryOperator.NextOperator&gt;</tt>
|  <tt>Not2&lt;UnaryOperator,NextOperator&gt;</tt>
|- 
|  <tt>Brackets&lt;UnaryOperator&gt;</tt>
|  <tt>Where&lt;UnaryOperator&gt;</tt>
|- 
|  <tt>Brackets&lt;Operand.Comparison&gt;</tt>
|  <tt>Where&lt;Operand,Comparison&gt;</tt>
|- 
|  <tt>Brackets&lt;Operand.Comparison.NextOperator&gt;</tt>
|  <tt>Where&lt;Operand,Comparison,NextOperator&gt;</tt>
|- 
|  <tt>Brackets&lt;UnaryOperator.NextOperator&gt;</tt>
|  <tt>Where2&lt;UnaryOperator,NextOperator&gt;</tt>
|}
==Comparisons==[anchor|#_df369913-4a3f-465a-8dde-83319813feb5]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>Table.field.IsEqual&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, Equal&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNotEqual&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, NotEqual&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsGreaterEqual&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, GreaterEqual&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsGreater&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, Greater&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsLessEqual&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, LessEqual&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsLess&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, Less&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsLike&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, Like&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNotLike&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, NotLike&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsBetween&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, Between&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNotBetween&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, NotBetween&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNull</tt>
|  <tt>&lt;Table.field, IsNull&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNotNull</tt>
|  <tt>&lt;Table.field, IsNotNull&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsIn&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, In&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNotIn&lt;TOperand&gt;</tt>
|  <tt>&lt;Table.field, NotIn&lt;TOperand&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsInSub&lt;TSearch&gt;</tt>
|  <tt>&lt;Table.field, In2&lt;TSearch&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNotInSub&lt;TSearch&gt;</tt>
|  <tt>&lt;Table.field, NotIn2&lt;TSearch&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsIn&lt;TConst1, ..., TConstN&gt;</tt>
|  <tt>&lt;Table.field, In3&lt;TConst1, ..., TConstN&gt;&gt;</tt>
|- 
|  <tt>Table.field.IsNotIn&lt;TConst1, ..., TConstN&gt;</tt>
|  <tt>&lt;Table.field, NotIn3&lt;TConst1, ..., TConstN&gt;&gt;</tt>
|}
==Case, When, Then, and Else Operators==[anchor|#_4ba331e7-5437-4d2b-bff1-48954601473c]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>Operand1.When&lt;Condition1&gt;.Else&lt;Operand2&gt;.When&lt;Condition2&gt;.&#91;...&#93;</tt>
|  <tt>Switch&lt;Cases&gt;</tt>
|- 
|  <tt>Operand1.When&lt;Condition1&gt;.&#91;...&#93;.Else&lt;Default&gt;</tt>
|  <tt>Switch&lt;Cases,Default&gt;</tt>
|- 
|  <tt>Operand.When&lt;Condition&gt;</tt>
|  <tt>Case&lt;Condition,Operand&gt;</tt>
|- 
|  <tt>Operand.When&lt;Condition&gt;.Else&lt;Operand2&gt;.When&lt;Condition2&gt;.&#91;...&#93;</tt>
|  <tt>Case&lt;Condition,Operand,NextCase&gt;</tt>
|}
==Arithmetic Operations and Operations with Strings and Dates==[anchor|#_295d7b3a-34e3-4cf2-8440-0e6cb246ea30]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Fluent BQL
!width="50%" ! Traditional BQL
|- 
| <tt>Op1.Add&lt;Op2&gt;</tt>
|  <tt>Add&lt;Op1, Op2&gt;</tt>
|- 
|  <tt>Op1.Subtract&lt;Op2&gt;</tt>
|  <tt>Sub&lt;Op1, Op2&gt;</tt>
|- 
|  <tt>Op1.Multiply&lt;Op2&gt;</tt>
|  <tt>Mult&lt;Op1, Op2&gt;</tt>
|- 
|  <tt>Op1.Divide&lt;Op2&gt;</tt>
|  <tt>Div&lt;Op1, Op2&gt;</tt>
|- 
|  <tt>Op1.Concat&lt;Op2&gt;</tt>
|  <tt>Concat&lt;Op1, Op2&gt;</tt>
|- 
|  <tt>Op1.IfNullThen&lt;Op2&gt;</tt>
|  <tt>IsNull&lt;Op1, Op2&gt;</tt>
|- 
|  <tt>Op1.NullIf&lt;Op2&gt;</tt>
|  <tt>NullIf&lt;Op1, Op2&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Years</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.year&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Quarters</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.quarter&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Months</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.month&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Weeks</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.week&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Days</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.day&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Hours</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.hour&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Minutes</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.minute&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Seconds</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.second&gt;</tt>
|- 
|  <tt>Date1.Diff&lt;Date2&gt;.Milliseconds</tt>
|  <tt>DateDiff&lt;Date1, Date2, DateDiff.millisecond&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Year</tt>
|  <tt>DatePart&lt;DatePart.year, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Quarter</tt>
|  <tt>DatePart&lt;DatePart.quarter, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Month</tt>
|  <tt>DatePart&lt;DatePart.month, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Week</tt>
|  <tt>DatePart&lt;DatePart.week, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.WeekDay</tt>
|  <tt>DatePart&lt;DatePart.weekDay, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Day</tt>
|  <tt>DatePart&lt;DatePart.day, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.DayOfYear</tt>
|  <tt>DatePart&lt;DatePart.dayOfYear, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Hour</tt>
|  <tt>DatePart&lt;DatePart.hour, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Minute</tt>
|  <tt>DatePart&lt;DatePart.minute, Date&gt;</tt>
|- 
|  <tt>DatePart&lt;Date&gt;.Second</tt>
|  <tt>DatePart&lt;DatePart.second, Date&gt;</tt>
|}
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_BQL_and_LINQ|BQL and LINQ]
*[HelpRoot_Dev_Platform\AD__con_Fluent_BQL|Fluent Business Query Language]]]></column>
			<column name="PlainText"><![CDATA[Fluent BQL and Traditional BQL Equivalents The fluent business query language (BQL) library defines the equivalents of traditional BQL     classes listed in the following tables. You can use the converter from BQL to fluent BQL available on GitHub ( ) to convert the     previously defined BQL queries to fluent BQL. Data View Declarations All data views that contain aggregating are read-only. Fluent BQL Traditional BQL SelectFrom<>.View PXSelect<> SelectFrom<>.View.ReadOnly PXSelectReadonly<> SelectFrom<>.OrderBy<>.View PXSelectOrderBy<,> SelectFrom<>.OrderBy<>.View.ReadOnly PXSelectReadonly3<,> SelectFrom<>.AggregateTo<>.View.ReadOnly PXSelectGroupBy<,> SelectFrom<>.AggregateTo<>.OrderBy<>.View.ReadOnly PXSelectGroupByOrderBy<,,> SelectFrom<>.Where<>.View PXSelect<,> SelectFrom<>.Where<>.View.ReadOnly PXSelectReadonly<,> SelectFrom<>.Where<>.OrderBy<>.View PXSelect<,,> SelectFrom<>.Where<>.OrderBy<>.View.ReadOnly PXSelectReadonly<,,> SelectFrom<>.Where<>.AggregateTo<>.View.ReadOnly PXSelectGroupBy<,,> SelectFrom<>.Where<>.AggregateTo<>.OrderBy<>.View.ReadOnly PXSelectGroupBy<,,,> SelectFrom<>.[Joins].View PXSelectJoin<,> SelectFrom<>.[Joins].View.ReadOnly PXSelectReadonly2<,> SelectFrom<>.[Joins].OrderBy<>.View PXSelectJoinOrderBy<,,> SelectFrom<>.[Joins].OrderBy<>.View.ReadOnly PXSelectReadonly3<,,> SelectFrom<>.[Joins].AggregateTo<>.View.ReadOnly PXSelectJoinGroupBy<,,> SelectFrom<>.[Joins].AggregateTo<>.OrderBy<>.View.ReadOnly PXSelectGroupByOrderBy<,,,> SelectFrom<>.[Joins].Where<>.View PXSelectJoin<,,> SelectFrom<>.[Joins].Where<>.View.ReadOnly PXSelectReadonly2<,,> SelectFrom<>.[Joins].Where<>.OrderBy<>.View PXSelectJoin<,,,> SelectFrom<>.[Joins].Where<>.OrderBy<>.View.ReadOnly PXSelectReadonly2<,,,> SelectFrom<>.[Joins].Where<>.AggregateTo<>.View.ReadOnly PXSelectJoinGroupBy<,,,> SelectFrom<>.[Joins].Where<>.AggregateTo<>.OrderBy<>.View.ReadOnly PXSelectJoinGroupBy<,,,,> Select Commands Fluent BQL Traditional BQL SelectFrom<> Select<> SelectFrom<>.OrderBy<> Select3<,> SelectFrom<>.AggregateTo<> Select4<,> SelectFrom<>.AggregateTo<>.OrderBy<> Select6<,,> SelectFrom<>.Where<> Select<,> SelectFrom<>.Where<>.OrderBy<> Select<,,> SelectFrom<>.Where<>.AggregateTo<> Select4<,,> SelectFrom<>.Where<>.AggregateTo<>.OrderBy<> Select4<,,,> SelectFrom<>.[Joins] Select2<,> SelectFrom<>.[Joins].OrderBy<> Select3<,,> SelectFrom<>.[Joins].AggregateTo<> Select5<,,> SelectFrom<>.[Joins].AggregateTo<>.OrderBy<> Select6<,,,> SelectFrom<>.[Joins].Where<> Select2<,,> SelectFrom<>.[Joins].Where<>.OrderBy<> Select2<,,,> SelectFrom<>.[Joins].Where<>.AggregateTo<> Select5<,,,> SelectFrom<>.[Joins].Where<>.AggregateTo<>.OrderBy<> Select5<,,,,> Search Commands Fluent BQL Traditional BQL SelectFrom<>.SearchFor<> Search<> SelectFrom<>.OrderBy<>.SearchFor<> Search3<,> SelectFrom<>.AggregateTo<>.SearchFor<> Search4<,> SelectFrom<>.AggregateTo<>.OrderBy<>.SearchFor<> Search6<,,> SelectFrom<>.Where<>.SearchFor<> Search<,> SelectFrom<>.Where<>.OrderBy<>.SearchFor<> Search<,,> SelectFrom<>.Where<>.AggregateTo<>.SearchFor<> Search4<,,> SelectFrom<>.Where<>.AggregateTo<>.OrderBy<>.SearchFor<> Search4<,,,> SelectFrom<>.[Joins].SearchFor<> Search2<,> SelectFrom<>.[Joins].OrderBy<>.SearchFor<> Search3<,,> SelectFrom<>.[Joins].AggregateTo<>.SearchFor<> Search5<,,> SelectFrom<>.[Joins].AggregateTo<>.OrderBy<>.SearchFor<> Search6<,,,> SelectFrom<>.[Joins].Where<>.SearchFor<> Search2<,,> SelectFrom<>.[Joins].Where<>.OrderBy<>.SearchFor<> Search2<,,,> SelectFrom<>.[Joins].Where<>.AggregateTo<>.SearchFor<> Search5<,,,> SelectFrom<>.[Joins].Where<>.AggregateTo<>.OrderBy<>.SearchFor<> Search5<,,,,> Join Clauses Fluent BQL Traditional BQL .InnerJoin<Table>.On<> InnerJoin<Table,On> .InnerJoin<Table>.On<>.NextJoin InnerJoin<Table,On,NextJoin> .InnerJoin<Table>.On<>.SingleTableOnly InnerJoinSingleTable<Table,On> .InnerJoin<Table>.On<>.SingleTableOnly.NextJoin InnerJoinSingleTable<Table,On,NextJoin> .LeftJoin<Table>.On<> LeftJoin<Table,On> .LeftJoin<Table>.On<>.NextJoin LeftJoin<Table,On,NextJoin> .LeftJoin<Table>.On<>.SingleTableOnly LeftJoinSingleTable<Table,On> .LeftJoin<Table>.On<>.SingleTableOnly.NextJoin LeftJoinSingleTable<Table,On,NextJoin> .RightJoin<Table>.On<> RightJoin<Table,On> .RightJoin<Table>.On<>.NextJoin RightJoin<Table,On,NextJoin> .RightJoin<Table>.On<>.SingleTableOnly RightJoinSingleTable<Table,On> .RightJoin<Table>.On<>.SingleTableOnly.NextJoin RightJoinSingleTable<Table,On,NextJoin> .FullJoin<Table>.On<> FullJoin<Table,On> .FullJoin<Table>.On<>.NextJoin FullJoin<Table,On,NextJoin> .FullJoin<Table>.On<>.SingleTableOnly FullJoinSingleTable<Table,On> .FullJoin<Table>.On<>.SingleTableOnly.NextJoin FullJoinSingleTable<Table,On,NextJoin> .CrossJoin<Table> CrossJoin<Table> .CrossJoin<Table>.NextJoin CrossJoin<Table,NextJoin> .CrossJoin<Table>.SingleTableOnly CrossJoinSingleTable<Table> .CrossJoin<Table>.SingleTableOnly.NextJoin CrossJoinSingleTable<Table,NextJoin> Where Clause Fluent BQL Traditional BQL .Where<UnaryOperator> Where<UnaryOperator> .Where<Operand.Comparison> Where<Operand,Comparison> .Where<Operand.Comparison.NextOperator> Where<Operand,Comparison,NextOperator> .Where<UnaryOperator.NextOperator> Where2<UnaryOperator,NextOperator> Aggregate Clause Fluent BQL Traditional BQL .AggregateTo<Function> Aggregate<Function> .AggregateTo<TFunctions>.THaving Aggregate<TFunctions,THaving> .Having<TCondition> Having<TCondition> GroupBy<Field> GroupBy<Field> GroupBy<Field>, NextAggregate GroupBy<Field,NextAggregate> Max<Field> Max<Field> Max<Field>, NextAggregate Max<Field,NextAggregate> Min<Field> Min<Field> Min<Field>, NextAggregate Min<Field,NextAggregate> Sum<Field> Sum<Field> Sum<Field>, NextAggregate Sum<Field,NextAggregate> Avg<Field> Avg<Field> Avg<Field>, NextAggregate Avg<Field,NextAggregate> Count Count Count<Field> Count<Field> OrderBy Clause Fluent BQL Traditional BQL .OrderBy<List> OrderBy<List> Field.Asc Asc<Field> Field.Asc, NextSort Asc<Field,NextSort> Field.Desc Desc<Field> Field.Desc, NextSort Desc<Field,NextSort> Parameters Fluent BQL Traditional BQL Field.FromCurrent Current<Field> Field.FromCurrent.NoDefault Current2<Field> Field.AsOptional Optional<Field> Field.AsOptional.NoDefault Optional2<Field> @P.AsBool Required<Field> , where the property field of           Field  has the  bool  type @P.AsByte Required<Field> , where the property field of           Field  has the  byte  type @P.AsShort Required<Field> , where the property field of           Field  has the  short  type @P.AsInt Required<Field> , where the property field of           Field  has the  int  type @P.AsLong Required<Field> , where the property field of           Field  has the  long  type @P.AsFloat Required<Field> , where the property field of           Field  has the  float  type @P.AsDouble Required<Field> , where the property field of           Field  has the  double  type @P.AsDecimal Required<Field> , where the property field of           Field  has the  decimal  type @P.AsGuid Required<Field> , where the property field of           Field  has the  Guid  type @P.AsDateTime Required<Field> , where the property field of           Field  has the  DateTime  type @P.AsString Required<Field> , where the property field of           Field  has the  string  type Argument.AsBool Argument<bool?> Argument.AsByte Argument<byte?> Argument.AsShort Argument<short?> Argument.AsInt Argument<int?> Argument.AsLong Argument<long?> Argument.AsFloat Argument<float?> Argument.AsDouble Argument<double?> Argument.AsDecimal Argument<decimal?> Argument.AsGuid Argument<Guid?> Argument.AsDateTime Argument<DateTime?> Argument.AsString Argument<string> Logical Operators and Brackets Fluent BQL Traditional BQL And<UnaryOperator> And<UnaryOperator> And<Operand.Comparison> And<Operand,Comparison> And<Operand.Comparison>.NextOperator And<Operand,Comparison,NextOperator> And<UnaryOperator.NextOperator> And2<UnaryOperator,NextOperator> Or<UnaryOperator> Or<UnaryOperator> Or<Operand.Comparison> Or<Operand,Comparison> Or<Operand.Comparison>.NextOperator Or<Operand,Comparison,NextOperator> Or<UnaryOperator.NextOperator> Or2<UnaryOperator,NextOperator> Not<UnaryOperator> Not<UnaryOperator> Not<Operand.Comparison> Not<Operand,Comparison> Not<Operand.Comparison.NextOperator> Not<Operand,Comparison,NextOperator> Not<UnaryOperator.NextOperator> Not2<UnaryOperator,NextOperator> Brackets<UnaryOperator> Where<UnaryOperator> Brackets<Operand.Comparison> Where<Operand,Comparison> Brackets<Operand.Comparison.NextOperator> Where<Operand,Comparison,NextOperator> Brackets<UnaryOperator.NextOperator> Where2<UnaryOperator,NextOperator> Comparisons Fluent BQL Traditional BQL Table.field.IsEqual<TOperand> <Table.field, Equal<TOperand>> Table.field.IsNotEqual<TOperand> <Table.field, NotEqual<TOperand>> Table.field.IsGreaterEqual<TOperand> <Table.field, GreaterEqual<TOperand>> Table.field.IsGreater<TOperand> <Table.field, Greater<TOperand>> Table.field.IsLessEqual<TOperand> <Table.field, LessEqual<TOperand>> Table.field.IsLess<TOperand> <Table.field, Less<TOperand>> Table.field.IsLike<TOperand> <Table.field, Like<TOperand>> Table.field.IsNotLike<TOperand> <Table.field, NotLike<TOperand>> Table.field.IsBetween<TOperand> <Table.field, Between<TOperand>> Table.field.IsNotBetween<TOperand> <Table.field, NotBetween<TOperand>> Table.field.IsNull <Table.field, IsNull<TOperand>> Table.field.IsNotNull <Table.field, IsNotNull<TOperand>> Table.field.IsIn<TOperand> <Table.field, In<TOperand>> Table.field.IsNotIn<TOperand> <Table.field, NotIn<TOperand>> Table.field.IsInSub<TSearch> <Table.field, In2<TSearch>> Table.field.IsNotInSub<TSearch> <Table.field, NotIn2<TSearch>> Table.field.IsIn<TConst1, ..., TConstN> <Table.field, In3<TConst1, ..., TConstN>> Table.field.IsNotIn<TConst1, ..., TConstN> <Table.field, NotIn3<TConst1, ..., TConstN>> Case, When, Then, and Else Operators Fluent BQL Traditional BQL Operand1.When<Condition1>.Else<Operand2>.When<Condition2>.[...] Switch<Cases> Operand1.When<Condition1>.[...].Else<Default> Switch<Cases,Default> Operand.When<Condition> Case<Condition,Operand> Operand.When<Condition>.Else<Operand2>.When<Condition2>.[...] Case<Condition,Operand,NextCase> Arithmetic Operations and Operations with Strings and Dates Fluent BQL Traditional BQL Op1.Add<Op2> Add<Op1, Op2> Op1.Subtract<Op2> Sub<Op1, Op2> Op1.Multiply<Op2> Mult<Op1, Op2> Op1.Divide<Op2> Div<Op1, Op2> Op1.Concat<Op2> Concat<Op1, Op2> Op1.IfNullThen<Op2> IsNull<Op1, Op2> Op1.NullIf<Op2> NullIf<Op1, Op2> Date1.Diff<Date2>.Years DateDiff<Date1, Date2, DateDiff.year> Date1.Diff<Date2>.Quarters DateDiff<Date1, Date2, DateDiff.quarter> Date1.Diff<Date2>.Months DateDiff<Date1, Date2, DateDiff.month> Date1.Diff<Date2>.Weeks DateDiff<Date1, Date2, DateDiff.week> Date1.Diff<Date2>.Days DateDiff<Date1, Date2, DateDiff.day> Date1.Diff<Date2>.Hours DateDiff<Date1, Date2, DateDiff.hour> Date1.Diff<Date2>.Minutes DateDiff<Date1, Date2, DateDiff.minute> Date1.Diff<Date2>.Seconds DateDiff<Date1, Date2, DateDiff.second> Date1.Diff<Date2>.Milliseconds DateDiff<Date1, Date2, DateDiff.millisecond> DatePart<Date>.Year DatePart<DatePart.year, Date> DatePart<Date>.Quarter DatePart<DatePart.quarter, Date> DatePart<Date>.Month DatePart<DatePart.month, Date> DatePart<Date>.Week DatePart<DatePart.week, Date> DatePart<Date>.WeekDay DatePart<DatePart.weekDay, Date> DatePart<Date>.Day DatePart<DatePart.day, Date> DatePart<Date>.DayOfYear DatePart<DatePart.dayOfYear, Date> DatePart<Date>.Hour DatePart<DatePart.hour, Date> DatePart<Date>.Minute DatePart<DatePart.minute, Date> DatePart<Date>.Second DatePart<DatePart.second, Date> ]]></column>
		</row>
		<row PageID="2204f63e-6ab7-4f29-ba28-1b549570e40f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="55d3a2b0-f91c-e8b8-02f0-de45091409dc" RecordSourceID="22377">
			<column name="Content"><![CDATA[To send a request to the database, you call the <tt>Select()</tt> method of a <tt>PXSelectBase</tt>-derived class and cast the result of the query execution to a data access class (DAC) or an array of DACs, as described in this topic. The <tt>Select()</tt> method can accept additional parameters if a business query language (BQL) statement includes parameters. {br}{TOC}
==To Execute a BQL Statement That Defines a Data View==
When a webpage requests data, you do not need to execute a data view manually; the system executes each data view automatically. If you need to manually execute a BQL statement that defines a data view, do the following:[anchor|#ul_lkv_zd5_nk]
#Declare a data view as a member in a graph.
#Execute the data view by calling the <tt>Select()</tt> method of a <tt>PXSelectBase</tt>-derived class.
#Cast the result of the query execution to a DAC or an array of DACs, or iterate through DACs in the result by using the {{foreach}} statement. The following sample code shows the approach of iterating through DACs. For details, see [HelpRoot_Dev_Platform\AD__how_Process_Resultset|To Process the Result of the Execution of the BQL Statement].<source lang="csharp">// Business logic controller (graph) declaration
public class OrderDataEntry : PXGraph&lt;OrderDataEntry, SalesOrder&gt;
{
    // A data view declared as a graph member
    public SelectFrom&lt;SalesOrder&gt;.
               OrderBy&lt;Asc&lt;SalesOrder.orderNbr&gt;&gt;.View Orders;
    ...
    public void SomeMethod()
    {
        // An execution of the data view in code
        foreach(SalesOrder so in Orders.Select())
        {
            // The SalesOrder record selected by a data view can
            // be modified and updated through the Update() method.
            so.OrderTotal = so.LinesTotal + so.FreightAmt;
            // Update the SalesOrder data record in PXCache
            Orders.Update(so); 
        }
    }
}</source>

==To Execute a BQL Statement Statically==
To execute a BQL statement statically, do the following: [anchor|#_b6f34987-0d58-4d76-9a59-955314d01459]
#Execute a BQL statement by using the {{static}}<tt>Select()</tt> method of a <tt>PXSelectBase</tt>-derived class. Provide a graph object as the parameter of the method. 
#Cast the result of the query execution to a DAC or an array of DACs, or iterate through DACs in the result by using the {{foreach}} statement. The following sample code shows the approach of iterating through DACs. For details, see [HelpRoot_Dev_Platform\AD__how_Process_Resultset|To Process the Result of the Execution of the BQL Statement].
<source lang="csharp">// Business logic controller (graph) declaration
public class OrderDataEntry : PXGraph&lt;OrderDataEntry, SalesOrder&gt;
{
    ...
    public void SomeMethod()
    {
        // Execution through the static Select() method
        foreach(SalesOrder so in
            SelectFrom&lt;SalesOrder&gt;.
                OrderBy&lt;Asc&lt;SalesOrder.orderNbr&gt;&gt;.View.Select(this))
            ...
    }
}</source>
==To Execute a BQL Statement Dynamically==
To execute a BQL statement dynamically, do the following: [anchor|#_fbc8ef5f-258e-4f45-abff-aa8198fee988]
#Dynamically instantiate a data view in code. You should also provide the graph object as a parameter to the data view constructor.
#Execute the data view by using the <tt>Select()</tt> method of the instance of a <tt>PXSelectBase</tt>-derived class. 
#Cast the result of the query execution to a DAC or an array of DACs, or iterate through DACs in the result by using the {{foreach}} statement. The following sample code shows the approach of iterating through DACs. For details, see [HelpRoot_Dev_Platform\AD__how_Process_Resultset|To Process the Result of the Execution of the BQL Statement].
<source lang="csharp">// Business logic controller (graph) declaration
public class OrderDataEntry : PXGraph&lt;OrderDataEntry, SalesOrder&gt;
{
    ...
    public void SomeMethod()
    {
        // Dynamic instantiation of a data view
        PXSelectBase&lt;SalesOrder&gt; orders =
            new SelectFrom&lt;SalesOrder&gt;.
                OrderBy&lt;Asc&lt;SalesOrder.orderNbr&gt;&gt;.View(this);

        // An execution of a dynamically created BQL statement
        foreach(SalesOrder so in orders.Select())
            ...
    }
}</source>
==To Execute a BQL Statement with Parameters==
Use parameters (such as <tt>AsOptional</tt>, <tt>FromCurrent</tt>, and <tt>@P.As&#91;Type&#93;</tt> in fluent BQL and <tt>Optional</tt>, <tt>Current</tt>, and <tt>Required</tt> in traditional BQL) to pass specific values to a BQL statement, as shown in the following example. For more details on how to construct a BQL statement with parameters, see [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL|To Use Parameters in Fluent BQL Queries] and [HelpRoot_Dev_Platform\AD__how_BQL_Parameters|To Use Parameters in Traditional BQL].<source lang="csharp">// Declaration of a BLC
public class ReceiptDataEntry : PXGraph&lt;ReceiptDataEntry, Document&gt;
{
    // When a screen associated with this BLC is first opened,
    // the Optional parameter is replaced with the default DocType value.
    public SelectFrom&lt;Document&gt;.
        Where&lt;Document.docType.IsEqual&lt;Document.docType.AsOptional&gt;&gt; Receipts;

    // The FromCurrent parameters are replaced with the values from
    // the Current property of the PXCache&lt;Document&gt; object.
    public SelectFrom&lt;DocTransaction&gt;.
        Where&lt;DocTransaction.docNbr.IsEqual&lt;Document.docNbr.FromCurrent&gt;.
            And&lt;DocTransaction.docType.IsEqual&lt;Document.docType.FromCurrent&gt;&gt;&gt;.
        OrderBy&lt;Asc&lt;DocTransaction.lineNbr&gt;&gt; ReceiptTransactions;

    public void SomeMethod()
    {
        // Select documents of the same DocType as the current document
        // has, or of the default DocType if the current document is null.
        PXResult&lt;Document&gt; res1 = Receipts.Select();
        foreach(Document doc in res1)
            ...

        // Select documents of the "N" DocType.
        PXResult&lt;Document&gt; res2 = Receipts.Select("N");
        foreach(Document doc in res2)
            ...

        // Use parameter values from the current document.
        PXResult&lt;DocTransaction&gt; res3 = ReceiptTransactions.Select();
        foreach(DocTransaction docTran in res3)
            ...

        // Use the @P.AsString parameter to provide values in code.
        // The result set here is the same as the res2 result set.
        PXResult&lt;Document&gt; res4 =
            SelectFrom&lt;Document&gt;.
                Where&lt;Document.docType.IsEqual&lt;@P.AsString&gt;&gt;.View
            .Select(this, "N");
        foreach(Document doc in res4)
            ...
    }
    ...
}</source>[anchor|#_36988f03-38e3-4f9a-89f6-1623935e81fa]
==To Execute a BQL Statement in a Data View Delegate==
If the data requested from the database cannot be described by a declarative BQL statement, implement the data view delegate that is used instead of the standard <tt>Select()</tt> logic to retrieve data from the database; this data view delegate must satisfy the following requirements:[anchor|#_1039779e-6e87-43cc-a80f-ad03aad2a906]
*The data view delegate must have the same name as the data view except for the first letter, which must be lowercase. 
*The data view delegate must return <tt>IEnumerable</tt>, as shown in the following example.
*:((({S:Hint}If the data view delegate is not defined or it returns {{null}}, the standard <tt>Select()</tt> logic is executed.
)))
{br}

The following sample code defines a data view delegate.<source lang="csharp">// A view declaration in a graph
public SelectFrom&lt;BalancedAPDocument&gt;.
    LeftJoin&lt;APInvoice&gt;.
        On&lt;APInvoice.docType.IsEqual&lt;BalancedAPDocument.docType&gt;.
            And&lt;APInvoice.refNbr.IsEqual&lt;BalancedAPDocument.refNbr&gt;&gt;&gt;.
    LeftJoin&lt;APPayment&gt;.
        On&lt;APPayment.docType.IsEqual&lt;BalancedAPDocument.docType&gt;.
            And&lt;APPayment.refNbr.IsEqual&lt;BalancedAPDocument.refNbr&gt;&gt;&gt;.View
    DocumentList;

// The data view delegate
protected virtual IEnumerable documentlist()
{
    // Iterating over the result set of a complex BQL statement
    foreach (PXResult&lt;BalancedAPDocument, APInvoice, APPayment, APAdjust&gt; res in
        SelectFrom&lt;BalancedAPDocument&gt;.
            LeftJoin&lt;APInvoice&gt;.
                On&lt;APInvoice.docType.IsEqual&lt;BalancedAPDocument.docType&gt;.
                    And&lt;APInvoice.refNbr.IsEqual&lt;BalancedAPDocument.refNbr&gt;&gt;&gt;.
            LeftJoin&lt;APPayment&gt;.
                On&lt;APPayment.docType.IsEqual&lt;BalancedAPDocument.docType&gt;.
                    And&lt;APPayment.refNbr.IsEqual&lt;BalancedAPDocument.refNbr&gt;&gt;&gt;.
            LeftJoin&lt;APAdjust&gt;.
                On&lt;APAdjust.adjgDocType.IsEqual&lt;BalancedAPDocument.docType&gt;&gt;.
            AggregateTo&lt;GroupBy&lt;BalancedAPDocument.docType&gt;,
                GroupBy&lt;BalancedAPDocument.refNbr&gt;,
                GroupBy&lt;BalancedAPDocument.released&gt;,
                GroupBy&lt;BalancedAPDocument.prebooked&gt;,
                GroupBy&lt;BalancedAPDocument.openDoc&gt;&gt;.View.Select(this))
    {
        // Casting a result set record to DAC types
        BalancedAPDocument apdoc = (BalancedAPDocument)res;
        APAdjust adj = (APAdjust)res;
        // Checking some conditions and modifying records
        ...
    }

    return new PXResult&lt;BalancedAPDocument, APInvoice, APPayment&gt;(
            apdoc, res, res);
}</source>
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]
*[HelpRoot_Dev_Platform\AD__how_Process_Resultset|To Process the Result of the Execution of the BQL Statement]]]></column>
			<column name="PlainText"><![CDATA[To Execute BQL Statements To send a request to the database, you call the                  Select()  method of a  PXSelectBase -derived             class and cast the result of the query execution to a data access class (DAC) or an             array of DACs, as described in this topic. The  Select()  method can             accept additional parameters if a business query language (BQL) statement includes             parameters.  To Execute a BQL Statement That Defines a Data View When a webpage requests data, you do not need to execute a data view manually; the                 system executes each data view automatically. If you need to manually execute a BQL                 statement that defines a data view, do the following: Declare a data view as a member in a graph. Execute the data view by calling the  Select()  method of a                              PXSelectBase -derived class. Cast the result of the query execution to a DAC or an array of DACs, or                         iterate through DACs in the result by using the  foreach                          statement. The following sample code shows the approach of iterating through                         DACs. For details, see  To Process the Result of the Execution of the BQL Statement. // Business logic controller (graph) declaration
public class OrderDataEntry : PXGraph<OrderDataEntry, SalesOrder>
{
    // A data view declared as a graph member
    public SelectFrom<SalesOrder>.
               OrderBy<Asc<SalesOrder.orderNbr>>.View Orders;
    ...
    public void SomeMethod()
    {
        // An execution of the data view in code
        foreach(SalesOrder so in Orders.Select())
        {
            // The SalesOrder record selected by a data view can
            // be modified and updated through the Update() method.
            so.OrderTotal = so.LinesTotal + so.FreightAmt;
            // Update the SalesOrder data record in PXCache
            Orders.Update(so); 
        }
    }
} To Execute a BQL Statement Statically To execute a BQL statement statically, do the following:  Execute a BQL statement by using the  static Select()  method of a                          PXSelectBase -derived class. Provide a graph object as the                         parameter of the method.  Cast the result of the query execution to a DAC or an array of DACs, or                         iterate through DACs in the result by using the  foreach                          statement. The following sample code shows the approach of iterating through                         DACs. For details, see  To Process the Result of the Execution of the BQL Statement. // Business logic controller (graph) declaration
public class OrderDataEntry : PXGraph<OrderDataEntry, SalesOrder>
{
    ...
    public void SomeMethod()
    {
        // Execution through the static Select() method
        foreach(SalesOrder so in
            SelectFrom<SalesOrder>.
                OrderBy<Asc<SalesOrder.orderNbr>>.View.Select(this))
            ...
    }
} To Execute a BQL Statement Dynamically To execute a BQL statement dynamically, do the following:  Dynamically instantiate a data view in code. You should also provide the                         graph object as a parameter to the data view constructor. Execute the data view by using the  Select()  method of the                         instance of a  PXSelectBase -derived class.  Cast the result of the query execution to a DAC or an array of DACs, or                         iterate through DACs in the result by using the  foreach                          statement. The following sample code shows the approach of iterating through                         DACs. For details, see  To Process the Result of the Execution of the BQL Statement. // Business logic controller (graph) declaration
public class OrderDataEntry : PXGraph<OrderDataEntry, SalesOrder>
{
    ...
    public void SomeMethod()
    {
        // Dynamic instantiation of a data view
        PXSelectBase<SalesOrder> orders =
            new SelectFrom<SalesOrder>.
                OrderBy<Asc<SalesOrder.orderNbr>>.View(this);

        // An execution of a dynamically created BQL statement
        foreach(SalesOrder so in orders.Select())
            ...
    }
} To Execute a BQL Statement with Parameters Use parameters (such as  AsOptional ,  FromCurrent , and                      @P.As[Type]  in fluent BQL and  Optional ,                      Current , and  Required  in traditional BQL)                 to pass specific values to a BQL statement, as shown in the following example. For                 more details on how to construct a BQL statement with parameters, see  To Use Parameters in Fluent BQL Queries and  To Use Parameters in Traditional BQL. // Declaration of a BLC
public class ReceiptDataEntry : PXGraph<ReceiptDataEntry, Document>
{
    // When a screen associated with this BLC is first opened,
    // the Optional parameter is replaced with the default DocType value.
    public SelectFrom<Document>.
        Where<Document.docType.IsEqual<Document.docType.AsOptional>> Receipts;

    // The FromCurrent parameters are replaced with the values from
    // the Current property of the PXCache<Document> object.
    public SelectFrom<DocTransaction>.
        Where<DocTransaction.docNbr.IsEqual<Document.docNbr.FromCurrent>.
            And<DocTransaction.docType.IsEqual<Document.docType.FromCurrent>>>.
        OrderBy<Asc<DocTransaction.lineNbr>> ReceiptTransactions;

    public void SomeMethod()
    {
        // Select documents of the same DocType as the current document
        // has, or of the default DocType if the current document is null.
        PXResult<Document> res1 = Receipts.Select();
        foreach(Document doc in res1)
            ...

        // Select documents of the "N" DocType.
        PXResult<Document> res2 = Receipts.Select("N");
        foreach(Document doc in res2)
            ...

        // Use parameter values from the current document.
        PXResult<DocTransaction> res3 = ReceiptTransactions.Select();
        foreach(DocTransaction docTran in res3)
            ...

        // Use the @P.AsString parameter to provide values in code.
        // The result set here is the same as the res2 result set.
        PXResult<Document> res4 =
            SelectFrom<Document>.
                Where<Document.docType.IsEqual<@P.AsString>>.View
            .Select(this, "N");
        foreach(Document doc in res4)
            ...
    }
    ...
} To Execute a BQL Statement in a Data View Delegate If the data requested from the database cannot be described by a declarative BQL                 statement, implement the data view delegate that is used instead of the standard                      Select()  logic to retrieve data from the database; this data                 view delegate must satisfy the following requirements: The data view delegate must have the same name as the data view except for                         the first letter, which must be lowercase.  The data view delegate must return  IEnumerable , as shown                         in the following example. If the data view delegate is not defined or                             it returns  null , the standard                                  Select()  logic is executed. The following sample code defines a data view                 delegate. // A view declaration in a graph
public SelectFrom<BalancedAPDocument>.
    LeftJoin<APInvoice>.
        On<APInvoice.docType.IsEqual<BalancedAPDocument.docType>.
            And<APInvoice.refNbr.IsEqual<BalancedAPDocument.refNbr>>>.
    LeftJoin<APPayment>.
        On<APPayment.docType.IsEqual<BalancedAPDocument.docType>.
            And<APPayment.refNbr.IsEqual<BalancedAPDocument.refNbr>>>.View
    DocumentList;

// The data view delegate
protected virtual IEnumerable documentlist()
{
    // Iterating over the result set of a complex BQL statement
    foreach (PXResult<BalancedAPDocument, APInvoice, APPayment, APAdjust> res in
        SelectFrom<BalancedAPDocument>.
            LeftJoin<APInvoice>.
                On<APInvoice.docType.IsEqual<BalancedAPDocument.docType>.
                    And<APInvoice.refNbr.IsEqual<BalancedAPDocument.refNbr>>>.
            LeftJoin<APPayment>.
                On<APPayment.docType.IsEqual<BalancedAPDocument.docType>.
                    And<APPayment.refNbr.IsEqual<BalancedAPDocument.refNbr>>>.
            LeftJoin<APAdjust>.
                On<APAdjust.adjgDocType.IsEqual<BalancedAPDocument.docType>>.
            AggregateTo<GroupBy<BalancedAPDocument.docType>,
                GroupBy<BalancedAPDocument.refNbr>,
                GroupBy<BalancedAPDocument.released>,
                GroupBy<BalancedAPDocument.prebooked>,
                GroupBy<BalancedAPDocument.openDoc>>.View.Select(this))
    {
        // Casting a result set record to DAC types
        BalancedAPDocument apdoc = (BalancedAPDocument)res;
        APAdjust adj = (APAdjust)res;
        // Checking some conditions and modifying records
        ...
    }

    return new PXResult<BalancedAPDocument, APInvoice, APPayment>(
            apdoc, res, res);
} ]]></column>
		</row>
		<row PageID="8609c829-7b9c-4660-acf9-891b0971b6a3" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="17e24c6a-b918-3774-4617-16addd2223d8" RecordSourceID="22377">
			<column name="Content"><![CDATA[
<tt>Select()</tt> returns the <tt>PXResultset&lt;T0&gt;</tt> object. The type parameter (<tt>T0</tt>) is set to the first table selected by the business query language (BQL) statement, and <tt>PXResultset&lt;T0&gt;</tt> is a collection of <tt>PXResult&lt;T0&gt;</tt> objects. You can iterate through the result set in a <tt>foreach</tt> loop and obtain either data access class (DAC) instances or <tt>PXResult&lt;&gt;</tt> instances. A <tt>PXResult&lt;&gt;</tt> instance represents a whole result set record and can be cast to any of the DAC types joined in the BQL statement.[anchor|#_3fa4383b-2b91-4af6-b8a4-6bf4e24fa853]
==To Get the Objects of the Primary DAC==
In the {{foreach}} loop, cast each <tt>PXResult&lt;T0&gt;</tt> object in the collection to an object of the main DAC. The <tt>PXResult&lt;T0&gt;</tt> object is implicitly converted to the <tt>T0</tt> class. In the following sample code, records are selected from the {{Document}} table.<source lang="csharp">// Result set records are implicitly cast to the Document DAC.
foreach(Document doc in SelectFrom&lt;Document&gt;.View.Select(this))
{
    ...
}</source>
==To Get the Objects of Joined DACs==
[anchor|#_7772b62c-1b44-4f84-ba2c-9d53609879c8]
#In the {{foreach}} loop, cast each <tt>PXResult&lt;T0&gt;</tt> object in the collection to the needed <tt>PXResult&lt;T0, T1, T2, ...&gt;</tt> object, where <tt>T0</tt>, <tt>T1</tt>, <tt>T2</tt>, and other type parameters are joined DACs from the BQL statement. The <tt>PXResult&lt;T0, T1, T2, ...&gt;</tt> type must be specialized with the DACs of all joined tables.
#Cast each <tt>PXResult&lt;T0, T1, T2, ...&gt;</tt> item to any of the listed types to get the object of this type.
The following sample code shows how to process the result set of a BQL statement joining two tables.<source lang="csharp">// The static Select() method is called to execute a BQL command.
PXResultset&lt;OrderLine&gt; result =
    SelectFrom&lt;OrderLine&gt;.InnerJoin&lt;SalesOrder&gt;.
        On&lt;SalesOrder.orderNbr.IsEqual&lt;OrderLine.orderNbr&gt;&gt;.View.Select(this);

// Iterating over the result set:
// PXResult should be specialized with the DACs of all joined tables
// to be able to cast to these DACs.
foreach(PXResult&lt;OrderLine, SalesOrder&gt; record in result)
{
    // Casting a result set record to the OrderLine DAC:
    OrderLine detail = (OrderLine)record;
    // Casting a result set record to the SalesOrder DAC:
    SalesOrder order = (SalesOrder)record;
    ...
}</source>
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]]]></column>
			<column name="PlainText"><![CDATA[To Process the Result of the Execution of the BQL Statement Select()  returns the  PXResultset<T0>                  object. The type parameter ( T0 ) is set to the first table                 selected by the business query language (BQL) statement, and                      PXResultset<T0>  is a collection of                      PXResult<T0>  objects. You can iterate through the result                 set in a  foreach  loop and obtain either data access class (DAC)                 instances or  PXResult<>  instances. A                      PXResult<>  instance represents a whole result set                 record and can be cast to any of the DAC types joined in the BQL statement. To Get the Objects of the Primary DAC In the  foreach  loop, cast each  PXResult<T0>                  object in the collection to an object of the main DAC. The                      PXResult<T0>  object is implicitly converted to the                      T0  class. In the following sample code, records are selected                 from the  Document  table. // Result set records are implicitly cast to the Document DAC.
foreach(Document doc in SelectFrom<Document>.View.Select(this))
{
    ...
} To Get the Objects of Joined DACs In the  foreach  loop, cast each                              PXResult<T0>  object in the collection to the                         needed  PXResult<T0, T1, T2, ...>  object, where                              T0 ,  T1 ,  T2 , and                         other type parameters are joined DACs from the BQL statement. The                              PXResult<T0, T1, T2, ...>  type must be specialized                         with the DACs of all joined tables. Cast each  PXResult<T0, T1, T2, ...>  item to any of the                         listed types to get the object of this type. The following sample code shows how to process the result set of a BQL                 statement joining two tables. // The static Select() method is called to execute a BQL command.
PXResultset<OrderLine> result =
    SelectFrom<OrderLine>.InnerJoin<SalesOrder>.
        On<SalesOrder.orderNbr.IsEqual<OrderLine.orderNbr>>.View.Select(this);

// Iterating over the result set:
// PXResult should be specialized with the DACs of all joined tables
// to be able to cast to these DACs.
foreach(PXResult<OrderLine, SalesOrder> record in result)
{
    // Casting a result set record to the OrderLine DAC:
    OrderLine detail = (OrderLine)record;
    // Casting a result set record to the SalesOrder DAC:
    SalesOrder order = (SalesOrder)record;
    ...
} ]]></column>
		</row>
		<row PageID="f3436474-d5a9-40b3-98e9-23984b9b1416" Language="en-US" PageRevisionID="1" PlainText="Creating Fluent BQL Queries To query data from the database, you use the business query language (BQL), which has two     dialects: fluent BQL and traditional BQL. In this chapter, you can find information on how to create fluent BQL queries. For general     information about data querying, see  Querying Data in Acumatica Framework. For details     about building queries with traditional BQL, see  Creating Traditional BQL Queries. In This Chapter Fluent Business Query LanguageData Access Classes in Fluent BQLSearch and Select Commands and Data Views in Fluent BQLConstants in Fluent BQLParameters in Fluent BQLTo Select Records by Using Fluent BQLTo Use Parameters in Fluent BQL Queries" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="36dd4633-d3d7-5b13-d178-5706120de79f" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To query data from the database, you use the business query language (BQL), which has two dialects: fluent BQL and traditional BQL.{br}

In this chapter, you can find information on how to create fluent BQL queries. For general information about data querying, see [HelpRoot_Dev_Platform\AD__mng_Querying_Data|Querying Data in Acumatica Framework]. For details about building queries with traditional BQL, see [HelpRoot_Dev_Platform\AD__mng_Traditional_BQL|Creating Traditional BQL Queries].
==In This Chapter==[anchor|#_fdea5094-3248-4ffa-944e-19d5ae91bc7d]
{| class="checklist invisiblechecklist" | width="100%" 
|- 
| [anchor|#_e699c3c7-cb06-4867-b619-8e77f2a5c974]
*[HelpRoot_Dev_Platform\AD__con_Fluent_BQL|Fluent Business Query Language]
*[HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL]
*[HelpRoot_Dev_Platform\AD__con_View_Select_Search_in_Fluent_BQL|Search and Select Commands and Data Views in Fluent BQL]
*[HelpRoot_Dev_Platform\AD__con_Constants_in_FBQL|Constants in Fluent BQL]
*[HelpRoot_Dev_Platform\AC__con_Parameters_in_FBQL|Parameters in Fluent BQL]

| [anchor|#_e1f1faa0-c50a-4c10-b4f2-08ab4abd03f3]
*[HelpRoot_Dev_Platform\AD__how_Select_Records_in_Fluent_BQL|To Select Records by Using Fluent BQL]
*[HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL|To Use Parameters in Fluent BQL Queries]

|}]]></column>
		</row>
		<row PageID="ddc12506-3658-4f0a-b735-93bb0e035fd2" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e0e73ce6-29be-b334-e14d-7beca432f3b0" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Fluent business query language (BQL), which is described in this topic, is a dialect of BQL that is more similar to SQL than traditional BQL is. You can find all classes that can be used in fluent BQL in the <tt>PX.Data.BQL</tt> and <tt>PX.Data.BQL.Fluent</tt> namespaces.{br}{TOC}
==Fluent BQL Structure==
Fluent BQL uses nesting of generic classes. That is, each section of a fluent BQL query does not depend on the other sections and can appear in only specific places of the query. The order of the sections is shown in the following code.<source lang="csharp">SelectFrom&lt;&gt;.[Joins].Where&lt;&gt;.AggregateTo&lt;&gt;.OrderBy&lt;&gt;</source>{br}

<tt>SelectFrom&lt;&gt;</tt> is the only mandatory part of the query. You can add to the query any number of <tt>Join</tt> sections and the <tt>Where&lt;&gt;</tt>, <tt>AggregateTo&lt;&gt;</tt>, and <tt>OrderBy&lt;&gt;</tt> sections of the query, depending on whether you need the corresponding clauses of the query. {br}

The query defined with fluent BQL as described above is equivalent to the <tt>Select</tt> command in traditional BQL. To compose a query for different purposes (such as to define a data view or to define a <tt>Search</tt> command in an attribute constructor), you need to prepend additional elements to the query or append them to the query, as described in [HelpRoot_Dev_Platform\AD__con_View_Select_Search_in_Fluent_BQL|Search and Select Commands and Data Views in Fluent BQL]. You can find the equivalents of traditional BQL in fluent BQL in [HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents].
==SelectFrom&lt;&gt; Section==
In the <tt>SelectFrom&lt;&gt;</tt> section of the query, you use the <tt>SelectFrom&lt;&gt;</tt> class, which uses a data access class (DAC) as the type parameter. For details on DACs, see [HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL].
==Join Sections==
Each <tt>Join</tt> section of the fluent BQL query consists of the following components: [anchor|#_991dcc7d-c1cd-4545-8c77-75f9ba044900]
*The join type (<tt>InnerJoin&lt;&gt;</tt>, <tt>LeftJoin&lt;&gt;</tt>, <tt>RightJoin&lt;&gt;</tt>, <tt>FullJoin&lt;&gt;</tt>, <tt>CrossJoin&lt;&gt;</tt>) with the joined DAC as the type parameter.
*The joining condition (<tt>On&lt;&gt;</tt>). This condition is not specified for <tt>CrossJoin&lt;&gt;</tt>.
*The single table modifier (<tt>SingleTableOnly</tt>). This optional part of each <tt>Join</tt> section forces optimization if a DAC used in the query has the [https://help.acumatica.com/(W(3))/Main?ScreenId=ShowWiki&pageid=2331ae85-d8bc-88a4-a205-d9d41825f447|<tt>PXProjection</tt>] attribute.
The following code fragments show the <tt>Join</tt> sections with different types of joins.<source lang="csharp">.InnerJoin&lt;TBqlTable&gt;.On&lt;TJoinCondition&gt;.SingleTableOnly

.LeftJoin&lt;TBqlTable&gt;.On&lt;TJoinCondition&gt;.SingleTableOnly

.RightJoin&lt;TBqlTable&gt;.On&lt;TJoinCondition&gt;.SingleTableOnly

.FullJoin&lt;TBqlTable&gt;.On&lt;TJoinCondition&gt;.SingleTableOnly

.CrossJoin&lt;TBqlTable&gt;.SingleTableOnly</source>{br}

Fluent BQL queries can contain any number of <tt>Join</tt> sections.
==Where&lt;&gt; Section and On&lt;&gt; Subsection==
Conditions in the query are defined in the <tt>Where&lt;&gt;</tt> section and the <tt>On&lt;&gt;</tt> subsections of the <tt>Join</tt> sections. The conditions can contain the following nested components:[anchor|#_08c7560f-8a4f-41f5-86cf-fc163b4f8734]
*Comparisons, such as {{Table.field.IsEqual<TOperand>}}
*<tt>And&lt;&gt;</tt> subsections
*<tt>Or&lt;&gt;</tt> subsections
*<tt>Brackets&lt;&gt;</tt> subsections
{br}

The following code fragments show examples of an <tt>On&lt;&gt;</tt> subsection and a <tt>Where&lt;&gt;</tt> section.<source lang="csharp">.On&lt;PMTask.projectID.IsEqual&lt;PMProject.contractID&gt;.
  And&lt;
    PMTask.approverID.IsEqual&lt;EPActivityFilter.approverID.FromCurrent&gt;&gt;&gt;

.Where&lt;PMProject.isActive.IsEqual&lt;True&gt;.
  And&lt;PMTask.taskID.IsNotNull.
    Or&lt;PMProject.approverID.IsEqual&lt;
      EPActivityFilter.approverID.FromCurrent&gt;&gt;&gt;&gt;</source>
==AggregateTo&lt;&gt; and OrderBy&lt;&gt; Sections==
The <tt>AggregateTo&lt;&gt;</tt> and <tt>OrderBy&lt;&gt;</tt> sections of a fluent BQL query accept non-empty arrays of the specific base type as the only generic parameters. To make it easier for developers to write and read of the queries, fluent BQL includes groups of aliases that embed certain array usage. These aliases are pregenerated for arrays with up to 32 elements. {br}

The <tt>AggregateTo&lt;&gt;</tt> section can also include an optional <tt>Having&lt;&gt;</tt> subsection. In this subsection, you include conditions that can contain only logical operators, constants, parameters, and aggregated fields (that is, the fields with <tt>.Averaged</tt>, <tt>.Summarized</tt>, <tt>.Maximized</tt>, <tt>.Minimized</tt>, or <tt>.Grouped</tt> appended). {br}

The following code fragments show examples of <tt>AggregateTo&lt;&gt;</tt> and <tt>OrderBy&lt;&gt;</tt> sections.<source lang="csharp">.AggregateTo&lt;Sum&lt;field1&gt;, GroupBy&lt;field2&gt;, Max&lt;field3&gt;, 
  Min&lt;field4&gt;, Avg&lt;field5&gt;, Count&lt;field6&gt;&gt;.
    Having&lt;field5.Averaged.IsGreater&lt;Zero&gt;&gt;

.OrderBy&lt;field1.Asc, field2.Desc, field3.Asc&gt;</source>
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_View_Select_Search_in_Fluent_BQL|Search and Select Commands and Data Views in Fluent BQL]
*[HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL]
*[HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents]]]></column>
			<column name="PlainText"><![CDATA[Fluent Business Query Language Fluent business query language (BQL), which is described in this topic, is a dialect of BQL         that is more similar to SQL than traditional BQL is. You can find all classes that can be         used in fluent BQL in the  PX.Data.BQL  and            PX.Data.BQL.Fluent  namespaces. Fluent BQL Structure Fluent BQL uses nesting of generic classes. That is, each section of a fluent BQL query does         not depend on the other sections and can appear in only specific places of the query. The         order of the sections is shown in the following         code. SelectFrom<>.[Joins].Where<>.AggregateTo<>.OrderBy<> SelectFrom<>  is the only mandatory part of the query. You can add to         the query any number of  Join  sections and the            Where<> ,  AggregateTo<> , and            OrderBy<>  sections of the query, depending on whether you need the         corresponding clauses of the query.  The query defined with fluent BQL as described above is equivalent to the            Select  command in traditional BQL. To compose a query for different         purposes (such as to define a data view or to define a  Search  command in         an attribute constructor), you need to prepend additional elements to the query or append         them to the query, as described in  Search and Select Commands and Data Views in Fluent BQL. You can find the equivalents of         traditional BQL in fluent BQL in  Fluent BQL and Traditional BQL Equivalents. SelectFrom<> Section In the  SelectFrom<>  section of the query, you use the            SelectFrom<>  class, which uses a data access class (DAC) as the         type parameter. For details on DACs, see  Data Access Classes in Fluent BQL. Join Sections Each  Join  section of the fluent BQL query consists of the following         components:  The join type ( InnerJoin<> ,  LeftJoin<> ,                RightJoin<> ,  FullJoin<> ,                CrossJoin<> ) with the joined DAC as the type parameter. The joining condition ( On<> ). This condition is not specified             for  CrossJoin<> . The single table modifier ( SingleTableOnly ). This optional part of             each  Join  section forces optimization if a DAC used in the query has             the  PXProjection <tt>PXProjection</tt> attribute. The following code fragments show the  Join  sections with different         types of         joins. .InnerJoin<TBqlTable>.On<TJoinCondition>.SingleTableOnly

.LeftJoin<TBqlTable>.On<TJoinCondition>.SingleTableOnly

.RightJoin<TBqlTable>.On<TJoinCondition>.SingleTableOnly

.FullJoin<TBqlTable>.On<TJoinCondition>.SingleTableOnly

.CrossJoin<TBqlTable>.SingleTableOnly Fluent BQL queries can contain any number of  Join  sections. Where<> Section and On<> Subsection Conditions in the query are defined in the  Where<>  section and the            On<>  subsections of the  Join  sections. The         conditions can contain the following nested components: Comparisons, such as  Table.field.IsEqual<TOperand> And<>  subsections Or<>  subsections Brackets<>  subsections The following code fragments show examples of an  On<>  subsection and a            Where<>          section. .On<PMTask.projectID.IsEqual<PMProject.contractID>.
  And<
    PMTask.approverID.IsEqual<EPActivityFilter.approverID.FromCurrent>>>

.Where<PMProject.isActive.IsEqual<True>.
  And<PMTask.taskID.IsNotNull.
    Or<PMProject.approverID.IsEqual<
      EPActivityFilter.approverID.FromCurrent>>>> AggregateTo<> and OrderBy<> Sections The  AggregateTo<>  and  OrderBy<>  sections of a         fluent BQL query accept non-empty arrays of the specific base type as the only generic         parameters. To make it easier for developers to write and read of the queries, fluent BQL         includes groups of aliases that embed certain array usage. These aliases are pregenerated         for arrays with up to 32 elements.  The  AggregateTo<>  section can also include an optional            Having<>  subsection. In this subsection, you include conditions that         can contain only logical operators, constants, parameters, and aggregated fields (that is,         the fields with  .Averaged ,  .Summarized ,            .Maximized ,  .Minimized , or            .Grouped  appended).  The following code fragments show examples of  AggregateTo<>  and            OrderBy<>          sections. .AggregateTo<Sum<field1>, GroupBy<field2>, Max<field3>, 
  Min<field4>, Avg<field5>, Count<field6>>.
    Having<field5.Averaged.IsGreater<Zero>>

.OrderBy<field1.Asc, field2.Desc, field3.Asc> ]]></column>
		</row>
		<row PageID="957f950d-22cd-4b2f-81ca-77464d0c9eff" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="37902d7e-8752-4a12-c08b-c99922080f92" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The data access classes (DACs) that are used in fluent BQL differ from the DACs that are used in traditional BQL in the declarations of the class fields. For the general information about the declaration of DACs for both traditional BQL and fluent BQL, see [HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes].{br}

Each class field of a DAC (that is, each {{public abstract}} class of a DAC) is strongly typed, which makes it possible to perform compile-time code checks in Visual Studio. You derive class fields not from the <tt>IBqlField</tt> interface (as you would in traditional BQL) but from the specific fluent BQL classes that correspond to the type of the property field as shown in the following table. You assign the class field a name that starts with a lowercase letter.[anchor|#_fd84963d-fcc7-4e2a-a39f-869e681c297f]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! Type of the Property Field
!width="50%" ! Type of the Class Field
|- 
| {{bool}}
| <tt>BqlBool.Field&lt;TSelf&gt;</tt>
|- 
| {{byte}}
| <tt>BqlByte.Field&lt;TSelf&gt;</tt>
|- 
| {{short}}
| <tt>BqlShort.Field&lt;TSelf&gt;</tt>
|- 
| {{int}}
| <tt>BqlInt.Field&lt;TSelf&gt;</tt>
|- 
| {{long}}
| <tt>BqlLong.Field&lt;TSelf&gt;</tt>
|- 
| {{float}}
| <tt>BqlFloat.Field&lt;TSelf&gt;</tt>
|- 
| {{double}}
| <tt>BqlDouble.Field&lt;TSelf&gt;</tt>
|- 
| {{decimal}}
| <tt>BqlDecimal.Field&lt;TSelf&gt;</tt>
|- 
| {{Guid}}
| <tt>BqlGuid.Field&lt;TSelf&gt;</tt>
|- 
| {{DateTime}}
| <tt>BqlDateTime.Field&lt;TSelf&gt;</tt>
|- 
| {{String}}
| <tt>BqlString.Field&lt;TSelf&gt;</tt>
|- 
| {{byte[]}}
| <tt>BqlByteArray.Field&lt;TSelf&gt;</tt>
|}
The following code shows an example of the <tt>Product</tt> DAC declaration.<source lang="csharp">using System;
using PX.Data;

[Serializable]
public class Product : PX.Data.IBqlTable
{
    // The class used in BQL statements to refer to the ProductID column
    public abstract class productID : PX.Data.BQL.BqlInt.Field&lt;productID&gt;
    {
    }
    // The property holding the ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }

    // The class used in BQL statements to refer to the AvailQty column
    public abstract class availQty : PX.Data.BQL.BqlDecimal.Field&lt;availQty&gt;
    {
    }
    // The property holding the AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
}</source>
==Simultaneous Use of DACs in Fluent BQL and Traditional BQL==
The DAC fields declared in fluent BQL style can be used in traditional BQL queries without any modifications.{br}

The class fields that are defined in the traditional BQL style (as described in [HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes]) can be used in fluent BQL queries if you wrap these fields in the <tt>Use&lt;&gt;.As&#91;Type&#93;</tt> class, where {{[Type]}} is one of the following: {{Bool}}, {{Byte}}, {{Short}}, {{Int}}, {{Long}}, {{Float}}, {{Double}}, {{Decimal}}, {{Guid}}, {{DateTime}}, {{String}}, or {{ByteArray}}. {br}

The following code shows the definition of the {{availQty}} class field in the traditional BQL style and its use in a fluent BQL comparison.<source lang="csharp">public class Product : PX.Data.IBqlTable
{
    public abstract class availQty : PX.Data.IBqlField
    {
    }
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
}

SelectFrom&lt;Product&gt;.
    Where&lt;Use&lt;Product.availQty&gt;.AsDecimal.IsNotEqual&lt;Zero&gt;&gt;.
    View AvailableProducts;</source>{br}

Though the DAC fields in the traditional BQL style can be used in fluent BQL queries, we recommend that you use the fluent BQL style of DAC declaration for simplicity. 
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes]]]></column>
			<column name="PlainText"><![CDATA[Data Access Classes in Fluent BQL The data access classes (DACs) that are used in fluent BQL differ from the DACs that                 are used in traditional BQL in the declarations of the class fields. For the general                 information about the declaration of DACs for both traditional BQL and fluent BQL,                 see  Data Access Classes. Each class field of a DAC (that is, each  public abstract  class of a                 DAC) is strongly typed, which makes it possible to perform compile-time code checks                 in Visual Studio. You derive class fields not from the  IBqlField                  interface (as you would in traditional BQL) but from the specific fluent BQL classes                 that correspond to the type of the property field as shown in the following table.                 You assign the class field a name that starts with a lowercase letter. Type of the Property Field Type of the Class Field bool BqlBool.Field<TSelf> byte BqlByte.Field<TSelf> short BqlShort.Field<TSelf> int BqlInt.Field<TSelf> long BqlLong.Field<TSelf> float BqlFloat.Field<TSelf> double BqlDouble.Field<TSelf> decimal BqlDecimal.Field<TSelf> Guid BqlGuid.Field<TSelf> DateTime BqlDateTime.Field<TSelf> String BqlString.Field<TSelf> byte[] BqlByteArray.Field<TSelf> The following code shows an example of the  Product  DAC                 declaration. using System;
using PX.Data;

[Serializable]
public class Product : PX.Data.IBqlTable
{
    // The class used in BQL statements to refer to the ProductID column
    public abstract class productID : PX.Data.BQL.BqlInt.Field<productID>
    {
    }
    // The property holding the ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }

    // The class used in BQL statements to refer to the AvailQty column
    public abstract class availQty : PX.Data.BQL.BqlDecimal.Field<availQty>
    {
    }
    // The property holding the AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
} Simultaneous Use of DACs in Fluent BQL and Traditional BQL The DAC fields declared in fluent BQL style can be used in traditional BQL queries                 without any modifications. The class fields that are defined in the traditional BQL style (as described in  Data Access Classes) can be used in fluent BQL queries if you wrap                 these fields in the  Use<>.As[Type]  class, where                      [Type]  is one of the following:  Bool ,                      Byte ,  Short ,  Int ,                      Long ,  Float ,  Double ,                      Decimal ,  Guid ,  DateTime ,                      String , or  ByteArray .  The following code shows the definition of the  availQty  class field                 in the traditional BQL style and its use in a fluent BQL                 comparison. public class Product : PX.Data.IBqlTable
{
    public abstract class availQty : PX.Data.IBqlField
    {
    }
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
}

SelectFrom<Product>.
    Where<Use<Product.availQty>.AsDecimal.IsNotEqual<Zero>>.
    View AvailableProducts; Though the DAC fields in the traditional BQL style can be used in fluent BQL queries,                 we recommend that you use the fluent BQL style of DAC declaration for simplicity.  ]]></column>
		</row>
		<row PageID="89612b68-c812-438a-86c4-05b295d450c5" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="04a66740-d133-c952-9f4c-a57c637b163b" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use fluent business query language (BQL) to define data views and specify <tt>Select</tt> and <tt>Search</tt> commands. {br}{TOC}
==Data Views==
You can use any of the following approaches to define a data view:[anchor|#_8d8e7d7f-8520-4c11-99b3-c11e839407a8]
*Use the <tt>PXViewOf&lt;&gt;</tt> class before the fluent BQL query, as shown in the following code example.<source lang="csharp">PXViewOf&lt;Product&gt;.BasedOn&lt;
    SelectFrom&lt;Product&gt;.
        Where&lt;Product.isActive.IsEqual&lt;True&gt;&gt;&gt;.ReadOnly ActiveProducts;</source>
*:The DACs that are specified as type parameters in <tt>PXViewOf&lt;&gt;</tt> and <tt>SelectFrom&lt;&gt;</tt> must be the same; this is checked by the compiler. You can omit <tt>.BasedOn&lt;&gt;</tt> if you want to declare a view that selects all records from one table. You append <tt>.ReadOnly</tt> to the view definition if you need to define a read-only data view.
*Append <tt>.View</tt> to the fluent BQL query, as shown in the following code example.<source lang="csharp">SelectFrom&lt;Product&gt;.
    Where&lt;Product.isActive, Equal&lt;True&gt;&gt;.View.ReadOnly ActiveProducts;</source>
*:You append <tt>.ReadOnly</tt> to the view definition if you need to define a read-only data view.
{br}

The data views defined with fluent BQL are equivalent to the corresponding traditional BQL data views. For the full list of equivalents, see [HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents]. Also, the fluent BQL data views have the same static methods as the traditional BQL data views have. 
==Select Commands==
The query defined with fluent BQL, as described in [HelpRoot_Dev_Platform\AD__con_Fluent_BQL|Fluent Business Query Language], is equivalent to the <tt>Select</tt> BQL command. For the full list of equivalents, see [HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents].
==Search Commands==
You can use any of the following approaches to define a <tt>Search</tt> BQL command:[anchor|#_80ca7272-8156-494a-bc74-d0a322f0aa7e]
*Use the <tt>SearchFor&lt;&gt;</tt> class before the fluent BQL query, as shown in the following code example.<source lang="csharp">SearchFor&lt;Product.productId&gt;.In&lt;
    SelectFrom&lt;Product&gt;.
        Where&lt;Product.isActive.IsEqual&lt;True&gt;&gt;&gt;</source>
*Append <tt>.SearchFor&lt;&gt;</tt> to the fluent BQL query, as shown in the following code example.<source lang="csharp">SelectFrom&lt;Product&gt;.
    Where&lt;Product.isActive.IsEqual&lt;True&gt;&gt;.SearchFor&lt;Product.productId&gt;</source>
{br}

The <tt>Search</tt> commands defined with fluent BQL are equivalent to the corresponding traditional BQL commands. For the full list of equivalents, see [HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents].
==Dynamic Query Building==
Because <tt>SearchFor&lt;&gt;</tt> and <tt>SelectFrom&lt;&gt;</tt> are derived from the <tt>BqlCommand</tt> class, they can be used in dynamic query building through the <tt>WhereAnd</tt>, <tt>AppendJoin</tt>, and <tt>OrderByNew</tt> functions. However, fluent BQL commands (which are derived from the <tt>FbqlCommand</tt> class) aren&rsquo;t decomposed by <tt>BqlCommand.Decompose()</tt> directly. That is, the <tt>Decompose</tt> function checks whether a command has a <tt>FbqlCommand</tt> type, retrieves the type of its underlying <tt>BqlCommand</tt>, and decomposes this underlying <tt>BqlCommand</tt> command. Therefore, the elements of the array produced by the <tt>Decompose</tt> function are components of the <tt>BqlCommand</tt>, and are not components of the passed <tt>FbqlCommand</tt>. {br}

<tt>PXViewOf&lt;TBqlTable&gt;</tt> also supports all dynamic query building actions that the traditional BQL <tt>PXView</tt> supports.
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Fluent_BQL|Fluent Business Query Language]
*[HelpRoot_Dev_Platform\AD__con_FluentBQL_and_BQL_Equivalents|Fluent BQL and Traditional BQL Equivalents]]]></column>
			<column name="PlainText"><![CDATA[Search and Select Commands and Data Views in Fluent BQL You can use fluent business query language (BQL) to define data views and specify            Select  and  Search  commands.  Data Views You can use any of the following approaches to define a data view: Use the  PXViewOf<>  class before the fluent BQL query, as shown             in the following code               example. PXViewOf<Product>.BasedOn<
    SelectFrom<Product>.
        Where<Product.isActive.IsEqual<True>>>.ReadOnly ActiveProducts; The               DACs that are specified as type parameters in  PXViewOf<>  and                  SelectFrom<>  must be the same; this is checked by the               compiler. You can omit  .BasedOn<>  if you want to declare a view               that selects all records from one table. You append  .ReadOnly  to               the view definition if you need to define a read-only data view. Append  .View  to the fluent BQL query, as shown in the following             code               example. SelectFrom<Product>.
    Where<Product.isActive, Equal<True>>.View.ReadOnly ActiveProducts; You               append  .ReadOnly  to the view definition if you need to define a               read-only data view. The data views defined with fluent BQL are equivalent to the corresponding traditional BQL         data views. For the full list of equivalents, see  Fluent BQL and Traditional BQL Equivalents. Also, the fluent BQL data views have         the same static methods as the traditional BQL data views have.  Select Commands The query defined with fluent BQL, as described in  Fluent Business Query Language,         is equivalent to the  Select  BQL command. For the full list of         equivalents, see  Fluent BQL and Traditional BQL Equivalents. Search Commands You can use any of the following approaches to define a  Search  BQL           command: Use the  SearchFor<>  class before the fluent BQL query, as shown             in the following code             example. SearchFor<Product.productId>.In<
    SelectFrom<Product>.
        Where<Product.isActive.IsEqual<True>>> Append  .SearchFor<>  to the fluent BQL query, as shown in the             following code             example. SelectFrom<Product>.
    Where<Product.isActive.IsEqual<True>>.SearchFor<Product.productId> The  Search  commands defined with fluent BQL are equivalent to the         corresponding traditional BQL commands. For the full list of equivalents, see  Fluent BQL and Traditional BQL Equivalents. Dynamic Query Building Because  SearchFor<>  and  SelectFrom<>  are         derived from the  BqlCommand  class, they can be used in dynamic query         building through the  WhereAnd ,  AppendJoin , and            OrderByNew  functions. However, fluent BQL commands (which are derived         from the  FbqlCommand  class) aren't decomposed by            BqlCommand.Decompose()  directly. That is, the            Decompose  function checks whether a command has a            FbqlCommand  type, retrieves the type of its underlying            BqlCommand , and decomposes this underlying            BqlCommand  command. Therefore, the elements of the array produced by         the  Decompose  function are components of the            BqlCommand , and are not components of the passed            FbqlCommand .  PXViewOf<TBqlTable>  also supports all dynamic query building actions         that the traditional BQL  PXView  supports. ]]></column>
		</row>
		<row PageID="84837158-8b2f-4f18-b51d-4c89bc165dc4" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="c55ad824-dd0a-8808-0dbb-707945c09c67" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use predefined constants (such as integer <tt>Zero</tt>, datetime <tt>Now</tt>, <tt>Today</tt>, and <tt>MaxDate</tt>, string <tt>StringEmpty</tt>, and the Boolean values <tt>True</tt> and <tt>False</tt>) in fluent BQL queries without any changes.{br}

If you need to use a custom constant in a fluent BQL query, you define this constant by using the class that corresponds to the C# type of the constant. The following table lists the constant classes that correspond to C# types.[anchor|#_a8937995-2493-4cbb-a00e-3311c19fe60e]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! C# Type
!width="50%" ! Fluent BQL Type
|- 
| {{bool}}
| <tt>BqlBool.Constant&lt;TSelf&gt;</tt>
|- 
| {{byte}}
| <tt>BqlByte.Constant&lt;TSelf&gt;</tt>
|- 
| {{short}}
| <tt>BqlShort.Constant&lt;TSelf&gt;</tt>
|- 
| {{int}}
| <tt>BqlInt.Constant&lt;TSelf&gt;</tt>
|- 
| {{long}}
| <tt>BqlLong.Constant&lt;TSelf&gt;</tt>
|- 
| {{float}}
| <tt>BqlFloat.Constant&lt;TSelf&gt;</tt>
|- 
| {{double}}
| <tt>BqlDouble.Constant&lt;TSelf&gt;</tt>
|- 
| {{decimal}}
| <tt>BqlDecimal.Constant&lt;TSelf&gt;</tt>
|- 
| {{Guid}}
| <tt>BqlGuid.Constant&lt;TSelf&gt;</tt>
|- 
| {{DateTime}}
| <tt>BqlDateTime.Constant&lt;TSelf&gt;</tt>
|- 
| {{String}}
| <tt>BqlString.Constant&lt;TSelf&gt;</tt>
|}{br}

The following code shows an example of the {{decimal_0}} constant declaration.<source lang="csharp">public class decimal_0 : PX.Data.BQL.BqlDecimal.Constant&lt;decimal_0&gt; 
{ 
  public decimal_0()
    : base(0m)
  {
  }
}</source>
==Simultaneous Use of Constants in Fluent BQL and Traditional BQL==
The predefined constants and the constants defined as described in the previous section can be used in traditional BQL without any changes. {br}

The constants defined in the traditional BQL style (that is, derived from the <tt>Constant&lt;Type&gt;</tt> class) can be used in the fluent BQL queries if you wrap these constants in the <tt>Use&lt;&gt;.As&#91;Type&#93;</tt> class, where {{[Type]}} is one of the following: {{Bool}}, {{Byte}}, {{Short}}, {{Int}}, {{Long}}, {{Float}}, {{Double}}, {{Decimal}}, {{Guid}}, {{DateTime}}, or {{String}}. {br}

The following code shows the declaration of the {{decimal_0}} constant in traditional BQL style and its use in a fluent BQL comparison.<source lang="csharp">publicclass decimal_0 : Constant&lt;Decimal&gt;
{
    public decimal_0()
        : base(0m)
    {
    }
}

SelectFrom&lt;Table&gt;.
    Where&lt;Table.decimalField.AsDecimal.IsEqual&lt;Use&lt;decimal_0&gt;.AsDecimal&gt;&gt;.
    View records;</source>{br}

Although the constants in the traditional BQL style can be used in fluent BQL queries, we recommend that you use the fluent BQL style of constant declaration for simplicity. ]]></column>
			<column name="PlainText"><![CDATA[Constants in Fluent BQL You can use predefined constants (such as integer  Zero , datetime       Now ,  Today , and  MaxDate , string       StringEmpty , and the Boolean values  True  and       False ) in fluent BQL queries without any changes. If you need to use a custom constant in a fluent BQL query, you define this constant by using     the class that corresponds to the C# type of the constant. The following table lists the     constant classes that correspond to C# types. C# Type Fluent BQL Type bool BqlBool.Constant<TSelf> byte BqlByte.Constant<TSelf> short BqlShort.Constant<TSelf> int BqlInt.Constant<TSelf> long BqlLong.Constant<TSelf> float BqlFloat.Constant<TSelf> double BqlDouble.Constant<TSelf> decimal BqlDecimal.Constant<TSelf> Guid BqlGuid.Constant<TSelf> DateTime BqlDateTime.Constant<TSelf> String BqlString.Constant<TSelf> The following code shows an example of the  decimal_0  constant     declaration. public class decimal_0 : PX.Data.BQL.BqlDecimal.Constant<decimal_0> 
{ 
  public decimal_0()
    : base(0m)
  {
  }
} Simultaneous Use of Constants in Fluent BQL and Traditional BQL The predefined constants and the constants defined as described in the previous section can be     used in traditional BQL without any changes.  The constants defined in the traditional BQL style (that is, derived from the       Constant<Type>  class) can be used in the fluent BQL queries if you     wrap these constants in the  Use<>.As[Type]  class, where       [Type]  is one of the following:  Bool ,  Byte ,       Short ,  Int ,  Long ,  Float ,       Double ,  Decimal ,  Guid ,       DateTime , or  String .  The following code shows the declaration of the  decimal_0  constant in     traditional BQL style and its use in a fluent BQL     comparison. publicclass decimal_0 : Constant<Decimal>
{
    public decimal_0()
        : base(0m)
    {
    }
}

SelectFrom<Table>.
    Where<Table.decimalField.AsDecimal.IsEqual<Use<decimal_0>.AsDecimal>>.
    View records; Although the constants in the traditional BQL style can be used in fluent BQL queries, we     recommend that you use the fluent BQL style of constant declaration for simplicity.  ]]></column>
		</row>
		<row PageID="9d56ea11-0768-4f4d-b7ab-1cea724c42cb" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8ccb9efc-301f-a43f-b8b8-3ce7b026c9bd" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you need to specify values in a fluent business query language (BQL) statement, you use fluent BQL parameters, which are replaced with the needed values in the translation to SQL. For details about how BQL statements with parameters are translated to SQL, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL#_ff6436a7-d8a9-43c8-9201-d5ea9afbe2d5|Translation of a BQL Command with Parameters to an SQL Query Tree].{br}

In this topic, you can find a description of the fluent BQL parameters and the difference between them.{br}{TOC}
==Use of the Current Value of the Field from PXCache==
To insert into the SQL query the field value of the <tt>Current</tt> object from the <tt>PXCache</tt> object, you append <tt>.FromCurrent</tt> to the field name in a fluent BQL query. If the <tt>Current</tt> object from the <tt>PXCache</tt> object is {{null}}, <tt>FromCurrent</tt> retrieves the default value of the field. If you do not need to retrieve the default value if the <tt>Current</tt> object is {{null}}, you need to append <tt>.FromCurrent.NoDefault</tt> to the field name in a fluent BQL query. In this case, the system doesn&rsquo;t retrieve the default value and inserts {{null}}.{br}

((({S:Hint}<tt>FromCurrent</tt> is the equivalent of the <tt>Current</tt> parameter in traditional BQL. <tt>FromCurrent.NoDefault</tt> is the equivalent of the <tt>Current2</tt> parameter in traditional BQL.
))){br}

By using the current field value from <tt>PXCache</tt> in the declaration of a data view, you can refer to another view to relate these data views to each other. A typical example is referencing the current master record on master-detail webpages. For details on how the current field value is used, see [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL#_27cf551c-951d-463a-9005-74584894a725|To Relate Data Views to Each Another].
==Insertion of a Specific Value into the Query==
To insert a specific value into the SQL query, you use the <tt>@P.As&#91;Type&#93;</tt> classes, where <tt>&#91;Type&#93;</tt> corresponds to the C# type of the parameter. The following table lists the fluent BQL types that correspond to C# types.[anchor|#_2acba4b9-005f-40c9-bb43-efa627ae5120]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! C# Type
!width="50%" ! Fluent BQL Type
|- 
| {{bool}}
| <tt>@P.AsBool</tt>
|- 
| {{byte}}
| <tt>@P.AsByte</tt>
|- 
| {{short}}
| <tt>@P.AsShort</tt>
|- 
| {{int}}
| <tt>@P.AsInt</tt>
|- 
| {{long}}
| <tt>@P.AsLong</tt>
|- 
| {{float}}
| <tt>@P.AsFloat</tt>
|- 
| {{double}}
| <tt>@P.AsDouble</tt>
|- 
| {{decimal}}
| <tt>@P.AsDecimal</tt>
|- 
| {{Guid}}
| <tt>@P.AsGuid</tt>
|- 
| {{DateTime}}
| <tt>@P.AsDateTime</tt>
|- 
| {{String}}
| <tt>@P.AsString</tt>
|}((({S:Hint} <tt>@P.As&#91;Type&#93;</tt> is the equivalent of the <tt>Required</tt> parameter in traditional BQL.
)))
By using these classes, you can pass values to the SQL query, as described in [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL#_6e19063a-c756-4b7d-88a0-7d0100a187d9|To Pass a Field Value to the SQL Query] and [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL#_cc3c4e58-b049-4351-b3c6-ebd9e62a350d|To Pass Multiple Field Values to the SQL Query].
==Insertion of an Optional Value into the Query==
To insert an optional value into the query, you append <tt>.AsOptional</tt> to the field name in a fluent BQL query. If you specify an explicit value for this parameter during the execution of the BQL statement, <tt>AsOptional</tt> uses the specified value. If you don&rsquo;t specify an explicit value for this parameter during the execution of the BQL statement, <tt>AsOptional</tt> works similarly to <tt>FromCurrent</tt>—that is, retrieves the field value of the <tt>Current</tt> object from the <tt>PXCache</tt> object and uses the default value of the field if the <tt>Current</tt> object is {{null}}. You can append <tt>.AsOptional.NoDefault</tt> to the field name in a fluent BQL query to make the system not use the default value and insert {{null}}.{br}

((({S:Hint}<tt>AsOptional</tt> is the equivalent of the <tt>Optional</tt> parameter in traditional BQL. <tt>AsOptional.NoDefault</tt> is the equivalent of the <tt>Optional2</tt> parameter in traditional BQL.
))){br}

By using <tt>AsOptional</tt>, you can pass the external presentations of the values to the SQL query, as described in [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL#_4473b629-e9a7-4f41-9041-c0442303d2be|To Provide External Presentation of the Field Value to the SQL Query].
==Insertion of a Value from the UI Control into the Query==
To insert a value from the UI control into the SQL query, you use the <tt>Argument.As&#91;Type&#93;</tt> classes, where <tt>&#91;Type&#93;</tt> corresponds to the C# type of the inserted value. The following table lists the fluent BQL types that correspond to C# types.[anchor|#_9fff804f-5503-4bc6-aaa2-d55fa0551358]
{| class="checklist" | width="100%" 
|- 
!width="50%" ! C# Type
!width="50%" ! Fluent BQL Type
|- 
| {{bool}}
| <tt>Argument.AsBool</tt>
|- 
| {{byte}}
| <tt>Argument.AsByte</tt>
|- 
| {{short}}
| <tt>Argument.AsShort</tt>
|- 
| {{int}}
| <tt>Argument.AsInt</tt>
|- 
| {{long}}
| <tt>Argument.AsLong</tt>
|- 
| {{float}}
| <tt>Argument.AsFloat</tt>
|- 
| {{double}}
| <tt>Argument.AsDouble</tt>
|- 
| {{decimal}}
| <tt>Argument.AsDecimal</tt>
|- 
| {{Guid}}
| <tt>Argument.AsGuid</tt>
|- 
| {{DateTime}}
| <tt>Argument.AsDateTime</tt>
|- 
| {{String}}
| <tt>Argument.AsString</tt>
|}{br}

By using the <tt>Argument</tt> classes, you can pass values to the data view delegates. For more information on how to use the <tt>Argument</tt> classes, see [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL#_1f3bef64-92a7-469f-9fd2-89f0910565fe|To Pass a Value from a UI Control to a Data View].
==Related Articles==
*[HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL|To Use Parameters in Fluent BQL Queries]]]></column>
			<column name="PlainText"><![CDATA[Parameters in Fluent BQL If you need to specify values in a fluent business query language (BQL) statement, you use     fluent BQL parameters, which are replaced with the needed values in the translation to SQL. For     details about how BQL statements with parameters are translated to SQL, see  Translation of a BQL Command with Parameters to an SQL Query Tree. In this topic, you can find a description of the fluent BQL parameters and the difference     between them. Use of the Current Value of the Field from PXCache To insert into the SQL query the field value of the  Current  object from the       PXCache  object, you append  .FromCurrent  to the field name     in a fluent BQL query. If the  Current  object from the       PXCache  object is  null ,  FromCurrent      retrieves the default value of the field. If you do not need to retrieve the default value if     the  Current  object is  null , you need to append       .FromCurrent.NoDefault  to the field name in a fluent BQL query. In this     case, the system doesn't retrieve the default value and inserts  null . FromCurrent  is the equivalent of the  Current       parameter in traditional BQL.  FromCurrent.NoDefault  is the equivalent of the        Current2  parameter in traditional BQL. By using the current field value from  PXCache  in the declaration of a data     view, you can refer to another view to relate these data views to each other. A typical example     is referencing the current master record on master-detail webpages. For details on how the     current field value is used, see  To Relate Data Views to Each Another. Insertion of a Specific Value into the Query To insert a specific value into the SQL query, you use the  @P.As[Type]      classes, where  [Type]  corresponds to the C# type of the parameter. The     following table lists the fluent BQL types that correspond to C# types. C# Type Fluent BQL Type bool @P.AsBool byte @P.AsByte short @P.AsShort int @P.AsInt long @P.AsLong float @P.AsFloat double @P.AsDouble decimal @P.AsDecimal Guid @P.AsGuid DateTime @P.AsDateTime String @P.AsString @P.As[Type]  is the equivalent of the  Required      parameter in traditional BQL. By using these classes, you can pass values to the SQL query, as described in  To Pass a Field Value to the SQL Query and  To Pass Multiple Field Values to the SQL Query. Insertion of an Optional Value into the Query To insert an optional value into the query, you append  .AsOptional  to the     field name in a fluent BQL query. If you specify an explicit value for this parameter during the     execution of the BQL statement,  AsOptional  uses the specified value. If you     don't specify an explicit value for this parameter during the execution of the BQL statement,       AsOptional  works similarly to  FromCurrent —that is,     retrieves the field value of the  Current  object from the       PXCache  object and uses the default value of the field if the       Current  object is  null . You can append       .AsOptional.NoDefault  to the field name in a fluent BQL query to make the     system not use the default value and insert  null . AsOptional  is the equivalent of the  Optional       parameter in traditional BQL.  AsOptional.NoDefault  is the equivalent of the        Optional2  parameter in traditional BQL. By using  AsOptional , you can pass the external presentations of the values     to the SQL query, as described in  To Provide External Presentation of the Field Value to the SQL Query. Insertion of a Value from the UI Control into the Query To insert a value from the UI control into the SQL query, you use the       Argument.As[Type]  classes, where  [Type]  corresponds to     the C# type of the inserted value. The following table lists the fluent BQL types that     correspond to C# types. C# Type Fluent BQL Type bool Argument.AsBool byte Argument.AsByte short Argument.AsShort int Argument.AsInt long Argument.AsLong float Argument.AsFloat double Argument.AsDouble decimal Argument.AsDecimal Guid Argument.AsGuid DateTime Argument.AsDateTime String Argument.AsString By using the  Argument  classes, you can pass values to the data view     delegates. For more information on how to use the  Argument  classes, see  To Pass a Value from a UI Control to a Data View. ]]></column>
		</row>
		<row PageID="3a964dfb-df28-4bea-89d6-76439c44dae3" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2428016c-4fbf-ed7a-1213-3fbff3d5f64f" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can select records from the database by constructing a fluent business query language (BQL) statement. To construct a fluent BQL statement, you use the <tt>SelectFrom&lt;&gt;</tt> class and append the needed clauses to the statement. [anchor|#_a2ece77b-73d5-4c7b-a46a-73a1b3a9f0b5]{br}

This topic describes how to compose <tt>Select</tt> statements by using fluent BQL. For details on how to adjust these statements to define data views or to specify <tt>Search</tt> commands in fluent BQL, see [HelpRoot_Dev_Platform\AD__con_View_Select_Search_in_Fluent_BQL|Search and Select Commands and Data Views in Fluent BQL]. ((({S:Hint}In a <tt>SelectFrom&lt;&gt;</tt> class, you configure a query to the database. The actual request to the database is performed once you cast the result of the query execution to a DAC or an array of DACs, or when you iterate through DACs in the result with the {{foreach}} statement. For details, see [HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution].
)))[anchor|#_1f0a8248-99eb-4897-be95-8bb852d09cbc]
==Before You Proceed==
[anchor|#_71cbee56-a5b5-41f7-8413-216710bfe2ac]
*Make sure that the application database has the database tables from which you are going to request data, and that the application defines the data access classes (DACs) for these tables. For more information on defining DACs, see [HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL].
*Add references to <tt>PX.Data.dll</tt> and <tt>PX.Data.BQL.Fluent.dll</tt> in the project.
*Add the following {{using}} directives to your code.<source lang="csharp">using PX.Data.BQL.Fluent;
using PX.Data.BQL;</source>
[anchor|#_7070d995-fef5-4f90-98ce-2918b02a9a19]
==To Compose a Fluent BQL Statement==
[anchor|#_9576d07d-2304-4d27-98de-691ba2e984a5]
#Type the <tt>SelectFrom&lt;&gt;</tt> class with the needed DAC as the type parameter.
#:For example, suppose that you need to convert the following SQL statement to fluent BQL. {{{{SELECT Product.CategoryCD, MIN(Product.BookedQty) FROM Product
INNER JOIN SupplierProduct
    ON SupplierProduct.ProductID = Product.ProductID
INNER JOIN Supplier
    ON Supplier.AccountID = SupplierProduct.AccountID
WHERE (Product.BookedQty IS NOT NULL
       AND Product.AvailQty IS NOT NULL
       AND Product.MinAvailQty IS NOT NULL
       AND(Product.Active = 1
           OR Product.Active IS NULL)
       AND(Product.BookedQty &gt; Product.AvailQty
           OR Product.AvailQty &lt; Product.MinAvailQty))
    OR Product.AvailQty IS NOT NULL
GROUP BY Product.CategoryCD
ORDER BY Product.UnitPrice, Product.AvailQty DESC
}}}}
#:You start the corresponding fluent BQL query as follows.<source lang="csharp">SelectFrom&lt;Product&gt;</source>
#If you need to include {{JOIN}} clauses in the query, for each table that you want to join, do the following:
##Append to the statement one of the <tt>Join</tt> classes—such as <tt>InnerJoin</tt>, <tt>LeftJoin</tt>, <tt>RightJoin</tt>, <tt>FullJoin</tt>, or <tt>CrossJoin</tt>, which are directly mapped to SQL <tt>JOIN</tt> clauses. 
##Append to the statement the <tt>On&lt;&gt;</tt> clause with the joining conditions. Adhere to the following rules when you specify the conditions:
##*Use the <tt>And&lt;&gt;</tt>, <tt>Or&lt;&gt;</tt>, and <tt>Brackets&lt;&gt;</tt> classes to logically connect the conditions and comparisons.[anchor|#_8ef83ff3-aa85-4491-83fb-ce6963f5795a]
##*To specify the fields that should be used in the conditions, use the class fields defined in the DAC, such as <tt>Product.productID</tt>. (The name of the field class starts with a lowercase letter. Do not confuse it with the property field, which has the same name but starts with an uppercase letter.) [anchor|#_7695e00c-ee33-4b01-9f97-3ea80cec91ee]
##*If you need to use constants in the fluent BQL statement, use one of the predefined BQL constants or your own constant. (For details on using constants, see [HelpRoot_Dev_Platform\AD__con_Constants_in_FBQL|Constants in Fluent BQL].) [anchor|#_c98f33ac-6096-49f1-b910-ea628253253f]
##*If you need to specify the values of the parameters at run time, use the fluent BQL parameters. For information about parameters, see [HelpRoot_Dev_Platform\AC__con_Parameters_in_FBQL|Parameters in Fluent BQL]. For information about how to use parameters, see [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL|To Use Parameters in Fluent BQL Queries]. 
#:In the sample code that has been presented in this topic, you would add two <tt>Join</tt> classes to the statement, as follows.<source lang="csharp">SelectFrom&lt;Product&gt;.
    InnerJoin&lt;SupplierProduct&gt;.
        On&lt;SupplierProduct.productID.IsEqual&lt;Product.productID&gt;&gt;.
    InnerJoin&lt;Supplier&gt;.
        On&lt;Supplier.accountID.IsEqual&lt;SupplierProduct.accountID&gt;&gt;</source>
#If you need to include a {{WHERE}} clause in the query, append the <tt>Where&lt;&gt;</tt> clause to the statement and specify the conditions as follows:
#*Use the <tt>And&lt;&gt;</tt>, <tt>Or&lt;&gt;</tt>, and <tt>Brackets&lt;&gt;</tt> classes to logically connect the conditions and comparisons.[anchor|#_32bb3b50-2c36-4b6a-828d-dc4d06a310c8]
#*To specify the fields that should be used in the conditions, use the class fields defined in the DAC, such as <tt>Product.productID</tt>. (The name of the field class starts with a lowercase letter. Do not confuse it with the property field, which has the same name but starts with an uppercase letter.) [anchor|#_ec9ef3f8-cf5a-4265-84f7-2028c82e4ad9]
#*If you need to use constants in the fluent BQL statement, use one of the predefined BQL constants or your own constant. (For details on using constants, see [HelpRoot_Dev_Platform\AD__con_Constants_in_FBQL|Constants in Fluent BQL].) [anchor|#_fa7e23c6-fe5d-4cef-a21a-00c2bcc48a44]
#*If you need to specify the values of the parameters at run time, use the fluent BQL parameters. For information about parameters, see [HelpRoot_Dev_Platform\AC__con_Parameters_in_FBQL|Parameters in Fluent BQL]. For information about how to use parameters, see [HelpRoot_Dev_Platform\AD__how_Use_Parameters_in_FBQL|To Use Parameters in Fluent BQL Queries]. 
#:In the sample code that has been presented in this topic, you would append the <tt>Where&lt;&gt;</tt> clause to the statement, as follows.<source lang="csharp">SelectFrom&lt;Product&gt;.
    InnerJoin&lt;SupplierProduct&gt;.
        On&lt;SupplierProduct.productID.IsEqual&lt;Product.productID&gt;&gt;.
    InnerJoin&lt;Supplier&gt;.
        On&lt;Supplier.accountID.IsEqual&lt;SupplierProduct.accountID&gt;&gt;.
    Where&lt;
        Brackets&lt;Product.bookedQty.IsNotNull.
            And&lt;Product.availQty.IsNotNull&gt;.
            And&lt;Product.minAvailQty.IsNotNull&gt;.
            And&lt;Product.active.IsEqual&lt;True&gt;.
                Or&lt;Product.active.IsNull&gt;&gt;.
            And&lt;Product.bookedQty.IsGreater&lt;Product.availQty&gt;.
                Or&lt;Product.availQty.IsLess&lt;Product.minAvailQty&gt;&gt;&gt;&gt;.
        Or&lt;Product.availQty.IsNotNull&gt;&gt;</source>
#If you need to group or aggregate records, append the <tt>AggregateTo&lt;&gt;</tt> clause to the statement and specify the grouping conditions and aggregation functions by using the <tt>GroupBy</tt> clauses and the <tt>Min</tt>, <tt>Max</tt>, <tt>Sum</tt>, <tt>Avg</tt>, and <tt>Count</tt> aggregation functions.
#:In the sample code that has been presented in this topic, you would append the <tt>AggregateTo&lt;&gt;</tt> clause to the statement as follows.<source lang="csharp">SelectFrom&lt;Product&gt;.
    InnerJoin&lt;SupplierProduct&gt;.
        On&lt;SupplierProduct.productID.IsEqual&lt;Product.productID&gt;&gt;.
    InnerJoin&lt;Supplier&gt;.
        On&lt;Supplier.accountID.IsEqual&lt;SupplierProduct.accountID&gt;&gt;.
    Where&lt;
        Brackets&lt;Product.bookedQty.IsNotNull.
            And&lt;Product.availQty.IsNotNull&gt;.
            And&lt;Product.minAvailQty.IsNotNull&gt;.
            And&lt;Product.active.IsEqual&lt;True&gt;.
                Or&lt;Product.active.IsNull&gt;&gt;.
            And&lt;Product.bookedQty.IsGreater&lt;Product.availQty&gt;.
                Or&lt;Product.availQty.IsLess&lt;Product.minAvailQty&gt;&gt;&gt;&gt;.
        Or&lt;Product.availQty.IsNotNull&gt;&gt;.
    AggregateTo&lt;GroupBy&lt;Product.categoryCD&gt;, 
                Min&lt;Product.bookedQty&gt;&gt;</source>
#If you need to order records, append to the statement the <tt>OrderBy&lt;&gt;</tt> clause with the <tt>Asc&lt;&gt;</tt> and <tt>Desc&lt;&gt;</tt> classes as the type parameters.
#:In the sample code that has been presented in this topic, you would append the <tt>OrderBy&lt;&gt;</tt> clause to the statement as follows.<source lang="csharp">SelectFrom&lt;Product&gt;.
    InnerJoin&lt;SupplierProduct&gt;.
        On&lt;SupplierProduct.productID.IsEqual&lt;Product.productID&gt;&gt;.
    InnerJoin&lt;Supplier&gt;.
        On&lt;Supplier.accountID.IsEqual&lt;SupplierProduct.accountID&gt;&gt;.
    Where&lt;
        Brackets&lt;Product.bookedQty.IsNotNull.
            And&lt;Product.availQty.IsNotNull&gt;.
            And&lt;Product.minAvailQty.IsNotNull&gt;.
            And&lt;Product.active.IsEqual&lt;True&gt;.
                Or&lt;Product.active.IsNull&gt;&gt;.
            And&lt;Product.bookedQty.IsGreater&lt;Product.availQty&gt;.
                Or&lt;Product.availQty.IsLess&lt;Product.minAvailQty&gt;&gt;&gt;&gt;.
        Or&lt;Product.availQty.IsNotNull&gt;&gt;.
    AggregateTo&lt;GroupBy&lt;Product.categoryCD&gt;, 
                Min&lt;Product.bookedQty&gt;&gt;.
    OrderBy&lt;Product.unitPrice.Asc, 
            Product.availQty.Desc&gt;</source>

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Fluent_BQL|Fluent Business Query Language]
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]
*[HelpRoot_Dev_Platform\AD__how_Execute_BQL_Statement|To Execute BQL Statements]]]></column>
			<column name="PlainText"><![CDATA[To Select Records by Using Fluent BQL You can select records from the database by constructing a fluent business query                 language (BQL) statement. To construct a fluent BQL statement, you use the                      SelectFrom<>  class and append the needed clauses to the                 statement.  This topic describes how to compose                      Select  statements by using fluent BQL. For details on how to                 adjust these statements to define data views or to specify  Search                  commands in fluent BQL, see  Search and Select Commands and Data Views in Fluent BQL.                      In a  SelectFrom<>  class, you configure a query to                     the database. The actual request to the database is performed once you cast the                     result of the query execution to a DAC or an array of DACs, or when you iterate through                     DACs in the result with the  foreach  statement. For details, see                          Data Query Execution. Before You Proceed Make sure that the application database has the database tables from which                         you are going to request data, and that the application defines the data                         access classes (DACs) for these tables. For more information on defining                         DACs, see  Data Access Classes in Fluent BQL. Add references to  PX.Data.dll  and                              PX.Data.BQL.Fluent.dll  in the project. Add the following  using  directives to your                         code. using PX.Data.BQL.Fluent;
using PX.Data.BQL; To Compose a Fluent BQL Statement Type the  SelectFrom<>  class with the needed DAC as the                         type parameter. For example, suppose that you need to convert the                             following SQL statement to fluent BQL.                              SELECT Product.CategoryCD, MIN(Product.BookedQty) FROM Product
INNER JOIN SupplierProduct
    ON SupplierProduct.ProductID = Product.ProductID
INNER JOIN Supplier
    ON Supplier.AccountID = SupplierProduct.AccountID
WHERE (Product.BookedQty IS NOT NULL
       AND Product.AvailQty IS NOT NULL
       AND Product.MinAvailQty IS NOT NULL
       AND(Product.Active = 1
           OR Product.Active IS NULL)
       AND(Product.BookedQty > Product.AvailQty
           OR Product.AvailQty < Product.MinAvailQty))
    OR Product.AvailQty IS NOT NULL
GROUP BY Product.CategoryCD
ORDER BY Product.UnitPrice, Product.AvailQty DESC You                             start the corresponding fluent BQL query as                             follows. SelectFrom<Product> If you need to include  JOIN  clauses in the query, for each                         table that you want to join, do the following: Append to the statement one of the  Join                                  classes—such as  InnerJoin ,                                      LeftJoin ,  RightJoin ,                                      FullJoin , or  CrossJoin ,                                 which are directly mapped to SQL  JOIN  clauses.  Append to the statement the  On<>  clause with                                 the joining conditions. Adhere to the following rules when you                                 specify the conditions: Use the  And<> ,  Or<> , and                      Brackets<>  classes to logically connect the conditions and                 comparisons. To specify the fields that should be used in the                 conditions, use the class fields defined in the DAC, such as                      Product.productID . (The name of the field class starts with a                 lowercase letter. Do not confuse it with the property field, which has the same name                 but starts with an uppercase letter.)  If you need to use constants in the fluent BQL                 statement, use one of the predefined BQL constants or your own constant. (For                 details on using constants, see  Constants in Fluent BQL.)  If you need to specify the values of the parameters                 at run time, use the fluent BQL parameters. For information about parameters, see                      Parameters in Fluent BQL. For                 information about how to use parameters, see  To Use Parameters in Fluent BQL Queries.  In the sample code that has been presented in this topic, you would                             add two  Join  classes to the statement, as                             follows. SelectFrom<Product>.
    InnerJoin<SupplierProduct>.
        On<SupplierProduct.productID.IsEqual<Product.productID>>.
    InnerJoin<Supplier>.
        On<Supplier.accountID.IsEqual<SupplierProduct.accountID>> If you need to include a  WHERE  clause in the query, append                         the  Where<>  clause to the statement and specify the                         conditions as follows: Use the  And<> ,  Or<> , and                      Brackets<>  classes to logically connect the conditions and                 comparisons. To specify the fields that should be used in the                 conditions, use the class fields defined in the DAC, such as                      Product.productID . (The name of the field class starts with a                 lowercase letter. Do not confuse it with the property field, which has the same name                 but starts with an uppercase letter.)  If you need to use constants in the fluent BQL                 statement, use one of the predefined BQL constants or your own constant. (For                 details on using constants, see  Constants in Fluent BQL.)  If you need to specify the values of the parameters                 at run time, use the fluent BQL parameters. For information about parameters, see                      Parameters in Fluent BQL. For                 information about how to use parameters, see  To Use Parameters in Fluent BQL Queries.  In the sample code that has been presented in this topic, you would                             append the  Where<>  clause to the statement, as                             follows. SelectFrom<Product>.
    InnerJoin<SupplierProduct>.
        On<SupplierProduct.productID.IsEqual<Product.productID>>.
    InnerJoin<Supplier>.
        On<Supplier.accountID.IsEqual<SupplierProduct.accountID>>.
    Where<
        Brackets<Product.bookedQty.IsNotNull.
            And<Product.availQty.IsNotNull>.
            And<Product.minAvailQty.IsNotNull>.
            And<Product.active.IsEqual<True>.
                Or<Product.active.IsNull>>.
            And<Product.bookedQty.IsGreater<Product.availQty>.
                Or<Product.availQty.IsLess<Product.minAvailQty>>>>.
        Or<Product.availQty.IsNotNull>> If you need to group or aggregate records, append the                              AggregateTo<>  clause to the statement and specify                         the grouping conditions and aggregation functions by using the                              GroupBy  clauses and the  Min ,                              Max ,  Sum ,  Avg ,                         and  Count  aggregation functions. In the sample code                             that has been presented in this topic, you would append the                                  AggregateTo<>  clause to the statement as                         follows. SelectFrom<Product>.
    InnerJoin<SupplierProduct>.
        On<SupplierProduct.productID.IsEqual<Product.productID>>.
    InnerJoin<Supplier>.
        On<Supplier.accountID.IsEqual<SupplierProduct.accountID>>.
    Where<
        Brackets<Product.bookedQty.IsNotNull.
            And<Product.availQty.IsNotNull>.
            And<Product.minAvailQty.IsNotNull>.
            And<Product.active.IsEqual<True>.
                Or<Product.active.IsNull>>.
            And<Product.bookedQty.IsGreater<Product.availQty>.
                Or<Product.availQty.IsLess<Product.minAvailQty>>>>.
        Or<Product.availQty.IsNotNull>>.
    AggregateTo<GroupBy<Product.categoryCD>, 
                Min<Product.bookedQty>> If you need to order records, append to the statement the                              OrderBy<>  clause with the                              Asc<>  and  Desc<>  classes as                         the type parameters. In the sample code that has been presented in this                             topic, you would append the  OrderBy<>  clause to                             the statement as                         follows. SelectFrom<Product>.
    InnerJoin<SupplierProduct>.
        On<SupplierProduct.productID.IsEqual<Product.productID>>.
    InnerJoin<Supplier>.
        On<Supplier.accountID.IsEqual<SupplierProduct.accountID>>.
    Where<
        Brackets<Product.bookedQty.IsNotNull.
            And<Product.availQty.IsNotNull>.
            And<Product.minAvailQty.IsNotNull>.
            And<Product.active.IsEqual<True>.
                Or<Product.active.IsNull>>.
            And<Product.bookedQty.IsGreater<Product.availQty>.
                Or<Product.availQty.IsLess<Product.minAvailQty>>>>.
        Or<Product.availQty.IsNotNull>>.
    AggregateTo<GroupBy<Product.categoryCD>, 
                Min<Product.bookedQty>>.
    OrderBy<Product.unitPrice.Asc, 
            Product.availQty.Desc> ]]></column>
		</row>
		<row PageID="af596e3e-d343-47cf-9796-419630ca23ee" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="df59dc36-54d4-bd54-a3fb-e3151ec480a5" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you need to specify values in a fluent business query language (BQL) statement, you use fluent BQL parameters, which are replaced with the needed values in the translation to SQL. For details about how BQL statements with parameters are translated to SQL, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL#_ff6436a7-d8a9-43c8-9201-d5ea9afbe2d5|Translation of a BQL Command with Parameters to an SQL Query Tree]. {br}

You may need to use BQL parameters to relate data views to each other, to pass field values to the SQL query, to pass the external presentations of the values to the SQL query, or to pass values from UI controls to the SQL query. {br}{TOC}[anchor|#_27cf551c-951d-463a-9005-74584894a725]
==To Relate Data Views to Each Another==
To relate data views to each another, in a data query, use the field value of the <tt>Current</tt> object from the <tt>PXCache</tt> object, as shown in the following sample code.{{{{using PX.Data;
using PX.Data.BQL.Fluent;

// The view declarations in a graph
SelectFrom&lt;Document&gt;.View Documents;
SelectFrom&lt;DocTransaction&gt;.
    Where&lt;DocTransaction.docNbr.IsEqual&lt;Document.docNbr.FromCurrent&gt;.
        And&lt;DocTransaction.docType.IsEqual&lt;Document.docType.FromCurrent&gt;&gt;&gt;.View
    DocTransactions;
}}}}{br}

In this code, there is a many-to-one relationship between the <tt>DocTransaction</tt> and <tt>Document</tt> data access classes (DACs), and this relationship is implemented through the <tt>DocNbr</tt> and <tt>DocType</tt> key fields. The data views in the code connect the <tt>Document</tt> and <tt>DocTransaction</tt> records.((({S:Hint}Acumatica Framework translates the fluent BQL query of the second view in the sample code to the following SQL statement. In this SQL query, {{[parameter1]}} is the <tt>DocNbr</tt> value and {{[parameter2]}} is the <tt>DocType</tt> value retrieved from the <tt>Current</tt> property of the <tt>DocTransaction</tt> cache; {{[list of columns]}} is the list of columns of the {{DocTransaction}} table.{{{{SET @P0 = [parameter1] 
SET @P1 = [parameter2]

SELECT * FROM DocTransaction
WHERE DocTransaction.DocNbr = @P0
    AND DocTransaction.DocType = @P1
}}}}[anchor|#_bc78a53f-d648-47ce-8084-fa6ceb84190c]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))[anchor|#_6e19063a-c756-4b7d-88a0-7d0100a187d9]
==To Pass a Field Value to the SQL Query==
To pass a specific value to the SQL query, do the following;[anchor|#_108b51c7-0745-4d91-8bf1-596b9f387482]
#Use the <tt>@P.As&#91;Type&#93;</tt> class of the needed type in the BQL statement, where {{[Type]}} is one of the following: {{Bool}}, {{Byte}}, {{Short}}, {{Int}}, {{Long}}, {{Float}}, {{Double}}, {{Decimal}}, {{Guid}}, {{DateTime}}, or {{String}}. 
#Specify the needed value as the <tt>Select()</tt> method argument. The value passed to <tt>Select()</tt> must be of the same type as the type of the specified field.
{br}

((({S:Hint}The <tt>@P.As&#91;Type&#93;</tt> class must be used only in the BQL statements that are directly executed in the application code. The data views that are queried from the UI will not work if they contain this class.
))){br}

The code below shows the execution of a BQL statement with a specific value passed in code.<source lang="csharp">using PX.Data;
using PX.Data.BQL.Fluent;
using PX.Data.BQL;

// Suppose an event handler related to the Product DAC
// is being executed.
Product product = (Product)e.Row;

// Select the Category record with the specified CategoryCD.
Category category =
    SelectFrom&lt;Category&gt;.
        Where&lt;Category.categoryCD.IsEqual&lt;@P.AsString&gt;&gt;.View.         
        Select(this, product.CategoryCD);</source>((({S:Hint} Acumatica Framework translates the previous fluent BQL query to the following SQL statement. In this SQL query, {{[parameter]}} is the value of the {{product.CategoryCD}} variable at the moment the <tt>Select()</tt> method is invoked; {{[list of columns]}} is the list of columns of the {{Category}} table.{{{{SET @P0 = [parameter] 

SELECT * FROM Category
WHERE Category.CategoryCD = @P0
}}}}[anchor|#_ea75432a-ca72-462f-b6b5-807c661d6495]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))[anchor|#_cc3c4e58-b049-4351-b3c6-ebd9e62a350d]
==To Pass Multiple Field Values to the SQL Query==
To pass multiple values to the SQL query, do the following:[anchor|#_785c07fa-7a1f-45d7-9d53-989f84d1e0ec]
#Use multiple <tt>@P.As&#91;Type&#93;</tt> classes of the needed type in the fluent BQL statement, where {{[Type]}} is one of the following: {{Bool}}, {{Byte}}, {{Short}}, {{Int}}, {{Long}}, {{Float}}, {{Double}}, {{Decimal}}, {{Guid}}, {{DateTime}}, or {{String}}. 
#Specify the needed values as the <tt>Select()</tt> method arguments in the order in which the parameters are specified in the BQL statement. The number of <tt>@P.As&#91;Type&#93;</tt> classes must match the number of parameters passed to the <tt>Select()</tt> method. 
{br}

((({S:Hint}The <tt>@P.As&#91;Type&#93;</tt> classes should be used in only the BQL statements that are executed in the application code. 
))){br}

The following code shows an example of a fluent BQL statement with two <tt>Required</tt> parameters.<source lang="csharp">using PX.Data;
using PX.Data.BQL.Fluent;
using PX.Data.BQL;

// Suppose an event handler related to the DocTransaction DAC
// is being executed.
DocTransaction line = (DocTransaction)e.Row;

Document doc =
    SelectFrom&lt;Document&gt;.
        Where&lt;Document.docNbr.IsEqual&lt;@P.AsString&gt;.
             And&lt;Document.docType.IsEqual&lt;@P.AsString&gt;&gt;&gt;.View.
    Select(this, line.DocNbr, line.DocType);</source>((({S:Hint} Acumatica Framework translates the previous fluent BQL query to the following SQL statement, where {{[list of columns]}} is the list of the columns of the {{Document}} table. {{{{SET @P0 = [line.DocNbr value]
SET @P1 = [line.DocType value]

SELECT * FROM Document
WHERE Document.DocNbr = @P0
    AND Document.DocType = @P1
}}}}[anchor|#_b6a30c13-9df4-470a-8989-6447a88f21c1]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))[anchor|#_1f3bef64-92a7-469f-9fd2-89f0910565fe]
==To Pass a Value from a UI Control to a Data View==
To pass a value from a UI control to a data view, do the following:[anchor|#_bd92083d-f390-47ff-89aa-27215c2c0dfd]
#Define a data view with the <tt>Argument.As&#91;Type&#93;</tt> class, where {{[Type]}} specifies the data type of the expected value, as shown in the following sample BQL query.<source lang="csharp">using PX.Data;
using PX.Data.BQL.Fluent;

SelectFrom&lt;TreeViewItem&gt;.
    Where&lt;TreeViewItem.parentID.IsEqual&lt;Argument.AsInt&gt;&gt;.
    OrderBy&lt;Asc&lt;TreeViewItem.parentID&gt;&gt;.View GridDataSource;</source>
#:((({S:Hint}Acumatica Framework translates the previous fluent BQL query to the following SQL statement. In this SQL query, {{[parameter]}} will contain the value received from the UI control and passed to the <tt>Select()</tt> method; {{[list of columns]}} is the list of columns of the {{TreeViewItem}} table.{{{{SET @P0 = [parameter]

SELECT [list of columns] FROM TreeViewItem
WHERE TreeViewItem.ParentID = @P0
ORDER BY TreeViewItem.ParentID
}}}}[anchor|#_ad04e1c7-0053-480b-b7dc-876468adebcb] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
#Define the data view delegate with parameters through which you can access the values passed from the UI. (You can find more information on how to use data view delegates in [HelpRoot_Dev_Platform\AD__how_Execute_BQL_Statement#_36988f03-38e3-4f9a-89f6-1623935e81fa|To Execute a BQL Statement in a Data View Delegate].)
#:((({S:Hint}When a BQL statement with the <tt>Argument</tt> parameter is executed in code, the value must be specified in the parameters of the <tt>Select()</tt> method.
)))
[anchor|#_4473b629-e9a7-4f41-9041-c0442303d2be]
==To Provide External Presentation of the Field Value to the SQL Query==
To substitute a value in the SQL query, do the following:[anchor|#_b37d7823-a6d2-4838-8d82-0ef40e364a36]
#Add the <tt>PXSelector</tt> attribute with a substitute key to a DAC field, as shown in the following example.<source lang="csharp">using PX.Data;
using PX.Data.BQL.Fluent;

[PXSelector(typeof(SearchFor&lt;Product.productID&gt;.In&lt;SelectFrom&lt;Product&gt;&gt;,
            new Type [] {
                    typeof(Product.productCD),
                    typeof(Product.productName)
            },
            SubstituteKey = typeof(Product.productCD))]
public virtual int? ProductID { get; set; }</source>
#:In this example, <tt>PXSelector</tt> replaces the <tt>ProductID</tt> field in the user interface with the human-readable <tt>ProductCD</tt> field. In the UI control for this field, the user enters a <tt>ProductCD</tt> value. The <tt>PXSelector</tt> attribute implements the <tt>FieldUpdating</tt> event handler, which replaces the <tt>ProductCD</tt> value with the corresponding <tt>ProductID</tt> value. 
#Use the <tt>AsOptional</tt> class to select records by the external presentation of the field value, as shown in the following code for <tt>OrderLine</tt> records.<source lang="csharp">using PX.Data;
using PX.Data.BQL.Fluent;

// p is a Product data record.
// To select OrderLine records, pass the ProductCD value
// to the Select() method.
PXResultset&lt;OrderLine&gt; details = 
    SelectFrom&lt;OrderLine&gt;.
        Where&lt;OrderLine.productID.IsEqual&lt;OrderLine.productID.AsOptional&gt;&gt;.
        View.
    Select(this, p.ProductCD);</source>
#In the <tt>Select()</tt> method, provide values for all <tt>AsOptional</tt>, <tt>@P.As&#91;Type&#93;</tt>, and <tt>Argument.As&#91;Type&#93;</tt> parameters up to the last <tt>@P.As&#91;Type&#93;</tt> or <tt>Argument.As&#91;Type&#93;</tt> parameter in the fluent BQL statement, as shown in the following sample code. <source lang="csharp">using PX.Data;
using PX.Data.BQL.Fluent;

// P is a Product data record. 
// od is an OrderLine data record.

// At least three values (in addition to the graph reference) must
// be passed to the Select() method below.
// The second AsOptional parameter here will be replaced with the
// default UnitPrice value.
PXResultset&lt;OrderLine&gt; details =
    SelectFrom&lt;OrderLine&gt;.
        Where&lt;OrderLine.productID.IsEqual&lt;OrderLine.productID.AsOptional&gt;.
            And&lt;OrderLine.extPrice.IsLess&lt;@P.AsDecimal&gt;&gt;.
            And&lt;OrderLine.unitPrice.IsGreater&lt;@P.AsDecimal&gt;&gt;.
            And&lt;OrderLine.taxRate.IsEqual&lt;OrderLine.taxRate.AsOptional&gt;&gt;&gt;.View.
        .Select(this, p.ProductCD, od.ExtPrice, od.UnitPrice);</source>
#:((({S:Hint}Acumatica Framework translates the fluent BQL query in the code to the following SQL statement, where {{[list of columns]}} is the list of columns of the {{OrderLine}} table. {{{{SET @P0 = [line.ProductID value or default]
SET @P1 = [line.ExtPrice value]
SET @P2 = [line.UnitPrice value]
SET @P3 = [Default TaxRate value]

SELECT [list of columns] FROM OrderLine
WHERE OrderLine.ProductID = @P0
    AND OrderLine.ExtPrice &lt; @P1
    AND OrderLine.UnitPrice &gt; @P2
    AND OrderLine.TaxRate = @P3
}}}}[anchor|#_81b4a835-ff1d-4968-a857-8f44b9777ec6] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
]]></column>
			<column name="PlainText"><![CDATA[To Use Parameters in Fluent BQL Queries If you need to specify values in a fluent business query language (BQL) statement,                 you use fluent BQL parameters, which are replaced with the needed values in the                 translation to SQL. For details about how BQL statements with parameters are                 translated to SQL, see  Translation of a BQL Command with Parameters to an SQL Query Tree.  You may need to use BQL parameters to relate data views to each other, to pass field                 values to the SQL query, to pass the external presentations of the values to the SQL                 query, or to pass values from UI controls to the SQL query.  To Relate Data Views to Each Another To relate data views to each another, in a data query, use the field value of the                      Current  object from the  PXCache  object, as                 shown in the following sample                 code. using PX.Data;
using PX.Data.BQL.Fluent;

// The view declarations in a graph
SelectFrom<Document>.View Documents;
SelectFrom<DocTransaction>.
    Where<DocTransaction.docNbr.IsEqual<Document.docNbr.FromCurrent>.
        And<DocTransaction.docType.IsEqual<Document.docType.FromCurrent>>>.View
    DocTransactions; In this code, there is a many-to-one relationship between the                      DocTransaction  and  Document  data access                 classes (DACs), and this relationship is implemented through the                      DocNbr  and  DocType  key fields. The data                 views in the code connect the  Document  and                      DocTransaction  records. Acumatica Framework translates the fluent BQL query of the second view in the sample code to the                     following SQL statement. In this SQL query,  [parameter1]  is the                          DocNbr  value and  [parameter2]  is the                          DocType  value retrieved from the                          Current  property of the  DocTransaction                      cache;  [list of columns]  is the list of columns of the                          DocTransaction                          table. SET @P0 = [parameter1] 
SET @P1 = [parameter2]

SELECT * FROM DocTransaction
WHERE DocTransaction.DocNbr = @P0
    AND DocTransaction.DocType = @P1  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Pass a Field Value to the SQL Query To pass a specific value to the SQL query, do the following; Use the  @P.As[Type]  class of the needed type in the BQL                         statement, where  [Type]  is one of the following:                              Bool ,  Byte ,  Short ,                              Int ,  Long ,  Float ,                              Double ,  Decimal ,                          Guid ,  DateTime , or                          String .  Specify the needed value as the  Select()  method argument.                         The value passed to  Select()  must be of the same type as                         the type of the specified field. The  @P.As[Type]  class must be used only in the BQL                     statements that are directly executed in the application code. The data views                     that are queried from the UI will not work if they contain this class. The code below shows the execution of a BQL statement with a specific value passed in                 code. using PX.Data;
using PX.Data.BQL.Fluent;
using PX.Data.BQL;

// Suppose an event handler related to the Product DAC
// is being executed.
Product product = (Product)e.Row;

// Select the Category record with the specified CategoryCD.
Category category =
    SelectFrom<Category>.
        Where<Category.categoryCD.IsEqual<@P.AsString>>.View.         
        Select(this, product.CategoryCD);  Acumatica Framework translates the previous fluent BQL query to the following SQL statement. In this                 SQL query,  [parameter]  is the value of the                      product.CategoryCD  variable at the moment the                      Select()  method is invoked;  [list of                     columns]  is the list of columns of the  Category                      table. SET @P0 = [parameter] 

SELECT * FROM Category
WHERE Category.CategoryCD = @P0  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Pass Multiple Field Values to the SQL Query To pass multiple values to the SQL query, do the following: Use multiple  @P.As[Type]  classes of the needed type in                         the fluent BQL statement, where  [Type]  is one of the                         following:  Bool ,  Byte ,                              Short ,  Int ,  Long ,                              Float ,  Double ,                              Decimal ,  Guid ,                              DateTime , or  String .  Specify the needed values as the  Select()  method                         arguments in the order in which the parameters are specified in the BQL                         statement. The number of  @P.As[Type]  classes must match                         the number of parameters passed to the  Select()  method.                      The  @P.As[Type]  classes should be used in only the BQL                     statements that are executed in the application code.  The following code shows an example of a fluent BQL statement with two                      Required  parameters. using PX.Data;
using PX.Data.BQL.Fluent;
using PX.Data.BQL;

// Suppose an event handler related to the DocTransaction DAC
// is being executed.
DocTransaction line = (DocTransaction)e.Row;

Document doc =
    SelectFrom<Document>.
        Where<Document.docNbr.IsEqual<@P.AsString>.
             And<Document.docType.IsEqual<@P.AsString>>>.View.
    Select(this, line.DocNbr, line.DocType);  Acumatica Framework translates the previous fluent BQL query to the following SQL statement, where                      [list of columns]  is the list of the columns of the                      Document  table.                      SET @P0 = [line.DocNbr value]
SET @P1 = [line.DocType value]

SELECT * FROM Document
WHERE Document.DocNbr = @P0
    AND Document.DocType = @P1  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Pass a Value from a UI Control to a Data View To pass a value from a UI control to a data view, do the following: Define a data view with the  Argument.As[Type]  class,                         where  [Type]  specifies the data type of the expected value,                         as shown in the following sample BQL                                 query. using PX.Data;
using PX.Data.BQL.Fluent;

SelectFrom<TreeViewItem>.
    Where<TreeViewItem.parentID.IsEqual<Argument.AsInt>>.
    OrderBy<Asc<TreeViewItem.parentID>>.View GridDataSource; Acumatica Framework translates the previous fluent BQL query to the following SQL                             statement. In this SQL query,  [parameter]  will contain                             the value received from the UI control and passed to the                                  Select()  method;  [list of                                 columns]  is the list of columns of the                                  TreeViewItem                                  table. SET @P0 = [parameter]

SELECT [list of columns] FROM TreeViewItem
WHERE TreeViewItem.ParentID = @P0
ORDER BY TreeViewItem.ParentID  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. Define the data view delegate with parameters through which you can access                         the values passed from the UI. (You can find more information on how to use                         data view delegates in  To Execute a BQL Statement in a Data View Delegate.) When a BQL statement with the  Argument                              parameter is executed in code, the value must be specified in the                             parameters of the  Select()  method. To Provide External Presentation of the Field Value to the SQL Query To substitute a value in the SQL query, do the following: Add the  PXSelector  attribute with a substitute key to a                         DAC field, as shown in the following                             example. using PX.Data;
using PX.Data.BQL.Fluent;

[PXSelector(typeof(SearchFor<Product.productID>.In<SelectFrom<Product>>,
            new Type [] {
                    typeof(Product.productCD),
                    typeof(Product.productName)
            },
            SubstituteKey = typeof(Product.productCD))]
public virtual int? ProductID { get; set; } In                             this example,  PXSelector  replaces the                                  ProductID  field in the user interface with the                             human-readable  ProductCD  field. In the UI control for                             this field, the user enters a  ProductCD  value. The                                  PXSelector  attribute implements the                                  FieldUpdating  event handler, which replaces the                                  ProductCD  value with the corresponding                                  ProductID  value.  Use the  AsOptional  class to select records by the                         external presentation of the field value, as shown in the following code for                              OrderLine                          records. using PX.Data;
using PX.Data.BQL.Fluent;

// p is a Product data record.
// To select OrderLine records, pass the ProductCD value
// to the Select() method.
PXResultset<OrderLine> details = 
    SelectFrom<OrderLine>.
        Where<OrderLine.productID.IsEqual<OrderLine.productID.AsOptional>>.
        View.
    Select(this, p.ProductCD); In the  Select()  method, provide values for all                              AsOptional ,  @P.As[Type] , and                              Argument.As[Type]  parameters up to the last                              @P.As[Type]  or  Argument.As[Type]                          parameter in the fluent BQL statement, as shown in the following sample                         code.                                  using PX.Data;
using PX.Data.BQL.Fluent;

// P is a Product data record. 
// od is an OrderLine data record.

// At least three values (in addition to the graph reference) must
// be passed to the Select() method below.
// The second AsOptional parameter here will be replaced with the
// default UnitPrice value.
PXResultset<OrderLine> details =
    SelectFrom<OrderLine>.
        Where<OrderLine.productID.IsEqual<OrderLine.productID.AsOptional>.
            And<OrderLine.extPrice.IsLess<@P.AsDecimal>>.
            And<OrderLine.unitPrice.IsGreater<@P.AsDecimal>>.
            And<OrderLine.taxRate.IsEqual<OrderLine.taxRate.AsOptional>>>.View.
        .Select(this, p.ProductCD, od.ExtPrice, od.UnitPrice); Acumatica Framework translates the fluent BQL query in the code to the following SQL                             statement, where  [list of columns]  is the list of                             columns of the  OrderLine  table.                                  SET @P0 = [line.ProductID value or default]
SET @P1 = [line.ExtPrice value]
SET @P2 = [line.UnitPrice value]
SET @P3 = [Default TaxRate value]

SELECT [list of columns] FROM OrderLine
WHERE OrderLine.ProductID = @P0
    AND OrderLine.ExtPrice < @P1
    AND OrderLine.UnitPrice > @P2
    AND OrderLine.TaxRate = @P3  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. ]]></column>
		</row>
		<row PageID="c3ae0da2-63d1-4a43-b1f6-b8b3a96da221" Language="en-US" PageRevisionID="1" PlainText="Creating Traditional BQL Queries To query data from the database, you use the business query language (BQL), which has two     dialects: fluent BQL and traditional BQL. In this chapter, you can find information on how to create traditional BQL queries. For the     general information about BQL, see  Querying Data in Acumatica Framework. For details about     building queries with traditional BQL, see  Creating Traditional BQL Queries. In This Chapter Traditional Business Query LanguageData Access Classes in Traditional BQLPXSelect ClassesThe Classes That Compose BQL StatementsParameters in Traditional BQL StatementsData Query ExecutionTo Select Records By Using Traditional BQLTo Filter RecordsTo Order RecordsTo Query Multiple TablesTo Group and Aggregate RecordsTo Use Parameters in Traditional BQLTo Use Arithmetic OperationsTo Compose a BQL Statement from an SQL Statement" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="5cae56f9-d5e1-e7a8-5674-529983ad3c4c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To query data from the database, you use the business query language (BQL), which has two dialects: fluent BQL and traditional BQL.{br}

In this chapter, you can find information on how to create traditional BQL queries. For the general information about BQL, see [HelpRoot_Dev_Platform\AD__mng_Querying_Data|Querying Data in Acumatica Framework]. For details about building queries with traditional BQL, see [HelpRoot_Dev_Platform\AD__mng_Traditional_BQL|Creating Traditional BQL Queries].
==In This Chapter==[anchor|#_980c134d-979b-46c3-89ce-d9d01a936586]
{| class="checklist invisiblechecklist" | width="100%" 
|- 
| 
*[HelpRoot_Dev_Platform\AD__con_Traditional_BQL|Traditional Business Query Language]
*[HelpRoot_Dev_Platform\AD__con_DACs_in_TraditionalBQL|Data Access Classes in Traditional BQL]
*[HelpRoot_Dev_Platform\AD__con_BQL_PXSelect|PXSelect Classes]
*[HelpRoot_Dev_Platform\AD__con_BQL_Commands|The Classes That Compose BQL Statements]
*[HelpRoot_Dev_Platform\AD__con_Parameters|Parameters in Traditional BQL Statements]
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]

| 
*[HelpRoot_Dev_Platform\AD__how_Construct_Statement|To Select Records By Using Traditional BQL]
*[HelpRoot_Dev_Platform\AD__how_BQL_Filter|To Filter Records]
*[HelpRoot_Dev_Platform\AD__how_BQL_OrderBy|To Order Records]
*[HelpRoot_Dev_Platform\AD__how_Query_Multiple_Tables|To Query Multiple Tables]
*[HelpRoot_Dev_Platform\AD__how_BQL_Group_and_Aggregate|To Group and Aggregate Records]
*[HelpRoot_Dev_Platform\AD__how_BQL_Parameters|To Use Parameters in Traditional BQL]
*[HelpRoot_Dev_Platform\AD__how_BQL_Functions|To Use Arithmetic Operations]
*[HelpRoot_Dev_Platform\AD__how_Translate_SQL_to_BQL|To Compose a BQL Statement from an SQL Statement]

|}]]></column>
		</row>
		<row PageID="9daff8e3-c057-4633-8bf3-fcbacf652123" Language="en-US" PageRevisionID="1" PlainText="Traditional Business Query Language When you compose a query with the traditional business query language (BQL), you work with         the following classes: The classes that correspond to database tables (data access classes) and columns. For             details on data access classes, see  Data Access Classes in Traditional BQL. The classes that define data views in a graph and select data from the database in             code ( PXSelect  classes). For more information on these classes, see                PXSelect Classes. The classes that compose BQL statements, such as  Select ,                Search ,  Where ,  OrderBy ,                And , and  Add . For more information on these             classes, see  The Classes That Compose BQL Statements. The classes that pass parameters to BQL statements, such as              Current ,  Required ,  Optional ,                Argument . For details on BQL parameters, see  Parameters in Traditional BQL Statements. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f0aaa669-98b4-f4de-ca6a-25796b9cc93b" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When you compose a query with the traditional business query language (BQL), you work with the following classes:[anchor|#_d7aa1f14-c513-4457-9f60-87d62189bf96]
*The classes that correspond to database tables (data access classes) and columns. For details on data access classes, see [HelpRoot_Dev_Platform\AD__con_DACs_in_TraditionalBQL|Data Access Classes in Traditional BQL].
*The classes that define data views in a graph and select data from the database in code (<tt>PXSelect</tt> classes). For more information on these classes, see [HelpRoot_Dev_Platform\AD__con_BQL_PXSelect|PXSelect Classes].
*The classes that compose BQL statements, such as <tt>Select</tt>, <tt>Search</tt>, <tt>Where</tt>, <tt>OrderBy</tt>, <tt>And</tt>, and <tt>Add</tt>. For more information on these classes, see [HelpRoot_Dev_Platform\AD__con_BQL_Commands|The Classes That Compose BQL Statements].
*The classes that pass parameters to BQL statements, such as <tt>Current</tt>, <tt>Required</tt>, <tt>Optional</tt>, <tt>Argument</tt>. For details on BQL parameters, see [HelpRoot_Dev_Platform\AD__con_Parameters|Parameters in Traditional BQL Statements].
]]></column>
		</row>
		<row PageID="a47ddb36-eb85-486f-9d6b-49beac42fc80" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="a4839497-4528-954c-f943-53a9a7a0c989" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The data access classes (DACs) that are used in traditional BQL differ from the DACs that are used in fluent BQL in the declarations of the class fields. For details about the DAC declaration, see [HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes].{br}

You derive each class field of a DAC (a {{public abstract}} class of a DAC) from the <tt>IBqlField</tt> interface and assign it a name that starts with a lowercase letter. {br}

The following code shows an example of the <tt>Product</tt> data access class declared in traditional BQL style.<source lang="csharp">using System;
using PX.Data;

[Serializable]
public class Product : PX.Data.IBqlTable
{
    // The class used in BQL statements to refer to the ProductID column
    public abstract class productID : PX.Data.IBqlField
    {
    }
    // The property holding the ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }

    // The class used in BQL statements to refer to the AvailQty column
    public abstract class availQty : PX.Data.IBqlField
    {
    }
    // The property holding the AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
}</source>
==Simultaneous Use of DACs in Traditional BQL and Fluent BQL==
The class fields declared in traditional BQL style cannot be used in fluent BQL queries.{br}

The class fields that are defined in the fluent BQL style (as described in [HelpRoot_Dev_Platform\AD__con_DACs_in_FBQL|Data Access Classes in Fluent BQL]) can be used in traditional BQL queries without any modifications. Therefore, we recommend that you use the fluent BQL style of DAC declaration. 
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes]]]></column>
			<column name="PlainText"><![CDATA[Data Access Classes in Traditional BQL The data access classes (DACs) that are used in traditional BQL differ from the DACs that         are used in fluent BQL in the declarations of the class fields. For details about the DAC         declaration, see  Data Access Classes. You derive each class field of a DAC (a  public abstract  class of a DAC)         from the  IBqlField  interface and assign it a name that starts with a         lowercase letter.  The following code shows an example of the  Product  data access class         declared in traditional BQL         style. using System;
using PX.Data;

[Serializable]
public class Product : PX.Data.IBqlTable
{
    // The class used in BQL statements to refer to the ProductID column
    public abstract class productID : PX.Data.IBqlField
    {
    }
    // The property holding the ProductID value in a record
    [PXDBIdentity(IsKey = true)]
    public virtual int? ProductID { get; set; }

    // The class used in BQL statements to refer to the AvailQty column
    public abstract class availQty : PX.Data.IBqlField
    {
    }
    // The property holding the AvailQty value in a record
    [PXDBDecimal(2)]
    public virtual decimal? AvailQty { get; set; }
} Simultaneous Use of DACs in Traditional BQL and Fluent BQL The class fields declared in traditional BQL style cannot be used in fluent BQL         queries. The class fields that are defined in the fluent BQL style (as described in  Data Access Classes in Fluent BQL) can be used in traditional BQL queries without any         modifications. Therefore, we recommend that you use the fluent BQL style of DAC declaration.        ]]></column>
		</row>
		<row PageID="7d3035af-dac2-47fe-bbe6-b733565697cf" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="a9702f1c-7016-f4f5-08eb-aad5f10cb913" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In traditional business query language (BQL), you define a data view or request database data in code by using one of the <tt>PXSelect</tt> classes (that is, the classes derived from <tt>PXSelectBase</tt>). {br}{TOC}
==PXSelect Classes==The instances of <tt>PXSelect</tt> classes are complex objects containing the following:[anchor|#ul_ndl_p1z_hk]
*A reference to the <tt>PXView</tt> object instantiated to process the data query
*A reference (through the <tt>PXView</tt> object) to the <tt>Select</tt> object, which is the business query language (BQL) command to be executed 
*A reference to the graph
*A reference to the cache of the data access class (DAC) type that is specified in the first type parameter of <tt>PXSelect</tt>

That is, through the <tt>PXSelect</tt> classes, you can execute the BQL command and interact with the cache, as illustrated in the following diagram.[anchor|#_590e2ed4-891f-433c-a732-9f68c2377555][image:StudioDeveloperGuide/Images/PXSelect,Select,Search.png|popup|450px]((({S:Hint}Do not confuse the <tt>PXSelect</tt> classes with the <tt>Select</tt> classes. <tt>PXSelect</tt> is an aggregate of the data view, cache, and graph. You can use <tt>PXSelect</tt> classes to read, write, update, and delete records in the scope of a graph. <tt>Select</tt> classes simply represent BQL commands. You cannot read records by using a BQL command without instantiating a data view. For more information on the <tt>Select</tt> classes, see [HelpRoot_Dev_Platform\AD__con_BQL_Commands|The Classes That Compose BQL Statements].
)))
==Types of PXSelect Classes==
The first type parameter of all <tt>PXSelect</tt> classes is a data access class (DAC) generally bound to a database table. The resulting SQL query selects records from this table. Other type parameters (such as <tt>Where</tt>, <tt>OrderBy</tt>, <tt>Join</tt>, and <tt>Aggregate</tt>) are optional and represent clauses that can be added to the basic select statement.{br}

Depending on the clauses that will be used in a query, you select the appropriate variant of the <tt>PXSelect</tt> class.{br}

For example, if you need to use the <tt>Where</tt>, <tt>OrderBy</tt>, and <tt>Join</tt> clauses, you can use the <tt>PXSelectJoin&lt;Table, Join, Where, OrderBy&gt;</tt> class to create the query, as shown in the following BQL sample code.<source lang="csharp">PXSelectJoin&lt;Table1,
    LeftJoin&lt;Table2, On&lt;Table2.field2, Equal&lt;Table1.field1&gt;&gt;&gt;,
    Where&lt;Table1.field3, IsNotNull&gt;,
    OrderBy&lt;Asc&lt;Table1.field1&gt;&gt;&gt;</source>((({S:Hint} Acumatica Framework translates this statement to the following SQL query, where {{[list of columns]}} is the list of columns of the joined tables. {{{{SELECT [list of columns] FROM Table1
    LEFT JOIN Table2 ON Table2.Field2 = Table1.Field1
    WHERE Table1.Field3 IS NOT NULL
    ORDER BY Table1.Field1 
}}}}[anchor|#_013157ba-a778-4d36-a5b4-96a5d5663854]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
For more information on how to use the BQL clauses, see [HelpRoot_Dev_Platform\AD__how_Construct_Statement|To Select Records By Using Traditional BQL].{br}

If you need to retrieve data as it is currently stored in the database, you use one of the <tt>PXSelect</tt> classes that has <tt>Readonly</tt> in its name, such as the <tt>PXSelectReadonly&lt;Table&gt;</tt> class, or any of the <tt>PXSelect</tt> classes that use aggregation, such as the <tt>PXSelectGroupBy&lt;Table, Aggregate&gt;</tt> class. Otherwise, the data retrieved from the database can be merged with the data currently stored in the cache. For more information on how the data is merged with the cache, see [HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache].
==The List of PXSelect Classes==
 Acumatica Framework provides the following <tt>PXSelect</tt> classes:[anchor|#_ab5af201-45e1-420e-be2a-38ecd58a9de2]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=82e24896-5ff7-a1fe-a0f8-9bff0ddf27ea|<tt>PXSelect&lt;Table, Where, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5ec6f10c-23ef-14aa-6f01-31a2679baebc| <tt>PXSelect&lt;Table, Where&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=df23e254-51d3-6c56-2532-55f3602c486b| <tt>PXSelect&lt;Table&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=91a0013f-35d6-edeb-0807-74d1754fc756| <tt>PXSelectGroupBy&lt;Table, Aggregate&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=aa1de26d-e076-e380-ef3b-3e4af9e4962a| <tt>PXSelectGroupBy&lt;Table, Where, Aggregate, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ab32e32c-e84e-f3cb-149d-f4790e5cc800| <tt>PXSelectGroupBy&lt;Table, Where, Aggregate&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ad8688e6-5353-143c-7d1f-2d7606c8e393| <tt>PXSelectGroupByOrderBy&lt;Table, Aggregate, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=4fc392e5-99e7-73cc-b526-49ccce3e05c2| <tt>PXSelectGroupByOrderBy&lt;Table, Join, Aggregate, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=49aea5fc-82e2-ca3b-d766-128f52b544b8| <tt>PXSelectJoin&lt;Table, Join, Where, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b3d13bad-ec9d-121e-d0bb-0ddb9c3ed7d1| <tt>PXSelectJoin&lt;Table, Join, Where&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=bc94968c-2642-d512-d7f7-a0d286b59126| <tt>PXSelectJoin&lt;Table, Join&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c4b6e1f7-866e-58b5-a196-5389e0a7bfe6| <tt>PXSelectJoinGroupBy&lt;Table, Join, Aggregate&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e7e783a3-cff9-85da-8681-ecee191db62d| <tt>PXSelectJoinGroupBy&lt;Table, Join, Where, Aggregate, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fcb1550e-f1df-7cb1-fb71-865b4646498d| <tt>PXSelectJoinGroupBy&lt;Table, Join, Where, Aggregate&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b0667493-2ad5-c38a-e80e-e17818841dc5| <tt>PXSelectJoinOrderBy&lt;Table, Join, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fdf23b92-19c4-f2b3-27ec-dd80a240820a| <tt>PXSelectOrderBy&lt;Table, Join, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8e8c6674-d029-5f35-069a-b70a9c3e7938| <tt>PXSelectOrderBy&lt;Table, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d6496092-e1a7-66b7-a1fa-8ab4dee0a035| <tt>PXSelectReadonly&lt;Table, Where, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a0e97d1d-b640-12ee-b6df-54e90d5c73ca| <tt>PXSelectReadonly&lt;Table, Where&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a17a006c-90fe-e3b2-df96-0cbddc84cd5d| <tt>PXSelectReadonly&lt;Table&gt; </tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=549c3942-b680-1c50-3e63-f8cb423956c1| <tt>PXSelectReadonly2&lt;Table, Join, Where, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a0f3fe13-d460-4f0d-b302-4c6fb38a27ae| <tt>PXSelectReadonly2&lt;Table, Join, Where&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5349f5f1-6f58-9ac0-1bdd-cab07e51168b| <tt>PXSelectReadonly2&lt;Table, Join&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=235c9fa2-ca6a-27d2-f6ce-d145b2608e23| <tt>PXSelectReadonly3&lt;Table, Join, OrderBy&gt;</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1cb18bdd-100a-d8d0-a81d-ce74c95757e0| <tt>PXSelectReadonly3&lt;Table, OrderBy&gt;</tt>]
]]></column>
			<column name="PlainText"><![CDATA[PXSelect Classes In traditional business query language (BQL), you define a data view or request database         data in code by using one of the  PXSelect  classes (that is, the classes         derived from  PXSelectBase ).  PXSelect Classes The instances of          PXSelect  classes are complex objects containing the following: A reference to the  PXView  object instantiated to process the data           query A reference (through the  PXView  object) to the              Select  object, which is the business query language (BQL) command to           be executed  A reference to the graph A reference to the cache of the data access class (DAC) type that is specified in the           first type parameter of  PXSelect That is, through the  PXSelect  classes, you can execute the BQL         command and interact with the cache, as illustrated in the following diagram. Do not confuse the            PXSelect  classes with the  Select  classes.            PXSelect  is an aggregate of the data view, cache, and graph. You can         use  PXSelect  classes to read, write, update, and delete records in the         scope of a graph.  Select  classes simply represent BQL commands. You         cannot read records by using a BQL command without instantiating a data view. For more         information on the  Select  classes, see  The Classes That Compose BQL Statements. Types of PXSelect Classes The first type parameter of all  PXSelect  classes is a data access class         (DAC) generally bound to a database table. The resulting SQL query selects records from this         table. Other type parameters (such as  Where ,  OrderBy ,            Join , and  Aggregate ) are optional and represent         clauses that can be added to the basic select statement. Depending on the clauses that will be used in a query, you select the appropriate variant         of the  PXSelect  class. For example, if you need to use the  Where ,  OrderBy ,         and  Join  clauses, you can use the  PXSelectJoin<Table, Join,           Where, OrderBy>  class to create the query, as shown in the following BQL         sample code. PXSelectJoin<Table1,
    LeftJoin<Table2, On<Table2.field2, Equal<Table1.field1>>>,
    Where<Table1.field3, IsNotNull>,
    OrderBy<Asc<Table1.field1>>>  Acumatica Framework         translates this statement to the following SQL query, where  [list of           columns]  is the list of columns of the joined tables.            SELECT [list of columns] FROM Table1
    LEFT JOIN Table2 ON Table2.Field2 = Table1.Field1
    WHERE Table1.Field3 IS NOT NULL
    ORDER BY Table1.Field1   Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. For more information on how to use the BQL clauses, see  To Select Records By Using Traditional BQL. If you need to retrieve data as it is currently stored in the database, you use one of the            PXSelect  classes that has  Readonly  in its name, such         as the  PXSelectReadonly<Table>  class, or any of the            PXSelect  classes that use aggregation, such as the            PXSelectGroupBy<Table, Aggregate>  class. Otherwise, the data         retrieved from the database can be merged with the data currently stored in the cache. For         more information on how the data is merged with the cache, see  Merge of the Records with PXCache. The List of PXSelect Classes  Acumatica Framework provides the following  PXSelect  classes: PXSelect<Table,                 Where, OrderBy> <tt>PXSelect&lt;Table, Where, OrderBy&gt;</tt>PXSelect<Table,                 Where>  <tt>PXSelect&lt;Table, Where&gt;</tt>PXSelect<Table>  <tt>PXSelect&lt;Table&gt;</tt>PXSelectGroupBy<Table, Aggregate>  <tt>PXSelectGroupBy&lt;Table, Aggregate&gt;</tt>PXSelectGroupBy<Table, Where, Aggregate,             OrderBy>  <tt>PXSelectGroupBy&lt;Table, Where, Aggregate, OrderBy&gt;</tt>PXSelectGroupBy<Table, Where, Aggregate>  <tt>PXSelectGroupBy&lt;Table, Where, Aggregate&gt;</tt>PXSelectGroupByOrderBy<Table, Aggregate,             OrderBy>  <tt>PXSelectGroupByOrderBy&lt;Table, Aggregate, OrderBy&gt;</tt>PXSelectGroupByOrderBy<Table, Join, Aggregate,               OrderBy>  <tt>PXSelectGroupByOrderBy&lt;Table, Join, Aggregate, OrderBy&gt;</tt>PXSelectJoin<Table, Join, Where, OrderBy>  <tt>PXSelectJoin&lt;Table, Join, Where, OrderBy&gt;</tt>PXSelectJoin<Table, Join, Where>  <tt>PXSelectJoin&lt;Table, Join, Where&gt;</tt>PXSelectJoin<Table, Join>  <tt>PXSelectJoin&lt;Table, Join&gt;</tt>PXSelectJoinGroupBy<Table, Join, Aggregate>  <tt>PXSelectJoinGroupBy&lt;Table, Join, Aggregate&gt;</tt>PXSelectJoinGroupBy<Table, Join, Where, Aggregate,                 OrderBy>  <tt>PXSelectJoinGroupBy&lt;Table, Join, Where, Aggregate, OrderBy&gt;</tt>PXSelectJoinGroupBy<Table, Join, Where,             Aggregate>  <tt>PXSelectJoinGroupBy&lt;Table, Join, Where, Aggregate&gt;</tt>PXSelectJoinOrderBy<Table, Join, OrderBy>  <tt>PXSelectJoinOrderBy&lt;Table, Join, OrderBy&gt;</tt>PXSelectOrderBy<Table, Join, OrderBy>  <tt>PXSelectOrderBy&lt;Table, Join, OrderBy&gt;</tt>PXSelectOrderBy<Table, OrderBy>  <tt>PXSelectOrderBy&lt;Table, OrderBy&gt;</tt>PXSelectReadonly<Table, Where, OrderBy>  <tt>PXSelectReadonly&lt;Table, Where, OrderBy&gt;</tt>PXSelectReadonly<Table, Where>  <tt>PXSelectReadonly&lt;Table, Where&gt;</tt>PXSelectReadonly<Table>   <tt>PXSelectReadonly&lt;Table&gt; </tt>PXSelectReadonly2<Table, Join, Where, OrderBy>  <tt>PXSelectReadonly2&lt;Table, Join, Where, OrderBy&gt;</tt>PXSelectReadonly2<Table, Join, Where>  <tt>PXSelectReadonly2&lt;Table, Join, Where&gt;</tt>PXSelectReadonly2<Table, Join>  <tt>PXSelectReadonly2&lt;Table, Join&gt;</tt>PXSelectReadonly3<Table, Join, OrderBy>  <tt>PXSelectReadonly3&lt;Table, Join, OrderBy&gt;</tt>PXSelectReadonly3<Table, OrderBy>  <tt>PXSelectReadonly3&lt;Table, OrderBy&gt;</tt>]]></column>
		</row>
		<row PageID="5dcf2b9e-ab3a-4ba6-a25d-3f2c28c3cf8a" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e89d74c7-4c0e-53aa-6a75-3e38a2d40a66" RecordSourceID="22377">
			<column name="Content"><![CDATA[
This topic contains an overview of the classes that you use to compose business query language (BQL) statements inside <tt>PXSelect</tt> and to define attributes of DACs.{br}{TOC}
==Overview of the Classes==
Almost all classes that compose BQL statements are derived from the <tt>IBqlCreator</tt> interface, which inherits from the <tt>IBqlVerifier</tt> interface. These interfaces provide the following key methods: [anchor|#_3f6fb5af-1791-4ced-93b3-551c0377d084]
*<tt>IBqlCreator.AppendExpression()</tt>: Used during a BQL command preparation to translate a BQL statement into an SQL tree expression, which is then produces the SQL text to be sent to the database maintenance server. For more information on how this method is used during BQL statement execution, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
*<tt>IBqlVerifier.Verify()</tt>: Used during the merge of the records with <tt>PXCache</tt> to evaluate a condition on a record retrieved from the database or calculate an expression with the record. For details on the merge, see [HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache].
{br}

Depending on the purpose of each BQL class, the class also implements the methods of the interfaces derived from the <tt>IBqlCreator</tt> interface. For example, the aggregation functions—such as <tt>Sum</tt>, <tt>Avg</tt>, <tt>Min</tt>, and <tt>Max</tt>—implement the methods of the <tt>IBqlFunction</tt> interface. {br}

The high-level overview of BQL class inheritance is illustrated in the following diagram. For descriptions of the interfaces and classes, see the API Reference.[anchor|#_2850a196-2b5e-4500-abbe-3aedefe693cd][anchor|#_c9987692-faad-4c84-9387-3861ef7b2195][image:StudioDeveloperGuide/Images/BQLCommands.png|popup|BQL commands|450px]{br}

The sections below describe the classes derived from the <tt>BqlCommand</tt> class.
==Select Classes==
The <tt>Select</tt> classes, which are derived from the <tt>BqlCommand</tt> class, represent BQL commands and select all bound fields of the DAC and the unbound fields with specific attributes, such as <tt>PXDBCalced</tt>. ((({S:Hint}More specific, the <tt>Select</tt> classes select all DAC fields that are decorated with the attributes that subscribe to the <tt>PXCommandPreparing</tt> event. For details on which fields are selected, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
))){br}

In a BQL expression based on <tt>Select</tt>, the first type parameter is a DAC, as shown in the following sample BQL statement. <source lang="csharp">Select&lt;Product&gt;</source>
The <tt>Select</tt> classes can parse themselves into SQL and provide methods for modifying the BQL command. However, you cannot directly use the <tt>Select</tt> class to execute the BQL query. Typically, you use <tt>Select</tt> in attributes in DACs, such as the <tt>PXProjection</tt> attribute.
==Search Classes==
The <tt>Search</tt> classes, which are derived from the <tt>BqlCommand</tt> class, select one field of a DAC (while the <tt>Select</tt> classes select multiple fields). {br}

In a <tt>Search</tt>-based statement, the first type parameter is a DAC field, as shown in the following sample BQL expression. This expression selects the <tt>Product.unitPrice</tt> field.<source lang="csharp">Search&lt;Product.unitPrice&gt;</source>These classes can parse themselves into SQL and provide methods for modifying the BQL command. However, you cannot directly use the <tt>Search</tt> class to execute the BQL query. Typically, you use <tt>Search</tt> in attributes in DACs, such as the <tt>PXSelector</tt> attribute. (<tt>PXSelectorAttribute</tt> requires a <tt>Search</tt> class and not a <tt>Select</tt> because the lookup control, which is configured by this attribute, displays precisely one field (usually a key field), which is what <tt>Search</tt> returns.)
==BqlCommand Classes==
The <tt>BqlCommand</tt> classes represent BQL commands. The system uses the following types of <tt>BqlCommand</tt> classes:[anchor|#_70c4aa70-6941-48e5-b434-ba17028cf6ae]
*<tt>BqlCommand</tt>: This base class for the <tt>Select</tt> and <tt>Search</tt> classes is used by the system during the processing of data queries on the data entry forms.
*<tt>BqlGenericCommand</tt>: This class, which is derived from the <tt>BqlCommand</tt> class, is used by the system during the processing of generic inquiries.
*<tt>BqlSoapCommand</tt>: This class, which is derived from the <tt>BqlCommand</tt> class, is used by the system during the processing of reports. For details on report processing, see [HelpRoot_Dev_Platform\CC__con_Rendering_of_Reports|Display of Reports].

The main purpose of <tt>BqlCommand</tt> classes is to convert BQL commands to SQL text. The <tt>BqlGenericCommand</tt> and <tt>BqlSoapCommand</tt> classes provide additional methods for generic inquiry and report processing.
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL]]]></column>
			<column name="PlainText"><![CDATA[The Classes That Compose BQL Statements This topic contains an overview of the classes that you use to compose business query                 language (BQL) statements inside  PXSelect  and to define                 attributes of DACs. Overview of the Classes Almost all classes that compose BQL statements are derived from the                      IBqlCreator  interface, which inherits from the                      IBqlVerifier  interface. These interfaces provide the                 following key methods:  IBqlCreator.AppendExpression() : Used during a BQL command                         preparation to translate a BQL statement into an SQL tree expression, which                         is then produces the SQL text to be sent to the database maintenance server.                         For more information on how this method is used during BQL statement                         execution, see  Translation of a BQL Command to SQL. IBqlVerifier.Verify() : Used during the merge of the                         records with  PXCache  to evaluate a condition on a record                         retrieved from the database or calculate an expression with the record. For                         details on the merge, see  Merge of the Records with PXCache. Depending on the purpose of each BQL class, the class also implements the methods of                 the interfaces derived from the  IBqlCreator  interface. For                 example, the aggregation functions—such as  Sum ,                      Avg ,  Min , and                  Max —implement the methods of the                      IBqlFunction  interface.  The high-level overview of BQL class inheritance is illustrated in the following                 diagram. For descriptions of the interfaces and classes, see the API Reference. BQL commands The sections below describe the classes derived from the                      BqlCommand  class. Select Classes The  Select  classes, which are derived from the                      BqlCommand  class, represent BQL commands and select all bound                 fields of the DAC and the unbound fields with specific attributes, such as                      PXDBCalced .  More specific, the                          Select  classes select all DAC fields that are decorated                     with the attributes that subscribe to the  PXCommandPreparing                      event. For details on which fields are selected, see  Translation of a BQL Command to SQL. In a BQL expression based on  Select , the first type parameter is a                 DAC, as shown in the following sample BQL statement.  Select<Product> The  Select  classes can parse themselves into SQL and provide                 methods for modifying the BQL command. However, you cannot directly use the                      Select  class to execute the BQL query. Typically, you use                      Select  in attributes in DACs, such as the                      PXProjection  attribute. Search Classes The  Search  classes, which are                 derived from the  BqlCommand  class, select one field of a DAC                 (while the  Select  classes select multiple fields).  In a                      Search -based statement, the first type parameter is a DAC                 field, as shown in the following sample BQL expression. This expression selects the                      Product.unitPrice              field. Search<Product.unitPrice> These             classes can parse themselves into SQL and provide methods for modifying the BQL command.             However, you cannot directly use the  Search  class to execute the BQL             query. Typically, you use  Search  in attributes in DACs, such as the                  PXSelector  attribute. ( PXSelectorAttribute              requires a  Search  class and not a  Select  because             the lookup control, which is configured by this attribute, displays precisely one field             (usually a key field), which is what  Search  returns.) BqlCommand Classes The  BqlCommand  classes represent BQL commands. The system uses the                 following types of  BqlCommand  classes: BqlCommand : This base class for the  Select                      and  Search  classes is used by the system during the                     processing of data queries on the data entry forms. BqlGenericCommand : This class, which is derived from the                          BqlCommand  class, is used by the system during the                     processing of generic inquiries. BqlSoapCommand : This class, which is derived from the                          BqlCommand  class, is used by the system during the                     processing of reports. For details on report processing, see  Display of Reports. The main purpose of  BqlCommand  classes is to convert BQL commands                 to SQL text. The  BqlGenericCommand  and                      BqlSoapCommand  classes provide additional methods for generic                 inquiry and report processing. ]]></column>
		</row>
		<row PageID="546dcc53-3648-4c09-a940-afb5692cdfdf" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="99ff3cc7-ef21-e469-0d4f-a81b915185e1" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you need to specify values in a business query language (BQL) statement, you use BQL parameters, which are replaced with the needed values in the translation to SQL. For details, how BQL statements with parameters are translated to SQL, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL#_ff6436a7-d8a9-43c8-9201-d5ea9afbe2d5|Translation of a BQL Command with Parameters to an SQL Query Tree].{br}

In this topic, you can find the description of the BQL parameters and the difference between them.{br}{TOC}
==Current and Current2==
The <tt>Current</tt> parameter, as well as the <tt>Current2</tt> parameter, inserts the field value of the <tt>Current</tt> object from the <tt>PXCache</tt> object in the SQL query. If the <tt>Current</tt> object from the <tt>PXCache</tt> object is {{null}}, the <tt>Current</tt> parameter retrieves the default value of the field, while the <tt>Current2</tt> parameter doesn&rsquo;t retrieve the default value and inserts {{null}}.{br}

By using the <tt>Current</tt> or <tt>Current2</tt> parameter in the declaration of a data view, you can refer to another view to relate these data views to each other. A typical example is referencing the current master record on master-detail webpages. For details on how the <tt>Current</tt> and <tt>Current2</tt> parameters are used, see [HelpRoot_Dev_Platform\AD__how_BQL_Parameters#_def33638-9099-460b-b2d8-b93f75871625|To Relate Data Views to One Another].
==Required==
The <tt>Required</tt> parameter inserts a specific value into the SQL query. {br}

By using the <tt>Required</tt> parameters, you can pass values to the SQL query, as described in [HelpRoot_Dev_Platform\AD__how_BQL_Parameters#_6e19063a-c756-4b7d-88a0-7d0100a187d9|To Pass a Field Value to the SQL Query] and [HelpRoot_Dev_Platform\AD__how_BQL_Parameters#_cc3c4e58-b049-4351-b3c6-ebd9e62a350d|To Pass Multiple Field Values to the SQL Query].
==Optional and Optional2==
The <tt>Optional</tt> parameter works similarly to <tt>Current</tt> (as well as the <tt>Optional2</tt> parameter works similarly to <tt>Current2</tt>) if you don&rsquo;t specify an explicit value for this parameter during BQL statement execution. However, you can also pass an explicit value of the parameter to the SQL query. {br}

By using the <tt>Optional</tt> or <tt>Optional2</tt> parameters, you can pass the external presentations of the values to the SQL query, as described in [HelpRoot_Dev_Platform\AD__how_BQL_Parameters#_4473b629-e9a7-4f41-9041-c0442303d2be|To Provide External Presentation of the Field Value to the SQL Query].
==Argument==
The <tt>Argument</tt> parameter passes values from UI controls to the SQL query. {br}

By using the <tt>Argument</tt> parameters, you can pass values to the data view delegates. For more information on how to use the <tt>Argument</tt> parameter, see [HelpRoot_Dev_Platform\AD__how_BQL_Parameters#_1f3bef64-92a7-469f-9fd2-89f0910565fe|To Pass a Value from a UI Control to a Data View].
==Related Articles==
*[HelpRoot_Dev_Platform\AD__how_BQL_Parameters|To Use Parameters in Traditional BQL]]]></column>
			<column name="PlainText"><![CDATA[Parameters in Traditional BQL Statements If you need to specify values in a business query language (BQL) statement, you use BQL     parameters, which are replaced with the needed values in the translation to SQL. For details,     how BQL statements with parameters are translated to SQL, see  Translation of a BQL Command with Parameters to an SQL Query Tree. In this topic, you can find the description of the BQL parameters and the difference between     them. Current and Current2 The  Current  parameter, as well as the  Current2      parameter, inserts the field value of the  Current  object from the       PXCache  object in the SQL query. If the  Current  object     from the  PXCache  object is  null , the       Current  parameter retrieves the default value of the field, while the       Current2  parameter doesn't retrieve the default value and inserts       null . By using the  Current  or  Current2  parameter in the     declaration of a data view, you can refer to another view to relate these data views to each     other. A typical example is referencing the current master record on master-detail webpages. For     details on how the  Current  and  Current2  parameters are     used, see  To Relate Data Views to One Another. Required The  Required  parameter inserts a specific value into the SQL query.  By using the  Required  parameters, you can pass values to the SQL query, as     described in  To Pass a Field Value to the SQL Query and  To Pass Multiple Field Values to the SQL Query. Optional and Optional2 The  Optional  parameter works similarly to  Current  (as     well as the  Optional2  parameter works similarly to       Current2 ) if you don't specify an explicit value for this parameter during     BQL statement execution. However, you can also pass an explicit value of the parameter to the     SQL query.  By using the  Optional  or  Optional2  parameters, you can     pass the external presentations of the values to the SQL query, as described in  To Provide External Presentation of the Field Value to the SQL Query. Argument The  Argument  parameter passes values from UI controls to the SQL query.  By using the  Argument  parameters, you can pass values to the data view     delegates. For more information on how to use the  Argument  parameter, see       To Pass a Value from a UI Control to a Data View. ]]></column>
		</row>
		<row PageID="5e4ecd15-69fc-4f39-9076-0adb7a928129" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="30f4485f-db91-0865-3252-85562c8e5d67" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The traditional business query language (BQL) library defines the following SQL function equivalents. Note that the use of the BQL equivalents may slightly differ from the use of the corresponding SQL functions. For details on each BQL class, see the API Reference.[anchor|#_43e80f78-d9da-43b1-8aec-dde8ecbf5a50]
===Correspondence Between SQL and BQL===
{| class="checklist" | width="100%" 
|- 
!width="50%" ! SQL
!width="50%" ! Traditional BQL
|- 
| colspan="2" | '''Clauses'''
|- 
| {{WHERE}}
| <tt>Where</tt>
|- 
| {{INNER JOIN}}
| <tt>InnerJoin</tt>
|- 
| {{LEFT JOIN}}
| <tt>LeftJoin</tt>
|- 
| {{RIGHT JOIN}}
| <tt>RightJoin</tt>
|- 
| {{FULL JOIN}}
| <tt>FullJoin</tt>
|- 
| {{CROSS JOIN}}
| <tt>CrossJoin</tt>
|- 
| {{ON}}
| <tt>On</tt>, <tt>On2</tt>
|- 
| {{ORDER BY}}
| <tt>OrderBy</tt>
|- 
| {{ASC}}
| <tt>Asc</tt>
|- 
| {{DESC}}
| <tt>Desc</tt>
|- 
| {{GROUP BY}}
| <tt>Aggregate</tt>, <tt>GroupBy</tt>
|- 
| {{HAVING}}
| <tt>Having</tt>
|- 
| colspan="2" |  '''Aggregation Functions'''
|- 
| {{AVG}}
| <tt>Avg</tt>
|- 
| {{SUM}}
| <tt>Sum</tt>
|- 
| {{MIN}}
| <tt>Min</tt>
|- 
| {{MAX}}
| <tt>Max</tt>
|- 
| {{COUNT}}
| <tt>Count</tt>
|- 
| colspan="2" |  '''Functions'''
|- 
| {{ISNULL}}
| <tt>IsNull&lt;Operand1, Operand2&gt;</tt>
|- 
| {{NULLIF}}
| <tt>NullIf</tt>
|- 
| {{ROUND}}
| <tt>Round</tt>
|- 
| {{SUBSTRING}}
| <tt>Substring</tt>
|- 
| {{CONCAT}}
| <tt>Add</tt>
|- 
| {{RTRIM}}
| <tt>RTrim</tt>
|- 
| {{REPLACE}}
| <tt>Replace</tt>
|- 
| {{DATEDIFF}}
| <tt>DateDiff</tt>
|- 
| {{CASE}}
| <tt>Switch</tt>, <tt>Case</tt>
|- 
| colspan="2" |  '''Arithmetic Operations'''
|- 
| {{(Operand1 + Operand2)}}
| <tt>Add&lt;Operand1, Operand2&gt;</tt>
|- 
| {{(Operand1 - Operand2)}}
| <tt>Sub&lt;Operand1, Operand2&gt;</tt>
|- 
| {{(Operand1 * Operand2)}}
| <tt>Mult&lt;Operand1, Operand2&gt;</tt>
|- 
| {{(Operand1 / Operand2)}}
| <tt>Div&lt;Operand1, Operand2&gt;</tt>
|- 
| {{-Operand}}
| <tt>Minus&lt;Operand&gt;</tt>
|- 
| colspan="2" |  '''Comparisons'''
|- 
| {{=}}
| <tt>Equal</tt>
|- 
| {{<>}}
| <tt>NotEqual</tt>
|- 
| {{>}}
| <tt>Greater</tt>
|- 
| {{<}}
| <tt>Less</tt>
|- 
| {{<=}}
| <tt>LessEqual</tt>
|- 
| {{<=}}
| <tt>GreaterEqual</tt>
|- 
| {{LIKE}}
| <tt>Like</tt>
|- 
| {{NOT LIKE}}
| <tt>NotLike</tt>
|- 
| {{BETWEEN}}
| <tt>Between</tt>
|- 
| {{NOT BETWEEN}}
| <tt>NotBetween</tt>
|- 
| {{IS NULL}}
| <tt>IsNull</tt>
|- 
| {{IS NOT NULL}}
| <tt>IsNotNull</tt>
|- 
| {{IN}}
| <tt>In</tt>, <tt>In2</tt>, <tt>In3</tt>
|- 
| {{NOT IN}}
| <tt>NotIn</tt>, <tt>NotIn2</tt>
|- 
| {{EXISTS}}
| <tt>Exists</tt>
|- 
| colspan="2" |  '''Logical Operators'''
|- 
| {{AND}}
| <tt>And</tt>, <tt>And2</tt>
|- 
| {{OR}}
| <tt>Or</tt>, <tt>Or2</tt>
|- 
| {{NOT}}
| <tt>Not</tt>, <tt>Not2</tt>
|- 
| colspan="2" |  '''Constants'''
|- 
| {{NULL}}
| <tt>Null</tt>
|- 
| Other constants
| <tt>Now</tt>, <tt>Today</tt>, <tt>Tomorrow</tt>, <tt>True</tt>, <tt>False</tt>, <tt>Zero</tt>, <tt>StringEmpty</tt>, <tt>MaxDate</tt>
|- 
| colspan="2" |  '''Full-Text Search Functions'''
|- 
| {{FREETEXTTABLE}}
| <tt>FreeText</tt>
|- 
| {{CONTAINSTABLE}}
| <tt>Contains</tt>
|}]]></column>
			<column name="PlainText"><![CDATA[Traditional BQL and SQL Equivalents The traditional business query language (BQL) library defines the following SQL function    equivalents. Note that the use of the BQL equivalents may slightly differ from the use of the    corresponding SQL functions. For details on each BQL class, see the API Reference. Correspondence Between SQL and BQL SQL Traditional BQL Clauses WHERE Where INNER JOIN InnerJoin LEFT JOIN LeftJoin RIGHT JOIN RightJoin FULL JOIN FullJoin CROSS JOIN CrossJoin ON On ,  On2 ORDER BY OrderBy ASC Asc DESC Desc GROUP BY Aggregate ,  GroupBy HAVING Having Aggregation Functions AVG Avg SUM Sum MIN Min MAX Max COUNT Count Functions ISNULL IsNull<Operand1, Operand2> NULLIF NullIf ROUND Round SUBSTRING Substring CONCAT Add RTRIM RTrim REPLACE Replace DATEDIFF DateDiff CASE Switch ,  Case Arithmetic Operations (Operand1 + Operand2) Add<Operand1, Operand2> (Operand1 - Operand2) Sub<Operand1, Operand2> (Operand1 * Operand2) Mult<Operand1, Operand2> (Operand1 / Operand2) Div<Operand1, Operand2> -Operand Minus<Operand> Comparisons = Equal <> NotEqual > Greater < Less <= LessEqual <= GreaterEqual LIKE Like NOT LIKE NotLike BETWEEN Between NOT BETWEEN NotBetween IS NULL IsNull IS NOT NULL IsNotNull IN In ,  In2 ,  In3 NOT IN NotIn ,  NotIn2 EXISTS Exists Logical Operators AND And ,  And2 OR Or ,  Or2 NOT Not ,  Not2 Constants NULL Null Other constants Now ,  Today ,  Tomorrow ,           True ,  False ,  Zero ,           StringEmpty ,  MaxDate Full-Text Search Functions FREETEXTTABLE FreeText CONTAINSTABLE Contains ]]></column>
		</row>
		<row PageID="610ce4e6-85e6-48e1-8a89-317a6a7f0542" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="906cc1a8-c3d4-803c-b49a-e181aadc6b13" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To select records from the database, you can construct a business query language (BQL) statement. To construct a BQL statement, you use one of the generic <tt>PXSelect</tt> classes. You select the needed <tt>PXSelect</tt> class depending on the statement you need to compose, as described in the sections of this topic.((({S:Hint}In a <tt>PXSelect</tt> class, you configure a query to the database. The actual request to the database is performed once you cast the result of the query execution to a DAC or an array of DACs, or iterate through DACs in the result with the {{foreach}} statement. For details, see [HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution].
))){br}{TOC}[anchor|#_1f0a8248-99eb-4897-be95-8bb852d09cbc]
==Before You Proceed==
Make sure that the application database has the database tables from which you are going to request data, and that the application defines the data access classes (DACs) for these tables. For more information on defining DACs, see [HelpRoot_Dev_Platform\AD__con_DACs_in_TraditionalBQL|Data Access Classes in Traditional BQL].[anchor|#_437434b0-16db-4efd-8f2d-51011ed2b6bb]
==To Select All Records from a Database Table==
To select all data from one database table without applying any filtering conditions or ordering, use one of the <tt>PXSelect</tt> classes that has DAC as the only type parameter, such as the <tt>PXSelect&lt;Table&gt;</tt> or <tt>PXSelectReadonly&lt;Table&gt;</tt> class, as shown in the following sample BQL statement. <source lang="csharp">PXSelect&lt;Product&gt;</source>{br}

In this BQL statement, you are selecting all data records (with the values of all bound fields) from the <tt>Product</tt> table.((({S:Hint}For example, suppose that the <tt>Product</tt> table has two columns, {{ProductID}} and {{UnitPrice}}. In this case, Acumatica Framework translates the previous BQL statement to the following SQL query. The framework adds ordering by the DAC key field (in ascending order) to the end of the SQL query because the BQL statement does not specify ordering.{{{{SELECT Product.ProductID, Product.UnitPrice FROM Product 
       ORDERBY Product.ProductID
}}}}
)))[anchor|#_87d6f3c4-7c4a-49d1-bcf7-4ae37c27e7bd]
==To Filter Records==
To filter records in the database table to be retrieved, construct a BQL statement with conditions by doing the following:[anchor|#_3973149d-e87e-41e2-a8e6-3ea95678e257]
#Use one of the <tt>PXSelect</tt> classes that has the <tt>Where</tt> type parameter, such as <tt>PXSelect&lt;Table, Where&gt;</tt>. For the full list of <tt>PXSelect</tt> classes, see [HelpRoot_Dev_Platform\AD__con_BQL_PXSelect|PXSelect Classes].
#Specify the filtering conditions by using the <tt>Where</tt> clause, as described in [HelpRoot_Dev_Platform\AD__how_BQL_Filter|To Filter Records].
#To specify the fields that should be used for filtering, use the class fields defined in the DACs, such as <tt>Product.productID</tt>. (The name of the field class starts with a lowercase letter. Do not confuse it with the property field, which has the same name but starts with uppercase letter.) 
The following sample BQL statement selects all data records from the {{Product}} table that have the specified value in the {{ProductID}} column.<source lang="csharp">PXSelect&lt;Product,
    Where&lt;Product.productID, Equal&lt;Required&lt;Product.productID&gt;&gt;&gt;&gt;</source>((({S:Hint} Acumatica Framework translates the previous BQL statement to the following SQL query. In this SQL query, {{[list of columns]}} is the list of columns of the {{Product}} table; {{[parameter]}} is the value passed to the <tt>Select()</tt> method of the <tt>PXSelect</tt> class, which is called when the BQL query is executed. {{{{SET @P0 = [parameter];

SELECT [list of columns] FROM Product
    WHERE Product.ProductID = @P0
        ORDERBY Product.ProductID
}}}}[anchor|#_d25748a5-59fc-42f6-a940-ce3ef11039a5]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))[anchor|#_5325d553-3534-4c24-953f-e32fca5d2cb3]
==To Order Records==
To order records in the database table to be retrieved, construct a BQL statement with ordering by doing the following:[anchor|#_72c05844-0d84-4787-baeb-6ea7b766f0f3]
#Use one of the <tt>PXSelect</tt> classes that has the <tt>OrderBy</tt> type parameter, such as <tt>PXSelectOrderBy&lt;Table, OrderBy&gt;</tt> or <tt>PXSelect&lt;Table, Where, OrderBy&gt;</tt>. For the full list of <tt>PXSelect</tt> classes, see [HelpRoot_Dev_Platform\AD__con_BQL_PXSelect|PXSelect Classes].
#Use the <tt>OrderBy</tt> clause to order records, as described in [HelpRoot_Dev_Platform\AD__how_BQL_OrderBy|To Order Records].
#To specify the field that should be used for filtering, use the class field defined in the DAC, such as <tt>Product.productID</tt>. (The name of the field class starts with a lowercase letter. Do not confuse it with the property field, which has the same name but starts with uppercase letter.) 
{br}

The following sample BQL statement selects all <tt>Product</tt> data records and sorts them by the <tt>UnitPrice</tt> field in ascending order.{{{{PXSelectOrderBy&lt;Product, OrderBy&lt;Asc&lt;Product.unitPrice&gt;&gt;&gt;
}}}}((({S:Hint} Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice
}}}}[anchor|#_87aa5d54-334b-4be5-9878-93a8e138d4c7]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
==To Query Multiple Tables==
To join multiple tables, construct a BQL statement by doing the following:[anchor|#_5783419b-1d0c-4fdb-9088-95f07ad44c23]
#Use one of the <tt>PXSelect</tt> classes that has the <tt>Join</tt> type parameter, such as <tt>PXSelectJoin&lt;Table, Join&gt;</tt> or <tt>PXSelectReadonly2&lt;Table, Join&gt;</tt>.
#In the <tt>Join</tt> type parameter of the <tt>PXSelect</tt> class, use one of the <tt>Join</tt> clauses—such as <tt>InnerJoin</tt>, <tt>LeftJoin</tt>, <tt>RightJoin</tt>, <tt>FullJoin</tt>, or <tt>CrossJoin</tt>—that are directly mapped to SQL <tt>JOIN</tt> clauses, as shown in the following sample BQL statement. For more information on the use of <tt>Join</tt> clauses, see [HelpRoot_Dev_Platform\AD__how_Query_Multiple_Tables|To Query Multiple Tables].<source lang="csharp">PXSelectJoin&lt;SalesOrder,
    InnerJoin&lt;OrderDetail,
        On&lt;OrderDetail.orderNbr, Equal&lt;SalesOrder.orderNbr&gt;&gt;&gt;&gt;</source>
#:((({S:Hint}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the joined tables. {{{{SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr
}}}}[anchor|#_ac6373bc-a507-416d-9057-6c6abb1fb00d] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))

==To Aggregate Records==
To group or aggregate records, construct a BQL statement by doing the following:[anchor|#_b13792db-22a0-4dba-a506-419c05130cbe]
#Use one of the <tt>PXSelect</tt> classes with the <tt>Aggregate</tt> type parameter, such as <tt>PXSelectGroupBy&lt;Table, Aggregate&gt;</tt>.
#In the <tt>Aggregate</tt> type parameter of the <tt>PXSelect</tt> class, specify the grouping conditions and aggregation functions by using the <tt>Aggregate&lt;Function&gt;</tt> class, the <tt>GroupBy</tt> clauses, and the <tt>Min</tt>, <tt>Max</tt>, <tt>Sum</tt>, <tt>Avg</tt>, and <tt>Count</tt> aggregation functions, as shown in the following sample BQL statement. For more information on the use of the grouping conditions and aggregation functions, see [HelpRoot_Dev_Platform\AD__how_BQL_Group_and_Aggregate|To Group and Aggregate Records].<source lang="csharp">PXSelectGroupBy&lt;Product,
    Aggregate&lt;GroupBy&lt;Product.categoryCD&gt;&gt;&gt;</source>
#:((({S:Hint}Acumatica Framework translates the previous BQL statement to the following SQL query. {{{{SELECT Product.CategoryCD,
       [MAX(Field) for other fields]
FROM Product
GROUP BY Product.CategoryCD
}}}}
)))

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_BQL_PXSelect|PXSelect Classes]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=82e24896-5ff7-a1fe-a0f8-9bff0ddf27ea|PXSelect&lt;Table, Where, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5ec6f10c-23ef-14aa-6f01-31a2679baebc|PXSelect&lt;Table, Where&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=df23e254-51d3-6c56-2532-55f3602c486b|PXSelect&lt;Table&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=91a0013f-35d6-edeb-0807-74d1754fc756|PXSelectGroupBy&lt;Table, Aggregate&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=aa1de26d-e076-e380-ef3b-3e4af9e4962a|PXSelectGroupBy&lt;Table, Where, Aggregate, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ab32e32c-e84e-f3cb-149d-f4790e5cc800|PXSelectGroupBy&lt;Table, Where, Aggregate&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ad8688e6-5353-143c-7d1f-2d7606c8e393|PXSelectGroupByOrderBy&lt;Table, Aggregate, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=4fc392e5-99e7-73cc-b526-49ccce3e05c2|PXSelectGroupByOrderBy&lt;Table, Join, Aggregate, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=49aea5fc-82e2-ca3b-d766-128f52b544b8|PXSelectJoin&lt;Table, Join, Where, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b3d13bad-ec9d-121e-d0bb-0ddb9c3ed7d1|PXSelectJoin&lt;Table, Join, Where&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=bc94968c-2642-d512-d7f7-a0d286b59126|PXSelectJoin&lt;Table, Join&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c4b6e1f7-866e-58b5-a196-5389e0a7bfe6|PXSelectJoinGroupBy&lt;Table, Join, Aggregate&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e7e783a3-cff9-85da-8681-ecee191db62d|PXSelectJoinGroupBy&lt;Table, Join, Where, Aggregate, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fcb1550e-f1df-7cb1-fb71-865b4646498d|PXSelectJoinGroupBy&lt;Table, Join, Where, Aggregate&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b0667493-2ad5-c38a-e80e-e17818841dc5|PXSelectJoinOrderBy&lt;Table, Join, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fdf23b92-19c4-f2b3-27ec-dd80a240820a|PXSelectOrderBy&lt;Table, Join, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8e8c6674-d029-5f35-069a-b70a9c3e7938|PXSelectOrderBy&lt;Table, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d6496092-e1a7-66b7-a1fa-8ab4dee0a035|PXSelectReadonly&lt;Table, Where, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a0e97d1d-b640-12ee-b6df-54e90d5c73ca|PXSelectReadonly&lt;Table, Where&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a17a006c-90fe-e3b2-df96-0cbddc84cd5d|PXSelectReadonly&lt;Table&gt; ]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=549c3942-b680-1c50-3e63-f8cb423956c1|PXSelectReadonly2&lt;Table, Join, Where, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a0f3fe13-d460-4f0d-b302-4c6fb38a27ae|PXSelectReadonly2&lt;Table, Join, Where&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5349f5f1-6f58-9ac0-1bdd-cab07e51168b|PXSelectReadonly2&lt;Table, Join&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=235c9fa2-ca6a-27d2-f6ce-d145b2608e23|PXSelectReadonly3&lt;Table, Join, OrderBy&gt;]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1cb18bdd-100a-d8d0-a81d-ce74c95757e0|PXSelectReadonly3&lt;Table, OrderBy&gt;]]]></column>
			<column name="PlainText"><![CDATA[To Select Records By Using Traditional BQL To select records from the database, you can construct a business query language (BQL)         statement. To construct a BQL statement, you use one of the generic            PXSelect  classes. You select the needed  PXSelect          class depending on the statement you need to compose, as described in the sections of this           topic. In a  PXSelect  class, you configure a query to the database.           The actual request to the database is performed once you cast the result of the query           execution to a DAC or an array of DACs, or iterate through DACs in the result with the              foreach  statement. For details, see  Data Query Execution. Before You Proceed Make sure that the application database has the database tables from which you are going to         request data, and that the application defines the data access classes (DACs) for these         tables. For more information on defining DACs, see  Data Access Classes in Traditional BQL. To Select All Records from a Database Table To select all data from one database table without applying any filtering conditions or         ordering, use one of the  PXSelect  classes that has DAC as the only type         parameter, such as the  PXSelect<Table>  or            PXSelectReadonly<Table>  class, as shown in the following sample BQL         statement.  PXSelect<Product> In this BQL statement, you are selecting all data records (with the values of all bound         fields) from the  Product  table. For example, suppose that the              Product  table has two columns,  ProductID  and              UnitPrice . In this case,  Acumatica Framework translates the previous BQL statement to the following SQL query. The framework adds           ordering by the DAC key field (in ascending order) to the end of the SQL query because the           BQL statement does not specify           ordering. SELECT Product.ProductID, Product.UnitPrice FROM Product 
       ORDERBY Product.ProductID To Filter Records To filter records in the database table to be retrieved, construct a BQL statement with         conditions by doing the following: Use one of the  PXSelect  classes that has the                Where  type parameter, such as  PXSelect<Table,               Where> . For the full list of  PXSelect  classes, see  PXSelect Classes. Specify the filtering conditions by using the  Where  clause, as             described in  To Filter Records. To specify the fields that should be used for filtering, use the class fields defined             in the DACs, such as  Product.productID . (The name of the field class             starts with a lowercase letter. Do not confuse it with the property field, which has the             same name but starts with uppercase letter.)  The following sample BQL statement selects all data records from the            Product  table that have the specified value in the            ProductID  column. PXSelect<Product,
    Where<Product.productID, Equal<Required<Product.productID>>>>  Acumatica Framework         translates the previous BQL statement to the following SQL query. In this SQL query,            [list of columns]  is the list of columns of the  Product          table;  [parameter]  is the value passed to the  Select()          method of the  PXSelect  class, which is called when the BQL query is         executed.            SET @P0 = [parameter];

SELECT [list of columns] FROM Product
    WHERE Product.ProductID = @P0
        ORDERBY Product.ProductID  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Order Records To order records in the database table to be retrieved, construct a BQL statement with         ordering by doing the following: Use one of the  PXSelect  classes that has the                OrderBy  type parameter, such as  PXSelectOrderBy<Table,               OrderBy>  or  PXSelect<Table, Where, OrderBy> . For the             full list of  PXSelect  classes, see  PXSelect Classes. Use the  OrderBy  clause to order records, as described in  To Order Records. To specify the field that should be used for filtering, use the class field defined in             the DAC, such as  Product.productID . (The name of the field class             starts with a lowercase letter. Do not confuse it with the property field, which has the             same name but starts with uppercase letter.)  The following sample BQL statement selects all  Product  data records and         sorts them by the  UnitPrice  field in ascending order. PXSelectOrderBy<Product, OrderBy<Asc<Product.unitPrice>>>  Acumatica Framework         translates the previous BQL statement to the following SQL query, where  [list of           columns]  is the list of columns of the  Product            table. SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Query Multiple Tables To join multiple tables, construct a BQL statement by doing the following: Use one of the  PXSelect  classes that has the                Join  type parameter, such as  PXSelectJoin<Table,               Join>  or  PXSelectReadonly2<Table, Join> . In the  Join  type parameter of the  PXSelect              class, use one of the  Join  clauses—such as                InnerJoin ,  LeftJoin ,                RightJoin ,  FullJoin , or                CrossJoin —that are directly mapped to SQL                JOIN  clauses, as shown in the following sample BQL statement. For             more information on the use of  Join  clauses, see  To Query Multiple Tables. PXSelectJoin<SalesOrder,
    InnerJoin<OrderDetail,
        On<OrderDetail.orderNbr, Equal<SalesOrder.orderNbr>>>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                  [list of columns]  is the list of columns of the joined tables.                  SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Aggregate Records To group or aggregate records, construct a BQL statement by doing the following: Use one of the  PXSelect  classes with the                Aggregate  type parameter, such as                PXSelectGroupBy<Table, Aggregate> . In the  Aggregate  type parameter of the  PXSelect              class, specify the grouping conditions and aggregation functions by using the                Aggregate<Function>  class, the  GroupBy              clauses, and the  Min ,  Max ,  Sum ,                Avg , and  Count  aggregation functions, as shown             in the following sample BQL statement. For more information on the use of the grouping             conditions and aggregation functions, see  To Group and Aggregate Records. PXSelectGroupBy<Product,
    Aggregate<GroupBy<Product.categoryCD>>> Acumatica Framework translates the previous BQL statement to the following SQL query.                SELECT Product.CategoryCD,
       [MAX(Field) for other fields]
FROM Product
GROUP BY Product.CategoryCD PXSelect<Table,       Where, OrderBy> PXSelect<Table,       Where> PXSelect<Table> PXSelectGroupBy<Table, Aggregate> PXSelectGroupBy<Table, Where, Aggregate,         OrderBy> PXSelectGroupBy<Table, Where, Aggregate> PXSelectGroupByOrderBy<Table, Aggregate,         OrderBy> PXSelectGroupByOrderBy<Table, Join, Aggregate,         OrderBy> PXSelectJoin<Table, Join, Where, OrderBy> PXSelectJoin<Table, Join, Where> PXSelectJoin<Table, Join> PXSelectJoinGroupBy<Table, Join, Aggregate> PXSelectJoinGroupBy<Table, Join, Where, Aggregate,         OrderBy> PXSelectJoinGroupBy<Table, Join, Where,         Aggregate> PXSelectJoinOrderBy<Table, Join, OrderBy> PXSelectOrderBy<Table, Join, OrderBy> PXSelectOrderBy<Table, OrderBy> PXSelectReadonly<Table, Where, OrderBy> PXSelectReadonly<Table, Where> PXSelectReadonly<Table>  PXSelectReadonly2<Table, Join, Where, OrderBy> PXSelectReadonly2<Table, Join, Where> PXSelectReadonly2<Table, Join> PXSelectReadonly3<Table, Join, OrderBy> PXSelectReadonly3<Table, OrderBy> ]]></column>
		</row>
		<row PageID="afd13b51-3676-4cfb-bde6-ff563057014d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="a504e3e1-ff47-8525-4565-91654bc82350" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You construct business query language (BQL) statements with filtering conditions by using the <tt>Where</tt> clause in a <tt>PXSelect</tt> class that has the <tt>Where</tt> type parameter. (For more information on selecting the <tt>PXSelect</tt> class, see [HelpRoot_Dev_Platform\AD__how_Construct_Statement|To Select Records By Using Traditional BQL].) One <tt>Where</tt> clause can contain multiple conditions chained to one another by logical operators (<tt>Or</tt>, <tt>And</tt>, and <tt>Not</tt>) and nested <tt>Where</tt> clauses (these nested clauses are equivalent to placing conditions in brackets). {br}

Typically, you construct a BQL statement with a condition to compare one field with another field or a constant, or to check if the field value has been specified (that is, to compare the field value with null). You can also use multiple conditions in the <tt>Where</tt> clause.{br}{TOC}
==To Compare a Field with Another Field==
To compare one field with another field in the <tt>Where</tt> clause, do the following:[anchor|#_32d8e8ae-fc38-4847-9214-a405d3eff9ba]
#Select the comparison class that you need, such as <tt>NotEqual</tt>, <tt>Greater</tt>, or <tt>Less</tt>.
#Specify the compared field in the first type parameter of the <tt>Where</tt> class and the comparison in the second type parameter, as shown in the following sample BQL statement.<source lang="csharp">PXSelect&lt;Product, Where&lt;Product.bookedQty, Greater&lt;Product.availQty&gt;&gt;&gt;</source>
#:((({S:Hint}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table. {{{{SELECT [list of columns] FROM Product WHERE Product.BookedQty &gt; Product.AvailQty
}}}}[anchor|#_09d65722-ade8-4cad-a00b-1b2d690d5063] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
[anchor|#_32d3d633-c741-4cc3-8f49-f4a611f164cb]
==To Compare a Field with a Constant==
To compare a field with a constant in the <tt>Where</tt> clause, do the following:[anchor|#_e36db1ae-33be-43c8-8976-2da98b804a54]
#Select the comparison class that you need, such as <tt>NotEqual</tt>, <tt>Greater</tt>, or <tt>Less</tt>.
#Select one of the predefined constants—that is, the BQL class derived from the <tt>Constant&lt;Type&gt;</tt> class (such as Boolean values <tt>True</tt> and <tt>False</tt>, integer <tt>Zero</tt>, datetime <tt>Now</tt>, <tt>Today</tt>, and <tt>MaxDate</tt>, and string <tt>StringEmpty</tt>), or define your own constant as a class derived from the <tt>Constant&lt;Type&gt;</tt> class.
#Specify the compared field in the first type parameter of the <tt>Where</tt> class and the comparison in the second type parameter, as shown in the following sample BQL statement.<source lang="csharp">PXSelect&lt;Product, Where&lt;Product.active, Equal&lt;True&gt;&gt;&gt;</source>
#:((({S:Hint}Acumatica Framework translates this BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table. {{{{SELECT [list of columns] FROM Product WHERE Product.Active = CONVERT(BIT, 1)
}}}}[anchor|#_7e1e24f0-2dea-4289-969f-9a71937a4257] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))

==To Compare the Field Value with Null==
To check whether a field value is specified, you compare the field value with null in one of the following ways:[anchor|#_fca7671f-99ff-4728-ac47-691400e8db32]
*To check that the field is null, use the <tt>Where&lt;Operand, Comparison&gt;</tt> class, as shown in the following sample BQL statement.<source lang="csharp">PXSelect&lt;Product, Where&lt;Product.bookedQty, IsNull&gt;&gt;</source>
*:((({S:Hint}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product WHERE Product.BookedQty IS NULL
}}}}[anchor|#_80857f1a-ec3a-4ead-af33-4727cc169806] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
*To check that the field is not null, do one of the following:
**Use the <tt>Where&lt;Operator&gt;</tt> class and the logical operator <tt>Not</tt>, as shown in the following sample BQL statement.{{{{PXSelect&lt;Product, Where&lt;Not&lt;Product.bookedQty, IsNull&gt;&gt;&gt;
}}}}
**:((({S:Hint}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product WHERE NOT (Product.BookedQty IS NULL)
}}}}[anchor|#_40056430-365e-41d5-bc53-a9b9812c3e37] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
**Use the <tt>Where&lt;Operand, Comparison</tt> class, as shown in the following sample BQL statement..<source lang="csharp">PXSelect&lt;Product, Where&lt;Product.bookedQty, IsNotNull&gt;&gt;</source>
**:((({S:Hint}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product WHERE Product.BookedQty IS NOT NULL
}}}}[anchor|#_d06d7a0c-40d6-4b65-8663-3fef2beb2d37] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
((({S:Hint}The predefined constant <tt>Null</tt> cannot be used in the <tt>Where</tt> clause with <tt>Equal</tt> to select records with null fields. The <tt>Null</tt> constant is used in <tt>Switch</tt> conditions.
)))
==To Use Multiple Conditions in One Where Clause==
To specify multiple comparisons in one <tt>Where</tt> clause, do one of the following:[anchor|#_751e1fb5-9f62-43cb-913c-4d079eba992b]
*To specify multiple comparisons that are connected with the same logical operator, use the <tt>Where&lt;Operand, Comparison, NextOperator&gt;</tt> class and specify its type parameters as follows:
**In the first type parameter, specify the first compared field.
**In the second type parameter, specify the first comparison, such as <tt>NotEqual</tt>, <tt>Greater</tt>, or <tt>Less</tt>.
**In the third type parameter, specify the logical operator, such as <tt>And</tt>, <tt>And2</tt>, <tt>Or</tt>, or <tt>Or2</tt>. You can chain any number of comparisons to one another by using binary operators with three type parameters, as shown in the following sample BQL statement. {{{{PXSelect&lt;Product,
    Where&lt;Product.bookedQty, Greater&lt;Product.availQty&gt;,
        Or&lt;Product.availQty, Less&lt;Product.minAvailQty&gt;,
        Or&lt;Product.availQty, IsNull&gt;&gt;&gt;&gt;
}}}}
**:((({S:Hint}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product
WHERE Product.BookedQty &gt; Product.AvailQty
    OR Product.AvailQty &lt; Product.MinAvailQty
    OR Product.AvailQty IsNull
}}}}[anchor|#_d4210b18-d6d7-4625-8992-3bb57b55162d] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
*To write more complex conditional expressions with logical operators of different types, use nested <tt>Where</tt> or <tt>Where2</tt> clauses. For more information on writing complex BQL statements, see [HelpRoot_Dev_Platform\AD__how_Translate_SQL_to_BQL|To Compose a BQL Statement from an SQL Statement].

==Related Articles==
*[HelpRoot_Dev_Platform\AD__how_Translate_SQL_to_BQL|To Compose a BQL Statement from an SQL Statement]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=333f0b35-3b1b-d2e6-9461-7f938893da28|Where&lt;UnaryOperator&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=31772e9f-cf66-a704-5aba-afa93c1b1074|Where&lt;Operand,Comparison&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3d98a29a-0adf-2e77-c70a-d22c06856532|Where&lt;Operand,Comparison,NextOperator&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=f1b7fe99-466c-e596-3f2d-2eb523e662bc|Where2&lt;UnaryOperator,NextOperator&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8a7aea7a-6023-f297-449a-330e36a9039c|Equal&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5bf9cdb1-e01d-017d-0ba2-b67b492c5d2f|NotEqual&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a3abf000-b05d-0e75-92a2-71e51cececd6|Greater&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ed6975a0-18f7-a84d-a18b-6e844092560a|GreaterEqual&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=771c8dec-68ee-7405-f74b-faf963ef68ad|Less&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=24321145-ff89-6dc3-1310-0b4134e646c5|LessEqual&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=afa57f50-1f83-2109-2f45-45d2056fcb09|Like&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1ed13254-585f-8cb0-6f76-c1005248aa40|NotLike&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1ee13f48-868f-608a-6f7f-5657e37d061f|NotBetween&lt;Operand1,Operand2&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d707630b-5c0a-cb8f-3c27-cc7a3f881596|Between&lt;Operand1,Operand2&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1f860331-9959-e8af-becc-4246290d2c1b|IsNull Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=f0f19cfd-5cb8-c7e5-6bca-53a08f590b7b|IsNotNull Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=63727f4d-167e-0024-7ffa-cdac1cb87c80|In&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=72a1d03c-75f1-7edd-907f-5b8a529d61de|In2&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b20a5bf2-a586-3765-1ce3-7e46453e23e9|In3&lt;Operand1,Operand2,Operand3,Operand4&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9f502a96-3342-e27e-f2b9-d229434e39d9|NotIn&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=55bb1526-615a-2121-15fd-fdc4a7b28c8f|NotIn2&lt;Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6c4b075f-4754-acec-645a-9ca461d49010|Constant&lt;ConstType&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e573cf27-fd87-936e-1fcc-23f844733e28|Null Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b3883e2d-3778-a813-9443-788407786c86|Now Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5a2e8a1a-f597-3622-a017-48b13896fc35|Today Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e5db984c-9d1e-ba79-156d-29357f89f42f|Tomorrow Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c43895a9-b24d-1b79-6292-4da7f5b36d4c|True Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=39df6834-9221-d605-d840-0acd8a7646f0|False Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fb1b0290-c58d-996b-796f-fa67cc1d7e79|Zero Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7342a4e0-e0dc-5bc5-a903-1647a5a856be|StringEmpty Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d255794d-2885-6556-b3fe-48658cdec8ec|MaxDate Class]]]></column>
			<column name="PlainText"><![CDATA[To Filter Records You construct business query language (BQL) statements with filtering conditions by using         the  Where  clause in a  PXSelect  class that has the            Where  type parameter. (For more information on selecting the            PXSelect  class, see  To Select Records By Using Traditional BQL.) One            Where  clause can contain multiple conditions chained to one another by         logical operators ( Or ,  And , and          Not ) and nested  Where  clauses (these nested clauses         are equivalent to placing conditions in brackets).  Typically, you construct a BQL statement with a condition to compare one field with another         field or a constant, or to check if the field value has been specified (that is, to compare         the field value with null). You can also use multiple conditions in the            Where  clause. To Compare a Field with Another Field To compare one field with another field in the  Where  clause, do the           following: Select the comparison class that you need, such as  NotEqual ,                Greater , or  Less . Specify the compared field in the first type parameter of the  Where              class and the comparison in the second type parameter, as shown in the following sample             BQL                 statement. PXSelect<Product, Where<Product.bookedQty, Greater<Product.availQty>>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                  [list of columns]  is the list of columns of the                  Product  table.                  SELECT [list of columns] FROM Product WHERE Product.BookedQty > Product.AvailQty  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Compare a Field with a Constant To compare a field with a constant in the  Where  clause, do the           following: Select the comparison class that you need, such as  NotEqual ,                Greater , or  Less . Select one of the predefined constants—that is, the BQL class derived from the                Constant<Type>  class (such as Boolean values                True  and  False , integer  Zero ,             datetime  Now ,  Today , and                MaxDate , and string  StringEmpty ), or define your             own constant as a class derived from the  Constant<Type>              class. Specify the compared field in the first type parameter of the  Where              class and the comparison in the second type parameter, as shown in the following sample             BQL                 statement. PXSelect<Product, Where<Product.active, Equal<True>>> Acumatica Framework translates this BQL statement to the following SQL query, where  [list of                 columns]  is the list of columns of the  Product  table.                  SELECT [list of columns] FROM Product WHERE Product.Active = CONVERT(BIT, 1)  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Compare the Field Value with Null To check whether a field value is specified, you compare the field value with null in one         of the following ways: To check that the field is null, use the  Where<Operand,               Comparison>  class, as shown in the following sample BQL                 statement. PXSelect<Product, Where<Product.bookedQty, IsNull>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                  [list of columns]  is the list of columns of the                  Product                  table. SELECT [list of columns] FROM Product WHERE Product.BookedQty IS NULL  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To check that the field is not null, do one of the following: Use the  Where<Operator>  class and the logical operator                    Not , as shown in the following sample BQL                     statement. PXSelect<Product, Where<Not<Product.bookedQty, IsNull>>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                      [list of columns]  is the list of columns of the                      Product                      table. SELECT [list of columns] FROM Product WHERE NOT (Product.BookedQty IS NULL)  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. Use the  Where<Operand, Comparison  class, as shown in the                 following sample BQL                     statement.. PXSelect<Product, Where<Product.bookedQty, IsNotNull>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                      [list of columns]  is the list of columns of the                      Product                      table. SELECT [list of columns] FROM Product WHERE Product.BookedQty IS NOT NULL  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. The predefined constant  Null  cannot be used           in the  Where  clause with  Equal  to select records           with null fields. The  Null  constant is used in              Switch  conditions. To Use Multiple Conditions in One Where Clause To specify multiple comparisons in one  Where  clause, do one of the           following: To specify multiple comparisons that are connected with the same logical operator, use             the  Where<Operand, Comparison, NextOperator>  class and specify             its type parameters as follows: In the first type parameter, specify the first compared field. In the second type parameter, specify the first comparison, such as                    NotEqual ,  Greater , or                    Less . In the third type parameter, specify the logical operator, such as                    And ,  And2 ,  Or , or                    Or2 . You can chain any number of comparisons to one another by                 using binary operators with three type parameters, as shown in the following sample                 BQL statement.                      PXSelect<Product,
    Where<Product.bookedQty, Greater<Product.availQty>,
        Or<Product.availQty, Less<Product.minAvailQty>,
        Or<Product.availQty, IsNull>>>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                      [list of columns]  is the list of columns of the                      Product                      table. SELECT [list of columns] FROM Product
WHERE Product.BookedQty > Product.AvailQty
    OR Product.AvailQty < Product.MinAvailQty
    OR Product.AvailQty IsNull  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To write more complex conditional expressions with logical operators of different             types, use nested  Where  or  Where2  clauses. For             more information on writing complex BQL statements, see  To Compose a BQL Statement from an SQL Statement. Where<UnaryOperator> Class Where<Operand,Comparison> Class Where<Operand,Comparison,NextOperator> Class Where2<UnaryOperator,NextOperator> Class Equal<Operand> Class NotEqual<Operand> Class Greater<Operand> Class GreaterEqual<Operand> Class Less<Operand> Class LessEqual<Operand> Class Like<Operand> Class NotLike<Operand> Class NotBetween<Operand1,Operand2> Class Between<Operand1,Operand2> Class IsNull Class IsNotNull Class In<Operand> Class In2<Operand> Class In3<Operand1,Operand2,Operand3,Operand4> Class NotIn<Operand> Class NotIn2<Operand> Class Constant<ConstType> Class Null Class Now Class Today Class Tomorrow Class True Class False Class Zero Class StringEmpty Class MaxDate Class ]]></column>
		</row>
		<row PageID="fadd819c-7751-438c-b5ee-ede99ef2e4fa" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="443dde5b-6100-ce85-04db-a1c9d1384930" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You construct business query language (BQL) statements that include ordering of records by using the <tt>OrderBy</tt> clause in one of the <tt>PXSelect</tt> classes that has the <tt>OrderBy</tt> type parameter. (For more information on selecting the <tt>PXSelect</tt> class, see [HelpRoot_Dev_Platform\AD__how_Construct_Statement|To Select Records By Using Traditional BQL].) {br}

By default, if the BQL statement does not specify ordering, Acumatica Framework adds ordering by the data access class (DAC) key fields (in the order of field declaration) in ascending order to the end of the SQL query. You can order the records by one column or multiple columns, or by a condition. {br}{TOC}
==To Order Records by One Column==
To order records by one column in ascending or descending order, use the <tt>OrderBy</tt> class and the <tt>Asc&lt;Field&gt;</tt> or <tt>Desc&lt;Field&gt;</tt> class, as shown in the following sample BQL statement. {{{{PXSelectOrderBy&lt;Product, OrderBy&lt;Asc&lt;Product.unitPrice&gt;&gt;&gt;
}}}}{br}

In this statement, all <tt>Product</tt> data records are selected and are sorted by the <tt>UnitPrice</tt> field in ascending order.((({S:Hint}Acumatica Framework translates this BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice
}}}}[anchor|#_82c56f37-99d9-4508-8774-64730af411e9]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
==To Order Records by Multiple Columns==
To order records by multiple columns, use the <tt>OrderBy</tt> class and the <tt>Asc&lt;Field, NextField&gt;</tt> or <tt>Desc&lt;Field, NextField&gt;</tt> class, as shown in the following sample BQL statement. {{{{PXSelectOrderBy&lt;Product,
    OrderBy&lt;Asc&lt;Product.unitPrice, Desc&lt;Product.availQty&gt;&gt;&gt;&gt;
}}}}((({S:Hint} Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice, Product.AvailQty DESC
}}}}[anchor|#_d0c4c40d-8600-41e5-a9c9-b8d734fb7d22]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
==To Order Records by a Condition==
To sort data records according to a condition, put the <tt>Switch</tt> clause inside <tt>Asc</tt> or <tt>Desc</tt> in <tt>OrderBy</tt>, as shown in the following sample BQL statement.<source lang="csharp">PXSelectOrderBy&lt;Product,
   OrderBy&lt;Asc&lt;
       Switch&lt;Case&lt;Where&lt;Product.availQty, Greater&lt;Product.bookedQty&gt;&gt;, True&gt;,
              False&gt;&gt;&gt;&gt;</source>{br}

In this statement, the records with <tt>AvailQty</tt> values less or equal to <tt>BookedQty</tt> values are ordered first.((({S:Hint}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table. {{{{SELECT [list of columns] FROM Product
ORDER BY
    ( CASE
         WHEN Product.AvailQty &gt; Product.BookedQty THEN 1
         ELSE 0
      END )
}}}}[anchor|#_6a3e1b21-e9c5-448c-8eb2-0ce015a6790a]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=03cd827b-ce56-05ff-4df3-2443671b1f49|OrderBy&lt;List&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=0e985725-1b3e-c304-37ac-f11ed8696f6a|Asc&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=61408018-bac6-cfb0-896a-2aa9dcc3fd60|Asc&lt;Field,NextField&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d08ab3e2-14f3-ba13-eef1-338af476acdc|Desc&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d442af4b-1155-584a-77cc-3129391c4531|Desc&lt;Field,NextField&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=4c3d5304-4a27-9a58-44ef-532baf5a7410|Switch&lt;Case&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d7ee3bc8-f28c-3824-d24b-3a723ebcc2c9|Switch&lt;Case,Default&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ac0f4d62-2a52-0bf8-1ed2-da25d5c57dde|Case&lt;Where&#95;,Operand&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=15dd8bb7-047f-f2a6-b2ec-d3f3bef79019|Case&lt;Where&#95;,Operand,NextCase&gt; Class]]]></column>
			<column name="PlainText"><![CDATA[To Order Records You construct business query language (BQL) statements that include ordering of                 records by using the  OrderBy  clause in one of the                      PXSelect  classes that has the  OrderBy  type                 parameter. (For more information on selecting the  PXSelect  class,                 see  To Select Records By Using Traditional BQL.)  By default, if the BQL statement does not specify ordering,  Acumatica Framework adds ordering by the data access class (DAC) key fields (in the order of field                 declaration) in ascending order to the end of the SQL query. You can order the                 records by one column or multiple columns, or by a condition.  To Order Records by One Column To order records by one column in ascending or descending order, use the                      OrderBy  class and the  Asc<Field>  or                      Desc<Field>  class, as shown in the following sample BQL                 statement.                  PXSelectOrderBy<Product, OrderBy<Asc<Product.unitPrice>>> In this statement, all  Product  data records are selected and are                 sorted by the  UnitPrice  field in ascending order. Acumatica Framework translates this BQL statement to the following SQL query, where  [list                         of columns]  is the list of columns of the  Product                          table. SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Order Records by Multiple Columns To order records by multiple columns, use the  OrderBy  class and                 the  Asc<Field, NextField>  or  Desc<Field,                     NextField>  class, as shown in the following sample BQL statement.  PXSelectOrderBy<Product,
    OrderBy<Asc<Product.unitPrice, Desc<Product.availQty>>>>  Acumatica Framework translates the previous BQL statement to the following SQL query, where                      [list of columns]  is the list of columns of the                      Product                      table. SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice, Product.AvailQty DESC  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Order Records by a Condition To sort data records according to a condition, put the  Switch                  clause inside  Asc  or  Desc  in                      OrderBy , as shown in the following sample BQL                 statement. PXSelectOrderBy<Product,
   OrderBy<Asc<
       Switch<Case<Where<Product.availQty, Greater<Product.bookedQty>>, True>,
              False>>>> In this statement, the records with  AvailQty  values less or equal                 to  BookedQty  values are ordered first. Acumatica Framework translates the previous BQL statement to the following SQL query, where                          [list of columns]  is the list of columns of the                          Product  table.                          SELECT [list of columns] FROM Product
ORDER BY
    ( CASE
         WHEN Product.AvailQty > Product.BookedQty THEN 1
         ELSE 0
      END )  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. OrderBy<List> Class Asc<Field> Class Asc<Field,NextField> Class Desc<Field> Class Desc<Field,NextField> Class Switch<Case> Class Switch<Case,Default> Class Case<Where_,Operand> Class Case<Where_,Operand,NextCase> Class ]]></column>
		</row>
		<row PageID="13001ef0-91f0-4094-b924-d1114c3e8e41" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="36a02f27-0bed-e920-0e05-98dec0cf2878" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You construct business query language (BQL) statements that join multiple tables by using one of the <tt>Join</tt> clauses in one of the <tt>PXSelect</tt> classes that has the <tt>Join</tt> type parameter. (For more information on selecting the <tt>PXSelect</tt> class, see [HelpRoot_Dev_Platform\AD__how_Construct_Statement|To Select Records By Using Traditional BQL].) In BQL statements, you can join multiple database tables by using the following clauses directly mapped to SQL <tt>JOIN</tt> clauses:[anchor|#ul_i4m_bjm_kk]
*<tt>InnerJoin</tt> returns all records where there is at least one match in both tables.
*<tt>LeftJoin</tt> returns all records from the left table, and the matched records from the right table. Where there are no matched records from the right table, null values are inserted.
*<tt>RightJoin</tt> returns all records from the right table, and the matched records from the left table. Where there are no matched records from the left table, null values are inserted.
*<tt>FullJoin</tt> returns all records when there is a match in one of the tables.
*<tt>CrossJoin</tt> returns the entire Cartesian product of the two tables.
{br}{TOC}
==To Join Two Tables (Inner Join, Left Join, Right Join, or Full Join)==
To join two tables, use one of the <tt>Join</tt> clauses with two type parameters (such as <tt>InnerJoin&lt;Table, On&gt;</tt>) and the <tt>On&lt;Operand, Comparison&gt;</tt> or <tt>On&lt;Operator&gt;</tt> class to specify a conditional expression for joining, as shown in the following sample BQL statement. <source lang="csharp">PXSelectJoin&lt;SalesOrder,
    InnerJoin&lt;OrderDetail,
        On&lt;OrderDetail.orderNbr, Equal&lt;SalesOrder.orderNbr&gt;&gt;&gt;&gt;</source>((({S:Hint} Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the joined tables.{{{{SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr
}}}}[anchor|#_449a6bfb-4e28-4c7f-948a-76e0a83c9151]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
==To Cross-Join Two Tables==
To cross-join two tables, use the <tt>CrossJoin&lt;Table&gt;</tt> class, as shown in the following sample BQL statement.<source lang="csharp">PXSelectJoin&lt;Product, CrossJoin&lt;Supplier&gt;&gt;</source>((({S:Hint} Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the joined tables.{{{{SELECT [list of columns] FROM Product CROSS JOIN Supplier
}}}}[anchor|#_b54252c3-ad91-4962-aa9a-c3e0bcd2482c]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
==To Join Multiple Tables==
To specify multiple join clauses, use the following instructions:[anchor|#_355eb67e-f1d6-4440-8669-835073b515b5]
*Use a <tt>Join</tt> clause with three type parameters (such as <tt>InnerJoin&lt;Table, On, NextJoin&gt;</tt>). Each subsequent join clause is specified as the last type parameter of the previous join clause, as shown in the following sample BQL statement.{{{{PXSelectJoin&lt;SalesOrder,
    InnerJoin&lt;OrderDetail,
        On&lt;OrderDetail.orderNbr, Equal&lt;SalesOrder.orderNbr&gt;&gt;,
    LeftJoin&lt;Employee,
        On&lt;Employee.employeeID, Equal&lt;SalesOrder.employeeID&gt;&gt;&gt;&gt;&gt;
}}}}
*:((({S:Hint}Acumatica Framework translates this BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the joined tables. {{{{SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr
LEFT JOIN Employee
    ON Employee.EmployeeID = SalesOrder.EmployeeID
}}}}[anchor|#_ef6e48c9-a47c-4608-8a95-714ab8fab796] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
*Use the <tt>On</tt> conditions to specify conditional expressions for joining, as shown in the following sample BQL statement. In subsequent join clauses, the <tt>On</tt> conditions can refer to fields from any joined table, and can contain any number of conditions chained by logical operators as in filtering conditions.<source lang="csharp">PXSelectJoin&lt;SalesOrder,
    InnerJoin&lt;OrderDetail,
        On&lt;OrderDetail.orderNbr, Equal&lt;SalesOrder.orderNbr&gt;&gt;,
    LeftJoin&lt;Employee,
        On&lt;Employee.employeeID, Equal&lt;SalesOrder.employeeID&gt;&gt;,
    RightJoin&lt;Product,
        On&lt;Product.productID, Equal&lt;OrderDetail.productID&gt;,
        And&lt;Product.unitPrice, Equal&lt;OrderDetail.unitPrice&gt;&gt;&gt;&gt;&gt;&gt;&gt;</source>
*:((({S:Hint}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the joined tables. {{{{SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr
LEFT JOIN Employee
    ON Employee.EmployeeID = SalesOrder.EmployeeID
RIGHT JOIN Product
    ON (Product.ProductID = OrderDetail.ProductID AND
        Product.UnitPrice = OrderDetail.UnitPrice)
}}}}[anchor|#_db5c2795-e2ff-4430-9c38-a8938326fbe8] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))

==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=85ce9501-4545-d16d-80a9-6414e82b891c|InnerJoin&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=0a08f5a5-0d6b-e24a-e97c-c4c7e0aaa8c1|InnerJoin&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d0f3d228-023e-e0b1-c246-2a3cde35be01|InnerJoinSingleTable&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1ccf8c22-2f5c-3a7f-3746-a802a9dbc991|InnerJoinSingleTable&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e223a087-0b26-b098-cb6c-626020c475ac|LeftJoin&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e97f269e-0779-352a-9440-e4897db81b06|LeftJoin&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=0e6f7c63-0618-0415-3700-ce516ff5e4fd|LeftJoinSingleTable&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8e610cde-1958-2250-eb04-0c5db04bc5d5|LeftJoinSingleTable&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=329bd6a9-5e12-6be8-2821-6b6fc767185f|RightJoin&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=124ebf93-5063-2c3c-0811-fcef0f89cab9|RightJoin&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3350adc4-f6d5-5327-dc41-49c33b972bb4|RightJoinSingleTable&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9edbd28d-f03c-a2dd-93f2-117eaee4f090|RightJoinSingleTable&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e9ecfe4b-2478-6655-ed63-f33dc5f1277c|FullJoin&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=53fbedb7-b7de-e478-3dbb-218b14e8247b|FullJoin&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c05e45af-63d5-1f0a-5b1a-72918da7a626|FullJoinSingleTable&lt;Table,On&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a3b57fc6-df8b-0dd1-5518-13bce71dc7cc|FullJoinSingleTable&lt;Table,On,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a7c74d92-09e1-6e3c-53ca-395da6483028|CrossJoin&lt;Table&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b99003c9-77b5-147e-aa21-b10e7496a7e0|CrossJoin&lt;Table,NextJoin&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=15053230-2aac-89a2-3f8e-89dd0951fbbc|CrossJoinSingleTable&lt;Table&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=08277fd4-ba8f-312d-e49c-8f366845ec11|CrossJoinSingleTable&lt;Table,NextJoin&gt; Class]]]></column>
			<column name="PlainText"><![CDATA[To Query Multiple Tables You construct business query language (BQL) statements that join multiple tables by using         one of the  Join  clauses in one of the  PXSelect  classes         that has the  Join  type parameter. (For more information on selecting the            PXSelect  class, see  To Select Records By Using Traditional BQL.) In BQL         statements, you can join multiple database tables by using the following clauses directly         mapped to SQL  JOIN  clauses: InnerJoin  returns all records where there is at least one match in           both tables. LeftJoin  returns all records from the left table, and the matched           records from the right table. Where there are no matched records from the right table,           null values are inserted. RightJoin  returns all records from the right table, and the matched           records from the left table. Where there are no matched records from the left table, null           values are inserted. FullJoin  returns all records when there is a match in one of the           tables. CrossJoin  returns the entire Cartesian product of the two           tables. To Join Two Tables (Inner Join, Left Join, Right Join, or Full Join) To join two tables, use one of the  Join  clauses with two type parameters         (such as  InnerJoin<Table, On> ) and the  On<Operand,           Comparison>  or  On<Operator>  class to specify a conditional         expression for joining, as shown in the following sample BQL statement.  PXSelectJoin<SalesOrder,
    InnerJoin<OrderDetail,
        On<OrderDetail.orderNbr, Equal<SalesOrder.orderNbr>>>>  Acumatica Framework         translates the previous BQL statement to the following SQL query, where  [list of           columns]  is the list of columns of the joined           tables. SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Cross-Join Two Tables To cross-join two tables, use the  CrossJoin<Table>  class, as shown in         the following sample BQL statement. PXSelectJoin<Product, CrossJoin<Supplier>>  Acumatica Framework         translates the previous BQL statement to the following SQL query, where  [list of           columns]  is the list of columns of the joined           tables. SELECT [list of columns] FROM Product CROSS JOIN Supplier  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Join Multiple Tables To specify multiple join clauses, use the following instructions: Use a  Join  clause with three type parameters (such as                  InnerJoin<Table, On, NextJoin> ). Each subsequent join clause               is specified as the last type parameter of the previous join clause, as shown in the               following sample BQL statement. PXSelectJoin<SalesOrder,
    InnerJoin<OrderDetail,
        On<OrderDetail.orderNbr, Equal<SalesOrder.orderNbr>>,
    LeftJoin<Employee,
        On<Employee.employeeID, Equal<SalesOrder.employeeID>>>>> Acumatica Framework translates this BQL statement to the following SQL query, where  [list of                   columns]  is the list of columns of the joined tables.                    SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr
LEFT JOIN Employee
    ON Employee.EmployeeID = SalesOrder.EmployeeID  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. Use the  On  conditions to specify conditional expressions for               joining, as shown in the following sample BQL statement. In subsequent join clauses,               the  On  conditions can refer to fields from any joined table, and               can contain any number of conditions chained by logical operators as in filtering               conditions. PXSelectJoin<SalesOrder,
    InnerJoin<OrderDetail,
        On<OrderDetail.orderNbr, Equal<SalesOrder.orderNbr>>,
    LeftJoin<Employee,
        On<Employee.employeeID, Equal<SalesOrder.employeeID>>,
    RightJoin<Product,
        On<Product.productID, Equal<OrderDetail.productID>,
        And<Product.unitPrice, Equal<OrderDetail.unitPrice>>>>>>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                  [list of columns]  is the list of columns of the joined tables.                  SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr
LEFT JOIN Employee
    ON Employee.EmployeeID = SalesOrder.EmployeeID
RIGHT JOIN Product
    ON (Product.ProductID = OrderDetail.ProductID AND
        Product.UnitPrice = OrderDetail.UnitPrice)  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. InnerJoin<Table,On> Class InnerJoin<Table,On,NextJoin> Class InnerJoinSingleTable<Table,On> Class InnerJoinSingleTable<Table,On,NextJoin> Class LeftJoin<Table,On> Class LeftJoin<Table,On,NextJoin> Class LeftJoinSingleTable<Table,On> Class LeftJoinSingleTable<Table,On,NextJoin> Class RightJoin<Table,On> Class RightJoin<Table,On,NextJoin> Class RightJoinSingleTable<Table,On> Class RightJoinSingleTable<Table,On,NextJoin> Class FullJoin<Table,On> Class FullJoin<Table,On,NextJoin> Class FullJoinSingleTable<Table,On> Class FullJoinSingleTable<Table,On,NextJoin> Class CrossJoin<Table> Class CrossJoin<Table,NextJoin> Class CrossJoinSingleTable<Table> Class CrossJoinSingleTable<Table,NextJoin> Class ]]></column>
		</row>
		<row PageID="44827160-45dd-4cfe-82b9-6d4230e4f620" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="9c92ffcc-9189-a8e8-79bc-d8acd06e9f5a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You construct business query language (BQL) statements that group and aggregate records by using the <tt>Aggregate</tt> clause in one of the <tt>PXSelect</tt> classes that has the <tt>Aggregate</tt> type parameter. (For more information on selecting the <tt>PXSelect</tt> class, see [HelpRoot_Dev_Platform\AD__how_Construct_Statement|To Select Records By Using Traditional BQL].) 
==To Group and Aggregate Records==
To group and aggregate records, follow the instructions below:[anchor|#_23e97a66-804a-482f-85be-8d990e41a515]
#Specify all grouping conditions (the <tt>GroupBy</tt> clause) and aggregation functions (such as <tt>Min</tt>, <tt>Max</tt>, <tt>Sum</tt>, <tt>Avg</tt>, and <tt>Count</tt>) in the <tt>Aggregate</tt> clause, as shown in the following sample BQL statement. Fields specified in <tt>GroupBy</tt> clauses are selected as is; an aggregation function is applied to all other fields. The default <tt>Max</tt> function is used if no function is specified for a field. If a data field has the <tt>PXDBScalar</tt> attribute, NULL is inserted for that field.<source lang="csharp">PXSelectGroupBy&lt;Product,
    Aggregate&lt;GroupBy&lt;Product.categoryCD&gt;&gt;&gt;</source>
#:((({S:Hint}Acumatica Framework translates the previous BQL statement to the following SQL query.{{{{SELECT Product.CategoryCD,
       [MAX(Field) for other fields]
FROM Product
GROUP BY Product.CategoryCD
}}}}
)))
#If necessary, insert another <tt>GroupBy</tt> clause or aggregation function as the second type parameter of the previous <tt>GroupBy</tt> clause or aggregation function, as shown in the following sample BQL statement.<source lang="csharp">PXSelectGroupBy&lt;Product,
    Aggregate&lt;GroupBy&lt;Product.categoryCD,
              Sum&lt;Product.availQty,
              Sum&lt;Product.bookedQty,
              GroupBy&lt;Product.stockUnit,
              Min&lt;Product.unitPrice&gt;&gt;&gt;&gt;&gt;&gt;&gt;</source>
#:((({S:Hint}Acumatica Framework translates the previous BQL statement to the following SQL query.{{{{SELECT Product.CategoryCD, Product.StockUnit,
       SUM(Product.AvailQty), SUM(Product.AvailQty), MIN(Product.UnitPrice),
       [MAX(Field) for other fields]
FROM Product
GROUP BY Product.CategoryCD, Product.StockUnit
}}}}
)))

==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a68f8d2b-9917-d62d-bc82-037affc0327b|Aggregate&lt;Function&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=cb1df45b-f23c-f767-749e-88f0fa4c79f2|GroupBy&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=dfabceb1-c8d1-0f8a-02d6-2fd26e5e928f|GroupBy&lt;Field,NextAggregate&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7edc9b63-2102-74f6-fd5a-6d58146cdc16|Min&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=4a691f0e-ce9d-427a-015a-d3eb84fb40fc|Min&lt;Field,NextAggregate&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8ebdb12a-8083-df48-cb90-1f088037fda9|Max&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9922cbdd-9f68-d682-59e1-79f4b29107d5|Max&lt;Field,NextAggregate&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8d6b4bc4-d6b6-d5c6-cc12-25718d84ef16|Sum&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fbe63dbc-715a-d504-4ca3-47e47b849e83|Sum&lt;Field,NextAggregate&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1e7eb237-880e-1582-77ae-bf9c6f9ae5c9|Avg&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d6838e35-7cc3-19af-3b57-4266f15f2737|Avg&lt;Field,NextAggregate&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7cd8b299-8184-6726-af1d-0192167dd87a|Count Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8ce5be95-5414-d507-2fb9-64856cbe10ac|Count&lt;Field&gt; Class]]]></column>
			<column name="PlainText"><![CDATA[To Group and Aggregate Records You construct business query language (BQL) statements that group and aggregate                 records by using the  Aggregate  clause in one of the                      PXSelect  classes that has the  Aggregate                  type parameter. (For more information on selecting the  PXSelect                  class, see  To Select Records By Using Traditional BQL.)  To Group and Aggregate Records To group and aggregate records, follow the instructions below: Specify all grouping conditions (the  GroupBy  clause) and                         aggregation functions (such as  Min ,                              Max ,  Sum ,  Avg ,                         and  Count ) in the  Aggregate  clause, as                         shown in the following sample BQL statement. Fields specified in                              GroupBy  clauses are selected as is; an aggregation                         function is applied to all other fields. The default  Max                          function is used if no function is specified for a field. If a data field                         has the  PXDBScalar  attribute, NULL is inserted for that                                 field. PXSelectGroupBy<Product,
    Aggregate<GroupBy<Product.categoryCD>>> Acumatica Framework                             translates the previous BQL statement to the following SQL                             query. SELECT Product.CategoryCD,
       [MAX(Field) for other fields]
FROM Product
GROUP BY Product.CategoryCD If necessary, insert another  GroupBy  clause or                         aggregation function as the second type parameter of the previous                              GroupBy  clause or aggregation function, as shown in                         the following sample BQL                                 statement. PXSelectGroupBy<Product,
    Aggregate<GroupBy<Product.categoryCD,
              Sum<Product.availQty,
              Sum<Product.bookedQty,
              GroupBy<Product.stockUnit,
              Min<Product.unitPrice>>>>>>> Acumatica Framework                             translates the previous BQL statement to the following SQL                             query. SELECT Product.CategoryCD, Product.StockUnit,
       SUM(Product.AvailQty), SUM(Product.AvailQty), MIN(Product.UnitPrice),
       [MAX(Field) for other fields]
FROM Product
GROUP BY Product.CategoryCD, Product.StockUnit Aggregate<Function> Class GroupBy<Field> Class GroupBy<Field,NextAggregate> Class Min<Field> Class Min<Field,NextAggregate> Class Max<Field> Class Max<Field,NextAggregate> Class Sum<Field> Class Sum<Field,NextAggregate> Class Avg<Field> Class Avg<Field,NextAggregate> Class Count Class Count<Field> Class ]]></column>
		</row>
		<row PageID="d54a07cc-67d0-4ccb-8cf2-5be7210fb8ec" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="4784c0c7-7ed8-9909-fb1f-5f879466a0ef" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You may need to use BQL parameters if you need to relate data views to each other, to pass field values to the SQL query, to pass the external presentations of the values to the SQL query, or to pass values from UI controls to the SQL query. For more information on the BQL parameters, see [HelpRoot_Dev_Platform\AD__con_Parameters|Parameters in Traditional BQL Statements].{br}{TOC}[anchor|#_def33638-9099-460b-b2d8-b93f75871625]
==To Relate Data Views to One Another==
To relate data views to one another, use the <tt>Current</tt> parameter, as shown in the following sample code.{{{{// The view declarations in a graph
PXSelect&lt;Document&gt; Documents;
PXSelect&lt;DocTransaction,
    Where&lt;DocTransaction.docNbr, Equal&lt;Current&lt;Document.docNbr&gt;&gt;,
        And&lt;DocTransaction.docType, Equal&lt;Current&lt;Document.docType&gt;&gt;&gt;&gt;&gt;
            DocTransactions;
}}}}{br}

In this code, there is a many-to-one relationship between the <tt>DocTransaction</tt> and <tt>Document</tt> data access classes (DACs), and this relationship is implemented through the <tt>DocNbr</tt> and <tt>DocType</tt> key fields. The views in the code connect the <tt>Document</tt> and <tt>DocTransaction</tt> records.((({S:Hint}Acumatica Framework translates the BQL query of the second view in the sample BQL code to the following SQL statement. In this SQL query, {{[parameter1]}} is the <tt>DocNbr</tt> value and {{[parameter2]}} is the <tt>DocType</tt> value taken from the <tt>Current</tt> property of the <tt>DocTransaction</tt> cache; {{[list of columns]}} is the list of columns of the {{DocTransaction}} table.{{{{SET @P0 = [parameter1] 
SET @P1 = [parameter2]

SELECT * FROM DocTransaction
WHERE DocTransaction.DocNbr = @P0
    AND DocTransaction.DocType = @P1
}}}}[anchor|#_7d2fbb02-ee19-4a06-8de1-daf19636b248]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))[anchor|#_6e19063a-c756-4b7d-88a0-7d0100a187d9]
==To Pass a Field Value to the SQL Query==
To pass a specific value to the SQL query, use the <tt>Required</tt> parameter in the BQL statement and specify the needed value as the <tt>Select()</tt> method argument. The value passed to <tt>Select()</tt> must be of the same type as the type of the specified field.{br}

((({S:Hint}The <tt>Required</tt> parameter should be used only in the BQL statements that are directly executed in the application code. The data views that are queried from the UI will not work if they contain <tt>Required</tt> parameters.
))){br}

The code below shows the execution of a BQL statement with the <tt>Required</tt> parameter.<source lang="csharp">// Suppose an event handler related to the Product DAC
// is being executed
Product product = (Product)e.Row;

// Select the Category record with the specified CategoryCD
Category category =
    PXSelect&lt;Category,
        Where&lt;Category.categoryCD, Equal&lt;Required&lt;Category.categoryCD&gt;&gt;&gt;&gt;
        .Select(this, product.CategoryCD);</source>((({S:Hint} Acumatica Framework translates the previous BQL query to the following SQL statement. In this SQL query, {{[parameter]}} is the value of the {{product.CategoryCD}} variable at the moment the <tt>Select()</tt> method is invoked; {{[list of columns]}} is the list of columns of the {{Category}} table.{{{{SET @P0 = [parameter] 

SELECT * FROM Category
WHERE Category.CategoryCD = @P0
}}}}[anchor|#_d7c6b065-deb9-45ec-8927-96d38075596c]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))[anchor|#_cc3c4e58-b049-4351-b3c6-ebd9e62a350d]
==To Pass Multiple Field Values to the SQL Query==
To pass multiple values to the SQL query, use multiple <tt>Required</tt> parameters in the BQL statement and specify the needed values as the <tt>Select()</tt> method arguments in the order in which the parameters are specified in the BQL statement. The number of <tt>Required</tt> parameters must match the number of parameters passed to the <tt>Select()</tt> function. {br}

((({S:Hint}The <tt>Required</tt> parameters should be used in only the BQL statements that are executed in the application code. 
))){br}

The following code shows an example of a BQL statement with two <tt>Required</tt> parameters.<source lang="csharp">// Suppose an event handler related to the DocTransaction DAC
// is being executed
DocTransaction line = (DocTransaction)e.Row;
...
Document doc =
    PXSelect&lt;Document,
        Where&lt;Document.docNbr, Equal&lt;Required&lt;DocTransaction.docNbr&gt;,
            And&lt;Document.docType, Equal&lt;Required&lt;DocTransaction.docType&gt;&gt;&gt;&gt;&gt;
    .Select(this, line.DocNbr, line.DocType);</source>((({S:Hint} Acumatica Framework translates the previous BQL query to the following SQL statement, where {{[list of columns]}} is the list of columns of the {{Document}} table. {{{{SET @P0 = [line.DocNbr value]
SET @P1 = [line.DocType value]

SELECT * FROM Document
WHERE Document.DocNbr = @P0
    AND Document.DocType = @P1
}}}}[anchor|#_661902ba-785e-4064-bf33-ec3c16728713]
 Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))[anchor|#_4473b629-e9a7-4f41-9041-c0442303d2be]
==To Provide External Presentation of the Field Value to the SQL Query==
To substitute the value in the SQL query, do the following:[anchor|#_b37d7823-a6d2-4838-8d82-0ef40e364a36]
#Add the <tt>PXSelector</tt> attribute with a substitute key to a DAC field, as shown in the following example.<source lang="csharp">[PXSelector(typeof(Search&lt;Product.productID&gt;),
            new Type [] {
                    typeof(Product.productCD),
                    typeof(Product.productName)
            },
            SubstituteKey = typeof(Product.productCD))]
public virtual int? ProductID { get; set; }</source>
#:In this example, <tt>PXSelector</tt> replaces the <tt>ProductID</tt> field in the user interface with the human-readable <tt>ProductCD</tt> field. In the UI control for this field, the user enters a <tt>ProductCD</tt> value. The <tt>PXSelector</tt> attribute implements the <tt>FieldUpdating</tt> event handler, which replaces the <tt>ProductCD</tt> value with the corresponding <tt>ProductID</tt> value. 
#Use the <tt>Optional</tt> parameter to select records by the external presentation of the field value, as shown in the following code for <tt>OrderDetail</tt> records.<source lang="csharp">// Product data record obtained
Product p = ...
// Selecting OrderDetail records: ProductCD value is passed
// to the Select() method.
PXSelect&lt;OrderDetail,
    Where&lt;OrderDetail.ProductID, Equal&lt;Optional&lt;OrderDetail.ProductID&gt;&gt;&gt;&gt;
        .Select(this, p.ProductCD);</source>
#In the <tt>Select()</tt> method, provide values for all <tt>Optional</tt>, <tt>Required</tt>, and <tt>Argument</tt> parameters up to the last <tt>Required</tt> or <tt>Argument</tt> parameter in the BQL statement, as shown in the following sample code. <source lang="csharp">// Related OrderDetail and Product records obtained
OrderDetail od = ...
Product p = ...

// At least three values (in addition to graph reference) must
// be passed to the Select() method below.
// The second Optional parameter here will be replaced with the
// default UnitPrice value.
PXResultset&lt;OrderDetail&gt; details =
   PXSelect&lt;OrderDetail,
      Where&lt;OrderDetail.productID, Equal&lt;Optional&lt;OrderDetail.productID&gt;&gt;,
          And&lt;OrderDetail.extPrice, Less&lt;Required&lt;OrderDetail.extPrice&gt;&gt;,
          And&lt;OrderDetail.unitPrice, Greater&lt;Required&lt;OrderDetail.unitPrice&gt;&gt;,
          And&lt;OrderDetail.taxRate, Equal&lt;Optional&lt;OrderDetail.taxRate&gt;&gt;&gt;&gt;&gt;&gt;&gt;
      .Select(this, p.ProductCD, od.ExtPrice, od.UnitPrice);</source>
#:((({S:Hint}Acumatica Framework translates the BQL query in the code to the following SQL statement, where {{[list of columns]}} is the list of columns of the {{OrderDetail}} table. {{{{SET @P0 = [line.ProductID value or default]
SET @P1 = [line.ExtPrice value]
SET @P2 = [line.UnitPrice value]
SET @P3 = [Default TaxRate value]

SELECT [list of columns] FROM OrderDetail
WHERE OrderDetail.ProductID = @P0
    AND OrderDetail.ExtPrice &lt; @P1
    AND OrderDetail.UnitPrice &gt; @P2
    AND OrderDetail.TaxRate = @P3
}}}}[anchor|#_fde8ed23-efd4-4318-a124-6e37aba1e21d] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
[anchor|#_1f3bef64-92a7-469f-9fd2-89f0910565fe]
==To Pass a Value from a UI Control to a Data View==
To pass a value from a UI control to a data view, do the following:[anchor|#_bd92083d-f390-47ff-89aa-27215c2c0dfd]
#Define the <tt>PXSelect</tt> data view with the <tt>Argument</tt> parameter whose type parameter specifies the data type of the expected value, as shown in the following sample BQL query.<source lang="csharp">PXSelect&lt;TreeViewItem,
    Where&lt;TreeViewItem.parentID, Equal&lt;Argument&lt;int?&gt;&gt;&gt;,
    OrderBy&lt;Asc&lt;TreeViewItem.parentID&gt;&gt;&gt; GridDataSource;</source>
#:((({S:Hint}Acumatica Framework translates the previous BQL query to the following SQL statement. In this SQL query, {{[parameter]}} will contain the value received from the UI control and passed to the <tt>Select()</tt> method; {{[list of columns]}} is the list of columns of the {{TreeViewItem}} table.{{{{SET @P0 = [parameter]

SELECT [list of columns] FROM TreeViewItem
WHERE TreeViewItem.ParentID = @P0
ORDER BY TreeViewItem.ParentID
}}}}[anchor|#_25cd0e39-6afc-4010-a484-b7e8694aa160] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))
#Define the data view delegate with the parameters through which you can access the values passed from the UI. (You can find more information on how to use data view delegates in [HelpRoot_Dev_Platform\AD__how_Execute_BQL_Statement|To Execute BQL Statements].)
#:((({S:Hint}When a BQL statement with the <tt>Argument</tt> parameter is executed in code, the value must be specified in the parameters of the <tt>Select()</tt> method.
)))

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Parameters|Parameters in Traditional BQL Statements]
*[HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c19bd9db-77fe-b066-d303-5264bf213410|Current&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1dac11b6-9a2a-7344-ec63-3c934063e70f|Current2&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ea358533-f102-21d0-d4b5-cc4795a3cbc0|Required&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=97688c34-9fef-b1b3-b3c9-b9303568ffc5|Optional&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5d5ef7c0-cf1c-4ff6-b691-ccb44c7714d9|Optional2&lt;Field&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=21827d74-245c-e10a-0a73-9e9cbcdd1260|Argument&lt;ArgumentType&gt; Class]]]></column>
			<column name="PlainText"><![CDATA[To Use Parameters in Traditional BQL You may need to use BQL parameters if you need to relate data views to each other, to pass         field values to the SQL query, to pass the external presentations of the values to the SQL         query, or to pass values from UI controls to the SQL query. For more information on the BQL         parameters, see  Parameters in Traditional BQL Statements. To Relate Data Views to One Another To relate data views to one another, use the  Current  parameter, as shown         in the following sample         code. // The view declarations in a graph
PXSelect<Document> Documents;
PXSelect<DocTransaction,
    Where<DocTransaction.docNbr, Equal<Current<Document.docNbr>>,
        And<DocTransaction.docType, Equal<Current<Document.docType>>>>>
            DocTransactions; In this code, there is a many-to-one relationship between the            DocTransaction  and  Document  data access classes         (DACs), and this relationship is implemented through the  DocNbr  and            DocType  key fields. The views in the code connect the            Document  and  DocTransaction  records. Acumatica Framework translates the BQL query of the second view in the sample BQL code to the following SQL           statement. In this SQL query,  [parameter1]  is the              DocNbr  value and  [parameter2]  is the              DocType  value taken from the  Current  property of           the  DocTransaction  cache;  [list of columns]  is the           list of columns of the  DocTransaction              table. SET @P0 = [parameter1] 
SET @P1 = [parameter2]

SELECT * FROM DocTransaction
WHERE DocTransaction.DocNbr = @P0
    AND DocTransaction.DocType = @P1  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Pass a Field Value to the SQL Query To pass a specific value to the SQL query, use the  Required  parameter in         the BQL statement and specify the needed value as the  Select()  method         argument. The value passed to  Select()  must be of the same type as the         type of the specified field. The  Required  parameter should be used only in the BQL statements           that are directly executed in the application code. The data views that are queried from           the UI will not work if they contain  Required  parameters. The code below shows the execution of a BQL statement with the  Required          parameter. // Suppose an event handler related to the Product DAC
// is being executed
Product product = (Product)e.Row;

// Select the Category record with the specified CategoryCD
Category category =
    PXSelect<Category,
        Where<Category.categoryCD, Equal<Required<Category.categoryCD>>>>
        .Select(this, product.CategoryCD);  Acumatica Framework         translates the previous BQL query to the following SQL statement. In this SQL query,            [parameter]  is the value of the  product.CategoryCD          variable at the moment the  Select()  method is invoked;  [list of           columns]  is the list of columns of the  Category            table. SET @P0 = [parameter] 

SELECT * FROM Category
WHERE Category.CategoryCD = @P0  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Pass Multiple Field Values to the SQL Query To pass multiple values to the SQL query, use multiple  Required          parameters in the BQL statement and specify the needed values as the            Select()  method arguments in the order in which the parameters are         specified in the BQL statement. The number of  Required  parameters must         match the number of parameters passed to the  Select()  function.  The  Required  parameters should be used in only the BQL statements           that are executed in the application code.  The following code shows an example of a BQL statement with two  Required          parameters. // Suppose an event handler related to the DocTransaction DAC
// is being executed
DocTransaction line = (DocTransaction)e.Row;
...
Document doc =
    PXSelect<Document,
        Where<Document.docNbr, Equal<Required<DocTransaction.docNbr>,
            And<Document.docType, Equal<Required<DocTransaction.docType>>>>>
    .Select(this, line.DocNbr, line.DocType);  Acumatica Framework         translates the previous BQL query to the following SQL statement, where  [list of           columns]  is the list of columns of the  Document  table.            SET @P0 = [line.DocNbr value]
SET @P1 = [line.DocType value]

SELECT * FROM Document
WHERE Document.DocNbr = @P0
    AND Document.DocType = @P1  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Provide External Presentation of the Field Value to the SQL Query To substitute the value in the SQL query, do the following: Add the  PXSelector  attribute with a substitute key to a DAC field,             as shown in the following               example. [PXSelector(typeof(Search<Product.productID>),
            new Type [] {
                    typeof(Product.productCD),
                    typeof(Product.productName)
            },
            SubstituteKey = typeof(Product.productCD))]
public virtual int? ProductID { get; set; } In               this example,  PXSelector  replaces the  ProductID                field in the user interface with the human-readable  ProductCD                field. In the UI control for this field, the user enters a                  ProductCD  value. The  PXSelector  attribute               implements the  FieldUpdating  event handler, which replaces the                  ProductCD  value with the corresponding                  ProductID  value.  Use the  Optional  parameter to select records by the external             presentation of the field value, as shown in the following code for                OrderDetail              records. // Product data record obtained
Product p = ...
// Selecting OrderDetail records: ProductCD value is passed
// to the Select() method.
PXSelect<OrderDetail,
    Where<OrderDetail.ProductID, Equal<Optional<OrderDetail.ProductID>>>>
        .Select(this, p.ProductCD); In the  Select()  method, provide values for all                Optional ,  Required , and                Argument  parameters up to the last  Required  or                Argument  parameter in the BQL statement, as shown in the following             sample code.                  // Related OrderDetail and Product records obtained
OrderDetail od = ...
Product p = ...

// At least three values (in addition to graph reference) must
// be passed to the Select() method below.
// The second Optional parameter here will be replaced with the
// default UnitPrice value.
PXResultset<OrderDetail> details =
   PXSelect<OrderDetail,
      Where<OrderDetail.productID, Equal<Optional<OrderDetail.productID>>,
          And<OrderDetail.extPrice, Less<Required<OrderDetail.extPrice>>,
          And<OrderDetail.unitPrice, Greater<Required<OrderDetail.unitPrice>>,
          And<OrderDetail.taxRate, Equal<Optional<OrderDetail.taxRate>>>>>>>
      .Select(this, p.ProductCD, od.ExtPrice, od.UnitPrice); Acumatica Framework translates the BQL query in the code to the following SQL statement, where                  [list of columns]  is the list of columns of the                  OrderDetail  table.                  SET @P0 = [line.ProductID value or default]
SET @P1 = [line.ExtPrice value]
SET @P2 = [line.UnitPrice value]
SET @P3 = [Default TaxRate value]

SELECT [list of columns] FROM OrderDetail
WHERE OrderDetail.ProductID = @P0
    AND OrderDetail.ExtPrice < @P1
    AND OrderDetail.UnitPrice > @P2
    AND OrderDetail.TaxRate = @P3  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. To Pass a Value from a UI Control to a Data View To pass a value from a UI control to a data view, do the following: Define the  PXSelect  data view with the  Argument              parameter whose type parameter specifies the data type of the expected value, as shown             in the following sample BQL                 query. PXSelect<TreeViewItem,
    Where<TreeViewItem.parentID, Equal<Argument<int?>>>,
    OrderBy<Asc<TreeViewItem.parentID>>> GridDataSource; Acumatica Framework translates the previous BQL query to the following SQL statement. In this SQL               query,  [parameter]  will contain the value received from the UI               control and passed to the  Select()  method;  [list of                 columns]  is the list of columns of the  TreeViewItem                  table. SET @P0 = [parameter]

SELECT [list of columns] FROM TreeViewItem
WHERE TreeViewItem.ParentID = @P0
ORDER BY TreeViewItem.ParentID  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. Define the data view delegate with the parameters through which you can access the             values passed from the UI. (You can find more information on how to use data view             delegates in  To Execute BQL Statements.) When a BQL statement with the  Argument  parameter is               executed in code, the value must be specified in the parameters of the                  Select()  method. Current<Field> Class Current2<Field> Class Required<Field> Class Optional<Field> Class Optional2<Field> Class Argument<ArgumentType> Class ]]></column>
		</row>
		<row PageID="82cf157e-97f8-42d6-85f9-3774c7ff13ef" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="dd82a34d-7f3a-e8a8-08a0-cf8958b5c467" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Arithmetic operations—such as {{Add<Operand1, Operand2>}}, {{Sub<Operand1, Operand2>}}, {{Mult<Operand1, Operand2>}}, {{Div<Operand1, Operand2>}}, and {{Minus<Operand>}}—are used primarily in attributes to calculate the value of a field from other fields. Arithmetic operations can also be used as operands in <tt>Where</tt> and <tt>OrderBy</tt> clauses in business query language (BQL) statements.{br}{TOC}
==To Use Arithmetic Operations in Attributes==
To calculate an expression in an attribute, do the following:[anchor|#_8e252edc-0358-43a3-8771-5db29bae7e35]
#Compose the expression by using arithmetic operations. For example, you can calculate product reorder discrepancy by using the following BQL expression, where the <tt>decimal&#95;0</tt> constant represents the 0 decimal value. <tt>IsNull</tt> returns the first argument if it is not null or the second argument otherwise.<source lang="csharp">Minus&lt;
    Sub&lt;Sub&lt;IsNull&lt;Product.availQty, decimal_0&gt;, 
            IsNull&lt;Product.bookedQty, decimal_0&gt;&gt;, 
        Product.minAvailQty&gt;&gt;</source>
#:((({S:Hint}Acumatica Framework translates the previous BQL statement to the following SQL query.{{{{ -((ISNULL(Product.AvailQty, .0) - ISNULL(Product.BookedQty, .0))
    - Product.MinAvailQty)
}}}}
)))
#Use the calculated expression in an attribute (such as <tt>PXDBCalced</tt>) to define a calculated field that is not bound to a database column, as shown in the following sample code.<source lang="csharp">// Data field definition in a DAC
[PXDecimal(2)]
[PXDBCalced(typeof(Minus&lt;
                       Sub&lt;Sub&lt;IsNull&lt;Product.availQty, decimal_0&gt;, 
                               IsNull&lt;Product.bookedQty, decimal_0&gt;&gt;, 
                           Product.minAvailQty&gt;&gt;),
            typeof(Decimal))]
public virtual decimal? Discrepancy { get; set; }</source>

==To Use Arithmetic Operations in BQL Statements==
To use arithmetic operations in a conditional expression in a BQL statement, do the following:[anchor|#_d5522ba7-0761-4f06-bb90-bccbebbe263a]
#Compose the expression by using arithmetic operations. For example, you can calculate product reorder discrepancy by using the following BQL expression, where the <tt>decimal&#95;0</tt> constant represents the 0 decimal value. <tt>IsNull</tt> returns the first argument if it is not null or the second argument otherwise.<source lang="csharp">Minus&lt;
    Sub&lt;Sub&lt;IsNull&lt;Product.availQty, decimal_0&gt;, 
            IsNull&lt;Product.bookedQty, decimal_0&gt;&gt;, 
        Product.minAvailQty&gt;&gt;</source>
#:((({S:Hint}Acumatica Framework translates the previous BQL statement to the following SQL query.{{{{ -((ISNULL(Product.AvailQty, .0) - ISNULL(Product.BookedQty, .0))
    - Product.MinAvailQty)
}}}}
)))
#Use the calculated expression in a BQL statement, as shown in the following example.<source lang="csharp">PXSelect&lt;Product,
    Where&lt;Minus&lt;
              Sub&lt;Sub&lt;IsNull&lt;Product.availQty, decimal_0&gt;, 
                      IsNull&lt;Product.bookedQty, decimal_0&gt;&gt;, 
                  Product.minAvailQty&gt;&gt;,
          NotEqual&lt;decimal_0&gt;&gt;&gt;</source>
#:((({S:Hint}Acumatica Framework translates the previous BQL statement to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table. {{{{SELECT [list of columns] FROM Product
WHERE -((ISNULL(Product.AvailQty, .0) - ISNULL(Product.BookedQty, .0))
        - Product.MinAvailQty) &lt;&gt; .0
}}}}[anchor|#_035c783d-e1f4-4ff9-8888-839c2898a2b6] Acumatica Framework explicitly enumerates the columns of the database table in the SQL query. For details on which columns are enumerated, see [HelpRoot_Dev_Platform\AD__con_BQL_Translation_to_SQL|Translation of a BQL Command to SQL].
)))

==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=48ad54c9-08d9-e528-69e2-c86697438ce4|Add&lt;Operand1,Operand2&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8b9c612e-4384-79a6-b803-efddb83dc839|Sub&lt;Operand1,Operand2&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=157dfccb-ff63-b322-954b-35bc4f71016c|Mult&lt;Operand1,Operand2&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=272c6239-3e42-328f-29a0-2d56a3db41b0|Div&lt;Operand1,Operand2&gt; Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9c92f90d-bbdb-b127-38dc-597ab757c0d7|Minus&lt;Operand&gt; Class]]]></column>
			<column name="PlainText"><![CDATA[To Use Arithmetic Operations Arithmetic operations—such as  Add<Operand1, Operand2> ,            Sub<Operand1, Operand2> ,  Mult<Operand1, Operand2> ,            Div<Operand1, Operand2> , and          Minus<Operand> —are used primarily in attributes to calculate the         value of a field from other fields. Arithmetic operations can also be used as operands in            Where  and  OrderBy  clauses in business query language         (BQL) statements. To Use Arithmetic Operations in Attributes To calculate an expression in an attribute, do the following: Compose the expression by using arithmetic operations. For example, you can calculate             product reorder discrepancy by using the following BQL expression, where the                decimal_0  constant represents the 0 decimal value.                IsNull  returns the first argument if it is not null or the second             argument                 otherwise. Minus<
    Sub<Sub<IsNull<Product.availQty, decimal_0>, 
            IsNull<Product.bookedQty, decimal_0>>, 
        Product.minAvailQty>> Acumatica Framework translates the previous BQL statement to the following SQL               query.  -((ISNULL(Product.AvailQty, .0) - ISNULL(Product.BookedQty, .0))
    - Product.MinAvailQty) Use the calculated expression in an attribute (such as  PXDBCalced )             to define a calculated field that is not bound to a database column, as shown in the             following sample             code. // Data field definition in a DAC
[PXDecimal(2)]
[PXDBCalced(typeof(Minus<
                       Sub<Sub<IsNull<Product.availQty, decimal_0>, 
                               IsNull<Product.bookedQty, decimal_0>>, 
                           Product.minAvailQty>>),
            typeof(Decimal))]
public virtual decimal? Discrepancy { get; set; } To Use Arithmetic Operations in BQL Statements To use arithmetic operations in a conditional expression in a BQL statement, do the           following: Compose the expression by using arithmetic operations. For example, you can calculate             product reorder discrepancy by using the following BQL expression, where the                decimal_0  constant represents the 0 decimal value.                IsNull  returns the first argument if it is not null or the second             argument                 otherwise. Minus<
    Sub<Sub<IsNull<Product.availQty, decimal_0>, 
            IsNull<Product.bookedQty, decimal_0>>, 
        Product.minAvailQty>> Acumatica Framework translates the previous BQL statement to the following SQL               query.  -((ISNULL(Product.AvailQty, .0) - ISNULL(Product.BookedQty, .0))
    - Product.MinAvailQty) Use the calculated expression in a BQL statement, as shown in the following                 example. PXSelect<Product,
    Where<Minus<
              Sub<Sub<IsNull<Product.availQty, decimal_0>, 
                      IsNull<Product.bookedQty, decimal_0>>, 
                  Product.minAvailQty>>,
          NotEqual<decimal_0>>> Acumatica Framework translates the previous BQL statement to the following SQL query, where                  [list of columns]  is the list of columns of the                  Product  table.                  SELECT [list of columns] FROM Product
WHERE -((ISNULL(Product.AvailQty, .0) - ISNULL(Product.BookedQty, .0))
        - Product.MinAvailQty) <> .0  Acumatica Framework             explicitly enumerates the columns of the database table in the SQL query.             For details on which columns are enumerated, see  Translation of a BQL Command to SQL. Add<Operand1,Operand2> Class Sub<Operand1,Operand2> Class Mult<Operand1,Operand2> Class Div<Operand1,Operand2> Class Minus<Operand> Class ]]></column>
		</row>
		<row PageID="0c3be5f8-d333-4080-9180-f610b0f14757" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="0fdf2680-8da5-9e2d-1979-e5185d94c86a" RecordSourceID="22377">
			<column name="Content"><![CDATA[If you are familiar with the construction of SQL statements, you may want to first construct an SQL statement and then translate it to business query language (BQL). You can follow the instructions described in this topic to translate SQL statements to BQL statements.
==To Translate an SQL Statement to BQL==
To translate an SQL statement to BQL, do the following:[anchor|#_983f846c-4cd8-4d8a-a84a-6a0e99e56fbf]
#Construct an SQL statement that selects the data you need. 
#:For example, suppose that you need to convert to BQL the following SQL statement. In this SQL query, we use the {{*}} sign to indicate that all columns of the <tt>Product</tt> table should be selected.{{{{SELECT * FROM Product
INNER JOIN SupplierProduct
    ON SupplierProduct.ProductID = Product.ProductID
INNER JOIN Supplier
    ON Supplier.AccountID = SupplierProduct.AccountID
WHERE (Product.BookedQty IS NOT NULL
       AND Product.AvailQty IS NOT NULL
       AND Product.MinAvailQty IS NOT NULL
       AND(Product.Active = 1
           OR Product.Active IS NULL)
       AND(Product.BookedQty &gt; Product.AvailQty
           OR Product.AvailQty &lt; Product.MinAvailQty))
    OR Product.AvailQty IS NOT NULL
ORDER BY Product.UnitPrice, Product.AvailQty DESC
}}}}
#Replace the names of columns with the names of class fields that correspond to the columns in data access classes (DACs). That is, change the uppercase letter in the name of each column to the lowercase, as shown in the following sample code. In this sample code, the changes are shown in bold type.{{{{SELECT * FROM Product
INNER JOIN SupplierProduct
    ON SupplierProduct.'''productID''' = Product.'''productID'''
INNER JOIN Supplier
    ON Supplier.'''accountID''' = SupplierProduct.'''accountID'''
WHERE (Product.'''bookedQty''' IS NOT NULL
       AND Product.'''availQty''' IS NOT NULL
       AND Product.'''minAvailQty''' IS NOT NULL
       AND(Product.'''active''' = 1
           OR Product.'''active''' IS NULL)
       AND(Product.'''bookedQty''' &gt; Product.'''availQty'''
           OR Product.'''availQty''' &lt; Product.'''minAvailQty'''))
    OR Product.'''availQty''' IS NOT NULL
ORDER BY Product.unitPrice, Product.availQty DESC
}}}}
#If your SQL statement contains constants, replace it with either one of the predefined constants or your own constant. (For details on using constants, see [HelpRoot_Dev_Platform\AD__how_BQL_Filter#_32d3d633-c741-4cc3-8f49-f4a611f164cb|To Compare a Field with a Constant] and the description of the [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6c4b075f-4754-acec-645a-9ca461d49010|<tt>Constant&lt;ConstType&gt;</tt>] class.) If you need to change the values of the constants at runtime, replace the constants with parameters, as described in [HelpRoot_Dev_Platform\AD__how_BQL_Parameters|To Use Parameters in Traditional BQL].
#Find the {{JOIN}}, {{WHERE}}, {{GROUP BY}}, and {{ORDER BY}} clauses that you have in the SQL statement. Depending on the included clauses, select one of the <tt>PXSelect</tt> classes, and replace {{SELECT * FROM}} with this class in your SQL statement. For details on selection of the <tt>PXSelect</tt> class, see [HelpRoot_Dev_Platform\AD__how_Construct_Statement|To Select Records By Using Traditional BQL]. For the list of all <tt>PXSelect</tt> classes, see [HelpRoot_Dev_Platform\AD__con_BQL_PXSelect|PXSelect Classes].
#:In the sample code that has been presented in this topic, you would use the <tt>PXSelectJoin&lt;Table, Join, Where, OrderBy&gt;</tt> class, and you would change the sample code as follows. (The changes are shown in bold type.){{{{'''PXSelectJoin&lt;Product,'''
INNER JOIN SupplierProduct
    ON SupplierProduct.productID = Product.productID
INNER JOIN Supplier
    ON Supplier.accountID = SupplierProduct.accountID''','''
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty &gt; Product.availQty
           OR Product.availQty &lt; Product.minAvailQty))
    OR Product.availQty IS NOT NULL''','''
ORDER BY Product.unitPrice, Product.availQty DESC'''&gt;'''
}}}}
#If your SQL statement includes {{JOIN}} clauses, do the following:
##Replace the last {{JOIN}} clause with the corresponding BQL <tt>Join</tt> clause. You would change the sample code of this topic as follows. (The changes are shown in bold type.){{{{PXSelectJoin&lt;Product,
INNER JOIN SupplierProduct
    ON SupplierProduct.productID = Product.productID
'''InnerJoin&lt;'''Supplier''','''
    ON Supplier.accountID = SupplierProduct.accountID'''&gt;''',
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty &gt; Product.availQty
           OR Product.availQty &lt; Product.minAvailQty))
    OR Product.availQty IS NOT NULL,
ORDER BY Product.unitPrice, Product.availQty DESC&gt;
}}}}
##Chain other {{JOIN}} clauses to one another, as described in [HelpRoot_Dev_Platform\AD__how_Query_Multiple_Tables|To Query Multiple Tables]. You would change the sample code of this topic as follows. (The changes are shown in bold type.){{{{PXSelectJoin&lt;Product,
'''InnerJoin&lt;'''SupplierProduct''','''
    ON SupplierProduct.productID = Product.productID''','''
InnerJoin&lt;Supplier,
    ON Supplier.accountID = SupplierProduct.accountID&gt;'''&gt;''',
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty &gt; Product.availQty
           OR Product.availQty &lt; Product.minAvailQty))
    OR Product.availQty IS NOT NULL,
ORDER BY Product.unitPrice, Product.availQty DESC&gt;
}}}}
##Replace each {{ON}} clause, as follows:
##*For a single condition or groups that start with a simple condition, replace the {{ON}} clause with <tt>On</tt>. 
##*For groups that start with a group of conditions, replace the {{ON}} clause with <tt>On2</tt>. 
##:With these replacements, the sample code used in this topic would be changed to the following code. (The changes are shown in bold type.){{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    '''On&lt;'''SupplierProduct.productID = Product.productID'''&gt;''',
InnerJoin&lt;Supplier,
    '''On&lt;'''Supplier.accountID = SupplierProduct.accountID'''&gt;'''&gt;&gt;,
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty &gt; Product.availQty
           OR Product.availQty &lt; Product.minAvailQty))
    OR Product.availQty IS NOT NULL,
ORDER BY Product.unitPrice, Product.availQty DESC&gt;
}}}}
#If your SQL statement includes a {{WHERE}} clause, replace the {{WHERE}} clause and each pair of parentheses that encloses each group of conditions in the {{WHERE}} clause with a <tt>Where</tt>, <tt>Where2</tt>, <tt>Not</tt>, or <tt>Not2</tt> clause, as follows:
#*<tt>Where</tt> is used for groups that start with a simple condition. 
#*<tt>Not</tt> is used for groups that start with a simple condition but are preceded with the logical {{NOT}}.
#*<tt>Where2</tt> is used for groups that start with a group of conditions. 
#*<tt>Not2</tt> is used for groups that start with a group of conditions but preceded with the logical {{NOT}}.
#:With these replacements, the sample code used in this topic would be changed to the following code. (The changes are shown in bold type.){{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    On&lt;SupplierProduct.productID = Product.productID&gt;,
InnerJoin&lt;Supplier,
    On&lt;Supplier.accountID = SupplierProduct.accountID&gt;&gt;&gt;,
'''Where2&lt;''' '''Where&lt;'''Product.bookedQty''',''' IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND '''Where&lt;'''Product.active = 1''','''
           OR Product.active IS NULL'''&gt;'''
       AND '''Where&lt;'''Product.bookedQty &gt; Product.availQty''','''
           OR Product.availQty &lt; Product.minAvailQty'''&gt;''' '''&gt;''' ''','''
    OR Product.availQty IS NOT NULL'''&gt;''',
OrderBy&lt;Asc&lt;Product.unitPrice, Desc&lt;Product.availQty&gt;&gt;&gt;&gt;
}}}}
#In each BQL <tt>Where</tt> or <tt>On</tt> clause, replace the logical operators (either {{AND}} or {{OR}}) to <tt>And</tt>, <tt>Or</tt>, <tt>And2</tt>, or <tt>Or2</tt>, as follows:
##Replace the last {{AND}} or {{OR}} in each BQL <tt>Where</tt> or <tt>On</tt> clause with the <tt>And</tt> or <tt>Or</tt> operator, respectively, as shown in the following code. (The changes are shown in bold type.){{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    On&lt;SupplierProduct.productID = Product.productID&gt;,
InnerJoin&lt;Supplier,
    On&lt;Supplier.accountID = SupplierProduct.accountID&gt;&gt;&gt;,
Where2&lt;Where&lt;Product.bookedQty, IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND Where&lt;Product.active = 1,
           '''Or&lt;'''Product.active IS NULL'''&gt;'''&gt;
       '''And&lt;'''Where&lt;Product.bookedQty &gt; Product.availQty,
           '''Or&lt;'''Product.availQty &lt; Product.minAvailQty'''&gt;'''&gt;'''&gt;'''&gt;,
    '''Or&lt;'''Product.availQty IS NOT NULL'''&gt;'''&gt;,
OrderBy&lt;Asc&lt;Product.unitPrice, Desc&lt;Product.availQty&gt;&gt;&gt;&gt;
}}}}
##In each BQL <tt>Where</tt> or <tt>On</tt> clause, if the {{AND}} or {{OR}} is located before a simple condition, replace it with <tt>And</tt> or <tt>Or</tt>, respectively. If the condition is preceded by {{NOT}}, wrap it in <tt>Not</tt>. With these replacements, the sample code used in this topic would be changed to the following code. (The changes are shown in bold type.){{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    On&lt;SupplierProduct.productID = Product.productID&gt;,
InnerJoin&lt;Supplier,
    On&lt;Supplier.accountID = SupplierProduct.accountID&gt;&gt;&gt;,
Where2&lt;Where&lt;Product.bookedQty, IS NOT NULL,
       '''And&lt;'''Product.availQty IS NOT NULL''',''' '''And&lt;'''Product.minAvailQty IS NOT NULL''','''
       AND Where&lt;Product.active = 1,
           Or&lt;Product.active IS NULL&gt;&gt;
       And&lt;Where&lt;Product.bookedQty &gt; Product.availQty,
           Or&lt;Product.availQty &lt; Product.minAvailQty&gt;&gt;&gt;'''&gt;''' '''&gt;'''&gt;,
    Or&lt;Product.availQty IS NOT NULL&gt;&gt;,
OrderBy&lt;Asc&lt;Product.unitPrice, Desc&lt;Product.availQty&gt;&gt;&gt;&gt;
}}}}
##In each BQL <tt>Where</tt> or <tt>On</tt> clause, if the {{AND}} or {{OR}} is located before a group of conditions, replace it with <tt>And2&lt;Operator, NextOperator&gt;</tt> or <tt>Or2&lt;Operator, NextOperator&gt;</tt>, respectively. The first parameter in a logical operator is <tt>Where</tt> (or <tt>Where2</tt>). If the condition is preceded by {{NOT}}, place {{Not}} before a group in a <tt>Where</tt> clause. The following sample code implements these changes (shown in bold type).{{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    On&lt;SupplierProduct.productID = Product.productID&gt;,
InnerJoin&lt;Supplier,
    On&lt;Supplier.accountID = SupplierProduct.accountID&gt;&gt;&gt;,
Where2&lt;Where&lt;Product.bookedQty, IS NOT NULL,
       And&lt;Product.availQty IS NOT NULL,
       And&lt;Product.minAvailQty IS NOT NULL,
       '''And2&lt;'''Where&lt;Product.active = 1,
           Or&lt;Product.active IS NULL&gt;&gt;,
       And&lt;Where&lt;Product.bookedQty &gt; Product.availQty,
           Or&lt;Product.availQty &lt; Product.minAvailQty&gt;&gt;&gt;'''&gt;'''&gt;&gt;&gt;,
    Or&lt;Product.availQty IS NOT NULL&gt;&gt;,
OrderBy&lt;Asc&lt;Product.unitPrice, Desc&lt;Product.availQty&gt;&gt;&gt;&gt;
}}}}
#In each <tt>Where</tt> or <tt>On</tt> clause, replace the groups that use arithmetic operations with the corresponding BQL operators, as described in [HelpRoot_Dev_Platform\AD__how_BQL_Functions|To Use Arithmetic Operations].
#In each <tt>Where</tt> or <tt>On</tt> clause, replace each comparison with the corresponding comparison operator, such as <tt>Equal</tt>, <tt>Greater</tt>, or <tt>IsNull</tt>. For more information on constructing comparisons, see [HelpRoot_Dev_Platform\AD__how_BQL_Filter|To Filter Records].
#:The following sample code includes these changes (shown in bold type).{{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    On&lt;SupplierProduct.productID''', Equal&lt;Product.productID&gt;'''&gt;,
InnerJoin&lt;Supplier,
    On&lt;Supplier.accountID''', Equal&lt;SupplierProduct.accountID&gt;'''&gt;&gt;&gt;,
Where2&lt;Where&lt;Product.bookedQty, '''IsNotNull''',
       And&lt;Product.availQty''', IsNotNull''',
       And&lt;Product.minAvailQty''', IsNotNull''',
       And2&lt;Where&lt;Product.active''', Equal&lt;True&gt;''',
           Or&lt;Product.active''', IsNull'''&gt;&gt;,
       And&lt;Where&lt;Product.bookedQty''', Greater&lt;Product.availQty&gt;''',
           Or&lt;Product.availQty''', Less&lt;Product.minAvailQty&gt;'''&gt;&gt;&gt;&gt;&gt;&gt;&gt;,
    Or&lt;Product.availQty''', IsNotNull'''&gt;&gt;,
OrderBy&lt;Asc&lt;Product.unitPrice, Desc&lt;Product.availQty&gt;&gt;&gt;&gt;
}}}}
#Align logical operators of the same level so that they have the same indentation and so that each simple condition is placed on a separate line. Do not add line breaks before nested <tt>Where</tt> clauses.
#If your SQL statement includes the {{GROUP BY}} clause, do the following:
##Replace the {{GROUP BY}} clause with the <tt>Aggregate</tt> clause. 
##Chain the <tt>GroupBy</tt> clause and aggregation functions (such as <tt>Min</tt>, <tt>Max</tt>, <tt>Sum</tt>, <tt>Avg</tt>, and <tt>Count</tt>) to one another as described in [HelpRoot_Dev_Platform\AD__how_BQL_Group_and_Aggregate|To Group and Aggregate Records]. 
#If your SQL statement includes the {{ORDER BY}} clause, do the following:
##Replace the {{ORDER BY}} clause with the <tt>OrderBy</tt> clause. The following sample code shows this change (with changes shown in bold type).{{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    On&lt;SupplierProduct.productID, Equal&lt;Product.productID&gt;&gt;,
InnerJoin&lt;Supplier,
    On&lt;Supplier.accountID, Equal&lt;SupplierProduct.accountID&gt;&gt;&gt;&gt;,
Where2&lt;Where&lt;Product.bookedQty, IsNotNull,
       And&lt;Product.availQty, IsNotNull,
       And&lt;Product.minAvailQty, IsNotNull,
       And2&lt;Where&lt;Product.active, Equal&lt;True&gt;,
           Or&lt;Product.active, IsNull&gt;&gt;,
       And&lt;Where&lt;Product.bookedQty, Greater&lt;Product.availQty&gt;,
           Or&lt;Product.availQty, Less&lt;Product.minAvailQty&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;,
    Or&lt;Product.availQty, IsNotNull&gt;&gt;,
'''OrderBy&lt;'''Product.unitPrice, Product.availQty DESC'''&gt;'''&gt;
}}}}
##Chain the <tt>Asc</tt> and <tt>Desc</tt> operators to one another, as described in [HelpRoot_Dev_Platform\AD__how_BQL_OrderBy|To Order Records]. The following sample code shows this change (with changes shown in bold type).{{{{PXSelectJoin&lt;Product,
InnerJoin&lt;SupplierProduct,
    On&lt;SupplierProduct.productID, Equal&lt;Product.productID&gt;&gt;,
InnerJoin&lt;Supplier,
    On&lt;Supplier.accountID, Equal&lt;SupplierProduct.accountID&gt;&gt;&gt;&gt;,
Where2&lt;Where&lt;Product.bookedQty, IsNotNull,
       And&lt;Product.availQty, IsNotNull,
       And&lt;Product.minAvailQty, IsNotNull,
       And2&lt;Where&lt;Product.active, Equal&lt;True&gt;,
           Or&lt;Product.active, IsNull&gt;&gt;,
       And&lt;Where&lt;Product.bookedQty, Greater&lt;Product.availQty&gt;,
           Or&lt;Product.availQty, Less&lt;Product.minAvailQty&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;,
    Or&lt;Product.availQty, IsNotNull&gt;&gt;,
OrderBy&lt;'''Asc&lt;'''Product.unitPrice, '''Desc&lt;'''Product.availQty'''&gt;''' '''&gt;'''&gt;&gt;
}}}}
#Check that the final statement is correct by doing the following:
#*Check that all lines except the last line of the BQL statement end with a comma.
#*Ensure that the number of closing angle brackets equals the number of opening angle brackets.

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Correspondence_BQL_SQL|Traditional BQL and SQL Equivalents]]]></column>
			<column name="PlainText"><![CDATA[To Compose a BQL Statement from an SQL Statement If you are familiar with the construction of SQL statements, you may want to first             construct an SQL statement and then translate it to business query language (BQL). You             can follow the instructions described in this topic to translate SQL statements to BQL             statements. To Translate an SQL Statement to BQL To translate an SQL statement to BQL, do the following: Construct an SQL statement that selects the data you need.  For example,                             suppose that you need to convert to BQL the following SQL statement. In                             this SQL query, we use the  *  sign to indicate that all                             columns of the  Product  table should be                             selected. SELECT * FROM Product
INNER JOIN SupplierProduct
    ON SupplierProduct.ProductID = Product.ProductID
INNER JOIN Supplier
    ON Supplier.AccountID = SupplierProduct.AccountID
WHERE (Product.BookedQty IS NOT NULL
       AND Product.AvailQty IS NOT NULL
       AND Product.MinAvailQty IS NOT NULL
       AND(Product.Active = 1
           OR Product.Active IS NULL)
       AND(Product.BookedQty > Product.AvailQty
           OR Product.AvailQty < Product.MinAvailQty))
    OR Product.AvailQty IS NOT NULL
ORDER BY Product.UnitPrice, Product.AvailQty DESC Replace the names of columns with the names of class fields that correspond                         to the columns in data access classes (DACs). That is, change the uppercase                         letter in the name of each column to the lowercase, as shown in the                         following sample code. In this sample code, the changes are shown in bold                         type. SELECT * FROM Product
INNER JOIN SupplierProduct
    ON SupplierProduct. productID  = Product. productID 
INNER JOIN Supplier
    ON Supplier. accountID  = SupplierProduct. accountID 
WHERE (Product. bookedQty  IS NOT NULL
       AND Product. availQty  IS NOT NULL
       AND Product. minAvailQty  IS NOT NULL
       AND(Product. active  = 1
           OR Product. active  IS NULL)
       AND(Product. bookedQty  > Product. availQty 
           OR Product. availQty  < Product. minAvailQty ))
    OR Product. availQty  IS NOT NULL
ORDER BY Product.unitPrice, Product.availQty DESC If your SQL statement contains constants, replace it with either one of the                         predefined constants or your own constant. (For details on using constants,                         see  To Compare a Field with a Constant and the description of the  Constant<ConstType> <tt>Constant&lt;ConstType&gt;</tt> class.) If you                         need to change the values of the constants at runtime, replace the constants                         with parameters, as described in  To Use Parameters in Traditional BQL. Find the  JOIN ,  WHERE ,  GROUP                             BY , and  ORDER BY  clauses that you have in the                         SQL statement. Depending on the included clauses, select one of the                              PXSelect  classes, and replace  SELECT *                             FROM  with this class in your SQL statement. For details on                         selection of the  PXSelect  class, see  To Select Records By Using Traditional BQL. For the list of all  PXSelect  classes, see  PXSelect Classes. In the sample code that has been presented in this topic, you                             would use the  PXSelectJoin<Table, Join, Where,                                 OrderBy>  class, and you would change the sample code as                             follows. (The changes are shown in bold                             type.) PXSelectJoin<Product, 
INNER JOIN SupplierProduct
    ON SupplierProduct.productID = Product.productID
INNER JOIN Supplier
    ON Supplier.accountID = SupplierProduct.accountID , 
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty > Product.availQty
           OR Product.availQty < Product.minAvailQty))
    OR Product.availQty IS NOT NULL , 
ORDER BY Product.unitPrice, Product.availQty DESC > If your SQL statement includes  JOIN  clauses, do the                             following: Replace the last  JOIN  clause with the corresponding                                 BQL  Join  clause. You would change the sample code                                 of this topic as follows. (The changes are shown in bold                                 type.) PXSelectJoin<Product,
INNER JOIN SupplierProduct
    ON SupplierProduct.productID = Product.productID
 InnerJoin< Supplier , 
    ON Supplier.accountID = SupplierProduct.accountID > ,
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty > Product.availQty
           OR Product.availQty < Product.minAvailQty))
    OR Product.availQty IS NOT NULL,
ORDER BY Product.unitPrice, Product.availQty DESC> Chain other  JOIN  clauses to one another, as                                 described in  To Query Multiple Tables. You would change the sample code of this topic as follows. (The                                 changes are shown in bold                                 type.) PXSelectJoin<Product,
 InnerJoin< SupplierProduct , 
    ON SupplierProduct.productID = Product.productID , 
InnerJoin<Supplier,
    ON Supplier.accountID = SupplierProduct.accountID> > ,
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty > Product.availQty
           OR Product.availQty < Product.minAvailQty))
    OR Product.availQty IS NOT NULL,
ORDER BY Product.unitPrice, Product.availQty DESC> Replace each  ON  clause, as follows: For a single condition or groups that start with a simple                                         condition, replace the  ON  clause with                                              On .  For groups that start with a group of conditions, replace                                         the  ON  clause with  On2 .                                      With these replacements, the sample code used in this topic                                     would be changed to the following code. (The changes are shown                                     in bold                                     type.) PXSelectJoin<Product,
InnerJoin<SupplierProduct,
     On< SupplierProduct.productID = Product.productID > ,
InnerJoin<Supplier,
     On< Supplier.accountID = SupplierProduct.accountID > >>,
WHERE (Product.bookedQty IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND(Product.active = 1
           OR Product.active IS NULL)
       AND(Product.bookedQty > Product.availQty
           OR Product.availQty < Product.minAvailQty))
    OR Product.availQty IS NOT NULL,
ORDER BY Product.unitPrice, Product.availQty DESC> If your SQL statement includes a  WHERE  clause, replace the                              WHERE  clause and each pair of parentheses that encloses                         each group of conditions in the  WHERE  clause with a                              Where ,  Where2 ,                              Not , or  Not2  clause, as                             follows: Where  is used for groups that start with a simple                                 condition.  Not  is used for groups that start with a simple                                 condition but are preceded with the logical                                  NOT . Where2  is used for groups that start with a group                                 of conditions.  Not2  is used for groups that start with a group                                 of conditions but preceded with the logical                                  NOT . With these replacements, the sample code used in this topic would be                             changed to the following code. (The changes are shown in bold                             type.) PXSelectJoin<Product,
InnerJoin<SupplierProduct,
    On<SupplierProduct.productID = Product.productID>,
InnerJoin<Supplier,
    On<Supplier.accountID = SupplierProduct.accountID>>>,
 Where2< Where< Product.bookedQty ,  IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND  Where< Product.active = 1 , 
           OR Product.active IS NULL > 
       AND  Where< Product.bookedQty > Product.availQty , 
           OR Product.availQty < Product.minAvailQty > > , 
    OR Product.availQty IS NOT NULL > ,
OrderBy<Asc<Product.unitPrice, Desc<Product.availQty>>>> In each BQL  Where  or  On  clause,                         replace the logical operators (either  AND  or                              OR ) to  And ,  Or ,                              And2 , or  Or2 , as follows: Replace the last  AND  or  OR  in each                                 BQL  Where  or  On  clause with                                 the  And  or  Or  operator,                                 respectively, as shown in the following code. (The changes are shown                                 in bold                                 type.) PXSelectJoin<Product,
InnerJoin<SupplierProduct,
    On<SupplierProduct.productID = Product.productID>,
InnerJoin<Supplier,
    On<Supplier.accountID = SupplierProduct.accountID>>>,
Where2<Where<Product.bookedQty, IS NOT NULL
       AND Product.availQty IS NOT NULL
       AND Product.minAvailQty IS NOT NULL
       AND Where<Product.active = 1,
            Or< Product.active IS NULL > >
        And< Where<Product.bookedQty > Product.availQty,
            Or< Product.availQty < Product.minAvailQty > > > >,
     Or< Product.availQty IS NOT NULL > >,
OrderBy<Asc<Product.unitPrice, Desc<Product.availQty>>>> In each BQL  Where  or  On                                  clause, if the  AND  or  OR  is                                 located before a simple condition, replace it with                                      And  or  Or , respectively.                                 If the condition is preceded by  NOT , wrap it in                                      Not . With these replacements, the sample code                                 used in this topic would be changed to the following code. (The                                 changes are shown in bold                                 type.) PXSelectJoin<Product,
InnerJoin<SupplierProduct,
    On<SupplierProduct.productID = Product.productID>,
InnerJoin<Supplier,
    On<Supplier.accountID = SupplierProduct.accountID>>>,
Where2<Where<Product.bookedQty, IS NOT NULL,
        And< Product.availQty IS NOT NULL , And< Product.minAvailQty IS NOT NULL , 
       AND Where<Product.active = 1,
           Or<Product.active IS NULL>>
       And<Where<Product.bookedQty > Product.availQty,
           Or<Product.availQty < Product.minAvailQty>>> > > >,
    Or<Product.availQty IS NOT NULL>>,
OrderBy<Asc<Product.unitPrice, Desc<Product.availQty>>>> In each BQL  Where  or  On                                  clause, if the  AND  or  OR  is                                 located before a group of conditions, replace it with                                      And2<Operator, NextOperator>  or                                      Or2<Operator, NextOperator> , respectively.                                 The first parameter in a logical operator is                                      Where  (or  Where2 ). If the                                 condition is preceded by  NOT , place                                      Not  before a group in a                                      Where  clause. The following sample code                                 implements these changes (shown in bold                                 type). PXSelectJoin<Product,
InnerJoin<SupplierProduct,
    On<SupplierProduct.productID = Product.productID>,
InnerJoin<Supplier,
    On<Supplier.accountID = SupplierProduct.accountID>>>,
Where2<Where<Product.bookedQty, IS NOT NULL,
       And<Product.availQty IS NOT NULL,
       And<Product.minAvailQty IS NOT NULL,
        And2< Where<Product.active = 1,
           Or<Product.active IS NULL>>,
       And<Where<Product.bookedQty > Product.availQty,
           Or<Product.availQty < Product.minAvailQty>>> > >>>,
    Or<Product.availQty IS NOT NULL>>,
OrderBy<Asc<Product.unitPrice, Desc<Product.availQty>>>> In each  Where  or  On  clause, replace                         the groups that use arithmetic operations with the corresponding BQL                         operators, as described in  To Use Arithmetic Operations. In each  Where  or  On  clause, replace                         each comparison with the corresponding comparison operator, such as                              Equal ,  Greater , or                              IsNull . For more information on constructing                         comparisons, see  To Filter Records. The following sample code includes these changes (shown in bold                             type). PXSelectJoin<Product,
InnerJoin<SupplierProduct,
    On<SupplierProduct.productID , Equal<Product.productID> >,
InnerJoin<Supplier,
    On<Supplier.accountID , Equal<SupplierProduct.accountID> >>>,
Where2<Where<Product.bookedQty,  IsNotNull ,
       And<Product.availQty , IsNotNull ,
       And<Product.minAvailQty , IsNotNull ,
       And2<Where<Product.active , Equal<True> ,
           Or<Product.active , IsNull >>,
       And<Where<Product.bookedQty , Greater<Product.availQty> ,
           Or<Product.availQty , Less<Product.minAvailQty> >>>>>>>,
    Or<Product.availQty , IsNotNull >>,
OrderBy<Asc<Product.unitPrice, Desc<Product.availQty>>>> Align logical operators of the same level so that they have the same                         indentation and so that each simple condition is placed on a separate line.                         Do not add line breaks before nested  Where  clauses. If your SQL statement includes the  GROUP BY  clause, do the                             following: Replace the  GROUP BY  clause with the                                      Aggregate  clause.  Chain the  GroupBy  clause and aggregation                                 functions (such as  Min ,  Max ,                                      Sum ,  Avg , and                                      Count ) to one another as described in  To Group and Aggregate Records.  If your SQL statement includes the  ORDER BY  clause, do the                             following: Replace the  ORDER BY  clause with the                                      OrderBy  clause. The following sample code                                 shows this change (with changes shown in bold                                 type). PXSelectJoin<Product,
InnerJoin<SupplierProduct,
    On<SupplierProduct.productID, Equal<Product.productID>>,
InnerJoin<Supplier,
    On<Supplier.accountID, Equal<SupplierProduct.accountID>>>>,
Where2<Where<Product.bookedQty, IsNotNull,
       And<Product.availQty, IsNotNull,
       And<Product.minAvailQty, IsNotNull,
       And2<Where<Product.active, Equal<True>,
           Or<Product.active, IsNull>>,
       And<Where<Product.bookedQty, Greater<Product.availQty>,
           Or<Product.availQty, Less<Product.minAvailQty>>>>>>>>,
    Or<Product.availQty, IsNotNull>>,
 OrderBy< Product.unitPrice, Product.availQty DESC > > Chain the  Asc  and  Desc                                  operators to one another, as described in  To Order Records. The following sample code shows this change (with changes shown                                 in bold                                 type). PXSelectJoin<Product,
InnerJoin<SupplierProduct,
    On<SupplierProduct.productID, Equal<Product.productID>>,
InnerJoin<Supplier,
    On<Supplier.accountID, Equal<SupplierProduct.accountID>>>>,
Where2<Where<Product.bookedQty, IsNotNull,
       And<Product.availQty, IsNotNull,
       And<Product.minAvailQty, IsNotNull,
       And2<Where<Product.active, Equal<True>,
           Or<Product.active, IsNull>>,
       And<Where<Product.bookedQty, Greater<Product.availQty>,
           Or<Product.availQty, Less<Product.minAvailQty>>>>>>>>,
    Or<Product.availQty, IsNotNull>>,
OrderBy< Asc< Product.unitPrice,  Desc< Product.availQty > > >> Check that the final statement is correct by doing the following: Check that all lines except the last line of the BQL statement end                                 with a comma. Ensure that the number of closing angle brackets equals the number                                 of opening angle brackets. ]]></column>
		</row>
		<row PageID="8f8f3b86-935a-4ba0-bbb8-1e1a01f4ec4f" Language="en-US" PageRevisionID="1" PlainText="Creating LINQ Queries To query data from the database, you can use language-integrated query (LINQ), which is a    part of .NET Framework. In the code of  Acumatica Framework-based    applications, you can use both the standard query operators (provided by LINQ libraries) and the      Acumatica Framework-specific operators that are designed to query database data.  In this chapter, you can find     information on how to create LINQ queries. For the general information about data querying, see       Querying Data in Acumatica Framework.  In This Chapter LINQ in Acumatica FrameworkDeferred LINQ Query ExecutionFallback to the LINQ to Objects ModeTo Select Records by Using LINQTo Append LINQ Expressions to BQL Statements" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="3324a27e-da22-04c4-b079-457a7796cd04" RecordSourceID="22377">
			<column name="Content"><![CDATA[To query data from the database, you can use language-integrated query (LINQ), which is a part of .NET Framework. In the code of Acumatica Framework-based applications, you can use both the standard query operators (provided by LINQ libraries) and the Acumatica Framework-specific operators that are designed to query database data. 
In this chapter, you can find information on how to create LINQ queries. For the general information about data querying, see [HelpRoot_Dev_Platform\AD__mng_Querying_Data|Querying Data in Acumatica Framework]. 
==In This Chapter==[anchor|#_e5997ee2-39b0-4608-a398-44f66e80c097]
{| class="checklist invisiblechecklist" | width="100%" 
|- 
| [anchor|#_93066789-a65a-4bb7-9805-486e06af6175]
*[HelpRoot_Dev_Platform\AD__con_LINQ_in_Acumatica_Framework|LINQ in Acumatica Framework]
*[HelpRoot_Dev_Platform\AD__con_Deferred_LINQ_Query_Execution|Deferred LINQ Query Execution]
*[HelpRoot_Dev_Platform\AD__con_Fallback_to_LINQ2Objects|Fallback to the LINQ to Objects Mode]

| [anchor|#_d3276ca7-2ed8-4591-b7f7-4013682d0055]
*[HelpRoot_Dev_Platform\AD__how_LINQ_Select_Records|To Select Records by Using LINQ]
*[HelpRoot_Dev_Platform\AD__how_LINQ_Filter_BQL|To Append LINQ Expressions to BQL Statements]

|}]]></column>
		</row>
		<row PageID="0964f231-82b9-4b86-bca4-1d26151f8baf" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="429bff7a-5722-67a8-65e6-399bf657c104" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use language-integrated query (LINQ) provided by the {{System.Linq}} library when you need to select records from the database in the code of Acumatica Framework-based applications or if you want to apply additional filtering to the data of a BQL query. However, you still have to use business query language (BQL) to define the data views in graphs and to specify the data queries in attributes of data fields. For details about BQL, see [HelpRoot_Dev_Platform\AD__mng_Fluent_BQL|Creating Fluent BQL Queries] and [HelpRoot_Dev_Platform\AD__mng_Traditional_BQL|Creating Traditional BQL Queries]. For more information about the differences between LINQ and BQL, see [HelpRoot_Dev_Platform\AD__con_Comparison_of_TBQL_FBQL_LINQ|Comparison of Fluent BQL, Traditional BQL, and LINQ].{br}{TOC}
==Data Access Classes in LINQ==
In LINQ expressions, to access data from the database tables, you use data access classes (DACs). For details on DACs, see [HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes]. {br}

You use property fields of DACs when you need to specify table columns in LINQ expressions. (The name of the property field starts with an uppercase letter. Do not confuse it with the class field, which has the same name but starts with lowercase letter.)
==Query Syntax==[anchor|#_771118a5-da49-47ef-943e-cb45274b4693]
To configure a LINQ query, you can use the following variants of syntax:[anchor|#_a6dca6cf-56c4-4e4f-98b5-93ee384e3fb7]
*Query expressions, which use standard query operators from the {{System.Linq}} namespace (such as {{where}} or {{orderby}}) or Acumatica Framework-specific operators from the {{PX.Data.SQLTree}} namespace (such as <tt>SQL.BinaryLen</tt>, which is shown in the following example of this syntax). <source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var goods = from p in graph.Select&lt;Product&gt;()
  where 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0
  select new 
  { 
    p.ProductID, 
    p.ProductCD, 
    p.ProductName, 
    Len = p.ProductName.Length, 
    BLen = SQL.BinaryLen( p.ProductName) + 1, 
    p.GroupMask, 
    p.WorkGroupID 
};</source>
*Explicit (method-based) syntax. The arguments of the methods used in this syntax are lambda expressions. In these expressions, you can use the standard C# operators and Acumatica Framework-specific operators from the {{PX.Data.SQLTree}} namespace (such as <tt>SQL.BinaryLen</tt>, which is shown in the following code). The code below is equivalent to the query expression shown above.<source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var goods = graph.Select&lt;Product&gt;()
  .Where( p =&gt; 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0)
  .Select( p =&gt; new     
    { 
      p.ProductID, 
      p.ProductCD, 
      p.ProductName, 
      Len = p.ProductName.Length, 
      BLen = SQL.BinaryLen(p.ProductName) + 1, 
      p.GroupMask, p.WorkGroupID 
    });</source>
{br}

For details about composing LINQ queries, see [HelpRoot_Dev_Platform\AD__how_LINQ_Select_Records|To Select Records by Using LINQ]. In the code examples of this guide, we use explicit syntax.
==Simultaneous Use of LINQ and BQL==
The <tt>Select</tt> method of all <tt>PXSelect</tt> classes of Acumatica Framework return <tt>PXResultset&lt;T0&gt;</tt>, which implements the {{IQueryable<PXResult<T0>>}} interface. That is, you can work with the query expression defined with BQL by using LINQ. The following code shows an example of additional filtering of data of the BQL query.<source lang="csharp">//BQL statement
var Products = new PXSelect&lt;Product, 
  Where&lt;Product.productCD, Like&lt;string_D&gt;&gt;&gt;(graph);
//Use of LINQ for the result of the BQL query
var goods = Products.Select()
  .Where(p =&gt; p.GetItem&lt;Product&gt;().StockUnit == "item");
//Execution of the query
foreach (var good in goods) {
  var prod = good.GetItem&lt;Product&gt;();
}</source>{br}

However, you cannot work with the query defined with LINQ by using BQL.{br}

For details about how to use LINQ and BQL simultaneously, see [HelpRoot_Dev_Platform\AD__how_LINQ_Filter_BQL|To Append LINQ Expressions to BQL Statements].
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Comparison_of_TBQL_FBQL_LINQ|Comparison of Fluent BQL, Traditional BQL, and LINQ]
*[HelpRoot_Dev_Platform\AD__how_LINQ_Select_Records|To Select Records by Using LINQ]
*[HelpRoot_Dev_Platform\AD__how_LINQ_Filter_BQL|To Append LINQ Expressions to BQL Statements]]]></column>
			<column name="PlainText"><![CDATA[LINQ in  Acumatica FrameworkYou can use language-integrated query (LINQ) provided by the  System.Linq          library when you need to select records from the database in the code of  Acumatica Framework-based applications or if you want to apply additional filtering to the data of a BQL         query. However, you still have to use business query language (BQL) to define the data views         in graphs and to specify the data queries in attributes of data fields. For details about         BQL, see  Creating Fluent BQL Queries and  Creating Traditional BQL Queries. For more information about the differences between         LINQ and BQL, see  Comparison of Fluent BQL, Traditional BQL, and LINQ. Data Access Classes in LINQ In LINQ expressions, to access data from the database tables, you use data access classes         (DACs). For details on DACs, see  Data Access Classes.  You use property fields of DACs when you need to specify table columns in LINQ expressions.         (The name of the property field starts with an uppercase letter. Do not confuse it with the         class field, which has the same name but starts with lowercase letter.) Query Syntax To configure a LINQ query, you can use the following       variants of syntax: Query expressions, which use standard query operators from the              System.Linq  namespace (such as  where  or              orderby ) or  Acumatica Framework-specific           operators from the  PX.Data.SQLTree  namespace (such as              SQL.BinaryLen , which is shown in the following example of this           syntax).            ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var goods = from p in graph.Select<Product>()
  where 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0
  select new 
  { 
    p.ProductID, 
    p.ProductCD, 
    p.ProductName, 
    Len = p.ProductName.Length, 
    BLen = SQL.BinaryLen( p.ProductName) + 1, 
    p.GroupMask, 
    p.WorkGroupID 
}; Explicit (method-based) syntax. The arguments of the methods used in this syntax are           lambda expressions. In these expressions, you can use the standard C# operators and  Acumatica Framework-specific           operators from the  PX.Data.SQLTree  namespace (such as              SQL.BinaryLen , which is shown in the following code). The code below           is equivalent to the query expression shown           above. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var goods = graph.Select<Product>()
  .Where( p => 
    p.ProductCD.Length == 5 && 
    p.GroupMask.Length == 4 && 
    (p.WorkGroupID & 0b10) != 0)
  .Select( p => new     
    { 
      p.ProductID, 
      p.ProductCD, 
      p.ProductName, 
      Len = p.ProductName.Length, 
      BLen = SQL.BinaryLen(p.ProductName) + 1, 
      p.GroupMask, p.WorkGroupID 
    }); For details about composing LINQ queries, see  To Select Records by Using LINQ. In the code examples of this guide, we use explicit syntax. Simultaneous Use of LINQ and BQL The  Select  method of all  PXSelect  classes of  Acumatica Framework         return  PXResultset<T0> , which implements the            IQueryable<PXResult<T0>>  interface. That is, you can work with the         query expression defined with BQL by using LINQ. The following code shows an example of         additional filtering of data of the BQL         query. //BQL statement
var Products = new PXSelect<Product, 
  Where<Product.productCD, Like<string_D>>>(graph);
//Use of LINQ for the result of the BQL query
var goods = Products.Select()
  .Where(p => p.GetItem<Product>().StockUnit == "item");
//Execution of the query
foreach (var good in goods) {
  var prod = good.GetItem<Product>();
} However, you cannot work with the query defined with LINQ by using BQL. For details about how to use LINQ and BQL simultaneously, see  To Append LINQ Expressions to BQL Statements. ]]></column>
		</row>
		<row PageID="c086439e-08ff-4812-bc02-abcfc1279bea" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="97aa66ab-0c53-1e46-d7e5-fda7b02a45a8" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Queries defined with LINQ in Acumatica Framework implement the {{IQueryable}} interface—that is, for these queries, the system generates expression trees and executes the queries only when they are iterated over. For details about query execution, see [HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution].{br}{TOC}
==Execution of the LINQ Query in Code==
To execute the query, you do one of the following:[anchor|#_decfb88d-7a14-4b10-b48f-8470b2364b30]
*Call the {{ToList}} or {{ToArray}} method for the query, as shown in the following code.<source lang="csharp">//query is a LINQ expression.
var data = query.ToList();</source>
*Iterate the query by using the {{foreach}} statement, as shown in the following code.<source lang="csharp">//query has the IQueryable&lt;Product&gt; type.
//Product is a DAC.
foreach (Product record in query)
{
    ...
}</source>

==Explicit Merge of Records with PXCache==
The system merges with <tt>PXCache</tt> the records the system has retrieved from the database by using the LINQ queries, as described in [HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache].{br}

You may need to explicitly merge the records retrieved from the database with a particular <tt>PXCache</tt> object. To merge the records with <tt>PXCache</tt> explicitly, you use the <tt>Merge</tt> method, as shown in the following code example.<source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var query = new PXSelectReadonly&lt;Product&gt;(graph).Select()
    .Select(r =&gt; r.GetItem&lt;Product&gt;())
    .Where(p =&gt; SQL.Like(p.ProductName, "%d%") && p.StockUnit != null)
    .OrderBy(p =&gt; p.ProductID);
var result = query.Merge(p =&gt; p).ToArray();</source>{br}

You also can specify that the query should not be merged with <tt>PXCache</tt> by using the <tt>ReadOnly</tt> method, as shown in the following code example.<source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var query = new PXSelect&lt;Product&gt;(graph).Select()
    .Select(r =&gt; r.GetItem&lt;Product&gt;())
    .Where(p =&gt; SQL.Like(p.ProductName, "%d%") && p.StockUnit != null);
    .OrderBy(p =&gt; p.ProductID);
var result = query.ReadOnly().ToArray();</source>
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_Query_Execution|Data Query Execution]
*[HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache]]]></column>
			<column name="PlainText"><![CDATA[Deferred LINQ Query Execution Queries defined with LINQ in  Acumatica Framework         implement the  IQueryable  interface—that is, for these queries, the         system generates expression trees and executes the queries only when they are iterated over.         For details about query execution, see  Data Query Execution. Execution of the LINQ Query in Code To execute the query, you do one of the following: Call the  ToList  or  ToArray  method for the query, as             shown in the following             code. //query is a LINQ expression.
var data = query.ToList(); Iterate the query by using the  foreach  statement, as shown in the             following             code. //query has the IQueryable<Product> type.
//Product is a DAC.
foreach (Product record in query)
{
    ...
} Explicit Merge of Records with PXCache The system merges with  PXCache  the records the system has retrieved from         the database by using the LINQ queries, as described in  Merge of the Records with PXCache. You may need to explicitly merge the records retrieved from the database with a particular            PXCache  object. To merge the records with  PXCache          explicitly, you use the  Merge  method, as shown in the following code         example. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var query = new PXSelectReadonly<Product>(graph).Select()
    .Select(r => r.GetItem<Product>())
    .Where(p => SQL.Like(p.ProductName, "%d%") && p.StockUnit != null)
    .OrderBy(p => p.ProductID);
var result = query.Merge(p => p).ToArray(); You also can specify that the query should not be merged with  PXCache  by         using the  ReadOnly  method, as shown in the following code         example. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var query = new PXSelect<Product>(graph).Select()
    .Select(r => r.GetItem<Product>())
    .Where(p => SQL.Like(p.ProductName, "%d%") && p.StockUnit != null);
    .OrderBy(p => p.ProductID);
var result = query.ReadOnly().ToArray(); ]]></column>
		</row>
		<row PageID="f0785138-5659-413b-9908-814a4891f85b" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="286db9d9-a2b8-a6a3-41ee-d4de959ae25b" RecordSourceID="22377">
			<column name="Content"><![CDATA[
With LINQ, you may not be able to filter records by using custom C# functions. For example, suppose that your C# function filters records by a regular expression, which cannot be converted to standard SQL functions. If the system cannot convert a custom C# function in a LINQ statement to an SQL query tree, the system falls back to LINQ to Objects mode—that is, the system executes the data query in memory, which can lead to degradation of the application&rsquo;s performance.{br}

The following code shows an example of a situation when the system falls back to LINQ to Objects mode. In this example, the system selects from the database all records from the {{CRCase}} table, and then, in memory, orders the retrieved records by the {{Date}} column and selects the records that satisfy the condition specified by using the {{MyHelpers.IsHighPriority}} function.<source lang="csharp">// MyHelpers.IsHighPriority is a custom function.
var results = graph
    .Select&lt;CRCase&gt;()
    .OrderByDescending(c =&gt; c.Date)
    .Where(c =&gt; MyHelpers.IsHighPriority(c));

foreach (CRCase case in results)
{
    ...
}</source>((({S:Hint}If the system falls back to LINQ to Objects, only the results of the base <tt>PXSelectBase</tt> query are merged with <tt>PXCache</tt> as described in [HelpRoot_Dev_Platform\AD__con_Merge_of_Records_with_PXCache|Merge of the Records with PXCache]. The <tt>Merge</tt> and <tt>ReadOnly</tt> methods do not affect the merge of records with <tt>PXCache</tt> for the queries that caused fallback.
)))
The LINQ fallback is supported in Acumatica Framework for compatibility with previous versions. The system writes to the trace log about all situations in which the system falls back to LINQ to Objects mode. Therefore, we strongly recommend that you investigate the trace log for such issues and fix the issues in one of the following ways:[anchor|#_ff6461ad-bf6a-4de5-b3ea-cf14607d52f2]
*Remove the custom C# functions that cause fallback so that the full query is executed in the database.
*Append the <tt>AsEnumerable()</tt> method to the part of the query that can be converted to SQL, and add after it the conditions that include custom C# functions. In this case, the system does not waste resources trying to build the SQL query tree for the whole query. Instead, the system builds the SQL query tree for the part of the query that has <tt>AsEnumerable()</tt> appended and performs the corresponding request to the database, while the custom C# conditions of the query are processed in memory. For example, the code example above can be modified as follows.<source lang="csharp">// MyHelpers.IsHighPriority is a custom function.
var results = graph
    .Select&lt;CRCase&gt;()
    .OrderByDescending(c =&gt; c.Date).AsEnumerable()
    .Where(c =&gt; MyHelpers.IsHighPriority(c));

foreach (CRCase case in results)
{
    ...
}</source>
*:((({S:Hint}The system executes the following SQL query for the code above, where {{[list of columns]}} is the list of columns of the {{CRCase}} table.{{{{SELECT [list of columns] FROM CRCase
    ORDER BY CRCase.Date DESC
}}}}
)))

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_LINQ_in_Acumatica_Framework|LINQ in Acumatica Framework]]]></column>
			<column name="PlainText"><![CDATA[Fallback to the LINQ to Objects Mode With LINQ, you may not be able to filter records by using custom C# functions. For example,     suppose that your C# function filters records by a regular expression, which cannot be converted     to standard SQL functions. If the system cannot convert a custom C# function in a LINQ statement     to an SQL query tree, the system falls back to LINQ to Objects mode—that is, the system     executes the data query in memory, which can lead to degradation of the application's     performance. The following code shows an example of a situation when the system falls back to LINQ to     Objects mode. In this example, the system selects from the database all records from the       CRCase  table, and then, in memory, orders the retrieved records by the       Date  column and selects the records that satisfy the condition specified by     using the  MyHelpers.IsHighPriority      function. // MyHelpers.IsHighPriority is a custom function.
var results = graph
    .Select<CRCase>()
    .OrderByDescending(c => c.Date)
    .Where(c => MyHelpers.IsHighPriority(c));

foreach (CRCase case in results)
{
    ...
} If the system falls back to LINQ to Objects, only the results of the base       PXSelectBase  query are merged with  PXCache  as described     in  Merge of the Records with PXCache. The  Merge  and       ReadOnly  methods do not affect the merge of records with       PXCache  for the queries that caused fallback. The LINQ fallback is supported in  Acumatica Framework for     compatibility with previous versions. The system writes to the trace log about all situations in     which the system falls back to LINQ to Objects mode. Therefore, we strongly recommend that you     investigate the trace log for such issues and fix the issues in one of the following ways: Remove the custom C# functions that cause fallback so that the full query is executed in       the database. Append the  AsEnumerable()  method to the part of the query that can be       converted to SQL, and add after it the conditions that include custom C# functions. In this       case, the system does not waste resources trying to build the SQL query tree for the whole       query. Instead, the system builds the SQL query tree for the part of the query that has         AsEnumerable()  appended and performs the corresponding request to the       database, while the custom C# conditions of the query are processed in memory. For example,       the code example above can be modified as        follows. // MyHelpers.IsHighPriority is a custom function.
var results = graph
    .Select<CRCase>()
    .OrderByDescending(c => c.Date).AsEnumerable()
    .Where(c => MyHelpers.IsHighPriority(c));

foreach (CRCase case in results)
{
    ...
} The        system executes the following SQL query for the code above, where  [list of         columns]  is the list of columns of the  CRCase         table. SELECT [list of columns] FROM CRCase
    ORDER BY CRCase.Date DESC ]]></column>
		</row>
		<row PageID="53571695-dd57-4099-8820-7ea518a28b90" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="845beafe-ef00-8b14-b13e-2ee8d8081004" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To select records from the database by using language-integrated query (LINQ), you use the standard query operators (provided by LINQ libraries), as described in this topic. In the LINQ queries, you use the property fields of DACs to specify the columns of database tables. (The name of the property field starts with an uppercase letter. Do not confuse it with the class field, which has the same name but starts with lowercase letter.)[anchor|#_f31d9a74-fcb0-4627-a84f-f725d3ac7a82]((({S:Hint}After you have composed a LINQ expression, to execute the query defined by this expression, you have to call the {{ToList}} or {{ToArray}} method for the query, or iterate the query by using the {{foreach}} statement. For example, the following code executes the query defined by a LINQ expression.{{{{//query is a LINQ expression
var data = query.ToList();
}}}}
For details about the execution of LINQ expressions, see [HelpRoot_Dev_Platform\AD__con_Deferred_LINQ_Query_Execution|Deferred LINQ Query Execution].
))){br}{TOC}[anchor|#_799d1a4d-a146-4746-9428-6a8fa4173aa0]
==Before You Proceed==
[anchor|#_10024b9f-f1e4-4028-bfe1-f3efd579bc0d]
*Add the {{using}} directives shown below to your code.<source lang="csharp">using PX.Data;
using PX.Data.SQLTree;
using System.Linq;</source>
*Make sure that the application database has the database tables from which you are going to request data, and that the application defines the data access classes (DACs) for these tables. For more information on defining DACs, see [HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes].

==To Filter Records==
To filter records in the database table to be retrieved, construct the LINQ expression by using the {{Where}} LINQ method and the needed conditions. In the conditions, use the property field defined in the DAC, such as <tt>Product.ProductID</tt>. {br}

The following LINQ expression uses the C# logical operators (<tt>||</tt>, <tt>&&</tt>, and <tt>!</tt>) to define multiple conditions.{{{{ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
IQueryable&lt;Product&gt; query = graph.Select&lt;Product&gt;().Where(prod =&gt;
    prod.BookedQty &gt; prod.AvailQty
    || prod.AvailQty &lt; prod.MinAvailQty
    || prod.AvailQty == null);
}}}}((({S:Hint}This LINQ expression is equivalent to the following SQL query. In this SQL query, {{[list of columns]}} is the list of columns of the {{Product}} table. {{{{SELECT [list of columns] FROM Product
WHERE Product.BookedQty &gt; Product.AvailQty
    OR Product.AvailQty &lt; Product.MinAvailQty
    OR Product.AvailQty IsNull
}}}}
)))
==To Order Records==
To order records to be retrieved from the database table, construct the LINQ expression by using the {{OrderBy}} or {{OrderByDescending}} LINQ method and the needed property fields of the DAC, such as <tt>Product.ProductID</tt>. {br}

The following sample LINQ expression selects all <tt>Product</tt> data records and sorts them by the <tt>UnitPrice</tt> field in ascending order.<source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
IQueryable&lt;Product&gt; query = graph.Select&lt;Product&gt;().OrderBy(prod =&gt; prod.UnitPrice)
  .ThenByDescending(prod =&gt; prod.AvailQty);</source>((({S:Hint}This LINQ expression is equivalent to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice, Product.AvailQty DESC
}}}}
)))
==To Query Multiple Tables==
To join multiple tables, construct the LINQ expression by using the {{Join}}, {{LeftJoin}}, {{GroupJoin}}, and {{FullJoin}} LINQ methods and the needed property fields of DACs, such as <tt>SalesOrder.OrderNbr</tt>. {br}

The following sample LINQ expression performs an inner join of the <tt>SalesOrder</tt> and <tt>OrderDetail</tt> DACs by the <tt>OrderNbr</tt> field.<source lang="csharp">SalesOrderEntry graph = PXGraph.CreateInstance&lt;SalesOrderEntry&gt;();
var query = graph.Select&lt;SalesOrder&gt;()
    .Join(graph.Select&lt;OrderLine&gt;(),
          ord =&gt; ord.OrderNbr, ordDet =&gt; ordDet.OrderNbr,
          (ord, ordDet) =&gt; new { SalesOrder = ord, OrderDetail = ordDet });</source>((({S:Hint}This LINQ expression is equivalent to the following SQL query, where {{[list of columns]}} is the list of columns of the {{Product}} table.{{{{SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr
}}}}
)))
==To Group or Aggregate Records==
To group or aggregate records, do the following:[anchor|#_cd2b8cae-d32f-421e-b66d-44d8c7a1618d]
#Construct the LINQ expression by using the {{GroupBy}} LINQ method and the needed property fields of the DAC, such as <tt>Product.CategoryCD</tt>. (The name of the property field starts with an uppercase letter. Do not confuse it with the class field, which has the same name but starts with lowercase letter.) 
#Append to the expression the <tt>Select</tt> LINQ method.
#:((({S:Hint}You have to use the <tt>Select</tt> method after {{GroupBy}} to eliminate the number of requests that the system performs to the database.
)))
{br}

The following sample LINQ expression groups the records of the {{Product}} table by the {{CategoryCD}} field.<source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var query = graph.Select&lt;Product&gt;().GroupBy(prod =&gt; prod.CategoryCD).
  Select(group =&gt; new { CategoryCD = group.Key });</source>((({S:Hint}This LINQ expression is equivalent to the following SQL query.{{{{SELECT Product.CategoryCD
FROM Product
GROUP BY Product.CategoryCD
}}}}
)))
==To Select Particular Columns of Records==
To select particular columns, specify the corresponding property fields of DACs in the {{Select}} clause.{br}

The following example selects the values of the {{ProductCD}} and {{AvailQty}} fields for all records of the {{Product}} table.<source lang="csharp">ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();
var results = graph.Select&lt;Product&gt;()
    .Select(p =&gt; new { ProductCD = p.ProductCD, AvailQty = p.AvailQty });</source>((({S:Hint}The system executes the following SQL query for the code above.{{{{SELECT Product.ProductCD, Product.AvailQty FROM Product
}}}}
)))
==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_LINQ_in_Acumatica_Framework|LINQ in Acumatica Framework]]]></column>
			<column name="PlainText"><![CDATA[To Select Records by Using LINQ To select records from the database by using language-integrated query (LINQ), you                 use the standard query operators (provided by LINQ libraries), as described in this                 topic. In the LINQ queries, you use the property fields of DACs to specify the                 columns of database tables. (The name of the property field starts with an uppercase                 letter. Do not confuse it with the class field, which has the same name but starts                 with lowercase letter.) After you have composed a LINQ expression, to             execute the query defined by this expression, you have to call the                  ToList  or  ToArray  method for the query, or iterate             the query by using the  foreach  statement. For example, the following             code executes the query defined by a LINQ                 expression. //query is a LINQ expression
var data = query.ToList(); For                 details about the execution of LINQ expressions, see  Deferred LINQ Query Execution. Before You Proceed Add the  using  directives shown below to your                         code. using PX.Data;
using PX.Data.SQLTree;
using System.Linq; Make sure that the application database has the database tables from which you are going to                         request data, and that the application defines the data access classes                         (DACs) for these tables. For more information on defining DACs, see  Data Access Classes. To Filter Records To filter records in the database table to be retrieved, construct the LINQ                 expression by using the  Where  LINQ method and the needed                 conditions. In the conditions, use the property field defined in the DAC, such as                      Product.ProductID .  The following LINQ expression uses the C# logical operators ( || ,                      && , and  ! ) to define multiple                     conditions. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
IQueryable<Product> query = graph.Select<Product>().Where(prod =>
    prod.BookedQty > prod.AvailQty
    || prod.AvailQty < prod.MinAvailQty
    || prod.AvailQty == null); This                     LINQ expression is equivalent to the following SQL query. In this SQL query,                          [list of columns]  is the list of columns of the                          Product  table.                      SELECT [list of columns] FROM Product
WHERE Product.BookedQty > Product.AvailQty
    OR Product.AvailQty < Product.MinAvailQty
    OR Product.AvailQty IsNull To Order Records To order records to be retrieved from the database table, construct the LINQ                 expression by using the  OrderBy  or                      OrderByDescending  LINQ method and the needed property fields of                 the DAC, such as  Product.ProductID .  The following sample LINQ expression selects all  Product  data                 records and sorts them by the  UnitPrice  field in ascending                 order. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
IQueryable<Product> query = graph.Select<Product>().OrderBy(prod => prod.UnitPrice)
  .ThenByDescending(prod => prod.AvailQty); This LINQ expression is equivalent to the following SQL query, where  [list                     of columns]  is the list of columns of the  Product                  table. SELECT [list of columns] FROM Product
    ORDER BY Product.UnitPrice, Product.AvailQty DESC To Query Multiple Tables To join multiple tables, construct the LINQ expression by using the                      Join ,  LeftJoin ,  GroupJoin ,                 and  FullJoin  LINQ methods and the needed property fields of DACs,                 such as  SalesOrder.OrderNbr .  The following sample LINQ expression performs an inner join of the                      SalesOrder  and  OrderDetail  DACs by the                      OrderNbr  field. SalesOrderEntry graph = PXGraph.CreateInstance<SalesOrderEntry>();
var query = graph.Select<SalesOrder>()
    .Join(graph.Select<OrderLine>(),
          ord => ord.OrderNbr, ordDet => ordDet.OrderNbr,
          (ord, ordDet) => new { SalesOrder = ord, OrderDetail = ordDet }); This LINQ expression is equivalent to the following SQL query, where  [list                     of columns]  is the list of columns of the  Product                  table. SELECT [list of columns] FROM SalesOrder
INNER JOIN OrderDetail
    ON OrderDetail.OrderNbr = SalesOrder.OrderNbr To Group or Aggregate Records To group or aggregate records, do the following: Construct the LINQ expression by using the  GroupBy  LINQ                         method and the needed property fields of the DAC, such as                              Product.CategoryCD . (The name of the property field                         starts with an uppercase letter. Do not confuse it with the class field,                         which has the same name but starts with lowercase letter.)  Append to the expression the  Select  LINQ method. You                             have to use the  Select  method after                                  GroupBy  to eliminate the number of requests that                             the system performs to the database. The following sample LINQ expression groups the records of the                      Product  table by the  CategoryCD  field. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var query = graph.Select<Product>().GroupBy(prod => prod.CategoryCD).
  Select(group => new { CategoryCD = group.Key }); This LINQ expression is equivalent to the following SQL                 query. SELECT Product.CategoryCD
FROM Product
GROUP BY Product.CategoryCD To Select Particular Columns of Records To select particular columns, specify the corresponding property fields of DACs in                 the  Select  clause. The following example selects the values of the  ProductCD  and                      AvailQty  fields for all records of the  Product                      table. ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();
var results = graph.Select<Product>()
    .Select(p => new { ProductCD = p.ProductCD, AvailQty = p.AvailQty }); The                     system executes the following SQL query for the code                     above. SELECT Product.ProductCD, Product.AvailQty FROM Product ]]></column>
		</row>
		<row PageID="6e0f7080-d099-4fc3-9cb6-ad15b800546d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="53ec0445-9918-dfc9-f2f9-a393aeadcfab" RecordSourceID="22377">
			<column name="Content"><![CDATA[
By using LINQ, you can work with a query expression that is defined with BQL. In this topic, you can find out how to apply additional filtering to a BQL statement and join a table to a BQL statement by using LINQ.{br}{TOC}[anchor|#_099b7200-eabb-4ca7-b65d-ff6e63f121e6]
==Before You Proceed==
[anchor|#_8608bcec-aca4-46e8-8cb2-f8162be29629]
*Add the {{using}} directives shown below to your code.<source lang="csharp">using PX.Data;
using PX.Data.SQLTree;
using System.Linq;</source>
*Make sure that the application database has the database tables from which you are going to request data, and that the application defines the data access classes (DACs) for these tables. For more information on defining DACs, see [HelpRoot_Dev_Platform\AD__con_BQL_DAC|Data Access Classes].

==To Append LINQ Expressions to BQL Statements==To append LINQ expressions to BQL statements, do the following:[anchor|#_ef830bfa-a6ca-4ad5-936c-2f1011f50f10]
#Configure a BQL query derived from <tt>PXSelectBase</tt> either in fluent BQL or in traditional BQL.
#Call the <tt>Select()</tt> method of <tt>PXSelectBase</tt>, and append the LINQ query to the result. Because the result of the <tt>Select()</tt> method call is a <tt>PXResultset&lt;&gt;</tt> object, you need to cast it to a DAC type by using the <tt>PXResult.GetItem&lt;DacType&gt;()</tt> method or direct casting.

The following example appends LINQ joining and filtering to a BQL query.<source lang="csharp">using PX.Data;
using PX.Data.SQLTree;
using System.Linq;
using PX.Data.BQL.Fluent;

ProductMaint graph = PXGraph.CreateInstance&lt;ProductMaint&gt;();

//Configure a BQL query
var products = new SelectFrom&lt;Product&gt;.
    Where&lt;Product.productCD.IsLike&lt;string_D&gt;&gt;.View(graph);

//Append joining and filtering by using LINQ
var goods = products.Select().Join(graph.Select&lt;SupplierProduct&gt;(),
    p =&gt; p.GetItem&lt;Product&gt;().ProductID,
    sp =&gt; sp.ProductID,
    (p, sp) =&gt; new { p = p.GetItem&lt;Product&gt;(), sp }
).Where(sp =&gt; sp.p.UnitPrice &gt;= 0 && sp.sp.LastPurchaseDate == null);

//Execute the query
foreach (var item in goods)
{
  ...
}</source>((({S:Hint}The system executes the following SQL query for the code above. In this SQL query, {{[list of columns]}} is the list of columns of the {{Product}} and {{SupplierProduct}} tables. {{{{SELECT [list of columns] FROM Product
INNER JOIN SupplierProduct
    ON Product.ProductID = SupplierProduct.ProductID
WHERE Product.ProductCD LIKE 'D' AND Product.UnitPrice&gt;=0 
    AND SupplierProduct.LastPurchaseDate IS NULL
}}}}
)))]]></column>
			<column name="PlainText"><![CDATA[To Append LINQ Expressions to BQL Statements By using LINQ, you can work with a query expression that is defined with BQL. In this                 topic, you can find out how to apply additional filtering to a BQL statement and                 join a table to a BQL statement by using LINQ. Before You Proceed Add the  using  directives shown below to your                         code. using PX.Data;
using PX.Data.SQLTree;
using System.Linq; Make sure that the application database has the database tables from which you are going to                         request data, and that the application defines the data access classes                         (DACs) for these tables. For more information on defining DACs, see  Data Access Classes. To Append LINQ Expressions to BQL Statements To append LINQ             expressions to BQL statements, do the following: Configure a BQL query derived from  PXSelectBase  either in                     fluent BQL or in traditional BQL. Call the  Select()  method of  PXSelectBase ,                     and append the LINQ query to the result. Because the result of the                          Select()  method call is a                          PXResultset<>  object, you need to cast it to a DAC                     type by using the  PXResult.GetItem<DacType>()  method or                     direct casting. The following example appends LINQ joining and filtering to a BQL                     query. using PX.Data;
using PX.Data.SQLTree;
using System.Linq;
using PX.Data.BQL.Fluent;

ProductMaint graph = PXGraph.CreateInstance<ProductMaint>();

//Configure a BQL query
var products = new SelectFrom<Product>.
    Where<Product.productCD.IsLike<string_D>>.View(graph);

//Append joining and filtering by using LINQ
var goods = products.Select().Join(graph.Select<SupplierProduct>(),
    p => p.GetItem<Product>().ProductID,
    sp => sp.ProductID,
    (p, sp) => new { p = p.GetItem<Product>(), sp }
).Where(sp => sp.p.UnitPrice >= 0 && sp.sp.LastPurchaseDate == null);

//Execute the query
foreach (var item in goods)
{
  ...
} The                     system executes the following SQL query for the code above. In this SQL query,                          [list of columns]  is the list of columns of the                          Product  and  SupplierProduct  tables.                      SELECT [list of columns] FROM Product
INNER JOIN SupplierProduct
    ON Product.ProductID = SupplierProduct.ProductID
WHERE Product.ProductCD LIKE 'D' AND Product.UnitPrice>=0 
    AND SupplierProduct.LastPurchaseDate IS NULL ]]></column>
		</row>
		<row PageID="92c13762-b9c3-4267-b5cf-4b04fdb78e78" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can learn how to define relationships between data access classes (DACs) by using the special classes for primary and foreign keys.&#xA;==In This Chapter==[anchor|#_40926635-a71c-4253-a071-0c5632dfabbc]&#xA;*[HelpRoot_Dev_Platform\AD__con_PK_and_FK_API|Establishment of a Relationship Between Two DACs]&#xA;*[HelpRoot_Dev_Platform\AD__how_Define_Primary_Key|To Define a Primary Key]&#xA;*[HelpRoot_Dev_Platform\AD__how_Define_Foreign_Key|To Define a Foreign Key]&#xA;" PlainText="Defining Relationships Between DACs In this chapter, you can learn how to define relationships between data access classes (DACs)     by using the special classes for primary and foreign keys. In This Chapter Establishment of a Relationship Between Two DACsTo Define a Primary KeyTo Define a Foreign Key" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="a88592cb-6b00-74c1-45e0-3d13cd346521" RecordSourceID="22377" />
		<row PageID="67621706-e4f4-4423-b90f-84b3b6b189c4" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2f2b7af5-1347-3fb0-d99c-efc8af87e73f" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To define a relationship between two tables, you need to define the primary keys of the parent and child tables. Also, in the child table, you need to define the foreign key that refers to the primary key of the parent table. {br}

In the code of an Acumatica Framework-based application, you can define this relationship as follows:[anchor|#_fbe1aa53-57d7-4cf1-94e5-f7e963309c56]
*To define a primary key of a table, for the set of key fields of the data access class (DAC) that corresponds to the table, you set the <tt>IsKey</tt> property of the data type attribute to {{true}}. 
*To define a foreign key of a table, in the DAC that corresponds to the table, you mark the field that contains the foreign key with one of the following attributes: <tt>PXForeignReference</tt>, [https://help.acumatica.com/(W(42))/Main?ScreenId=ShowWiki&pageid=6ed489c0-36a3-9790-7bcd-5072e718a728|<tt>PXSelector</tt>], or [https://help.acumatica.com/(W(42))/Main?ScreenId=ShowWiki&pageid=a916cba2-1f12-0c2b-8f70-31b1ecc05b99|<tt>PXParent</tt>]. 
{br}

To select a record from the database by its primary or foreign key, you can use a <tt>Select</tt> statement in business query language (BQL) or use the methods of the attributes mentioned above. {br}

Another way to define a relationship between two tables is to use the classes and methods that are specially designed for the definition of primary and foreign keys. This approach, which is described in this topic, provides the following advantages:[anchor|#_0eff0f63-599c-475c-b497-f60ecad1352e]
*These classes provide static information that a compiler can use to identify errors in the code.
*You can use runtime information about primary keys to select records by their keys.
*These classes and methods have no other meanings and use cases; conversely, the <tt>PXForeignReference</tt>, <tt>PXSelector</tt>, and <tt>PXParent</tt> attributes can be used for other purposes.
*These classes and methods are optimized for the selection of records from the database; therefore, using them improves database access performance on record selection. 
{br}{TOC}
==Definition of a Primary Key==
You define a primary key of a DAC by using the <tt>PrimaryKeyOf&lt;Table&gt;.By&lt;keyFields&gt;</tt> class. With this class, you can define simple keys (with one key field) and compound keys (with up to five key fields). In the primary key definition, you have to define the {{public}}<tt>Find</tt> method, which calls the {{protected}}<tt>FindBy</tt> method. A definition of a compound key is shown in the following example.<source lang="csharp">using PX.Data.ReferentialIntegrity.Attributes;

public partial class SOLine : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf&lt;SOLine&gt;.By&lt;orderType, orderNbr, lineNbr&gt;
    {
        public static SOLine Find(
            PXGraph graph, string orderType, string orderNbr, int lineNbr) 
                =&gt; FindBy(graph, orderType, orderNbr, lineNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
    public abstract class lineNbr : PX.Data.IBqlField { }
}</source>[anchor|#_a65fe2e3-9eb0-4ffe-850d-b704d6111ac3]
==Definition of a Foreign Key==
You can define a foreign key based on the primary key of the referenced table, as shown in the following code.<source lang="csharp">//Definition of the primary key
public partial class SOOrder : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf&lt;SOOrder&gt;.By&lt;orderType, orderNbr&gt;
    {
        public static SOOrder Find(
            PXGraph graph, string orderType, string orderNbr) =&gt; 
            FindBy(graph, orderType, orderNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
} 

//Definition of the foreign key based on the primary key
public partial class SOLine : PX.Data.IBqlTable
{
    public class SOOrderFK : SOOrder.PK.ForeignKeyOf&lt;SOLine&gt;
        .By&lt;orderType, orderNbr&gt; { }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
}</source>
==Selection of a Record by Key Fields==
If a primary key is defined for a DAC, you can select a record by using the values of the key fields of the record, as shown in the following example.<source lang="csharp">SOLine line = SOLine.PK.Find(
    this, split.OrderType, split.OrderNbr, split.LineNbr.Value);</source>{br}

((({S:Hint}The <tt>Find</tt> method encapsulates a {{PXSelectReadonly<Table, Where<...>>.SelectWindowed(graph, 0, 1, keys)}} call. Therefore, the code above can replace the following code written using BQL.<source lang="csharp">SOLine line = PXSelectReadonly&lt;SOLine,
    Where&lt;SOLine.orderType, Equal&lt;Required&lt;SOLine.orderType&gt;&gt;,
        And&lt;SOLine.orderNbr, Equal&lt;Required&lt;SOLine.orderNbr&gt;&gt;,
        And&lt;SOLine.lineNbr, Equal&lt;Required&lt;SOLine.lineNbr&gt;&gt;&gt;&gt;&gt;
    &gt;.Select(this, split.OrderType, split.OrderNbr, split.LineNbr);</source>
)))You can also select a record by using a record of the same type with the key fields specified, as shown in the following example.<source lang="csharp">InventoryItem actualItem = InventoryItem.PK.Find(this, notActualItem);</source>{br}

If a foreign key is defined for a DAC, you can select the parent and child records, as shown in the following code.<source lang="csharp">//Selection of the parent record
SOOrder order = SOLine.SOOrderFK.FindParent(this, soLine);
//Selection of the child records
IEnumerable&lt;SOLine&gt; lines = SOLine.SOOrderFK.SelectChildren(this, soOrder);</source>
==Use of Primary and Foreign Keys in Attributes==
You can use static foreign keys, defined as described in [[#_a65fe2e3-9eb0-4ffe-850d-b704d6111ac3|Definition of a Foreign Key], for the configuration of the <tt>PXForeignReference</tt> and <tt>PXParent</tt> attributes, as shown in the following example.<source lang="csharp">public partial class SOLine : PX.Data.IBqlTable
{
    public class SOOrderFK : SOOrder.PK.ForeignKeyOf&lt;SOLine&gt;
        .By&lt;orderType, orderNbr&gt; { }
    public class InventoryFK : InventoryItem.PK.ForeignKeyOf&lt;SOLine&gt;
        .By&lt;inventoryID&gt; { }

    public abstract class orderType : PX.Data.IBqlField { }

    [...]
    [PXParent(typeof(SOOrderFK))]
    public virtual String OrderNbr { get; set; }
    public abstract class orderNbr : PX.Data.IBqlField { }

    [...]
    [PXForeignReference(typeof(InventoryFK))]
    public virtual Int32? InventoryID { get; set; }
    public abstract class inventoryID : PX.Data.IBqlField { }
}</source>{br}

Because all primary keys, which are defined as described in this topic, implement the <tt>IPrimaryKey</tt> interface, you can use primary and foreign keys in the scope of custom attributes, as shown in the following example.{{{{public class SomeAttribute : PXEventSubscriberAttribute, ...
{
    private readonly IPrimaryKey _pk;
    public SomeAttribute(Type pkType)
    {
        _pk = (IPrimaryKey)Activator.CreateInstance(pkType);
    }

    public void SomeHandler(PXCache cache, PXSomeEventArgs e)
    {
        IBqlTable row = _pk.Find(cache.Graph, e.NewValue);
        ...
        _pk.StoreCached(cache.graph, row);
        ...
        row = _pk.Find(cache.Graph, row);
    }
}
}}}}
==Related Articles==
*[HelpRoot_Dev_Platform\AD__how_Define_Primary_Key|To Define a Primary Key]
*[HelpRoot_Dev_Platform\AD__how_Define_Foreign_Key|To Define a Foreign Key]]]></column>
			<column name="PlainText"><![CDATA[Establishment of a Relationship Between Two DACs To define a relationship between two tables, you need to define the primary keys of                 the parent and child tables. Also, in the child table, you need to define the                 foreign key that refers to the primary key of the parent table.  In the code of an  Acumatica Framework-based application, you can define this relationship as follows: To define a primary key of a table, for the set of key fields of the data                         access class (DAC) that corresponds to the table, you set the                              IsKey  property of the data type attribute to                              true .  To define a foreign key of a table, in the DAC that corresponds to the                         table, you mark the field that contains the foreign key with one of the                         following attributes:  PXForeignReference ,  PXSelector <tt>PXSelector</tt>, or                              PXParent <tt>PXParent</tt>.  To select a record from the database by its primary or foreign key, you can use a                      Select  statement in business query language (BQL) or use the                 methods of the attributes mentioned above.  Another way to define a relationship between two tables is to use the classes and                 methods that are specially designed for the definition of primary and foreign keys.                 This approach, which is described in this topic, provides the following                 advantages: These classes provide static information that a compiler can use to identify                     errors in the code. You can use runtime information about primary keys to select records by their                     keys. These classes and methods have no other meanings and use cases; conversely, the                          PXForeignReference ,  PXSelector , and                          PXParent  attributes can be used for other purposes. These classes and methods are optimized for the selection of records from the                     database; therefore, using them improves database access performance on record                     selection.  Definition of a Primary Key You define a primary key of a DAC by using the                      PrimaryKeyOf<Table>.By<keyFields>  class. With                 this class, you can define simple keys (with one key field) and compound keys (with                 up to five key fields). In the primary key definition, you have to define the                      public Find  method, which calls the  protected FindBy  method. A definition of a compound key is shown in the                 following                 example. using PX.Data.ReferentialIntegrity.Attributes;

public partial class SOLine : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf<SOLine>.By<orderType, orderNbr, lineNbr>
    {
        public static SOLine Find(
            PXGraph graph, string orderType, string orderNbr, int lineNbr) 
                => FindBy(graph, orderType, orderNbr, lineNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
    public abstract class lineNbr : PX.Data.IBqlField { }
} Definition of a Foreign Key You can define a foreign key based on the primary key of the referenced table, as shown in the                 following                 code. //Definition of the primary key
public partial class SOOrder : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf<SOOrder>.By<orderType, orderNbr>
    {
        public static SOOrder Find(
            PXGraph graph, string orderType, string orderNbr) => 
            FindBy(graph, orderType, orderNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
} 

//Definition of the foreign key based on the primary key
public partial class SOLine : PX.Data.IBqlTable
{
    public class SOOrderFK : SOOrder.PK.ForeignKeyOf<SOLine>
        .By<orderType, orderNbr> { }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
} Selection of a Record by Key Fields If a primary key is defined for a DAC, you can select a record by using the values of the key                 fields of the record, as shown in the following                 example. SOLine line = SOLine.PK.Find(
    this, split.OrderType, split.OrderNbr, split.LineNbr.Value); The  Find  method encapsulates a  PXSelectReadonly<Table,                         Where<...>>.SelectWindowed(graph, 0, 1, keys)  call.                     Therefore, the code above can replace the following code written using                     BQL. SOLine line = PXSelectReadonly<SOLine,
    Where<SOLine.orderType, Equal<Required<SOLine.orderType>>,
        And<SOLine.orderNbr, Equal<Required<SOLine.orderNbr>>,
        And<SOLine.lineNbr, Equal<Required<SOLine.lineNbr>>>>>
    >.Select(this, split.OrderType, split.OrderNbr, split.LineNbr); You                 can also select a record by using a record of the same type with the key fields                 specified, as shown in the following                 example. InventoryItem actualItem = InventoryItem.PK.Find(this, notActualItem); If a foreign key is defined for a DAC, you can select the parent and child records, as shown                 in the following                 code. //Selection of the parent record
SOOrder order = SOLine.SOOrderFK.FindParent(this, soLine);
//Selection of the child records
IEnumerable<SOLine> lines = SOLine.SOOrderFK.SelectChildren(this, soOrder); Use of Primary and Foreign Keys in Attributes You can use static foreign keys, defined as described in  Definition of a Foreign Key Definition of a Foreign Key, for the configuration of the                      PXForeignReference  and  PXParent                  attributes, as shown in the following                 example. public partial class SOLine : PX.Data.IBqlTable
{
    public class SOOrderFK : SOOrder.PK.ForeignKeyOf<SOLine>
        .By<orderType, orderNbr> { }
    public class InventoryFK : InventoryItem.PK.ForeignKeyOf<SOLine>
        .By<inventoryID> { }

    public abstract class orderType : PX.Data.IBqlField { }

    [...]
    [PXParent(typeof(SOOrderFK))]
    public virtual String OrderNbr { get; set; }
    public abstract class orderNbr : PX.Data.IBqlField { }

    [...]
    [PXForeignReference(typeof(InventoryFK))]
    public virtual Int32? InventoryID { get; set; }
    public abstract class inventoryID : PX.Data.IBqlField { }
} Because all primary keys, which are defined as described in this topic, implement the                      IPrimaryKey  interface, you can use primary and foreign keys                 in the scope of custom attributes, as shown in the following                 example. public class SomeAttribute : PXEventSubscriberAttribute, ...
{
    private readonly IPrimaryKey _pk;
    public SomeAttribute(Type pkType)
    {
        _pk = (IPrimaryKey)Activator.CreateInstance(pkType);
    }

    public void SomeHandler(PXCache cache, PXSomeEventArgs e)
    {
        IBqlTable row = _pk.Find(cache.Graph, e.NewValue);
        ...
        _pk.StoreCached(cache.graph, row);
        ...
        row = _pk.Find(cache.Graph, row);
    }
} ]]></column>
		</row>
		<row PageID="34e875c7-a5c3-496e-9e2b-f7f6f9f20a40" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="dc7469c1-5a1c-eb4d-b8fb-33c22aaf5f4a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can define the primary key of a data access class (DAC) by using the <tt>PrimaryKeyOf&lt;Table&gt;.By&lt;keyFields&gt;</tt> class. With this class, you can define simple keys (with one key field) and compound keys (with up to five key fields) and select records by using these keys, as described in this topic.{br}{TOC}
==To Define a Simple Primary Key and Select a Record by This Key==[anchor|#_528f727b-2037-4948-bde0-b418c0fb28a2]
#In the DAC, declare a <tt>PrimaryKeyOf&lt;Table&gt;</tt> <tt>.By&lt;keyFields&gt;</tt> descendant with the {{public}}<tt>Find</tt> method, which calls the {{protected}}<tt>FindBy</tt> method, as shown in the following code.<source lang="csharp">using PX.Data.ReferentialIntegrity.Attributes;

public partial class InventoryItem : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf&lt;InventoryItem&gt;.By&lt;inventoryID&gt;
    {
        public static InventoryItem Find(PXGraph graph, int inventoryID) 
          =&gt; FindBy(graph, inventoryID);
    }

    public abstract class inventoryID : PX.Data.IBqlField { }
}</source>
#Use the primary key to select a record, as shown in the following code.<source lang="csharp">InventoryItem item = InventoryItem.PK.Find(this, soLine.InventoryID.Value);</source>

==To Define a Compound Primary Key and Select a Record by This Key==[anchor|#_ea6e3b92-93f2-4f77-b340-2a820e18a94f]
#In the data access class (DAC), declare a <tt>PrimaryKeyOf&lt;Table&gt;</tt> <tt>.By&lt;keyFields&gt;</tt> descendant with the {{public}}<tt>Find</tt> method, which has the needed number (up to five) of key fields. The <tt>Find</tt> method must call the {{protected}}<tt>FindBy</tt> method with the same number of key fields, as shown in the following code.<source lang="csharp">using PX.Data.ReferentialIntegrity.Attributes;

public partial class SOLine : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf&lt;SOLine&gt;
        .By&lt;orderType, orderNbr, lineNbr&gt;
    {
        public static SOLine Find(
            PXGraph graph, string orderType, string orderNbr, int lineNbr) 
                =&gt; FindBy(graph, orderType, orderNbr, lineNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
    public abstract class lineNbr : PX.Data.IBqlField { }
}</source>
#Use the compound primary key to select a record, as shown in the following code.<source lang="csharp">SOLine line = SOLine.PK.Find(
    this, split.OrderType, split.OrderNbr, split.LineNbr.Value);</source>

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_PK_and_FK_API|Establishment of a Relationship Between Two DACs]]]></column>
			<column name="PlainText"><![CDATA[To Define a Primary Key You can define the primary key of a data access class (DAC) by using the                      PrimaryKeyOf<Table>.By<keyFields>  class. With                 this class, you can define simple keys (with one key field) and compound keys (with                 up to five key fields) and select records by using these keys, as described in this                 topic. To Define a Simple Primary Key and Select a Record by This Key In the DAC, declare a                          PrimaryKeyOf<Table> .By<keyFields>                      descendant with the  public Find  method, which calls the  protected FindBy  method, as shown in the following                     code. using PX.Data.ReferentialIntegrity.Attributes;

public partial class InventoryItem : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf<InventoryItem>.By<inventoryID>
    {
        public static InventoryItem Find(PXGraph graph, int inventoryID) 
          => FindBy(graph, inventoryID);
    }

    public abstract class inventoryID : PX.Data.IBqlField { }
} Use the primary key to select a record, as shown in the following                     code. InventoryItem item = InventoryItem.PK.Find(this, soLine.InventoryID.Value); To Define a Compound Primary Key and Select a Record by This Key In the data access class (DAC), declare a                          PrimaryKeyOf<Table> .By<keyFields>                      descendant with the  public Find  method, which has the needed number (up to five) of key                     fields. The  Find  method must call the                          protected FindBy  method with the same number of key fields, as shown in                     the following                     code. using PX.Data.ReferentialIntegrity.Attributes;

public partial class SOLine : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf<SOLine>
        .By<orderType, orderNbr, lineNbr>
    {
        public static SOLine Find(
            PXGraph graph, string orderType, string orderNbr, int lineNbr) 
                => FindBy(graph, orderType, orderNbr, lineNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
    public abstract class lineNbr : PX.Data.IBqlField { }
} Use the compound primary key to select a record, as shown in the following                     code. SOLine line = SOLine.PK.Find(
    this, split.OrderType, split.OrderNbr, split.LineNbr.Value); ]]></column>
		</row>
		<row PageID="20b9a017-ff40-42b7-843c-94f2fced764e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e2da509a-0240-ca34-2133-6ecb33d67eb4" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can define a foreign key based on the primary key of the parent data access class (DAC) and select records by this key, as described in this topic.
==To Define a Foreign Key and Use It to Select Records==[anchor|#_c0f37de8-cbde-4a87-826e-5b150e7a712b]
#In the DAC of the parent table, define the primary key, as described in [HelpRoot_Dev_Platform\AD__how_Define_Primary_Key|To Define a Primary Key]. The following code shows an example of the definition of the primary key that is used in the following code examples in this instruction.<source lang="csharp">public partial class SOOrder : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf&lt;SOOrder&gt;.By&lt;orderType, orderNbr&gt;
    {
        public static SOOrder Find(
            PXGraph graph, string orderType, string orderNbr) 
            =&gt; FindBy(graph, orderType, orderNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
} </source>
#In the DAC of the child table, define the foreign key based on the primary key of the parent table, as shown below.<source lang="csharp">public partial class SOLine : PX.Data.IBqlTable
{
    public class SOOrderFK : SOOrder.PK.ForeignKeyOf&lt;SOLine&gt;
        .By&lt;orderType, orderNbr&gt; { }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
}</source>
#Use the foreign key to select the parent record or child records, as shown in the following code.<source lang="csharp">//Select the parent record
SOOrder order = SOLine.SOOrderFK.FindParent(this, soLine);
//Select the child records
IEnumerable&lt;SOLine&gt; lines = SOLine.SOOrderFK.SelectChildren(this, soOrder);</source>

==Related Articles==
*[HelpRoot_Dev_Platform\AD__con_PK_and_FK_API|Establishment of a Relationship Between Two DACs]]]></column>
			<column name="PlainText"><![CDATA[To Define a Foreign Key You can define a foreign key based on the primary key of the parent data access class                 (DAC) and select records by this key, as described in this topic. To Define a Foreign Key and Use It to Select Records In the DAC of the parent table, define the primary key, as described in  To Define a Primary Key. The following code shows an example of the definition of the primary key                     that is used in the following code examples in this                     instruction. public partial class SOOrder : PX.Data.IBqlTable
{
    public class PK : PrimaryKeyOf<SOOrder>.By<orderType, orderNbr>
    {
        public static SOOrder Find(
            PXGraph graph, string orderType, string orderNbr) 
            => FindBy(graph, orderType, orderNbr);
    }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
}  In the DAC of the child table, define the foreign key based on the primary key                     of the parent table, as shown                     below. public partial class SOLine : PX.Data.IBqlTable
{
    public class SOOrderFK : SOOrder.PK.ForeignKeyOf<SOLine>
        .By<orderType, orderNbr> { }

    public abstract class orderType : PX.Data.IBqlField { }
    public abstract class orderNbr : PX.Data.IBqlField { }
} Use the foreign key to select the parent record or child records, as shown in                     the following                     code. //Select the parent record
SOOrder order = SOLine.SOOrderFK.FindParent(this, soLine);
//Select the child records
IEnumerable<SOLine> lines = SOLine.SOOrderFK.SelectChildren(this, soOrder); ]]></column>
		</row>
		<row PageID="3ae29586-f0b3-4d86-a0c2-86ed55c4ce54" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can learn how to store graph data in the session and use slots to cache data objects.&#xA;==In This Chapter==[anchor|#_85df8233-e963-40e5-86fe-8f6433e4838b]&#xA;*[HelpRoot_Dev_Platform\AD__con_Session|Session]&#xA;*[HelpRoot_Dev_Platform\AD__con_Session_Sharing|Session Sharing Between Application Servers]&#xA;*[HelpRoot_Dev_Platform\AD__con_Storing_In_Session|Storing of Graph Data in the Session]&#xA;*[HelpRoot_Dev_Platform\AD__con_Using_Slots_to_Cache_Data|Use of Slots to Cache Data Objects]&#xA;" PlainText="Working with Data in Cache and Session In this chapter, you can learn how to store graph data in the session and use slots to cache     data objects. In This Chapter SessionSession Sharing Between Application ServersStoring of Graph Data in the SessionUse of Slots to Cache Data Objects" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="cb64541b-a218-e5fa-ac97-d6679dade211" RecordSourceID="22377" />
		<row PageID="4009fc41-b1ec-4e2d-9940-c92a32d5ca9b" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="6ec1b271-dcfb-51bd-7e8e-f8be202582dc" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The Acumatica ERP server creates a separate session for each browser tab or window that opens an Acumatica ERP form.{br}

The server creates the first session for a user after the user authorization when the starting form is loading. Then the server does the following:[anchor|#_657433bf-123b-4e9b-96b2-c8ca798626d9]
*Saves the user authorization data (<tt>.ASPXAUTH</tt>) and the session ID (<tt>ASP.NET&#95;SessionID</tt>) in the browser cookies for the website URL
*Creates the shared session data to be used for the Acumatica ERP forms opened in new browser tabs and windows
*Saves the shared session data in the storage that is specified in the website configuration
{br}

When the user opens a form of Acumatica ERP in a new browser tab, the server creates a new session that is based on the previous session data. To access the shared data, the server uses the session ID from the cookies, which are added to the request by the browser.{br}

The following diagram shows how the server of Acumatica ERP manages the shared session data that is used for multiple sessions of a single user.[anchor|#_08e0ef00-e124-4945-9880-2942edc76761][anchor|#_e63df35d-20e7-437f-af8b-18a0d33b33b5][image:StudioDeveloperGuide/Images/OV_Architecture_SessionSplit.png|popup|Use of shared data for multiple sessions of a user|450px]{br}

If the session data has been changed during the processing of a request, the server updates the data in the shared session data store. For example, if the user clicks '''Copy''' on a form toolbar to copy the form data, the data is stored in the shared session, so that it is accessible for the '''Paste''' action in another session of the same user.{br}

To distinguish different sessions that have the same <tt>ASP.NET&#95;SessionID</tt>, the server adds to each new session a unique identifier that consists of the ''W'' character and a number value wrapped in parentheses. In the browser, you can see such an identifier in the site URL, as with the bolded part in the following example: ''http://localhost/MySite/'''(W(3))'''/Main.aspx?ScreenId=AR301000''.]]></column>
			<column name="PlainText"><![CDATA[Session The  Acumatica ERP    server creates a separate session for each browser tab or window that opens an  Acumatica ERP    form. The server creates the first session for a user after the user authorization when the starting    form is loading. Then the server does the following: Saves the user authorization data ( .ASPXAUTH ) and the session ID       ( ASP.NET_SessionID ) in the browser cookies for the website URL Creates the shared session data to be used for the  Acumatica ERP      forms opened in new browser tabs and windows Saves the shared session data in the storage that is specified in the website      configuration When the user opens a form of  Acumatica ERP in    a new browser tab, the server creates a new session that is based on the previous session data.    To access the shared data, the server uses the session ID from the cookies, which are added to    the request by the browser. The following diagram shows how the server of  Acumatica ERP    manages the shared session data that is used for multiple sessions of a single user. Use of shared data for multiple sessions of a user If the session data has been changed during the processing of a request, the server updates the    data in the shared session data store. For example, if the user clicks      Copy  on a form toolbar to copy the form data, the data is stored in the    shared session, so that it is accessible for the  Paste  action in another    session of the same user. To distinguish different sessions that have the same  ASP.NET_SessionID , the    server adds to each new session a unique identifier that consists of the  W  character and a    number value wrapped in parentheses. In the browser, you can see such an identifier in the site    URL, as with the bolded part in the following example:      http://localhost/MySite/ (W(3)) /Main.aspx?ScreenId=AR301000 . ]]></column>
		</row>
		<row PageID="18374228-1e14-48e1-bc40-4f3b526928ed" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="9d02fffe-a98c-e673-7442-d2e43d40265a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To achieve horizontal scalability and fault tolerance, an application written with Acumatica Framework can be configured to run in a cluster of application servers behind a load balancer. With this configuration, it is not possible to predict the application server that will receive the next request from the client. In this model, session specific data must be shared between the application servers.{br}

The following diagram shows difference in storing session data on a stand-alone server and in a cluster. On a stand-alone Acumatica ERP server, session data is stored in the server memory. In a cluster of application servers, session data must be serialized and stored in a high-performance remote server, such as Redis or Microsoft SQL.[anchor|#_8bd7a8fb-c020-4236-8203-993df5e8b717][anchor|#_89f3fdb7-659f-4eb9-9d7a-d48f176ac3a0][image:StudioDeveloperGuide/Images/OV_Acumatica_And_Web_SessionOnCluster_01.png|popup|Storing session data on a stand-alone server and in a cluster|445px]{br}

The cost of serialization and the amount of data that need to be shared between application servers is often the main challenge to scaling complex business applications horizontally.{br}

 Acumatica Framework implements the following techniques to address issues related to session-state management without sacrificing performance, fault tolerance, or scalability:[anchor|#_90bde1b7-de6b-4388-bc12-49e04fa99454]
*Objects on the application server are created on each request and disposed after the request execution. The application state is preserved in the session through the serialization mechanism.
*Data serialized into the session is minimized to store only modified data (inserted, deleted, held and modified records). (Serialization and retrieval times are directly proportional to the size of the serialized data.) 
*The rest of the data is extracted from the database on demand and built around the session data. (A custom algorithm that extracts only the data required for the current request execution from the database is implemented.)
*A custom serialization mechanism is implemented to serialize only relevant data and reduce the amount of service information. (The standard serialization mechanism implemented in the Microsoft .NET platform is generic and cannot be optimized when used for a specific task.)
*Hash tables, constraints, relations, and indexes concerned with the execution of business logic are created strictly on demand. This technique allows the user to avoid execution of these operations on each request if not needed. (Creation of indexes, constrains, hash tables, and relations consumes a significant amount of CPU and runtime memory.)
]]></column>
			<column name="PlainText"><![CDATA[Session Sharing Between Application Servers To achieve horizontal scalability and fault tolerance, an application written with  Acumatica Framework can be    configured to run in a cluster of application servers behind a load balancer. With this    configuration, it is not possible to predict the application server that will receive the next    request from the client. In this model, session specific data must be shared between the    application servers. The following diagram shows difference in storing session data on a stand-alone server and in a    cluster. On a stand-alone  Acumatica ERP    server, session data is stored in the server memory. In a cluster of application servers, session    data must be serialized and stored in a high-performance remote server, such as Redis or    Microsoft SQL. Storing session data on a stand-alone server and in a cluster The cost of serialization and the amount of data that need to be shared between application    servers is often the main challenge to scaling complex business applications horizontally.  Acumatica Framework    implements the following techniques to address issues related to session-state management without    sacrificing performance, fault tolerance, or scalability: Objects on the application server are created on each request and disposed after the request     execution. The application state is preserved in the session through the serialization     mechanism. Data serialized into the session is minimized to store only modified data (inserted, deleted,     held and modified records). (Serialization and retrieval times are directly proportional to the     size of the serialized data.)  The rest of the data is extracted from the database on demand and built around the session     data. (A custom algorithm that extracts only the data required for the current request execution     from the database is implemented.) A custom serialization mechanism is implemented to serialize only relevant data and reduce     the amount of service information. (The standard serialization mechanism implemented in the     Microsoft .NET platform is generic and cannot be optimized when used for a specific task.) Hash tables, constraints, relations, and indexes concerned with the execution of business     logic are created strictly on demand. This technique allows the user to avoid execution of these     operations on each request if not needed. (Creation of indexes, constrains, hash tables, and     relations consumes a significant amount of CPU and runtime memory.) ]]></column>
		</row>
		<row PageID="7de20fae-aa20-407b-976d-38f05fb4083c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8a008218-47e7-8f6f-ef3f-b2f6a599eb8d" RecordSourceID="22377">
			<column name="Content"><![CDATA[
 Acumatica ERP keeps all modified data records in the cache. Therefore, you do not change a data record in the database directly when you modify its value in the user interface.{br}

((({S:Hint}The system commits the changes to the database in the following cases:[anchor|#_d084d1f7-53f7-47ca-9776-29e213bf075c]
*The user clicks '''Save'''.
*A request is sent through the Web Service API.
*The <tt>Actions.PressSave</tt> method is invoked on the graph instance.
*The <tt>PXAutoSaveAttribute</tt> attribute is defined for a data access class. As a result, the <tt>PXCache&lt;&gt;.Unload</tt> method automatically stores in the database all the changes of the appropriate data records at the end of each round trip.
))){br}

A graph instance exists on the server only while a user request is being processed, and it is destroyed right after this processing. The following diagram shows that a graph instance is created to process a user request on the Acumatica ERP server and destroyed once processing is completed.[anchor|#_b0e1ca8e-5ccd-46ed-8807-6f4cc058a49f][anchor|#_324bab80-c93c-4b70-bde2-296e93423a4a][image:StudioDeveloperGuide/Images/REF_Graph_RoundTrips.png|popup|Processing of user requests|450px]In the diagram above, the blue rectangles labeled 1, 2, 3, and 4 indicate the lifetime of graph instances. After a graph instance completes the processing of a request, the system stores the graph state in the session. It also stores the inserted, deleted, held, and modified records of the cache that are required to restore the state and data of the graph for the processing of the subsequent user request on the same Acumatica ERP form.((({S:Hint}On a stand-alone Acumatica ERP server, session data is stored in the server memory. In a cluster of Acumatica ERP servers, session data must be serialized and stored in external high-performance session state storage. (For more information on storing session data in a cluster, see [HelpRoot_Dev_Platform\AD__con_Session_Sharing|Session Sharing Between Application Servers].)
))){br}

For a user request on an Acumatica ERP form, the following operations are executed in the system:[anchor|#_2e54d58a-73d7-4728-8a7e-69a985eb9df8]
#The application server creates a graph instance that is specified in the <tt>TypeName</tt> property of the <tt>PXDataSource</tt> control of the form. (For more information about the initialization of graph views, caches, actions, and event handlers, see [HelpRoot_Dev_Platform\BL__con_Execution_of_Event_Handlers#_57644a4b-f2b5-4ff0-bf72-622bf84d90f7|Initialization of an Event Handler Collection].)
#If the user session contains graph data that has been stored during a previous request, the system loads the graph state and the cache data from the session.
#The graph instance processes the requested data on the data view that is specified in the ASPX code in the <tt>DataMember</tt> property of the control container for the data to be processed. To process the data, the system invokes the <tt>ExecuteSelect</tt>, <tt>ExecuteInsert</tt>, <tt>ExecuteUpdate</tt>, or <tt>ExecuteDelete</tt> method of the graph, based on the request type. The invoked method implements the logic of the appropriate scenario to add the request data to the cache and to execute the event handlers defined for the data fields and records in the cache. (See [HelpRoot_Dev_Platform\BL__con_Events_Scenarios|Data Manipulation Scenarios] for details.) The cache then merges the data retrieved from the database with the data restored from the session, and the application accesses the data as if the entire data set had been preserved from the time of the previous request.
#The graph instance returns the request results to the <tt>PXDatasource</tt> control of the form.
#The system stores in the session the graph state and the modified data of the cache.
#:((({S:Hint}Because the graph instance is no longer being used by the application server, the .NET Framework garbage collector then clears the memory allocated for the graph instance.
)))
{br}

While a graph is instantiated, all the cached data of the graph is saved in the appropriate <tt>PXCache</tt> objects that are created in the graph instance based on the data access class (DAC) declarations. To preserve the modified entity data between user requests, the cache controller saves the <tt>Updated</tt>, <tt>Inserted</tt>, <tt>Deleted</tt>, and <tt>Held</tt> collections of each <tt>PXCache</tt> object in the session.{br}

The following diagram shows how the graph state and cache data are stored in the <tt>Session</tt> object.[anchor|#_9fc1db28-f79b-4ce8-a3c3-898a1f0a9add][anchor|#_7a606a7b-0377-405c-97bf-b71eb3460322][image:StudioDeveloperGuide/Images/REF_Graph_Cache_Session.png|popup|The graph data stored in the session|450px]In the diagram above, notice the following:[anchor|#_5432ba5b-89f4-4c0d-b433-6583d36b6587]
*The items of the graph instance are stored in the <tt>GraphInfo</tt> collection of the <tt>Session</tt> object as a key-value pair, where the <tt>key</tt> is equal to the full name of the graph.
*The items of a <tt>PXCache</tt> object are stored in the <tt>CacheInfo</tt> collection of the <tt>Session</tt> object as a key-value pair, where the <tt>key</tt> consists of the following parts separated by the ''$'' symbol:
*#The full name of the graph
*#The full name of the DAC
((({S:Hint}When you instantiate a graph from code, the system will not load data from the session, because you may want to perform redirection or other processing. You can direct the system to load this data by using the <tt>PXPreserveScope</tt> class, as the following code snippet shows.{{{{using (new PXPreserveScope())
{
  GraphName graph = PXGraph.CreateInstance&lt;GraphName&gt;();
  graph.Load();
  ...
}
}}}}
)))]]></column>
			<column name="PlainText"><![CDATA[Storing of Graph Data in the Session  Acumatica ERP keeps all modified data records in the cache. Therefore, you do not change a data record in       the database directly when you modify its value in the user interface. The system commits the changes to the database in the following cases: The user clicks  Save . A request is sent through the Web Service API. The  Actions.PressSave  method is invoked on the graph instance. The  PXAutoSaveAttribute  attribute is defined for a data access             class. As a result, the  PXCache<>.Unload  method automatically             stores in the database all the changes of the appropriate data records at the end of             each round trip. A graph instance exists on the server only while a user request is being processed, and it is       destroyed right after this processing. The following diagram shows that a graph instance is       created to process a user request on the  Acumatica ERP server and destroyed once processing is completed. Processing of user requests In the diagram above, the blue rectangles labeled 1, 2, 3, and 4 indicate the lifetime       of graph instances. After a graph instance completes the processing of a request, the system       stores the graph state in the session. It also stores the inserted, deleted, held, and       modified records of the cache that are required to restore the state and data of the graph for       the processing of the subsequent user request on the same  Acumatica ERP form. On a stand-alone  Acumatica ERP server, session data is stored in the server memory. In a cluster of  Acumatica ERP servers, session data must be serialized and stored in external high-performance session         state storage. (For more information on storing session data in a cluster, see  Session Sharing Between Application Servers.) For a user request on an  Acumatica ERP form, the following operations are executed in the system: The application server creates a graph instance that is specified in the              TypeName  property of the  PXDataSource  control of           the form. (For more information about the initialization of graph views, caches, actions,           and event handlers, see  Initialization of an Event Handler Collection.) If the user session contains graph data that has been stored during a previous request,           the system loads the graph state and the cache data from the session. The graph instance processes the requested data on the data view that is specified in           the ASPX code in the  DataMember  property of the control container for           the data to be processed. To process the data, the system invokes the              ExecuteSelect ,  ExecuteInsert ,              ExecuteUpdate , or  ExecuteDelete  method of the           graph, based on the request type. The invoked method implements the logic of the           appropriate scenario to add the request data to the cache and to execute the event           handlers defined for the data fields and records in the cache. (See  Data Manipulation Scenarios for details.) The cache then merges the data           retrieved from the database with the data restored from the session, and the application           accesses the data as if the entire data set had been preserved from the time of the           previous request. The graph instance returns the request results to the  PXDatasource            control of the form. The system stores in the session the graph state and the modified data of the             cache. Because the graph instance is no longer being used by the application             server, the .NET Framework garbage collector then clears the memory allocated for the             graph instance. While a graph is instantiated, all the cached data of the graph is saved in the appropriate          PXCache  objects that are created in the graph instance based on the data       access class (DAC) declarations. To preserve the modified entity data between user requests,       the cache controller saves the  Updated ,  Inserted ,          Deleted , and  Held  collections of each          PXCache  object in the session. The following diagram shows how the graph state and cache data are stored in the          Session  object. The graph data stored in the session In the diagram above, notice the following: The items of the graph instance are stored in the  GraphInfo            collection of the  Session  object as a key-value pair, where the              key  is equal to the full name of the graph. The items of a  PXCache  object are stored in the              CacheInfo  collection of the  Session  object as a           key-value pair, where the  key  consists of the following parts separated           by the  $  symbol: The full name of the graph The full name of the DAC When you instantiate a graph from code, the system will not load data from the session,         because you may want to perform redirection or other processing. You can direct the system         to load this data by using the  PXPreserveScope  class, as the following         code snippet         shows. using (new PXPreserveScope())
{
  GraphName graph = PXGraph.CreateInstance<GraphName>();
  graph.Load();
  ...
} ]]></column>
		</row>
		<row PageID="7d60ac9e-ff6c-40fc-a593-52e1545493fe" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2d7f5fd6-5336-4ff7-5da4-e03019bb8635" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you have to cache a data object from your code, you can use the slots provided by the <tt>PXContext</tt> and <tt>PXDatabase</tt> classes. By using these slots, you can cache any type of data object without restrictions.{br}

A slot provided by the <tt>PXContext</tt> class exists in the memory of the application server only during the current HTTP request. Therefore, you can use these slots for quick data exchange between different server modules while the server processes a single request.{br}

A slot of the <tt>PXDatabase</tt> class is stored in the server memory until you clear the slot. Therefore, you can use such a slot to cache a data object for a long time—for example, to read the cached data during a future HTTP request.{br}

If a <tt>PXDatabase</tt> slot is used to cache the data that is obtained from the database tables, you can use a special API to automatically update the data in the slot when any of these tables has been changed.{br}

For detailed information on using slots, see the sections of this topic.{br}{TOC}[anchor|#_d38fe24d-5e23-4635-8ade-ede9f4dca92b]
==Caching Data in <tt>PXContext</tt> Slots==
If you need to keep a data object during a single HTTP request, we recommend that you cache the object in a slot provided by the <tt>PXContext</tt> class.{br}

You can use the following public static methods of the class to save a data object in a slot.[anchor|#_7857047f-a58e-4ae3-94a4-c8fb46ff2fb9]
{| class="checklist" | width="100%" 
|- 
!width="33%" ! Method
!width="66%" ! Description
|- 
| {{public static ObjectType SetSlot<ObjectType> (ObjectType value)}}
| Stores the specified data object under the key that is created on the base of the object type.
|- 
| {{public static ObjectType SetSlot<ObjectType> (string key, ObjectType value)}}
| Stores the specified data object under the key that is defined by the first parameter.
|}{br}

The following example shows how you can save the {{MyData}} object in the slot of the current HTTP context under the key that is the same as the object type.{{{{PXContext.SetSlot&lt;MyDataType&gt;(MyData);
}}}}{br}

To get a data object that is cached in the current HTTP context, you can use the following methods of the <tt>PXContext</tt> class.[anchor|#_7fe848ff-33a9-4e7d-96a5-b0093339c27c]
{| class="checklist" | width="100%" 
|- 
!width="33%" ! Method
!width="66%" ! Description
|- 
| {{public static ObjectType GetSlot<ObjectType>()}}
| Returns the data object that is cached under the key that is created on the base of the object type.
|- 
| {{public static ObjectType GetSlot<ObjectType> (string key)}}
| Returns the data object that is cached under the specified key.
|}{br}

The following example shows how you can get from the slot of the current HTTP context the {{MyData}} object that is cached under the ''MyData22'' key.{{{{var MyData = PXContext.GetSlot&lt;MyDataType&gt;("MyData22");
}}}}{br}

The following diagram illustrates how you can use a data object cached by using a slot provided by the <tt>PXContext</tt> class.[anchor|#_8597511b-4063-4c7a-a8fe-c288554bf6e1][anchor|#_6a284050-7ecb-46ff-b8f9-3fb971a39299][image:StudioDeveloperGuide/Images/UsingSlotsToCacheData01.png|popup|Caching data in a slot of the <tt>PXContext</tt> class|355px]{br}

You do not need to delete the data saved in the <tt>PXContext</tt> class slots, because the system deletes these slots from the server memory along with the data of the current HTTP context created for the current request.[anchor|#_020dad6c-309a-4ecf-acd9-684fb03a39b3]
==Caching Data in <tt>PXDatabase</tt> Slots==
If you need to keep a data object in the server memory for a long time, we recommend that you cache the object in a slot provided by the <tt>PXDatabase</tt> class.{br}

You can use the following public static methods of the class to cache a data object in a slot and to get the cached object from the slot.[anchor|#_31a95fcc-9507-4952-bf43-09f403eb4cc4]
{| class="checklist" | width="100%" 
|- 
!width="33%" ! Method
!width="66%" ! Description
|- 
| {{public static ObjectType GetSlot<ObjectType> (string key, params Type[] tables)}}
| If the <tt>PXDatabase</tt> slots contain a valid data object of the specified type saved under the key defined by the first parameter, returns this data object. Otherwise, the method creates a new object of the specified type, saves this empty object in the slot under the key defined by the first parameter, and returns the data object that is used by the calling code to save the needed data. The list of the table types specified in the <tt>params</tt> parameter is used to invalidate the slot if any table of the list has been changed in the database.((({S:Hint}If this method is used to cache a data object of an {{ObjectType}} class inherited from the <tt>IPrefetchable&lt;&gt;</tt> interface, the <tt>GetSlot&lt;&gt;</tt> method invokes the <tt>Prefetch</tt> method of the object without a parameter.
)))
|- 
| {{public static ObjectType GetSlot<ObjectType, Parameter> (string key, Parameter parameter, params Type[] tables)}}
| Is used for caching a data object of an {{ObjectType}} class inherited from the <tt>IPrefetchable&lt;&gt;</tt> interface to provide automatic update of the object in the slot. If the <tt>PXDatabase</tt> slots contain a valid data object of the specified type saved under the key defined by the first parameter, the method returns this data object. Otherwise, the method does the following:[anchor|#_c2a7624f-a620-4099-ae77-cfdb3b5245d3]
#Creates a new object of the specified type
#To create or update data in the object, invokes the <tt>Prefetch</tt> method with the <tt>parameter</tt> specified in the second parameter
#Saves this object in the slot under the key defined by the first parameter
#Returns the data object to the calling method
The list of the table types specified in the <tt>params</tt> parameter is used to invalidate the slot in the case if any table of the list has been changed in the database. The use of this method is described below in the [[#_469c7eaf-0f4b-4cad-97f4-f4676e32419e|Automatically Updating Data in a PXDatabase Slot] section.
|}{br}

The following example shows how you can use the <tt>GetSlot&lt;ObjectType&gt; (string key, params Type&#91;&#93; tables)</tt> method to cache data under the ''MyData'' key in the slot of the <tt>PXDatabase</tt> class.{{{{...
  Dictionary&lt;string, string[]&gt; dict = 
    PXDatabase.GetSlot&lt;Dictionary&lt;string, string[]&gt;&gt;(
      "MyData", typeof(Table1), typeof(Table2), typeof(Table3));
  lock (((System.Collections.ICollection)dict).SyncRoot)
  {
...
    List&lt;string&gt; myList = new List&lt;string&gt;();
...
    string key = "myListKey";
    dict[key] = myList.ToArray();
  }
...
}}}}After the data object has been cached, you can access the object by using the following instruction.{{{{Dictionary&lt;string, string[]&gt; dict = 
          PXDatabase.GetSlot&lt;Dictionary&lt;string, string[]&gt;&gt;(
            "MyData", typeof(Table1), typeof(Table2), typeof(Table3));
}}}}{br}

You can clear a slot provided by the <tt>PXDatabase</tt> class by means of the following public static methods of the class.[anchor|#_794cb613-1f91-42dd-bca0-4b10d8c2bc99]
{| class="checklist" | width="100%" 
|- 
!width="33%" ! Method
!width="66%" ! Description
|- 
| {{public static void ResetSlot<ObjectType> (string key, params Type[] tables)}}
| Sets to ''null'' the value of the slot that has the specified key.
|- 
| {{public static void ResetSlots()}}
| Sets to ''null'' the value of each slot that is provided by the <tt>PXDatabase</tt> class.
|}{br}

The following example shows how you can clear the slot created in the example above.{{{{PXDatabase.ResetSlot&lt;MyDataType&gt;(
            "MyData", typeof(Table1), typeof(Table2), typeof(Table3));
}}}}[anchor|#_469c7eaf-0f4b-4cad-97f4-f4676e32419e]
==Automatically Updating Data in a <tt>PXDatabase</tt> Slot==
If a data object that is to be cached depends on data in the database, we recommend that you inherit the object class from the <tt>IPrefetchable&lt;&gt;</tt> interface and develop in this class the <tt>Prefetch</tt> method, to provide automatic updating of data in the object. Then the {{GetSlot<ObjectType, Parameter>(string key, Parameter parameter, params Type[] tables)}} method of the <tt>PXDatabase</tt> class will use the <tt>Prefetch</tt> method to update the data in the slot, if required. (See the description of the method in [[#_020dad6c-309a-4ecf-acd9-684fb03a39b3|Caching Data in PXDatabase Slots].){br}

For example, suppose that you need to develop a data provider that selects data from multiple tables of the database and caches the data in <tt>PXDatabase</tt> slots. To do this, you can develop the provider class based on the following code.{br}

{{{{public abstract class MyProvider : ProviderBase
{
  // Here you can add abstract definitions for all the methods of 
  // the PXDatabaseMyProvider class
}

public class PXDatabaseMyProvider : MyProvider
{

  private class MyDataObject : IPrefetchable&lt;PXDatabaseMyProvider&gt;
  {
    public MyDataType MyData = new MyData();

    public void Prefetch(PXDatabaseMyProvider provider)
    {
      // Here you can implement the code to generate data of the MyData object.
    }
  }

  private MyDataObject MyDataObj
  {
    get
    {
      return PXDatabase.GetSlot&lt;MyDataObject, PXDatabaseMyProvider&gt;(
        "MYDATA_SLOT_KEY",
               this, typeof(Table1), typeof(Table2), typeof(Table3)
               /* ,... Add here the types of all tables, any change in which 
               should make the slot invalid. */ );
    }
  }

  // Here you need to add the code for all the methods that are defined 
  // in the MyProvider abstract class.
  // These methods can be used to manage the MyData object.
...
}
}}}}{br}

The code above contains declarations of the following classes:[anchor|#_23bf13d3-2799-428a-8975-35a8532ddd5a]
*The {{MyProvider}} abstract class, which derives from the <tt>System.Configuration.Provider.ProviderBase</tt> public abstract class and is used to define implementation of the {{PXDatabaseMyProvider}} class.
*The {{PXDatabaseMyProvider}} class, which contains the following:
**The {{MyDataObject}} private class, which derives from the <tt>IPrefetchable&lt;PXDatabaseMyProvider&gt;</tt> interface and contains the following members:
***The {{MyData}} data object to be cached
***The <tt>Prefetch</tt> method, which creates or updates the data object
**An implementation of the methods that are declared in the {{MyProvider}} abstract class and used to manage to the {{MyData}} object. To access the data object stored in the database slot, in these methods, you can use the {{MyDataObject}} property of the {{PXDatabaseMyProvider}} class, as the following instruction shows.{{{{MyDataObject data = MyDataObj;
}}}}
{br}

For the code above, the following diagram shows how the data object is cached and automatically updated in the <tt>PXDatabase</tt> slot.[anchor|#_bdbae4c8-9113-42ab-bf35-54aa64356e85][anchor|#_8f92b6ac-f6d2-49e0-adf7-53649da04acf][image:StudioDeveloperGuide/Images/UsingSlotsToCacheData02.png|popup|Automatic update of the cached data|450px]{br}

((({S:Hint}If you have discovered that a <tt>PXDatabase</tt> slot returns legacy data, you can invoke the <tt>SelectTimeStamp()</tt> public static method of the <tt>PXDatabase</tt> class to invalidate all the <tt>PXDatabase</tt> slots that contain data obtained from the database tables that have been changed. Then the <tt>GetSlot</tt> method invokes the <tt>Prefetch</tt> method and updates the data in the slot.
)))]]></column>
			<column name="PlainText"><![CDATA[Use of Slots to Cache Data Objects If you have to cache a data object from your code, you can use the slots provided by the            PXContext  and  PXDatabase  classes. By using these         slots, you can cache any type of data object without restrictions. A slot provided by the  PXContext  class exists in the memory of the         application server only during the current HTTP request. Therefore, you can use these slots         for quick data exchange between different server modules while the server processes a single         request. A slot of the  PXDatabase  class is stored in the server memory until you         clear the slot. Therefore, you can use such a slot to cache a data object for a long         time—for example, to read the cached data during a future HTTP request. If a  PXDatabase  slot is used to cache the data that is obtained from the         database tables, you can use a special API to automatically update the data in the slot when         any of these tables has been changed. For detailed information on using slots, see the sections of this topic. Caching Data in  PXContext  Slots If you need to keep a data object during a single HTTP request, we recommend that you cache         the object in a slot provided by the  PXContext  class. You can use the following public static methods of the class to save a data object in a           slot. Method Description public static ObjectType SetSlot<ObjectType> (ObjectType                     value) Stores the specified data object under the key that is created on the base of                   the object type. public static ObjectType SetSlot<ObjectType> (string key,                     ObjectType value) Stores the specified data object under the key that is defined by the first                   parameter. The following example shows how you can save the  MyData  object in the slot         of the current HTTP context under the key that is the same as the object         type. PXContext.SetSlot<MyDataType>(MyData); To get a data object that is cached in the current HTTP context, you can use the following         methods of the  PXContext  class. Method Description public static ObjectType GetSlot<ObjectType>() Returns the data object that is cached under the key that is created on the                   base of the object type. public static ObjectType GetSlot<ObjectType> (string                   key) Returns the data object that is cached under the specified key. The following example shows how you can get from the slot of the current HTTP context the            MyData  object that is cached under the  MyData22          key. var MyData = PXContext.GetSlot<MyDataType>("MyData22"); The following diagram illustrates how you can use a data object cached by using a slot         provided by the  PXContext  class. Caching data in a slot of the  PXContext  class You do not need to delete the data saved in the  PXContext  class slots,         because the system deletes these slots from the server memory along with the data of the         current HTTP context created for the current request. Caching Data in  PXDatabase  Slots If you need to keep a data object in the server memory for a long time, we recommend that         you cache the object in a slot provided by the  PXDatabase  class. You can use the following public static methods of the class to cache a data object in a         slot and to get the cached object from the slot. Method Description public static ObjectType GetSlot<ObjectType> (string key, params                     Type[] tables) If the  PXDatabase  slots contain a valid data object of the                   specified type saved under the key defined by the first parameter, returns this                   data object. Otherwise, the method creates a new object of the specified type,                   saves this empty object in the slot under the key defined by the first parameter,                   and returns the data object that is used by the calling code to save the needed                   data. The list of the table types specified in the  params                    parameter is used to invalidate the slot if any table of the list has been changed                   in the database. If this method is used to cache a data object of an                        ObjectType  class inherited from the                        IPrefetchable<>  interface, the                        GetSlot<>  method invokes the  Prefetch                      method of the object without a parameter. public static ObjectType GetSlot<ObjectType, Parameter> (string                     key, Parameter parameter, params Type[] tables) Is used for caching a data object of an  ObjectType  class                   inherited from the  IPrefetchable<>  interface to provide                   automatic update of the object in the slot. If the  PXDatabase                    slots contain a valid data object of the specified type saved under the key                   defined by the first parameter, the method returns this data object. Otherwise,                   the method does the following: Creates a new object of the specified type To create or update data in the object, invokes the                          Prefetch  method with the  parameter                        specified in the second parameter Saves this object in the slot under the key defined by the first                       parameter Returns the data object to the calling method The list of the table types specified in the  params                    parameter is used to invalidate the slot in the case if any table of the list has                   been changed in the database. The use of this method is described below in the                      Automatically Updating Data in a PXDatabase Slot Automatically Updating Data in a PXDatabase Slot section. The following example shows how you can use the  GetSlot<ObjectType> (string           key, params Type[] tables)  method to cache data under the  MyData  key in         the slot of the  PXDatabase          class. ...
  Dictionary<string, string[]> dict = 
    PXDatabase.GetSlot<Dictionary<string, string[]>>(
      "MyData", typeof(Table1), typeof(Table2), typeof(Table3));
  lock (((System.Collections.ICollection)dict).SyncRoot)
  {
...
    List<string> myList = new List<string>();
...
    string key = "myListKey";
    dict[key] = myList.ToArray();
  }
... After         the data object has been cached, you can access the object by using the following         instruction. Dictionary<string, string[]> dict = 
          PXDatabase.GetSlot<Dictionary<string, string[]>>(
            "MyData", typeof(Table1), typeof(Table2), typeof(Table3)); You can clear a slot provided by the  PXDatabase  class by means of the         following public static methods of the class. Method Description public static void ResetSlot<ObjectType> (string key, params                     Type[] tables) Sets to  null  the value of the slot that has the specified key. public static void ResetSlots() Sets to  null  the value of each slot that is provided by the                      PXDatabase  class. The following example shows how you can clear the slot created in the example         above. PXDatabase.ResetSlot<MyDataType>(
            "MyData", typeof(Table1), typeof(Table2), typeof(Table3)); Automatically Updating Data in a  PXDatabase  Slot If a data object that is to be cached depends on data in the database, we recommend that         you inherit the object class from the  IPrefetchable<>  interface and         develop in this class the  Prefetch  method, to provide automatic updating         of data in the object. Then the  GetSlot<ObjectType, Parameter>(string key,           Parameter parameter, params Type[] tables)  method of the            PXDatabase  class will use the  Prefetch  method to         update the data in the slot, if required. (See the description of the method in  Caching Data in PXDatabase Slots Caching Data in PXDatabase Slots.) For example, suppose that you need to develop a data provider that selects data from         multiple tables of the database and caches the data in  PXDatabase  slots.         To do this, you can develop the provider class based on the following code. public abstract class MyProvider : ProviderBase
{
  // Here you can add abstract definitions for all the methods of 
  // the PXDatabaseMyProvider class
}

public class PXDatabaseMyProvider : MyProvider
{

  private class MyDataObject : IPrefetchable<PXDatabaseMyProvider>
  {
    public MyDataType MyData = new MyData();

    public void Prefetch(PXDatabaseMyProvider provider)
    {
      // Here you can implement the code to generate data of the MyData object.
    }
  }

  private MyDataObject MyDataObj
  {
    get
    {
      return PXDatabase.GetSlot<MyDataObject, PXDatabaseMyProvider>(
        "MYDATA_SLOT_KEY",
               this, typeof(Table1), typeof(Table2), typeof(Table3)
               /* ,... Add here the types of all tables, any change in which 
               should make the slot invalid. */ );
    }
  }

  // Here you need to add the code for all the methods that are defined 
  // in the MyProvider abstract class.
  // These methods can be used to manage the MyData object.
...
} The code above contains declarations of the following classes: The  MyProvider  abstract class, which derives from the                System.Configuration.Provider.ProviderBase  public abstract class             and is used to define implementation of the  PXDatabaseMyProvider              class. The  PXDatabaseMyProvider  class, which contains the following: The  MyDataObject  private class, which derives from the                    IPrefetchable<PXDatabaseMyProvider>  interface and contains                 the following members: The  MyData  data object to be cached The  Prefetch  method, which creates or updates the data                     object An implementation of the methods that are declared in the                    MyProvider  abstract class and used to manage to the                    MyData  object. To access the data object stored in the database                 slot, in these methods, you can use the  MyDataObject  property of                 the  PXDatabaseMyProvider  class, as the following instruction                 shows. MyDataObject data = MyDataObj; For the code above, the following diagram shows how the data object is cached and         automatically updated in the  PXDatabase  slot. Automatic update of the cached data If you have discovered that a  PXDatabase  slot returns legacy data,           you can invoke the  SelectTimeStamp()  public static method of the              PXDatabase  class to invalidate all the  PXDatabase            slots that contain data obtained from the database tables that have been changed. Then the              GetSlot  method invokes the  Prefetch  method and           updates the data in the slot. ]]></column>
		</row>
		<row PageID="6aea8e6f-3cc6-4f61-88a3-d7f49cd6c4b7" Language="en-US" PageRevisionID="1" Content="&#xA;The topics in this part of the guide explain how to implement business logic of an application based on Acumatica Framework.&#xA;==In This Part==[anchor|#ul_m1f_qxh_cl]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Working_With_Events|Working with Events]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Working_With_Attributes|Working with Attributes]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Working_with_Attachments|Working with Attachments]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Configuring_UI_from_Back_End|Configuring the UI from the Back End]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Executing_Code_Asynchronously|Executing Code Asynchronously]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Localizing_Applications|Localizing Applications]&#xA;*[HelpRoot_Dev_Platform\BL__mng_Reusing_Business_Logic|Reusing Business Logic]&#xA;" PlainText="Implementing Business Logic The topics in this part of the guide explain how to implement business logic of an                 application based on  Acumatica Framework. In This Part Working with EventsWorking with AttributesWorking with AttachmentsConfiguring the UI from the Back EndExecuting Code AsynchronouslyLocalizing ApplicationsReusing Business Logic" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="5bd4a233-df9a-df77-5237-8d3571563ee5" RecordSourceID="22377" />
		<row PageID="106557db-e5f6-416c-8872-5ef3de9bf433" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8ca427e9-12ef-29ff-9b22-07363cd529d6" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The Acumatica Framework provides its own event model in which events related to the manipulation of data records and data fields are raised in a particular order within certain scenarios. An ''event handler'' is a method invoked by the Acumatica Framework once the corresponding event is raised.{br}

By implementing event handlers, application developers can add business logic for the manipulation of data within business logic controllers (BLCs). This business logic includes the validation and calculation of field values, the management of data records (inserting, updating, or deleting), the checks for duplicate records, and the implementation of the presentation logic of the user interface.
==In This Chapter==[anchor|#_0a1f7b39-caa1-44c3-aaba-93a7ce18679f]
*[HelpRoot_Dev_Platform\BL__con_Event_Handler|Event Handlers]
*[HelpRoot_Dev_Platform\BL__con_Execution_of_Event_Handlers|Execution of Event Handlers]
*[HelpRoot_Dev_Platform\BL__con_Events_Scenarios|Data Manipulation Scenarios]
*[HelpRoot_Dev_Platform\BL__con_Events_Insert|Sequence of Events: Insertion of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Update|Sequence of Events: Update of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Delete|Sequence of Events: Deletion of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Display|Sequence of Events: Display of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Persist|Sequence of Events: Saving of Changes to the Database]
*[HelpRoot_Dev_Platform\BL__con_Events_All|List of Events]
]]></column>
			<column name="PlainText"><![CDATA[Working with Events The  Acumatica Framework     provides its own event model in which events related to the manipulation of data records and     data fields are raised in a particular order within certain scenarios. An  event handler      is a method invoked by the  Acumatica Framework once     the corresponding event is raised. By implementing event handlers, application developers can add business logic for the     manipulation of data within business logic controllers (BLCs). This business logic includes the     validation and calculation of field values, the management of data records (inserting, updating,     or deleting), the checks for duplicate records, and the implementation of the presentation logic     of the user interface. In This Chapter Event HandlersExecution of Event HandlersData Manipulation ScenariosSequence of Events: Insertion of a Data RecordSequence of Events: Update of a Data RecordSequence of Events: Deletion of a Data RecordSequence of Events: Display of a Data RecordSequence of Events: Saving of Changes to the DatabaseList of Events]]></column>
		</row>
		<row PageID="cd34176b-2ab9-42cc-890c-b6cb42cd433e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="604c1270-b4c7-ed16-4b88-c99f06e724f8" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The Acumatica Framework raises events in the context of a graph. An event handler can be implemented in a graph, as well as in an attribute of a data field.
==Graph and Attribute Event Handlers==
''Graph event handlers'' are defined as methods in a business logic controller (BLC) class for a particular data access class (DAC) or a particular DAC field. See the topics in the [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3ce58733-bf9c-d909-ae69-01db28ec45f6|PX.Data Delegates] section in the API Reference for each event for an example of a graph event handler declaration.{br}

''Attribute event handlers'' are defined as methods in attribute classes. The logic of the event handlers is attached to all DAC objects or data fields annotated with these attributes. The attribute in which an attribute event handler is implemented must be derived from the <tt>PXEventSubscriberAttribute</tt> class and must implement the interface of the {{IPX<EventName>Subscriber}} form (where {{<EventName>}} is replaced with the name of the needed event), as shown in the following example. <source lang="csharp">// The attribute implements handlers for the FieldVerifying
// and RowPersisting events
public class MyAttribute : PXEventSubscriberAttribute,
                           IPXFieldVerifyingSubscriber,
                           IPXRowPersistingSubscriber
{
     public virtual void FieldVerifying(PXCache sender,
                                        PXFieldVerifyingEventArgs e)
     {
         ...
     }

     public virtual void RowPersisting(PXCache sender,
                                       PXRowPersistingEventArgs e)
     {
         ...
     }
}</source>
==Related Articles==
*[HelpRoot_Dev_Platform\DA__con_Event_Handler_Naming|Naming Conventions for Event Handlers Defined in Graphs]]]></column>
			<column name="PlainText"><![CDATA[Event Handlers The  Acumatica Framework         raises events in the context of a graph. An event handler can be implemented in a graph, as         well as in an attribute of a data field. Graph and Attribute Event Handlers Graph event handlers  are defined as methods in a business logic controller (BLC) class     for a particular data access class (DAC) or a particular DAC field. See the topics in the  PX.Data Delegates PX.Data Delegates section in the API Reference for each     event for an example of a graph event handler declaration. Attribute event handlers  are defined as methods in attribute classes. The logic of the     event handlers is attached to all DAC objects or data fields annotated with these attributes.     The attribute in which an attribute event handler is implemented must be derived from the       PXEventSubscriberAttribute  class and must implement the interface of the       IPX<EventName>Subscriber  form (where  <EventName>  is     replaced with the name of the needed event), as shown in the following example.      // The attribute implements handlers for the FieldVerifying
// and RowPersisting events
public class MyAttribute : PXEventSubscriberAttribute,
                           IPXFieldVerifyingSubscriber,
                           IPXRowPersistingSubscriber
{
     public virtual void FieldVerifying(PXCache sender,
                                        PXFieldVerifyingEventArgs e)
     {
         ...
     }

     public virtual void RowPersisting(PXCache sender,
                                       PXRowPersistingEventArgs e)
     {
         ...
     }
} ]]></column>
		</row>
		<row PageID="4a062f32-f55b-4e0e-bc04-aa38683a69b5" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="bd145f64-f645-8164-4fc4-e1a632c8aefe" RecordSourceID="22377">
			<column name="Content"><![CDATA[In this topic, you can find information about how event handlers are executed and how to add and remove event handlers at run time.{br}{TOC}
==Execution of Event Handlers ==
All event handlers for a particular event share the same <tt>PXCache</tt> instance that has raised this event. The system creates a <tt>PXCache</tt> instance to control the modified data records of a particular data access class (DAC) type. The <tt>PXCache</tt> instance is always available as the first argument in an event handler; the second argument provides the specific data that corresponds to the event.{br}

Once an event is raised, the order in which the associated event handlers are executed may differ. For some events, the chain of graph event handlers is executed before the attribute event handlers are; the attribute event handlers are executed only if the <tt>Cancel</tt> property of the event arguments doesn&rsquo;t equal <tt>true</tt> after the execution of the graph event handlers.{br}

For other events, the attribute event handlers are executed first, and the graph event handlers are executed next. The topics in the [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3ce58733-bf9c-d909-ae69-01db28ec45f6|PX.Data Delegates] section in the API Reference for each event shows the order in which the system invokes handlers for a particular event.
==Dynamic Addition of Event Handlers ==
A business logic controller (BLC) includes the collections of graph event handlers for all events except <tt>CacheAttached</tt>. Each of these collections holds event handlers for a particular event and has the same name as the event. (You can find more information about how these collections are initialized in the [[#_57644a4b-f2b5-4ff0-bf72-622bf84d90f7|Initialization of an Event Handler Collection] section in this topic.) By using the methods of these collections, you can add and remove graph event handlers in code at run time.{br}

A method added as an event handler must have the signature of a graph event handler, but doesn&rsquo;t need to follow the naming convention for graph event handlers. If you want to add a method as an event handler, you invoke the {{AddHandler<>()}} method on the corresponding collection. For example, if the event is related to a row, it is invoked as follows.<source lang="csharp">RowEventName.AddHandler&lt;DACName&gt;(MethodName);</source>
The event is invoked as follows if it is related to a field.{{{{FieldEventName.AddHandler&lt;DACName.fieldName&gt;(MethodName);
}}}}{br}

When the {{AddHandler<>()}} method is invoked, event handlers are added to the collection as follows:[anchor|#ul_knk_frs_3k]
*Event handlers are added to the beginning of the collection for any event whose name ends with ''ing'' except the <tt>RowSelecting</tt> event.
*Event handlers are added to the end of the collection for any event whose name ends with ''ed'' and for the <tt>RowSelecting</tt> event.
{br}

To remove a handler, you should invoke the {{RemoveHandler<>()}} method.[anchor|#_57644a4b-f2b5-4ff0-bf72-622bf84d90f7]
==Initialization of an Event Handler Collection==
On each round trip, the <tt>PXGraph()</tt> constructor does the following while it initializes a graph instance:[anchor|#_a88e41fe-9e2d-418d-8e95-5e90f4b3960a]
#Creates the <tt>Cashes</tt>, <tt>Views</tt>, and <tt>Actions</tt> collections and other required collections. All of these collections are initially empty.
#If the graph instance is being created on the Acumatica ERP server for the first time:
##Obtains the metadata of this graph from the appropriate assembly (which is <tt>PX.Objects</tt> for most graphs in the application).
##By using the metadata, emits the <tt>InitializeDelegate</tt> method, which is designed to subscribe event handlers and to initialize graph views, caches, and actions. To process the metadata for the fields declared in the graph, the constructor invokes the <tt>PXGraph.ProcessFields</tt> static method. To process the metadata of the methods that are defined in the graph, the constructor invokes the <tt>PXGraph.ProcessMethods</tt> static method.
##:((({S:Hint}The <tt>ProcessMethods</tt> method processes the metadata of the methods that are declared in the graph and all extensions of the graph. According to the naming convention for event handlers, the ''&#95;'' symbol is a separator, so this method tries to split the name of each processed method into segments. If the name of the processed method has fewer than two segments or more than three segments, the processed method is skipped.{br}

If the name of the processed method adheres to the naming convention for record event handlers, the processed method is added to the <tt>&#95;EventsRow</tt> collection of the <tt>PXCache&lt;DACName&gt;</tt> object that is instantiated in the graph instance based on the DAC declaration. For example, the <tt>SOOrder&#95;RowSelected</tt> event handler is added to the <tt>&#95;EventsRow</tt> collection of the <tt>PXCache&lt;SOOrder&gt;</tt> cache object as an element with the <tt>RowSelected</tt> key.{br}

If the name of the processed method adheres to the naming convention for field event handlers, the processed method is added to the ''<tt>EventName</tt>'' <tt>Events</tt> collection of the <tt>PXCache&lt;DACName&gt;</tt> object. For example, the <tt>SOOrder&#95;CustomerID&#95;FieldUpdated </tt> event handler is added to the <tt>FieldUpdatedEvents</tt> collection of the <tt>PXCache&lt;SOOrder&gt;</tt> cache object as an element with the <tt>CustomerID</tt> key.
)))
##Saves the graph metadata and the <tt>InitializeDelegate</tt> emitted method in the Acumatica ERP server memory as the <tt>GraphStaticInfo</tt> static object shared for the entire application instance.
#From the <tt>GraphStaticInfo</tt> static object, invokes the <tt>InitializeDelegate</tt> method, which initializes graph views, caches, and actions; the method also adds event handler delegates to the appropriate event handler collections of the relevant <tt>PXCache</tt> objects.
{br}

The following diagram shows how an instance of the <tt>PX.Objects.SO.SOOrderEntry</tt> graph uses the <tt>PX.Objects</tt> assembly metadata to add the <tt>SOOrder&#95;CustomerID&#95;FieldUpdated() </tt> event handler (described in the graph and graph extensions) to the <tt>FieldUpdatedEvents</tt> collection of the <tt>PXCache&lt;SOOrder&gt;</tt> cache object.[anchor|#_6c5e505a-e960-473c-a292-205f398b72fe][anchor|#_059e8d12-89c1-400c-9fe1-cd7564fef1b1][image:StudioDeveloperGuide/Images/REF_Event_Handler_NamingConventions_01.png|popup|Addition of an event handler to the appropriate collection|450px]In the collection, the <tt>CustomerID</tt> field name is used as a key, and the delegate of the event handler sequence for the field processing is used as a value.]]></column>
			<column name="PlainText"><![CDATA[Execution of Event Handlers In this topic, you can find information about how event handlers are    executed and how to add and remove event handlers at run time. Execution of Event Handlers  All event handlers for a particular event share the same  PXCache  instance     that has raised this event. The system creates a  PXCache  instance to control     the modified data records of a particular data access class (DAC) type. The       PXCache  instance is always available as the first argument in an event     handler; the second argument provides the specific data that corresponds to the event. Once an event is raised, the order in which the associated event handlers are executed may     differ. For some events, the chain of graph event handlers is executed before the attribute     event handlers are; the attribute event handlers are executed only if the       Cancel  property of the event arguments doesn't equal  true      after the execution of the graph event handlers. For other events, the attribute event handlers are executed first, and the graph event     handlers are executed next. The topics in the  PX.Data Delegates PX.Data Delegates section in the API Reference for each     event shows the order in which the system invokes handlers for a particular event. Dynamic Addition of Event Handlers  A business logic controller (BLC) includes the collections of graph event handlers for all     events except  CacheAttached . Each of these collections holds event handlers     for a particular event and has the same name as the event. (You can find more information about     how these collections are initialized in the  Initialization of an Event Handler Collection Initialization of an Event Handler Collection section in this topic.) By using the methods of these collections, you can add     and remove graph event handlers in code at run time. A method added as an event handler must have the signature of a graph event handler, but     doesn't need to follow the naming convention for graph event handlers. If you want to add a     method as an event handler, you invoke the  AddHandler<>()  method on the     corresponding collection. For example, if the event is related to a row, it is invoked as     follows. RowEventName.AddHandler<DACName>(MethodName); The event is invoked as follows if it is related to a field. FieldEventName.AddHandler<DACName.fieldName>(MethodName); When the  AddHandler<>()  method is invoked, event handlers are added to     the collection as follows: Event handlers are added to the beginning of the collection for any event whose name ends      with  ing  except the  RowSelecting  event. Event handlers are added to the end of the collection for any event whose name ends with        ed  and for the  RowSelecting  event. To remove a handler, you should invoke the  RemoveHandler<>()      method. Initialization of an Event Handler Collection On each round trip, the  PXGraph()  constructor does the following while it     initializes a graph instance: Creates the  Cashes ,  Views , and         Actions  collections and other required collections. All of these       collections are initially empty. If the graph instance is being created on the  Acumatica ERP       server for the first time: Obtains the metadata of this graph from the appropriate assembly (which is           PX.Objects  for most graphs in the application). By using the metadata, emits the  InitializeDelegate  method, which is         designed to subscribe event handlers and to initialize graph views, caches, and actions. To         process the metadata for the fields declared in the graph, the constructor invokes the           PXGraph.ProcessFields  static method. To process the metadata of the         methods that are defined in the graph, the constructor invokes the           PXGraph.ProcessMethods  static method. The  ProcessMethods  method processes the metadata of the methods that           are declared in the graph and all extensions of the graph. According to the naming           convention for event handlers, the  _  symbol is a separator, so this method tries to           split the name of each processed method into segments. If the name of the processed method           has fewer than two segments or more than three segments, the processed method is           skipped. If the name of the processed method adheres to the naming convention for record event           handlers, the processed method is added to the  _EventsRow  collection of           the  PXCache<DACName>  object that is instantiated in the graph           instance based on the DAC declaration. For example, the             SOOrder_RowSelected  event handler is added to the             _EventsRow  collection of the  PXCache<SOOrder>            cache object as an element with the  RowSelected  key. If the name of the processed method adheres to the naming convention for field event           handlers, the processed method is added to the             EventName Events  collection of the             PXCache<DACName>  object. For example, the             SOOrder_CustomerID_FieldUpdated   event handler is added to the             FieldUpdatedEvents  collection of the             PXCache<SOOrder>  cache object as an element with the             CustomerID  key. Saves the graph metadata and the  InitializeDelegate  emitted method in         the  Acumatica ERP server memory as the  GraphStaticInfo  static object shared for the         entire application instance. From the  GraphStaticInfo  static object, invokes the         InitializeDelegate  method, which initializes graph views, caches, and       actions; the method also adds event handler delegates to the appropriate event handler       collections of the relevant  PXCache  objects. The following diagram shows how an instance of the       PX.Objects.SO.SOOrderEntry  graph uses the  PX.Objects      assembly metadata to add the  SOOrder_CustomerID_FieldUpdated()   event     handler (described in the graph and graph extensions) to the       FieldUpdatedEvents  collection of the  PXCache<SOOrder>      cache object. Addition of an event handler to the appropriate collection In the collection, the  CustomerID  field name is used as a key, and the     delegate of the event handler sequence for the field processing is used as a value. ]]></column>
		</row>
		<row PageID="d9cf6274-f5c8-43e7-9d13-9b423113d67e" Language="en-US" PageRevisionID="1" PlainText="Data Manipulation Scenarios Most events are raised within common scenarios related to the manipulation of data records. The       scenarios are invoked by  Acumatica Framework       when users perform certain actions in the user interface, when the corresponding requests are       made to the web services API, and when special methods are executed within the business logic       controller (BLC). The following diagram shows how different types of event handlers are invoked. Use of event handlers while the basic data operations are processed For details on how  Acumatica Framework       processes the basic data operations, see the following topics: Sequence of Events: Insertion of a Data RecordSequence of Events: Update of a Data RecordSequence of Events: Deletion of a Data RecordSequence of Events: Display of a Data RecordSequence of Events: Saving of Changes to the Database" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="168127ad-706a-c79a-0648-b38e80d2a0a6" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Most events are raised within common scenarios related to the manipulation of data records. The scenarios are invoked by Acumatica Framework when users perform certain actions in the user interface, when the corresponding requests are made to the web services API, and when special methods are executed within the business logic controller (BLC).{br}

The following diagram shows how different types of event handlers are invoked.[anchor|#fig_gby_gwm_4v][anchor|#image_pjq_lwm_4v][image:StudioDeveloperGuide/Images/REF_EventsInScenarios.png|popup|Use of event handlers while the basic data operations are processed|450px]{br}

For details on how Acumatica Framework processes the basic data operations, see the following topics:
*[HelpRoot_Dev_Platform\BL__con_Events_Insert|Sequence of Events: Insertion of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Update|Sequence of Events: Update of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Delete|Sequence of Events: Deletion of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Display|Sequence of Events: Display of a Data Record]
*[HelpRoot_Dev_Platform\BL__con_Events_Persist|Sequence of Events: Saving of Changes to the Database]
]]></column>
		</row>
		<row PageID="5fb67bf3-6db4-498d-983c-e4fe28a65d11" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="033f8abe-c307-76b8-6fed-ae30c04dff68" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The figure below illustrates the sequence of events raised during the insertion of a data record.[anchor|#image_y35_hl1_ck][image:StudioDeveloperGuide/Images/Ref_Events_Insert.png|popup|Insertion of a data record|390px]
The system inserts a data record—as an instance of a data access class (DAC)—when a user creates a new data record in the user interface, a request to insert a record is sent to the web services API, or the {{Insert()}} method of a data view is called in code. The data record is actually inserted into the <tt>PXCache</tt> object that corresponds to the DAC of the data record. The inserted data record has the <tt>Inserted</tt> status and is available through the <tt>Inserted</tt> and <tt>Dirty</tt> collections of the <tt>PXCache</tt> object. {br}

When a data record is inserted, data field events are raised for each data field in the following order:[anchor|#ul_fx3_zm2_3k]
#{{FieldDefaulting}}
#{{FieldUpdating}} if the {{e.Cancel}} property equals <tt>true</tt>
#{{FieldVerifying}}
#{{FieldUpdated}}

Next, the following data record events are raised:[anchor|#ul_z5s_vp2_3k]
#{{RowInserting}} (If the {{e.Cancel}} property is {{true}}, no further events are raised.)
#{{RowSelected}}
#{{RowInserted}}

The instance of the inserted data record is available in the {{e.Row}} property of event arguments. ]]></column>
			<column name="PlainText"><![CDATA[Sequence of Events: Insertion of a Data Record The figure below illustrates the sequence of events raised during the insertion of a data         record. Insertion of a data record The system inserts a data record—as an instance of a data access class         (DAC)—when a user creates a new data record in the user interface, a request to insert         a record is sent to the web services API, or the  Insert()  method of a data         view is called in code. The data record is actually inserted into the            PXCache  object that corresponds to the DAC of the data record. The         inserted data record has the  Inserted  status and is available through the            Inserted  and  Dirty  collections of the            PXCache  object.  When a data record is inserted, data field events are raised for each data field in the         following order: FieldDefaulting FieldUpdating  if the  e.Cancel  property equals              true FieldVerifying FieldUpdated Next, the following data record events are raised: RowInserting  (If the  e.Cancel  property is              true , no further events are raised.) RowSelected RowInserted The instance of the inserted data record is available in the  e.Row          property of event arguments.  ]]></column>
		</row>
		<row PageID="8f77ddc6-374b-4ad9-be20-a282febf88f8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="b663a4d8-e8b9-e0bf-2196-a2386caf3537" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The figure below illustrates the sequence of events raised during the update of a data record. [anchor|#image_byf_3l1_ck][image:StudioDeveloperGuide/Images/Ref_Events_Update.png|popup|Update of a data record|390px]
A data record is updated when a user modifies the data record on the user interface, the request is sent through the Web Service API, or the {{Update()}} method is invoked on the data view. Updated data records, which the system gives the <tt>Updated</tt> status, are later available through the <tt>Updated</tt> and <tt>Dirty</tt> collections of the appropriate <tt>PXCache</tt> object.{br}

The <tt>RowUpdating</tt> event is fired before the update happens, while the <tt>RowUpdated</tt> event is fired after the update. The developer can handle these events and has access to the updated data record and the previous version of the data record that is kept in the <tt>PXCache</tt> object. The actual update happens between these two events when the data record is copied to the <tt>PXCache</tt> object.{br}

When a data record is updated, the following data field events are raised for each updated data field:[anchor|#ul_t1k_sq2_3k]
#{{FieldUpdating}}
#{{FieldVerifying}}
#{{FieldUpdated}}
Next, data record events are raised as follows:[anchor|#ul_tzy_5q2_3k]
#{{RowUpdating}} is raised. At this moment, in the {{e}} variable, which represents event data, {{e.Row}} holds the data record version from the cache, while {{e.NewRow}} holds the updated data record. You can still stop the update by throwing a <tt>PXException</tt> instance.
#If {{e.Cancel}} doesn&rsquo;t equal {{true}}:
##{{RowSelected}} is raised. Only the updated data record can be accessed through {{e.Row}}.
##{{RowUpdated}} is raised. {{e.Row}} now holds the updated instance, while {{e.OldRow}} holds a copy of the old data record with the previous values.
]]></column>
			<column name="PlainText"><![CDATA[Sequence of Events: Update of a Data Record The figure below illustrates the sequence of events raised during the update of a data         record.  Update of a data record A data record is updated when a user modifies the data record on the user interface, the         request is sent through the Web Service API, or the  Update()  method is         invoked on the data view. Updated data records, which the system gives the            Updated  status, are later available through the            Updated  and  Dirty  collections of the appropriate            PXCache  object. The  RowUpdating  event is fired before the update happens, while the            RowUpdated  event is fired after the update. The developer can handle         these events and has access to the updated data record and the previous version of the data         record that is kept in the  PXCache  object. The actual update happens         between these two events when the data record is copied to the  PXCache          object. When a data record is updated, the following data field events are raised for each updated         data field: FieldUpdating FieldVerifying FieldUpdated Next, data record events are raised as follows: RowUpdating  is raised. At this moment, in the  e              variable, which represents event data,  e.Row  holds the data record             version from the cache, while  e.NewRow  holds the updated data record.             You can still stop the update by throwing a  PXException              instance. If  e.Cancel  doesn't equal  true : RowSelected  is raised. Only the updated data record can be                 accessed through  e.Row . RowUpdated  is raised.  e.Row  now holds the                 updated instance, while  e.OldRow  holds a copy of the old data                 record with the previous values. ]]></column>
		</row>
		<row PageID="0d160007-252e-44f8-a9cd-25b40b786dc1" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="d9113c16-08a4-cf7b-90c3-cdb9493e2577" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The figure below illustrates the sequence of events raised during the deletion of a data record.[anchor|#image_g14_3l1_ck][image:StudioDeveloperGuide/Images/Ref_Events_Delete.png|popup|Deletion of a data record|330px]
A data record is deleted when a user deletes the record on the user interface, the deletion request is sent through the Web Service API, or the {{Delete()}} method of a data view is invoked in code. As a result of the deletion, the data record gets the <tt>Deleted</tt> status if it already exists in the database, or the <tt>InsertedDeleted</tt> status if the record has just been inserted into the <tt>PXCache</tt> object and deletion from the database is not required. The data record is later available through the <tt>Deleted</tt> and <tt>Dirty</tt> collections of the <tt>PXCache</tt> object. {br}

If the deletion has been initiated by a user on the UI or through the web services API, the following field events are raised for each key data field before any other events are raised:[anchor|#ul_bd4_qdf_3k]
#{{FieldUpdating}}
#{{FieldUpdated}}

Next, regardless of how the deletion was initiated, data record events are raised as follows:[anchor|#ul_ozf_5df_3k]
#{{RowDeleting}} is raised. At this point, the developer can still stop the deletion by throwing a <tt>PXException</tt> instance. In the {{e}} variable representing event data, {{e.Row}} holds the data record being deleted.
#If {{e.Cancel}} doesn&rsquo;t equal {{true}}:
##{{RowDeleted}} is raised, and {{e.Row}} still holds the data record.
##{{RowSelected}} is raised, and {{e.Row}} equals {{NULL}}.
]]></column>
			<column name="PlainText"><![CDATA[Sequence of Events: Deletion of a Data Record The figure below illustrates the sequence of events raised during the deletion of a data         record. Deletion of a data record A data record is deleted when a user deletes the record on the user interface, the deletion         request is sent through the Web Service API, or the  Delete()  method of a         data view is invoked in code. As a result of the deletion, the data record gets the            Deleted  status if it already exists in the database, or the            InsertedDeleted  status if the record has just been inserted into the            PXCache  object and deletion from the database is not required. The data         record is later available through the  Deleted  and            Dirty  collections of the  PXCache  object.  If the deletion has been initiated by a user on the UI or through the web services API, the         following field events are raised for each key data field before any other events are         raised: FieldUpdating FieldUpdated Next, regardless of how the deletion was initiated, data record events are raised as         follows: RowDeleting  is raised. At this point, the developer can still stop the           deletion by throwing a  PXException  instance. In the  e            variable representing event data,  e.Row  holds the data record being           deleted. If  e.Cancel  doesn't equal  true : RowDeleted  is raised, and  e.Row  still holds the               data record. RowSelected  is raised, and  e.Row  equals                  NULL . ]]></column>
		</row>
		<row PageID="02e8c036-30e7-4cca-86bd-b0dc47626793" Language="en-US" PageRevisionID="1" Content="&#xA;Each time a data record is displayed in the user interface or retrieved through the Web Service API, the {{RowSelected}} and {{FieldSelecting}} events are raised for each data field. For both events, the {{e.Row}} property of event arguments holds the data record that is being displayed or retrieved. {br}&#xA;&#xA;The diagram below illustrates this process in more detail.[anchor|#image_gy5_3l1_ck][image:StudioDeveloperGuide/Images/Ref_Events_Display.png|popup|Display of a data record|450px]" PlainText="Sequence of Events: Display of a Data Record Each time a data record is displayed in the user interface or retrieved through the Web         Service API, the  RowSelected  and  FieldSelecting  events are         raised for each data field. For both events, the  e.Row  property of event         arguments holds the data record that is being displayed or retrieved.  The diagram below illustrates this process in more detail. Display of a data record " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="0983591c-0cd8-087c-86c1-a1c38a7897f6" RecordSourceID="22377" />
		<row PageID="e08a2496-d5fc-416a-966c-4a8b6332345c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="df2e875f-4b74-0687-c51d-dfb9327e6d61" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The following figure illustrates the sequence of events that are raised when a data record is saved.[anchor|#image_jx3_jl1_ck][image:StudioDeveloperGuide/Images/Ref_Events_Persist.png|popup|Save (commit) of a data record to the database|350px]
While a user is inserting, updating, or deleting a data record, no changes are committed to the database. The system stores the modified data records in the session, and you can access them through the appropriate <tt>PXCache</tt> object. The system commits the changes to the database when the user clicks '''Save''' in the user interface, the save request is sent through the Web Service API, or {{Actions.PressSave()}} is invoked on the business logic controller (BLC) instance. In both cases, the <tt>Persist()</tt> method of the graph is invoked. The <tt>Actions.PressSave()</tt> method additionally checks that the <tt>Save</tt> action exists in the graph and is enabled. The <tt>Save</tt> action then invokes the <tt>Persist()</tt> method.{br}

When changes are saved to the database, events are raised as follows:[anchor|#ul_oqx_g3f_3k]
#{{RowPersisting}} is raised. At this moment, a database transaction has already been opened. If any of the handlers sets {{e.Cancel}} to {{true}}, the process will be canceled for the currently processed data record without an error being reported to the user. To cancel the process of committing changes and indicate the error to the user, you should throw the <tt>PXException</tt> exception.
#If {{e.Cancel}} doesn&rsquo;t equal {{true}}:
##{{RowPersisted}} is raised. The commit operation for the current data record (available through {{e.Row}} in the handler) is completed, but the transaction is still open: {{e.TranStatus}} equals {{Open}}.
##{{RowPersisted}} is raised one more time, either with {{e.TranStatus}} equal to {{Completed}} (if all changes have been saved successfully) or with {{e.TranStatus}} equal to {{Aborted}} if an error has occurred and all changes have been canceled.

==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=05ec8787-e83f-dbf2-228f-d6bb45870781|Persist() Method]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d302caf7-87a4-d7e4-65b3-c463f4d62ee3|PXRowPersisting Delegate]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ac686a56-ea6d-5ece-1063-a2842fb9aaa0|PXRowPersisted Delegate]]]></column>
			<column name="PlainText"><![CDATA[Sequence of Events: Saving of Changes to the Database The following figure illustrates the sequence of events that are raised when a data record         is saved. Save (commit) of a data record to the database While a user is inserting, updating, or deleting a data record, no changes are committed to         the database. The system stores the modified data records in the session, and you can access         them through the appropriate  PXCache  object. The system commits the         changes to the database when the user clicks  Save  in the user         interface, the save request is sent through the Web Service API, or            Actions.PressSave()  is invoked on the business logic controller (BLC)         instance. In both cases, the  Persist()  method of the graph is invoked.         The  Actions.PressSave()  method additionally checks that the            Save  action exists in the graph and is enabled. The            Save  action then invokes the  Persist()  method. When changes are saved to the database, events are raised as follows: RowPersisting  is raised. At this moment, a database transaction has           already been opened. If any of the handlers sets  e.Cancel  to              true , the process will be canceled for the currently processed data           record without an error being reported to the user. To cancel the process of committing           changes and indicate the error to the user, you should throw the              PXException  exception. If  e.Cancel  doesn't equal  true : RowPersisted  is raised. The commit operation for the current data               record (available through  e.Row  in the handler) is completed, but the               transaction is still open:  e.TranStatus  equals                Open . RowPersisted  is raised one more time, either with                  e.TranStatus  equal to  Completed  (if all changes               have been saved successfully) or with  e.TranStatus  equal to                  Aborted  if an error has occurred and all changes have been               canceled. Persist() Method PXRowPersisting Delegate PXRowPersisted Delegate ]]></column>
		</row>
		<row PageID="abe22b44-8111-4069-8a24-fa5c901ec5dd" Language="en-US" PageRevisionID="1" PlainText="List of Events In this topic, you can find the list of all events by category. You can get more         information about any of these events by navigating to the applicable topic in the API         Reference. Data Field Events PXFieldDefaulting PXFieldDefaultingPXFieldVerifying PXFieldVerifyingPXFieldUpdating PXFieldUpdatingPXFieldUpdated PXFieldUpdatedPXFieldSelecting PXFieldSelectingData Record Events PXRowSelected PXRowSelectedPXRowInserting PXRowInsertingPXRowInserted PXRowInsertedPXRowUpdating PXRowUpdatingPXRowUpdated PXRowUpdatedPXRowDeleting PXRowDeletingPXRowDeleted PXRowDeletedDatabase-Related Events PXCommandPreparing PXCommandPreparingPXRowSelecting PXRowSelectingPXRowPersisting PXRowPersistingPXRowPersisted PXRowPersistedException-Handling Event PXExceptionHandling PXExceptionHandlingEvent for Overriding DAC Field Attributes CacheAttached CacheAttached" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="5a3fa117-3676-eb63-ae85-4bb7d1a19999" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can find the list of all events by category. You can get more information about any of these events by navigating to the applicable topic in the API Reference.
==Data Field Events==[anchor|#_e1d0a3a3-e5e7-4c1e-bb88-6866cdb5c617]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6db70fe7-3fc3-4e05-d3a6-5ecb93bea6a9|PXFieldDefaulting]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c7a01517-1072-6780-430f-b89a9d305072|PXFieldVerifying]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=cca7462c-8f4b-9ada-03b0-17fd2832d009|PXFieldUpdating]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9048a6d5-41a0-a5bd-9b78-7ce9833114b2|PXFieldUpdated]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7afeed34-d321-02e8-bc8a-853d66732de3|PXFieldSelecting]

==Data Record Events==[anchor|#_70b54f4a-fc4a-45a5-9119-01185b11b977]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=bf5181e8-fc0f-0386-1871-711e7c29ccc7|PXRowSelected]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a086e293-dd12-789c-386a-7f6cbcd56ca2|PXRowInserting]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=08743ca9-5121-b910-b432-7306ebe02cd2|PXRowInserted]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=787ff1db-8126-07e2-3e17-85bce318589c|PXRowUpdating]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fcb1a36f-0dce-61ca-a67e-7d7bf6117948|PXRowUpdated]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=2e6b60b0-de18-e687-8e33-d8176ea7f2db|PXRowDeleting]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ef249f39-058c-18de-a8f2-9ad965cfb53f|PXRowDeleted]

==Database-Related Events==[anchor|#_c106dc09-3e70-4acd-8d0a-1f58e6acbc76]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b3c881ac-7118-24c7-0a99-4edb98887cd6|PXCommandPreparing]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3914d39a-0394-c506-92b5-3bbe3b044cbb|PXRowSelecting]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=d302caf7-87a4-d7e4-65b3-c463f4d62ee3|PXRowPersisting]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ac686a56-ea6d-5ece-1063-a2842fb9aaa0|PXRowPersisted]

==Exception-Handling Event==[anchor|#_2d789a0a-7482-46aa-9d87-aad53e2b8e3f]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=de7f1a9f-8bd0-84e7-3ffa-79f2d3839018|PXExceptionHandling]

==Event for Overriding DAC Field Attributes==[anchor|#_ec0692bf-152b-4502-a125-654ab11c151b]
*[https://help.acumatica.com/(W(2))/Main?ScreenId=ShowWiki&pageid=3af81acb-d7a6-3ebe-2f7d-38cc8abd302d|CacheAttached]
]]></column>
		</row>
		<row PageID="452232d6-60da-4e0e-9fe4-23318464a3b2" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="fa0bf8ea-d864-4b7a-a10e-990aa7d5b80a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In Acumatica Framework, you use attributes to add common business logic to the application components. {br}

Attributes implement business logic by subscribing to events. Each attribute class directly or indirectly derives from the <tt>PXEventSubscriberAttribute</tt> class. In addition, an attribute class derives from the interfaces that correspond to the event handlers it implements. For example, the <tt>PXDefault</tt> attribute derives from the <tt>IPXFieldDefaultingSubscriber</tt>, <tt>IPXRowPersistingSubscriber</tt>, and <tt>IPXFieldSelectingSubscriber</tt> interfaces, which means that it implements its logic in the <tt>FieldDefaulting</tt>, <tt>RowSelecting</tt>, and <tt>FieldSelecting</tt> event handler methods.{br}

Attributes can be added to a data access class (DAC) definition, a data view declaration in a business logic controller (BLC), and the BLC definition itself.{br}

For more information on each attribute, see the [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=fd1f3fb5-f5f2-4316-882e-a98232bbfba5|API Reference].
==In This Chapter==[anchor|#ul_ckc_l2r_rk]
*[HelpRoot_Dev_Platform\BL__con_Attributes|Code Reuse Through Attributes]
*[HelpRoot_Dev_Platform\BL__con_Mandatory_Attributes|Mandatory Attributes]
*[HelpRoot_Dev_Platform\BL__con_Use_of_Attributes|Use of Attributes]
*[HelpRoot_Dev_Platform\BL__con_Attr_DB_Types|Bound Field Data Types]
*[HelpRoot_Dev_Platform\BL__con_Attr_Unbound_Data_Types|Unbound Field Data Types]
*[HelpRoot_Dev_Platform\BL__con_PXUIField_Attribute|UI Field Configuration]
*[HelpRoot_Dev_Platform\BL__con_Default_Values|Default Values]
*[HelpRoot_Dev_Platform\BL__con_Attr_Selectors|Complex Input Controls]
*[HelpRoot_Dev_Platform\BL__con_Attr_Referential_Integrity|Referential Integrity and Calculations]
*[HelpRoot_Dev_Platform\BL__con_Attr_SQL_Adhoc|Ad Hoc SQL for Fields]
*[HelpRoot_Dev_Platform\BL__con_Attr_Audit|Audit Fields]
*[HelpRoot_Dev_Platform\BL__con_Attr_Projection|Data Projection]
*[HelpRoot_Dev_Platform\BL__con_Attr_Access_Control|Access Control]
*[HelpRoot_Dev_Platform\BL__con_Attr_Notes|Notes]
*[HelpRoot_Dev_Platform\BL__con_Attr_Report_Opt|Report Optimization]
*[HelpRoot_Dev_Platform\BL__con_Attr_DAC|Attributes on DACs]
*[HelpRoot_Dev_Platform\BL__con_Attr_Actions| Action Attributes]
*[HelpRoot_Dev_Platform\BL__con_Attr_Views|Attributes on Data Views]
]]></column>
			<column name="PlainText"><![CDATA[Working with Attributes In  Acumatica Framework, you use attributes to add common business logic to the application components.  Attributes implement business logic by subscribing to events. Each attribute class directly or     indirectly derives from the  PXEventSubscriberAttribute  class. In addition, an     attribute class derives from the interfaces that correspond to the event handlers it implements.     For example, the  PXDefault  attribute derives from the       IPXFieldDefaultingSubscriber ,  IPXRowPersistingSubscriber ,     and  IPXFieldSelectingSubscriber  interfaces, which means that it implements     its logic in the  FieldDefaulting ,  RowSelecting , and       FieldSelecting  event handler methods. Attributes can be added to a data access class (DAC) definition, a data view declaration in a     business logic controller (BLC), and the BLC definition itself. For more information on each attribute, see the  API Reference API Reference. In This Chapter Code Reuse Through AttributesMandatory AttributesUse of AttributesBound Field Data TypesUnbound Field Data TypesUI Field ConfigurationDefault ValuesComplex Input ControlsReferential Integrity and CalculationsAd Hoc SQL for FieldsAudit FieldsData ProjectionAccess ControlNotesReport OptimizationAttributes on DACs Action AttributesAttributes on Data Views]]></column>
		</row>
		<row PageID="4724097c-0097-40d2-bb80-98b62cf3a7dc" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f015129c-681c-2fab-2c7d-93f25226cb49" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The following code implements the logic of updating a receipt total when a document transaction is updated in the system. <source lang="csharp">public virtual void DocTransation_RowUpdated(PXCache cache,
                                             PXRowUpdatedEventArgs e)
{
    DocTransaction old = e.OldRow as DocTransaction;
    DocTransaction trn = e.Row as DocTransaction;
    if ((trn != null) && (trn.TranQty != old.TranQty ||
                                   trn.UnitPrice != old.UnitPrice))
    {
        Document doc = Receipts.Current;
        if (doc != null)
        {
            doc.TotalAmt -= old.TranQty * old.UnitPrice;
            doc.TotalAmt += trn.TranQty * trn.UnitPrice;
            Receipts.Update(doc);
        }
    }
}</source>{br}

This logic can be used in multiple forms of the application, and therefore can be moved into an <tt>Attribute</tt> class. The attribute is used to annotate a data field in the data access class. Then it can be reused anywhere in the code, as in the example below.<source lang="csharp">public class DocTransaction : PX.Data.IBqlTable
{
    ...
    #region TotalAmt
    public abstract class totalAmt : PX.Data.IBqlField
    {
    }
    [PXDBDecimal(2)]
    [PXDefault(TypeCode.Decimal, "0.00")]
    [PXUIField(DisplayName = "Line Total", Enabled = false)]
    '''[DeltaMultiply(typeof(DocTransaction.tranQty), typeof(DocTransaction.unitPrice),
                   typeof(Document.totalAmt)]'''
    public virtual decimal? ExtPrice { get; set; }
    #endregion
    ...
}</source>
In this example, the logic of updating the receipt total on an update of the transaction is implemented inside the {{DeltaMultiply}} attribute. This logic is triggered after each update, delete, or insert operation on the {{DocTransaction}} data access class instance and updates totals on the receipt level in the appropriate {{Document}} data access class instance.{br}

 Acumatica Framework provides a wide range of predefined attributes that can be used for defining data types, database mapping, referential integrity, data format validation, and default values for the field. The following code shows an example of how you can implement the logic from the above example by using the predefined <tt>PXFormula</tt> attribute, which is used for implementing calculations of data fields.<source lang="csharp">public class DocTransaction : PX.Data.IBqlTable
{
    ...
    #region TotalAmt
    public abstract class totalAmt : PX.Data.IBqlField
    {
    }
    [PXDBDecimal(2)]
    [PXDefault(TypeCode.Decimal, "0.00")]
    [PXUIField(DisplayName = "Line Total", Enabled = false)]
    '''[PXFormula(typeof(Mult&lt;DocTransaction.tranQty, DocTransaction.unitPrice&gt;),
               typeof(SumCalc&lt;Document.totalAmt&gt;))]'''
    public virtual decimal? ExtPrice { get; set; }
    #endregion
    ...
}</source>{br}

Because the data access classes are shared within an application, formatting, custom logic, and any constraints implemented in attributes are reused in each business logic controller that utilizes each data access class. By reusing code through attributes, you can move shared application functionality into attributes and avoid code duplication, while still enforcing application integrity.]]></column>
			<column name="PlainText"><![CDATA[Code Reuse Through Attributes The following code implements the logic of updating a receipt total when a document                 transaction is updated in the system.                  public virtual void DocTransation_RowUpdated(PXCache cache,
                                             PXRowUpdatedEventArgs e)
{
    DocTransaction old = e.OldRow as DocTransaction;
    DocTransaction trn = e.Row as DocTransaction;
    if ((trn != null) && (trn.TranQty != old.TranQty ||
                                   trn.UnitPrice != old.UnitPrice))
    {
        Document doc = Receipts.Current;
        if (doc != null)
        {
            doc.TotalAmt -= old.TranQty * old.UnitPrice;
            doc.TotalAmt += trn.TranQty * trn.UnitPrice;
            Receipts.Update(doc);
        }
    }
} This logic can be used in multiple forms of the application, and therefore can be moved into     an  Attribute  class. The attribute is used to annotate a data field in the     data access class. Then it can be reused anywhere in the code, as in the example below. public class DocTransaction : PX.Data.IBqlTable
{
    ...
    #region TotalAmt
    public abstract class totalAmt : PX.Data.IBqlField
    {
    }
    [PXDBDecimal(2)]
    [PXDefault(TypeCode.Decimal, "0.00")]
    [PXUIField(DisplayName = "Line Total", Enabled = false)]
     [DeltaMultiply(typeof(DocTransaction.tranQty), typeof(DocTransaction.unitPrice),
                   typeof(Document.totalAmt)] 
    public virtual decimal? ExtPrice { get; set; }
    #endregion
    ...
} In this example, the logic of updating the receipt total on an update of the transaction is                 implemented inside the  DeltaMultiply  attribute. This logic is                 triggered after each update, delete, or insert operation on the                      DocTransaction  data access class instance and updates totals on                 the receipt level in the appropriate  Document  data access class                 instance.  Acumatica Framework                 provides a wide range of predefined attributes that can be used for defining data                 types, database mapping, referential integrity, data format validation, and default                 values for the field. The following code shows an example of how you can implement                 the logic from the above example by using the predefined                      PXFormula  attribute, which is used for implementing                 calculations of data                 fields. public class DocTransaction : PX.Data.IBqlTable
{
    ...
    #region TotalAmt
    public abstract class totalAmt : PX.Data.IBqlField
    {
    }
    [PXDBDecimal(2)]
    [PXDefault(TypeCode.Decimal, "0.00")]
    [PXUIField(DisplayName = "Line Total", Enabled = false)]
     [PXFormula(typeof(Mult<DocTransaction.tranQty, DocTransaction.unitPrice>),
               typeof(SumCalc<Document.totalAmt>))] 
    public virtual decimal? ExtPrice { get; set; }
    #endregion
    ...
} Because the data access classes are shared within an application, formatting, custom logic,                 and any constraints implemented in attributes are reused in each business logic                 controller that utilizes each data access class. By reusing code through attributes,                 you can move shared application functionality into attributes and avoid code                 duplication, while still enforcing application integrity. ]]></column>
		</row>
		<row PageID="a211a689-4bd3-4593-8144-f9ef631c418d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="bb369783-f3c1-ca53-ea1a-7f03d9472e4c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can learn about the mandatory attributes of data access class (DAC) fields and actions.
==Mandatory Attributes of DAC Fields==
For each field defined in a DAC, you must specify the following attributes:[anchor|#ul_djw_hfr_rk]
*A data type attribute, which is either a bound field data type attribute that binds the field to a database column of a particular data type, or an unbound field data type attribute that indicates that the field is unbound. For lists of these attributes, see [HelpRoot_Dev_Platform\BL__con_Attr_DB_Types|Bound Field Data Types] and [HelpRoot_Dev_Platform\BL__con_Attr_Unbound_Data_Types|Unbound Field Data Types].
*The <tt>PXUIField</tt> attribute, which is mandatory for all fields that are displayed in the user interface. For details on the <tt>PXUIField</tt> attribute, see [HelpRoot_Dev_Platform\BL__con_PXUIField_Attribute|UI Field Configuration].

The example below demonstrates a declaration of a DAC field bound to a database column and displayed in the user interface.<source lang="csharp">// The data access class for the POReceiptFilter database table
[Serializable]
public partial class POReceiptFilter : IBqlTable
{
    ...
    // The type declaration of a DAC field
    public abstract class receiptType : PX.Data.IBqlField
    {
    }
    // The value declaration of a DAC field 
    // Put attributes before this declaration
    [PXDBString(2, IsFixed = true)]
    [PXUIField(DisplayName = "Type", Enabled = false)]
    public virtual String ReceiptType { get; set; }
    ...
}</source>
==Mandatory Attributes of Actions==
A declaration of a method that implements an action in a business logic controller must be preceded with the <tt>PXButton</tt> attribute or one of its successors and the <tt>PXUIField</tt> attribute. For details on the <tt>PXUIField</tt> attribute, see [HelpRoot_Dev_Platform\BL__con_PXUIField_Attribute|UI Field Configuration].{br}

The example below demonstrates a declaration of an action handler.{br}

<source lang="csharp">public PXAction&lt;SalesOrder&gt; ViewDocument;

[PXUIField(DisplayName = "View Document",
           MapEnableRights = PXCacheRights.Select,
           MapViewRights = PXCacheRights.Select)]
[PXButton]
public virtual IEnumerable viewDocument(PXAdapter adapter)
{
    ...
}</source>
==Related Articles==
*[HelpRoot_Dev_Platform\BL__con_Attr_DB_Types|Bound Field Data Types]
*[HelpRoot_Dev_Platform\BL__con_Attr_Unbound_Data_Types|Unbound Field Data Types]
*[HelpRoot_Dev_Platform\BL__con_PXUIField_Attribute|UI Field Configuration]
*[https://help.acumatica.com/(W(14))/Main?ScreenId=ShowWiki&pageid=ea7ce94e-4b3e-0f91-df1d-a4ce8023b184|PXUIFieldAttribute]
*[https://help.acumatica.com/(W(14))/Main?ScreenId=ShowWiki&pageid=e1a6f32e-fa9b-010a-b85f-0b2c2ffa0fea|PXButtonAttribute]]]></column>
			<column name="PlainText"><![CDATA[Mandatory Attributes In this topic, you can learn about the mandatory attributes of data         access class (DAC) fields and actions. Mandatory Attributes of DAC Fields For each field defined in a DAC, you must specify the following attributes: A data type attribute, which is either a bound field data type attribute that binds the           field to a database column of a particular data type, or an unbound field data type           attribute that indicates that the field is unbound. For lists of these attributes, see              Bound Field Data Types and  Unbound Field Data Types. The  PXUIField  attribute, which is mandatory for all fields that are           displayed in the user interface. For details on the  PXUIField            attribute, see  UI Field Configuration. The example below demonstrates a declaration of a DAC field bound to a database column and         displayed in the user interface. // The data access class for the POReceiptFilter database table
[Serializable]
public partial class POReceiptFilter : IBqlTable
{
    ...
    // The type declaration of a DAC field
    public abstract class receiptType : PX.Data.IBqlField
    {
    }
    // The value declaration of a DAC field 
    // Put attributes before this declaration
    [PXDBString(2, IsFixed = true)]
    [PXUIField(DisplayName = "Type", Enabled = false)]
    public virtual String ReceiptType { get; set; }
    ...
} Mandatory Attributes of Actions A declaration of a method that implements an action in a business logic controller must be         preceded with the  PXButton  attribute or one of its successors and the            PXUIField  attribute. For details on the  PXUIField          attribute, see  UI Field Configuration. The example below demonstrates a declaration of an action handler. public PXAction<SalesOrder> ViewDocument;

[PXUIField(DisplayName = "View Document",
           MapEnableRights = PXCacheRights.Select,
           MapViewRights = PXCacheRights.Select)]
[PXButton]
public virtual IEnumerable viewDocument(PXAdapter adapter)
{
    ...
} PXUIFieldAttribute PXButtonAttribute ]]></column>
		</row>
		<row PageID="5a036000-ca13-4c75-be1c-ac02d819ddce" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="1dff3dea-4b33-d084-d2ad-c3e424fee3e2" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To apply the attribute business logic to an entity, you should place the attribute on the entity declaration. At run time, you can call the static methods of a particular attribute to adjust the attribute&rsquo;s behavior.
==Attributes on the Entity Declaration==
An attribute may be placed on a declaration of a class or a class member, with or without parameters. The parameters that are possible for an attribute depend on the constructor parameters and the properties defined in the attribute. The parameters of the selected constructor are placed first without names, and the named property settings follow them, as shown in the following example.<source lang="csharp">[PXDefault(false, PersistingCheck = PXPersistingCheck.Nothing)]
public virtual Boolean? Released { get; set; }</source>
Here the <tt>PXDefault</tt> attribute is created with the constructor that takes a Boolean-type parameter (set to <tt>false</tt>). Additionally, the <tt>PersistingCheck</tt> property is specified.
==Setting of Attribute Properties at Run Time==
You should call static methods defined in the attribute class to change the properties at run time. The static methods can affect a single attribute instance or multiple attribute instances related to a specific data record or all data records in a particular cache object. The following example shows an invocation of a static method.<source lang="csharp">PXUIFieldAttribute.SetVisible&lt;APInvoice.curyID&gt;(cache, doc, true);</source>
When calling such a method, you typically specify the cache object, a data record related to this cache object, and the data access class (DAC) field. The method affects the attribute instance created for this field and the specified data record. If you pass <tt>null</tt> as the data record, the method affects attribute instances related to all data records in the specified cache object.]]></column>
			<column name="PlainText"><![CDATA[Use of Attributes To apply the attribute business logic to an entity, you should place the attribute on the         entity declaration. At run time, you can call the static methods of a particular attribute         to adjust the attribute's behavior. Attributes on the Entity Declaration An attribute may be placed on a declaration of a class or a class member, with or without         parameters. The parameters that are possible for an attribute depend on the constructor         parameters and the properties defined in the attribute. The parameters of the selected         constructor are placed first without names, and the named property settings follow them, as         shown in the following example. [PXDefault(false, PersistingCheck = PXPersistingCheck.Nothing)]
public virtual Boolean? Released { get; set; } Here the  PXDefault  attribute is created with the constructor that takes         a Boolean-type parameter (set to  false ). Additionally, the            PersistingCheck  property is specified. Setting of Attribute Properties at Run Time You should call static methods defined in the attribute class to change the properties at         run time. The static methods can affect a single attribute instance or multiple attribute         instances related to a specific data record or all data records in a particular cache         object. The following example shows an invocation of a static method. PXUIFieldAttribute.SetVisible<APInvoice.curyID>(cache, doc, true); When calling such a method, you typically specify the cache object, a data record related         to this cache object, and the data access class (DAC) field. The method affects the         attribute instance created for this field and the specified data record. If you pass            null  as the data record, the method affects attribute instances related         to all data records in the specified cache object. ]]></column>
		</row>
		<row PageID="61059393-8873-451f-b474-783906330fc6" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f1439f93-c2fb-83a0-398b-4a28cde5f151" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The following attributes bind a data access class (DAC) field to a database column of a specific type.
{| class="checklist" | width="100%" 
|- 
!width="27%" ! Attribute
!width="13%" ! C# Data Type
!width="18%" ! Database Data Type
!width="40%" ! Comment
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6f43bb00-f714-4dd4-3e18-952b10a7d49b|<tt>PXDBBool</tt>]
|  <tt>bool?</tt>
|  <tt>bit</tt>
| Boolean value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=bb912e5d-5582-187a-211c-026832ef3952|<tt>PXDBByte</tt>]
|  <tt>byte?</tt>
|  <tt>tinyint</tt>
| One-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b8abec45-68df-3f25-2661-b48baddf4f2d|<tt>PXDBDate</tt>]
|  <tt>DateTime?</tt>
|  <tt>datetime</tt> or <tt>smalldatetime</tt>
| Date and time
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9cd8c337-f815-e101-4335-56625c37e39e|<tt>PXDBTime</tt>]
|  <tt>DateTime?</tt>
|  <tt>smalldatetime</tt>
| Time without date
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=0fe1d7bb-3452-b2b0-c70c-0de73c8a3c37|<tt>PXDBDateAndTime</tt>]
|  <tt>DateTime?</tt>
|  <tt>datetime</tt> or <tt>smalldatetime</tt>
| Date and time values represented by separate input controls in the user interface
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=82a6bfec-fa58-7622-82b5-84f23e6f6836|<tt>PXDBDecimal</tt>]
|  <tt>decimal?</tt>
|  <tt>decimal</tt>
| Sixteen-byte floating point numeric value with a specific precision
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=bb67f00f-3c3a-8c03-a445-97610d43ab35|<tt>PXDBDecimalString</tt>]
|  <tt>decimal?</tt>
|  <tt>decimal</tt>
| A decimal value with a value selected by a user from the list of predefined values
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7dac4820-527e-5c93-e274-a8f88b968a6a|<tt>PXDBDouble</tt>]
|  <tt>double?</tt>
|  <tt>float</tt>
| Eight-byte floating point value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5b9e3a58-2bac-bcd0-9ab5-cc9ee9da2b1a|<tt>PXDBFloat</tt>]
|  <tt>float?</tt>
|  <tt>real</tt>
| Four-byte floating point value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=05170859-440d-4eb2-15bf-242eb2542452|<tt>PXDBGuid</tt>]
|  <tt>Guid?</tt>
|  <tt>uniqueidentifier</tt>
| Sixteen-byte unique value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=0c0be73a-f67b-7678-5fee-ca1ec59d96a4|<tt>PXDBIdentity</tt>]
|  <tt>int?</tt>
|  <tt>int</tt>
| Four-byte auto-incremented integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a475457c-148e-b8d1-0195-c608b0b4ffe5|<tt>PXDBLongIdentity</tt>]
|  <tt>int64?</tt>
|  <tt>bigint</tt>
| Eight-byte auto-incremented integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1bc72a36-9195-15e5-e630-2a7b3605b7f3|<tt>PXDBShort</tt>]
|  <tt>short?</tt>
|  <tt>smallint</tt>
| Two-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=933686ac-8589-8c13-519f-aa3d9a225e68|<tt>PXDBInt</tt>]
|  <tt>int?</tt>
|  <tt>int</tt>
| Four-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=55c77d76-282f-6911-52f4-0b0e9f890cc6|<tt>PXDBLong</tt>]
|  <tt>int64?</tt>
|  <tt>bigint</tt>
| Eight-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=684c8a76-2fb6-3aac-fcd4-c19eeda8304b|<tt>PXDBString</tt>]
|  <tt>string</tt>
|  <tt>char</tt>, <tt>varchar</tt>, <tt>nchar</tt>, or <tt>nvarchar</tt>
| Common string
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=83c22aa8-e32c-36b7-8603-b649104e43fd|<tt>PXDBEmail</tt>]
|  <tt>string</tt>
|  <tt>nvarchar</tt>
| Email address
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a6ea052d-3b45-f5ca-7dec-5c5f44bd5d40|<tt>PXDBLocalString</tt>]
|  <tt>string</tt>
|  <tt>char</tt>, <tt>varchar</tt>, <tt>nchar</tt>, or <tt>nvarchar</tt>
| Localized string
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=176377a7-4d01-786c-a56d-e17ccbf188f0|<tt>PXDBCryptString</tt>]
|  <tt>string</tt>
|  <tt>char</tt>, <tt>varchar</tt>, <tt>nchar</tt>, or <tt>nvarchar</tt>
| Encrypted string
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5ee7728a-fffb-2010-3992-6c232a162ae2|<tt>PXDBText</tt>]
|  <tt>string</tt>
|  <tt>nvarchar</tt> or <tt>varchar</tt>
| Text
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=5432e798-8be3-661d-6e2a-b3bcf0525428|<tt>PXDBTimeSpan</tt>]
|  <tt>int?</tt>
|  <tt>int</tt>
| Date and time value represented by minutes passed from 01/01/1900
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=58e9d3f8-12a0-621c-8088-e26bc875d0cb|<tt>PXDBTimeSpanLong</tt>]
|  <tt>int?</tt>
|  <tt>int</tt>
| Duration in time as a number of minutes
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=f73e9ff3-9ea0-0538-cc43-958dd25b99bc|<tt>PXDBTimestamp</tt>]
|  <tt>byte&#91;&#93;</tt>
|  <tt>timestamp</tt>
| Eight-byte unique, automatically generated binary numbers within a database
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=cc9c8bec-c3c1-d8b5-a909-bfc75598671e|<tt>PXDBBinary</tt>]
|  <tt>byte&#91;&#93;</tt>
| 
| Arbitrary array of bytes
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e1daa7b2-8cbe-1c9e-f810-74133c736988|<tt>PXDBVariant</tt>]
|  <tt>byte&#91;&#93;</tt>
|  <tt>variant</tt>
| Variant data type
|}
 Acumatica Framework also includes other attributes that are used in special cases to bind a DAC field to database columns. ]]></column>
			<column name="PlainText"><![CDATA[Bound Field Data Types The following attributes bind a data access class (DAC) field to a database column of a         specific type. Attribute C# Data Type Database Data Type Comment PXDBBool <tt>PXDBBool</tt>bool? bit Boolean value PXDBByte <tt>PXDBByte</tt>byte? tinyint One-byte integer value PXDBDate <tt>PXDBDate</tt>DateTime? datetime  or  smalldatetime Date and time PXDBTime <tt>PXDBTime</tt>DateTime? smalldatetime Time without date PXDBDateAndTime <tt>PXDBDateAndTime</tt>DateTime? datetime  or  smalldatetime Date and time values represented by separate input controls in the user                 interface PXDBDecimal <tt>PXDBDecimal</tt>decimal? decimal Sixteen-byte floating point numeric value with a specific precision PXDBDecimalString <tt>PXDBDecimalString</tt>decimal? decimal A decimal value with a value selected by a user from the list of predefined                 values PXDBDouble <tt>PXDBDouble</tt>double? float Eight-byte floating point value PXDBFloat <tt>PXDBFloat</tt>float? real Four-byte floating point value PXDBGuid <tt>PXDBGuid</tt>Guid? uniqueidentifier Sixteen-byte unique value PXDBIdentity <tt>PXDBIdentity</tt>int? int Four-byte auto-incremented integer value PXDBLongIdentity <tt>PXDBLongIdentity</tt>int64? bigint Eight-byte auto-incremented integer value PXDBShort <tt>PXDBShort</tt>short? smallint Two-byte integer value PXDBInt <tt>PXDBInt</tt>int? int Four-byte integer value PXDBLong <tt>PXDBLong</tt>int64? bigint Eight-byte integer value PXDBString <tt>PXDBString</tt>string char ,  varchar ,  nchar ,                 or  nvarchar Common string PXDBEmail <tt>PXDBEmail</tt>string nvarchar Email address PXDBLocalString <tt>PXDBLocalString</tt>string char ,  varchar ,  nchar ,                 or  nvarchar Localized string PXDBCryptString <tt>PXDBCryptString</tt>string char ,  varchar ,  nchar ,                 or  nvarchar Encrypted string PXDBText <tt>PXDBText</tt>string nvarchar  or  varchar Text PXDBTimeSpan <tt>PXDBTimeSpan</tt>int? int Date and time value represented by minutes passed from 01/01/1900 PXDBTimeSpanLong <tt>PXDBTimeSpanLong</tt>int? int Duration in time as a number of minutes PXDBTimestamp <tt>PXDBTimestamp</tt>byte[] timestamp Eight-byte unique, automatically generated binary numbers within a                 database PXDBBinary <tt>PXDBBinary</tt>byte[] Arbitrary array of bytes PXDBVariant <tt>PXDBVariant</tt>byte[] variant Variant data type  Acumatica Framework also includes other attributes that are used in special cases to bind a DAC field to         database columns.  ]]></column>
		</row>
		<row PageID="fd0adc27-e163-422d-a74e-057aa10ad2d9" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="54dbff66-b9dd-5430-0df1-7445c05516d1" RecordSourceID="22377">
			<column name="Content"><![CDATA[The following table contains unbound field attributes. You use unbound attributes when you define a custom fields of your own that are not bound to any database fields.[anchor|#table_umg_wfx_qk]
{| class="checklist" | width="100%" 
|- 
!width="28%" ! Attribute
!width="14%" ! C# Data Type
!width="57%" ! Comment
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7d843c14-ade9-d303-f0fc-49834fb4701c|<tt>PXBool</tt>]
|  <tt>bool?</tt>
| Boolean value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=4fb7414c-eeaa-da00-e73f-96012eeb9a8c|<tt>PXByte</tt>]
|  <tt>byte?</tt>
| One-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=e13e06c7-dd25-b9ae-6fdb-ca0103b3642b|<tt>PXDate</tt>]
|  <tt>DateTime?</tt>
| Date and time
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b9434f84-8a5d-d88c-ee97-cdb53e48c506|<tt>PXDateAndTime</tt>]
|  <tt>DateTime?</tt>
| Date and time values represented by separate input controls in the user interface
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=2dab17b2-a8b3-3565-03d2-80d4a445451c|<tt>PXDecimal</tt>]
|  <tt>Decimal?</tt>
| Sixteen-byte floating point numeric value with a specific precision
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7e937089-0faf-a1c1-872b-a178164d04d6|<tt>PXDouble</tt>]
|  <tt>double?</tt>
| Eight-byte floating point value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3cce9d22-92a7-3cc4-59da-35b5ab1f66ab|<tt>PXFloat</tt>]
|  <tt>float?</tt>
| Four-byte floating point value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=cccb6cf3-c8b2-378a-cb90-895989f58a90|<tt>PXGuid</tt>]
|  <tt>Guid?</tt>
| Sixteen-byte unique value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ab3d3e23-3c87-9e1f-5d8b-4e77651d6653|<tt>PXShort</tt>]
|  <tt>short?</tt>
| Two-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=91955df3-3ceb-e5c0-27ad-0f336217a147|<tt>PXInt</tt>]
|  <tt>int?</tt>
| Four-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7e0c708e-813b-7cc6-5585-0e4aa57bfe7f|<tt>PXLong</tt>]
|  <tt>int64?</tt>
| Eight-byte integer value
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=54a0e4fd-a521-7de4-2817-7ac59805293d|<tt>PXString</tt>]
|  <tt>string</tt>
| String of characters
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3f010029-4b46-cda7-232d-8338b166d54e|<tt>PXTimeSpan</tt>]
|  <tt>int?</tt>
| Date and time value represented by minutes passed from 01/01/1900
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=0dbbea05-2eba-9bff-2509-6564c8fcb1b2|<tt>PXTimeSpanLong</tt>]
|  <tt>int?</tt>
| Duration in time as a number of minutes
|- 
| [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=92f5623d-eebb-e5e7-db17-5aa98633b219|<tt>PXVariant</tt>]
|  <tt>byte&#91;&#93;</tt>
| Random array of bytes
|}]]></column>
			<column name="PlainText"><![CDATA[Unbound Field Data Types The following table contains unbound field attributes. You use unbound attributes when       you define a custom fields of your own that are not bound to any database fields. Attribute C# Data Type Comment PXBool <tt>PXBool</tt>bool? Boolean value PXByte <tt>PXByte</tt>byte? One-byte integer value PXDate <tt>PXDate</tt>DateTime? Date and time PXDateAndTime <tt>PXDateAndTime</tt>DateTime? Date and time values represented by separate input controls in the user                 interface PXDecimal <tt>PXDecimal</tt>Decimal? Sixteen-byte floating point numeric value with a specific precision PXDouble <tt>PXDouble</tt>double? Eight-byte floating point value PXFloat <tt>PXFloat</tt>float? Four-byte floating point value PXGuid <tt>PXGuid</tt>Guid? Sixteen-byte unique value PXShort <tt>PXShort</tt>short? Two-byte integer value PXInt <tt>PXInt</tt>int? Four-byte integer value PXLong <tt>PXLong</tt>int64? Eight-byte integer value PXString <tt>PXString</tt>string String of characters PXTimeSpan <tt>PXTimeSpan</tt>int? Date and time value represented by minutes passed from 01/01/1900 PXTimeSpanLong <tt>PXTimeSpanLong</tt>int? Duration in time as a number of minutes PXVariant <tt>PXVariant</tt>byte[] Random array of bytes ]]></column>
		</row>
		<row PageID="9fa848ae-704a-4332-95bd-0beac0180ddb" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="a118cd2b-3845-803a-bc1f-a333935b0178" RecordSourceID="22377">
			<column name="Content"><![CDATA[
By using the <tt>PXUIField</tt> attribute, you can configure the layout of input controls and buttons. The attribute is mandatory for all data access class (DAC) fields displayed in the user interface. 
==Setting of the PXUIField Attribute==
You can add the <tt>PXUIField</tt> attribute in the following ways:[anchor|#_1383d627-91b4-4175-b188-c1e5e9573459]
*To a DAC field declaration to configure the field input control, as shown in the following example<source lang="csharp">[PXDBDate()]
[PXUIField(DisplayName = "Pay Date")]
public virtual DateTime? PayDate { get; set; }</source>
*To the declaration of a method that implements an action to configure the action button, as shown in the following sample code<source lang="csharp">[PXUIField(DisplayName = "View Document",
           MapEnableRights = PXCacheRights.Select,
           MapViewRights = PXCacheRights.Select)]
[PXButton]
public virtual IEnumerable viewDocument(PXAdapter adapter)
{
    ...
}</source>

The attribute&rsquo;s properties determine the control layout in the user interface. You can specify the display name, specify whether the control is visible and available, set the error marker, and specify the access rights to view and use the control.
==Setting of the Properties of the PXUIField Attribute at Run Time==
You can use the static methods (such as <tt>SetEnabled</tt> and <tt>SetRequired</tt>) of the <tt>PXUIFieldAttribute</tt> class to set the properties of a control at run time. The <tt>PXUIFieldAttribute</tt> static methods can be called in the graph constructor or the <tt>RowSelected</tt> event handlers.((({S:Hint}The <tt>RowSelected</tt> event handler is raised when the user interface controls are prepared to be displayed. This happens each time the webpage sends a request to the server.
)))
If you want to modify the <tt>Visible</tt>, <tt>Enabled</tt>, and <tt>Required</tt> properties for all detail rows in a grid, you use the <tt>RowSelected</tt> event handler of the primary view DAC. If you want to set the <tt>Enabled</tt> property of a field in particular row in a grid, you use the <tt>RowSelected</tt> event handler of the DAC that includes this field.{br}

If the grid column layout is configured at run time, you set the <tt>data</tt> parameter of the corresponding method to <tt>null</tt>. This indicates that the property should be set for all data records shown in the grid. If a specific data record is passed to the method rather than {{null}}, the method invocation has no effect.((({S:Hint}If you want to change the <tt>Visible</tt> or <tt>Enabled</tt> property of <tt>PXUIFieldAttribute</tt> for a button at run time, you use the corresponding static methods of <tt>PXAction</tt>. You usually use these methods in the <tt>RowSelected</tt> event handler of the primary view DAC.
)))
==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ea7ce94e-4b3e-0f91-df1d-a4ce8023b184|PXUIFieldAttribute Class]]]></column>
			<column name="PlainText"><![CDATA[UI Field Configuration By using the  PXUIField  attribute, you can configure the layout of input     controls and buttons. The attribute is mandatory for all data access class (DAC) fields     displayed in the user interface.  Setting of the PXUIField Attribute You can add the  PXUIField  attribute in the following ways: To a DAC field declaration to configure the field input control, as shown in the following      example [PXDBDate()]
[PXUIField(DisplayName = "Pay Date")]
public virtual DateTime? PayDate { get; set; } To the declaration of a method that implements an action to configure the action button, as      shown in the following sample      code [PXUIField(DisplayName = "View Document",
           MapEnableRights = PXCacheRights.Select,
           MapViewRights = PXCacheRights.Select)]
[PXButton]
public virtual IEnumerable viewDocument(PXAdapter adapter)
{
    ...
} The attribute's properties determine the control layout in the user interface. You can specify     the display name, specify whether the control is visible and available, set the error marker,     and specify the access rights to view and use the control. Setting of the Properties of the PXUIField Attribute at Run Time You can use the static methods (such as  SetEnabled  and       SetRequired ) of the  PXUIFieldAttribute  class to set the     properties of a control at run time. The  PXUIFieldAttribute  static methods     can be called in the graph constructor or the  RowSelected  event handlers. The  RowSelected  event handler is raised when the user interface controls     are prepared to be displayed. This happens each time the webpage sends a request to the     server. If you want to modify the  Visible ,  Enabled , and       Required  properties for all detail rows in a grid, you use the       RowSelected  event handler of the primary view DAC. If you want to set the       Enabled  property of a field in particular row in a grid, you use the       RowSelected  event handler of the DAC that includes this field. If the grid column layout is configured at run time, you set the  data      parameter of the corresponding method to  null . This indicates that the     property should be set for all data records shown in the grid. If a specific data record is     passed to the method rather than  null , the method invocation has no effect. If you want to change the  Visible  or  Enabled  property     of  PXUIFieldAttribute  for a button at run time, you use the corresponding     static methods of  PXAction . You usually use these methods in the       RowSelected  event handler of the primary view DAC. PXUIFieldAttribute Class ]]></column>
		</row>
		<row PageID="59a784a5-7663-4031-ab15-594c2ec1c027" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e28c80ce-659e-cd88-86f9-dd1876777367" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can set the default values to data access class (DAC) fields by using the following attributes:[anchor|#ul_xdc_ylz_pk]
*<tt>PXDefault</tt>: This attribute sets the default value and validates the field value when the value is saved to the database. The following attributes are derived from the <tt>PXDefault</tt> attribute:
**<tt>PXUnboundDefault</tt> behaves in the same way as <tt>PXDefault</tt> does, but the default value is assigned to the field when a data record is retrieved from the database.
**<tt>PXDefaultValidate</tt>.
*<tt>PXDBDefault</tt>: This attribute sets the default value by using the value of some source field, and updates the value if the source field value changes in the database before the data record is saved.

==PXDefault Attribute==
The <tt>PXDefault</tt> attribute provides the default value for a DAC field. The default value is assigned to the field when the cache raises the <tt>FieldDefaulting</tt> event. This happens when a new row is inserted in code or through the user interface.{br}

A value specified as a default can be a constant or the result of a BQL query. If you provide a BQL query, the attribute executes it on the <tt>FieldDefaulting</tt> event. You can specify both a constant and a BQL query; the attribute first executes the BQL query and then uses the constant if the BQL query returns an empty set. If you provide a DAC field as the BQL query, the attribute retrieves the value of this field from the <tt>Current</tt> property of the cache object. The attribute uses the cache object of the DAC type in which the field is defined.{br}

The <tt>PXDefault</tt> attribute also checks that the field value is not <tt>null</tt> before saving a record to the database. You can adjust this behavior by using the <tt>PersistingCheck</tt> property. Its value indicates whether the attribute should verify that the value is not <tt>null</tt>, verify that the value is not <tt>null</tt> or a blank string, or not perform any verification.{br}

The attribute can redirect the error that happened on the field to another field if you set the <tt>MapErrorTo</tt> property.{br}

You can use the static methods of the attribute to change the attribute properties for a particular data record in the cache or for all data records in the cache.
==Differences==
You usually set the default value to a DAC field by using the <tt>PXDefault</tt> attribute. You can set a constant as the default value or provide a BQL query to obtain a value from the database or data records from the cache. The default value is assigned to the field when a data record that includes this field is inserted into the cache.{br}

You can use the <tt>PXDefault</tt> attribute just to make the field mandatory for input by using the attribute without parameters.{br}

The <tt>PXDefault</tt> attribute is not suitable when the default value is retrieved from a field that can be auto-generated by the database (such as the identity field). In this case, you should use the <tt>PXDBDefault</tt> attribute. It updates the value assigned to the field as the default with the value generated by the database.{br}

For example, if you implement a master-detail relationship, you should use the <tt>PXDBDefault</tt> attribute to bind the detail data record fields to the master data record key fields. If the master data record is new, its identity field is set to a real value by the database when the master record is saved. So if a detail data record is created before the master data record is saved, the detail data record field is set to the temporary value of the master identity field. However, the <tt>PXDBDefault</tt> attribute replaces the temporary value with the real value when the detail data record is saved to the database.{br}

You can use the <tt>PXUnboundDefault</tt> attribute to set the default value to an unbound field. The value is assigned when a data record is retrieved from the database (on the <tt>RowSelecting</tt> event).
==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c97384f1-fe6e-9c90-c97e-ba2e53af675d|PXDBDefaultAttribute Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=96b4e224-d0d2-e2d8-671e-9ba2ed73c21b|PXDefaultAttribute Class]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9657f891-5eec-949b-53ee-d700542cb03c|PXUnboundDefaultAttribute Class]]]></column>
			<column name="PlainText"><![CDATA[Default Values You can set the default values to data access class (DAC) fields by using the following     attributes: PXDefault : This attribute sets the default value and validates the field      value when the value is saved to the database. The following attributes are derived from the        PXDefault  attribute: PXUnboundDefault  behaves in the same way as          PXDefault  does, but the default value is assigned to the field when a        data record is retrieved from the database. PXDefaultValidate . PXDBDefault : This attribute sets the default value by using the value of      some source field, and updates the value if the source field value changes in the database      before the data record is saved. PXDefault Attribute The  PXDefault  attribute provides the default value for a DAC field. The     default value is assigned to the field when the cache raises the       FieldDefaulting  event. This happens when a new row is inserted in code or     through the user interface. A value specified as a default can be a constant or the result of a BQL query. If you provide     a BQL query, the attribute executes it on the  FieldDefaulting  event. You can     specify both a constant and a BQL query; the attribute first executes the BQL query and then     uses the constant if the BQL query returns an empty set. If you provide a DAC field as the BQL     query, the attribute retrieves the value of this field from the  Current      property of the cache object. The attribute uses the cache object of the DAC type in which the     field is defined. The  PXDefault  attribute also checks that the field value is not       null  before saving a record to the database. You can adjust this behavior by     using the  PersistingCheck  property. Its value indicates whether the attribute     should verify that the value is not  null , verify that the value is not       null  or a blank string, or not perform any verification. The attribute can redirect the error that happened on the field to another field if you set     the  MapErrorTo  property. You can use the static methods of the attribute to change the attribute properties for a     particular data record in the cache or for all data records in the cache. Differences You usually set the default value to a DAC field by using the  PXDefault      attribute. You can set a constant as the default value or provide a BQL query to obtain a value     from the database or data records from the cache. The default value is assigned to the field     when a data record that includes this field is inserted into the cache. You can use the  PXDefault  attribute just to make the field mandatory for     input by using the attribute without parameters. The  PXDefault  attribute is not suitable when the default value is retrieved     from a field that can be auto-generated by the database (such as the identity field). In this     case, you should use the  PXDBDefault  attribute. It updates the value assigned     to the field as the default with the value generated by the database. For example, if you implement a master-detail relationship, you should use the       PXDBDefault  attribute to bind the detail data record fields to the master     data record key fields. If the master data record is new, its identity field is set to a real     value by the database when the master record is saved. So if a detail data record is created     before the master data record is saved, the detail data record field is set to the temporary     value of the master identity field. However, the  PXDBDefault  attribute     replaces the temporary value with the real value when the detail data record is saved to the     database. You can use the  PXUnboundDefault  attribute to set the default value to an     unbound field. The value is assigned when a data record is retrieved from the database (on the       RowSelecting  event). PXDBDefaultAttribute Class PXDefaultAttribute Class PXUnboundDefaultAttribute Class ]]></column>
		</row>
		<row PageID="e4cb712a-076e-4da4-b7dc-79be3192e8ef" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="621698f2-bec5-fce0-d109-00cecb48a454" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use attributes to configure complex input controls, such as drop-down lists and lookup controls.{br}{TOC}
==Drop-Down Lists==
You can use the following attributes to configure a drop-down list that represents a data access class (DAC) field in the user interface:[anchor|#ul_kgf_hvr_rk]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=426773d0-8861-2fe4-d789-0d7d41f8bae9|<tt>PXStringList</tt>]: Configures a drop-down list from which a user can select from a fixed set of strings.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c09a2a41-bd5d-5633-898c-bda54ae9f933|<tt>PXIntList</tt>]: Configures a drop-down list where a user can select from a fixed set of values. The control displays strings, while the field is assigned the integer value corresponding to the selected string. 
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1694aae7-8afa-7428-2769-9fb9ac51bdf3|<tt>PXDecimalList</tt>]: Configures a drop-down list where a user can select from a fixed set of strings converted to decimal values.
*<tt>PXImagesList</tt>: Configures a drop-down list where a user can select from a fixed set of images.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=0f8c60a8-06ba-bb4e-b501-584ebc1c6327|<tt>PXDBIntList</tt>]: Configures a drop-down control for an integer field. The values and labels for the drop-down control are retrieved from the specified database table.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b2acdca2-7bb3-6ec2-e783-2169f22256d4|<tt>PXDBStringList</tt>]: Configures a drop-down control for a string field. The values and labels for the drop-down control are retrieved from the specified database table.

==Lookup Controls==
You can use the following attributes to configure a lookup control that represents a field in the user interface:[anchor|#ul_sgf_hvr_rk]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6ed489c0-36a3-9790-7bcd-5072e718a728|<tt>PXSelector</tt>]: Defines a lookup control for a DAC field that references a data record from a particular table by holding its key.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=45e2b103-e3ae-d59e-57dc-985bb665181e|<tt>PXCustomSelector</tt>]: Serves as the base class to derive custom attributes used to configure lookup controls.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8b1d5510-5820-f605-78f6-191bf1c89944|<tt>PXRestrictor</tt>]: Adds a restriction to a BQL command that selects data for a lookup control, and displays an error message when the value entered does not fit the restriction. The attribute works only with <tt>PXSelector</tt> and cannot be used with <tt>PXCustomSelector</tt>.

==Segmented Key Controls==
A segmented key value is a string value that identifies a data record in the system and consists of one segment or multiple segments. A segmented key is an entity that is identified by a string (referred to as a ''dimension'') and associated with segments. For each segment, you can define the list of possible values. You can create a new segment when the data records identified by the segmented key already exist in the database.{br}

You can use the following attributes to configure a control to input a segmented key value in the user interface:[anchor|#ul_h5z_jpz_rk]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=60b4d8bd-443c-df2d-19dd-fbe3da498dee|<tt>PXDimension</tt>]: Defines an input control that formats the input as a segmented key value and displays the list of allowed values for each key segment.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=836b2dd0-009b-da18-ac40-019c3c5eb8e3|<tt>PXDimensionSelector</tt>]: Defines an input control that combines the functionality of the <tt>PXDimenstion</tt> attribute and the <tt>PXSelector</tt> attribute. A user can view the data set defined by the attribute and select a data record from this data set to assign its segmented key value to the field or to replace it with the surrogate key.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=70c2d94f-a115-b3c2-ad61-89c48e569114|<tt>PXDimensionWildcard</tt>]: Behaves similarly to the <tt>PXDimensionSelector</tt> attribute, but also allows the ''?'' character to be treated as a wildcard.
]]></column>
			<column name="PlainText"><![CDATA[Complex Input Controls You can use attributes to configure complex input controls, such as drop-down lists and         lookup controls. Drop-Down Lists You can use the following attributes to configure a drop-down list that represents a data         access class (DAC) field in the user interface: PXStringList <tt>PXStringList</tt>: Configures a           drop-down list from which a user can select from a fixed set of strings. PXIntList <tt>PXIntList</tt>: Configures a           drop-down list where a user can select from a fixed set of values. The control displays           strings, while the field is assigned the integer value corresponding to the selected           string.  PXDecimalList <tt>PXDecimalList</tt>: Configures a           drop-down list where a user can select from a fixed set of strings converted to decimal           values. PXImagesList : Configures a drop-down list where a user can select           from a fixed set of images. PXDBIntList <tt>PXDBIntList</tt>: Configures a           drop-down control for an integer field. The values and labels for the drop-down control           are retrieved from the specified database table. PXDBStringList <tt>PXDBStringList</tt>: Configures a           drop-down control for a string field. The values and labels for the drop-down control are           retrieved from the specified database table. Lookup Controls You can use the following attributes to configure a lookup control that represents a field         in the user interface: PXSelector <tt>PXSelector</tt>: Defines a lookup control for a DAC field that           references a data record from a particular table by holding its key. PXCustomSelector <tt>PXCustomSelector</tt>: Serves as the base class to derive custom           attributes used to configure lookup controls. PXRestrictor <tt>PXRestrictor</tt>: Adds a           restriction to a BQL command that selects data for a lookup control, and displays an error           message when the value entered does not fit the restriction. The attribute works only with              PXSelector  and cannot be used with              PXCustomSelector . Segmented Key Controls A segmented key value is a string value that identifies a data record in the system and         consists of one segment or multiple segments. A segmented key is an entity that is         identified by a string (referred to as a  dimension ) and associated with segments. For         each segment, you can define the list of possible values. You can create a new segment when         the data records identified by the segmented key already exist in the database. You can use the following attributes to configure a control to input a segmented key value         in the user interface: PXDimension <tt>PXDimension</tt>: Defines an input control that formats the input           as a segmented key value and displays the list of allowed values for each key           segment. PXDimensionSelector <tt>PXDimensionSelector</tt>: Defines an input control that combines           the functionality of the  PXDimenstion  attribute and the              PXSelector  attribute. A user can view the data set defined by the           attribute and select a data record from this data set to assign its segmented key value to           the field or to replace it with the surrogate key. PXDimensionWildcard <tt>PXDimensionWildcard</tt>: Behaves similarly to the              PXDimensionSelector  attribute, but also allows the  ?  character           to be treated as a wildcard. ]]></column>
		</row>
		<row PageID="5dcd7912-7a39-4d7d-9350-f2d9f19fb83f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e65c2f6c-4be5-1d00-2b65-1a3747c5635a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can use the following attributes to implement referential integrity and perform calculations at run time:[anchor|#ul_ezn_l13_sk]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a916cba2-1f12-0c2b-8f70-31b1ecc05b99|<tt>PXParent</tt>]: Creates a reference to a parent data record. By default, when the parent data record is deleted, all child data records that reference it are also deleted. (You can change this behavior by using the <tt>LeaveChildren</tt> property.)
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3ee852ea-0af8-aea8-81e2-2e90aa3769d7|<tt>PXFormula</tt>]: Calculates a field from other fields of the same data record or sets an aggregation expression to calculate a parent data record field from its child data record fields. These calculations happen only when the parent field is changed or a new record is inserted.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1247ee11-793e-41fb-e126-788cd13b4bc4|<tt>PXUnboundFormula</tt>]: Calculates the value from the child data record fields and aggregates all such values computed for the child data records into the parent data record field. These calculations happen on every data reading.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=52e14c1d-8f10-4eb7-99c7-7ad12c4d9da5|<tt>PXDBChildIdentity</tt>]: Indicates that a DAC field references an auto-generated key field from another table, and ensures that the field value is correct after changes have been committed to the database.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=46ca2072-24fa-e6d7-6914-d56eab4e3c89|<tt>PXLineNbr</tt>]: Generates unique line numbers that identify child data records in the parent-child relationship.

Note that all the attributes in the list above add server-side logic used at run time. The referential integrity is implemented on the server side, as are the calculations. See the [HelpRoot_Dev_Platform\BL__con_Attr_SQL_Adhoc|Ad Hoc SQL for Fields] topic for information about the attributes that enable the calculation of fields on the database side.]]></column>
			<column name="PlainText"><![CDATA[Referential Integrity and Calculations You can use the following attributes to implement referential integrity and perform         calculations at run time: PXParent <tt>PXParent</tt>: Creates a reference           to a parent data record. By default, when the parent data record is deleted, all child           data records that reference it are also deleted. (You can change this behavior by using           the  LeaveChildren  property.) PXFormula <tt>PXFormula</tt>: Calculates a field           from other fields of the same data record or sets an aggregation expression to calculate a           parent data record field from its child data record fields. These calculations happen only           when the parent field is changed or a new record is inserted. PXUnboundFormula <tt>PXUnboundFormula</tt>: Calculates           the value from the child data record fields and aggregates all such values computed for           the child data records into the parent data record field. These calculations happen on           every data reading. PXDBChildIdentity <tt>PXDBChildIdentity</tt>: Indicates           that a DAC field references an auto-generated key field from another table, and ensures           that the field value is correct after changes have been committed to the database. PXLineNbr <tt>PXLineNbr</tt>: Generates                                         unique line numbers that identify child data records in the                                         parent-child relationship. Note that all the attributes in the list above add server-side logic used at run time. The                                 referential integrity is implemented on the server side, as are the                                 calculations. See the  Ad Hoc SQL for Fields topic                                 for information about the attributes that enable the calculation of                                 fields on the database side. ]]></column>
		</row>
		<row PageID="95f32fae-7e43-4998-8c17-4236039a9da9" Language="en-US" PageRevisionID="1" Content="&#xA;The following attributes define the database-side calculation of data access class (DAC) fields that are not bound to particular database columns:[anchor|#ul_jql_1pz_tk]&#xA;*[https://help.acumatica.com/Main?ScreenId=ShowWiki&amp;pageid=514ddad8-b833-bef0-6eab-389eee1f9f6d|&lt;tt&gt;PXDBCalced&lt;/tt&gt;]: Defines an SQL expression that calculates an unbound field from the fields of the same DAC whose values are taken from the database.&#xA;*[https://help.acumatica.com/Main?ScreenId=ShowWiki&amp;pageid=6d5c11d9-def0-db67-945d-17f4d36db5b4|&lt;tt&gt;PXDBScalar&lt;/tt&gt;]: Defines an SQL subrequest that retrieves a value for an unbound DAC field. The subrequest can retrieve data from any bound field in any DAC.&#xA;&#xA;The attributes add the provided expression and the subrequest into the SQL query that selects data records of the given DAC." PlainText="Ad Hoc SQL for Fields The following attributes define the database-side calculation of data access class (DAC)         fields that are not bound to particular database columns: PXDBCalced &lt;tt&gt;PXDBCalced&lt;/tt&gt;: Defines an SQL expression that calculates an           unbound field from the fields of the same DAC whose values are taken from the           database. PXDBScalar &lt;tt&gt;PXDBScalar&lt;/tt&gt;: Defines an SQL subrequest that retrieves a value           for an unbound DAC field. The subrequest can retrieve data from any bound field in any           DAC. The attributes add the provided expression and the subrequest into the SQL query that         selects data records of the given DAC. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f14e8a74-a10f-404b-9f30-560c14662d3a" RecordSourceID="22377" />
		<row PageID="259a9d39-e09d-4caf-969c-743f7b32deef" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="9eb043ed-193f-3308-d567-3a7bb19c4e1f" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The following attributes are placed on data access class (DAC) fields used for data audit: 
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=cd35c842-a4e7-e544-6dd1-6fefe379b341|<tt>PXDBLastChangeDateTime</tt>]: Maps a DAC field to the database column and automatically sets the field value to the data record&rsquo;s last modification date and time.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b2ed3b4c-869e-aa78-0440-25e5237d22a0|<tt>PXDBCreatedByID</tt>]: Maps a DAC field to a database column and automatically sets the field value to the ID of the user who created the data record.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7c141c4d-1c51-04d3-6011-c2277ecb2bf9|<tt>PXDBCreatedByScreenID</tt>]: Maps a DAC field to a database column and automatically sets the field value to the string ID of the application screen from which the data record was created.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=77dfd6d6-6050-1a83-2558-0351009241d0|<tt>PXDBCreatedDateTime</tt>]: Maps a DAC field to a database column and automatically sets the field value to the data record&rsquo;s creation date and time.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=62e93d23-636e-57c7-2b4f-6f4fe671e1ae|<tt>PXDBCreatedDateTimeUtc</tt>]: Maps a DAC field to a database column and automatically sets the field value to the data record&rsquo;s creation UTC date and time.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=99f6ff22-674a-629f-c9cb-02c17b6d26e5|<tt>PXDBLastModifiedByID</tt>]: Maps a DAC field to a database column and automatically sets the field value to the ID of the user who last modified the data record.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3575a029-3f68-4972-c950-9fc72b0c137b|<tt>PXDBLastModifiedByScreenID</tt>]: Maps a DAC field to a database column and automatically sets the field value to the string ID of the application screen on which the data record was last modified.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=acfc21ea-e732-de8c-5a29-89695691f22f|<tt>PXDBLastModifiedDateTime</tt>]: Maps a DAC field to a database column and automatically sets the field value to the data record&rsquo;s last modification date and time.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=19f32b15-683b-f8d2-fded-b6caf2475f1d|<tt>PXDBLastModifiedDateTimeUtc</tt>]: Maps a DAC field to a database column and automatically sets the field value to the data record&rsquo;s last modification date and time in UTC.

The framework binds the DAC fields to database columns and automatically assigns field values.]]></column>
			<column name="PlainText"><![CDATA[Audit Fields The following attributes are placed on data access class (DAC) fields                                 used for data audit:  PXDBLastChangeDateTime <tt>PXDBLastChangeDateTime</tt>:                                         Maps a DAC field to the database column and automatically                                         sets the field value to the data record's last modification                                         date and time. PXDBCreatedByID <tt>PXDBCreatedByID</tt>: Maps a                                         DAC field to a database column and automatically sets the                                         field value to the ID of the user who created the data                                         record. PXDBCreatedByScreenID <tt>PXDBCreatedByScreenID</tt>:                                         Maps a DAC field to a database column and automatically sets                                         the field value to the string ID of the application screen                                         from which the data record was created. PXDBCreatedDateTime <tt>PXDBCreatedDateTime</tt>:                                         Maps a DAC field to a database column and automatically sets                                         the field value to the data record's creation date and                                         time. PXDBCreatedDateTimeUtc <tt>PXDBCreatedDateTimeUtc</tt>:                                         Maps a DAC field to a database column and automatically sets                                         the field value to the data record's creation UTC date and                                         time. PXDBLastModifiedByID <tt>PXDBLastModifiedByID</tt>:                                         Maps a DAC field to a database column and automatically sets                                         the field value to the ID of the user who last modified the                                         data record. PXDBLastModifiedByScreenID <tt>PXDBLastModifiedByScreenID</tt>:                                         Maps a DAC field to a database column and automatically sets                                         the field value to the string ID of the application screen                                         on which the data record was last modified. PXDBLastModifiedDateTime <tt>PXDBLastModifiedDateTime</tt>:                                         Maps a DAC field to a database column and automatically sets                                         the field value to the data record's last modification date                                         and time. PXDBLastModifiedDateTimeUtc <tt>PXDBLastModifiedDateTimeUtc</tt>:                                         Maps a DAC field to a database column and automatically sets                                         the field value to the data record's last modification date                                         and time in UTC. The framework binds the DAC fields to database columns and automatically                                 assigns field values. ]]></column>
		</row>
		<row PageID="c41b409d-9580-42a9-9d79-76227ed7aeda" Language="en-US" PageRevisionID="1" Content="&#xA;The following attributes implement the projection of data from one table or multiple tables into a single data access class (DAC):[anchor|#ul_jtw_132_5k]&#xA;*[https://help.acumatica.com/Main?ScreenId=ShowWiki&amp;pageid=2331ae85-d8bc-88a4-a205-d9d41825f447|&lt;tt&gt;PXProjection&lt;/tt&gt;]: Binds the DAC to a random data set. The attribute thus defines a named view, but is implemented by the server side rather than by the database.&#xA;*[https://help.acumatica.com/Main?ScreenId=ShowWiki&amp;pageid=2b648bf4-6cf4-522e-52d7-a2db46f61f17|&lt;tt&gt;PXExtraKey&lt;/tt&gt;]: Indicates that the field implements a relationship between two tables. The use of this attribute enables the update of the referenced table when the projection is updated.&#xA;" PlainText="Data Projection The following attributes implement the projection of data from one table or multiple tables         into a single data access class (DAC): PXProjection &lt;tt&gt;PXProjection&lt;/tt&gt;: Binds the DAC to           a random data set. The attribute thus defines a named view, but is implemented by the           server side rather than by the database. PXExtraKey &lt;tt&gt;PXExtraKey&lt;/tt&gt;: Indicates that the field implements a             relationship between two tables. The use of this attribute enables the update of the             referenced table when the projection is updated. " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="574240f8-999a-5e94-1a74-ec2bcde559b7" RecordSourceID="22377" />
		<row PageID="03d5ea15-1d8d-44fc-9c3b-acf797fce811" Language="en-US" PageRevisionID="1" Content="&#xA;The group mask value indicates the access rights a user should have in order to use a data record. To be able to set access rights for particular data records, you should use the &lt;tt&gt;PXDBGroupMask&lt;/tt&gt; attribute to mark the data access class (DAC) field that holds the group mask value.{br}&#xA;&#xA;On a substitute form, to define the inheritance of access rights for an action that is implemented in the corresponding entry form, you can use the &lt;tt&gt;PXEntryScreenRights&lt;/tt&gt; attribute.&#xA;==Related Articles==&#xA;*[https://help.acumatica.com/Main?ScreenId=ShowWiki&amp;pageid=0b26fe07-448a-37c0-7d90-73b6cd8385dc|PXDBGroupMaskAttribute Class]&#xA;*[https://help.acumatica.com/Main?ScreenId=ShowWiki&amp;pageid=ba267379-af16-f332-3ab2-d0c4902aa4da|PXEntryScreenRightsAttribute Class]" PlainText="Access Control The group mask value indicates the access rights a user should have in order to use a data         record. To be able to set access rights for particular data records, you should use the            PXDBGroupMask  attribute to mark the data access class (DAC) field that         holds the group mask value. On a substitute form, to define the inheritance of access rights for an action that is         implemented in the corresponding entry form, you can use the            PXEntryScreenRights  attribute. PXDBGroupMaskAttribute Class PXEntryScreenRightsAttribute Class " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="4cef5290-8a4b-2e92-5dd7-c264b400a87a" RecordSourceID="22377" />
		<row PageID="1206ded4-46ba-4d69-868e-ecf4a1f2ed09" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="da1e7420-531a-6364-a889-3a482613758e" RecordSourceID="22377">
			<column name="Content"><![CDATA[
By using the <tt>PXNote</tt> attribute, you can give users the ability to attach text notes, files, and activity items to data records, and to search for an entity by using the full-text search index.{br}

You should use the <tt>PXNote</tt> attribute in the data access class of these data records to mark the field that stores the identifier of a note in the <tt>Note</tt> table. Notes are used to attach text to a data record. This text is stored in the note data record in the <tt>Note</tt> table. Additionally, you can attach files or other entities to a data record through a note. This feature is implemented through additional tables that store the identifiers of a note and the attached entity.{br}

The <tt>PXNote</tt> attribute can also be configured to save the specified table fields in a note. In this case, by using the Acumatica Framework application website search, the user will be able to search the data records by the values saved in the note.
==Related Articles==
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7996b57b-bfd3-ce24-d5dd-495b07254467|PXNoteAttribute Class]
*[HelpRoot_Dev_Platform\BL__how_Work_with_Attachments|To Allow Attachments to a Particular Webpage]
*[HelpRoot_Dev_Platform\BL__how_Display_Attached_Image|To Display an Attached Image on the Webpage]]]></column>
			<column name="PlainText"><![CDATA[Notes By using the  PXNote  attribute, you can give users the ability to attach         text notes, files, and activity items to data records, and to search for an entity by using         the full-text search index. You should use the  PXNote  attribute in the data access class of these         data records to mark the field that stores the identifier of a note in the            Note  table. Notes are used to attach text to a data record. This text         is stored in the note data record in the  Note  table. Additionally, you         can attach files or other entities to a data record through a note. This feature is         implemented through additional tables that store the identifiers of a note and the attached         entity. The  PXNote  attribute can also be configured to save the specified table         fields in a note. In this case, by using the  Acumatica Framework         application website search, the user will be able to search the data records by the values         saved in the note. PXNoteAttribute Class ]]></column>
		</row>
		<row PageID="72931747-da3b-4fc2-a766-a60c72b12f8d" Language="en-US" PageRevisionID="1" Content="&#xA;The value of an unbound data access class (DAC) field can be calculated in the property getter. The calculation can involve other fields of the same DAC. However, when the value of the DAC field is requested, other fields are not guaranteed to be calculated or assigned their values. These situations are normal when the integration services are used, copy-paste functionality is used, or the field is used in reports.{br}&#xA;&#xA;To ensure that the fields referenced in the property getter have values when it is executed, you should use the &lt;tt&gt;PXDependsOnFields&lt;/tt&gt; attribute.&#xA;==Related Articles==&#xA;*[https://help.acumatica.com/Main?ScreenId=ShowWiki&amp;pageid=5f2cb583-5aea-a584-786b-79aeb224895c|PXDependsOnFieldsAttribute Class]&#xA;*[HelpRoot_Dev_Platform\CC__con_Rendering_of_Reports|Display of Reports]" PlainText="Report Optimization The value of an unbound data access class (DAC) field can be calculated in the property         getter. The calculation can involve other fields of the same DAC. However, when the value of         the DAC field is requested, other fields are not guaranteed to be calculated or assigned         their values. These situations are normal when the integration services are used, copy-paste         functionality is used, or the field is used in reports. To ensure that the fields referenced in the property getter have values when it is         executed, you should use the  PXDependsOnFields  attribute. PXDependsOnFieldsAttribute Class " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="6fbb4cd5-d33d-f9c7-85bb-bc5f791c30dd" RecordSourceID="22377" />
		<row PageID="feec5367-994f-482c-b662-1006346d61c6" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="1906394f-134b-0040-2e46-b7a0e20573a8" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can place the following attributes on the data access class (DAC) declaration:[anchor|#ul_vgt_1jw_sk]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1dceb511-4e98-3700-7d7f-231688a7ac74|<tt>PXPrimaryGraph</tt>]: Specifies the graph that is used by default to edit a data record.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6e89e21c-b8f4-a16b-d741-2d6e483e9f65|<tt>PXCacheName</tt>]: Specifies the user-friendly name of the DAC. The name is displayed in the user interface.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=4c06b326-4644-cb3c-d502-327d3eb5a905|<tt>PXTable</tt>]: Binds a DAC that derives from another DAC to the table having the name of the derived table. Without the attribute, the derived DAC will be bound to the same table as the DAC that starts the inheritance hierarchy.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=4addf6d6-3ae5-0141-2edf-e44ff68a4a2b|<tt>PXAccumulator</tt>]: Updates the values of a data record in the database according to the policies specified in the attribute parameters.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a57486ae-817e-bfca-8807-baf14eb5d1be|<tt>PXHidden</tt>]: Gives the developer the ability to hide a DAC, graph, or view from the selectors of DACs and graphs, and from generic inquiries, reports, and the web services API.

The <tt>PXProjection</tt> and <tt>PXTable</tt> attributes can also mark a DAC. See [HelpRoot_Dev_Platform\BL__con_Attr_Projection|Data Projection] for more details.]]></column>
			<column name="PlainText"><![CDATA[Attributes on DACs You can place the following attributes on the data access class (DAC)                 declaration: PXPrimaryGraph <tt>PXPrimaryGraph</tt>:                     Specifies the graph that is used by default to edit a data record. PXCacheName <tt>PXCacheName</tt>:                     Specifies the user-friendly name of the DAC. The name is displayed in the user                     interface. PXTable <tt>PXTable</tt>: Binds a DAC that derives from                     another DAC to the table having the name of the derived table. Without the                     attribute, the derived DAC will be bound to the same table as the DAC that                     starts the inheritance hierarchy. PXAccumulator <tt>PXAccumulator</tt>:                     Updates the values of a data record in the database according to the policies                     specified in the attribute parameters. PXHidden <tt>PXHidden</tt>: Gives the                     developer the ability to hide a DAC, graph, or view from the selectors of DACs                     and graphs, and from generic inquiries, reports, and the web services API. The  PXProjection  and  PXTable  attributes can                 also mark a DAC. See  Data Projection for more                 details. ]]></column>
		</row>
		<row PageID="d7f7a53e-2a1b-49a6-be49-d2b1844c5a00" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="228e72ff-6000-ea29-7dc5-51a82e3736fe" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You use the following attributes to configure a button that will represent an action in the user interface:
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=54a2a223-b5ee-4e10-96af-a1a0853b6ce6|<tt>PXButton</tt>]: Serves as the base attribute for all other attributes, which give you the ability to configure buttons. The successor attributes only set the base class properties to specific values.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=32cb704a-5b7d-52c4-382d-07ad96524417|<tt>PXSaveButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3dee11ff-f322-9b6c-ed0e-6d3aa34640c9| <tt>PXSaveCloseButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=9cb42733-87b0-b6cd-ae8f-e7beb3934dba| <tt>PXCancelButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=8ee33144-6260-f281-aac0-e37030500ea0| <tt>PXCancelCloseButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1e6c3f34-fdce-1c7a-6896-25eab35218ed| <tt>PXInsertButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=3531d82d-30ee-5fd7-3e63-7dcb8eb22cce| <tt>PXDeleteButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=7a433359-55b8-d164-f531-42af4ca4075b| <tt>PXFirstButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c4fa313c-39e3-6b9a-5e2e-eb8fd5e349c3| <tt>PXPreviousButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=352ef8fb-fb92-97b5-68bb-098fa3a8c484| <tt>PXNextButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a8a501e1-1026-bef1-212b-a9e7e5626408| <tt>PXLastButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=64e89440-831a-5138-a7a9-893fd7c90b39| <tt>PXSendMailButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=096a97f9-23f7-d4e5-3200-04c3a5301f70| <tt>PXReplyMailButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=da3571a5-7790-e382-1f81-fc5f5af8340c| <tt>PXForwardMailButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=2a0013c8-d48a-985b-b140-7d6d1274bc23| <tt>PXTemplateMailButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=802b22a5-4210-bd81-41f2-4e62b3dee1ab| <tt>PXLookupButton</tt>]
* [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=6011f104-56a5-2bf8-ba17-4a394831c635| <tt>PXProcessButton</tt>]

Also, you can use the following attributes:[anchor|#_ae4ee79c-5cc1-4f95-a9f5-df1fbafcc4b9]
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ea7ce94e-4b3e-0f91-df1d-a4ce8023b184|<tt>PXUIField</tt>]: To configure the button layout and set access rights
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=ba267379-af16-f332-3ab2-d0c4902aa4da|<tt>PXEntryScreenRights</tt>]: On a List as Entry Point screen, to define the inheritance of access rights for an action that is implemented in the appropriate entry screen
]]></column>
			<column name="PlainText"><![CDATA[ Action Attributes You use the following attributes to configure a button that will represent an action in the         user interface: PXButton <tt>PXButton</tt>: Serves as the base attribute for all other attributes, which give you the ability to configure buttons. The successor attributes only set the base class properties to specific values. PXSaveButton <tt>PXSaveButton</tt>PXSaveCloseButton  <tt>PXSaveCloseButton</tt>PXCancelButton  <tt>PXCancelButton</tt>PXCancelCloseButton  <tt>PXCancelCloseButton</tt>PXInsertButton  <tt>PXInsertButton</tt>PXDeleteButton  <tt>PXDeleteButton</tt>PXFirstButton  <tt>PXFirstButton</tt>PXPreviousButton  <tt>PXPreviousButton</tt>PXNextButton  <tt>PXNextButton</tt>PXLastButton  <tt>PXLastButton</tt>PXSendMailButton  <tt>PXSendMailButton</tt>PXReplyMailButton  <tt>PXReplyMailButton</tt>PXForwardMailButton  <tt>PXForwardMailButton</tt>PXTemplateMailButton  <tt>PXTemplateMailButton</tt>PXLookupButton  <tt>PXLookupButton</tt>PXProcessButton  <tt>PXProcessButton</tt>Also, you can use the following attributes: PXUIField <tt>PXUIField</tt>: To configure the             button layout and set access rights PXEntryScreenRights <tt>PXEntryScreenRights</tt>: On a             List as Entry Point screen, to define the inheritance of access rights for an action             that is implemented in the appropriate entry screen ]]></column>
		</row>
		<row PageID="3073449e-2746-472f-b834-6d730bfac4fb" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="871c12bb-2882-62c9-bcdd-f2cf62994bff" RecordSourceID="22377">
			<column name="Content"><![CDATA[
You can place the following attributes on the declaration of a data view in a graph:
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1700f5aa-9484-5b47-02be-6cc2beaa6b6f|<tt>PXFilterable</tt>]: Adds the control that makes it possible for a user to create filters and save them in the database. The control is added to the grid that uses the data view to retrieve data.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=c69d2832-e4b4-2477-928f-8d09762b3b21|<tt>PXImport</tt>]: Adds the grid toobar button that a user clicks to load data from the file to the grid. The attribute is placed on the data view the grid uses to retrieve the data.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=a57486ae-817e-bfca-8807-baf14eb5d1be|<tt>PXHidden</tt>]: Hides the data view from the selectors of data access classes (DACs) and graphs, and from the web service API clients.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=903e4699-206e-bc03-1e4b-d530eb4bb048|<tt>PXCopyPasteHiddenView</tt>]: Indicates that the cache corresponding to the primary DAC of the data view is not copied when the copy-paste feature is used on the webpage.
*[https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=1258f435-4bc7-351c-aabc-7e22c6eb4245|<tt>PXCopyPasteHiddenFields</tt>]: Indicates that the specific fields of the primary DAC of the data view are not copied when the copy-paste feature is used on the webpage.
]]></column>
			<column name="PlainText"><![CDATA[Attributes on Data Views You can place the following attributes on the declaration of a data view in a                 graph: PXFilterable <tt>PXFilterable</tt>: Adds the control that makes it                     possible for a user to create filters and save them in the database. The control                     is added to the grid that uses the data view to retrieve data. PXImport <tt>PXImport</tt>: Adds the                     grid toobar button that a user clicks to load data from the file to the grid.                     The attribute is placed on the data view the grid uses to retrieve the                     data. PXHidden <tt>PXHidden</tt>: Hides the                     data view from the selectors of data access classes (DACs) and graphs, and from                     the web service API clients. PXCopyPasteHiddenView <tt>PXCopyPasteHiddenView</tt>: Indicates that the                     cache corresponding to the primary DAC of the data view is not copied when the                     copy-paste feature is used on the webpage. PXCopyPasteHiddenFields <tt>PXCopyPasteHiddenFields</tt>: Indicates that the                     specific fields of the primary DAC of the data view are not copied when the                     copy-paste feature is used on the webpage. ]]></column>
		</row>
		<row PageID="2d459c9b-fd53-4edd-8867-b09409b6aac2" Language="en-US" PageRevisionID="1" Content="&#xA;In Acumatica Framework-based and customized Acumatica ERP applications, you can attach files to the records displayed on the webpages. This chapter describes how to attach files to the records and display the attached image files on the webpages.&#xA;==In This Chapter==[anchor|#_b683173d-f1f8-49ca-914a-115a156201ec]&#xA;*[HelpRoot_Dev_Platform\BL__how_Work_with_Attachments|To Allow Attachments to a Particular Webpage]&#xA;*[HelpRoot_Dev_Platform\BL__how_Display_Attached_Image|To Display an Attached Image on the Webpage]&#xA;" PlainText="Working with Attachments In  Acumatica Framework-based and customized  Acumatica ERP     applications, you can attach files to the records displayed on the webpages. This chapter     describes how to attach files to the records and display the attached image files on the     webpages. In This Chapter To Allow Attachments to a Particular WebpageTo Display an Attached Image on the Webpage" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="1f35c5f0-9283-5f53-b4ea-ac790d1e868d" RecordSourceID="22377" />
		<row PageID="70a16c7d-8daa-43dd-a979-739117383229" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="2c3fc54a-da4c-838c-64c6-1addc8f51ebe" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Users of Acumatica Framework-based and Acumatica ERP applications can attach files, notes, and activities to master records displayed on webpages. They can also attach files and notes to the detail records, which are displayed in table rows on webpages. In this topic, you can find information about how to allow attachments to a particular webpage and the table rows on a specific webpage.
For more information about how a user can attach files and notes to webpages, see [HelpRoot_Interface\Attaching_Files_to_Forms_and_Records|To Attach a File to a Record] and [HelpRoot_Interface\Attaching_Notes_to_Records|To Attach a Note to a Record]. For information about activities, see [HelpRoot_CRM\CR__con_Managing_Your_Tasks__Events__and_Activities|Tasks, Events, and Activities]. 
((({S:Hint}The extensions of the files that can be uploaded to webpages must be registered on the [HelpRoot_FormReference\SM_20_25_50|File Upload Preferences] ([~/?ScreenId=SM202550|SM202550])  form. If the required file types are not registered on this form, you have to add them and save your changes. On this form, you can also define the maximum size of an uploaded file (in kilobytes).
)))
==To Allow Attachments to a Particular Webpage==[anchor|#_fe1f8714-5da0-40ea-a338-c3fd364fd1e9]
#In the data access class (DAC) that provides data for the webpage, add the <tt>NoteID</tt> field, as the following code shows.<source lang="csharp">#region NoteID
public abstract class noteID : PX.Data.IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; }
#endregion</source>
#:((({S:Hint}The database table that corresponds to the DAC must contain the {{NoteID}} column with the {{uniqueidentifier}} data type.
)))
#Rebuild the project.
#:Once you have added the <tt>NoteID</tt> field to the DAC and rebuilt the project, the following buttons appear on the title bar of the webpage:
#*'''Notes''', which users click to attach notes to the webpage
#*'''Files''', which users click to attach files to the webpage
#Optional: To change whether each of these elements is displayed on the title bar, in the ASPX code of the webpage, specify the values of the following properties of the <tt>PXFormView</tt> control:
#*<tt>NoteIndicator</tt>: Indicates (if set to {{True}}) that the '''Notes''' button is displayed on the title bar.
#*<tt>FilesIndicator</tt>: Indicates (if set to {{True}}) that the '''Files''' button is displayed on the title bar.
#*<tt>ActivityIndicator</tt>: Indicates (if set to {{True}}) that the '''Activities''' button is displayed on the title bar. This button, which users click to attach activities to the webpage, is not displayed by default.
#:((({S:Hint}The <tt>LinkIndicator</tt> property, which controlled whether the '''Help''' > '''Get Link''' element was displayed on the title bar, is now obsolete. '''Help''' > '''Get Link''' is always displayed on the title bar.
)))

==To Allow Attachments to Table Rows on a Webpage==[anchor|#_47605912-a26f-4d9e-8363-b133a7487819]
#In the data access class (DAC) that provides data for the table rows, add the <tt>NoteID</tt> field, as the following code shows.<source lang="csharp">#region NoteID
public abstract class noteID : PX.Data.IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; }
#endregion</source>
#:((({S:Hint}The database table that corresponds to the DAC must contain the {{NoteID}} column with the {{uniqueidentifier}} data type.
)))
#Rebuild the project.
#:Once you have added the <tt>NoteID</tt> field to the DAC and rebuilt the project, the following columns appear in the table:
#*[image:StudioDeveloperGuide/Images/Note_icon.png]: The Notes column, which users click to attach notes to the webpage
#*[image:StudioDeveloperGuide/Images/File_Icon.png]: The Files column, which users click to attach files to the webpage
#Optional: To change whether each of these columns is displayed in the table, in the ASPX code of the webpage, specify the values of the following properties of the <tt>PXGrid</tt> control that corresponds to the table:
#*<tt>NoteIndicator</tt>: Indicates (if set to {{True}}) that the Notes column is displayed in the table
#*<tt>FilesIndicator</tt>: Indicates (if set to {{True}}) that the Files column is displayed in the table
]]></column>
			<column name="PlainText"><![CDATA[To Allow Attachments to a Particular Webpage Users of  Acumatica Framework-based and  Acumatica ERP applications can attach files, notes, and activities to master records displayed on         webpages. They can also attach files and notes to the detail records, which are displayed in         table rows on webpages. In this topic, you can find information about how to allow         attachments to a particular webpage and the table rows on a specific webpage. For more information about how a user can attach files and notes to         webpages, see  To Attach a File to a Record and            To Attach a Note to a Record. For information about         activities, see  Tasks, Events, and Activities.          The extensions of the files that can be uploaded to webpages must be           registered on the   ([~/?ScreenId=SM202550|SM202550]) File Upload Preferences(SM202550)   form. If the required file types are not registered on this form, you           have to add them and save your changes. On this form, you can also define the maximum size           of an uploaded file (in kilobytes). To Allow Attachments to a Particular Webpage In the data access class (DAC) that provides data for the webpage, add the        NoteID  field, as the following code       shows. #region NoteID
public abstract class noteID : PX.Data.IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; }
#endregion The       database table that corresponds to the DAC must contain the  NoteID  column       with the  uniqueidentifier  data type. Rebuild the project. Once you have added the  NoteID  field to the DAC             and rebuilt the project, the following buttons appear on the title bar of the             webpage: Notes , which users click to attach notes to the webpage Files , which users click to attach files to the webpage Optional: To change whether each of these elements is displayed on the title bar, in the           ASPX code of the webpage, specify the values of the following properties of the              PXFormView  control: NoteIndicator : Indicates (if set to  True ) that               the  Notes  button is displayed on the title bar. FilesIndicator : Indicates (if set to  True ) that               the  Files  button is displayed on the title bar. ActivityIndicator : Indicates (if set to  True )               that the  Activities  button is displayed on the title bar. This               button, which users click to attach activities to the webpage, is not displayed by               default. The  LinkIndicator  property, which controlled whether the  Help Get Link  element was displayed on the title bar, is now obsolete.  Help Get Link  is always displayed on the title bar. To Allow Attachments to Table Rows on a Webpage In the data access class (DAC) that provides data for the table rows, add the              NoteID  field, as the following code             shows. #region NoteID
public abstract class noteID : PX.Data.IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; }
#endregion The             database table that corresponds to the DAC must contain the  NoteID              column with the  uniqueidentifier  data type. Rebuild the project. Once you have added the  NoteID  field to the             DAC and rebuilt the project, the following columns appear in the table: : The Notes column, which users click to               attach notes to the webpage : The Files column, which users click to               attach files to the webpage Optional: To change whether each of these columns is displayed in the table, in the ASPX           code of the webpage, specify the values of the following properties of the              PXGrid  control that corresponds to the table: NoteIndicator : Indicates (if set to  True ) that               the Notes column is displayed in the table FilesIndicator : Indicates (if set to  True ) that               the Files column is displayed in the table ]]></column>
		</row>
		<row PageID="cfec85eb-0597-4577-b0e6-4e127c38c134" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="3182fb4b-22fc-4d12-4477-655a710b7350" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you will learn how to display an attached image file on the webpage. In Acumatica ERP, you can find an example of an image file displayed in the UI on the '''Attributes''' tab of the [HelpRoot_FormReference\IN_20_25_00|Stock Items] ([~/?ScreenId=IN202500|IN202500]) form.
==To Display the Attached Image on the Webpage==
#Add the <tt>NoteID</tt> field and the field that stores the path to the image to the data access class (DAC) that provides data for the webpage on which you want to display the image, as shown in the following code.<source lang="csharp">#region NoteID
public abstract class noteID : PX.Data.IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; }
#endregion

#region ImageUrl
public abstract class imageUrl : PX.Data.IBqlField { }

[PXDBString(255)]
[PXUIField(DisplayName = "Image")]
public virtual string ImageUrl { get; set; }
#endregion</source>
#:((({S:Hint}The database table that provides data for the webpage on which you want to display the image must contain the following columns: [anchor|#_2b4ff834-6e28-4319-9555-c9286ee979a6]
*{{NoteID}} with the {{uniqueidentifier}} data type, to make it possible to attach images
*The field (in this example, {{ImageUrl}}) with the {{varchar(255)}} data type, to store the internal path to the attached image
)))
#In the ASPX code of the webpage that works with this DAC, add the <tt>PXImageUploader</tt> control linked to the <tt>ImageUrl</tt> data field, as shown in the following code. {{{{&lt;px:PXImageUploader Height="320px" Width="430px" 
            ID="imgUploader" runat="server" DataField="ImageUrl" 
            AllowUpload="true" ShowComment="true"
/&gt;
}}}}
#Rebuild the project.
]]></column>
			<column name="PlainText"><![CDATA[To Display an Attached Image on the Webpage In this topic, you will learn how to display an attached image file on the webpage. In  Acumatica ERP, you can find an example of an image file displayed in the UI on the            Attributes  tab of the   ([~/?ScreenId=IN202500|IN202500]) Stock Items (IN202500)         form. To Display the Attached Image on the Webpage Add the  NoteID  field and the field that stores the path to the image           to the data access class (DAC) that provides data for the webpage on which you want to           display the image, as shown in the following             code. #region NoteID
public abstract class noteID : PX.Data.IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; }
#endregion

#region ImageUrl
public abstract class imageUrl : PX.Data.IBqlField { }

[PXDBString(255)]
[PXUIField(DisplayName = "Image")]
public virtual string ImageUrl { get; set; }
#endregion The             database table that provides data for the webpage on which you want to display the image             must contain the following columns:  NoteID  with the  uniqueidentifier  data type, to                 make it possible to attach images The field (in this example,  ImageUrl ) with the                    varchar(255)  data type, to store the internal path to the                 attached image In the ASPX code of the webpage that works with this DAC, add the              PXImageUploader  control linked to the  ImageUrl            data field, as shown in the following code.            <px:PXImageUploader Height="320px" Width="430px" 
            ID="imgUploader" runat="server" DataField="ImageUrl" 
            AllowUpload="true" ShowComment="true"
/> Rebuild the project. ]]></column>
		</row>
		<row PageID="be859525-1515-4b35-8ac4-19250ea1b144" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can find information about configuration of the user interface of an Acumatica Framework-based application that involves not only the changing of the ASPX code of the webpage (as described in [HelpRoot_Dev_Platform\CW__mng|Configuring ASPX Webpages and Reports]) but also the implementation of business logic in the corresponding graph.&#xA;==In This Chapter==[anchor|#_4ec2d8d2-1810-473a-a562-37986c659056]&#xA;*[HelpRoot_Dev_Platform\BL__how_Configur_Input_and_Display_Mask|To Configure an Input Mask and a Display Mask for a Field]&#xA;*[HelpRoot_Dev_Platform\BL__how_Display_Dialog_Box|To Display a Dialog Box]&#xA;" PlainText="Configuring the UI from the Back End In this chapter, you can find information about configuration of the user interface of an  Acumatica Framework-based     application that involves not only the changing of the ASPX code of the webpage (as described in       Configuring ASPX Webpages and Reports) but also the implementation of business logic in the corresponding     graph. In This Chapter To Configure an Input Mask and a Display Mask for a FieldTo Display a Dialog Box" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f0d0443a-74ce-722d-1653-412b0eb62ca9" RecordSourceID="22377" />
		<row PageID="d0758787-4c73-423b-8566-11c83f3acde8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8b065aef-836b-8cfa-6cb4-92adea926dca" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can learn how to create a field on a webpage of an Acumatica Framework-based application so that its value is displayed in a specific format and how to govern what a user can enter as a value of this field. You can specify input and display masks for fields of the string and date and time types. For fields of the string type, you specify only the input mask, which defines both the format in which the user enters the value and the way the value is then displayed. For the date and time fields, you can specify different input and display masks. {br}{TOC}[anchor|#_0cc62625-b0fe-49a1-a170-5c17572f1e2d]
==To Specify an Input Mask and a Display Mask for a String Field==
[anchor|#_b9f91a17-bf67-4694-81bb-d81fd5ed32b0]
#In the data access class (DAC), add a new field or modify an existing {{string}} field as follows: 
##Add one of the string attributes ([https://help.acumatica.com/(W(24))/Main?ScreenId=ShowWiki&pageid=684c8a76-2fb6-3aac-fcd4-c19eeda8304b|<tt>PXDBString</tt>] or [https://help.acumatica.com/(W(24))/Main?ScreenId=ShowWiki&pageid=54a0e4fd-a521-7de4-2817-7ac59805293d|<tt>PXString</tt>]) to the property field.
##Specify the value of the <tt>InputMask</tt> property of the attribute. Use the following conventions to define the mask:
##*{{C}} or {{&}}: The user can enter any symbol.
##*{{A}} or {{a}}: The user can enter any letter or digit.
##*{{L}} or {{?}}: The user can enter only a letter.
##*{{#}}, {{0}}, or {{9}}: The user can enter only a digit.
##*{{>}}: All of the characters that follow this symbol should be in uppercase.
##*{{<}}: All of the characters that follow this symbol should be in lowercase.
##:The following example shows the use of the <tt>InputMask</tt> property.<source lang="csharp">//Users can enter only digits.
//If a user enters "1234567890", the value is displayed as "(123) 456-7890".
[PXDBString(10, InputMask = "(###) ###-####")]
[PXUIField(DisplayName = "Parameter 1")]
public virtual string Parameter1 { get; set; }</source>((({S:Hint}The value is stored in the database without any formatting characters. That is, for the code example above, if a user enters <tt>1234567890</tt>, the field in the database for the corresponding record will contain the same value (<tt>1234567890</tt>).
)))
#In the ASPX code of the webpage, add a new <tt>PXMaskEdit</tt> control or modify the control that corresponds to the field so that it has the <tt>PXMaskEdit</tt> type, as shown in the following code example.{{{{&lt;px:PXMaskEdit ID="edParameter1" runat="server" DataField="Parameter1"/&gt;
}}}}

==To Specify an Input and a Display Mask for a String Field at Run Time==
To specify the input mask for a string field at run time, use a <tt>SetInputMask</tt> method of the [https://help.acumatica.com/(W(24))/Main?ScreenId=ShowWiki&pageid=684c8a76-2fb6-3aac-fcd4-c19eeda8304b|<tt>PXDBString</tt>] or [https://help.acumatica.com/(W(24))/Main?ScreenId=ShowWiki&pageid=54a0e4fd-a521-7de4-2817-7ac59805293d|<tt>PXString</tt>] attribute. You use the same conventions to define the mask as those described for the <tt>InputMask</tt> property in [[#_0cc62625-b0fe-49a1-a170-5c17572f1e2d|To Specify an Input Mask and a Display Mask for a String Field]. {br}

In the following example, the input mask of the {{AccountMask}} field is changed at run time.<source lang="csharp">protected virtual void GLBudgetTree_IsGroup_FieldSelecting(PXCache sender, 
  PXFieldSelectingEventArgs e)
{
  PXStringState strState = (PXStringState)sender.GetStateExt(
    null, typeof(GLBudgetTree.accountID).Name);
  PXDBStringAttribute.SetInputMask(sender, 
    typeof(GLBudgetTree.accountMask).Name, 
    strState.InputMask.Replace('#', 'C'));
}</source>
==To Specify an Input or a Display Mask for a Date and Time Field==[anchor|#_b0171f89-4cd4-4354-8c7c-67cc1254801e]
#In the data access class (DAC), add a new field or modify an existing data and time field as follows:
##Add one of the date and time attributes ([https://help.acumatica.com/(W(31))/Main?ScreenId=ShowWiki&pageid=e13e06c7-dd25-b9ae-6fdb-ca0103b3642b|<tt>PXDate</tt>], [https://help.acumatica.com/(W(33))/Main?ScreenId=ShowWiki&pageid=b9434f84-8a5d-d88c-ee97-cdb53e48c506|<tt>PXDateAndTime</tt>], [https://help.acumatica.com/(W(31))/Main?ScreenId=ShowWiki&pageid=b8abec45-68df-3f25-2661-b48baddf4f2d|<tt>PXDBDate</tt>], [https://help.acumatica.com/(W(38))/Main?ScreenId=ShowWiki&pageid=9cd8c337-f815-e101-4335-56625c37e39e|<tt>PXDBTime</tt>], or [https://help.acumatica.com/(W(33))/Main?ScreenId=ShowWiki&pageid=0fe1d7bb-3452-b2b0-c70c-0de73c8a3c37|<tt>PXDBDateAndTime</tt>]) to the property field.
## Specify the value of the <tt>InputMask</tt> or <tt>DisplayMask</tt> property of the attribute. Use the [https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings|standard] and [https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings|custom] date and time format strings.
#:The following example shows the use of the <tt>InputMask</tt> and <tt>DisplayMask</tt> properties.<source lang="csharp">[PXDateAndTime(DisplayMask = "D", InputMask ="d")]
[PXUIField(DisplayName = "Parameter 1")]
public virtual DateTime? Parameter1 { get; set; }</source>
#In the ASPX code of the webpage, add a new <tt>PXDateTimeEdit</tt> control or modify the control that corresponds to the field so that it has the <tt>PXDateTimeEdit</tt> type, as shown in the following code example.{{{{&lt;px:PXDateTimeEdit ID="edParameter1" runat="server" DataField="Parameter1"/&gt;
}}}}
#:((({S:Hint}You can change how the <tt>PXDateTimeEdit</tt> control is displayed (whether the control shows a calendar selector or a drop-down list with time values) by specifying the value of the <tt>TimeMode</tt> property. The following example causes the system to display the list of time values. {{{{&lt;px:PXDateTimeEdit ID="edParameter1" runat="server" DataField="Parameter1" 
  TimeMode="true"/&gt;
}}}}
)))
]]></column>
			<column name="PlainText"><![CDATA[To Configure an Input Mask and a Display Mask for a Field In this topic, you can learn how to create a field on a webpage of an  Acumatica Framework-based application so that its value is displayed in a specific format and how to govern         what a user can enter as a value of this field. You can specify input and display masks for         fields of the string and date and time types. For fields of the string type, you specify         only the input mask, which defines both the format in which the user enters the value and         the way the value is then displayed. For the date and time fields, you can specify different         input and display masks.  To Specify an Input Mask and a Display Mask for a String Field In the data access class (DAC), add a new field or modify an existing                string  field as follows:  Add one of the string attributes ( PXDBString <tt>PXDBString</tt> or  PXString <tt>PXString</tt>) to the property                 field. Specify the value of the  InputMask  property of the attribute.                 Use the following conventions to define the mask: C  or  & : The user can enter any                     symbol. A  or  a : The user can enter any letter or                     digit. L  or  ? : The user can enter only a                     letter. # ,  0 , or  9 : The user                     can enter only a digit. > : All of the characters that follow this symbol should be in                     uppercase. < : All of the characters that follow this symbol should be                     in lowercase. The following example shows the use of the  InputMask                      property. //Users can enter only digits.
//If a user enters "1234567890", the value is displayed as "(123) 456-7890".
[PXDBString(10, InputMask = "(###) ###-####")]
[PXUIField(DisplayName = "Parameter 1")]
public virtual string Parameter1 { get; set; } The                     value is stored in the database without any formatting characters. That is, for                     the code example above, if a user enters  1234567890 , the                     field in the database for the corresponding record will contain the same value                       ( 1234567890 ). In the ASPX code of the webpage, add a new  PXMaskEdit  control or             modify the control that corresponds to the field so that it has the                PXMaskEdit  type, as shown in the following code             example. <px:PXMaskEdit ID="edParameter1" runat="server" DataField="Parameter1"/> To Specify an Input and a Display Mask for a String Field at Run Time To specify the input mask for a string field at run time, use a            SetInputMask  method of the  PXDBString <tt>PXDBString</tt> or  PXString <tt>PXString</tt> attribute. You use the         same conventions to define the mask as those described for the  InputMask          property in  To Specify an Input Mask and a Display Mask for a String Field To Specify an Input Mask and a Display Mask for a String Field.  In the following example, the input mask of the  AccountMask  field is         changed at run         time. protected virtual void GLBudgetTree_IsGroup_FieldSelecting(PXCache sender, 
  PXFieldSelectingEventArgs e)
{
  PXStringState strState = (PXStringState)sender.GetStateExt(
    null, typeof(GLBudgetTree.accountID).Name);
  PXDBStringAttribute.SetInputMask(sender, 
    typeof(GLBudgetTree.accountMask).Name, 
    strState.InputMask.Replace('#', 'C'));
} To Specify an Input or a Display Mask for a Date and Time Field In the data access class (DAC), add a new field or modify an existing data and time           field as follows: Add one of the date and time attributes ( PXDate <tt>PXDate</tt>,  PXDateAndTime <tt>PXDateAndTime</tt>,  PXDBDate <tt>PXDBDate</tt>,  PXDBTime <tt>PXDBTime</tt>, or  PXDBDateAndTime <tt>PXDBDateAndTime</tt>) to the               property field.  Specify the value of the  InputMask  or                  DisplayMask  property of the attribute. Use the  standard standard and  custom custom date and time format strings. The following example shows the use of the  InputMask  and                DisplayMask              properties. [PXDateAndTime(DisplayMask = "D", InputMask ="d")]
[PXUIField(DisplayName = "Parameter 1")]
public virtual DateTime? Parameter1 { get; set; } In the ASPX code of the webpage, add a new  PXDateTimeEdit  control or           modify the control that corresponds to the field so that it has the              PXDateTimeEdit  type, as shown in the following code             example. <px:PXDateTimeEdit ID="edParameter1" runat="server" DataField="Parameter1"/> You             can change how the  PXDateTimeEdit  control is displayed (whether the             control shows a calendar selector or a drop-down list with time values) by specifying             the value of the  TimeMode  property. The following example causes the             system to display the list of time values.              <px:PXDateTimeEdit ID="edParameter1" runat="server" DataField="Parameter1" 
  TimeMode="true"/> ]]></column>
		</row>
		<row PageID="0893a861-ee7d-49f5-84ea-1740df9f11d6" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="46cf1d55-3143-ed0a-dea0-e9d52f9288d3" RecordSourceID="22377">
			<column name="Content"><![CDATA[When a user clicks a button on a webpage of an Acumatica Framework-based application, you may need to display a dialog box that displays the settings related to the action to be performed. For example, on the [HelpRoot_FormReference\CS_10_15_00|Companies] ([~/?ScreenId=CS101500|CS101500]) form, if you click '''Create Ledger''', the system opens the '''Create Ledger''' dialog box, where a user can specify the setting related to the action.
==To Display a Dialog Box==[anchor|#_626e5ba5-05f1-41d2-bf4c-a0ac132e74a7]
#In the graph that corresponds to the webpage, add the action and the delegate for the button that opens the dialog box, as shown in the following example.<source lang="csharp">public PXAction&lt;MainDAC&gt; openDialogBox;

[PXUIField(DisplayName = "Open Dialog Box",
    MapEnableRights = PXCacheRights.Update,
    MapViewRights = PXCacheRights.Update)]
[PXButton]
public virtual IEnumerable OpenDialogBox(PXAdapter adapter)
{
    return adapter.Get();
}</source>
#:In this example, the {{MainDAC}} DAC is the main DAC of the primary view of the graph; therefore, the action is added to the toolbar of the form by default.
#If you want to specify additional properties of the action (such as <tt>CommitChanges</tt>), in the ASPX code of the webpage, add the <tt>PXDSCallbackCommand</tt> tag for the action and specify the necessary properties of the tag, as shown in the following example.{{{{&lt;px:PXDataSource ID="ds" runat="server" ...&gt;
    &lt;CallbackCommands&gt;
        ...
        &lt;px:PXDSCallbackCommand Name="CreateLedger" CommitChanges="true"/&gt;
    &lt;/CallbackCommands&gt;
&lt;/px:PXDataSource&gt;
}}}}
#In the graph that corresponds to the webpage, add the data view for the dialog box, as shown in the following code.<source lang="csharp">[Serializable]
public class DialogBoxParameters : IBqlTable
{
    public abstract class parameter1 : IBqlField { }
    [PXString(10, IsUnicode = true)]
    public virtual string Parameter1 { get; set; }

    public abstract class parameter2 : IBqlField { }
    [PXString(10, IsUnicode = true)]
    public virtual string Parameter2 { get; set; }
}

PXFilter&lt;DialogBoxParameters&gt; OpenDialogBoxView;</source>
#:In this code, we add a simple DAC with two unbound fields and use a data view based on the <tt>PXFilter</tt> class.
#In the ASPX code of the webpage, add the <tt>PXSmartPanel</tt> container with the <tt>Key</tt> property equal to the name of the data view you created for the dialog box, as shown in the following code. In the <tt>PXPanel</tt> container inside <tt>PXSmartPanel</tt>, add the commit buttons of the dialog box (such as '''OK''', '''Cancel'''). {{{{&lt;px:PXSmartPanel ID="pnlOpenDialogBox" runat="server" 
Style="z-index: 108;" Caption="Open Dialog Box" CaptionVisible="True" 
Key="OpenDialogBoxView" LoadOnDemand="true" AutoCallBack-Command="Refresh" 
AutoCallBack-Target="formOpenDialogBox" AutoCallBack-Enabled="true" 
AcceptButtonID="cbOk" CancelButtonID="cbCancel"&gt;
    &lt;px:PXFormView ID="formOpenDialogBox" runat="server" 
      DataSourceID="ds" DataMember="OpenDialogBoxView" 
      SkinID="Transparent"&gt;
        &lt;ContentStyle BorderWidth="0px"&gt;&lt;/ContentStyle&gt;
        &lt;Template&gt;
            &lt;px:PXLayoutRule runat="server" StartColumn="True" 
              LabelsWidth="SM" ControlSize="M" /&gt;
            &lt;px:PXTextEdit  ID="edParameter1" runat="server" 
              DataField="Parameter1" CommitChanges="True"/&gt;
            &lt;px:PXTextEdit  ID="edParameter2" runat="server" 
              DataField="Parameter2" CommitChanges="True" /&gt;
        &lt;/Template&gt;
    &lt;/px:PXFormView&gt;
    &lt;px:PXPanel ID="PXPanel3" runat="server" SkinID="Buttons"&gt;
        &lt;px:PXButton ID="cbOK" runat="server" Text="OK" 
          CommandSourceID="ds" DialogResult="OK" /&gt;
        &lt;px:PXButton ID="cbCancel" runat="server" Text="Cancel" 
          DialogResult="Cancel" /&gt;
    &lt;/px:PXPanel&gt;
&lt;/px:PXSmartPanel&gt;
}}}}
#In the button delegate, perform a call to an [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=df3262ed-e235-8bf0-66c9-8a2a39df4c3c|<tt>AskExt</tt>] method of the view specified in the <tt>Key</tt> property of the <tt>PXSmartPanel</tt> container.{{{{public virtual IEnumerable OpenDialogBox(PXAdapter adapter)
{
    if (OpenDialogBoxView.AskExt() == WebDialogResult.OK &&
        string.IsNullOrEmpty(OpenDialogBoxView.Current.Parameter1) 
        == false)
    {
        ...
    }
    return adapter.Get();
}
}}}}
#:When the user clicks the button on the webpage, the execution interrupts on the <tt>AskExt</tt> call and the dialog box is displayed. After the user clicks a button in the dialog box, the <tt>AskExt</tt> method returns the dialog box result.
#Rebuild the project.
]]></column>
			<column name="PlainText"><![CDATA[To Display a Dialog Box When a user clicks a button on a webpage of an  Acumatica Framework-based application, you may need to display a dialog box that displays the settings related       to the action to be performed. For example, on the   ([~/?ScreenId=CS101500|CS101500]) Companies (CS101500) form, if you click  Create Ledger , the system opens the          Create Ledger  dialog box, where a user can specify the setting       related to the action. To Display a Dialog Box In the graph that corresponds to the webpage, add the action and the delegate for the           button that opens the dialog box, as shown in the following             example. public PXAction<MainDAC> openDialogBox;

[PXUIField(DisplayName = "Open Dialog Box",
    MapEnableRights = PXCacheRights.Update,
    MapViewRights = PXCacheRights.Update)]
[PXButton]
public virtual IEnumerable OpenDialogBox(PXAdapter adapter)
{
    return adapter.Get();
} In             this example, the  MainDAC  DAC is the main DAC of the primary view of             the graph; therefore, the action is added to the toolbar of the form by           default. If you want to specify additional properties of the action (such as              CommitChanges ), in the ASPX code of the webpage, add the              PXDSCallbackCommand  tag for the action and specify the necessary           properties of the tag, as shown in the following           example. <px:PXDataSource ID="ds" runat="server" ...>
    <CallbackCommands>
        ...
        <px:PXDSCallbackCommand Name="CreateLedger" CommitChanges="true"/>
    </CallbackCommands>
</px:PXDataSource> In the graph that corresponds to the webpage, add the data view for the dialog box, as           shown in the following             code. [Serializable]
public class DialogBoxParameters : IBqlTable
{
    public abstract class parameter1 : IBqlField { }
    [PXString(10, IsUnicode = true)]
    public virtual string Parameter1 { get; set; }

    public abstract class parameter2 : IBqlField { }
    [PXString(10, IsUnicode = true)]
    public virtual string Parameter2 { get; set; }
}

PXFilter<DialogBoxParameters> OpenDialogBoxView; In             this code, we add a simple DAC with two unbound fields and use a data view based on the                PXFilter  class. In the ASPX code of the webpage, add the  PXSmartPanel  container with           the  Key  property equal to the name of the data view you created for the           dialog box, as shown in the following code. In the  PXPanel  container           inside  PXSmartPanel , add the commit buttons of the dialog box (such as              OK ,  Cancel ).            <px:PXSmartPanel ID="pnlOpenDialogBox" runat="server" 
Style="z-index: 108;" Caption="Open Dialog Box" CaptionVisible="True" 
Key="OpenDialogBoxView" LoadOnDemand="true" AutoCallBack-Command="Refresh" 
AutoCallBack-Target="formOpenDialogBox" AutoCallBack-Enabled="true" 
AcceptButtonID="cbOk" CancelButtonID="cbCancel">
    <px:PXFormView ID="formOpenDialogBox" runat="server" 
      DataSourceID="ds" DataMember="OpenDialogBoxView" 
      SkinID="Transparent">
        <ContentStyle BorderWidth="0px"></ContentStyle>
        <Template>
            <px:PXLayoutRule runat="server" StartColumn="True" 
              LabelsWidth="SM" ControlSize="M" />
            <px:PXTextEdit  ID="edParameter1" runat="server" 
              DataField="Parameter1" CommitChanges="True"/>
            <px:PXTextEdit  ID="edParameter2" runat="server" 
              DataField="Parameter2" CommitChanges="True" />
        </Template>
    </px:PXFormView>
    <px:PXPanel ID="PXPanel3" runat="server" SkinID="Buttons">
        <px:PXButton ID="cbOK" runat="server" Text="OK" 
          CommandSourceID="ds" DialogResult="OK" />
        <px:PXButton ID="cbCancel" runat="server" Text="Cancel" 
          DialogResult="Cancel" />
    </px:PXPanel>
</px:PXSmartPanel> In the button delegate, perform a call to an  AskExt <tt>AskExt</tt> method of the view           specified in the  Key  property of the  PXSmartPanel              container. public virtual IEnumerable OpenDialogBox(PXAdapter adapter)
{
    if (OpenDialogBoxView.AskExt() == WebDialogResult.OK &&
        string.IsNullOrEmpty(OpenDialogBoxView.Current.Parameter1) 
        == false)
    {
        ...
    }
    return adapter.Get();
} When             the user clicks the button on the webpage, the execution interrupts on the                AskExt  call and the dialog box is displayed. After the user clicks             a button in the dialog box, the  AskExt  method returns the dialog box             result. Rebuild the project. ]]></column>
		</row>
		<row PageID="64ebcd9f-54a8-4372-b4cf-62c39b824f8e" Language="en-US" PageRevisionID="1" Content="&#xA;In this chapter, you can find information about how to process operations whose execution takes long time. You execute these operations asynchronously in separate threads.&#xA;==In This Chapter==[anchor|#_ffc0e297-3efc-459a-aebf-2e404648eb0a]&#xA;*[HelpRoot_Dev_Platform\BL__con_Asynchronous_Execution|Asynchronous Execution]&#xA;*[HelpRoot_Dev_Platform\BL__how_Add_Button_to_Processing_Dialog_Box|To Add a Button to the Processing Dialog Box]&#xA;*[HelpRoot_Dev_Platform\BL__how_Disable_Processing_Dialog_Box|To Not Display the Processing Dialog Box]&#xA;" PlainText="Executing Code Asynchronously In this chapter, you can find information about how to process operations whose execution     takes long time. You execute these operations asynchronously in separate threads. In This Chapter Asynchronous ExecutionTo Add a Button to the Processing Dialog BoxTo Not Display the Processing Dialog Box" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="390f5b63-8e03-a656-dde7-398fa5179dd3" RecordSourceID="22377" />
		<row PageID="3e8c46fa-54a8-4f9c-9353-aa559c346215" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="0b65d616-0b6c-fc47-eb07-050f38e896a5" RecordSourceID="22377">
			<column name="Content"><![CDATA[
An instance of a graph is created on each round trip to process a request created by the user on the appropriate form. After the request is processed, the graph instance must be cleared from the memory of the Acumatica ERP server. If you implement code that might require a long time to execute an action or to process a document or data, you should execute this code asynchronously in a separate thread.{br}{TOC}
==Using the PXLongOperation Class==
To make the system invoke the method in a separate thread, you can use the <tt>PXLongOperation.StartOperation</tt> method. Within the method that you pass to <tt>StartOperation</tt>, you can, for example, create a new instance of a graph and invoke a processing method on that instance. The following code snippet demonstrates how you can execute code asynchronously as a long-running operation in a method of a graph.{{{{public class MyGraph : PXGraph
{
  ...
  public void MyMethod()
  {
    ...
    PXLongOperation.StartOperation(this, delegate()
    {
      // insert the delegate method code here
      ...
      GraphName graph = PXGraph.CreateInstance&lt;GraphName&gt;();
      foreach (... in ...)
      {
        ...
      }
      ...
    });
  ...
  }
  ...
}
}}}}{br}

If you need to start a long-running operation in a method of a graph extension, you have to use the <tt>Base</tt> property instead of the <tt>this</tt> keyword in the first parameter of the <tt>StartOperation</tt> method, as shown in the following code snippet.{{{{public class MyGraph_Extension : PXGraphExtension&lt;MyGraph&gt;
  ...
  public void MyMethod()
  {
    ...
    PXLongOperation.StartOperation(Base, delegate()
    {
      // insert the delegate method code here
      ...
    });
  ...
  }
  ...
}
}}}}
==Using the Custom Information Dictionary==
In the delegate method of a long-running operation, you can store a data object in the <tt>&#95;CustomInfo</tt> dictionary of the long-running operation and get the list of records processed by the method. You can add to the dictionary any data object needed for a long-running operation by using a <tt>SetCustomInfo</tt> method.{br}

The following diagram shows that each long-running operation includes the <tt>&#95;CustomInfo</tt> dictionary, which can contain multiple key-value pairs with custom data.[anchor|#_6646919c-d9a3-471f-88aa-65d831df0082][anchor|#_63005158-97b0-460c-901a-45e2648c3c77][image:StudioDeveloperGuide/Images/REF_PXLongOperation_CustomInfo.png|popup|Location of custom data in the memory of the Acumatica ERP server|450px]{br}

For a processing operation, the system stores the <tt>PXProcessingMessagesCollection&lt;TTable&gt;</tt> list of messages in the dictionary. Each message in the list is of the <tt>PXProcessingMessage</tt> type, which includes a string message and an error level that is of the <tt>PXErrorLevel</tt> type.{br}

See [http://asiablog.acumatica.com/2016/07/new-way-to-work-with-custominfo-of.html#more|New way to work with CustomInfo of PXLongOperation] at [http://asiablog.acumatica.com] for more information about the use of the dictionary.
==Executing a Processing Operation as a Long-Running Operation==
When a user clicks an action button on a form to start a processing operation, the data source control of the form generates a request to the Acumatica ERP server to execute the action delegate defined for the button. The server creates an instance of the graph, which provides the business logic for the form and invokes the action delegate method.{br}

Because a processing operation is a long-running operation, in the action delegate method, the data processing code must be included in the <tt>PXLongOperation.StartOperation</tt> method call as the definition of the long-running operation delegate. When the action delegate method is executed, the <tt>StartOperation</tt> method creates an instance of the <tt>PXAsyncResult</tt> class to hold the data and state of the long-running operation; the method also initiates the execution of the long-running operation delegate asynchronously in a separate thread.{br}

If the duration of the long-running operation is longer than five seconds, the server releases the graph instance. Then the form, which is still opened in the browser, generates requests to the server to get the results of the long-running operation every five seconds. For such a request, the server uses the ID of the long-running operatio to check the operation status. If the operation has completed, the server creates an instance of the graph and restores the graph state and the cache data to finish processing the action delegate and to return results to the form.{br}

The following diagram shows how the server executes an action asynchronously and how it returns the results of the action to the form.[anchor|#_6b32ed79-0f48-4ef0-a624-ab2f994050d5][anchor|#_7e2ff075-2b18-4ca5-950a-e18551ca6b92][image:StudioDeveloperGuide/Images/REF_PXLongOperation_Results.png|popup|Execution of an action that uses a long-running operation|450px][anchor|#_397e929e-f4b4-4441-9688-1e0a4ca7ab33]
==Processing a Report as a Long-Running Operation==
When the user launches a report, either from the report form or by clicking an action button on the maintenance or entry form, the system redirects the user to the report launcher form (<tt>ReportLauncher.aspx</tt>), which is designed to automatically run a report for the received parameters. The ASPX page for this form contains the <tt>PXReportViewer</tt> control, whose Java Scripts objects and functions are designed to get the report data and display the data on the form.{br}

To run the report, the report launcher creates a request to the <tt>PX.Web.UI.PXReportViewer</tt> control on the server. To process the request, the server instantiates the <tt>PX.Reports.Web.WebReport</tt> class and invokes its <tt>Render</tt> method, which launches the report generation as a long-running operation in a separate thread.{br}

The resulting report data is an object of the <tt>PX.Reports.Data.ReportNode</tt> type stored in the <tt>&#95;CustomInfo</tt> dictionary of the current long-running operation under the <tt>DEFAULT&#95;CUSTOM&#95;INFO&#95;KEY</tt> key. To provide quick access to the report data when the user views different pages of the report, the system saves the report data in the session as an object of the <tt>PX.Reports.Web.WebReport</tt> type.{br}

After the long-running operation has completed, the <tt>PXReportViewer</tt> control gets the report data from the dictionary and displays the report on the report launcher form. For details on how the report is displayed and how the report data is retrieved, see [HelpRoot_Dev_Platform\CC__con_Rendering_of_Reports|Display of Reports].{br}

The following diagram shows how the server generates a report asynchronously and how it returns the resulting report data to the report launcher form.[anchor|#_27127ed4-3313-4849-8806-c69600ec2263][anchor|#_8d521e0e-52bb-4bc6-b35b-e36cb0b66fbc][image:StudioDeveloperGuide/Images/REF_PXLongOperation_RunReport.png|popup|Execution of an action that launches the generation of a report |450px]
==Executing a Long-Running Operation in a Cluster==
If Acumatica ERP is configured to run in a cluster of application servers behind a load balancer, it is not possible to predict which application server will receive the next request from the client. In this model, session-specific data is serialized and stored in a high-performance remote server, such as Redis or MS SQL, to be shared between the application servers.{br}

When the user clicks an action button on a form to start a processing operation, the load balancer forwards the request to an Acumatica ERP server to execute the action delegate defined for the button. The server creates an instance of the graph, which provides the business logic for the form, and invokes the action delegate method.{br}

When the action delegate method is executed, the <tt>StartOperation</tt> method creates an instance of the <tt>PXAsyncResult</tt> class to hold the data and state of the long-running operation, initiates the execution of the long-running operation delegate asynchronously in a separate thread, and stores the serialized data of the operation in the remote storage.{br}

If the duration of the long-running operation is longer than five seconds, the server releases the graph instance, stores the serialized data of the graph in the remote storage, and continues processing the long-running operation in a separate thread. When the operation has completed, this server sets the operation status to {{PXLongRunStatus.Completed}} and updates the operation data in the remote session storage.{br}

Until the form that is still opened in the browsers obtains the request results, it generates requests to the site URL every five seconds to get these results. On every such request, the load balancer selects a server to be used to process the request and forwards the request to the server. The server uses the long-running operation ID, which is usually equal to the graph UID, to check the operation&rsquo;s status. If the operation is completed, the server creates an instance of the graph to finish processing the action delegate and to return results to the form.{br}

The following diagram shows how the data of a user session and of a long-running operation are stored in the remote session storage of a cluster.{br}

[anchor|#_e6f04f47-b8fe-47ce-913c-c62854638b4b][anchor|#_194f1e52-413b-428a-a858-d599ee16e33a][image:StudioDeveloperGuide/Images/REF_PXLongOperation_OnCluster.png|popup|Execution of an action that uses a long-running operation in a cluster|450px]]]></column>
			<column name="PlainText"><![CDATA[Asynchronous Execution An instance of a graph is created on each round trip to process a request created by the         user on the appropriate form. After the request is processed, the graph instance must be         cleared from the memory of the  Acumatica ERP server. If you implement code that might require a long time to execute an action or to         process a document or data, you should execute this code asynchronously in a separate         thread. Using the PXLongOperation Class To make the system invoke the method in a separate thread, you can use the       PXLongOperation.StartOperation  method. Within the method that you pass to       StartOperation , you can, for example, create a new instance of a graph and     invoke a processing method on that instance. The following code snippet demonstrates how you can     execute code asynchronously as a long-running operation in a method of a     graph. public class MyGraph : PXGraph
{
  ...
  public void MyMethod()
  {
    ...
    PXLongOperation.StartOperation(this, delegate()
    {
      // insert the delegate method code here
      ...
      GraphName graph = PXGraph.CreateInstance<GraphName>();
      foreach (... in ...)
      {
        ...
      }
      ...
    });
  ...
  }
  ...
} If you need to start a long-running operation in a method of a graph extension, you have to         use the  Base  property instead of the  this  keyword in         the first parameter of the  StartOperation  method, as shown in the         following code         snippet. public class MyGraph_Extension : PXGraphExtension<MyGraph>
  ...
  public void MyMethod()
  {
    ...
    PXLongOperation.StartOperation(Base, delegate()
    {
      // insert the delegate method code here
      ...
    });
  ...
  }
  ...
} Using the Custom Information Dictionary In the delegate method of a long-running operation, you can store a data object in the       _CustomInfo  dictionary of the long-running operation and get the list of     records processed by the method. You can add to the dictionary any data object needed for a     long-running operation by using a  SetCustomInfo  method. The following diagram shows that each long-running operation includes the       _CustomInfo  dictionary, which can contain multiple key-value pairs with     custom data. Location of custom data in the memory of the  Acumatica ERP       server For a processing operation, the system stores the            PXProcessingMessagesCollection<TTable>  list of messages in the         dictionary. Each message in the list is of the  PXProcessingMessage  type,         which includes a string message and an error level that is of the            PXErrorLevel  type. See  New way to work with CustomInfo of PXLongOperation New way to work with CustomInfo of PXLongOperation         at   for more         information about the use of the dictionary. Executing a Processing Operation as a Long-Running Operation When a user clicks an action button on a form to start a processing operation, the data source     control of the form generates a request to the  Acumatica ERP     server to execute the action delegate defined for the button. The server creates an instance of     the graph, which provides the business logic for the form and invokes the action delegate     method. Because a processing operation is a long-running operation, in the action delegate method, the         data processing code must be included in the            PXLongOperation.StartOperation  method call as the definition of the         long-running operation delegate. When the action delegate method is executed, the            StartOperation  method creates an instance of the            PXAsyncResult  class to hold the data and state of the long-running         operation; the method also initiates the execution of the long-running operation delegate         asynchronously in a separate thread. If the duration of the long-running operation is longer than five seconds, the server releases         the graph instance. Then the form, which is still opened in the browser, generates requests         to the server to get the results of the long-running operation every five seconds. For such         a request, the server uses the ID of the long-running operatio to check the operation         status. If the operation has completed, the server creates an instance of the graph and         restores the graph state and the cache data to finish processing the action delegate and to         return results to the form. The following diagram shows how the server executes an action asynchronously and how it         returns the results of the action to the form. Execution of an action that uses a long-running operation Processing a Report as a Long-Running Operation When the user launches a report, either from the report form or by clicking an action         button on the maintenance or entry form, the system redirects the user to the report         launcher form ( ReportLauncher.aspx ), which is designed to automatically         run a report for the received parameters. The ASPX page for this form contains the            PXReportViewer  control, whose Java Scripts objects and functions are         designed to get the report data and display the data on the form. To run the report, the report launcher creates a request to the            PX.Web.UI.PXReportViewer  control on the server. To process the request,         the server instantiates the  PX.Reports.Web.WebReport  class and invokes         its  Render  method, which launches the report generation as a long-running         operation in a separate thread. The resulting report data is an object of the  PX.Reports.Data.ReportNode          type stored in the  _CustomInfo  dictionary of the current long-running         operation under the  DEFAULT_CUSTOM_INFO_KEY  key. To provide quick access         to the report data when the user views different pages of the report, the system saves the         report data in the session as an object of the  PX.Reports.Web.WebReport          type. After the long-running operation has completed, the  PXReportViewer          control gets the report data from the dictionary and displays the report on the report         launcher form. For details on how the report is displayed and how the report data is         retrieved, see  Display of Reports. The following diagram shows how the server generates a report asynchronously and how it         returns the resulting report data to the report launcher form. Execution of an action that launches the generation of a report  Executing a Long-Running Operation in a Cluster If  Acumatica ERP     is configured to run in a cluster of application servers behind a load balancer, it is not     possible to predict which application server will receive the next request from the client. In     this model, session-specific data is serialized and stored in a high-performance remote server,     such as Redis or MS SQL, to be shared between the application servers. When the user clicks an action button on a form to start a processing operation, the load         balancer forwards the request to an  Acumatica ERP server to execute the action delegate defined for the button. The server creates an         instance of the graph, which provides the business logic for the form, and invokes the         action delegate method. When the action delegate method is executed, the  StartOperation  method         creates an instance of the  PXAsyncResult  class to hold the data and state         of the long-running operation, initiates the execution of the long-running operation         delegate asynchronously in a separate thread, and stores the serialized data of the         operation in the remote storage. If the duration of the long-running operation is longer than five seconds, the server releases         the graph instance, stores the serialized data of the graph in the remote storage, and         continues processing the long-running operation in a separate thread. When the operation has         completed, this server sets the operation status to            PXLongRunStatus.Completed  and updates the operation data in the remote         session storage. Until the form that is still opened in the browsers obtains the request results, it generates         requests to the site URL every five seconds to get these results. On every such request, the         load balancer selects a server to be used to process the request and forwards the request to         the server. The server uses the long-running operation ID, which is usually equal to the         graph UID, to check the operation's status. If the operation is completed, the server         creates an instance of the graph to finish processing the action delegate and to return         results to the form. The following diagram shows how the data of a user session and of a long-running operation are     stored in the remote session storage of a cluster. Execution of an action that uses a long-running operation in a cluster ]]></column>
		</row>
		<row PageID="5561c9af-8f01-43ef-a320-56226b17d9f1" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="1b623a5e-88f8-fb91-a873-d32ea8506e0a" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When a user starts a processing operation on a processing form, such as the [HelpRoot_FormReference\AR_50_10_00|Release AR Documents] ([~/?ScreenId=AR501000|AR501000]) form of Acumatica ERP, the '''Processing''' dialog box opens, which displays the status of the processing. When a processing operation is started, all elements of the processing form become unavailable. If you need to make a button from the processing form available during processing, you have to add this button to the processing dialog box, as described in this topic. 
==To Add a Button to the Processing Dialog Box==
To add a button to the processing dialog box, you can use one of the following approaches:[anchor|#_cd1c8262-e790-4132-a183-50626ddd46b2]
*For the action that corresponds to the button, in the graph, set the value of the <tt>VisibleOnProcessingResults</tt> property of <tt>PXButtonAttribute</tt> or its descendant to {{true}}, as shown in the following code example.<source lang="csharp">[PXUIField(DisplayName = Messages.ShowDocuments)]
[PXButton(VisibleOnProcessingResults = true)]
public virtual IEnumerable showDocuments(PXAdapter adapter)
{
    ShowOpenDocuments(SelectedItems);
    return adapter.Get();
}</source>
*In the ASPX file that corresponds to the form, set the value of the <tt>VisibleOnProcessingResults</tt> property of <tt>PXDSCallbackCommand</tt> to {{True}}, as shown in the following example.{{{{&lt;px:PXDataSource ID = "ds" Width="100%" 
    runat="server" Visible="True" PrimaryView="Filter" 
    TypeName="PX.Objects.FA.FAClosingProcess" &gt;
        &lt;CallbackCommands&gt;
            &lt;px:PXDSCallbackCommand Name = "showDocuments" 
                VisibleOnProcessingResults="True"/&gt;
        &lt;/CallbackCommands&gt; 
&lt;/px:PXDataSource&gt;
}}}}
]]></column>
			<column name="PlainText"><![CDATA[To Add a Button to the Processing Dialog Box When a user starts a processing operation on a processing form, such as the   ([~/?ScreenId=AR501000|AR501000]) Release AR Documents (AR501000) form of  Acumatica ERP, the  Processing  dialog box opens, which displays the status of the         processing. When a processing operation is started, all elements of the processing form         become unavailable. If you need to make a button from the processing form available during         processing, you have to add this button to the processing dialog box, as described in this         topic.  To Add a Button to the Processing Dialog Box To add a button to the processing dialog box, you can use one of the following approaches: For the action that corresponds to the button, in the graph, set the value of the         VisibleOnProcessingResults  property of         PXButtonAttribute  or its descendant to  true , as shown in       the following code       example. [PXUIField(DisplayName = Messages.ShowDocuments)]
[PXButton(VisibleOnProcessingResults = true)]
public virtual IEnumerable showDocuments(PXAdapter adapter)
{
    ShowOpenDocuments(SelectedItems);
    return adapter.Get();
} In the ASPX file that corresponds to the form, set the value of the                VisibleOnProcessingResults  property of                PXDSCallbackCommand  to  True , as shown in the             following             example. <px:PXDataSource ID = "ds" Width="100%" 
    runat="server" Visible="True" PrimaryView="Filter" 
    TypeName="PX.Objects.FA.FAClosingProcess" >
        <CallbackCommands>
            <px:PXDSCallbackCommand Name = "showDocuments" 
                VisibleOnProcessingResults="True"/>
        </CallbackCommands> 
</px:PXDataSource> ]]></column>
		</row>
		<row PageID="5cf3c709-9640-4637-8827-e49830c33960" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f0049deb-6f44-a68b-788b-3146b4b222f9" RecordSourceID="22377">
			<column name="Content"><![CDATA[When a user starts a processing operation on a processing form, such as the [HelpRoot_FormReference\AR_50_10_00|Release AR Documents] ([~/?ScreenId=AR501000|AR501000]) form of Acumatica ERP, the '''Processing''' dialog box opens, which displays the status of the processing. You can turn off the displaying of the processing dialog box and instead display the progress and the result of the processing on the form toolbar.
==To Turn Off the Displaying of the Processing Dialog Box==
To not display the processing dialog box on a processing form, you can do one of the following:[anchor|#_5c6b21de-ed7b-4bb5-8e1a-fe5a5370f71c]
*To not display the processing dialog box for a custom page, override the <tt>IsProcessing</tt> property of the graph that corresponds to the form, as shown in the following code.<source lang="csharp">public override bool IsProcessing
{
    get { return false; }
    set { }
}</source>
*To not display the processing dialog box for a customized Acumatica ERP form, configure the <tt>IsProcessing</tt> property of the graph that corresponds to the form in a graph extension as shown in the following code.<source lang="csharp">public class AllocationProcess_Extension : PXGraphExtension&lt;AllocationProcess&gt;  
{
    public override void Initialize()
    {
        Base.IsProcessing = false;
    }
}</source>
*To not display the processing dialog box for all processing forms, add the <tt>ProcessingProgressDialog</tt> key in the {{appSettings}} section of the <tt>web.config</tt> file of the application set to {{False}}, as shown in the following example.{{{{&lt;add key="ProcessingProgressDialog" value="false" /&gt;
}}}}
]]></column>
			<column name="PlainText"><![CDATA[To Not Display the Processing Dialog Box When a user starts a processing operation on a processing form, such as the   ([~/?ScreenId=AR501000|AR501000]) Release AR Documents (AR501000) form of  Acumatica ERP, the  Processing  dialog box opens, which displays the status of             the processing. You can turn off the displaying of the processing dialog box and instead             display the progress and the result of the processing on the form toolbar. To Turn Off the Displaying of the Processing Dialog Box To not display the processing dialog box on a processing form, you can do one of the                     following: To not display the processing dialog box for a custom page, override the                              IsProcessing  property of the graph that corresponds                         to the form, as shown in the following                         code. public override bool IsProcessing
{
    get { return false; }
    set { }
} To not display the processing dialog box for a customized  Acumatica ERP form, configure the  IsProcessing  property of the graph                         that corresponds to the form in a graph extension as shown in the following                         code. public class AllocationProcess_Extension : PXGraphExtension<AllocationProcess>  
{
    public override void Initialize()
    {
        Base.IsProcessing = false;
    }
} To not display the processing dialog box for all processing forms, add the                              ProcessingProgressDialog  key in the                              appSettings  section of the                              web.config  file of the application set to                              False , as shown in the following                         example. <add key="ProcessingProgressDialog" value="false" /> ]]></column>
		</row>
		<row PageID="06a993cf-56ad-4785-8dcd-b915ccf32354" Language="en-US" PageRevisionID="1" PlainText="Localizing Applications  Acumatica Framework provides built-in localization tools that you can use to translate the user interface and         application messages to different languages. This chapter provides guidelines on how to         prepare the  Acumatica Framework         application for localization efforts. To get the application ready for localization, you must prepare data access classes (DACs)         and the application code. In This Chapter LocalizationStrings That Can Be LocalizedTo Prepare DACs for LocalizationTo Localize Application MessagesTo Work with Multi-Language FieldsTo Optimize Memory Consumption of Localized Data ([~/?ScreenId=SM200540|SM200540]) " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="560a02bc-38b0-eadc-b21d-a429d92d6a28" RecordSourceID="22377">
			<column name="Content"><![CDATA[
 Acumatica Framework provides built-in localization tools that you can use to translate the user interface and application messages to different languages. This chapter provides guidelines on how to prepare the Acumatica Framework application for localization efforts.{br}

To get the application ready for localization, you must prepare data access classes (DACs) and the application code.
==In This Chapter==[anchor|#_18a2c5c8-aeae-493a-bc41-0c1e7d9e3667]
*[HelpRoot_Dev_Platform\BL__con_Localization|Localization]
*[HelpRoot_Dev_Platform\BL__con_Localizable_Strings|Strings That Can Be Localized]
*[HelpRoot_Dev_Platform\BL__how_Prepare_DAC_for_Localization|To Prepare DACs for Localization]
*[HelpRoot_Dev_Platform\BL__how_Prepare_Code_for_Localization|To Localize Application Messages]
*[HelpRoot_Dev_Platform\BL__how_Localize_Field_Values|To Work with Multi-Language Fields]
*[HelpRoot_Dev_Platform\BL__how_Optimize_Static_Cache|To Optimize Memory Consumption of Localized Data]

==Related Articles==
*[HelpRoot_FormReference\SM_20_05_40|Translation Dictionaries] ([~/?ScreenId=SM200540|SM200540])]]></column>
		</row>
		<row PageID="254a95ce-77fa-4399-9f56-14957aa49dd3" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="6314c598-d2ae-094b-22ce-ecd20fdae3c9" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Applications created with Acumatica Framework can be localized on the presentation, business logic, and database level owing to:[anchor|#_3768b503-aaba-4b27-915a-53d370631313]
*Standard Microsoft.NET localization mechanism is implemented for localizing the presentation layer.
*All messages returned from the business logic layer can be localized through the dictionary mechanism. For details about how to implement message localization in your code, see [HelpRoot_Dev_Platform\BL__how_Prepare_Code_for_Localization|To Localize Application Messages].
*The runtime environment of Acumatica Framework supports the Unicode standard to store and operate with data in a non-ANSI format.
*Information like addresses or product descriptions can be stored in special, language-specific, database fields and presented in the user selected language. For details on implementation of such fields, see [HelpRoot_Dev_Platform\BL__how_Localize_Field_Values|To Work with Multi-Language Fields].

 Acumatica Framework provides a built-in utility that enables localization of the product by the end user. Once localization is entered and applied, the application does not require any recompilation or re-installation. Also, localization can also be exported, imported, and merged. For more information about how to use the built-in localization mechanism, see [HelpRoot_Administration\SM__con_Translation_Process|Translation Process] in the System Administration Guide.
==Related Articles==
*[HelpRoot_Administration\SM__con_Translation_Process|Translation Process]
*[HelpRoot_Dev_Platform\BL__con_Localizable_Strings|Strings That Can Be Localized]]]></column>
			<column name="PlainText"><![CDATA[Localization Applications created with  Acumatica Framework can be    localized on the presentation, business logic, and database level owing to: Standard Microsoft.NET localization mechanism is implemented for localizing the presentation     layer. All messages returned from the business logic layer can be localized through the dictionary     mechanism. For details about how to implement message localization in your code, see  To Localize Application Messages. The runtime environment of  Acumatica Framework     supports the Unicode standard to store and operate with data in a non-ANSI format. Information like addresses or product descriptions can be stored in special,     language-specific, database fields and presented in the user selected language. For details on     implementation of such fields, see  To Work with Multi-Language Fields.  Acumatica Framework    provides a built-in utility that enables localization of the product by the end user. Once    localization is entered and applied, the application does not require any recompilation or    re-installation. Also, localization can also be exported, imported, and merged. For more    information about how to use the built-in localization mechanism, see  Translation Process in the System Administration Guide. ]]></column>
		</row>
		<row PageID="85f491d2-f604-45ab-bb1b-efa90392a9bf" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="68efa666-733d-fcb5-a1fa-f543629ad3d0" RecordSourceID="22377">
			<column name="Content"><![CDATA[
By using the [HelpRoot_FormReference\SM_20_05_40|Translation Dictionaries] ([~/?ScreenId=SM200540|SM200540]) form, you can add translations for the string constants that are collected from the code of the application, and save them to the database. When a user signs in with a specific language, the systems loads the translations and displays the translated strings to the user. For more information on localization, see [HelpRoot_Administration\SM__CON_Locales_and_Languages|Locales and Languages].{br}

The system collects for localization the string constants that are specified in the following items of the application:[anchor|#_7863972e-8da1-46e7-a2cd-370d26424f72]
*The <tt>DisplayName</tt> property of the <tt>PXUIField</tt> attribute of the fields of data access classes (DACs)
*The <tt>DisplayName</tt> property of the <tt>PXUIField</tt> attribute of fields and actions of a business logic controller (BLC) object, which override the attributes of the fields and actions of a DAC
*The <tt>AllowedLabels</tt> properte of the <tt>PXStringList</tt> and <tt>PXIntList</tt> attributes
*The <tt>Values</tt> property of the classes that implement the <tt>ILocalizableValues</tt> interface
*Captions of form, grid, and panel controls and labels of input controls, which are specified in ASPX
*Titles of all nodes in the site map
*Report elements (such as text box labels and diagram agendas)
*{{public const string}} fields of the classes marked with the <tt>PXLocalizable</tt> attribute
{br}

You can also translate user input to multiple languages and store translations in the database. For more information on the localization of user input, see [HelpRoot_Dev_Platform\BL__how_Localize_Field_Values|To Work with Multi-Language Fields].
==Related Articles==
*[HelpRoot_Administration\SM__CON_Locales_and_Languages|Locales and Languages]
*[HelpRoot_FormReference\SM_20_05_40|Translation Dictionaries] ([~/?ScreenId=SM200540|SM200540])]]></column>
			<column name="PlainText"><![CDATA[Strings That Can Be Localized By using the   ([~/?ScreenId=SM200540|SM200540]) Translation Dictionaries    (SM200540) form, you can add translations for the string constants that are collected from the    code of the application, and save them to the database. When a user signs in with a specific    language, the systems loads the translations and displays the translated strings to the user. For    more information on localization, see  Locales and Languages. The system collects for localization the string constants that are specified in the following    items of the application: The  DisplayName  property of the  PXUIField  attribute of           the fields of data access classes (DACs) The  DisplayName  property of the  PXUIField  attribute of           fields and actions of a business logic controller (BLC) object, which override the           attributes of the fields and actions of a DAC The  AllowedLabels  properte of the  PXStringList  and              PXIntList  attributes The  Values  property of the classes that implement the              ILocalizableValues  interface Captions of form, grid, and panel controls and labels of input controls, which are specified      in ASPX Titles of all nodes in the site map Report elements (such as text box labels and diagram agendas) public const string  fields of the classes marked with the        PXLocalizable  attribute You can also translate user input to multiple languages and store translations in the database.    For more information on the localization of user input, see  To Work with Multi-Language Fields.  ([~/?ScreenId=SM200540|SM200540]) ]]></column>
		</row>
		<row PageID="6aa5f890-e9fb-49fd-924c-9da852f741f8" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="72c6b443-b276-2640-4f67-231801d5891d" RecordSourceID="22377">
			<column name="Content"><![CDATA[
When the system localizes the fields of the data access classes (DACs) and DAC names, it collects the string constants that are specified in the following code elements:[anchor|#_42c66640-1cdc-48c2-acbb-ea7e1c58ab2b]
*The <tt>DisplayName</tt> property of the <tt>PXUIField</tt> attribute of the fields of DACs
*The <tt>AllowedLabels</tt> property of the <tt>PXStringList</tt> attribute or <tt>PXIntList</tt> attribute of the fields of DACs
{br}

To prepare each DAC for localization, you need to perform the steps that are described in this topic. 
==To Prepare Each DAC for Localization==[anchor|#_2bcc5b6a-870f-4252-bba0-2402e9b6896a]
#Make sure the <tt>DisplayName</tt> parameter of the <tt>PXUIField</tt> attribute is specified for each visible field in the DAC, as shown in the following example.
#:((({S:Hint}If you change the <tt>DisplayName</tt> value of the <tt>PXUIField</tt> attribute on the fly (by creating your own <tt>PXFieldState</tt>), you should localize the string independently.
)))<source lang="charp">public new abstract class docType : PX.Data.IBqlField{}
[PXDBString(3, IsKey = true, IsFixed = true)]
[PXDefault()]
[PXUIField(DisplayName = "Document Type")]
public override string DocType { get; set; }</source>
#Specify the values that should be displayed in drop-down lists by using the <tt>PXStringList</tt> attribute, as shown in the following example.<source lang="csharp">public abstract class lineSource : PX.Data.IBqlField{}
[PXString(1, IsFixed = true)]        
[PXStringList(
    new string[] { "D", "R" },
    new string[] { "Draft", "Request" })]
[PXUIField(DisplayName = "Line Source")]
public virtual string LineSource { get; set; }</source>
]]></column>
			<column name="PlainText"><![CDATA[To Prepare DACs for Localization When the system localizes the fields of the data access classes (DACs) and DAC names,                 it collects the string constants that are specified in the following code                     elements: The  DisplayName  property of the                              PXUIField  attribute of the fields of DACs The  AllowedLabels  property of the                              PXStringList  attribute or                              PXIntList  attribute of the fields of DACs To prepare each DAC for localization, you need to perform the steps that are                 described in this topic.  To Prepare Each DAC for Localization Make sure the  DisplayName  parameter of the                          PXUIField  attribute is specified for each visible field                     in the DAC, as shown in the following example. If you change the                              DisplayName  value of the  PXUIField                          attribute on the fly (by creating your own  PXFieldState ),                         you should localize the string                     independently. public new abstract class docType : PX.Data.IBqlField{}
[PXDBString(3, IsKey = true, IsFixed = true)]
[PXDefault()]
[PXUIField(DisplayName = "Document Type")]
public override string DocType { get; set; } Specify the values that should be displayed in drop-down lists by using the                          PXStringList  attribute, as shown in the following                     example. public abstract class lineSource : PX.Data.IBqlField{}
[PXString(1, IsFixed = true)]        
[PXStringList(
    new string[] { "D", "R" },
    new string[] { "Draft", "Request" })]
[PXUIField(DisplayName = "Line Source")]
public virtual string LineSource { get; set; } ]]></column>
		</row>
		<row PageID="49d467e5-7717-4393-a5c6-398d4bcf818c" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="8b81b7a7-f461-3201-f2ab-a48a60cfc69c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
For localization of the messages in the source code, the system collects the strings from the classes that are marked with the <tt>PXLocalizable</tt> attribute. {br}

To make your application display localized messages, you need to perform the steps, which are described in this topic. 
==To Display Localized Messages in Your Application==[anchor|#_9cf1fbc9-2ba1-4db1-b338-8772290ff372]
#Move all strings that should be translated to the public static {{Messages}} class and specify the <tt>PXLocalizable</tt> attribute for this class, as shown in the following code.
#:((({S:Hint}The exceptions to this requirement are field descriptions and list attributes in the data access classes, which are handled separately. For details on how to make field descriptions and list attributes localizable, see [HelpRoot_Dev_Platform\BL__how_Prepare_DAC_for_Localization|To Prepare DACs for Localization].
)))<source lang="csharp">using System;
using PX.Data;

[PXLocalizable()]
public static class Messages
{
   public const string FieldNotFound = "The field is not found.";
   public const string InvalidAddress = "The address is not valid.";
   public const string AdditionalData = "Author's title: {0}; author's name: {1}."
}</source>
#:((({S:Hint}No hyphenation is provided by the system. During the acquisition process of localizable data, all the new-line symbols (''\n\r'') are to be removed. You can use the reserved symbol (''~'') to cause the insertion of a new line.
)))
#If the message from the {{Messages}} class is used in an error or warning message, which is displayed when an exception of the <tt>PXException</tt> type or of a type derived from <tt>PXException</tt> is thrown, provide a non-localized message, as shown in the following example. The system displays the localized message automatically if there is a translation for this message in the database.<source lang="csharp">if (field == null)
{
        throw new PXException(Messages.FieldNotFound);
}</source>
#If you need to receive the translation of a message from the {{Messages}} class within the application code (for example, if the message is displayed in the confirmation dialog box, which is displayed if you use the <tt>Ask()</tt> method of a data view in the code), use one of the following methods:
#*<tt>PXMessages.Localize()</tt>: The method searches for the translation of the provided string in the database and returns the first translation found.<source lang="csharp">string msg = PXMessages.Localize(Messages.FieldNotFound);</source>
#*<tt>PXMessages.LocalizeFormat()</tt>: The method searches for the translation of the provided string, which includes placeholders (such as ''&#0123;0&#0125;'' or ''&#0123;1&#0125;''), in the database and returns the first translation found. 
#*<tt>PXLocalizer.Localize()</tt>: The method returns the translation with the given key, which you specify in the second parameter. A string may have multiple translations; one translation for each occurrence of the string in the application. For each of the occurrences, a key value is created. For example, if the string is declared in a class marked with the <tt>PXLocalizable</tt> attribute, the full qualified name of the class is the key, as the following code shows.{{{{string localizedMsg = PXLocalizer.Localize(
    ActionsMessages.ChangesWillBeSaved,
    typeof(ActionsMessages).ToString());
}}}}
]]></column>
			<column name="PlainText"><![CDATA[To Localize Application Messages For localization of the messages in the source code, the system collects the strings                 from the classes that are marked with the  PXLocalizable                  attribute.  To make your application display localized messages, you need to perform the steps,                 which are described in this topic.  To Display Localized Messages in Your Application Move all strings that should be translated to the public static                          Messages  class and specify the                          PXLocalizable  attribute for this class, as shown in the                     following code. The exceptions to this requirement are field descriptions                         and list attributes in the data access classes, which are handled                         separately. For details on how to make field descriptions and list                         attributes localizable, see  To Prepare DACs for Localization. using System;
using PX.Data;

[PXLocalizable()]
public static class Messages
{
   public const string FieldNotFound = "The field is not found.";
   public const string InvalidAddress = "The address is not valid.";
   public const string AdditionalData = "Author's title: {0}; author's name: {1}."
} No                         hyphenation is provided by the system. During the acquisition process of                         localizable data, all the new-line symbols ( \n\r ) are to be removed.                         You can use the reserved symbol ( ~ ) to cause the insertion of a new                         line. If the message from the  Messages  class is used in an error or                     warning message, which is displayed when an exception of the                          PXException  type or of a type derived from                          PXException  is thrown, provide a non-localized message,                     as shown in the following example. The system displays the localized message                     automatically if there is a translation for this message in the                     database. if (field == null)
{
        throw new PXException(Messages.FieldNotFound);
} If you need to receive the translation of a message from the                          Messages  class within the application code (for example, if                     the message is displayed in the confirmation dialog box, which is displayed if                     you use the  Ask()  method of a data view in the code), use one                     of the following methods: PXMessages.Localize() : The method searches for the                             translation of the provided string in the database and returns the first                             translation                             found. string msg = PXMessages.Localize(Messages.FieldNotFound); PXMessages.LocalizeFormat() : The method searches for                             the translation of the provided string, which  includes placeholders                             (such as  {0}  or  {1} ), in the database and returns the                             first translation found.  PXLocalizer.Localize() : The method returns the                             translation with the given key, which you specify in the second                             parameter. A string may have multiple translations; one translation for                             each occurrence of the string in the application. For each of the                             occurrences, a key value is created. For example, if the string is                             declared in a class marked with the  PXLocalizable                              attribute, the full qualified name of the class is the key, as the                             following code                             shows. string localizedMsg = PXLocalizer.Localize(
    ActionsMessages.ChangesWillBeSaved,
    typeof(ActionsMessages).ToString()); ]]></column>
		</row>
		<row PageID="a1de7d38-cd06-4497-a5b7-61b1a01b7d16" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="e44ad1aa-0e92-0806-b4cf-9b907c7fdf7c" RecordSourceID="22377">
			<column name="Content"><![CDATA[
With Acumatica Framework, you can create fields into which a user can type values in multiple languages if multiple locales are configured in the applicable Acumatica Framework application. For example, in Acumatica ERP, if an instance works with English and French locales, you can specify the value of the '''Description''' box on the [HelpRoot_FormReference\IN_20_25_00|Stock Items] ([~/?ScreenId=IN202500|IN202500]) form in English and French. For details on multi-language fields on Acumatica ERP forms, see [HelpRoot_Administration\SM__mng_Locales|Managing Locales and Languages].{br}{TOC}
==To Configure a Field to Have Values in Multiple Languages==
[anchor|#_86a5b9f6-593a-474a-8629-e8d5b0474f54]
#In the data access class (DAC) that you want to contain a multi-language field, define the <tt>NoteID</tt> field with the <tt>PXNote</tt> attribute, as follows.{{{{public abstract class noteID : IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; }
}}}}
#If you want to configure a field to have values in multiple languages, annotate this field with the <tt>PXDBLocalizableString</tt> attribute. The following code shows an example of the use of the <tt>PXDBLocalizableString</tt> attribute. {{{{[PXDBLocalizableString(60, IsUnicode = true)]
}}}}
#:The <tt>PXDBLocalizableString</tt> attribute works similarly to the <tt>PXDBString</tt> attribute, but unlike the <tt>PXDBString</tt> attribute, the <tt>PXDBLocalizableString</tt> attribute can be used instead of the <tt>PXDBText</tt> and <tt>PXString</tt> attributes.
#If you need to give values in multiple languages to a field with the <tt>PXDBText</tt> attribute, replace this attribute with the <tt>PXDBLocalizableString</tt> attribute and do not specify the length parameter, as shown in the following example. {{{{[PXDBLocalizableString(IsUnicode = true)]
}}}}
#If you need to configure a field that has the <tt>PXString</tt> attribute, which is used in conjunction with the <tt>PXDBCalced</tt> attribute, replace the <tt>PXString</tt> attribute with the <tt>PXDBLocalizableString</tt> attribute and set the value of the <tt>NonDB</tt> parameter to {{true}}, as shown in the following example.{{{{[PXDBLocalizableString(255, IsUnicode = true, NonDB = true, 
   BqlField = typeof(PaymentMethod.descr))] 
[PXDBCalced(typeof(Switch&lt;Case&lt;Where&lt;PaymentMethod.descr, IsNotNull&gt;, 
   PaymentMethod.descr&gt;, CustomerPaymentMethod.descr&gt;), typeof(string))]
}}}}

==To Configure the Default Value of a Multi-Language Field==
If you want a multi-language field to have a default value in a specific language, use the <tt>PXLocalizableDefault</tt> attribute instead of the <tt>PXDefault</tt> attribute and specify in its second parameter either a BQL field or a BQL select that provides language selection. {br}

For example, in Acumatica ERP, the {{SOLine}} line description defaulted to the appropriate {{InventoryItem}} description based on the language that is set for a customer. The {{TransactionDesr}} field of the {{SOLine}} DAC has the <tt>PXLocalizableDefault</tt> attribute with a second parameter that specifies the language as follows: {{typeof(Customer.languageName)}}. See the following example of the use of the <tt>PXLocalizableDefault</tt> attribute.{{{{[PXLocalizableDefault(typeof(Search&lt;InventoryItem.descr,
   Where&lt;InventoryItem.inventoryID, 
   Equal&lt;Current&lt;SOLine.inventoryID&gt;&gt;&gt;&gt;),
   typeof(Customer.languageName), 
   PersistingCheck = PXPersistingCheck.Nothing)]                                      
}}}}
==To Obtain the Value of a Multi-Language Field in the Current Locale==
If you want to obtain the value of a multi-language field in the current locale, use the <tt>PXDatabase.SelectSingle()</tt> or <tt>PXDatabase.SelectMulti()</tt> method, and pass to it the return value of the <tt>PXDBLocalizableStringAttribute.GetValueSelect()</tt> static method instead of passing a new <tt>PXDataField</tt> object to it. (The <tt>PXDBLocalizableStringAttribute.GetValueSelect()</tt> method takes three input parameters: the table name, the field name, and a Boolean flag that indicates whether strings should be returned as text with unlimited length.) {br}

The following code shows an example of the use of the <tt>PXDBLocalizableStringAttribute.GetValueSelect()</tt> method.{{{{foreach (PXDataRecord record in PXDatabase.SelectMulti&lt;Numbering&gt;(
   newPXDataField&lt;Numbering.numberingID&gt;(), 
   PXDBLocalizableStringAttribute.GetValueSelect("Numbering", 
      "NewSymbol", false),
   newPXDataField&lt;Numbering.userNumbering&gt;()))     
{
   ...
}                                             
}}}}((({S:Hint}Generally, you use the <tt>PXDatabase.SelectSingle()</tt> and <tt>PXDatabase.SelectMulti()</tt> methods for retrieving data within the <tt>Prefetch()</tt> method of a database slot. Don&rsquo;t forget to add language code to the slot key when you obtain a slot, as shown in the following example, because with the use of <tt>PXDBLocalizableStringAttribute</tt>, the data becomes language-specific. Therefore, you need different slot instances for different languages.{{{{Numberings items = PXDatabase.GetSlot&lt;Numberings&gt;(
   typeof(Numberings).Name + currentLanguage, typeof(Numbering));
}}}}
)))
==To Obtain the Value of a Multi-Language Field in a Specific Language==
If you want to obtain the value of a multi-language field in a specific language, use the <tt>PXDBLocalizableStringAttribute.GetTranslation()</tt> method. Pass to the method as input parameters a DAC cache, a DAC instance, a field name, and the ISO code of the language. {br}

The following code shows an example of use of the <tt>PXDBLocalizableStringAttribute.GetTranslation()</tt> method.{{{{tran.TranDesc =
   PXDBLocalizableStringAttribute.GetTranslation(
      Caches[typeof(InventoryItem)], item, typeof(InventoryItem.descr).Name,
      customer.Current?.LanguageName);
}}}}]]></column>
			<column name="PlainText"><![CDATA[To Work with Multi-Language Fields With  Acumatica Framework, you     can create fields into which a user can type values in multiple languages if multiple locales     are configured in the applicable  Acumatica Framework     application. For example, in  Acumatica ERP,     if an instance works with English and French locales, you can specify the value of the       Description  box on the   ([~/?ScreenId=IN202500|IN202500]) Stock Items (IN202500) form     in English and French. For details on multi-language fields on  Acumatica ERP     forms, see  Managing Locales and Languages. To Configure a Field to Have Values in Multiple Languages In the data access class (DAC) that you want to contain a multi-language field, define the         NoteID  field with the  PXNote  attribute, as       follows. public abstract class noteID : IBqlField { }

[PXNote]
public virtual Guid? NoteID { get; set; } If you want to configure a field to have values in multiple languages, annotate this field       with the  PXDBLocalizableString  attribute. The following code shows an       example of the use of the  PXDBLocalizableString  attribute.         [PXDBLocalizableString(60, IsUnicode = true)] The          PXDBLocalizableString  attribute works similarly to the          PXDBString  attribute, but unlike the  PXDBString         attribute, the  PXDBLocalizableString  attribute can be used instead of the          PXDBText  and  PXString  attributes. If you need to give values in multiple languages to a field with the         PXDBText  attribute, replace this attribute with the         PXDBLocalizableString  attribute and do not specify the length parameter,       as shown in the following example.        [PXDBLocalizableString(IsUnicode = true)] If you need to configure a field that has the  PXString  attribute, which       is used in conjunction with the  PXDBCalced  attribute, replace the         PXString  attribute with the  PXDBLocalizableString        attribute and set the value of the  NonDB  parameter to        true , as shown in the following       example. [PXDBLocalizableString(255, IsUnicode = true, NonDB = true, 
   BqlField = typeof(PaymentMethod.descr))] 
[PXDBCalced(typeof(Switch<Case<Where<PaymentMethod.descr, IsNotNull>, 
   PaymentMethod.descr>, CustomerPaymentMethod.descr>), typeof(string))] To Configure the Default Value of a Multi-Language Field If you want a multi-language field to have a default value in a specific language, use the       PXLocalizableDefault  attribute instead of the  PXDefault      attribute and specify in its second parameter either a BQL field or a BQL select that provides     language selection.  For example, in  Acumatica ERP,     the  SOLine  line description defaulted to the appropriate       InventoryItem  description based on the language that is set for a customer.     The  TransactionDesr  field of the  SOLine  DAC has the       PXLocalizableDefault  attribute with a second parameter that specifies the     language as follows:  typeof(Customer.languageName) . See the following example     of the use of the  PXLocalizableDefault      attribute. [PXLocalizableDefault(typeof(Search<InventoryItem.descr,
   Where<InventoryItem.inventoryID, 
   Equal<Current<SOLine.inventoryID>>>>),
   typeof(Customer.languageName), 
   PersistingCheck = PXPersistingCheck.Nothing)]                                       To Obtain the Value of a Multi-Language Field in the Current Locale If you want to obtain the value of a multi-language field in the current locale, use the       PXDatabase.SelectSingle()  or  PXDatabase.SelectMulti()      method, and pass to it the return value of the       PXDBLocalizableStringAttribute.GetValueSelect()  static method instead of     passing a new  PXDataField  object to it. (The       PXDBLocalizableStringAttribute.GetValueSelect()  method takes three input     parameters: the table name, the field name, and a Boolean flag that indicates whether strings     should be returned as text with unlimited length.)  The following code shows an example of the use of the       PXDBLocalizableStringAttribute.GetValueSelect()       method. foreach (PXDataRecord record in PXDatabase.SelectMulti<Numbering>(
   newPXDataField<Numbering.numberingID>(), 
   PXDBLocalizableStringAttribute.GetValueSelect("Numbering", 
      "NewSymbol", false),
   newPXDataField<Numbering.userNumbering>()))     
{
   ...
}                                              Generally,      you use the  PXDatabase.SelectSingle()  and        PXDatabase.SelectMulti()  methods for retrieving data within the        Prefetch()  method of a database slot. Don't forget to add language code to      the slot key when you obtain a slot, as shown in the following example, because with the use of        PXDBLocalizableStringAttribute , the data becomes language-specific.      Therefore, you need different slot instances for different      languages. Numberings items = PXDatabase.GetSlot<Numberings>(
   typeof(Numberings).Name + currentLanguage, typeof(Numbering)); To Obtain the Value of a Multi-Language Field in a Specific Language If you want to obtain the value of a multi-language field in a specific language, use the       PXDBLocalizableStringAttribute.GetTranslation()  method. Pass to the method     as input parameters a DAC cache, a DAC instance, a field name, and the ISO code of the language.  The following code shows an example of use of the       PXDBLocalizableStringAttribute.GetTranslation()      method. tran.TranDesc =
   PXDBLocalizableStringAttribute.GetTranslation(
      Caches[typeof(InventoryItem)], item, typeof(InventoryItem.descr).Name,
      customer.Current?.LanguageName); ]]></column>
		</row>
		<row PageID="ac6b5781-1d62-4dab-b153-63b29d138732" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="c83ad543-555d-6746-177a-e303c4e2d9dc" RecordSourceID="22377">
			<column name="Content"><![CDATA[
To optimize the memory consumption of static data, you can move the localization data from all customer application instances to centralized storage. By default, the localization data is kept in the database of every Acumatica ERP instance, and the total size of this data therefore equals the number of instances times the size of the data. If you move the localization data to centralized storage, there is only one copy of this data.{br}

Alternatively, you can optimize the consumption of memory by disabling localization.{br}

Whether you set up centralized storage of localization data or disable localization, you should perform the following steps:[anchor|#ul_yrp_tcp_jl]
#Implement a custom translation provider. Follow the instruction in [[#_9fb6a0e2-4efe-4bc7-9fb6-977cdbbf5e62|To Implement a Custom Translation Provider] or [[#_2c321ca4-d3b0-4643-a139-c40480fd3126|To Disable Localization] in this topic depending on which way of optimization of memory consumption you select.
#Place the assembly file with the new provider in the <tt>Bin</tt> directory of the Acumatica ERP instance, and add the assembly to the customization project as a ''File'' element. 
#Register the new provider in the <tt>pxtranslate</tt> element of the <tt>web.config</tt> file, as described in [[#_73ca3eeb-cea0-46ea-b496-0278113298d1|To Register the New Provider in Web.config] in this topic.
{br}{TOC}[anchor|#_9fb6a0e2-4efe-4bc7-9fb6-977cdbbf5e62]
==To Implement a Custom Translation Provider==
To implement a custom translation provider, derive a class from the <tt>PXTranslationProvider</tt> class and override the <tt>LoadCultureDictionary()</tt> method, as the following example shows.<source lang="csharp">public class DemoTranslationProvider : PXTranslationProvider
{
    public override PXCultureDictionary LoadCultureDictionary(
        string locale, bool includeObsolete, bool escapeStrings)
    {
        PXCultureDictionary dictionary = new PXCultureDictionary();
        ...
        // Adding a general translation for some string
        dictionary.Append(
            valueToTranslate,
            new PXCultureValue(locale, translation));
        // Adding a special translation for some string
        dictionary.AppendException(
            valueToTranslate,
            new PXCultureEx(resourceID, locale, translation));
        ...
        return dictionary;
    }
}</source>
The <tt>LoadCultureDictionary()</tt> method returns an instance of the <tt>PXCultureDictionary</tt> type. Values are added to objects of this type through the <tt>Append()</tt> and <tt>AppendException()</tt> methods. <tt>Append()</tt> adds a general translation for a string. <tt>AppendException()</tt> adds a translation for a special case (exception) identified by the resource key.{br}

The code below defines a custom translation provider that loads the localization data from an external Acumatica ERP database by using ADO.NET tools.<source lang="csharp">using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Linq;
using System.Text;
using PX.Data;
using PX.Translation;

namespace Demo.Translation
{
    public class DemoTranslationProvider : PXTranslationProvider
    {
        private struct TranslationKey
        {
            public Guid id;
            public string resKey;
            public string locale;
        }

        // The connection string for the database that stores localization
        // data
        // Specify a specific value of the connection string
        private const string connectionString = "";

        // Overriding the method that returns the dictionary of
        // localization data
        public override PXCultureDictionary LoadCultureDictionary(
            string locale, bool includeObsolete, bool escapeStrings)
        {
            string localizationValueSelect;
            string localizationTranslationSelect;
            InitializeSelectCommand(locale, includeObsolete,
                                    out localizationValueSelect,
                                    out localizationTranslationSelect);

            Dictionary&lt;Guid, string&gt; localizationValue;
            Dictionary&lt;TranslationKey, string&gt; localizationTranslation;
            SelectLocalizationValues(localizationValueSelect,
                                     localizationTranslationSelect,
                                     out localizationValue,
                                     out localizationTranslation);

            return CreateCultureDictionary(escapeStrings, localizationValue,
                                           localizationTranslation);
        }

        // Builds the SQL statement for selecting localization data
        private void InitializeSelectCommand(
            string locale, bool includeObsolete,
            out string localizationValueSelect,
            out string localizationTranslationSelect)
        {
            StringBuilder localizationValueSelectBld = 
                new StringBuilder("Select IDlv, NeutralValue" + 
                                  "From LocalizationValue");
            if (!includeObsolete)
            {
                localizationValueSelectBld.Append(" Where IsObsolete = 0");
            }
            localizationValueSelect = localizationValueSelectBld.ToString();

            StringBuilder localizationTranslationSelectBld =
                new StringBuilder("Select IDlt, ResKey, Value, Locale" + 
                                  "From LocalizationTranslation");
            if (!string.IsNullOrEmpty(locale))
            {
                localizationTranslationSelectBld.AppendFormat(
                    " Where Locale = '{0}'", locale);
            }
            localizationTranslationSelect = 
                localizationTranslationSelectBld.ToString();
        }

        // Retrieves localization data from the database by using the provided
        // SQL statement
        private void SelectLocalizationValues(
            string localizationValueSelect,
            string localizationTranslationSelect,
            out Dictionary&lt;Guid, string&gt; localizationValue,
            out Dictionary&lt;TranslationKey, string&gt; localizationTranslation)
        {
            localizationValue = new Dictionary&lt;Guid, string&gt;();
            localizationTranslation = 
                new Dictionary&lt;TranslationKey, string&gt;();

            using (SqlConnection connection = 
                   new SqlConnection(connectionString))
            {
                connection.Open();

                SqlCommand command = new SqlCommand(localizationValueSelect,
                                                    connection);
                using (SqlDataReader reader = command.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        localizationValue.Add(reader.GetGuid(0),
                                              reader.GetString(1));
                    }
                }

                command.CommandText = localizationTranslationSelect;
                using (SqlDataReader reader = command.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        TranslationKey newTranslationKey = new TranslationKey()
                        {
                            id = reader.GetGuid(0),
                            resKey = reader.GetString(1),
                            locale = reader.GetString(3)
                        };
                        localizationTranslation.Add(newTranslationKey,
                                                    reader.GetString(2));
                    }
                }
            }
        }

        // Fills the PXCultureDictionary object with localization data by using
        // the provided dictionaries of values to translate and the
        // corresponding translations
        private PXCultureDictionary CreateCultureDictionary(
            bool escapeStrings,
            Dictionary&lt;Guid, string&gt; localizationValue,
            Dictionary&lt;TranslationKey, string&gt; localizationTranslation)
        {
            PXCultureDictionary dictionary = new PXCultureDictionary();

            if (localizationTranslation.Count != 0)
            {
                foreach (Guid id in localizationValue.Keys)
                {
                    IEnumerable&lt;TranslationKey&gt; localizationTranslationKeys = 
                        from translationRowKey in localizationTranslation.Keys
                        where translationRowKey.id == id
                        select translationRowKey;
                    foreach (TranslationKey key in localizationTranslationKeys)
                    {
                        string translationResKey = key.resKey;
                        string translationLocale = key.locale;
                        string translationValue = localizationTranslation[key];
                        string value = escapeStrings ?
                            PXLocalizer.EscapeString(translationValue) :
                            translationValue;

                        if (string.IsNullOrEmpty(translationResKey))
                        {
                            dictionary.Append(
                                localizationValue[id],
                                new PXCultureValue(translationLocale, value));
                        }
                        else
                        {
                            dictionary.AppendException(
                                localizationValue[id],
                                new PXCultureEx(translationResKey,
                                                translationLocale, value));
                        }
                    }
                }
            }
            return dictionary;
        }
    }
}</source>[anchor|#_2c321ca4-d3b0-4643-a139-c40480fd3126]
==To Disable Localization==
To disable localization, implement a custom translation provider with the <tt>LoadCultureDictionary()</tt> method that returns <tt>null</tt>, as the following code shows.<source lang="csharp">public class DemoTranslationProvider : PXTranslationProvider
{
    public override PXCultureDictionary LoadCultureDictionary(
        string locale, bool includeObsolete, bool escapeStrings)
    {
        return null;
    }
}</source>[anchor|#_73ca3eeb-cea0-46ea-b496-0278113298d1]
==To Register the New Provider in Web.config==
Once the provider class is defined, register it in the <tt>web.config</tt> file by adding a new key to the <tt>providers</tt> collection of the <tt>pxtranslate</tt> element and specifying the new key in the <tt>defaultProvider</tt> property of <tt>pxtranslate</tt>. Use the <tt>add</tt> element to register the provider. Set the <tt>name</tt> attribute to the key, which can be any unique value, and specify the type of the custom provider in the <tt>type</tt> attribute.{br}

The following code shows the configuration of <tt>DemoTranslationProvider</tt>, introduced in the example above, in the <tt>pxtranslate</tt> element of the <tt>web.config</tt> file.<source lang="csharp">&lt;pxtranslate defaultProvider="DemoTranslationProvider"&gt;
  &lt;providers&gt;
    &lt;!--The default translation provider--&gt;
    &lt;remove name="PXDBTranslatonProvider" /&gt;
    &lt;add name="PXDBTranslatonProvider"
         type="PX.Data.PXDBTranslatonProvider, PX.Data" /&gt;

    &lt;!--The custom translation provider--&gt;
    &lt;remove name="DemoTranslationProvider" /&gt;
    &lt;add name="DemoTranslationProvider"
         type="Demo.Translation.DemoTranslationProvider, TranslationProvider"
         applicationName="/"/&gt;
  &lt;/providers&gt;
&lt;/pxtranslate&gt;</source>]]></column>
			<column name="PlainText"><![CDATA[To Optimize Memory Consumption of Localized Data To optimize the memory consumption of static data, you can move the localization data                 from all customer application instances to centralized storage. By default, the                 localization data is kept in the database of every  Acumatica ERP instance, and the total size of this data therefore equals the number of                 instances times the size of the data. If you move the localization data to                 centralized storage, there is only one copy of this data. Alternatively, you can optimize the consumption of memory by disabling                 localization. Whether you set up centralized storage of localization data or disable localization,                 you should perform the following steps: Implement a custom translation provider. Follow the instruction in  To Implement a Custom Translation Provider To Implement a Custom Translation Provider or  To Disable Localization To Disable Localization in this topic depending on which way of optimization of                     memory consumption you select. Place the assembly file with the new provider in the  Bin                      directory of the  Acumatica ERP instance, and add the assembly to the customization project as a  File                      element.  Register the new provider in the  pxtranslate  element of the                          web.config  file, as described in  To Register the New Provider in Web.config To Register the New Provider in Web.config in this topic. To Implement a Custom Translation Provider To implement a custom translation provider, derive a class from the                      PXTranslationProvider  class and override the                      LoadCultureDictionary()  method, as the following example                 shows. public class DemoTranslationProvider : PXTranslationProvider
{
    public override PXCultureDictionary LoadCultureDictionary(
        string locale, bool includeObsolete, bool escapeStrings)
    {
        PXCultureDictionary dictionary = new PXCultureDictionary();
        ...
        // Adding a general translation for some string
        dictionary.Append(
            valueToTranslate,
            new PXCultureValue(locale, translation));
        // Adding a special translation for some string
        dictionary.AppendException(
            valueToTranslate,
            new PXCultureEx(resourceID, locale, translation));
        ...
        return dictionary;
    }
} The  LoadCultureDictionary()  method returns an instance of the                      PXCultureDictionary  type. Values are added to objects of this                 type through the  Append()  and                      AppendException()  methods.  Append()  adds a                 general translation for a string.  AppendException()  adds a                 translation for a special case (exception) identified by the resource key. The code below defines a custom translation provider that loads the localization data                 from an external  Acumatica ERP database by using ADO.NET tools. using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Linq;
using System.Text;
using PX.Data;
using PX.Translation;

namespace Demo.Translation
{
    public class DemoTranslationProvider : PXTranslationProvider
    {
        private struct TranslationKey
        {
            public Guid id;
            public string resKey;
            public string locale;
        }

        // The connection string for the database that stores localization
        // data
        // Specify a specific value of the connection string
        private const string connectionString = "";

        // Overriding the method that returns the dictionary of
        // localization data
        public override PXCultureDictionary LoadCultureDictionary(
            string locale, bool includeObsolete, bool escapeStrings)
        {
            string localizationValueSelect;
            string localizationTranslationSelect;
            InitializeSelectCommand(locale, includeObsolete,
                                    out localizationValueSelect,
                                    out localizationTranslationSelect);

            Dictionary<Guid, string> localizationValue;
            Dictionary<TranslationKey, string> localizationTranslation;
            SelectLocalizationValues(localizationValueSelect,
                                     localizationTranslationSelect,
                                     out localizationValue,
                                     out localizationTranslation);

            return CreateCultureDictionary(escapeStrings, localizationValue,
                                           localizationTranslation);
        }

        // Builds the SQL statement for selecting localization data
        private void InitializeSelectCommand(
            string locale, bool includeObsolete,
            out string localizationValueSelect,
            out string localizationTranslationSelect)
        {
            StringBuilder localizationValueSelectBld = 
                new StringBuilder("Select IDlv, NeutralValue" + 
                                  "From LocalizationValue");
            if (!includeObsolete)
            {
                localizationValueSelectBld.Append(" Where IsObsolete = 0");
            }
            localizationValueSelect = localizationValueSelectBld.ToString();

            StringBuilder localizationTranslationSelectBld =
                new StringBuilder("Select IDlt, ResKey, Value, Locale" + 
                                  "From LocalizationTranslation");
            if (!string.IsNullOrEmpty(locale))
            {
                localizationTranslationSelectBld.AppendFormat(
                    " Where Locale = '{0}'", locale);
            }
            localizationTranslationSelect = 
                localizationTranslationSelectBld.ToString();
        }

        // Retrieves localization data from the database by using the provided
        // SQL statement
        private void SelectLocalizationValues(
            string localizationValueSelect,
            string localizationTranslationSelect,
            out Dictionary<Guid, string> localizationValue,
            out Dictionary<TranslationKey, string> localizationTranslation)
        {
            localizationValue = new Dictionary<Guid, string>();
            localizationTranslation = 
                new Dictionary<TranslationKey, string>();

            using (SqlConnection connection = 
                   new SqlConnection(connectionString))
            {
                connection.Open();

                SqlCommand command = new SqlCommand(localizationValueSelect,
                                                    connection);
                using (SqlDataReader reader = command.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        localizationValue.Add(reader.GetGuid(0),
                                              reader.GetString(1));
                    }
                }

                command.CommandText = localizationTranslationSelect;
                using (SqlDataReader reader = command.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        TranslationKey newTranslationKey = new TranslationKey()
                        {
                            id = reader.GetGuid(0),
                            resKey = reader.GetString(1),
                            locale = reader.GetString(3)
                        };
                        localizationTranslation.Add(newTranslationKey,
                                                    reader.GetString(2));
                    }
                }
            }
        }

        // Fills the PXCultureDictionary object with localization data by using
        // the provided dictionaries of values to translate and the
        // corresponding translations
        private PXCultureDictionary CreateCultureDictionary(
            bool escapeStrings,
            Dictionary<Guid, string> localizationValue,
            Dictionary<TranslationKey, string> localizationTranslation)
        {
            PXCultureDictionary dictionary = new PXCultureDictionary();

            if (localizationTranslation.Count != 0)
            {
                foreach (Guid id in localizationValue.Keys)
                {
                    IEnumerable<TranslationKey> localizationTranslationKeys = 
                        from translationRowKey in localizationTranslation.Keys
                        where translationRowKey.id == id
                        select translationRowKey;
                    foreach (TranslationKey key in localizationTranslationKeys)
                    {
                        string translationResKey = key.resKey;
                        string translationLocale = key.locale;
                        string translationValue = localizationTranslation[key];
                        string value = escapeStrings ?
                            PXLocalizer.EscapeString(translationValue) :
                            translationValue;

                        if (string.IsNullOrEmpty(translationResKey))
                        {
                            dictionary.Append(
                                localizationValue[id],
                                new PXCultureValue(translationLocale, value));
                        }
                        else
                        {
                            dictionary.AppendException(
                                localizationValue[id],
                                new PXCultureEx(translationResKey,
                                                translationLocale, value));
                        }
                    }
                }
            }
            return dictionary;
        }
    }
} To Disable Localization To disable localization, implement a custom translation provider with the                      LoadCultureDictionary()  method that returns                      null , as the following code shows. public class DemoTranslationProvider : PXTranslationProvider
{
    public override PXCultureDictionary LoadCultureDictionary(
        string locale, bool includeObsolete, bool escapeStrings)
    {
        return null;
    }
} To Register the New Provider in Web.config Once the provider class is defined, register it in the                      web.config  file by adding a new key to the                      providers  collection of the  pxtranslate                  element and specifying the new key in the  defaultProvider                  property of  pxtranslate . Use the  add  element                 to register the provider. Set the  name  attribute to the key,                 which can be any unique value, and specify the type of the custom provider in the                      type  attribute. The following code shows the configuration of                      DemoTranslationProvider , introduced in the example above, in                 the  pxtranslate  element of the  web.config                  file. <pxtranslate defaultProvider="DemoTranslationProvider">
  <providers>
    <!--The default translation provider-->
    <remove name="PXDBTranslatonProvider" />
    <add name="PXDBTranslatonProvider"
         type="PX.Data.PXDBTranslatonProvider, PX.Data" />

    <!--The custom translation provider-->
    <remove name="DemoTranslationProvider" />
    <add name="DemoTranslationProvider"
         type="Demo.Translation.DemoTranslationProvider, TranslationProvider"
         applicationName="/"/>
  </providers>
</pxtranslate> ]]></column>
		</row>
		<row PageID="76b8c160-89bd-4501-9f9f-1dabc648d417" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="d7d13646-6f1c-f4c2-ca7d-335afaba3635" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In an Acumatica ERP application or an Acumatica Framework-based application, you may need to use the same business logic in multiple places. For example, Acumatica ERP supports the calculation of amounts in multiple currencies. Therefore, the business logic containers (also called ''graphs'') that implement the multi-currency logic are included in different modules of the application. {br}

With the ability to reuse business logic in Acumatica ERP or Acumatica Framework, you can include the main business logic of particular functionality (such as multi-currency processing) in reusable generic graph extensions and use this logic whenever you need to. If you need to adjust this logic for the specifics of a particular module, you can override this business logic in the implementation of this module. For example, you can assign different names for the UI elements that are linked to the same fields of a data access class in different modules.{br}

In this section, you can find information about generic graph extensions. 
==In This Chapter==[anchor|#_c7db19f4-1a9d-40b5-80aa-72df8cd8f368]
{| class="checklist invisiblechecklist" | width="100%" 
|- 
| [anchor|#_4d514852-c595-4201-80d9-ca637a06b430]
*[HelpRoot_Dev_Platform\BL__con_Generic_Extensions|Reusable Business Logic Implementation]
*[HelpRoot_Dev_Platform\BL__con_Reusable_Logic_and_Database|Mapped Cache Extensions and the Application Database]
*[HelpRoot_Dev_Platform\BL__con_Reusable_Logic_and_Website|Reusable Business Logic and the Application Website]
*[HelpRoot_Dev_Platform\BL__con_Use_of_Generic_Graph_Extensions|Use of Generic Graph Extensions by the System]
*[HelpRoot_Dev_Platform\BL__con_Implemented_Generic_Extensions|Generic Graph Extensions Declared in Acumatica ERP]

| [anchor|#_94189ce6-10d1-46e3-bb78-75704a6a0c53]
*[HelpRoot_Dev_Platform\BL__how_Insert_Reusable_Business_Logic|To Insert Reusable Business Logic That Has Already Been Declared]
*[HelpRoot_Dev_Platform\BL__how_Sort_Generic_Graph_Extensions|To Sort Multiple Generic Graph Extensions]
*[HelpRoot_Dev_Platform\BL__how_Create_Reusable_Logic|To Implement Reusable Business Logic]

|}]]></column>
			<column name="PlainText"><![CDATA[Reusing Business Logic In an  Acumatica ERP     application or an  Acumatica Framework-based     application, you may need to use the same business logic in multiple places. For example,  Acumatica ERP     supports the calculation of amounts in multiple currencies. Therefore, the business logic     containers (also called  graphs ) that implement the multi-currency logic are included in     different modules of the application.  With the ability to reuse business logic in  Acumatica ERP     or  Acumatica Framework, you can include the main business logic of particular functionality (such as multi-currency     processing) in reusable generic graph extensions and use this logic whenever you need to. If you     need to adjust this logic for the specifics of a particular module, you can override this     business logic in the implementation of this module. For example, you can assign different names     for the UI elements that are linked to the same fields of a data access class in different     modules. In this section, you can find information about generic graph extensions.  In This Chapter Reusable Business Logic ImplementationMapped Cache Extensions and the Application DatabaseReusable Business Logic and the Application WebsiteUse of Generic Graph Extensions by the SystemGeneric Graph Extensions Declared in Acumatica ERPTo Insert Reusable Business Logic That Has Already Been DeclaredTo Sort Multiple Generic Graph ExtensionsTo Implement Reusable Business Logic]]></column>
		</row>
		<row PageID="bbc04253-7686-41dd-898b-aca47c1c6789" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="dd319429-593f-ad94-780c-6fc3ae61a58e" RecordSourceID="22377">
			<column name="Content"><![CDATA[
Suppose that you want to use the same business logic in multiple places in your application. That is, you have at least two graphs in which you need to insert the logic. The graphs operate with data in the data access classes (DACs) and implement business logic through event handlers, actions, and other methods. {br}

You encapsulate the business logic that you want to reuse in a ''generic graph extension'', which is a graph extension that does not relate to any particular graph and can be used with any base graph. The generic graph extension operates with data by using the ''mapped cache extensions'', which are cache extensions that are not bound to any particular DAC and can extend any DAC.{br}

To connect the mapped cache extensions to a particular DAC, you use a ''mapping class'', which maps the fields of a mapped cache extension to the fields of a DAC. To connect the generic graph extension to a particular base graph, in the base graph, you define an ''implementation class'', which inherits the generic graph extension. The following diagram shows in yellow rectangles the classes that you need to implement to reuse the business logic.[anchor|#_43ec8f0d-cef8-49a4-8f37-ea69850d117c][anchor|#_e15a1ec8-ebfa-417b-89cd-053a2c5d0d31][image:StudioDeveloperGuide/Images/GenericGraphExtensionImplementation.png|popup|Required classes|450px]{br}

These classes are described in detail in the sections below. (For details on the implementation of the classes, see [HelpRoot_Dev_Platform\BL__how_Create_Reusable_Logic|To Implement Reusable Business Logic] and [HelpRoot_Dev_Platform\BL__how_Insert_Reusable_Business_Logic|To Insert Reusable Business Logic That Has Already Been Declared].){br}{TOC}[anchor|#_efcb1dec-e793-4a88-b333-e647c6ff2b5e]
==Mapped Cache Extension==
A mapped cache extension is an analog of a data access class (DAC) for a generic graph extension. In the mapped cache extension, you include the main fields that are used in the reusable business logic implementation. You map the fields of a mapped cache extension to the fields of a base DAC by using the mapping class, which is described in the following section. The mapped cache extension can also include the fields that are not mapped to any base DAC fields. (For details, see [HelpRoot_Dev_Platform\BL__con_Reusable_Logic_and_Database|Mapped Cache Extensions and the Application Database].){br}

The class of a mapped cache extension inherits from the <tt>PXMappedCacheExtension</tt>{{abstract}} class, which derives from <tt>PXCacheExtension</tt> and <tt>IBqlTable</tt>. {br}

The declaration of a field of a mapped cache extension includes the following two required members, which are the same as the required members of a DAC field:[anchor|#_e3cd30ae-59bd-4689-b74c-d85dc4f8af9e]
*A {{public abstract}} class (which is also referred to as ''class field'').
*:You derive the class from the <tt>IBqlField</tt> interface and assign it a name that starts with a lowercase letter. 
*A {{public virtual}} property (which is also referred to as ''property field'').
*:You assign the property a name that starts with an uppercase letter. The system assigns the [https://help.acumatica.com/Main?ScreenId=ShowWiki&pageid=b78b0a53-b9db-0693-66fa-7d2b432b9f38|<tt>PXMergeAttributes</tt>] attribute with <tt>MergeMethod.Merge</tt> to each field of a mapped cache extension automatically. If you define the <tt>PXMergeAttributes</tt> attribute for a field of a mapped cache extension explicitly, the explicitly defined attribute overrides the automatically defined. You can also define any other attributes for the property field of the mapped cache extension, or not define the attributes at all. 
{br}

The following code shows an example of a mapped cache extension.[anchor|#_5d32dc99-bc18-4e51-bddf-520f842b04c6]<source lang="csharp">//Mapped cache extension
public class Document : PXMappedCacheExtension
{
  //BAccountID field
  public abstract class bAccountID : IBqlField
  {
  }
  protected Int32? _BAccountID;

  public virtual Int32? BAccountID
  {
    get
    {
      return _BAccountID;
    }
    set
    {
      _BAccountID = value;
    }
  }

  //CuryID field
  public abstract class curyID : IBqlField
  {
  }
  protected String _CuryID;

  public virtual String CuryID
  {
    get
    {
      return _CuryID;
    }
    set
    {
      _CuryID = value;
    }
  }

  ...
}</source>[anchor|#_07af458f-a094-4b51-8859-a8204ccb196e]
==Mapping Class==
A mapping class is a {{protected}} class that defines the mapping between the fields of a mapped cache extension and the fields of a DAC. In a generic graph extension, you declare a mapping class for each mapped cache extension that you need to use in the reusable logic implementation. {br}

A mapping class implements the <tt>IBqlMapping</tt> interface, which has the following two properties:[anchor|#_652c106e-e7ef-4aad-95da-aa2d133d77ae]
*<tt>Extension</tt>: The mapped cache extension
*<tt>Table</tt>: The DAC to which the extension is mapped
{br}

In the declaration of the mapping class, you also include declarations of the properties for each field of the mapped cache extension that you want to map to a field of the DAC, as the following code shows.[anchor|#_d954a8c7-234a-40a6-b51b-5e89b128763b]<source lang="csharp">//A mapping class
protected class DocumentMapping : IBqlMapping
{
  public Type Extension =&gt; typeof(Document);
  protected Type _table;
  public Type Table =&gt; _table;

  public DocumentMapping(Type table)
  {
    _table = table;
  }
  public Type BAccountID = typeof(Document.bAccountID);
  public Type CuryInfoID = typeof(Document.curyInfoID);
  public Type CuryID = typeof(Document.curyID);
  public Type DocumentDate = typeof(Document.documentDate);
}</source>{br}

If the name of a property field of the DAC is the same as the name of the mapping class property, the DAC field will be automatically mapped to the field of the mapped cache extension by the implementation class (which is described below). If the name of a property field of the DAC differs from the name of the mapping class field, you redefine the mapping manually in the implementation class. If no field in the DAC has the name of the mapping class field, and no mapping is defined in the implementation class, the field of the mapped cache extension is not mapped to any base DAC field, as shown in the following diagram.[anchor|#_f7b40bd5-e36d-4500-8207-902bd81b0876][anchor|#_914515bb-c9ea-4fac-bed9-cc8c1501171a][image:StudioDeveloperGuide/Images/MappingClass.png|popup|Mapping declaration|450px]
==Generic Graph Extension==
A generic graph extension is a {{public abstract}} class that encapsulates business logic that can be used in multiple places of an Acumatica ERP application or an Acumatica Framework-based application. The class inherits from the <tt>PXGraphExtension&lt;TGraph&gt;</tt> class, as the following code shows.[anchor|#_82ab087a-447d-4736-984b-8d6d7b2e40f0]<source lang="csharp">public abstract class MultiCurrencyGraph&lt;TGraph, TPrimary&gt; : 
  PXGraphExtension&lt;TGraph&gt;
    where TGraph : PXGraph
    where TPrimary : class, IBqlTable, new()
{
}</source>{br}

 In the generic graph extension, you declare the following items:[anchor|#_23fad20f-84ed-4d26-b5ae-8e9b7dcbc686]
*The mapping classes.
*The {{protected abstract}} methods that return the mapping classes. You have to override these methods in the implementation class.
*The views that can have either mapping-based declaration or standard declaration. You declare a mapping-based view by using the <tt>PXSelectExtension&lt;Table&gt;</tt> class.
*The event handlers, actions, and other methods.

==Implementation Class==
An implementation class defines the implementation of a generic graph extension for a particular graph. You declare the implementation class as a class that derives from the generic graph extension class with the following type parameters:[anchor|#_02a7771b-32de-4650-86f1-cbe267d53d30]
*The base graph to which you add reusable logic
*The main DAC of the primary data view of the base graph
{br}

In this class, you can override the mapping defined by the mapping class, override other the methods of the base class, and insert your own views, methods, and event handlers, as the following code shows.[anchor|#_c5b55c1f-0f7f-4462-8188-f0498e311b2c]<source lang="csharp">public class MultiCurrency : MultiCurrencyGraph&lt;OpportunityMaint, CROpportunity&gt;
{   
  protected override DocumentMapping GetDocumentMapping()
  {
    return new DocumentMapping(typeof(CROpportunity)) 
    {
      DocumentDate =  typeof(CROpportunity.closeDate)
    };
  }  

  protected override CurySourceMapping GetCurySourceMapping()
  {
    return new CurySourceMapping(typeof(Customer));
  }

  public PXSelect&lt;CRSetup&gt; crCurrency;
  protected PXSelectExtension&lt;CurySource&gt; SourceSetup =&gt; 
   new PXSelectExtension&lt;CurySource&gt;(crCurrency);

  protected virtual CurySourceMapping GetSourceSetupMapping()
  { 
    return new CurySourceMapping(typeof(CRSetup)) 
    {
      CuryID = typeof(CRSetup.defaultCuryID), 
       CuryRateTypeID = typeof(CRSetup.defaultRateTypeID)
    };        
  }

  protected override CurySource CurrentSourceSelect()
  {
    ...
  }
}</source>
==Related Articles==
*[HelpRoot_Dev_Platform\BL__how_Insert_Reusable_Business_Logic|To Insert Reusable Business Logic That Has Already Been Declared]
*[HelpRoot_Dev_Platform\BL__how_Create_Reusable_Logic|To Implement Reusable Business Logic]]]></column>
			<column name="PlainText"><![CDATA[Reusable Business Logic Implementation Suppose that you want to use the same business logic in multiple places in your                 application. That is, you have at least two graphs in which you need to insert the                 logic. The graphs operate with data in the data access classes (DACs) and implement                 business logic through event handlers, actions, and other methods.  You encapsulate the business logic that you want to reuse in a  generic graph                     extension , which is a graph extension that does not relate to any particular                 graph and can be used with any base graph. The generic graph extension operates with                 data by using the  mapped cache extensions , which are cache extensions that                 are not bound to any particular DAC and can extend any DAC. To connect the mapped cache extensions to a particular DAC, you use a  mapping                     class , which maps the fields of a mapped cache extension to the fields of a                 DAC. To connect the generic graph extension to a particular base graph, in the base                 graph, you define an  implementation class , which inherits the generic graph                 extension. The following diagram shows in yellow rectangles the classes that you                 need to implement to reuse the business logic. Required classes These classes are described in detail in the sections below. (For details on the                 implementation of the classes, see  To Implement Reusable Business Logic and  To Insert Reusable Business Logic That Has Already Been Declared.) Mapped Cache Extension A mapped cache extension is an analog of a data access class (DAC) for a generic                 graph extension. In the mapped cache extension, you include the main fields that are                 used in the reusable business logic implementation. You map the fields of a mapped                 cache extension to the fields of a base DAC by using the mapping class, which is                 described in the following section. The mapped cache extension can also include the                 fields that are not mapped to any base DAC fields. (For details, see  Mapped Cache Extensions and the Application Database.) The class of a mapped cache extension inherits from the                      PXMappedCacheExtension abstract  class, which derives from                      PXCacheExtension  and  IBqlTable .  The declaration of a field of a mapped cache extension includes the following two                 required members, which are the same as the required members of a DAC field: A  public abstract  class (which is also referred to as                              class field ). You derive the class from the                                  IBqlField  interface and assign it a name that                             starts with a lowercase letter.  A  public virtual  property (which is also referred to as                              property field ). You assign the property a name that starts                                 with an uppercase letter. The system assigns the  PXMergeAttributes <tt>PXMergeAttributes</tt>                             attribute with  MergeMethod.Merge  to each field of a                             mapped cache extension automatically. If you define the                                  PXMergeAttributes  attribute for a field of a                             mapped cache extension explicitly, the explicitly defined attribute                             overrides the automatically defined. You can also define any other                             attributes for the property field of the mapped cache extension, or not                             define the attributes at all.  The following code shows an example of a mapped cache                 extension. //Mapped cache extension
public class Document : PXMappedCacheExtension
{
  //BAccountID field
  public abstract class bAccountID : IBqlField
  {
  }
  protected Int32? _BAccountID;

  public virtual Int32? BAccountID
  {
    get
    {
      return _BAccountID;
    }
    set
    {
      _BAccountID = value;
    }
  }

  //CuryID field
  public abstract class curyID : IBqlField
  {
  }
  protected String _CuryID;

  public virtual String CuryID
  {
    get
    {
      return _CuryID;
    }
    set
    {
      _CuryID = value;
    }
  }

  ...
} Mapping Class A mapping class is a  protected  class that defines the mapping                 between the fields of a mapped cache extension and the fields of a DAC. In a generic                 graph extension, you declare a mapping class for each mapped cache extension that                 you need to use in the reusable logic implementation.  A mapping class implements the  IBqlMapping  interface, which has                 the following two properties: Extension : The mapped cache extension Table : The DAC to which the extension is mapped In the declaration of the mapping class, you also include declarations of the                 properties for each field of the mapped cache extension that you want to map to a                 field of the DAC, as the following code                 shows. //A mapping class
protected class DocumentMapping : IBqlMapping
{
  public Type Extension => typeof(Document);
  protected Type _table;
  public Type Table => _table;

  public DocumentMapping(Type table)
  {
    _table = table;
  }
  public Type BAccountID = typeof(Document.bAccountID);
  public Type CuryInfoID = typeof(Document.curyInfoID);
  public Type CuryID = typeof(Document.curyID);
  public Type DocumentDate = typeof(Document.documentDate);
} If the name of a property field of the DAC is the same as the name of the mapping                 class property, the DAC field will be automatically mapped to the field of the                 mapped cache extension by the implementation class (which is described below). If                 the name of a property field of the DAC differs from the name of the mapping class                 field, you redefine the mapping manually in the implementation class. If no field in                 the DAC has the name of the mapping class field, and no mapping is defined in the                 implementation class, the field of the mapped cache extension is not mapped to any                 base DAC field, as shown in the following diagram. Mapping declaration Generic Graph Extension A generic graph extension is a  public abstract  class that                 encapsulates business logic that can be used in multiple places of an  Acumatica ERP application or an  Acumatica Framework-based application. The class inherits from the                      PXGraphExtension<TGraph>  class, as the following code                 shows. public abstract class MultiCurrencyGraph<TGraph, TPrimary> : 
  PXGraphExtension<TGraph>
    where TGraph : PXGraph
    where TPrimary : class, IBqlTable, new()
{
}  In the generic graph extension, you declare the following items: The mapping classes. The  protected abstract  methods that return the mapping                         classes. You have to override these methods in the implementation                         class. The views that can have either mapping-based declaration or standard                         declaration. You declare a mapping-based view by using the                              PXSelectExtension<Table>  class. The event handlers, actions, and other methods. Implementation Class An implementation class defines the implementation of a generic graph extension for a                 particular graph. You declare the implementation class as a class that derives from                 the generic graph extension class with the following type parameters: The base graph to which you add reusable logic The main DAC of the primary data view of the base graph In this class, you can override the mapping defined by the mapping class, override                 other the methods of the base class, and insert your own views, methods, and event                 handlers, as the following code                 shows. public class MultiCurrency : MultiCurrencyGraph<OpportunityMaint, CROpportunity>
{   
  protected override DocumentMapping GetDocumentMapping()
  {
    return new DocumentMapping(typeof(CROpportunity)) 
    {
      DocumentDate =  typeof(CROpportunity.closeDate)
    };
  }  

  protected override CurySourceMapping GetCurySourceMapping()
  {
    return new CurySourceMapping(typeof(Customer));
  }

  public PXSelect<CRSetup> crCurrency;
  protected PXSelectExtension<CurySource> SourceSetup => 
   new PXSelectExtension<CurySource>(crCurrency);

  protected virtual CurySourceMapping GetSourceSetupMapping()
  { 
    return new CurySourceMapping(typeof(CRSetup)) 
    {
      CuryID = typeof(CRSetup.defaultCuryID), 
       CuryRateTypeID = typeof(CRSetup.defaultRateTypeID)
    };        
  }

  protected override CurySource CurrentSourceSelect()
  {
    ...
  }
} ]]></column>
		</row>
		<row PageID="cda07180-43aa-4b2e-9370-534336beb620" Language="en-US" PageRevisionID="1" PlainText="Mapped Cache Extensions and the Application Database The fields of a mapped cache extension that are mapped to the fields of a base data access    class (DAC) are used by the system to work with the database columns to which the fields of the    base DAC are bound.  If a mapped cache extension includes fields that are bound to database columns (with the type    attributes that are derived from the  PXDBFieldAttribute  class, such as      PXDBString ), the database table that corresponds to the base DAC must contain    these fields of the mapped cache extension. That is, the database table must include the fields    bound to a database column that are defined both in the base DAC and the mapped cache extension,    as shown in the following diagram. Database schema for a DAC and mapped cache extension " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="a592056a-e99b-9508-b36a-8a965c7b913f" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The fields of a mapped cache extension that are mapped to the fields of a base data access class (DAC) are used by the system to work with the database columns to which the fields of the base DAC are bound. {br}

If a mapped cache extension includes fields that are bound to database columns (with the type attributes that are derived from the <tt>PXDBFieldAttribute</tt> class, such as <tt>PXDBString</tt>), the database table that corresponds to the base DAC must contain these fields of the mapped cache extension. That is, the database table must include the fields bound to a database column that are defined both in the base DAC and the mapped cache extension, as shown in the following diagram.[anchor|#_c6c94e56-bb23-4c22-9586-9c5fa9a782c7][anchor|#_ad79f500-d887-4c35-8a0a-b9a00c44369d][image:StudioDeveloperGuide/Images/DatabaseSchemaForDACwithMCE.png|popup|Database schema for a DAC and mapped cache extension|450px]
==Related Articles==
*[HelpRoot_Dev_Platform\BL__con_Generic_Extensions|Reusable Business Logic Implementation]]]></column>
		</row>
		<row PageID="56b9b5ae-bc64-4e91-8aa5-8b17894d886a" Language="en-US" PageRevisionID="1" PlainText="Reusable Business Logic and the Application Website If the field of a mapped cache extension is mapped to a field of the base data access class       (DAC), you can use the merged field (that is, the base field that has merged attributes of the       base field and the mapped cache extension field) to configure the UI elements of the website       page. If the field of the mapped cache extension is not mapped to a field of the base DAC, you       can use the field of the mapped cache extension in the website page, as shown in the following         diagram. Fields on the website page The actions that are defined in the base graph, generic graph extension, and implementation       class are automatically added by the system on the website page, as shown in the following       diagram. The implementation class can override the actions declared in the generic graph         extension. Actions on a website page " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="ae4a33d1-ce42-4085-a957-d4cbd0ad00bb" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If the field of a mapped cache extension is mapped to a field of the base data access class (DAC), you can use the merged field (that is, the base field that has merged attributes of the base field and the mapped cache extension field) to configure the UI elements of the website page. If the field of the mapped cache extension is not mapped to a field of the base DAC, you can use the field of the mapped cache extension in the website page, as shown in the following diagram.[anchor|#_60f05de4-dcc9-403c-b735-4155b3615734][anchor|#_b45e1e98-3b40-40d0-84d7-0ccf0243c62f][image:StudioDeveloperGuide/Images/GenericGraphExtensions_FieldsOnWebPage.png|popup|Fields on the website page|450px]{br}

The actions that are defined in the base graph, generic graph extension, and implementation class are automatically added by the system on the website page, as shown in the following diagram. The implementation class can override the actions declared in the generic graph extension.[anchor|#_e41a7eee-e129-448e-a0c0-0763d2f0b046][anchor|#_cc6a313c-1057-49a8-96a1-af60780f64ba][image:StudioDeveloperGuide/Images/GenericGraphExtensions_ActionsOnWebPage.png|popup|Actions on a website page|450px]]]></column>
		</row>
		<row PageID="eece8358-f6ea-47e8-899a-d466eccbc14e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="3015d5bd-55a3-d021-0f52-e2b4b792e7c4" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you will learn how Acumatica ERP or an Acumatica Framework-based application works with generic graph extensions. 
==Initialization of a Graph Instance That Includes Reusable Logic==
During the initialization of a graph instance that includes reusable logic, the system adds to the collection of data views the data views that are declared in the base graph, including those that are declared in the implementation class or the generic graph extension from which the implementation class inherits. The mapping classes define the <tt>PXCache&lt;Table&gt;</tt> objects in which the mapping-based views keep data records.{br}

Event handlers that are declared in the base graph, implementation class, and generic graph extension are added by the system to the collections of event handlers in the corresponding <tt>PXCache</tt> object. The event handlers defined for the fields or rows of the mapped cache extension are added to the <tt>PXCache</tt> object of the base DAC type to which the mapped cache extension is mapped. {br}

The following diagram illustrates the initialization of a sample {{OpportunityMaint}} graph instance that includes reusable logic.[anchor|#_7ab9179e-c6fc-44be-a48a-939e955baa38][anchor|#_d3b46784-57fb-4047-b0eb-587d56bc3faf][image:StudioDeveloperGuide/Images/GenericGraphExtension_GraphInstance.png|popup|Intitialization of a graph instance|450px]]]></column>
			<column name="PlainText"><![CDATA[Use of Generic Graph Extensions by the System In this topic, you will learn how  Acumatica ERP     or an  Acumatica Framework-based     application works with generic graph extensions.  Initialization of a Graph Instance That Includes Reusable Logic During the initialization of a graph instance that includes reusable logic, the system adds to         the collection of data views the data views that are declared in the base graph, including         those that are declared in the implementation class or the generic graph extension from         which the implementation class inherits. The mapping classes define the            PXCache<Table>  objects in which the mapping-based views keep data         records. Event handlers that are declared in the base graph, implementation class, and generic graph         extension are added by the system to the collections of event handlers in the corresponding            PXCache  object. The event handlers defined for the fields or rows of         the mapped cache extension are added to the  PXCache  object of the base         DAC type to which the mapped cache extension is mapped.  The following diagram illustrates the initialization of a sample            OpportunityMaint  graph instance that includes reusable logic. Intitialization of a graph instance ]]></column>
		</row>
		<row PageID="0fd80806-d566-405c-b8cf-58ec58336b1f" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="29b2b892-7a32-8e73-6d78-72bf0b72a465" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The source code of Acumatica ERP includes the definitions of the generic graph extensions, which are described in detail in the following sections. These graph extensions are declared in the <tt>PX.Objects.Extensions</tt> namespace. You can use these generic graph extensions if you want to include the implemented functionality in the forms of your application. For details on how to include this functionality in your application, see [HelpRoot_Dev_Platform\BL__how_Insert_Reusable_Business_Logic|To Insert Reusable Business Logic That Has Already Been Declared].{br}{TOC}
==Multi-Currency Extension==
If you need to work with multiple currencies on a form, you can insert an implementation of the <tt>MultiCurrencyGraph&lt;TGraph, TPrimary&gt;</tt>{{abstract}} class in the graph that provides business logic for the form. For more information on the use of multiple currencies in the system, see [HelpRoot_Financials\CM_00_00_00|Currency Management] in the Financial Management Guide.{br}

The <tt>MultiCurrencyGraph&lt;TGraph, TPrimary&gt;</tt> class works with the following mapped cache extensions:[anchor|#_5f840836-aecb-4cfb-b648-1ee0679cda9d]
*<tt>Document</tt>: Represents a document that supports multi-currency
*<tt>CurySource</tt>: Contains the information on the currency source
{br}

For more information on these classes, see the API Reference.
==Sales Price Extension==
If you need to work with multiple price lists on a form, you can insert an implementation of the <tt>SalesPriceGraph&lt;TGraph, TPrimary&gt;</tt>{{abstract}} class in the graph that provides business logic for the form. For more information on sales prices, see [HelpRoot_Financials\AR__MNG_Sales_Prices|Managing Sales Prices] in the Financial Management Guide.{br}

The <tt>SalesPriceGraph&lt;TGraph, TPrimary&gt;</tt> class works with the following mapped cache extensions:[anchor|#_1efc97ac-24c9-441f-bd77-4ed82147b252]
*<tt>Document</tt>: Represents a document that supports multiple price lists
*<tt>Detail</tt>: Represents a detail line of the document
*<tt>PriceClassSource</tt>: Provides information about the source of the price class
 For more information on these classes, see the API Reference.
==Discount Extension==
If you need to work with discounts on a form, you can insert an implementation of the <tt>DiscountGraph&lt;TGraph, TPrimary&gt;</tt>{{abstract}} class in the graph that provides business logic for the form. For more information on discounts, see [HelpRoot_Financials\SO__MNG_Discounts_Prices|Managing Customer Discounts] in the Financial Management Guide.{br}

The <tt>DiscountGraph&lt;TGraph, TPrimary&gt;</tt> class works with the following mapped cache extensions:[anchor|#_8412b85f-e324-4624-b493-1e57b495d7a4]
*<tt>Document</tt>: Represents a document that supports discounts
*<tt>Detail</tt>: Represents a detail line of the document
*<tt>Discount</tt>: Provides information about the discount
{br}

For details on these classes, see the API Reference.
==Sales Tax Extension==
If you need to apply sales taxes to amounts of a form, you can insert an implementation of the <tt>TaxGraph&lt;TGraph, TPrimary&gt;</tt>{{abstract}} class in the graph that provides business logic for the form. For more information on taxes in the system, see [HelpRoot_Financials\TX_00_00_00|Taxes] in the Financial Management Guide.{br}

The <tt>TaxGraph&lt;TGraph, TPrimary&gt;</tt> class works with the following mapped cache extensions:[anchor|#_1442e3e4-724e-480b-97eb-c18a07fb57e6]
*<tt>Document</tt>: Represents a document that supports sales taxes.
*<tt>Detail</tt>: Represents a detail line of the document.
*<tt>TaxTotal</tt>: Represents the tax total amount
*<tt>TaxDetail</tt>: Represents a tax detail line
{br}

For detailed descriptions of the classes, see the API Reference.
==Related Articles==
*[HelpRoot_Dev_Platform\BL__how_Insert_Reusable_Business_Logic|To Insert Reusable Business Logic That Has Already Been Declared]]]></column>
			<column name="PlainText"><![CDATA[Generic Graph Extensions Declared in  Acumatica ERPThe source code of  Acumatica ERP includes the definitions of the generic graph extensions, which are described in detail         in the following sections. These graph extensions are declared in the            PX.Objects.Extensions  namespace. You can use these generic graph         extensions if you want to include the implemented functionality in the forms of your         application. For details on how to include this functionality in your application, see  To Insert Reusable Business Logic That Has Already Been Declared. Multi-Currency Extension If you need to work with multiple currencies on a form, you can insert an implementation of         the  MultiCurrencyGraph<TGraph, TPrimary> abstract  class in the graph that provides business logic for the form. For         more information on the use of multiple currencies in the system, see   ([~/?ScreenId=CM000000|CM000000]) Currency Management in the Financial Management Guide. The  MultiCurrencyGraph<TGraph, TPrimary>  class works with the         following mapped cache extensions: Document : Represents a document that supports multi-currency CurySource : Contains the information on the currency source For more information on these classes, see the API Reference. Sales Price Extension If you need to work with multiple price lists on a form, you can insert an implementation of         the  SalesPriceGraph<TGraph, TPrimary> abstract  class in the graph that provides business logic for the form. For         more information on sales prices, see  Managing Sales Prices         in the Financial Management Guide. The  SalesPriceGraph<TGraph, TPrimary>  class works with the following         mapped cache extensions: Document : Represents a document that supports multiple price             lists Detail : Represents a detail line of the document PriceClassSource : Provides information about the source of the             price class  For more information on these classes, see the API Reference. Discount Extension If you need to work with discounts on a form, you can insert an implementation of the            DiscountGraph<TGraph, TPrimary> abstract  class in the graph that provides business logic for the form. For         more information on discounts, see  Managing Customer Discounts         in the Financial Management Guide. The  DiscountGraph<TGraph, TPrimary>  class works with the following         mapped cache extensions: Document : Represents a document that supports discounts Detail : Represents a detail line of the document Discount : Provides information about the discount For details on these classes, see the API Reference. Sales Tax Extension If you need to apply sales taxes to amounts of a form, you can insert an implementation of         the  TaxGraph<TGraph, TPrimary> abstract  class in the graph that provides business logic for the form. For         more information on taxes in the system, see   ([~/?ScreenId=TX000000|TX000000]) Taxes in         the Financial Management Guide. The  TaxGraph<TGraph, TPrimary>  class works with the following mapped         cache extensions: Document : Represents a document that supports sales taxes. Detail : Represents a detail line of the document. TaxTotal : Represents the tax total amount TaxDetail : Represents a tax detail line For detailed descriptions of the classes, see the API Reference. ]]></column>
		</row>
		<row PageID="c9249c85-d703-4124-a376-bea0dd56c54e" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="1a8e35be-f002-e985-0751-b2bd104203ae" RecordSourceID="22377">
			<column name="Content"><![CDATA[
In this topic, you can find information about how to insert an already-declared generic graph extension in the application code.
==To Add a Generic Graph Extension to a Graph==[anchor|#_359459df-c5aa-4d02-8c9f-cdf1e2c4ec2b]
#Review the generic graph extension that provides the business logic that you want to reuse as follows:
##Identify the mapped cache extensions the generic graph extension works with and the list of their fields, and decide whether the default mapping (which is defined by the mapping class of the generic graph extension) is suitable for the base data access class (DAC) that you are going to use.
##Identify the fields of the mapped cache extension that are bound to columns of a database table, and make sure the database table that corresponds to the base DAC includes the columns to store the data from the mapped cache extension.
#In the code of the graph you need to add the reusable business logic to, add the public implementation class that derives from the generic graph extension of the needed type. Use the following types in the type parameters of the generic graph extension:
#*The base graph to which you add reusable logic
#*The main DAC of the primary data view of the base graphIn the following code, the {{MultiCurrency}} class extends the {{OpportunityMaint}} graph. The {{MultiCurrency}} class derives from {{public abstract class MultiCurrencyGraph<TGraph, TPrimary> : PXGraphExtension<TGraph>}}.<source lang="csharp">public class MultiCurrency : MultiCurrencyGraph&lt;OpportunityMaint, CROpportunity&gt;
{
}</source>
#In the added class, override the {{abstract}} methods of the generic graph extension as follows:
#*In the overridden methods of the generic graph extension that return the mapping classes, either use the default mapping of the fields of the mapped cache extension to the fields of the base DAC or adjust the mapping. 
#*In the other overridden methods, implement the required business logic. For details on the implementation of the methods in the generic graph extension declared in Acumatica ERP, see API Reference.
#In the added class, adjust the reused business logic by doing any of the following:
#*Override other methods of the base class.
#*Add your own views, methods, and event handlers.
#:The following code shows a sample implementation of the {{MultiCurrency}} class, which reuses the multi-currency business logic defined in the <tt>MultiCurrencyGraph</tt> generic graph extension.[anchor|#_42f3da2e-6483-48b4-88f0-dfe4c0b528ce]<source lang="csharp">public class MultiCurrency : MultiCurrencyGraph&lt;OpportunityMaint, CROpportunity&gt;
{   
  protected override DocumentMapping GetDocumentMapping()
  {
    return new DocumentMapping(typeof(CROpportunity)) 
    {
      DocumentDate =  typeof(CROpportunity.closeDate)
    };
  }  

  protected override CurySourceMapping GetCurySourceMapping()
  {
    return new CurySourceMapping(typeof(Customer));
  }

  public PXSelect&lt;CRSetup&gt; crCurrency;
  protected PXSelectExtension&lt;CurySource&gt; SourceSetup =&gt; 
   new PXSelectExtension&lt;CurySource&gt;(crCurrency);

  protected virtual CurySourceMapping GetSourceSetupMapping()
  { 
    return new CurySourceMapping(typeof(CRSetup)) 
    {
      CuryID = typeof(CRSetup.defaultCuryID), 
       CuryRateTypeID = typeof(CRSetup.defaultRateTypeID)
    };        
  }

  protected override CurySource CurrentSourceSelect()
  {
    ...
  }
}</source>
]]></column>
			<column name="PlainText"><![CDATA[To Insert Reusable Business Logic That Has Already Been Declared In this topic, you can find information about how to insert an already-declared                 generic graph extension in the application code. To Add a Generic Graph Extension to a Graph Review the generic graph extension that provides the business logic that you                     want to reuse as follows: Identify the mapped cache extensions the generic graph extension works                             with and the list of their fields, and decide whether the default                             mapping (which is defined by the mapping class of the generic graph                             extension) is suitable for the base data access class (DAC) that you are                             going to use. Identify the fields of the mapped cache extension that are bound to                             columns of a database table, and make sure the database table that                             corresponds to the base DAC includes the columns to store the data from                             the mapped cache extension. In the code of the graph you need to add the reusable business logic to, add the                     public implementation class that derives from the generic graph extension of the                     needed type. Use the following types in the type parameters of the generic graph                         extension: The base graph to which you add reusable logic The main DAC of the primary data view of the base graph In the following code, the  MultiCurrency  class extends the                          OpportunityMaint  graph. The  MultiCurrency                      class derives from  public abstract class MultiCurrencyGraph<TGraph,                         TPrimary> :                     PXGraphExtension<TGraph> . public class MultiCurrency : MultiCurrencyGraph<OpportunityMaint, CROpportunity>
{
} In the added class, override the  abstract  methods of the                     generic graph extension as follows: In the overridden methods of the generic graph extension that return the                             mapping classes, either use the default mapping of the fields of the                             mapped cache extension to the fields of the base DAC or adjust the                             mapping.  In the other overridden methods, implement the required business logic.                             For details on the implementation of the methods in the generic graph                             extension declared in  Acumatica ERP, see API Reference. In the added class, adjust the reused business logic by doing any of the                         following: Override other methods of the base class. Add your own views, methods, and event handlers. The following code shows a sample implementation of the                              MultiCurrency  class, which reuses the multi-currency                         business logic defined in the  MultiCurrencyGraph  generic                         graph                         extension. public class MultiCurrency : MultiCurrencyGraph<OpportunityMaint, CROpportunity>
{   
  protected override DocumentMapping GetDocumentMapping()
  {
    return new DocumentMapping(typeof(CROpportunity)) 
    {
      DocumentDate =  typeof(CROpportunity.closeDate)
    };
  }  

  protected override CurySourceMapping GetCurySourceMapping()
  {
    return new CurySourceMapping(typeof(Customer));
  }

  public PXSelect<CRSetup> crCurrency;
  protected PXSelectExtension<CurySource> SourceSetup => 
   new PXSelectExtension<CurySource>(crCurrency);

  protected virtual CurySourceMapping GetSourceSetupMapping()
  { 
    return new CurySourceMapping(typeof(CRSetup)) 
    {
      CuryID = typeof(CRSetup.defaultCuryID), 
       CuryRateTypeID = typeof(CRSetup.defaultRateTypeID)
    };        
  }

  protected override CurySource CurrentSourceSelect()
  {
    ...
  }
} ]]></column>
		</row>
		<row PageID="28785249-a875-492f-bca9-82da9cd5c0b4" Language="en-US" PageRevisionID="1" Content="&#xA;If you need to add multiple generic graph extensions to a graph, you need to define the order in which the extensions are applied.{br}&#xA;&#xA;To define the order in which the generic graph extensions are applied, add the class inherited from the {{Autofac.Module}} class and implement the sorting of the generic class extensions, as the following code shows.&lt;source lang=&quot;csharp&quot;&gt;public class ServiceRegistration : Module&#xA;{&#xA;  protected override void Load(ContainerBuilder builder)&#xA;  {&#xA;    builder.ActivateOnApplicationStart&amp;lt;ExtensionSorting&amp;gt;();&#xA;  }&#xA;  private class ExtensionSorting&#xA;  {&#xA;    private static readonly Dictionary&amp;lt;Type, int&amp;gt; _order = new Dictionary&amp;lt;Type, int&amp;gt;&#xA;    {&#xA;      {typeof(MultiCurrency), 4},&#xA;      {typeof(SalesPrice), 3},&#xA;      {typeof(Discount), 2},&#xA;      {typeof(SalesTax), 1},&#xA;    };&#xA;    public ExtensionSorting()&#xA;    {&#xA;      ...&#xA;    }&#xA;  }&#xA;}&lt;/source&gt;" PlainText="To Sort Multiple Generic Graph Extensions If you need to add multiple generic graph extensions to a graph, you need to define the order     in which the extensions are applied. To define the order in which the generic graph extensions are applied, add the class inherited         from the  Autofac.Module  class and implement the sorting of the generic         class extensions, as the following code         shows. public class ServiceRegistration : Module&#xA;{&#xA;  protected override void Load(ContainerBuilder builder)&#xA;  {&#xA;    builder.ActivateOnApplicationStart&lt;ExtensionSorting&gt;();&#xA;  }&#xA;  private class ExtensionSorting&#xA;  {&#xA;    private static readonly Dictionary&lt;Type, int&gt; _order = new Dictionary&lt;Type, int&gt;&#xA;    {&#xA;      {typeof(MultiCurrency), 4},&#xA;      {typeof(SalesPrice), 3},&#xA;      {typeof(Discount), 2},&#xA;      {typeof(SalesTax), 1},&#xA;    };&#xA;    public ExtensionSorting()&#xA;    {&#xA;      ...&#xA;    }&#xA;  }&#xA;} " ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="47820c73-8e1d-abc1-2f5b-18c412259bfd" RecordSourceID="22377" />
		<row PageID="0ff30b0e-e5a6-4211-ac29-85d996824d9d" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="5e9a577e-038a-edb1-9b16-dae21425db52" RecordSourceID="22377">
			<column name="Content"><![CDATA[
If you need to use the same business logic in multiple modules of your Acumatica ERP application or an Acumatica Framework-based application and this logic is not included in the source code of Acumatica ERP, you can define your own generic graph extensions, as described in this topic. For the list of the predefined generic graph extensions, see [HelpRoot_Dev_Platform\BL__con_Implemented_Generic_Extensions|Generic Graph Extensions Declared in Acumatica ERP].
==To Create a Generic Graph Extension==[anchor|#_8dd8ad90-5da9-470d-b74d-11cfb26d1e27]
#In the code of your application, define the mapped cache extensions, which inherit from the <tt>PXMappedCacheExtension</tt>{{abstract}} class. For details on the mapped cache extensions, see [HelpRoot_Dev_Platform\BL__con_Generic_Extensions#_efcb1dec-e793-4a88-b333-e647c6ff2b5e|Mapped Cache Extension].<source lang="csharp">//Mapped cache extension
public class Document : PXMappedCacheExtension
{
  //BAccountID field
  public abstract class bAccountID : IBqlField
  {
  }
  protected Int32? _BAccountID;

  public virtual Int32? BAccountID
  {
    get
    {
      return _BAccountID;
    }
    set
    {
      _BAccountID = value;
    }
  }

  //CuryID field
  public abstract class curyID : IBqlField
  {
  }
  protected String _CuryID;

  public virtual String CuryID
  {
    get
    {
      return _CuryID;
    }
    set
    {
      _CuryID = value;
    }
  }

  ...
}</source>
#In the code of your application, define the generic graph extension as follows:
##Define a class inherited from the <tt>PXGraphExtension&lt;TGraph&gt;</tt> class. The following code shows a declaration of a generic graph extension. <source lang="csharp">public abstract class MultiCurrencyGraph&lt;TGraph, TPrimary&gt; : 
  PXGraphExtension&lt;TGraph&gt;
    where TGraph : PXGraph
    where TPrimary : class, IBqlTable, new()
{
}</source>
##In the generic graph extension, for each mapped cache extension that you defined in the first step, declare the {{protected}} mapping class, as shown in the following code. For details on the mapping classes, see [HelpRoot_Dev_Platform\BL__con_Generic_Extensions#_07af458f-a094-4b51-8859-a8204ccb196e|Mapping Class].<source lang="csharp">//A mapping class
protected class DocumentMapping : IBqlMapping
{
  public Type Extension =&gt; typeof(Document);
  protected Type _table;
  public Type Table =&gt; _table;

  public DocumentMapping(Type table)
  {
    _table = table;
  }
  public Type BAccountID = typeof(Document.bAccountID);
  public Type CuryInfoID = typeof(Document.curyInfoID);
  public Type CuryID = typeof(Document.curyID);
  public Type DocumentDate = typeof(Document.documentDate);
}</source>
##In the generic graph extension, for each mapping class, declare the {{protected abstract}} method that returns the mapping class, as shown in the following code.<source lang="charp">protected abstract DocumentMapping GetDocumentMapping();</source>
##In the generic graph extension, define the views that use the mapped cache extensions, as the following code shows. To define each view, you use the <tt>PXSelectExtension&lt;Table&gt; : PXSelectBase&lt;Table&gt;</tt> class, where <tt>Table</tt> is a mapped cache extension.<source lang="csharp">//A view that uses the mapped cache extension
public PXSelectExtension&lt;Document&gt; Documents;</source>
##:((({S:Hint}In the generic graph extension, you can define standard views as well as the views that use the mapped cache extensions.
)))
##In the generic graph extension, define the reusable event handlers, as the following code shows.<source lang="csharp">protected virtual void _(
  Events.FieldUpdated2&lt;Document.documentDate, Document&gt; e)
{
  if (e.Row == null) return;
  CurrencyInfoAttribute.SetEffectiveDate&lt;Document.documentDate&gt;(
    Documents.Cache, 
    new PXFieldUpdatedEventArgs(e.Row, e.OldValue, e.ExternalCall));            
}</source>
##In the generic graph extension, implement any other business logic that you want to reuse, such as filters and actions.

Once you have defined the mapped cache extensions and the generic graph extension, you can insert reusable business logic to any part of your application, as described in [HelpRoot_Dev_Platform\BL__how_Insert_Reusable_Business_Logic|To Insert Reusable Business Logic That Has Already Been Declared].]]></column>
			<column name="PlainText"><![CDATA[To Implement Reusable Business Logic If you need to use the same business logic in multiple modules of your  Acumatica ERP application or an  Acumatica Framework-based application and this logic is not included in the source code of  Acumatica ERP, you can define your own generic graph extensions, as described in this topic.                 For the list of the predefined generic graph extensions, see  Generic Graph Extensions Declared in Acumatica ERP. To Create a Generic Graph Extension In the code of your application, define the mapped cache extensions, which                     inherit from the  PXMappedCacheExtension abstract  class. For details on the mapped cache extensions, see                          Mapped Cache Extension. //Mapped cache extension
public class Document : PXMappedCacheExtension
{
  //BAccountID field
  public abstract class bAccountID : IBqlField
  {
  }
  protected Int32? _BAccountID;

  public virtual Int32? BAccountID
  {
    get
    {
      return _BAccountID;
    }
    set
    {
      _BAccountID = value;
    }
  }

  //CuryID field
  public abstract class curyID : IBqlField
  {
  }
  protected String _CuryID;

  public virtual String CuryID
  {
    get
    {
      return _CuryID;
    }
    set
    {
      _CuryID = value;
    }
  }

  ...
} In the code of your application, define the generic graph extension as                         follows: Define a class inherited from the                                  PXGraphExtension<TGraph>  class. The following                             code shows a declaration of a generic graph extension.                              public abstract class MultiCurrencyGraph<TGraph, TPrimary> : 
  PXGraphExtension<TGraph>
    where TGraph : PXGraph
    where TPrimary : class, IBqlTable, new()
{
} In the generic graph extension, for each mapped cache extension that you                             defined in the first step, declare the  protected                              mapping class, as shown in the following code. For details on the                             mapping classes, see  Mapping Class. //A mapping class
protected class DocumentMapping : IBqlMapping
{
  public Type Extension => typeof(Document);
  protected Type _table;
  public Type Table => _table;

  public DocumentMapping(Type table)
  {
    _table = table;
  }
  public Type BAccountID = typeof(Document.bAccountID);
  public Type CuryInfoID = typeof(Document.curyInfoID);
  public Type CuryID = typeof(Document.curyID);
  public Type DocumentDate = typeof(Document.documentDate);
} In the generic graph extension, for each mapping class, declare the                                  protected abstract  method that returns the mapping                             class, as shown in the following                             code. protected abstract DocumentMapping GetDocumentMapping(); In the generic graph extension, define the views that use the mapped                             cache extensions, as the following code shows. To define each view, you                             use the  PXSelectExtension<Table> :                                 PXSelectBase<Table>  class, where                                  Table  is a mapped cache                                 extension. //A view that uses the mapped cache extension
public PXSelectExtension<Document> Documents; In                                 the generic graph extension, you can define standard views as well                                 as the views that use the mapped cache extensions. In the generic graph extension, define the reusable event handlers, as                             the following code                             shows. protected virtual void _(
  Events.FieldUpdated2<Document.documentDate, Document> e)
{
  if (e.Row == null) return;
  CurrencyInfoAttribute.SetEffectiveDate<Document.documentDate>(
    Documents.Cache, 
    new PXFieldUpdatedEventArgs(e.Row, e.OldValue, e.ExternalCall));            
} In the generic graph extension, implement any other business logic that                             you want to reuse, such as filters and actions. Once you have defined the mapped cache extensions and the generic graph extension,                 you can insert reusable business logic to any part of your application, as described                 in  To Insert Reusable Business Logic That Has Already Been Declared. ]]></column>
		</row>
		<row PageID="171000fe-a5ab-4c1f-b61b-7b1f6b0eadcd" Language="en-US" PageRevisionID="1" Content="In this part of the guide, you can find information about troubleshooting the applications based on Acumatica Framework.&#xA;==In This Part==[anchor|#_18673b71-74f1-4b41-9d06-4b2806d1d36e]&#xA;*[HelpRoot_Dev_Platform\TS__how_Debug_Application|To Debug Acumatica Framework-Based Applications]&#xA;" PlainText="Troubleshooting  Acumatica Framework-Based   Applications In this part of the guide, you can find information about troubleshooting the    applications based on  Acumatica Framework. In This Part To Debug Acumatica Framework-Based Applications" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="f4d825da-5060-6818-46b6-1cfac1d00c8a" RecordSourceID="22377" />
		<row PageID="17394b71-06d5-41d4-86ca-e677a148f317" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="c02a22ac-788f-9586-5288-28d39735c5b1" RecordSourceID="22377">
			<column name="Content"><![CDATA[
This topic describes how to link an Acumatica Framework-based application site to the database and start the Acumatica Framework application in debug mode.
==To Debug an Application from Visual Studio==[anchor|#_639abd1c-c1b7-4445-9149-6d74b85ae351]
#In Visual Studio, open the solution of your Acumatica Framework-based application.
#In the <tt>Site</tt> folder of the solution, open the <tt>web.config</tt> file.
#In the {{connectionStrings}} section of the file, modify the connection string by specifying the credentials to your development database as follows:
#*For a locally installed Microsoft SQL Server that uses SQL Server authentication (line breaks are for display purposes only){{{{&lt;connectionStrings&gt;
    &lt;remove name="ProjectX" /&gt;
    &lt;add name="ProjectX" providerName="System.Data.SqlClient" 
        connectionString="Data Source=(local);Initial Catalog=Project_Catalog; 
                          User Id=User_ID; Password=User_Password"
&lt;/connectionStrings&gt;
}}}}
#*For a locally installed Microsoft SQL Server that uses Windows authentication (line breaks are for display purposes only){{{{&lt;connectionStrings&gt;
    &lt;remove name="ProjectX" /&gt;
    &lt;add name="ProjectX" providerName="System.Data.SqlClient" 
        connectionString="Data Source=(local);Initial Catalog=Project_Catalog; 
                          Integrated Security=True"/&gt;
&lt;/connectionStrings&gt;
}}}}
#*For a remote Microsoft SQL Server that uses SQL Server authentication (line breaks are for display purposes only){{{{connectionStrings&gt;
    &lt;remove name="ProjectX" /&gt;
    &lt;add name="ProjectX" providerName="System.Data.SqlClient" 
        connectionString="Data Source=Server_Name; Initial Catalog=Project_Catalog; 
                          User Id=User_ID; Password=User_Password"
&lt;/connectionStrings&gt;
}}}}
#In the {{system.web}} section of the file, set the {{debug}} attribute of the {{compilation}} element to {{True}}, as shown in the following example.{{{{&lt;compilation debug="True" defaultLanguage="c#" 
    numRecompilesBeforeAppRestart="9999" targetFramework="4.7.1"&gt;
}}}}
#In Visual Studio, right-click the <tt>Site</tt> folder of the solution, and click '''Set as StartUp Project'''. 
#Right-click the <tt>Main.aspx</tt> file in the <tt>Site</tt> folder, and click '''Set as Start Page'''.
#Optional: If you need to debug a server error that throws an exception, do the following:
##On the toolbar, click '''Debug''' > '''Windows''' > '''Exception Settings'''.
##In the '''Exception Settings''' panel, which opens, expand '''Common Language Runtime Exceptions''', and select the check box for the exception that is thrown (such as '''System.ArgumentOutOfRangeException'''). 
#Run the solution in the Debug mode.
]]></column>
			<column name="PlainText"><![CDATA[To Debug  Acumatica Framework-Based Applications This topic describes how to link an  Acumatica Framework-based application site to the database and start the  Acumatica Framework application in debug mode. To Debug an Application from Visual Studio In Visual Studio, open the solution of your  Acumatica Framework-based application. In the  Site  folder of the solution, open the                          web.config  file. In the  connectionStrings  section of the file, modify the                     connection string by specifying the credentials to your development database as                         follows: For a locally installed Microsoft SQL Server that uses SQL Server                             authentication (line breaks are for display purposes                             only) <connectionStrings>
    <remove name="ProjectX" />
    <add name="ProjectX" providerName="System.Data.SqlClient" 
        connectionString="Data Source=(local);Initial Catalog=Project_Catalog; 
                          User Id=User_ID; Password=User_Password"
</connectionStrings> For a locally installed Microsoft SQL Server that uses Windows                             authentication (line breaks are for display purposes                             only) <connectionStrings>
    <remove name="ProjectX" />
    <add name="ProjectX" providerName="System.Data.SqlClient" 
        connectionString="Data Source=(local);Initial Catalog=Project_Catalog; 
                          Integrated Security=True"/>
</connectionStrings> For a remote Microsoft SQL Server that uses SQL Server authentication                             (line breaks are for display purposes                             only) connectionStrings>
    <remove name="ProjectX" />
    <add name="ProjectX" providerName="System.Data.SqlClient" 
        connectionString="Data Source=Server_Name; Initial Catalog=Project_Catalog; 
                          User Id=User_ID; Password=User_Password"
</connectionStrings> In the  system.web  section of the file, set the                          debug  attribute of the  compilation  element                     to  True , as shown in the following                     example. <compilation debug="True" defaultLanguage="c#" 
    numRecompilesBeforeAppRestart="9999" targetFramework="4.7.1"> In Visual Studio, right-click the  Site  folder of the                     solution, and click  Set as StartUp Project .  Right-click the  Main.aspx  file in the                          Site  folder, and click  Set as Start                         Page . Optional: If you need to debug a server error that throws an exception, do the                         following: On the toolbar, click  Debug Windows Exception Settings . In the  Exception Settings  panel, which opens,                             expand  Common Language Runtime Exceptions , and                             select the check box for the exception that is thrown (such as                                  System.ArgumentOutOfRangeException ).  Run the solution in the Debug mode. ]]></column>
		</row>
		<row PageID="f9e20abb-20c0-4df7-b959-7c7307533849" Language="en-US" PageRevisionID="1" ApprovalByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" ApprovalDateTime="1970-01-23 00:00:00" CreatedByID="b5344897-037e-4d58-b5c3-1bdfd0f47bf9" CreatedDateTime="1970-01-23 00:00:00" UID="30bbaa28-b93d-bc93-8490-05e8260fcb40" RecordSourceID="22377">
			<column name="Content"><![CDATA[
The following table contains definitions of the basic terms used in Acumatica Framework.[anchor|#table_kxq_lr2_gk]
{| class="checklist" | width="100%" 
|- 
| '''Term'''
|  '''Definition'''
|- 
|  '''Action'''
| An interface for executing a specific operation with data that is implemented in a business logic controller (BLC). An action is represented by the corresponding button on the user interface.
|- 
| ''' Acumatica Cloud xRP Platform'''
| The platform for the development of cloud ERP applications (such as Acumatica ERP and customizations of it), the mobile application for Acumatica ERP, and applications integrated with Acumatica ERP by means of the web services API.
|- 
| ''' Acumatica Customization           Platform'''
| The part of the Acumatica Cloud xRP Platform that provides customization tools for the development of applications embedded in Acumatica ERP (also called customizations of Acumatica ERP).
|- 
| ''' Acumatica Framework'''
| The part of the Acumatica Cloud xRP Platform that provides the platform API, web controls, and other tools for building ERP applications.
|- 
| ''' Acumatica Framework                         Templates'''
| A set of Visual Studio templates provided as a part of Acumatica Framework for creating application pages and business logic controllers.
|- 
| ''' Acumatica Framework-based application'''
| An application created by means of Acumatica Framework tools.
|- 
| '''Analytical report'''
| A report created with the Analytical Report Manager. For details on this tool, see [HelpRoot_ReportingTools\CS__ARM_Analytical_Report_Parameters|Analytical Report Manager].
|- 
| '''Bound field'''
| A data field that represents a column from a database table. Compare to '''Unbound field'''.
|- 
| '''BQL statement'''
| A generic BQL class specialization that represents a specific query to the database. The type parameters specified in the BQL statement are BQL operator classes and DACs.
|- 
| '''Business logic controller''' ('''BLC''')
| A stateless controller class that is intended for the execution of business logic on a particular application page. A BLC (also called a ''graph'') is derived from the <tt>PXGraph</tt> generic class.
|- 
| '''Business query language''' ('''BQL''')
| A set of generic classes for querying data records from the database.
|- 
| '''Cache'''
| A collection of modified data records from the same table stored in the user session and shared between requests.
|- 
| '''Custom report'''
| A report created on the custom report form.
|- 
| '''Customization of Acumatica ERP'''
| A modification of the user interface, business logic, and the database scheme without recompilation and re-installation of Acumatica ERP. This modification is packed in a customization project.
|- 
| '''Customization project'''
| A container that holds the changes you have made during a particular customization of Acumatica ERP.
|- 
| '''DAC field'''
| See '''Field'''.
|- 
| '''Data access class''' ('''DAC''')
| A class that represents a database table.
|- 
| '''Data entry form'''
| An application webpage that is used for the input of business documents.
|- 
| '''Data member'''
| A data view specified as the data source for a container of UI controls (a form, a tab, or a grid).
|- 
| '''Data record'''
| A specific record retrieved from the database or created in code and wrapped in a DAC instance.
|- 
| '''Data view'''
| A BQL statement that the BLC uses to access and manipulate data. A developer defines a data view in code by using [HelpRoot_Dev_Platform\AD__con_BQL_PXSelect|<tt>PXSelect</tt>] classes.
|- 
| '''Datasource control'''
| A service control on a page that is used to bind the page to a particular BLC. This control represents the page toolbar, which contains action buttons.
|- 
| '''Embedded application'''
| See '''Customization of Acumatica ERP'''.
|- 
| '''Event'''
| A way to provide notifications from Acumatica Framework to the application. Most business logic is implemented in event handlers.
|- 
| '''Event handler'''
| A method that is invoked by Acumatica Framework when the corresponding event is raised.
|- 
| '''Field (DAC field)'''
| A part of the DAC definition that typically represents a database column. A DAC field consists of an abstract class that is used to refer to the field in BQL and a property holding the actual field value.
|- 
| '''Form'''
| See '''Webpage'''.
|- 
| '''Graph'''
| See '''Business logic controller'''.
|- 
| '''Inquiry form'''
| An application webpage that displays a list of data records selected by the specified filter.
|- 
| '''Integrated application'''
| A third-party application integrated with Acumatica ERP by means of web services API.
|- 
| '''Maintenance form'''
| An application helper webpage that is used for the input of data on the data entry and processing pages.
|- 
| 
'''Mobile API'''
| The API that is used for customization of the Acumatica mobile application. For a description of the API, see [HelpRoot_Dev_Mobile\MOBILE_Reference|Mobile Site Map Reference].
|- 
| '''Multitenant application'''
| An application in which multiple tenants use the same Acumatica Framework-based application. For each tenant, the website looks identical and provides the same business logic. However, each tenant has exclusive access to the tenant&rsquo;s individual data and can have restricted access to the data of other tenants.
|- 
| '''Page template'''
| A Visual Studio template that is provided by Acumatica Framework and used for creating application pages.
|- 
| '''Platform API'''
| The API that is used to develop Acumatica Framework-based applications and customizations of Acumatica ERP.
|- 
| '''Primary BLC'''
| The BLC that corresponds to the default editing page of the data record. This BLC is specified in the [https://help.acumatica.com/(W(15))/Main?ScreenId=ShowWiki&pageid=1dceb511-4e98-3700-7d7f-231688a7ac74|<tt>PXPrimaryGraph</tt>] attribute.
|- 
| '''Primary DAC'''
| The first data access class specified in a BQL statement.
|- 
| '''Primary data view'''
| The first data view defined in a business logic controller.
|- 
| '''Processing form'''
| An application webpage that provides mass processing operations.
|- 
| ''' Report Designer'''
| A visual editor for creating report forms and printable pages.
|- 
| '''Report form'''
| An RPX page created in Report Designer that defines the form used for generating reports in the application.
|- 
| '''Screen'''
| See '''Webpage'''.
|- 
| '''Setup form'''
| An application webpage that provides the configuration parameters for the application.
|- 
| '''Unbound field'''
| A data field that exists only on the model level in a DAC definition, and that is not bound to a column of the database table. Compare to '''Bound field'''.
|- 
| '''Webpage'''
| A page that provides the UI of the application. Each webpage used in the application is a declarative ASPX page created from one of the Acumatica Framework                         Templates or a report form.
|- 
| '''Web services API'''
| The API for development of applications integrated with Acumatica ERP through SOAP or REST.
|}]]></column>
			<column name="PlainText"><![CDATA[Glossary The following table contains definitions of the basic terms used in  Acumatica Framework. Term Definition Action An interface for executing a specific operation with data that is implemented in               a business logic controller (BLC). An action is represented by the corresponding               button on the user interface.  Acumatica Cloud xRP PlatformThe platform for the development of cloud ERP applications (such as  Acumatica ERP and customizations of it), the mobile application for  Acumatica ERP, and applications integrated with  Acumatica ERP by means of the web services API.  Acumatica Customization           PlatformThe part of the  Acumatica Cloud xRP Platform that provides customization tools for the development of applications embedded in                  Acumatica ERP (also called customizations of  Acumatica ERP).  Acumatica FrameworkThe part of the  Acumatica Cloud xRP Platform that provides the platform API, web controls, and other tools for building ERP               applications.  Acumatica Framework                         TemplatesA set of Visual Studio templates provided as a part of  Acumatica Framework for creating application pages and business logic controllers.  Acumatica Framework-based application An application created by means of  Acumatica Framework tools. Analytical report A report created with the Analytical Report Manager. For details on this tool,               see  Analytical Report Manager. Bound field A data field that represents a column from a database table. Compare to                  Unbound field . BQL statement A generic BQL class specialization that represents a specific query to the               database. The type parameters specified in the BQL statement are BQL operator classes               and DACs. Business logic controller  ( BLC ) A stateless controller class that is intended for the execution of business logic               on a particular application page. A BLC (also called a  graph ) is derived from               the  PXGraph  generic class. Business query language  ( BQL ) A set of generic classes for querying data records from the database. Cache A collection of modified data records from the same table stored in the user               session and shared between requests. Custom report A report created on the custom report form. Customization of  Acumatica ERPA modification of the user interface, business logic, and the database scheme               without recompilation and re-installation of  Acumatica ERP. This modification is packed in a customization project. Customization project A container that holds the changes you have made during a particular               customization of  Acumatica ERP. DAC field See  Field . Data access class  ( DAC ) A class that represents a database table. Data entry form An application webpage that is used for the input of business documents. Data member A data view specified as the data source for a container of UI controls (a form,               a tab, or a grid). Data record A specific record retrieved from the database or created in code and wrapped in a               DAC instance. Data view A BQL statement that the BLC uses to access and manipulate data. A developer               defines a data view in code by using  PXSelect <tt>PXSelect</tt> classes. Datasource control A service control on a page that is used to bind the page to a particular BLC.               This control represents the page toolbar, which contains action buttons. Embedded application See  Customization of  Acumatica ERP. Event A way to provide notifications from  Acumatica Framework to the application. Most business logic is implemented in event handlers. Event handler A method that is invoked by  Acumatica Framework when the corresponding event is raised. Field (DAC field) A part of the DAC definition that typically represents a database column. A DAC               field consists of an abstract class that is used to refer to the field in BQL and a               property holding the actual field value. Form See  Webpage . Graph See  Business logic controller . Inquiry form An application webpage that displays a list of data records selected by the               specified filter. Integrated application A third-party application integrated with  Acumatica ERP by means of web services API. Maintenance form An application helper webpage that is used for the input of data on the data               entry and processing pages. Mobile API The API that is used for customization of the  Acumatica mobile application. For a description of the API, see  Mobile Site Map Reference. Multitenant application An application in which multiple tenants use the same  Acumatica Framework-based application. For each tenant, the website looks identical and provides the               same business logic. However, each tenant has exclusive access to the tenant's               individual data and can have restricted access to the data of other tenants. Page template A Visual Studio template that is provided by  Acumatica Framework and used for creating application pages. Platform API The API that is used to develop  Acumatica Framework-based applications and customizations of  Acumatica ERP. Primary BLC The BLC that corresponds to the default editing page of the data record. This BLC               is specified in the  PXPrimaryGraph <tt>PXPrimaryGraph</tt>               attribute. Primary DAC The first data access class specified in a BQL statement. Primary data view The first data view defined in a business logic controller. Processing form An application webpage that provides mass processing operations.  Report DesignerA visual editor for creating report forms and printable pages. Report form An RPX page created in  Report Designer that defines the form used for generating reports in the application. Screen See  Webpage . Setup form An application webpage that provides the configuration parameters for the               application. Unbound field A data field that exists only on the model level in a DAC definition, and that is               not bound to a column of the database table. Compare to  Bound field . Webpage A page that provides the UI of the application. Each webpage used in the               application is a declarative ASPX page created from one of the  Acumatica Framework                         Templates or a report form. Web services API The API for development of applications integrated with  Acumatica ERP through SOAP or REST. ]]></column>
		</row>
	</rows>
</data>